(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){

},{}],2:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ndarray_1 = require("../math/ndarray");
var MANIFEST_FILE = 'manifest.json';
var CheckpointLoader = (function () {
    function CheckpointLoader(urlPath) {
        this.urlPath = urlPath;
        if (this.urlPath.charAt(this.urlPath.length - 1) !== '/') {
            this.urlPath += '/';
        }
    }
    CheckpointLoader.prototype.loadManifest = function () {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var xhr = new XMLHttpRequest();
            xhr.open('GET', _this.urlPath + MANIFEST_FILE);
            xhr.onload = function () {
                _this.checkpointManifest = JSON.parse(xhr.responseText);
                resolve();
            };
            xhr.onerror = function (error) {
                throw new Error(MANIFEST_FILE + " not found at " + _this.urlPath + ". " + error);
            };
            xhr.send();
        });
    };
    CheckpointLoader.prototype.getCheckpointManifest = function () {
        var _this = this;
        if (this.checkpointManifest == null) {
            return new Promise(function (resolve, reject) {
                _this.loadManifest().then(function () {
                    resolve(_this.checkpointManifest);
                });
            });
        }
        return new Promise(function (resolve, reject) {
            resolve(_this.checkpointManifest);
        });
    };
    CheckpointLoader.prototype.getAllVariables = function () {
        var _this = this;
        if (this.variables != null) {
            return new Promise(function (resolve, reject) {
                resolve(_this.variables);
            });
        }
        return new Promise(function (resolve, reject) {
            _this.getCheckpointManifest().then(function (checkpointDefinition) {
                var variableNames = Object.keys(_this.checkpointManifest);
                var variablePromises = [];
                for (var i = 0; i < variableNames.length; i++) {
                    variablePromises.push(_this.getVariable(variableNames[i]));
                }
                Promise.all(variablePromises).then(function (variables) {
                    _this.variables = {};
                    for (var i = 0; i < variables.length; i++) {
                        _this.variables[variableNames[i]] = variables[i];
                    }
                    resolve(_this.variables);
                });
            });
        });
    };
    CheckpointLoader.prototype.getVariable = function (varName) {
        var _this = this;
        if (!(varName in this.checkpointManifest)) {
            throw new Error('Cannot load non-existant variable ' + varName);
        }
        var variableRequestPromiseMethod = function (resolve, reject) {
            var xhr = new XMLHttpRequest();
            xhr.responseType = 'arraybuffer';
            var fname = _this.checkpointManifest[varName].filename;
            xhr.open('GET', _this.urlPath + fname);
            xhr.onload = function () {
                var values = new Float32Array(xhr.response);
                var ndarray = ndarray_1.NDArray.make(_this.checkpointManifest[varName].shape, { values: values });
                resolve(ndarray);
            };
            xhr.onerror = function (error) {
                throw new Error("Could not fetch variable " + varName + ": " + error);
            };
            xhr.send();
        };
        if (this.checkpointManifest == null) {
            return new Promise(function (resolve, reject) {
                _this.loadManifest().then(function () {
                    new Promise(variableRequestPromiseMethod).then(resolve);
                });
            });
        }
        return new Promise(variableRequestPromiseMethod);
    };
    return CheckpointLoader;
}());
exports.CheckpointLoader = CheckpointLoader;

},{"../math/ndarray":55}],3:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ndarray_1 = require("../math/ndarray");
var util = require("../util");
var STATS_SAMPLE_PERCENTAGE = 0.1;
var InMemoryDataset = (function () {
    function InMemoryDataset(dataShapes) {
        this.dataShapes = dataShapes;
        this.normalizationInfo = {};
    }
    InMemoryDataset.prototype.getDataShape = function (dataIndex) {
        return this.dataShapes[dataIndex];
    };
    InMemoryDataset.prototype.getData = function () {
        return this.dataset;
    };
    InMemoryDataset.prototype.getStats = function () {
        var _this = this;
        if (this.dataset == null) {
            throw new Error('Data is null.');
        }
        return this.dataset.map(function (d) { return _this.getStatsForData(d); });
    };
    InMemoryDataset.prototype.getStatsForData = function (data) {
        var inputMin = Number.POSITIVE_INFINITY;
        var inputMax = Number.NEGATIVE_INFINITY;
        var exampleIndices = data.map(function (example, i) { return i; });
        util.shuffle(exampleIndices);
        exampleIndices =
            exampleIndices.slice(exampleIndices.length * STATS_SAMPLE_PERCENTAGE);
        for (var i = 0; i < exampleIndices.length; i++) {
            var inputValues = data[exampleIndices[i]].getValues();
            for (var j = 0; j < inputValues.length; j++) {
                inputMin = Math.min(inputMin, inputValues[j]);
                inputMax = Math.max(inputMax, inputValues[j]);
            }
        }
        return {
            inputMin: inputMin,
            inputMax: inputMax,
            exampleCount: data.length,
            shape: data[0].shape,
        };
    };
    InMemoryDataset.prototype.normalizeExamplesToRange = function (examples, curLowerBounds, curUpperBounds, newLowerBounds, newUpperBounds) {
        var curBoundsIsPerDimension = (curUpperBounds instanceof Float32Array &&
            curLowerBounds instanceof Float32Array);
        var newBoundsIsPerDimension = (newLowerBounds instanceof Float32Array &&
            newUpperBounds instanceof Float32Array);
        var inputSize = util.sizeFromShape(examples[0].shape);
        var newExamples = [];
        examples.forEach(function (example) {
            var inputValues = example.getValues();
            var normalizedValues = new Float32Array(inputSize);
            for (var j = 0; j < inputSize; j++) {
                var curLowerBound = curBoundsIsPerDimension ?
                    curLowerBounds[j] :
                    curLowerBounds;
                var curUpperBound = curBoundsIsPerDimension ?
                    curUpperBounds[j] :
                    curUpperBounds;
                var curRange = curUpperBound - curLowerBound;
                var newLowerBound = newBoundsIsPerDimension ?
                    newLowerBounds[j] :
                    newLowerBounds;
                var newUpperBound = newBoundsIsPerDimension ?
                    newUpperBounds[j] :
                    newUpperBounds;
                var newRange = newUpperBound - newLowerBound;
                if (curRange === 0) {
                    normalizedValues[j] = newLowerBound;
                }
                else {
                    normalizedValues[j] = newLowerBound +
                        newRange * (inputValues[j] - curLowerBound) / curRange;
                }
            }
            newExamples.push(ndarray_1.NDArray.make(example.shape, { values: normalizedValues }));
        });
        return newExamples;
    };
    InMemoryDataset.prototype.computeBounds = function (dataIndex) {
        var _this = this;
        if (this.dataset == null) {
            throw new Error('Data is null.');
        }
        var size = util.sizeFromShape(this.dataset[dataIndex][0].shape);
        this.normalizationInfo[dataIndex] = {
            isNormalized: false,
            minValues: new Float32Array(size),
            maxValues: new Float32Array(size)
        };
        for (var i = 0; i < size; i++) {
            this.normalizationInfo[dataIndex].minValues[i] = Number.POSITIVE_INFINITY;
            this.normalizationInfo[dataIndex].maxValues[i] = Number.NEGATIVE_INFINITY;
        }
        this.dataset[dataIndex].forEach(function (example) {
            var inputValues = example.getValues();
            for (var k = 0; k < size; k++) {
                _this.normalizationInfo[dataIndex].minValues[k] = Math.min(_this.normalizationInfo[dataIndex].minValues[k], inputValues[k]);
                _this.normalizationInfo[dataIndex].maxValues[k] = Math.max(_this.normalizationInfo[dataIndex].maxValues[k], inputValues[k]);
            }
        });
    };
    InMemoryDataset.prototype.normalizeWithinBounds = function (dataIndex, lowerBound, upperBound) {
        if (this.dataset == null) {
            throw new Error('Data is null.');
        }
        if (dataIndex >= this.dataset.length) {
            throw new Error('dataIndex out of bounds.');
        }
        if (this.normalizationInfo[dataIndex] == null) {
            this.computeBounds(dataIndex);
        }
        var curLowerBounds;
        var curUpperBounds;
        if (this.normalizationInfo[dataIndex].isNormalized) {
            curLowerBounds = this.normalizationInfo[dataIndex].lowerBound;
            curUpperBounds = this.normalizationInfo[dataIndex].upperBound;
        }
        else {
            curLowerBounds = this.normalizationInfo[dataIndex].minValues;
            curUpperBounds = this.normalizationInfo[dataIndex].maxValues;
        }
        this.dataset[dataIndex] = this.normalizeExamplesToRange(this.dataset[dataIndex], curLowerBounds, curUpperBounds, lowerBound, upperBound);
        this.normalizationInfo[dataIndex].isNormalized = true;
        this.normalizationInfo[dataIndex].lowerBound = lowerBound;
        this.normalizationInfo[dataIndex].upperBound = upperBound;
    };
    InMemoryDataset.prototype.isNormalized = function (dataIndex) {
        return this.normalizationInfo != null &&
            this.normalizationInfo[dataIndex].isNormalized;
    };
    InMemoryDataset.prototype.removeNormalization = function (dataIndex) {
        if (this.dataset == null) {
            throw new Error('Training or test data is null.');
        }
        if (!this.isNormalized(dataIndex)) {
            return;
        }
        this.dataset[dataIndex] = this.normalizeExamplesToRange(this.dataset[dataIndex], this.normalizationInfo[dataIndex].lowerBound, this.normalizationInfo[dataIndex].upperBound, this.normalizationInfo[dataIndex].minValues, this.normalizationInfo[dataIndex].maxValues);
        this.normalizationInfo[dataIndex].isNormalized = false;
    };
    InMemoryDataset.prototype.unnormalizeExamples = function (examples, dataIndex) {
        if (!this.isNormalized(dataIndex)) {
            return examples;
        }
        return this.normalizeExamplesToRange(examples, this.normalizationInfo[dataIndex].lowerBound, this.normalizationInfo[dataIndex].upperBound, this.normalizationInfo[dataIndex].minValues, this.normalizationInfo[dataIndex].maxValues);
    };
    InMemoryDataset.prototype.dispose = function () {
        if (this.dataset == null) {
            return;
        }
        for (var i = 0; i < this.dataset.length; i++) {
            for (var j = 0; j < this.dataset[i].length; j++) {
                this.dataset[i][j].dispose();
            }
        }
        this.dataset = [];
    };
    return InMemoryDataset;
}());
exports.InMemoryDataset = InMemoryDataset;

},{"../math/ndarray":55,"../util":88}],4:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ndarray_1 = require("../math/ndarray");
var util = require("../util");
var InMemoryShuffledInputProviderBuilder = (function () {
    function InMemoryShuffledInputProviderBuilder(inputs) {
        this.inputs = inputs;
        this.idx = 0;
        this.inputCounter = 0;
        this.epoch = 0;
        this.shuffledIndices = util.createShuffledIndices(inputs[0].length);
        this.numInputs = inputs.length;
        var numExamples = this.inputs[0].length;
        for (var i = 0; i < this.numInputs; i++) {
            util.assert(this.inputs[i].length === numExamples, 'Number of examples must match across different inputs.');
        }
        for (var i = 0; i < this.numInputs; i++) {
            var inputShape = this.inputs[i][0].shape;
            for (var j = 0; j < this.inputs[i].length; j++) {
                util.assertShapesMatch(inputShape, this.inputs[i][j].shape);
            }
        }
    }
    InMemoryShuffledInputProviderBuilder.prototype.getCurrentExampleIndex = function () {
        var returnIdx = this.idx;
        this.inputCounter++;
        if (this.inputCounter >= this.numInputs) {
            this.idx++;
            this.inputCounter = 0;
            if (this.idx >= this.inputs[0].length) {
                this.idx = 0;
                this.epoch++;
            }
        }
        return returnIdx;
    };
    InMemoryShuffledInputProviderBuilder.prototype.getNextInput = function (inputId) {
        var currentExampleIndex = this.getCurrentExampleIndex();
        return this.inputs[inputId][this.shuffledIndices[currentExampleIndex]];
    };
    InMemoryShuffledInputProviderBuilder.prototype.getEpoch = function () {
        return this.epoch;
    };
    InMemoryShuffledInputProviderBuilder.prototype.getInputProviders = function () {
        var inputProviders = [];
        for (var i = 0; i < this.numInputs; i++) {
            inputProviders.push(this.getInputProvider(i));
        }
        return inputProviders;
    };
    return InMemoryShuffledInputProviderBuilder;
}());
exports.InMemoryShuffledInputProviderBuilder = InMemoryShuffledInputProviderBuilder;
var InCPUMemoryShuffledInputProviderBuilder = (function (_super) {
    __extends(InCPUMemoryShuffledInputProviderBuilder, _super);
    function InCPUMemoryShuffledInputProviderBuilder() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    InCPUMemoryShuffledInputProviderBuilder.prototype.getInputProvider = function (inputId) {
        var shuffledInputProvider = this;
        return {
            getNextCopy: function (math) {
                return ndarray_1.NDArray.like(shuffledInputProvider.getNextInput(inputId));
            },
            disposeCopy: function (math, copy) {
                copy.dispose();
            }
        };
    };
    return InCPUMemoryShuffledInputProviderBuilder;
}(InMemoryShuffledInputProviderBuilder));
exports.InCPUMemoryShuffledInputProviderBuilder = InCPUMemoryShuffledInputProviderBuilder;
var InGPUMemoryShuffledInputProviderBuilder = (function (_super) {
    __extends(InGPUMemoryShuffledInputProviderBuilder, _super);
    function InGPUMemoryShuffledInputProviderBuilder() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    InGPUMemoryShuffledInputProviderBuilder.prototype.getInputProvider = function (inputId) {
        var shuffledInputProvider = this;
        return {
            getNextCopy: function (math) {
                return math.clone(shuffledInputProvider.getNextInput(inputId));
            },
            disposeCopy: function (math, copy) {
                copy.dispose();
            }
        };
    };
    return InGPUMemoryShuffledInputProviderBuilder;
}(InMemoryShuffledInputProviderBuilder));
exports.InGPUMemoryShuffledInputProviderBuilder = InGPUMemoryShuffledInputProviderBuilder;

},{"../math/ndarray":55,"../util":88}],5:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ndarray_1 = require("../math/ndarray");
var util = require("../util");
var dataset_1 = require("./dataset");
var PARSING_IMAGE_CANVAS_HEIGHT_PX = 1000;
function getXhrDatasetConfig(jsonConfigPath) {
    return new Promise(function (resolve, reject) {
        var xhr = new XMLHttpRequest();
        xhr.open('GET', jsonConfigPath);
        xhr.onload = function () {
            resolve(JSON.parse(xhr.responseText));
        };
        xhr.onerror = function (error) {
            reject(error);
        };
        xhr.send();
    });
}
exports.getXhrDatasetConfig = getXhrDatasetConfig;
var XhrDataset = (function (_super) {
    __extends(XhrDataset, _super);
    function XhrDataset(xhrDatasetConfig) {
        var _this = _super.call(this, xhrDatasetConfig.data.map(function (x) { return x.shape; })) || this;
        _this.xhrDatasetConfig = xhrDatasetConfig;
        return _this;
    }
    XhrDataset.prototype.getNDArray = function (info) {
        var dataPromise = info.dataType === 'png' ?
            parseTypedArrayFromPng(info, info.shape) :
            parseTypedArrayFromBinary(info);
        return dataPromise.then(function (data) {
            var inputSize = util.sizeFromShape(info.shape);
            var ndarrays = [];
            for (var i = 0; i < data.length / inputSize; i++) {
                var values = data.subarray(i * inputSize, (i + 1) * inputSize);
                var ndarray = ndarray_1.NDArray.make(info.shape, { values: new Float32Array(values) });
                ndarrays.push(ndarray);
            }
            return ndarrays;
        });
    };
    XhrDataset.prototype.fetchData = function () {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var promises = _this.xhrDatasetConfig.data.map(function (x) { return _this.getNDArray(x); });
            Promise.all(promises).then(function (data) {
                _this.dataset = data;
                resolve();
            });
        });
    };
    return XhrDataset;
}(dataset_1.InMemoryDataset));
exports.XhrDataset = XhrDataset;
function parseTypedArrayFromBinary(info) {
    return new Promise(function (resolve, reject) {
        var xhr = new XMLHttpRequest();
        xhr.open('GET', info.path);
        xhr.responseType = 'arraybuffer';
        xhr.onload = function (event) {
            var data = (info.dataType === 'float32') ?
                new Float32Array(xhr.response) :
                new Uint8Array(xhr.response);
            resolve(data);
        };
        xhr.onerror = function (err) { return reject(err); };
        xhr.send();
    });
}
function parseGrayscaleImageData(data, result, resultOffset) {
    var idx = resultOffset;
    for (var i = 0; i < data.length; i += 4) {
        result[idx++] = data[i];
    }
}
function parseRGBImageData(data, result, resultOffset) {
    var idx = resultOffset;
    for (var i = 0; i < data.length; i += 4) {
        result[idx] = data[i];
        result[idx + 1] = data[i + 1];
        result[idx + 2] = data[i + 2];
        idx += 3;
    }
}
function parseImage(img, shape) {
    var canvas = document.createElement('canvas');
    var ctx = canvas.getContext('2d');
    var N = img.height;
    var inputSize = util.sizeFromShape(shape);
    var result = new Uint8Array(N * inputSize);
    if (img.width !== shape[0] * shape[1]) {
        throw new Error("Image width (" + img.width + ") must be multiple of " +
            ("rows*columns (" + shape[0] + "*" + shape[1] + ") of the ndarray"));
    }
    canvas.width = img.width;
    canvas.height = PARSING_IMAGE_CANVAS_HEIGHT_PX;
    var sx = 0;
    var sWidth = canvas.width;
    var sHeight = canvas.height;
    var dx = 0;
    var dy = 0;
    var dWidth = sWidth;
    var dHeight = sHeight;
    var depth = shape[2];
    var offset = 0;
    var numPasses = Math.ceil(N / canvas.height);
    for (var pass = 0; pass < numPasses; ++pass) {
        var sy = pass * canvas.height;
        if ((pass === numPasses - 1) && (N % canvas.height > 0)) {
            canvas.height = N % canvas.height;
            sHeight = canvas.height;
            dHeight = sHeight;
        }
        ctx.drawImage(img, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight);
        var data = ctx.getImageData(0, 0, canvas.width, canvas.height).data;
        (depth === 1) ? parseGrayscaleImageData(data, result, offset) :
            parseRGBImageData(data, result, offset);
        offset += canvas.height * inputSize;
    }
    return result;
}
function parseTypedArrayFromPng(info, shape) {
    return new Promise(function (resolve, reject) {
        var img = new Image();
        img.setAttribute('crossOrigin', '');
        img.onload = function () {
            var result = parseImage(img, shape);
            img.src = '';
            img = null;
            resolve(result);
        };
        img.src = info.path;
    });
}

},{"../math/ndarray":55,"../util":88,"./dataset":3}],6:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function isMobile() {
    var a = navigator.userAgent || navigator.vendor || window.opera;
    return /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i
        .test(a) ||
        /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i
            .test(a.substr(0, 4));
}
exports.isMobile = isMobile;

},{}],7:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var device_util = require("./device_util");
var util = require("./util");
var Type;
(function (Type) {
    Type[Type["NUMBER"] = 0] = "NUMBER";
    Type[Type["BOOLEAN"] = 1] = "BOOLEAN";
})(Type = exports.Type || (exports.Type = {}));
exports.URL_PROPERTIES = [
    { name: 'WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_ENABLED', type: Type.BOOLEAN },
    { name: 'WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE', type: Type.BOOLEAN },
    { name: 'WEBGL_VERSION', type: Type.NUMBER },
    { name: 'WEBGL_FLOAT_TEXTURE_ENABLED', type: Type.BOOLEAN }, {
        name: 'WEBGL_GET_BUFFER_SUB_DATA_ASYNC_EXTENSION_ENABLED',
        type: Type.BOOLEAN
    }
];
function getWebGLRenderingContext(webGLVersion) {
    if (webGLVersion === 0) {
        throw new Error('Cannot get WebGL rendering context, WebGL is disabled.');
    }
    var tempCanvas = document.createElement('canvas');
    if (webGLVersion === 1) {
        return (tempCanvas.getContext('webgl') ||
            tempCanvas.getContext('experimental-webgl'));
    }
    return tempCanvas.getContext('webgl2');
}
function loseContext(gl) {
    if (gl != null) {
        var loseContextExtension = gl.getExtension('WEBGL_lose_context');
        if (loseContextExtension == null) {
            throw new Error('Extension WEBGL_lose_context not supported on this browser.');
        }
        loseContextExtension.loseContext();
    }
}
function isWebGLVersionEnabled(webGLVersion) {
    var gl = getWebGLRenderingContext(webGLVersion);
    if (gl != null) {
        loseContext(gl);
        return true;
    }
    return false;
}
function isWebGLDisjointQueryTimerEnabled(webGLVersion) {
    var gl = getWebGLRenderingContext(webGLVersion);
    var extensionName = webGLVersion === 1 ? 'EXT_disjoint_timer_query' :
        'EXT_disjoint_timer_query_webgl2';
    var ext = gl.getExtension(extensionName);
    var isExtEnabled = ext != null;
    if (gl != null) {
        loseContext(gl);
    }
    return isExtEnabled;
}
function isFloatTextureReadPixelsEnabled(webGLVersion) {
    if (webGLVersion === 0) {
        return false;
    }
    var gl = getWebGLRenderingContext(webGLVersion);
    if (webGLVersion === 1) {
        if (gl.getExtension('OES_texture_float') == null) {
            return false;
        }
    }
    else {
        if (gl.getExtension('EXT_color_buffer_float') == null) {
            return false;
        }
    }
    var frameBuffer = gl.createFramebuffer();
    var texture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, texture);
    var internalFormat = webGLVersion === 2 ? gl.RGBA32F : gl.RGBA;
    gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, 1, 1, 0, gl.RGBA, gl.FLOAT, null);
    gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
    var frameBufferComplete = (gl.checkFramebufferStatus(gl.FRAMEBUFFER) === gl.FRAMEBUFFER_COMPLETE);
    gl.readPixels(0, 0, 1, 1, gl.RGBA, gl.FLOAT, new Float32Array(4));
    var readPixelsNoError = gl.getError() === gl.NO_ERROR;
    loseContext(gl);
    return frameBufferComplete && readPixelsNoError;
}
function isWebGLGetBufferSubDataAsyncExtensionEnabled(webGLVersion) {
    if (webGLVersion !== 2) {
        return false;
    }
    var gl = getWebGLRenderingContext(webGLVersion);
    var ext = gl.getExtension('WEBGL_get_buffer_sub_data_async');
    var isEnabled = ext != null;
    loseContext(gl);
    return isEnabled;
}
var Environment = (function () {
    function Environment(features) {
        this.features = {};
        if (features != null) {
            this.features = features;
        }
    }
    Environment.prototype.get = function (feature) {
        if (feature in this.features) {
            return this.features[feature];
        }
        this.features[feature] = this.evaluateFeature(feature);
        return this.features[feature];
    };
    Environment.prototype.evaluateFeature = function (feature) {
        if (feature === 'WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_ENABLED') {
            var webGLVersion = this.get('WEBGL_VERSION');
            if (webGLVersion === 0) {
                return false;
            }
            return isWebGLDisjointQueryTimerEnabled(webGLVersion);
        }
        else if (feature === 'WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE') {
            return this.get('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_ENABLED') &&
                !device_util.isMobile();
        }
        else if (feature === 'WEBGL_VERSION') {
            if (isWebGLVersionEnabled(2)) {
                return 2;
            }
            else if (isWebGLVersionEnabled(1)) {
                return 1;
            }
            return 0;
        }
        else if (feature === 'WEBGL_FLOAT_TEXTURE_ENABLED') {
            return isFloatTextureReadPixelsEnabled(this.get('WEBGL_VERSION'));
        }
        else if (feature === 'WEBGL_GET_BUFFER_SUB_DATA_ASYNC_EXTENSION_ENABLED') {
            return isWebGLGetBufferSubDataAsyncExtensionEnabled(this.get('WEBGL_VERSION'));
        }
        throw new Error("Unknown feature " + feature + ".");
    };
    return Environment;
}());
exports.Environment = Environment;
var DEEPLEARNJS_FLAGS_PREFIX = 'dljsflags';
function getFeaturesFromURL() {
    var features = {};
    if (typeof window === 'undefined') {
        return features;
    }
    var urlParams = util.getQueryParams(window.location.search);
    if (DEEPLEARNJS_FLAGS_PREFIX in urlParams) {
        var urlFlags_1 = {};
        var keyValues = urlParams[DEEPLEARNJS_FLAGS_PREFIX].split(',');
        keyValues.forEach(function (keyValue) {
            var _a = keyValue.split(':'), key = _a[0], value = _a[1];
            urlFlags_1[key] = value;
        });
        exports.URL_PROPERTIES.forEach(function (urlProperty) {
            if (urlProperty.name in urlFlags_1) {
                console.log("Setting feature override from URL " + urlProperty.name + ": " +
                    ("" + urlFlags_1[urlProperty.name]));
                if (urlProperty.type === Type.NUMBER) {
                    features[urlProperty.name] = +urlFlags_1[urlProperty.name];
                }
                else if (urlProperty.type === Type.BOOLEAN) {
                    features[urlProperty.name] = urlFlags_1[urlProperty.name] === 'true';
                }
                else {
                    console.warn("Unknown URL param: " + urlProperty.name + ".");
                }
            }
        });
    }
    return features;
}
exports.ENV = new Environment(getFeaturesFromURL());
function setEnvironment(environment) {
    exports.ENV = environment;
}
exports.setEnvironment = setEnvironment;

},{"./device_util":6,"./util":88}],8:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var initializers_1 = require("../initializers");
var concat_util = require("../math/concat_util");
var conv_util = require("../math/conv_util");
var ndarray_1 = require("../math/ndarray");
var util = require("../util");
var GraphLayers = (function () {
    function GraphLayers(g) {
        this.g = g;
    }
    GraphLayers.prototype.dense = function (name, x, units, activation, useBias, kernelInitializer, biasInitializer) {
        if (activation === void 0) { activation = null; }
        if (useBias === void 0) { useBias = true; }
        if (kernelInitializer === void 0) { kernelInitializer = new initializers_1.VarianceScalingInitializer(); }
        if (biasInitializer === void 0) { biasInitializer = new initializers_1.ZerosInitializer(); }
        var weights = this.g.variable(name + '-weights', kernelInitializer.initialize([x.shape[0], units], x.shape[0], units));
        var out = this.g.matmul(x, weights);
        if (useBias) {
            var bias = this.g.variable(name + '-bias', biasInitializer.initialize([units], x.shape[0], units));
            out = this.g.add(out, bias);
        }
        if (activation != null) {
            out = activation(out);
        }
        return out;
    };
    return GraphLayers;
}());
exports.GraphLayers = GraphLayers;
var Graph = (function () {
    function Graph() {
        this.nodes = [];
        this.layers = new GraphLayers(this);
    }
    Graph.prototype.variable = function (name, data) {
        return this.addNodeAndReturnOutput(new VariableNode(this, name, data));
    };
    Graph.prototype.placeholder = function (name, shape) {
        return this.addNodeAndReturnOutput(new PlaceholderNode(this, name, shape));
    };
    Graph.prototype.constant = function (value) {
        var finalValue;
        if (typeof value === 'number') {
            finalValue = ndarray_1.Scalar.new(value);
        }
        else if (value instanceof ndarray_1.NDArray) {
            finalValue = value;
        }
        else if (value instanceof Array) {
            var flatValues = util.flatten(value);
            var vals = new Float32Array(flatValues);
            finalValue = ndarray_1.NDArray.make(util.inferShape(value), { values: vals });
        }
        else {
            throw new Error('unimplemented constant type.');
        }
        return this.addNodeAndReturnOutput(new ConstantNode(this, finalValue));
    };
    Graph.prototype.reshape = function (x, shape) {
        return this.addNodeAndReturnOutput(new ReshapeNode(this, 'Reshape', x, shape));
    };
    Graph.prototype.fusedLinearCombination = function (x1, x2, c1, c2) {
        return this.addNodeAndReturnOutput(new FusedLinearCombinationNode(this, x1, x2, c1, c2));
    };
    Graph.prototype.add = function (x1, x2) {
        return this.addNodeAndReturnOutput(new AddNode(this, x1, x2));
    };
    Graph.prototype.subtract = function (x1, x2) {
        return this.addNodeAndReturnOutput(new SubtractNode(this, x1, x2));
    };
    Graph.prototype.multiply = function (x1, x2) {
        return this.addNodeAndReturnOutput(new MultiplyNode(this, x1, x2));
    };
    Graph.prototype.divide = function (x1, x2) {
        return this.addNodeAndReturnOutput(new DivideNode(this, x1, x2));
    };
    Graph.prototype.reduceSum = function (x) {
        return this.addNodeAndReturnOutput(new ReduceSumNode(this, x));
    };
    Graph.prototype.concat3d = function (x1, x2, axis) {
        return this.addNodeAndReturnOutput(new Concat3DNode(this, x1, x2, axis));
    };
    Graph.prototype.matmul = function (x1, x2) {
        return this.addNodeAndReturnOutput(new MatMulNode(this, x1, x2));
    };
    Graph.prototype.conv2d = function (x, w, b, fieldSize, outputDepth, stride, zeroPad) {
        if (stride === void 0) { stride = 1; }
        return this.addNodeAndReturnOutput(new Convolution2DNode(this, x, w, b, fieldSize, outputDepth, stride, zeroPad));
    };
    Graph.prototype.maxPool = function (x, fieldSize, stride, zeroPad) {
        if (stride === void 0) { stride = 1; }
        return this.addNodeAndReturnOutput(new MaxPoolNode(this, x, fieldSize, stride, zeroPad));
    };
    Graph.prototype.exp = function (x) {
        return this.addNodeAndReturnOutput(new ExpNode(this, x));
    };
    Graph.prototype.log = function (x) {
        return this.addNodeAndReturnOutput(new LogNode(this, x));
    };
    Graph.prototype.relu = function (x) {
        return this.addNodeAndReturnOutput(new ReLUNode(this, x));
    };
    Graph.prototype.leakyRelu = function (x, alpha) {
        return this.addNodeAndReturnOutput(new LeakyReLUNode(this, x, alpha));
    };
    Graph.prototype.tanh = function (x) {
        return this.addNodeAndReturnOutput(new TanHNode(this, x));
    };
    Graph.prototype.sigmoid = function (x) {
        return this.addNodeAndReturnOutput(new SigmoidNode(this, x));
    };
    Graph.prototype.square = function (x) {
        return this.addNodeAndReturnOutput(new SquareNode(this, x));
    };
    Graph.prototype.softmax = function (x) {
        return this.addNodeAndReturnOutput(new SoftmaxNode(this, x));
    };
    Graph.prototype.softmaxCrossEntropyCost = function (x, target) {
        return this.addNodeAndReturnOutput(new SoftmaxCrossEntropyCostNode(this, x, target));
    };
    Graph.prototype.meanSquaredCost = function (label, prediction) {
        return this.addNodeAndReturnOutput(new MeanSquaredCostNode(this, label, prediction));
    };
    Graph.prototype.argmax = function (x) {
        return this.addNodeAndReturnOutput(new ArgMaxNode(this, x));
    };
    Graph.prototype.argmaxEquals = function (x1, x2) {
        return this.addNodeAndReturnOutput(new ArgMaxEqualsNode(this, x1, x2));
    };
    Graph.prototype.addNodeAndReturnOutput = function (node) {
        this.nodes.push(node);
        node.validate();
        return node.output;
    };
    Graph.prototype.getNodes = function () {
        return this.nodes;
    };
    return Graph;
}());
exports.Graph = Graph;
var Tensor = (function () {
    function Tensor(shape) {
        this.shape = shape;
        this.id = Tensor.nextID++;
    }
    Tensor.nextID = 0;
    return Tensor;
}());
exports.Tensor = Tensor;
var Node = (function () {
    function Node(graph, name, inputs, output) {
        this.graph = graph;
        this.name = name;
        this.inputs = inputs;
        this.output = output;
        this.id = Node.nextID++;
        output.node = this;
    }
    Node.nextID = 0;
    return Node;
}());
exports.Node = Node;
var VariableNode = (function (_super) {
    __extends(VariableNode, _super);
    function VariableNode(graph, name, data) {
        var _this = _super.call(this, graph, name, {}, new Tensor(data.shape)) || this;
        _this.data = data;
        return _this;
    }
    VariableNode.prototype.validate = function () {
        util.assert(this.data != null, 'Error adding variable op: Data for variable \'' + this.name +
            '\' is null or undefined');
    };
    return VariableNode;
}(Node));
exports.VariableNode = VariableNode;
var PlaceholderNode = (function (_super) {
    __extends(PlaceholderNode, _super);
    function PlaceholderNode(graph, name, shape) {
        return _super.call(this, graph, name, {}, new Tensor(shape)) || this;
    }
    PlaceholderNode.prototype.validate = function () { };
    return PlaceholderNode;
}(Node));
exports.PlaceholderNode = PlaceholderNode;
var ConstantNode = (function (_super) {
    __extends(ConstantNode, _super);
    function ConstantNode(graph, data) {
        var _this = _super.call(this, graph, 'Constant', {}, new Tensor(data.shape)) || this;
        _this.data = data;
        return _this;
    }
    ConstantNode.prototype.validate = function () {
        util.assert(this.data != null, 'Error adding constant: data for placeholder \'' + this.name +
            '\' is null or undefined');
    };
    return ConstantNode;
}(Node));
exports.ConstantNode = ConstantNode;
var ReshapeNode = (function (_super) {
    __extends(ReshapeNode, _super);
    function ReshapeNode(graph, name, x, shape) {
        var _this = _super.call(this, graph, name, { x: x }, new Tensor(shape)) || this;
        _this.name = name;
        _this.x = x;
        _this.shape = shape;
        return _this;
    }
    ReshapeNode.prototype.validate = function () {
        var xSize = util.sizeFromShape(this.x.shape);
        var shapeSize = util.sizeFromShape(this.shape);
        util.assert(xSize === shapeSize, "Error making reshape operation: input to reshape '" + this.name + "'" +
            (" of shape (" + this.x.shape + ") does not match size of ") +
            ("requested shape " + this.shape + "."));
    };
    ReshapeNode.X = 'x';
    return ReshapeNode;
}(Node));
exports.ReshapeNode = ReshapeNode;
var FusedLinearCombinationNode = (function (_super) {
    __extends(FusedLinearCombinationNode, _super);
    function FusedLinearCombinationNode(graph, t1, t2, c1, c2) {
        var _this = _super.call(this, graph, 'Linear Combination', { t1: t1, t2: t2, c1: c1, c2: c2 }, new Tensor(t1.shape)) || this;
        _this.t1 = t1;
        _this.t2 = t2;
        _this.c1 = c1;
        _this.c2 = c2;
        return _this;
    }
    FusedLinearCombinationNode.prototype.validate = function () {
        util.assertShapesMatch(this.t1.shape, this.t2.shape);
        if (!util.isScalarShape(this.c1.shape)) {
            throw new Error('Error adding fusedLinearCombination: c1 is not a scalar, got ' +
                ("shape: " + this.c1.shape));
        }
        if (!util.isScalarShape(this.c2.shape)) {
            throw new Error('Error adding fusedLinearCombination: c2 is not a scalar, got ' +
                ("shape: " + this.c2.shape));
        }
    };
    FusedLinearCombinationNode.T1 = 't1';
    FusedLinearCombinationNode.T2 = 't2';
    FusedLinearCombinationNode.C1 = 'c1';
    FusedLinearCombinationNode.C2 = 'c2';
    return FusedLinearCombinationNode;
}(Node));
exports.FusedLinearCombinationNode = FusedLinearCombinationNode;
var AddNode = (function (_super) {
    __extends(AddNode, _super);
    function AddNode(graph, t1, t2) {
        var _this = _super.call(this, graph, 'Add', { t1: t1, t2: t2 }, new Tensor(util.sizeFromShape(t1.shape) === 1 ? t2.shape : t1.shape)) || this;
        _this.t1 = t1;
        _this.t2 = t2;
        return _this;
    }
    AddNode.prototype.validate = function () {
        util.assert(util.sizeFromShape(this.t1.shape) === 1 ||
            util.sizeFromShape(this.t2.shape) === 1 ||
            util.arraysEqual(this.t1.shape, this.t2.shape), 'Error adding add operation op: one of inputs must be scalar or the ' +
            ("shapes " + this.t1.shape + " and " + this.t2.shape + " must match."));
    };
    AddNode.T1 = 't1';
    AddNode.T2 = 't2';
    return AddNode;
}(Node));
exports.AddNode = AddNode;
var SubtractNode = (function (_super) {
    __extends(SubtractNode, _super);
    function SubtractNode(graph, t1, t2) {
        var _this = _super.call(this, graph, 'Subtract', { t1: t1, t2: t2 }, new Tensor(util.sizeFromShape(t1.shape) === 1 ? t2.shape : t1.shape)) || this;
        _this.t1 = t1;
        _this.t2 = t2;
        return _this;
    }
    SubtractNode.prototype.validate = function () {
        util.assert(util.sizeFromShape(this.t1.shape) === 1 ||
            util.sizeFromShape(this.t2.shape) === 1 ||
            util.arraysEqual(this.t1.shape, this.t2.shape), 'Error adding subtract op: one of inputs must be scalar or the ' +
            ("shapes " + this.t1.shape + " and " + this.t2.shape + " must match."));
    };
    SubtractNode.T1 = 't1';
    SubtractNode.T2 = 't2';
    return SubtractNode;
}(Node));
exports.SubtractNode = SubtractNode;
var MultiplyNode = (function (_super) {
    __extends(MultiplyNode, _super);
    function MultiplyNode(graph, t1, t2) {
        var _this = _super.call(this, graph, 'Multiply', { t1: t1, t2: t2 }, new Tensor(util.sizeFromShape(t1.shape) === 1 ? t2.shape : t1.shape)) || this;
        _this.t1 = t1;
        _this.t2 = t2;
        return _this;
    }
    MultiplyNode.prototype.validate = function () {
        util.assert(util.sizeFromShape(this.t1.shape) === 1 ||
            util.sizeFromShape(this.t2.shape) === 1 ||
            util.arraysEqual(this.t1.shape, this.t2.shape), 'Error adding multiply op: one of inputs must be scalar or the ' +
            ("shapes " + this.t1.shape + " and " + this.t2.shape + " must match."));
    };
    MultiplyNode.T1 = 't1';
    MultiplyNode.T2 = 't2';
    return MultiplyNode;
}(Node));
exports.MultiplyNode = MultiplyNode;
var DivideNode = (function (_super) {
    __extends(DivideNode, _super);
    function DivideNode(graph, t1, t2) {
        var _this = _super.call(this, graph, 'Divide', { t1: t1, t2: t2 }, new Tensor(util.sizeFromShape(t1.shape) === 1 ? t2.shape : t1.shape)) || this;
        _this.t1 = t1;
        _this.t2 = t2;
        return _this;
    }
    DivideNode.prototype.validate = function () {
        util.assert(util.sizeFromShape(this.t1.shape) === 1 ||
            util.sizeFromShape(this.t2.shape) === 1 ||
            util.arraysEqual(this.t1.shape, this.t2.shape), 'Error adding divide op: one of inputs must be scalar or the ' +
            ("shapes " + this.t1.shape + " and " + this.t2.shape + " must match."));
    };
    DivideNode.T1 = 't1';
    DivideNode.T2 = 't2';
    return DivideNode;
}(Node));
exports.DivideNode = DivideNode;
var ReduceSumNode = (function (_super) {
    __extends(ReduceSumNode, _super);
    function ReduceSumNode(graph, x) {
        return _super.call(this, graph, 'ReduceSum', { x: x }, new Tensor([])) || this;
    }
    ReduceSumNode.prototype.validate = function () { };
    ReduceSumNode.X = 'x';
    return ReduceSumNode;
}(Node));
exports.ReduceSumNode = ReduceSumNode;
var Concat3DNode = (function (_super) {
    __extends(Concat3DNode, _super);
    function Concat3DNode(graph, x1, x2, axis) {
        var _this = _super.call(this, graph, 'Concat3D', { x1: x1, x2: x2 }, new Tensor(concat_util.computeOutShape(x1.shape, x2.shape, axis))) || this;
        _this.x1 = x1;
        _this.x2 = x2;
        _this.axis = axis;
        return _this;
    }
    Concat3DNode.prototype.validate = function () {
        concat_util.assertParams(this.x1.shape, this.x2.shape, this.axis);
    };
    Concat3DNode.X1 = 'x1';
    Concat3DNode.X2 = 'x2';
    Concat3DNode.AXIS = 'axis';
    return Concat3DNode;
}(Node));
exports.Concat3DNode = Concat3DNode;
function getMatMulOutputShape(x1Shape, x2Shape) {
    if (x1Shape.length === 1 && x2Shape.length === 1) {
        return [1];
    }
    else if (x1Shape.length === 1 && x2Shape.length === 2) {
        return [x2Shape[1]];
    }
    else if (x1Shape.length === 2 && x2Shape.length === 1) {
        return [x1Shape[0]];
    }
    return [x1Shape[0], x2Shape[1]];
}
var MatMulNode = (function (_super) {
    __extends(MatMulNode, _super);
    function MatMulNode(graph, x1, x2) {
        var _this = _super.call(this, graph, 'MatMul', { x1: x1, x2: x2 }, new Tensor(getMatMulOutputShape(x1.shape, x2.shape))) || this;
        _this.x1 = x1;
        _this.x2 = x2;
        return _this;
    }
    MatMulNode.prototype.validate = function () {
        if (this.x1.shape.length === 2 && this.x2.shape.length === 2) {
            util.assert(this.x1.shape[1] === this.x2.shape[0], 'Error adding matmul op: inner shapes of matrices with shapes ' +
                (this.x1.shape + " and " + this.x2.shape + " must match."));
        }
        else if (this.x1.shape.length === 2 && this.x2.shape.length === 1) {
            util.assert(this.x1.shape[1] === this.x2.shape[0], 'Error adding matmul op: second dimension of matrix with shape ' +
                this.x1.shape.toString() +
                (" must match size of vector with shape " + this.x2.shape + "."));
        }
        else if (this.x1.shape.length === 1 && this.x2.shape.length === 2) {
            util.assert(this.x1.shape[0] === this.x2.shape[0], "Error adding matmul op: size of vector with shape " + this.x1.shape +
                " must match first dimension of matrix with " +
                ("shape " + this.x2.shape + "."));
        }
        else {
            throw new Error('Error adding matmul op: inputs must be vectors or matrices.');
        }
    };
    MatMulNode.X1 = 'x1';
    MatMulNode.X2 = 'x2';
    return MatMulNode;
}(Node));
exports.MatMulNode = MatMulNode;
var Convolution2DNode = (function (_super) {
    __extends(Convolution2DNode, _super);
    function Convolution2DNode(graph, x, w, b, fieldSize, outputDepth, stride, zeroPad) {
        if (stride === void 0) { stride = 1; }
        var _this = _super.call(this, graph, 'Convolution 2D', { x: x, w: w, b: b }, new Tensor(conv_util.computeOutputShape3D(x.shape, fieldSize, outputDepth, stride, zeroPad))) || this;
        _this.x = x;
        _this.w = w;
        _this.b = b;
        _this.fieldSize = fieldSize;
        _this.outputDepth = outputDepth;
        _this.stride = stride;
        _this.zeroPad = zeroPad;
        return _this;
    }
    Convolution2DNode.prototype.validate = function () {
        util.assert(this.x.shape.length === 3, 'Error adding conv2d op: input must be of rank 3, but got shape: ' +
            (this.x.shape + "."));
        util.assert(this.w.shape.length === 4, 'Error adding conv2d op: weights must be of rank 4, but got shape: ' +
            (this.w.shape + "."));
        util.assert(this.b.shape.length === 1, 'Error adding conv2d op: biases must be of rank 1, but got shape: ' +
            (this.b.shape + "."));
        util.assert(this.x.shape[2] === this.w.shape[2], "Error adding conv2d op: depth of input (" + this.x.shape[2] + ") " +
            ("must match input depth for weights (" + this.w.shape[2] + ")."));
    };
    Convolution2DNode.X = 'x';
    Convolution2DNode.W = 'w';
    Convolution2DNode.B = 'b';
    return Convolution2DNode;
}(Node));
exports.Convolution2DNode = Convolution2DNode;
var MaxPoolNode = (function (_super) {
    __extends(MaxPoolNode, _super);
    function MaxPoolNode(graph, x, fieldSize, stride, zeroPad) {
        if (stride === void 0) { stride = 1; }
        var _this = _super.call(this, graph, 'Max pool', { x: x }, new Tensor(conv_util.computeOutputShape3D(x.shape, fieldSize, x.shape[2], stride, zeroPad))) || this;
        _this.x = x;
        _this.fieldSize = fieldSize;
        _this.stride = stride;
        _this.zeroPad = zeroPad;
        return _this;
    }
    MaxPoolNode.prototype.validate = function () {
        util.assert(this.x.shape.length === 3, 'Error adding maxPool op: input must be of rank 3, but got shape: ' +
            (this.x.shape + "."));
    };
    MaxPoolNode.X = 'x';
    return MaxPoolNode;
}(Node));
exports.MaxPoolNode = MaxPoolNode;
var ReLUNode = (function (_super) {
    __extends(ReLUNode, _super);
    function ReLUNode(graph, x) {
        return _super.call(this, graph, 'ReLU', { x: x }, new Tensor(x.shape)) || this;
    }
    ReLUNode.prototype.validate = function () { };
    ReLUNode.X = 'x';
    return ReLUNode;
}(Node));
exports.ReLUNode = ReLUNode;
var LeakyReLUNode = (function (_super) {
    __extends(LeakyReLUNode, _super);
    function LeakyReLUNode(graph, x, alpha) {
        var _this = _super.call(this, graph, 'LeakyReLU', { x: x }, new Tensor(x.shape)) || this;
        _this.alpha = alpha;
        return _this;
    }
    LeakyReLUNode.prototype.validate = function () { };
    LeakyReLUNode.X = 'x';
    return LeakyReLUNode;
}(Node));
exports.LeakyReLUNode = LeakyReLUNode;
var ExpNode = (function (_super) {
    __extends(ExpNode, _super);
    function ExpNode(graph, x) {
        return _super.call(this, graph, 'Exp', { x: x }, new Tensor(x.shape)) || this;
    }
    ExpNode.prototype.validate = function () { };
    ExpNode.X = 'x';
    return ExpNode;
}(Node));
exports.ExpNode = ExpNode;
var LogNode = (function (_super) {
    __extends(LogNode, _super);
    function LogNode(graph, x) {
        return _super.call(this, graph, 'Log', { x: x }, new Tensor(x.shape)) || this;
    }
    LogNode.prototype.validate = function () { };
    LogNode.X = 'x';
    return LogNode;
}(Node));
exports.LogNode = LogNode;
var TanHNode = (function (_super) {
    __extends(TanHNode, _super);
    function TanHNode(graph, x) {
        return _super.call(this, graph, 'TanH', { x: x }, new Tensor(x.shape)) || this;
    }
    TanHNode.prototype.validate = function () { };
    TanHNode.X = 'x';
    return TanHNode;
}(Node));
exports.TanHNode = TanHNode;
var SigmoidNode = (function (_super) {
    __extends(SigmoidNode, _super);
    function SigmoidNode(graph, x) {
        return _super.call(this, graph, 'Sigmoid', { x: x }, new Tensor(x.shape)) || this;
    }
    SigmoidNode.prototype.validate = function () { };
    SigmoidNode.X = 'x';
    return SigmoidNode;
}(Node));
exports.SigmoidNode = SigmoidNode;
var SquareNode = (function (_super) {
    __extends(SquareNode, _super);
    function SquareNode(graph, x) {
        return _super.call(this, graph, 'Square', { x: x }, new Tensor(x.shape)) || this;
    }
    SquareNode.prototype.validate = function () { };
    SquareNode.X = 'x';
    return SquareNode;
}(Node));
exports.SquareNode = SquareNode;
var SoftmaxCrossEntropyCostNode = (function (_super) {
    __extends(SoftmaxCrossEntropyCostNode, _super);
    function SoftmaxCrossEntropyCostNode(graph, x, target) {
        var _this = _super.call(this, graph, 'SoftmaxCrossEntropyCost', { x: x, target: target }, new Tensor([])) || this;
        _this.x = x;
        _this.target = target;
        return _this;
    }
    SoftmaxCrossEntropyCostNode.prototype.validate = function () {
        util.assert(util.arraysEqual(this.x.shape, this.target.shape), "Error adding softmaxCrossEntropyCost op: x shape (" + this.x.shape + ") " +
            ("must match target shape (" + this.target.shape + ")."));
    };
    SoftmaxCrossEntropyCostNode.X = 'x';
    SoftmaxCrossEntropyCostNode.TARGET = 'target';
    return SoftmaxCrossEntropyCostNode;
}(Node));
exports.SoftmaxCrossEntropyCostNode = SoftmaxCrossEntropyCostNode;
var SoftmaxNode = (function (_super) {
    __extends(SoftmaxNode, _super);
    function SoftmaxNode(graph, x) {
        var _this = _super.call(this, graph, 'Softmax', { x: x }, new Tensor(x.shape)) || this;
        _this.x = x;
        return _this;
    }
    SoftmaxNode.prototype.validate = function () {
        util.assert(this.x.shape.length === 1, 'The input to a softmax must be a 1-D tensor');
        util.assert(this.x.shape[0] >= 2, 'The input to a softmax must have at least 2 values');
    };
    SoftmaxNode.X = 'x';
    return SoftmaxNode;
}(Node));
exports.SoftmaxNode = SoftmaxNode;
var MeanSquaredCostNode = (function (_super) {
    __extends(MeanSquaredCostNode, _super);
    function MeanSquaredCostNode(graph, label, prediction) {
        var _this = _super.call(this, graph, 'Mean Squared Cost', { label: label, prediction: prediction }, new Tensor([])) || this;
        _this.label = label;
        _this.prediction = prediction;
        return _this;
    }
    MeanSquaredCostNode.prototype.validate = function () {
        util.assert(util.arraysEqual(this.label.shape, this.prediction.shape), "Error adding meanSquaredCost op: label shape (" + this.label.shape + ") " +
            ("must match prediction shape (" + this.prediction.shape + ")."));
    };
    MeanSquaredCostNode.LABEL = 'label';
    MeanSquaredCostNode.PREDICTION = 'prediction';
    return MeanSquaredCostNode;
}(Node));
exports.MeanSquaredCostNode = MeanSquaredCostNode;
var ArgMaxNode = (function (_super) {
    __extends(ArgMaxNode, _super);
    function ArgMaxNode(graph, x) {
        var _this = _super.call(this, graph, 'ArgMax', { x: x }, new Tensor([1])) || this;
        _this.x = x;
        return _this;
    }
    ArgMaxNode.prototype.validate = function () {
        util.assert(util.sizeFromShape(this.x.shape) > 0, 'Error adding argmax op: input tensor must have at least one entry.');
    };
    ArgMaxNode.X = 'x';
    return ArgMaxNode;
}(Node));
exports.ArgMaxNode = ArgMaxNode;
var ArgMaxEqualsNode = (function (_super) {
    __extends(ArgMaxEqualsNode, _super);
    function ArgMaxEqualsNode(graph, x1, x2) {
        var _this = _super.call(this, graph, 'ArgMaxEquals', { x1: x1, x2: x2 }, new Tensor([1])) || this;
        _this.x1 = x1;
        _this.x2 = x2;
        return _this;
    }
    ArgMaxEqualsNode.prototype.validate = function () {
        util.assert(util.arraysEqual(this.x1.shape, this.x2.shape), "Error adding ArgMaxEquals op: x1 shape (" + this.x1.shape + ") " +
            ("must match x2 shape (" + this.x2.shape + ")."));
    };
    ArgMaxEqualsNode.X1 = 'x1';
    ArgMaxEqualsNode.X2 = 'x2';
    return ArgMaxEqualsNode;
}(Node));
exports.ArgMaxEqualsNode = ArgMaxEqualsNode;

},{"../initializers":44,"../math/concat_util":48,"../math/conv_util":49,"../math/ndarray":55,"../util":88}],9:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var graph_1 = require("./graph");
var priority_queue = require("./priority_queue");
var priority_queue_1 = require("./priority_queue");
function getUnorderedEvaluationSet(nodes, terminatingNodes) {
    var terminatingNodeMap = {};
    var seen = {};
    var set = [];
    var visit = nodes.slice();
    terminatingNodes.forEach(function (node) { return terminatingNodeMap[node.id] = node; });
    var _loop_1 = function () {
        var cur = visit.pop();
        if (seen[cur.id] == null) {
            if (terminatingNodeMap[cur.id] == null) {
                Object.keys(cur.inputs)
                    .map(function (inputName) { return cur.inputs[inputName]; })
                    .forEach(function (input) { return visit.push(input.node); });
            }
            set.push(cur);
            seen[cur.id] = cur;
        }
    };
    while (visit.length !== 0) {
        _loop_1();
    }
    return set;
}
exports.getUnorderedEvaluationSet = getUnorderedEvaluationSet;
function getOrderedEvaluationSet(unorderedEvaluationSet) {
    var set = [];
    var nodeIndices = {};
    var pendingDependencies = {};
    var nodeQueue = new priority_queue_1.PriorityQueue(function (a, b) { return priority_queue.defaultCompare(pendingDependencies[a.id], pendingDependencies[b.id]); }, function (node, newIndex) { return nodeIndices[node.id] = newIndex; });
    unorderedEvaluationSet.forEach(function (node) { return pendingDependencies[node.id] = 0; });
    unorderedEvaluationSet.forEach(function (node) { return Object.keys(node.inputs)
        .map(function (key) { return node.inputs[key]; })
        .forEach(function (input) {
        if (unorderedEvaluationSet.indexOf(input.node) !== -1) {
            pendingDependencies[input.node.id]++;
        }
    }); });
    unorderedEvaluationSet.forEach(function (node) { return nodeQueue.enqueue(node); });
    while (!nodeQueue.empty()) {
        set.unshift(nodeQueue.dequeue());
        Object.keys(set[0].inputs).map(function (key) { return set[0].inputs[key]; }).forEach(function (input) {
            if (unorderedEvaluationSet.indexOf(input.node) === -1) {
                return;
            }
            pendingDependencies[input.node.id]--;
            nodeQueue.update(input.node, nodeIndices[input.node.id]);
        });
    }
    return set;
}
exports.getOrderedEvaluationSet = getOrderedEvaluationSet;
function isInputNode(node) {
    return Object.keys(node.inputs).length === 0;
}
exports.isInputNode = isInputNode;
function shouldBackProp(t) {
    return !(t.node instanceof graph_1.ConstantNode);
}
exports.shouldBackProp = shouldBackProp;
function isPassthroughNode(node, map) {
    var keys = Object.keys(node.inputs);
    for (var i = 0; i < keys.length; i++) {
        var input = node.inputs[keys[i]];
        if (map.get(input, true) === map.get(node.output, true)) {
            return true;
        }
    }
    return false;
}
exports.isPassthroughNode = isPassthroughNode;

},{"./graph":8,"./priority_queue":38}],10:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var graph_1 = require("./graph");
var graph_util = require("./graph_util");
var add_1 = require("./ops/add");
var argmax_1 = require("./ops/argmax");
var argmaxequals_1 = require("./ops/argmaxequals");
var concat3d_1 = require("./ops/concat3d");
var convolution_1 = require("./ops/convolution");
var divide_1 = require("./ops/divide");
var element_wise_activation_1 = require("./ops/element_wise_activation");
var element_wise_cost_1 = require("./ops/element_wise_cost");
var exp_1 = require("./ops/exp");
var linear_combination_1 = require("./ops/linear_combination");
var log_1 = require("./ops/log");
var matmul_1 = require("./ops/matmul");
var max_pool_1 = require("./ops/max_pool");
var multiply_1 = require("./ops/multiply");
var reduce_sum_1 = require("./ops/reduce_sum");
var reshape_1 = require("./ops/reshape");
var softmax_1 = require("./ops/softmax");
var subtract_1 = require("./ops/subtract");
function emitFromGraphNodes(nodes) {
    var ops = [];
    nodes.forEach(function (node) { return Array.prototype.push.apply(ops, emitOpFromNode(node)); });
    return ops;
}
exports.emitFromGraphNodes = emitFromGraphNodes;
function emitOpFromNode(node) {
    if (node instanceof graph_1.ReshapeNode) {
        return [new reshape_1.Reshape(node.inputs[graph_1.ReshapeNode.X], node.output)];
    }
    else if (node instanceof graph_1.MatMulNode) {
        var x1 = node.inputs[graph_1.MatMulNode.X1];
        var x2 = node.inputs[graph_1.MatMulNode.X2];
        return [new matmul_1.MatMul(x1, x2, node.output)];
    }
    else if (node instanceof graph_1.Convolution2DNode) {
        var w = node.inputs[graph_1.Convolution2DNode.W];
        var x = node.inputs[graph_1.Convolution2DNode.X];
        var b = node.inputs[graph_1.Convolution2DNode.B];
        return [new convolution_1.Convolution2D(w, x, b, node.output, node.fieldSize, node.outputDepth, node.stride, node.zeroPad)];
    }
    else if (node instanceof graph_1.MaxPoolNode) {
        var x = node.inputs[graph_1.MaxPoolNode.X];
        return [new max_pool_1.MaxPool(x, node.output, node.fieldSize, node.stride, node.zeroPad)];
    }
    else if (node instanceof graph_1.ExpNode) {
        return [new exp_1.Exp(node.inputs[graph_1.ExpNode.X], node.output)];
    }
    else if (node instanceof graph_1.LogNode) {
        return [new log_1.Log(node.inputs[graph_1.LogNode.X], node.output)];
    }
    else if (node instanceof graph_1.ReLUNode) {
        return [new element_wise_activation_1.ReLU(node.inputs[graph_1.ReLUNode.X], node.output)];
    }
    else if (node instanceof graph_1.LeakyReLUNode) {
        return [new element_wise_activation_1.LeakyReLU(node.inputs[graph_1.LeakyReLUNode.X], node.output, node.alpha)];
    }
    else if (node instanceof graph_1.TanHNode) {
        return [new element_wise_activation_1.TanH(node.inputs[graph_1.TanHNode.X], node.output)];
    }
    else if (node instanceof graph_1.SigmoidNode) {
        return [new element_wise_activation_1.Sigmoid(node.inputs[graph_1.SigmoidNode.X], node.output)];
    }
    else if (node instanceof graph_1.SoftmaxCrossEntropyCostNode) {
        var x = node.inputs[graph_1.SoftmaxCrossEntropyCostNode.X];
        var target = node.inputs[graph_1.SoftmaxCrossEntropyCostNode.TARGET];
        return [new softmax_1.SoftmaxCrossEntropyCost(x, target, node.output)];
    }
    else if (node instanceof graph_1.SoftmaxNode) {
        return [new softmax_1.Softmax(node.inputs[graph_1.SoftmaxNode.X], node.output)];
    }
    else if (node instanceof graph_1.MeanSquaredCostNode) {
        var label = node.inputs[graph_1.MeanSquaredCostNode.LABEL];
        var prediction = node.inputs[graph_1.MeanSquaredCostNode.PREDICTION];
        return [new element_wise_cost_1.MeanSquaredCost(label, prediction, node.output)];
    }
    else if (node instanceof graph_1.ArgMaxEqualsNode) {
        return [new argmaxequals_1.ArgMaxEquals(node.inputs[graph_1.ArgMaxEqualsNode.X1], node.inputs[graph_1.ArgMaxEqualsNode.X2], node.output)];
    }
    else if (node instanceof graph_1.ArgMaxNode) {
        return [new argmax_1.ArgMax(node.x, node.output)];
    }
    else if (node instanceof graph_1.FusedLinearCombinationNode) {
        return [new linear_combination_1.LinearCombination(node.inputs[graph_1.FusedLinearCombinationNode.T1], node.inputs[graph_1.FusedLinearCombinationNode.T2], node.inputs[graph_1.FusedLinearCombinationNode.C1], node.inputs[graph_1.FusedLinearCombinationNode.C2], node.output)];
    }
    else if (node instanceof graph_1.Concat3DNode) {
        return [new concat3d_1.Concat3D(node.inputs[graph_1.Concat3DNode.X1], node.inputs[graph_1.Concat3DNode.X2], node.axis, node.output)];
    }
    else if (node instanceof graph_1.SquareNode) {
        return [new element_wise_activation_1.Square(node.inputs[graph_1.SquareNode.X], node.output)];
    }
    else if (node instanceof graph_1.AddNode) {
        return [new add_1.Add(node.inputs[graph_1.AddNode.T1], node.inputs[graph_1.AddNode.T2], node.output)];
    }
    else if (node instanceof graph_1.SubtractNode) {
        return [new subtract_1.Subtract(node.inputs[graph_1.SubtractNode.T1], node.inputs[graph_1.SubtractNode.T2], node.output)];
    }
    else if (node instanceof graph_1.MultiplyNode) {
        return [new multiply_1.Multiply(node.inputs[graph_1.MultiplyNode.T1], node.inputs[graph_1.MultiplyNode.T2], node.output)];
    }
    else if (node instanceof graph_1.DivideNode) {
        return [new divide_1.Divide(node.inputs[graph_1.DivideNode.T1], node.inputs[graph_1.DivideNode.T2], node.output)];
    }
    else if (node instanceof graph_1.ReduceSumNode) {
        return [new reduce_sum_1.ReduceSum(node.inputs[graph_1.ReduceSumNode.X], node.output)];
    }
    else if (graph_util.isInputNode(node)) {
        return [];
    }
    else {
        throw Error("Unsupported node type: " + node.constructor.name);
    }
}

},{"./graph":8,"./graph_util":9,"./ops/add":11,"./ops/argmax":12,"./ops/argmaxequals":13,"./ops/concat3d":14,"./ops/convolution":15,"./ops/divide":16,"./ops/element_wise_activation":17,"./ops/element_wise_cost":18,"./ops/exp":19,"./ops/linear_combination":20,"./ops/log":21,"./ops/matmul":22,"./ops/max_pool":23,"./ops/multiply":24,"./ops/reduce_sum":26,"./ops/reshape":27,"./ops/softmax":28,"./ops/subtract":29}],11:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ndarray_1 = require("../../math/ndarray");
var util = require("../../util");
var graph_util = require("../graph_util");
var op_1 = require("./op");
var Add = (function (_super) {
    __extends(Add, _super);
    function Add(x1Tensor, x2Tensor, yTensor) {
        var _this = _super.call(this) || this;
        _this.x1Tensor = x1Tensor;
        _this.x2Tensor = x2Tensor;
        _this.yTensor = yTensor;
        util.assert(util.sizeFromShape(x1Tensor.shape) === 1 ||
            util.sizeFromShape(x2Tensor.shape) === 1 ||
            util.arraysEqual(x1Tensor.shape, x2Tensor.shape), 'One of t1 or t2 must be a scalar, or t1 and t2 must have ' +
            'the same shape');
        return _this;
    }
    Add.prototype.feedForward = function (math, inferenceArrays) {
        var _this = this;
        var x1 = inferenceArrays.get(this.x1Tensor);
        var x2 = inferenceArrays.get(this.x2Tensor);
        math.scope(function (keep) {
            var result;
            if (util.isScalarShape(x1.shape)) {
                result = math.scalarPlusArray(x1, x2);
            }
            else if (util.isScalarShape(x2.shape)) {
                result = math.scalarPlusArray(x2, x1);
            }
            else {
                result = math.add(x1, x2);
            }
            inferenceArrays.set(_this.yTensor, keep(result));
        });
    };
    Add.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
        var _this = this;
        var dy = gradientArrays.get(this.yTensor);
        math.scope(function () {
            if (graph_util.shouldBackProp(_this.x1Tensor)) {
                if (util.isScalarShape(_this.x1Tensor.shape)) {
                    var sum = math.sum(dy);
                    if (_this.dySizeScalar == null) {
                        _this.dySizeScalar = ndarray_1.Scalar.new(dy.size);
                    }
                    gradientArrays.add(_this.x1Tensor, math.divide(sum, _this.dySizeScalar));
                }
                else {
                    gradientArrays.add(_this.x1Tensor, math.clone(dy));
                }
            }
            if (graph_util.shouldBackProp(_this.x2Tensor)) {
                if (util.isScalarShape(_this.x2Tensor.shape)) {
                    var sum = math.sum(dy);
                    if (_this.dySizeScalar == null) {
                        _this.dySizeScalar = ndarray_1.Scalar.new(dy.size);
                    }
                    gradientArrays.add(_this.x2Tensor, math.divide(sum, _this.dySizeScalar));
                }
                else {
                    gradientArrays.add(_this.x2Tensor, math.clone(dy));
                }
            }
        });
    };
    Add.prototype.dispose = function () {
        if (this.dySizeScalar != null) {
            this.dySizeScalar.dispose();
        }
    };
    return Add;
}(op_1.Operation));
exports.Add = Add;

},{"../../math/ndarray":55,"../../util":88,"../graph_util":9,"./op":25}],12:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var op_1 = require("./op");
var ArgMax = (function (_super) {
    __extends(ArgMax, _super);
    function ArgMax(xTensor, yTensor) {
        var _this = _super.call(this) || this;
        _this.xTensor = xTensor;
        _this.yTensor = yTensor;
        return _this;
    }
    ArgMax.prototype.feedForward = function (math, inferenceArrays) {
        var _this = this;
        var x = inferenceArrays.get(this.xTensor);
        math.scope(function (keep) {
            inferenceArrays.set(_this.yTensor, keep(math.argMax(x)));
        });
    };
    ArgMax.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
        throw new Error('ArgMax backprop unimplemented');
    };
    return ArgMax;
}(op_1.Operation));
exports.ArgMax = ArgMax;

},{"./op":25}],13:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var op_1 = require("./op");
var ArgMaxEquals = (function (_super) {
    __extends(ArgMaxEquals, _super);
    function ArgMaxEquals(x1Tensor, x2Tensor, yTensor) {
        var _this = _super.call(this) || this;
        _this.x1Tensor = x1Tensor;
        _this.x2Tensor = x2Tensor;
        _this.yTensor = yTensor;
        return _this;
    }
    ArgMaxEquals.prototype.feedForward = function (math, inferenceArrays) {
        var _this = this;
        var x1 = inferenceArrays.get(this.x1Tensor);
        var x2 = inferenceArrays.get(this.x2Tensor);
        math.scope(function (keep) {
            inferenceArrays.set(_this.yTensor, keep(math.argMaxEquals(x1, x2)));
        });
    };
    ArgMaxEquals.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
        throw new Error('ArgMaxEquals backprop unimplemented');
    };
    return ArgMaxEquals;
}(op_1.Operation));
exports.ArgMaxEquals = ArgMaxEquals;

},{"./op":25}],14:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var concat_util = require("../../math/concat_util");
var op_1 = require("./op");
var Concat3D = (function (_super) {
    __extends(Concat3D, _super);
    function Concat3D(x1Tensor, x2Tensor, axis, yTensor) {
        var _this = _super.call(this) || this;
        _this.x1Tensor = x1Tensor;
        _this.x2Tensor = x2Tensor;
        _this.axis = axis;
        _this.yTensor = yTensor;
        concat_util.assertParams(x1Tensor.shape, x2Tensor.shape, axis);
        return _this;
    }
    Concat3D.prototype.feedForward = function (math, inferenceArrays) {
        var _this = this;
        var x1 = inferenceArrays.get(this.x1Tensor);
        var x2 = inferenceArrays.get(this.x2Tensor);
        math.scope(function (keep) {
            var concatResult = math.concat3D(x1, x2, _this.axis);
            inferenceArrays.set(_this.yTensor, keep(concatResult));
        });
    };
    Concat3D.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
        throw new Error('Concat3D backprop not implemented.');
    };
    return Concat3D;
}(op_1.Operation));
exports.Concat3D = Concat3D;

},{"../../math/concat_util":48,"./op":25}],15:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var conv_util = require("../../math/conv_util");
var util = require("../../util");
var op_1 = require("./op");
var Convolution2D = (function (_super) {
    __extends(Convolution2D, _super);
    function Convolution2D(wTensor, xTensor, bTensor, yTensor, fieldSize, outputDepth, stride, zeroPad) {
        if (stride === void 0) { stride = 1; }
        var _this = _super.call(this) || this;
        _this.wTensor = wTensor;
        _this.xTensor = xTensor;
        _this.bTensor = bTensor;
        _this.yTensor = yTensor;
        _this.fieldSize = fieldSize;
        _this.outputDepth = outputDepth;
        _this.stride = stride;
        _this.assertWeightsShape(wTensor.shape);
        _this.zeroPad = zeroPad != null ?
            zeroPad :
            conv_util.computeDefaultPad(_this.xTensor.shape, _this.fieldSize, _this.stride);
        util.assert(util.isInt(_this.zeroPad), "The zero padding (" + _this.zeroPad + ") must be an integer. Change the " +
            "stride and/or zero pad parameters");
        return _this;
    }
    Convolution2D.prototype.feedForward = function (math, inferenceArrays) {
        var _this = this;
        var weights = inferenceArrays.get(this.wTensor);
        var biases = inferenceArrays.get(this.bTensor);
        var x = inferenceArrays.get(this.xTensor);
        math.scope(function (keep) {
            inferenceArrays.set(_this.yTensor, keep(math.conv2d(x, weights, biases, _this.stride, _this.zeroPad)));
        });
    };
    Convolution2D.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
        var _this = this;
        var weights = inferenceArrays.get(this.wTensor);
        var x = inferenceArrays.get(this.xTensor);
        var dy = gradientArrays.get(this.yTensor);
        math.scope(function () {
            var _a = math.conv2dBackProp(x, dy, weights, _this.stride, _this.zeroPad), dw = _a.dw, db = _a.db, dx = _a.dx;
            gradientArrays.add(_this.wTensor, dw);
            gradientArrays.add(_this.bTensor, db);
            gradientArrays.add(_this.xTensor, dx);
        });
    };
    Convolution2D.prototype.assertWeightsShape = function (weightsShape) {
        util.assert(weightsShape[0] === this.fieldSize &&
            weightsShape[1] === this.fieldSize &&
            weightsShape[2] === this.xTensor.shape[2] &&
            weightsShape[3] === this.outputDepth, "weights must be of shape [" + this.fieldSize + "," + this.fieldSize + "," +
            (this.xTensor.shape[2] + "," + this.outputDepth + "] but they are of") +
            ("shape [" + weightsShape + "]"));
    };
    return Convolution2D;
}(op_1.Operation));
exports.Convolution2D = Convolution2D;

},{"../../math/conv_util":49,"../../util":88,"./op":25}],16:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var util = require("../../util");
var graph_util = require("../graph_util");
var op_1 = require("./op");
var Divide = (function (_super) {
    __extends(Divide, _super);
    function Divide(x1Tensor, x2Tensor, yTensor) {
        var _this = _super.call(this) || this;
        _this.x1Tensor = x1Tensor;
        _this.x2Tensor = x2Tensor;
        _this.yTensor = yTensor;
        util.assert(util.sizeFromShape(x1Tensor.shape) === 1 ||
            util.sizeFromShape(x2Tensor.shape) === 1 ||
            util.arraysEqual(x1Tensor.shape, x2Tensor.shape), 'One of t1 or t2 must be a scalar, or t1 and t2 must have ' +
            'the same shape');
        return _this;
    }
    Divide.prototype.feedForward = function (math, inferenceArrays) {
        var _this = this;
        var t1 = inferenceArrays.get(this.x1Tensor);
        var t2 = inferenceArrays.get(this.x2Tensor);
        math.scope(function (keep) {
            var result;
            if (util.isScalarShape(t1.shape)) {
                result = math.scalarDividedByArray(t1, t2);
            }
            else if (util.isScalarShape(t2.shape)) {
                result = math.arrayDividedByScalar(t1, t2);
            }
            else {
                result = math.divide(t1, t2);
            }
            inferenceArrays.set(_this.yTensor, keep(result));
        });
    };
    Divide.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
        var _this = this;
        var x1 = inferenceArrays.get(this.x1Tensor);
        var x2 = inferenceArrays.get(this.x2Tensor);
        var dy = gradientArrays.get(this.yTensor);
        var x1IsScalar = util.isScalarShape(x1.shape);
        var x2IsScalar = util.isScalarShape(x2.shape);
        math.scope(function () {
            if (graph_util.shouldBackProp(_this.x1Tensor)) {
                if (x1IsScalar) {
                    var div = math.divide(dy, x2);
                    gradientArrays.add(_this.x1Tensor, math.sum(div));
                    div.dispose();
                }
                else if (x2IsScalar) {
                    gradientArrays.add(_this.x1Tensor, math.arrayDividedByScalar(dy, x2));
                }
                else {
                    gradientArrays.add(_this.x1Tensor, math.divide(dy, x2));
                }
            }
            if (graph_util.shouldBackProp(_this.x2Tensor)) {
                var x2Squared = math.elementWiseMul(x2, x2);
                var x1OverX2Squared = void 0;
                if (x2IsScalar) {
                    x1OverX2Squared = math.arrayDividedByScalar(x1, x2Squared);
                }
                else if (x1IsScalar) {
                    x1OverX2Squared = math.scalarDividedByArray(x1, x2Squared);
                }
                else {
                    x1OverX2Squared = math.divide(x1, x2Squared);
                }
                var dx2 = math.neg(x1OverX2Squared);
                var dyTimesDerivative = math.elementWiseMul(dy, dx2);
                if (x2IsScalar) {
                    gradientArrays.add(_this.x2Tensor, math.sum(dyTimesDerivative));
                }
                else {
                    gradientArrays.add(_this.x2Tensor, dyTimesDerivative);
                }
            }
        });
    };
    return Divide;
}(op_1.Operation));
exports.Divide = Divide;

},{"../../util":88,"../graph_util":9,"./op":25}],17:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var activation_functions_1 = require("../../math/activation_functions");
var op_1 = require("./op");
var ElementWiseActivation = (function (_super) {
    __extends(ElementWiseActivation, _super);
    function ElementWiseActivation(xTensor, yTensor, func) {
        var _this = _super.call(this) || this;
        _this.xTensor = xTensor;
        _this.yTensor = yTensor;
        _this.func = func;
        return _this;
    }
    ElementWiseActivation.prototype.feedForward = function (math, inferenceArrays) {
        var _this = this;
        var x = inferenceArrays.get(this.xTensor);
        math.scope(function (keep) {
            inferenceArrays.set(_this.yTensor, keep(_this.func.output(math, x)));
        });
    };
    ElementWiseActivation.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
        var _this = this;
        var x = inferenceArrays.get(this.xTensor);
        var y = inferenceArrays.get(this.yTensor);
        var dy = gradientArrays.get(this.yTensor);
        math.scope(function () {
            var dydx = _this.func.der(math, x, y);
            gradientArrays.add(_this.xTensor, math.elementWiseMul(dy, dydx));
            dydx.dispose();
        });
    };
    ElementWiseActivation.prototype.dispose = function () {
        this.func.dispose();
    };
    return ElementWiseActivation;
}(op_1.Operation));
exports.ElementWiseActivation = ElementWiseActivation;
var ReLU = (function (_super) {
    __extends(ReLU, _super);
    function ReLU(xTensor, yTensor) {
        return _super.call(this, xTensor, yTensor, new activation_functions_1.ReLUFunc()) || this;
    }
    return ReLU;
}(ElementWiseActivation));
exports.ReLU = ReLU;
var LeakyReLU = (function (_super) {
    __extends(LeakyReLU, _super);
    function LeakyReLU(xTensor, yTensor, alpha) {
        return _super.call(this, xTensor, yTensor, new activation_functions_1.LeakyReluFunc(alpha)) || this;
    }
    return LeakyReLU;
}(ElementWiseActivation));
exports.LeakyReLU = LeakyReLU;
var TanH = (function (_super) {
    __extends(TanH, _super);
    function TanH(xTensor, yTensor) {
        return _super.call(this, xTensor, yTensor, new activation_functions_1.TanHFunc()) || this;
    }
    return TanH;
}(ElementWiseActivation));
exports.TanH = TanH;
var Sigmoid = (function (_super) {
    __extends(Sigmoid, _super);
    function Sigmoid(xTensor, yTensor) {
        return _super.call(this, xTensor, yTensor, new activation_functions_1.SigmoidFunc()) || this;
    }
    return Sigmoid;
}(ElementWiseActivation));
exports.Sigmoid = Sigmoid;
var Square = (function (_super) {
    __extends(Square, _super);
    function Square(xTensor, yTensor) {
        return _super.call(this, xTensor, yTensor, new activation_functions_1.SquareFunc()) || this;
    }
    return Square;
}(ElementWiseActivation));
exports.Square = Square;

},{"../../math/activation_functions":45,"./op":25}],18:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var cost_functions_1 = require("../../math/cost_functions");
var ndarray_1 = require("../../math/ndarray");
var util = require("../../util");
var graph_util = require("../graph_util");
var op_1 = require("./op");
var ElementWiseCost = (function (_super) {
    __extends(ElementWiseCost, _super);
    function ElementWiseCost(x1Tensor, x2Tensor, yTensor, func) {
        var _this = _super.call(this) || this;
        _this.x1Tensor = x1Tensor;
        _this.x2Tensor = x2Tensor;
        _this.yTensor = yTensor;
        _this.func = func;
        _this.oneOverNScalar = ndarray_1.Scalar.new(1 / util.sizeFromShape(x1Tensor.shape));
        return _this;
    }
    ElementWiseCost.prototype.feedForward = function (math, inferenceArrays) {
        var _this = this;
        var x1 = inferenceArrays.get(this.x1Tensor);
        var x2 = inferenceArrays.get(this.x2Tensor);
        math.scope(function (keep) {
            var elementWiseCost = _this.func.cost(math, x1, x2);
            var sum = math.sum(elementWiseCost);
            var result = math.scalarTimesArray(_this.oneOverNScalar, sum);
            inferenceArrays.set(_this.yTensor, keep(result));
        });
    };
    ElementWiseCost.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
        var _this = this;
        var x1 = inferenceArrays.get(this.x1Tensor);
        var x2 = inferenceArrays.get(this.x2Tensor);
        math.scope(function () {
            if (graph_util.shouldBackProp(_this.x1Tensor)) {
                gradientArrays.add(_this.x1Tensor, _this.func.der(math, x1, x2));
            }
            if (graph_util.shouldBackProp(_this.x2Tensor)) {
                gradientArrays.add(_this.x2Tensor, _this.func.der(math, x2, x1));
            }
        });
    };
    ElementWiseCost.prototype.dispose = function () {
        this.func.dispose();
        this.oneOverNScalar.dispose();
    };
    return ElementWiseCost;
}(op_1.Operation));
exports.ElementWiseCost = ElementWiseCost;
var MeanSquaredCost = (function (_super) {
    __extends(MeanSquaredCost, _super);
    function MeanSquaredCost(x1Tensor, x2Tensor, yTensor) {
        return _super.call(this, x1Tensor, x2Tensor, yTensor, new cost_functions_1.SquareCostFunc()) || this;
    }
    return MeanSquaredCost;
}(ElementWiseCost));
exports.MeanSquaredCost = MeanSquaredCost;

},{"../../math/cost_functions":51,"../../math/ndarray":55,"../../util":88,"../graph_util":9,"./op":25}],19:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var graph_util = require("../graph_util");
var op_1 = require("./op");
var Exp = (function (_super) {
    __extends(Exp, _super);
    function Exp(xTensor, yTensor) {
        var _this = _super.call(this) || this;
        _this.xTensor = xTensor;
        _this.yTensor = yTensor;
        return _this;
    }
    Exp.prototype.feedForward = function (math, inferenceArrays) {
        var _this = this;
        var x = inferenceArrays.get(this.xTensor);
        math.scope(function (keep) {
            inferenceArrays.set(_this.yTensor, keep(math.exp(x)));
        });
    };
    Exp.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
        var _this = this;
        var y = inferenceArrays.get(this.yTensor);
        var dy = gradientArrays.get(this.yTensor);
        math.scope(function () {
            if (graph_util.shouldBackProp(_this.xTensor)) {
                gradientArrays.add(_this.xTensor, math.elementWiseMul(y, dy));
            }
        });
    };
    return Exp;
}(op_1.Operation));
exports.Exp = Exp;

},{"../graph_util":9,"./op":25}],20:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var graph_util = require("../graph_util");
var op_1 = require("./op");
var LinearCombination = (function (_super) {
    __extends(LinearCombination, _super);
    function LinearCombination(x1Tensor, x2Tensor, c1Tensor, c2Tensor, outTensor) {
        var _this = _super.call(this) || this;
        _this.x1Tensor = x1Tensor;
        _this.x2Tensor = x2Tensor;
        _this.c1Tensor = c1Tensor;
        _this.c2Tensor = c2Tensor;
        _this.outTensor = outTensor;
        return _this;
    }
    LinearCombination.prototype.feedForward = function (math, inferenceArrays) {
        var _this = this;
        var x1 = inferenceArrays.get(this.x1Tensor);
        var x2 = inferenceArrays.get(this.x2Tensor);
        var c1 = inferenceArrays.get(this.c1Tensor).asScalar();
        var c2 = inferenceArrays.get(this.c2Tensor).asScalar();
        math.scope(function (keep) {
            inferenceArrays.set(_this.outTensor, keep(math.scaledArrayAdd(c1, x1, c2, x2)));
        });
    };
    LinearCombination.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
        var _this = this;
        var x1 = inferenceArrays.get(this.x1Tensor);
        var x2 = inferenceArrays.get(this.x2Tensor);
        var c1 = inferenceArrays.get(this.c1Tensor);
        var c2 = inferenceArrays.get(this.c2Tensor);
        var dy = gradientArrays.get(this.outTensor);
        math.scope(function () {
            if (graph_util.shouldBackProp(_this.x1Tensor)) {
                gradientArrays.add(_this.x1Tensor, math.scalarTimesArray(c1, dy));
            }
            if (graph_util.shouldBackProp(_this.x2Tensor)) {
                gradientArrays.add(_this.x2Tensor, math.scalarTimesArray(c2, dy));
            }
            if (graph_util.shouldBackProp(_this.c1Tensor)) {
                var dotProduct1 = math.elementWiseMul(x1, dy);
                gradientArrays.add(_this.c1Tensor, math.sum(dotProduct1));
            }
            if (graph_util.shouldBackProp(_this.c2Tensor)) {
                var dotProduct2 = math.elementWiseMul(x2, dy);
                gradientArrays.add(_this.c2Tensor, math.sum(dotProduct2));
            }
        });
    };
    return LinearCombination;
}(op_1.Operation));
exports.LinearCombination = LinearCombination;

},{"../graph_util":9,"./op":25}],21:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var graph_util = require("../graph_util");
var op_1 = require("./op");
var Log = (function (_super) {
    __extends(Log, _super);
    function Log(xTensor, yTensor) {
        var _this = _super.call(this) || this;
        _this.xTensor = xTensor;
        _this.yTensor = yTensor;
        return _this;
    }
    Log.prototype.feedForward = function (math, inferenceArrays) {
        var _this = this;
        var x = inferenceArrays.get(this.xTensor);
        math.scope(function (keep) {
            inferenceArrays.set(_this.yTensor, keep(math.log(x)));
        });
    };
    Log.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
        var _this = this;
        var x = inferenceArrays.get(this.xTensor);
        var dy = gradientArrays.get(this.yTensor);
        math.scope(function () {
            if (graph_util.shouldBackProp(_this.xTensor)) {
                gradientArrays.add(_this.xTensor, math.divide(dy, x));
            }
        });
    };
    return Log;
}(op_1.Operation));
exports.Log = Log;

},{"../graph_util":9,"./op":25}],22:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var math_1 = require("../../math/math");
var graph_util = require("../graph_util");
var op_1 = require("./op");
var MatMul = (function (_super) {
    __extends(MatMul, _super);
    function MatMul(x1Tensor, x2Tensor, yTensor) {
        var _this = _super.call(this) || this;
        _this.x1Tensor = x1Tensor;
        _this.x2Tensor = x2Tensor;
        _this.yTensor = yTensor;
        return _this;
    }
    MatMul.prototype.feedForward = function (math, inferenceArrays) {
        var _this = this;
        var x1 = inferenceArrays.get(this.x1Tensor);
        var x2 = inferenceArrays.get(this.x2Tensor);
        math.scope(function (keep) {
            if (x1.shape.length === 2 && x2.shape.length === 2) {
                inferenceArrays.set(_this.yTensor, keep(math.matMul(x1, x2)));
            }
            else if (x1.shape.length === 2 && x2.shape.length === 1) {
                inferenceArrays.set(_this.yTensor, keep(math.matrixTimesVector(x1, x2)));
            }
            else if (x1.shape.length === 1 && x2.shape.length === 2) {
                inferenceArrays.set(_this.yTensor, keep(math.vectorTimesMatrix(x1, x2)));
            }
        });
    };
    MatMul.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
        var _this = this;
        var x1 = inferenceArrays.get(this.x1Tensor);
        var x2 = inferenceArrays.get(this.x2Tensor);
        var dy = gradientArrays.get(this.yTensor);
        if (x1.shape.length === 1) {
            x1 = x1.reshape([1, x1.size]);
            dy = dy.reshape([1, dy.size]);
        }
        if (x2.shape.length === 1) {
            x2 = x2.reshape([x2.size, 1]);
            dy = dy.reshape([dy.size, 1]);
        }
        math.scope(function () {
            if (graph_util.shouldBackProp(_this.x1Tensor)) {
                var dx1 = math.matMul(dy, x2, math_1.MatrixOrientation.REGULAR, math_1.MatrixOrientation.TRANSPOSED);
                gradientArrays.add(_this.x1Tensor, _this.x1Tensor.shape.length === 1 ? dx1.as1D() : dx1);
            }
            if (graph_util.shouldBackProp(_this.x2Tensor)) {
                var dx2 = math.matMul(x1, dy, math_1.MatrixOrientation.TRANSPOSED, math_1.MatrixOrientation.REGULAR);
                gradientArrays.add(_this.x2Tensor, _this.x2Tensor.shape.length === 1 ? dx2.as1D() : dx2);
            }
        });
    };
    return MatMul;
}(op_1.Operation));
exports.MatMul = MatMul;

},{"../../math/math":52,"../graph_util":9,"./op":25}],23:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var conv_util = require("../../math/conv_util");
var util = require("../../util");
var op_1 = require("./op");
var MaxPool = (function (_super) {
    __extends(MaxPool, _super);
    function MaxPool(xTensor, yTensor, fieldSize, stride, pad) {
        if (stride === void 0) { stride = 1; }
        var _this = _super.call(this) || this;
        _this.xTensor = xTensor;
        _this.yTensor = yTensor;
        _this.fieldSize = fieldSize;
        _this.stride = stride;
        if (pad != null) {
            _this.pad = pad;
        }
        else {
            _this.pad = conv_util.computeDefaultPad(xTensor.shape, _this.fieldSize, _this.stride);
        }
        util.assert(util.isInt(_this.pad), "The zero padding (" + _this.pad + ") must be an integer. Change the " +
            "stride and/or zero pad parameters");
        return _this;
    }
    MaxPool.prototype.feedForward = function (math, inferenceArrays) {
        var _this = this;
        var x = inferenceArrays.get(this.xTensor);
        math.scope(function (keep) {
            inferenceArrays.set(_this.yTensor, keep(math.maxPool(x, _this.fieldSize, _this.stride, _this.pad)));
        });
    };
    MaxPool.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
        var _this = this;
        var x = inferenceArrays.get(this.xTensor);
        var dy = gradientArrays.get(this.yTensor);
        math.scope(function () {
            gradientArrays.add(_this.xTensor, math.maxPoolBackprop(dy, x, _this.fieldSize, _this.stride, _this.pad));
        });
    };
    return MaxPool;
}(op_1.Operation));
exports.MaxPool = MaxPool;

},{"../../math/conv_util":49,"../../util":88,"./op":25}],24:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var util = require("../../util");
var graph_util = require("../graph_util");
var op_1 = require("./op");
var Multiply = (function (_super) {
    __extends(Multiply, _super);
    function Multiply(x1Tensor, x2Tensor, yTensor) {
        var _this = _super.call(this) || this;
        _this.x1Tensor = x1Tensor;
        _this.x2Tensor = x2Tensor;
        _this.yTensor = yTensor;
        util.assert(util.sizeFromShape(x1Tensor.shape) === 1 ||
            util.sizeFromShape(x2Tensor.shape) === 1 ||
            util.arraysEqual(x1Tensor.shape, x2Tensor.shape), 'One of t1 or t2 must be a scalar, or t1 and t2 must have ' +
            'the same shape');
        return _this;
    }
    Multiply.prototype.feedForward = function (math, inferenceArrays) {
        var _this = this;
        var t1 = inferenceArrays.get(this.x1Tensor);
        var t2 = inferenceArrays.get(this.x2Tensor);
        math.scope(function (keep) {
            var result;
            if (util.isScalarShape(t1.shape)) {
                result = math.scalarTimesArray(t1, t2);
            }
            else if (util.isScalarShape(t2.shape)) {
                result = math.scalarTimesArray(t2, t1);
            }
            else {
                result = math.elementWiseMul(t1, t2);
            }
            inferenceArrays.set(_this.yTensor, keep(result));
        });
    };
    Multiply.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
        var _this = this;
        var x1 = inferenceArrays.get(this.x1Tensor);
        var x2 = inferenceArrays.get(this.x2Tensor);
        var dy = gradientArrays.get(this.yTensor);
        math.scope(function () {
            if (graph_util.shouldBackProp(_this.x1Tensor)) {
                if (util.isScalarShape(_this.x1Tensor.shape)) {
                    var mul = math.elementWiseMul(dy, x2);
                    gradientArrays.add(_this.x1Tensor, math.sum(mul));
                }
                else if (util.isScalarShape(x2.shape)) {
                    gradientArrays.add(_this.x1Tensor, math.scalarTimesArray(x2, dy));
                }
                else {
                    gradientArrays.add(_this.x1Tensor, math.elementWiseMul(x2, dy));
                }
            }
            if (graph_util.shouldBackProp(_this.x2Tensor)) {
                if (util.isScalarShape(_this.x2Tensor.shape)) {
                    var mul = math.elementWiseMul(dy, x1);
                    gradientArrays.add(_this.x2Tensor, math.sum(mul));
                }
                else if (util.isScalarShape(x1.shape)) {
                    gradientArrays.add(_this.x2Tensor, math.scalarTimesArray(x1, dy));
                }
                else {
                    gradientArrays.add(_this.x2Tensor, math.elementWiseMul(x1, dy));
                }
            }
        });
    };
    return Multiply;
}(op_1.Operation));
exports.Multiply = Multiply;

},{"../../util":88,"../graph_util":9,"./op":25}],25:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Operation = (function () {
    function Operation() {
    }
    Operation.prototype.disposeTransientArrays = function (inferenceArrays, gradientArrays) { };
    Operation.prototype.dispose = function () { };
    return Operation;
}());
exports.Operation = Operation;

},{}],26:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ndarray_1 = require("../../math/ndarray");
var util = require("../../util");
var graph_util = require("../graph_util");
var op_1 = require("./op");
var ReduceSum = (function (_super) {
    __extends(ReduceSum, _super);
    function ReduceSum(x, outTensor) {
        var _this = _super.call(this) || this;
        _this.x = x;
        _this.outTensor = outTensor;
        util.assertShapesMatch(outTensor.shape, []);
        return _this;
    }
    ReduceSum.prototype.feedForward = function (math, inferenceArrays) {
        var _this = this;
        var x = inferenceArrays.get(this.x);
        math.scope(function (keep) {
            inferenceArrays.set(_this.outTensor, keep(math.sum(x)));
        });
    };
    ReduceSum.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
        var _this = this;
        if (!graph_util.shouldBackProp(this.x)) {
            return;
        }
        math.scope(function () {
            var dy = gradientArrays.get(_this.outTensor);
            if (_this.ones == null) {
                var xArray = inferenceArrays.get(_this.x);
                _this.ones = ndarray_1.NDArray.zerosLike(xArray);
                _this.ones.fill(1);
            }
            gradientArrays.add(_this.x, math.scalarTimesArray(dy, _this.ones));
        });
    };
    return ReduceSum;
}(op_1.Operation));
exports.ReduceSum = ReduceSum;

},{"../../math/ndarray":55,"../../util":88,"../graph_util":9,"./op":25}],27:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var util = require("../../util");
var op_1 = require("./op");
var Reshape = (function (_super) {
    __extends(Reshape, _super);
    function Reshape(xTensor, yTensor) {
        var _this = _super.call(this) || this;
        _this.xTensor = xTensor;
        _this.yTensor = yTensor;
        var xSize = util.sizeFromShape(xTensor.shape);
        var ySize = util.sizeFromShape(yTensor.shape);
        util.assert(xSize === ySize, "The input size (" + xSize + ") and output size (" + ySize + ") must match");
        return _this;
    }
    Reshape.prototype.feedForward = function (math, inferenceArrays) {
        var _this = this;
        var x = inferenceArrays.get(this.xTensor);
        var clone = math.clone(x);
        math.scope(function (keep) {
            inferenceArrays.set(_this.yTensor, keep(clone.reshape(_this.yTensor.shape)));
        });
    };
    Reshape.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
        var _this = this;
        var dy = gradientArrays.get(this.yTensor);
        var clone = math.clone(dy);
        math.scope(function () {
            gradientArrays.add(_this.xTensor, clone.reshape(_this.xTensor.shape));
        });
    };
    return Reshape;
}(op_1.Operation));
exports.Reshape = Reshape;

},{"../../util":88,"./op":25}],28:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ndarray_1 = require("../../math/ndarray");
var util = require("../../util");
var graph_1 = require("../graph");
var op_1 = require("./op");
var Softmax = (function (_super) {
    __extends(Softmax, _super);
    function Softmax(logitsTensor, output) {
        var _this = _super.call(this) || this;
        _this.logitsTensor = logitsTensor;
        _this.output = output;
        return _this;
    }
    Softmax.prototype.feedForward = function (math, inferenceArrays) {
        var _this = this;
        var logits = inferenceArrays.get(this.logitsTensor);
        return math.scope(function (keep) {
            inferenceArrays.set(_this.output, keep(math.softmax(logits)));
        });
    };
    Softmax.prototype.backProp = function () {
        throw Error('Softmax backprop is not yet implemented');
    };
    return Softmax;
}(op_1.Operation));
exports.Softmax = Softmax;
var SoftmaxCrossEntropyCost = (function (_super) {
    __extends(SoftmaxCrossEntropyCost, _super);
    function SoftmaxCrossEntropyCost(logitsTensor, labelTensor, yTensor) {
        var _this = _super.call(this) || this;
        _this.logitsTensor = logitsTensor;
        _this.labelTensor = labelTensor;
        _this.yTensor = yTensor;
        _this.epsilon = ndarray_1.Scalar.new(1e-5);
        _this.softmaxTensor = new graph_1.Tensor(logitsTensor.shape);
        return _this;
    }
    SoftmaxCrossEntropyCost.prototype.feedForward = function (math, inferenceArrays) {
        var _this = this;
        var logits = inferenceArrays.get(this.logitsTensor);
        var label = inferenceArrays.get(this.labelTensor);
        math.scope(function (keep) {
            var softmaxResult = math.softmax(logits);
            inferenceArrays.set(_this.softmaxTensor, keep(softmaxResult));
            inferenceArrays.set(_this.yTensor, keep(crossEntropyCost(math, softmaxResult, label, _this.epsilon)));
        });
    };
    SoftmaxCrossEntropyCost.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
        var _this = this;
        var softmax = inferenceArrays.get(this.softmaxTensor);
        var label = inferenceArrays.get(this.labelTensor);
        math.scope(function () {
            gradientArrays.add(_this.logitsTensor, math.subtract(softmax, label));
        });
    };
    SoftmaxCrossEntropyCost.prototype.disposeTransientArrays = function (inferenceArrays, gradientArrays) {
        inferenceArrays.disposeArray(this.softmaxTensor);
    };
    SoftmaxCrossEntropyCost.prototype.dispose = function () {
        this.epsilon.dispose();
    };
    return SoftmaxCrossEntropyCost;
}(op_1.Operation));
exports.SoftmaxCrossEntropyCost = SoftmaxCrossEntropyCost;
function crossEntropyCost(math, y, target, epsilon) {
    util.assert(y.size === target.size, 'The output and target must be the same size');
    return math.scope(function () {
        var yPlusEps = math.scalarPlusArray(epsilon, y);
        var logOutput = math.log(yPlusEps);
        var tarLogOutput = math.elementWiseMul(target, logOutput);
        var costVector = math.neg(tarLogOutput);
        return math.sum(costVector);
    });
}
exports.crossEntropyCost = crossEntropyCost;

},{"../../math/ndarray":55,"../../util":88,"../graph":8,"./op":25}],29:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ndarray_1 = require("../../math/ndarray");
var util = require("../../util");
var graph_util = require("../graph_util");
var op_1 = require("./op");
var Subtract = (function (_super) {
    __extends(Subtract, _super);
    function Subtract(t1, t2, outTensor) {
        var _this = _super.call(this) || this;
        _this.t1 = t1;
        _this.t2 = t2;
        _this.outTensor = outTensor;
        util.assert(util.sizeFromShape(t1.shape) === 1 ||
            util.sizeFromShape(t2.shape) === 1 ||
            util.arraysEqual(t1.shape, t2.shape), 'One of t1 or t2 must be a scalar, or t1 and t2 must have ' +
            'the same shape');
        return _this;
    }
    Subtract.prototype.feedForward = function (math, inferenceArrays) {
        var _this = this;
        var t1 = inferenceArrays.get(this.t1);
        var t2 = inferenceArrays.get(this.t2);
        math.scope(function (keep) {
            var result;
            if (util.isScalarShape(t1.shape)) {
                result = math.scalarMinusArray(t1, t2);
            }
            else if (util.isScalarShape(t2.shape)) {
                result = math.arrayMinusScalar(t1, t2);
            }
            else {
                result = math.subtract(t1, t2);
            }
            inferenceArrays.set(_this.outTensor, keep(result));
        });
    };
    Subtract.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
        var _this = this;
        var dy = gradientArrays.get(this.outTensor);
        math.scope(function () {
            if (graph_util.shouldBackProp(_this.t1)) {
                if (util.isScalarShape(_this.t1.shape)) {
                    var sum = math.sum(dy);
                    if (_this.dySizeScalar == null) {
                        _this.dySizeScalar = ndarray_1.Scalar.new(dy.size);
                    }
                    gradientArrays.add(_this.t1, math.divide(sum, _this.dySizeScalar));
                }
                else {
                    gradientArrays.add(_this.t1, math.clone(dy));
                }
            }
            if (graph_util.shouldBackProp(_this.t2)) {
                if (util.isScalarShape(_this.t2.shape)) {
                    var sum = math.sum(dy);
                    var negSum = math.neg(sum);
                    if (_this.dySizeScalar == null) {
                        _this.dySizeScalar = ndarray_1.Scalar.new(dy.size);
                    }
                    gradientArrays.add(_this.t2, math.divide(negSum, _this.dySizeScalar));
                }
                else {
                    gradientArrays.add(_this.t2, math.neg(dy));
                }
            }
        });
    };
    Subtract.prototype.dispose = function () {
        if (this.dySizeScalar != null) {
            this.dySizeScalar.dispose();
        }
    };
    return Subtract;
}(op_1.Operation));
exports.Subtract = Subtract;

},{"../../math/ndarray":55,"../../util":88,"../graph_util":9,"./op":25}],30:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ndarray_1 = require("../../math/ndarray");
var tensor_array_map_1 = require("../tensor_array_map");
var optimizer_1 = require("./optimizer");
var AdadeltaOptimizer = (function (_super) {
    __extends(AdadeltaOptimizer, _super);
    function AdadeltaOptimizer(learningRate, gamma, specifiedVariableList) {
        var _this = _super.call(this, learningRate, specifiedVariableList) || this;
        _this.learningRate = learningRate;
        _this.gamma = gamma;
        _this.accumulatedSquaredGradients = new tensor_array_map_1.TensorArrayMap();
        _this.accumulatedUpdates = new tensor_array_map_1.TensorArrayMap();
        _this.eps = ndarray_1.Scalar.new(1e-6);
        _this.g = ndarray_1.Scalar.new(_this.gamma);
        return _this;
    }
    AdadeltaOptimizer.prototype.beforeBatch = function (math, batchSize, runtime, activationArrayMap, gradientArrayMap) {
        var _this = this;
        _super.prototype.beforeBatch.call(this, math, batchSize, runtime, activationArrayMap, gradientArrayMap);
        if (this.accumulatedSquaredGradients.size() === 0) {
            this.variableNodes.forEach(function (node) {
                _this.accumulatedSquaredGradients.set(node.output, ndarray_1.NDArray.zeros(node.output.shape));
                _this.accumulatedUpdates.set(node.output, ndarray_1.NDArray.zeros(node.output.shape));
            });
        }
    };
    AdadeltaOptimizer.prototype.afterBatch = function (math, batchSize, runtime, activationArrayMap, gradientArrayMap) {
        var _this = this;
        math.scope(function (keep) {
            _this.variableNodes.forEach(function (node) {
                var oldVariable = activationArrayMap.get(node.output);
                var gradient = _this.variableGradients.get(node.output);
                var oldCache = _this.accumulatedSquaredGradients.get(node.output);
                var oldUpdates = _this.accumulatedUpdates.get(node.output);
                var gradientSquare = math.multiply(gradient, gradient);
                var cache = math.scaledArrayAdd(_this.g, oldCache, math.subtract(_this.one, _this.g), gradientSquare);
                var updates = math.multiply(math.divide(math.sqrt(math.add(oldUpdates, _this.eps)), math.sqrt(math.add(oldCache, _this.eps))), gradient);
                var variable = math.scaledArrayAdd(_this.c, updates, _this.one, oldVariable);
                var updateSquare = math.multiply(updates, updates);
                var newUpdates = math.scaledArrayAdd(_this.g, oldUpdates, math.subtract(_this.one, _this.g), updateSquare);
                _this.accumulatedSquaredGradients.set(node.output, keep(cache));
                _this.accumulatedUpdates.set(node.output, keep(newUpdates));
                activationArrayMap.set(node.output, keep(variable));
                node.data = variable;
                oldVariable.dispose();
                oldCache.dispose();
                oldUpdates.dispose();
            });
        });
        this.variableGradients.dispose();
        this.variableGradients = new tensor_array_map_1.TensorArrayMap();
    };
    AdadeltaOptimizer.prototype.dispose = function () {
        _super.prototype.dispose.call(this);
        this.eps.dispose();
        this.g.dispose();
        this.accumulatedSquaredGradients.dispose();
        this.accumulatedUpdates.dispose();
    };
    return AdadeltaOptimizer;
}(optimizer_1.Optimizer));
exports.AdadeltaOptimizer = AdadeltaOptimizer;

},{"../../math/ndarray":55,"../tensor_array_map":41,"./optimizer":35}],31:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ndarray_1 = require("../../math/ndarray");
var tensor_array_map_1 = require("../tensor_array_map");
var optimizer_1 = require("./optimizer");
var AdagradOptimizer = (function (_super) {
    __extends(AdagradOptimizer, _super);
    function AdagradOptimizer(learningRate, specifiedVariableList) {
        var _this = _super.call(this, learningRate, specifiedVariableList) || this;
        _this.learningRate = learningRate;
        _this.accumulatedSquaredGradients = new tensor_array_map_1.TensorArrayMap();
        _this.eps = ndarray_1.Scalar.new(1e-6);
        return _this;
    }
    AdagradOptimizer.prototype.beforeBatch = function (math, batchSize, runtime, activationArrayMap, gradientArrayMap) {
        var _this = this;
        _super.prototype.beforeBatch.call(this, math, batchSize, runtime, activationArrayMap, gradientArrayMap);
        if (this.accumulatedSquaredGradients.size() === 0) {
            this.variableNodes.forEach(function (node) {
                _this.accumulatedSquaredGradients.set(node.output, ndarray_1.NDArray.zeros(node.output.shape));
            });
        }
    };
    AdagradOptimizer.prototype.afterBatch = function (math, batchSize, runtime, activationArrayMap, gradientArrayMap) {
        var _this = this;
        math.scope(function (keep) {
            _this.variableNodes.forEach(function (node) {
                var oldVariable = activationArrayMap.get(node.output);
                var gradient = _this.variableGradients.get(node.output);
                var oldCache = _this.accumulatedSquaredGradients.get(node.output);
                var gradientSquare = math.multiply(gradient, gradient);
                var cache = math.add(oldCache, gradientSquare);
                var variable = math.scaledArrayAdd(_this.c, math.divide(gradient, math.add(math.sqrt(cache), _this.eps)), _this.one, oldVariable);
                _this.accumulatedSquaredGradients.set(node.output, keep(cache));
                activationArrayMap.set(node.output, keep(variable));
                node.data = variable;
                oldVariable.dispose();
                oldCache.dispose();
            });
        });
        this.variableGradients.dispose();
        this.variableGradients = new tensor_array_map_1.TensorArrayMap();
    };
    AdagradOptimizer.prototype.dispose = function () {
        _super.prototype.dispose.call(this);
        this.eps.dispose();
        this.accumulatedSquaredGradients.dispose();
    };
    return AdagradOptimizer;
}(optimizer_1.Optimizer));
exports.AdagradOptimizer = AdagradOptimizer;

},{"../../math/ndarray":55,"../tensor_array_map":41,"./optimizer":35}],32:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ndarray_1 = require("../../math/ndarray");
var tensor_array_map_1 = require("../tensor_array_map");
var optimizer_1 = require("./optimizer");
var AdamOptimizer = (function (_super) {
    __extends(AdamOptimizer, _super);
    function AdamOptimizer(learningRate, beta1, beta2, specifiedVariableList) {
        var _this = _super.call(this, learningRate, specifiedVariableList) || this;
        _this.learningRate = learningRate;
        _this.beta1 = beta1;
        _this.beta2 = beta2;
        _this.firstMoment = new tensor_array_map_1.TensorArrayMap();
        _this.secondMoment = new tensor_array_map_1.TensorArrayMap();
        _this.eps = ndarray_1.Scalar.new(1e-8);
        _this.b1 = ndarray_1.Scalar.new(_this.beta1);
        _this.b2 = ndarray_1.Scalar.new(_this.beta2);
        _this.accB1 = ndarray_1.Scalar.new(_this.beta1);
        _this.accB2 = ndarray_1.Scalar.new(_this.beta2);
        return _this;
    }
    AdamOptimizer.prototype.beforeBatch = function (math, batchSize, runtime, activationArrayMap, gradientArrayMap) {
        var _this = this;
        _super.prototype.beforeBatch.call(this, math, batchSize, runtime, activationArrayMap, gradientArrayMap);
        if (this.firstMoment.size() === 0) {
            this.variableNodes.forEach(function (node) {
                _this.firstMoment.set(node.output, ndarray_1.NDArray.zeros(node.output.shape));
            });
        }
        if (this.secondMoment.size() === 0) {
            this.variableNodes.forEach(function (node) {
                _this.secondMoment.set(node.output, ndarray_1.NDArray.zeros(node.output.shape));
            });
        }
    };
    AdamOptimizer.prototype.afterBatch = function (math, batchSize, runtime, activationArrayMap, gradientArrayMap) {
        var _this = this;
        math.scope(function (keep) {
            _this.variableNodes.forEach(function (node) {
                var oldVariable = activationArrayMap.get(node.output);
                var gradient = _this.variableGradients.get(node.output);
                var oldFirstMoment = _this.firstMoment.get(node.output);
                var oldSecondMoment = _this.secondMoment.get(node.output);
                var newFirstMoment = math.scaledArrayAdd(_this.b1, oldFirstMoment, math.subtract(_this.one, _this.b1), gradient);
                var gradientSquare = math.multiply(gradient, gradient);
                var newSecondMoment = math.scaledArrayAdd(_this.b2, oldSecondMoment, math.subtract(_this.one, _this.b2), gradientSquare);
                var biasCorrectedFirstMoment = math.divide(newFirstMoment, math.subtract(_this.one, _this.accB1));
                var biasCorrectedSecondMoment = math.divide(newSecondMoment, math.subtract(_this.one, _this.accB2));
                var variable = math.scaledArrayAdd(_this.c, math.divide(biasCorrectedFirstMoment, math.add(math.sqrt(biasCorrectedSecondMoment), _this.eps)), _this.one, oldVariable);
                activationArrayMap.set(node.output, keep(variable));
                node.data = variable;
                _this.firstMoment.set(node.output, keep(newFirstMoment));
                _this.secondMoment.set(node.output, keep(newSecondMoment));
                oldVariable.dispose();
                gradient.dispose();
                oldFirstMoment.dispose();
                oldSecondMoment.dispose();
            });
            var oldAccB1 = _this.accB1;
            var oldAccB2 = _this.accB2;
            _this.accB1 = keep(math.multiply(_this.accB1, _this.b1));
            _this.accB2 = keep(math.multiply(_this.accB2, _this.b2));
            oldAccB1.dispose();
            oldAccB2.dispose();
        });
        this.variableGradients.dispose();
        this.variableGradients = new tensor_array_map_1.TensorArrayMap();
    };
    AdamOptimizer.prototype.dispose = function () {
        _super.prototype.dispose.call(this);
        this.firstMoment.dispose();
        this.secondMoment.dispose();
        this.eps.dispose();
        this.b1.dispose();
        this.b2.dispose();
        this.accB1.dispose();
        this.accB2.dispose();
    };
    return AdamOptimizer;
}(optimizer_1.Optimizer));
exports.AdamOptimizer = AdamOptimizer;

},{"../../math/ndarray":55,"../tensor_array_map":41,"./optimizer":35}],33:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ndarray_1 = require("../../math/ndarray");
var tensor_array_map_1 = require("../tensor_array_map");
var optimizer_1 = require("./optimizer");
var AdamaxOptimizer = (function (_super) {
    __extends(AdamaxOptimizer, _super);
    function AdamaxOptimizer(learningRate, beta1, beta2, specifiedVariableList) {
        var _this = _super.call(this, learningRate, specifiedVariableList) || this;
        _this.learningRate = learningRate;
        _this.beta1 = beta1;
        _this.beta2 = beta2;
        _this.firstMoment = new tensor_array_map_1.TensorArrayMap();
        _this.weightedInfNorm = new tensor_array_map_1.TensorArrayMap();
        _this.eps = ndarray_1.Scalar.new(1e-8);
        _this.b1 = ndarray_1.Scalar.new(_this.beta1);
        _this.b2 = ndarray_1.Scalar.new(_this.beta2);
        _this.accB1 = ndarray_1.Scalar.new(_this.beta1);
        return _this;
    }
    AdamaxOptimizer.prototype.beforeBatch = function (math, batchSize, runtime, activationArrayMap, gradientArrayMap) {
        var _this = this;
        _super.prototype.beforeBatch.call(this, math, batchSize, runtime, activationArrayMap, gradientArrayMap);
        if (this.firstMoment.size() === 0) {
            this.variableNodes.forEach(function (node) {
                _this.firstMoment.set(node.output, ndarray_1.NDArray.zeros(node.output.shape));
            });
        }
        if (this.weightedInfNorm.size() === 0) {
            this.variableNodes.forEach(function (node) {
                _this.weightedInfNorm.set(node.output, ndarray_1.NDArray.zeros(node.output.shape));
            });
        }
    };
    AdamaxOptimizer.prototype.afterBatch = function (math, batchSize, runtime, activationArrayMap, gradientArrayMap) {
        var _this = this;
        math.scope(function (keep) {
            _this.variableNodes.forEach(function (node) {
                var oldVariable = activationArrayMap.get(node.output);
                var gradient = _this.variableGradients.get(node.output);
                var oldFirstMoment = _this.firstMoment.get(node.output);
                var oldWeightedInfNorm = _this.weightedInfNorm.get(node.output);
                var newFirstMoment = math.scaledArrayAdd(_this.b1, oldFirstMoment, math.subtract(_this.one, _this.b1), gradient);
                var ut0 = math.multiply(_this.b2, oldWeightedInfNorm);
                var ut1 = math.abs(gradient);
                var newWeightedInfNorm = math.add(math.relu(math.subtract(ut0, ut1)), ut1);
                var variable = math.scaledArrayAdd(_this.one, oldVariable, math.divide(_this.c, math.subtract(_this.one, _this.accB1)), math.divide(newFirstMoment, math.add(_this.eps, newWeightedInfNorm)));
                activationArrayMap.set(node.output, keep(variable));
                node.data = variable;
                _this.firstMoment.set(node.output, keep(newFirstMoment));
                _this.weightedInfNorm.set(node.output, keep(newWeightedInfNorm));
                oldVariable.dispose();
                gradient.dispose();
                oldFirstMoment.dispose();
                oldWeightedInfNorm.dispose();
            });
            var oldAccB1 = _this.accB1;
            _this.accB1 = keep(math.multiply(_this.accB1, _this.b1));
            oldAccB1.dispose();
        });
        this.variableGradients.dispose();
        this.variableGradients = new tensor_array_map_1.TensorArrayMap();
    };
    AdamaxOptimizer.prototype.dispose = function () {
        _super.prototype.dispose.call(this);
        this.firstMoment.dispose();
        this.weightedInfNorm.dispose();
        this.eps.dispose();
        this.accB1.dispose();
        this.b1.dispose();
        this.b2.dispose();
    };
    return AdamaxOptimizer;
}(optimizer_1.Optimizer));
exports.AdamaxOptimizer = AdamaxOptimizer;

},{"../../math/ndarray":55,"../tensor_array_map":41,"./optimizer":35}],34:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ndarray_1 = require("../../math/ndarray");
var tensor_array_map_1 = require("../tensor_array_map");
var sgd_optimizer_1 = require("./sgd_optimizer");
var MomentumOptimizer = (function (_super) {
    __extends(MomentumOptimizer, _super);
    function MomentumOptimizer(learningRate, momentum, specifiedVariableList) {
        var _this = _super.call(this, learningRate, specifiedVariableList) || this;
        _this.learningRate = learningRate;
        _this.momentum = momentum;
        _this.variableVelocities = new tensor_array_map_1.TensorArrayMap();
        _this.m = ndarray_1.Scalar.new(_this.momentum);
        return _this;
    }
    MomentumOptimizer.prototype.beforeBatch = function (math, batchSize, runtime, activationArrayMap, gradientArrayMap) {
        var _this = this;
        _super.prototype.beforeBatch.call(this, math, batchSize, runtime, activationArrayMap, gradientArrayMap);
        if (this.variableVelocities.size() === 0) {
            this.variableNodes.forEach(function (node) {
                _this.variableVelocities.set(node.output, ndarray_1.NDArray.zeros(node.output.shape));
            });
        }
    };
    MomentumOptimizer.prototype.afterBatch = function (math, batchSize, runtime, activationArrayMap, gradientArrayMap) {
        var _this = this;
        math.scope(function (keep) {
            _this.variableNodes.forEach(function (node) {
                var oldVariable = activationArrayMap.get(node.output);
                var gradient = _this.variableGradients.get(node.output);
                var oldVelocity = _this.variableVelocities.get(node.output);
                var velocity = math.scaledArrayAdd(_this.m, oldVelocity, _this.one, gradient);
                var variable = math.scaledArrayAdd(_this.c, velocity, _this.one, oldVariable);
                _this.variableVelocities.set(node.output, keep(velocity));
                activationArrayMap.set(node.output, keep(variable));
                node.data = variable;
                oldVariable.dispose();
                oldVelocity.dispose();
            });
        });
        this.variableGradients.dispose();
        this.variableGradients = new tensor_array_map_1.TensorArrayMap();
    };
    MomentumOptimizer.prototype.dispose = function () {
        _super.prototype.dispose.call(this);
        this.m.dispose();
        this.variableVelocities.dispose();
    };
    MomentumOptimizer.prototype.setMomentum = function (momentum) {
        this.momentum = momentum;
    };
    return MomentumOptimizer;
}(sgd_optimizer_1.SGDOptimizer));
exports.MomentumOptimizer = MomentumOptimizer;

},{"../../math/ndarray":55,"../tensor_array_map":41,"./sgd_optimizer":37}],35:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ndarray_1 = require("../../math/ndarray");
var session_util = require("../session_util");
var tensor_array_map_1 = require("../tensor_array_map");
var Optimizer = (function () {
    function Optimizer(learningRate, specifiedVariableList) {
        this.learningRate = learningRate;
        this.variableGradients = new tensor_array_map_1.TensorArrayMap();
        this.one = ndarray_1.Scalar.new(1);
        if (specifiedVariableList != null) {
            this.specifiedVariableNodes = specifiedVariableList;
        }
    }
    Optimizer.prototype.beforeBatch = function (math, batchSize, runtime, activationArrayMap, gradientArrayMap) {
        var _this = this;
        this.variableNodes = this.specifiedVariableNodes == null ?
            session_util.getVariableNodesFromEvaluationSet(runtime.nodes) :
            this.specifiedVariableNodes;
        if (batchSize !== this.prevBatchSize) {
            if (this.c != null) {
                this.c.dispose();
            }
            this.prevBatchSize = batchSize;
            this.c = ndarray_1.Scalar.new(-this.learningRate / batchSize);
        }
        this.variableNodes.forEach(function (node) { return _this.variableGradients.set(node.output, ndarray_1.NDArray.zeros(node.output.shape)); });
    };
    Optimizer.prototype.afterExample = function (math, runtime, activationArrayMap, gradientArrayMap) {
        var _this = this;
        math.scope(function (keep) {
            _this.variableNodes.forEach(function (node) {
                var gradient = gradientArrayMap.get(node.output);
                var accumulatedGradient = _this.variableGradients.get(node.output);
                _this.variableGradients.set(node.output, keep(math.add(gradient, accumulatedGradient)));
                accumulatedGradient.dispose();
            });
        });
    };
    Optimizer.prototype.dispose = function () {
        if (this.c != null) {
            this.c.dispose();
        }
        this.one.dispose();
    };
    return Optimizer;
}());
exports.Optimizer = Optimizer;

},{"../../math/ndarray":55,"../session_util":40,"../tensor_array_map":41}],36:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ndarray_1 = require("../../math/ndarray");
var tensor_array_map_1 = require("../tensor_array_map");
var optimizer_1 = require("./optimizer");
var RMSPropOptimizer = (function (_super) {
    __extends(RMSPropOptimizer, _super);
    function RMSPropOptimizer(learningRate, gamma, specifiedVariableList) {
        var _this = _super.call(this, learningRate, specifiedVariableList) || this;
        _this.learningRate = learningRate;
        _this.gamma = gamma;
        _this.accumulatedSquaredGradients = new tensor_array_map_1.TensorArrayMap();
        _this.eps = ndarray_1.Scalar.new(1e-6);
        _this.g = ndarray_1.Scalar.new(_this.gamma);
        return _this;
    }
    RMSPropOptimizer.prototype.beforeBatch = function (math, batchSize, runtime, activationArrayMap, gradientArrayMap) {
        var _this = this;
        _super.prototype.beforeBatch.call(this, math, batchSize, runtime, activationArrayMap, gradientArrayMap);
        if (this.accumulatedSquaredGradients.size() === 0) {
            this.variableNodes.forEach(function (node) {
                _this.accumulatedSquaredGradients.set(node.output, ndarray_1.NDArray.zeros(node.output.shape));
            });
        }
    };
    RMSPropOptimizer.prototype.afterBatch = function (math, batchSize, runtime, activationArrayMap, gradientArrayMap) {
        var _this = this;
        math.scope(function (keep) {
            _this.variableNodes.forEach(function (node) {
                var oldVariable = activationArrayMap.get(node.output);
                var gradient = _this.variableGradients.get(node.output);
                var oldCache = _this.accumulatedSquaredGradients.get(node.output);
                var gradientSquare = math.multiply(gradient, gradient);
                var cache = math.scaledArrayAdd(_this.g, oldCache, math.subtract(_this.one, _this.g), gradientSquare);
                var variable = math.scaledArrayAdd(_this.c, math.divide(gradient, math.add(math.sqrt(cache), _this.eps)), _this.one, oldVariable);
                _this.accumulatedSquaredGradients.set(node.output, keep(cache));
                activationArrayMap.set(node.output, keep(variable));
                node.data = variable;
                oldVariable.dispose();
                oldCache.dispose();
            });
        });
        this.variableGradients.dispose();
        this.variableGradients = new tensor_array_map_1.TensorArrayMap();
    };
    RMSPropOptimizer.prototype.dispose = function () {
        _super.prototype.dispose.call(this);
        this.eps.dispose();
        this.g.dispose();
        this.accumulatedSquaredGradients.dispose();
    };
    return RMSPropOptimizer;
}(optimizer_1.Optimizer));
exports.RMSPropOptimizer = RMSPropOptimizer;

},{"../../math/ndarray":55,"../tensor_array_map":41,"./optimizer":35}],37:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var tensor_array_map_1 = require("../tensor_array_map");
var optimizer_1 = require("./optimizer");
var SGDOptimizer = (function (_super) {
    __extends(SGDOptimizer, _super);
    function SGDOptimizer(learningRate, specifiedVariableList) {
        var _this = _super.call(this, learningRate, specifiedVariableList) || this;
        _this.learningRate = learningRate;
        return _this;
    }
    SGDOptimizer.prototype.afterBatch = function (math, batchSize, runtime, activationArrayMap, gradientArrayMap) {
        var _this = this;
        math.scope(function (keep) {
            _this.variableNodes.forEach(function (node) {
                var oldVariable = activationArrayMap.get(node.output);
                var gradient = _this.variableGradients.get(node.output);
                var variable = math.scaledArrayAdd(_this.c, gradient, _this.one, oldVariable);
                activationArrayMap.set(node.output, keep(variable));
                node.data = variable;
                oldVariable.dispose();
            });
        });
        this.variableGradients.dispose();
        this.variableGradients = new tensor_array_map_1.TensorArrayMap();
    };
    SGDOptimizer.prototype.dispose = function () {
        _super.prototype.dispose.call(this);
    };
    SGDOptimizer.prototype.setLearningRate = function (learningRate) {
        this.learningRate = learningRate;
    };
    return SGDOptimizer;
}(optimizer_1.Optimizer));
exports.SGDOptimizer = SGDOptimizer;

},{"../tensor_array_map":41,"./optimizer":35}],38:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function defaultCompare(a, b) {
    if (a === b) {
        return 0;
    }
    else if (a < b) {
        return -1;
    }
    else {
        return 1;
    }
}
exports.defaultCompare = defaultCompare;
var PriorityQueue = (function () {
    function PriorityQueue(comparator, indexObserver) {
        this.comparator = comparator;
        this.indexObserver = indexObserver;
        this.heap = [];
    }
    PriorityQueue.prototype.enqueue = function (t) {
        this.heap.push(t);
        this.onIndexChanged(t, this.heap.length - 1);
        this.siftUp(this.heap.length - 1);
    };
    PriorityQueue.prototype.dequeue = function () {
        if (this.empty()) {
            throw new Error('dequeue called on empty priority queue.');
        }
        var t = this.heap[0];
        this.swap(0, this.heap.length - 1);
        this.heap.pop();
        this.siftDown(0);
        return t;
    };
    PriorityQueue.prototype.update = function (newT, index) {
        var last = (index === this.heap.length - 1);
        if (!last) {
            this.swap(index, this.heap.length - 1);
        }
        this.heap.pop();
        if (!last) {
            if (this.siftUpIndex(index) !== -1) {
                this.siftUp(index);
            }
            else if (this.siftDownIndex(index) !== -1) {
                this.siftDown(index);
            }
        }
        this.enqueue(newT);
    };
    PriorityQueue.prototype.empty = function () {
        return this.heap.length === 0;
    };
    PriorityQueue.prototype.onIndexChanged = function (t, newIndex) {
        if (this.indexObserver) {
            this.indexObserver(t, newIndex);
        }
    };
    PriorityQueue.prototype.getParentIndex = function (index) {
        if (index === 0) {
            return -1;
        }
        return Math.floor((index - 1) / 2);
    };
    PriorityQueue.prototype.getLeftChildIndex = function (index) {
        var candidate = index * 2 + 1;
        return candidate < this.heap.length ? candidate : -1;
    };
    PriorityQueue.prototype.getRightChildIndex = function (index) {
        var candidate = index * 2 + 2;
        return candidate < this.heap.length ? candidate : -1;
    };
    PriorityQueue.prototype.siftUpIndex = function (index) {
        var parentIndex = this.getParentIndex(index);
        if (parentIndex === -1) {
            return -1;
        }
        if (this.compare(parentIndex, index) > 0) {
            return parentIndex;
        }
        return -1;
    };
    PriorityQueue.prototype.siftUp = function (index) {
        var siftIndex = this.siftUpIndex(index);
        while (siftIndex !== -1) {
            this.swap(index, siftIndex);
            index = siftIndex;
            siftIndex = this.siftUpIndex(index);
        }
    };
    PriorityQueue.prototype.siftDownIndex = function (index) {
        if (index >= this.heap.length) {
            return -1;
        }
        var largestChildIndex = index;
        var leftChildIndex = this.getLeftChildIndex(index);
        if ((leftChildIndex !== -1) &&
            (this.compare(leftChildIndex, largestChildIndex) < 0)) {
            largestChildIndex = leftChildIndex;
        }
        var rightChildIndex = this.getRightChildIndex(index);
        if ((rightChildIndex !== -1) &&
            (this.compare(rightChildIndex, largestChildIndex) < 0)) {
            largestChildIndex = rightChildIndex;
        }
        return (largestChildIndex === index) ? -1 : largestChildIndex;
    };
    PriorityQueue.prototype.siftDown = function (index) {
        var siftIndex = this.siftDownIndex(index);
        while (siftIndex !== -1) {
            this.swap(index, siftIndex);
            index = siftIndex;
            siftIndex = this.siftDownIndex(index);
        }
    };
    PriorityQueue.prototype.compare = function (aIndex, bIndex) {
        return this.comparator(this.heap[aIndex], this.heap[bIndex]);
    };
    PriorityQueue.prototype.swap = function (a, b) {
        var temp = this.heap[a];
        this.heap[a] = this.heap[b];
        this.heap[b] = temp;
        this.onIndexChanged(this.heap[a], a);
        this.onIndexChanged(this.heap[b], b);
    };
    return PriorityQueue;
}());
exports.PriorityQueue = PriorityQueue;

},{}],39:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ndarray_1 = require("../math/ndarray");
var util = require("../util");
var operation_emitter = require("./operation_emitter");
var session_util = require("./session_util");
var tensor_array_map_1 = require("./tensor_array_map");
var FeedDictionary = (function () {
    function FeedDictionary(feedEntries) {
        var _this = this;
        this.dict = {};
        if (feedEntries) {
            feedEntries.forEach(function (entry) { return _this.dict[entry.tensor.id] = entry; });
        }
    }
    return FeedDictionary;
}());
exports.FeedDictionary = FeedDictionary;
var CostReduction;
(function (CostReduction) {
    CostReduction[CostReduction["NONE"] = 0] = "NONE";
    CostReduction[CostReduction["SUM"] = 1] = "SUM";
    CostReduction[CostReduction["MEAN"] = 2] = "MEAN";
})(CostReduction = exports.CostReduction || (exports.CostReduction = {}));
var Session = (function () {
    function Session(graph, math) {
        this.math = math;
        this.activationArrayMap = new tensor_array_map_1.TensorArrayMap();
        this.runtimeCache = {};
        this.oneScalar = ndarray_1.Scalar.new(1);
        this.gradientArrayMap = new tensor_array_map_1.SummedTensorArrayMap(this.math);
    }
    Session.prototype.dispose = function () {
        var _this = this;
        this.activationArrayMap.dispose();
        Object.keys(this.runtimeCache).forEach(function (key) {
            var runtime = _this.runtimeCache[key];
            if (runtime.operations) {
                runtime.operations.forEach(function (op) { return op.dispose(); });
            }
        });
        this.runtimeCache = {};
        if (this.batchSizeScalar != null) {
            this.batchSizeScalar.dispose();
        }
        this.oneScalar.dispose();
    };
    Session.prototype.evalAll = function (tensors, feedEntries) {
        var _this = this;
        return this.math.scope(function () {
            var feed = new FeedDictionary(feedEntries);
            var runtime = _this.getOrCreateRuntime(tensors, feed);
            var activations = _this.activationArrayMap;
            session_util.disposeAndInitializeOperationOutputs(runtime.nodes, activations);
            session_util.disposeTransientOperationArrays(runtime.operations, _this.activationArrayMap, _this.gradientArrayMap);
            session_util.addPersistentArraysToTensorArrayMap(runtime.nodes, activations);
            session_util.loadInputsFromFeedDictionaryToTensorArrayMap(feed, activations, _this.math);
            runtime.operations.forEach(function (op) { return op.feedForward(_this.math, activations); });
            var results = tensors.map(function (x) { return activations.get(x); });
            tensors.forEach(function (x) { return activations.delete(x); });
            session_util.releaseFeedDictionaryInputsFromTensorArrayMap(feed, activations, _this.math);
            return results;
        });
    };
    Session.prototype.eval = function (tensor, feedEntries) {
        return this.evalAll([tensor], feedEntries)[0];
    };
    Session.prototype.train = function (costTensor, feedEntries, batchSize, optimizer, costReduction) {
        var _this = this;
        if (costReduction === void 0) { costReduction = CostReduction.NONE; }
        util.assert(util.isScalarShape(costTensor.shape), 'Cost tensor for training must be a scalar value.');
        if (this.prevBatchSize !== batchSize) {
            this.prevBatchSize = batchSize;
            this.batchSizeScalar = ndarray_1.Scalar.new(batchSize);
        }
        var feed = new FeedDictionary(feedEntries);
        session_util.throwIfFeedDictionaryContainsNDArrays(feed);
        var runtime = this.getOrCreateRuntime([costTensor], feed);
        var inferenceOperations = runtime.operations;
        var backPropOperations = runtime.operations.slice().reverse();
        var activations = this.activationArrayMap;
        var gradients = this.gradientArrayMap;
        gradients.nullify(costTensor);
        gradients.add(costTensor, this.oneScalar);
        session_util.addPersistentArraysToTensorArrayMap(runtime.nodes, activations);
        optimizer.beforeBatch(this.math, batchSize, runtime, activations, gradients);
        return this.math.scope(function (keep, track) {
            var cost = track(ndarray_1.Scalar.new(0));
            for (var i = 0; i < batchSize; ++i) {
                session_util.disposeAndInitializeOperationOutputs(runtime.nodes, activations);
                session_util.disposeAndInitializeOperationInputGradients(runtime.nodes, gradients);
                session_util.disposeTransientOperationArrays(runtime.operations, activations, gradients);
                session_util.loadInputsFromFeedDictionaryToTensorArrayMap(feed, activations, _this.math);
                inferenceOperations.forEach(function (op) { return op.feedForward(_this.math, activations); });
                backPropOperations.forEach(function (op) { return op.backProp(_this.math, activations, gradients); });
                optimizer.afterExample(_this.math, runtime, activations, gradients);
                session_util.releaseFeedDictionaryInputsFromTensorArrayMap(feed, activations, _this.math);
                cost = _this.updateCostForExample(cost, activations.get(costTensor), costReduction);
            }
            optimizer.afterBatch(_this.math, batchSize, runtime, activations, gradients);
            return _this.updateCostForBatch(cost, costReduction);
        });
    };
    Session.prototype.updateCostForExample = function (totalCost, currCost, costReduction) {
        if (costReduction === CostReduction.MEAN ||
            costReduction === CostReduction.SUM) {
            return this.math.add(totalCost, currCost);
        }
        return totalCost;
    };
    Session.prototype.updateCostForBatch = function (totalCost, costReduction) {
        if (costReduction === CostReduction.MEAN) {
            return this.math.divide(totalCost, this.batchSizeScalar);
        }
        return totalCost;
    };
    Session.prototype.getOrCreateRuntime = function (tensors, feed) {
        var key = this.makeRuntimeCacheKey(tensors, feed);
        var runtime = this.runtimeCache[key];
        if (runtime === undefined) {
            var nodes = session_util.getOrderedEvaluationSetFromEvalTensor(tensors, feed);
            session_util.removeFeedDictionaryNodesFromEvaluationSet(feed, nodes);
            session_util.throwErrorIfEvaluationSetContainsPlaceholderNodes(nodes);
            var operations = operation_emitter.emitFromGraphNodes(nodes);
            runtime = { nodes: nodes, operations: operations };
            this.runtimeCache[key] = runtime;
        }
        return runtime;
    };
    Session.prototype.makeRuntimeCacheKey = function (tensors, feed) {
        return tensors.map(function (x) { return x.id; }).sort().join('_') + '__' +
            Object.keys(feed.dict).sort().join('_');
    };
    return Session;
}());
exports.Session = Session;

},{"../math/ndarray":55,"../util":88,"./operation_emitter":10,"./session_util":40,"./tensor_array_map":41}],40:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ndarray_1 = require("../math/ndarray");
var util = require("../util");
var graph_1 = require("./graph");
var graph_util = require("./graph_util");
function getTerminatingNodesFromFeedDictionary(feedDictionary) {
    return Object.keys(feedDictionary.dict)
        .map(function (tensorID) { return feedDictionary.dict[+tensorID].tensor.node; });
}
exports.getTerminatingNodesFromFeedDictionary = getTerminatingNodesFromFeedDictionary;
function getOrderedEvaluationSetFromEvalTensor(evalTensors, feedDictionary) {
    var terminatingNodes = getTerminatingNodesFromFeedDictionary(feedDictionary);
    var evalNodes = evalTensors.map(function (x) { return x.node; });
    var unorderedEvaluationSet = graph_util.getUnorderedEvaluationSet(evalNodes, terminatingNodes);
    var orderedEvaluationSet = graph_util.getOrderedEvaluationSet(unorderedEvaluationSet);
    return orderedEvaluationSet;
}
exports.getOrderedEvaluationSetFromEvalTensor = getOrderedEvaluationSetFromEvalTensor;
function addPersistentArraysToTensorArrayMap(evaluationSet, tensorArrayMap) {
    evaluationSet.forEach(function (node) {
        if (node instanceof graph_1.VariableNode || node instanceof graph_1.ConstantNode) {
            tensorArrayMap.set(node.output, node.data);
        }
    });
}
exports.addPersistentArraysToTensorArrayMap = addPersistentArraysToTensorArrayMap;
function getVariableNodesFromEvaluationSet(evaluationSet) {
    var nodes = [];
    evaluationSet.forEach(function (node) {
        if (node instanceof graph_1.VariableNode) {
            nodes.push(node);
        }
    });
    return nodes;
}
exports.getVariableNodesFromEvaluationSet = getVariableNodesFromEvaluationSet;
function throwIfFeedDictionaryContainsNDArrays(feedDictionary) {
    Object.keys(feedDictionary.dict).forEach(function (tensorID) {
        if (feedDictionary.dict[+tensorID].data instanceof ndarray_1.NDArray) {
            throw new Error('training requires FeedDictionary entries to be InputProviders' +
                'and not NDArrays.');
        }
    });
}
exports.throwIfFeedDictionaryContainsNDArrays = throwIfFeedDictionaryContainsNDArrays;
function loadInputsFromFeedDictionaryToTensorArrayMap(batchFeed, activations, math) {
    Object.keys(batchFeed.dict).forEach(function (tensorID) {
        var feedEntry = batchFeed.dict[+tensorID];
        var data;
        if (feedEntry.data instanceof ndarray_1.NDArray) {
            data = feedEntry.data;
        }
        else {
            var provider = feedEntry.data;
            data = provider.getNextCopy(math);
        }
        util.assert(util.arraysEqual(feedEntry.tensor.shape, data.shape), "Error loading FeedEntry: feeding NDArray of shape " + data.shape + " " +
            ("does not match Tensor (id: " + feedEntry.tensor.id + ") shape: ") +
            (feedEntry.tensor.shape + "."));
        activations.set(feedEntry.tensor, data);
    });
}
exports.loadInputsFromFeedDictionaryToTensorArrayMap = loadInputsFromFeedDictionaryToTensorArrayMap;
function releaseFeedDictionaryInputsFromTensorArrayMap(batchFeed, activations, math) {
    Object.keys(batchFeed.dict).forEach(function (tensorID) {
        var feedEntry = batchFeed.dict[+tensorID];
        if (!(feedEntry.data instanceof ndarray_1.NDArray)) {
            var provider = feedEntry.data;
            var feedEntryArray = activations.get(feedEntry.tensor);
            provider.disposeCopy(math, feedEntryArray);
        }
        activations.delete(feedEntry.tensor);
    });
}
exports.releaseFeedDictionaryInputsFromTensorArrayMap = releaseFeedDictionaryInputsFromTensorArrayMap;
function removeFeedDictionaryNodesFromEvaluationSet(feedDictionary, evaluationSet) {
    var i = 0;
    while (i < evaluationSet.length) {
        var node = evaluationSet[i];
        if (feedDictionary.dict[node.output.id] != null) {
            evaluationSet.splice(i, 1);
        }
        else {
            ++i;
        }
    }
}
exports.removeFeedDictionaryNodesFromEvaluationSet = removeFeedDictionaryNodesFromEvaluationSet;
function disposeAndInitializeOperationOutputs(evaluationSet, tensorArrayMap) {
    evaluationSet.forEach(function (node) {
        if (!graph_util.isInputNode(node)) {
            if (!graph_util.isPassthroughNode(node, tensorArrayMap)) {
                tensorArrayMap.disposeArray(node.output);
            }
            tensorArrayMap.set(node.output, null);
        }
    });
}
exports.disposeAndInitializeOperationOutputs = disposeAndInitializeOperationOutputs;
function disposeAndInitializeOperationInputGradients(evaluationSet, gradients) {
    evaluationSet.forEach(function (node) {
        Object.keys(node.inputs).forEach(function (inputName) {
            var input = node.inputs[inputName];
            if (gradients.get(input, true) !== gradients.get(node.output, true)) {
                gradients.disposeArray(input);
            }
            gradients.nullify(input);
        });
    });
}
exports.disposeAndInitializeOperationInputGradients = disposeAndInitializeOperationInputGradients;
function disposeTransientOperationArrays(operations, activations, gradients) {
    operations.forEach(function (op) { return op.disposeTransientArrays(activations, gradients); });
}
exports.disposeTransientOperationArrays = disposeTransientOperationArrays;
function throwErrorIfEvaluationSetContainsPlaceholderNodes(evaluationSet) {
    evaluationSet.forEach(function (node) {
        if (node instanceof graph_1.PlaceholderNode) {
            var shape = '[' + node.output.shape.join(', ') + ']';
            throw new Error('Placeholder node "' + node.name + '" ' + shape +
                ' not present in feed dictionary.');
        }
    });
}
exports.throwErrorIfEvaluationSetContainsPlaceholderNodes = throwErrorIfEvaluationSetContainsPlaceholderNodes;

},{"../math/ndarray":55,"../util":88,"./graph":8,"./graph_util":9}],41:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var TensorArrayMapBase = (function () {
    function TensorArrayMapBase() {
        this.dict = {};
    }
    TensorArrayMapBase.prototype.get = function (tensor, skipChecks) {
        if (skipChecks === void 0) { skipChecks = false; }
        if (!skipChecks && this.dict[tensor.id] === undefined) {
            throw new Error("tensor " + tensor.id + " not in array map.");
        }
        var nda = this.dict[tensor.id];
        if (!skipChecks && nda === null) {
            throw new Error("tensor " + tensor.id + " has null array.");
        }
        return nda;
    };
    TensorArrayMapBase.prototype.delete = function (tensor) {
        delete this.dict[tensor.id];
    };
    TensorArrayMapBase.prototype.nullify = function (tensor) {
        this.dict[tensor.id] = null;
    };
    TensorArrayMapBase.prototype.disposeArray = function (tensor) {
        if (this.dict[tensor.id] === undefined) {
            return;
        }
        var nda = this.dict[tensor.id];
        if (nda === null) {
            return;
        }
        nda.dispose();
        this.dict[tensor.id] = null;
    };
    TensorArrayMapBase.prototype.size = function () {
        return Object.keys(this.dict).length;
    };
    TensorArrayMapBase.prototype.dispose = function () {
        var _this = this;
        Object.keys(this.dict).forEach(function (tensorID) {
            var nda = _this.dict[+tensorID];
            if (nda) {
                nda.dispose();
            }
        });
        this.dict = {};
    };
    TensorArrayMapBase.prototype.hasNullArray = function (tensor) {
        if (this.dict[tensor.id] === undefined) {
            throw new Error("tensor " + tensor.id + " not in array map.");
        }
        return this.dict[tensor.id] === null;
    };
    return TensorArrayMapBase;
}());
exports.TensorArrayMapBase = TensorArrayMapBase;
var TensorArrayMap = (function (_super) {
    __extends(TensorArrayMap, _super);
    function TensorArrayMap() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    TensorArrayMap.prototype.set = function (tensor, array) {
        this.dict[tensor.id] = array;
    };
    return TensorArrayMap;
}(TensorArrayMapBase));
exports.TensorArrayMap = TensorArrayMap;
var SummedTensorArrayMap = (function (_super) {
    __extends(SummedTensorArrayMap, _super);
    function SummedTensorArrayMap(math) {
        var _this = _super.call(this) || this;
        _this.math = math;
        return _this;
    }
    SummedTensorArrayMap.prototype.add = function (tensor, array) {
        if (this.dict[tensor.id] == null) {
            this.dict[tensor.id] = this.math.keep(array);
        }
        else {
            var oldValue = this.get(tensor);
            var newValue = this.math.keep(this.math.addStrict(oldValue, array));
            this.dict[tensor.id] = newValue;
            oldValue.dispose();
        }
    };
    return SummedTensorArrayMap;
}(TensorArrayMapBase));
exports.SummedTensorArrayMap = SummedTensorArrayMap;

},{}],42:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var session_1 = require("./graph/session");
var ndarray_1 = require("./math/ndarray");
var DEFAULT_EVAL_INTERVAL_MS = 1500;
var DEFAULT_COST_INTERVAL_MS = 500;
var DEFAULT_INFERENCE_EXAMPLE_INTERVAL_MS = 3000;
var MetricReduction;
(function (MetricReduction) {
    MetricReduction[MetricReduction["SUM"] = 0] = "SUM";
    MetricReduction[MetricReduction["MEAN"] = 1] = "MEAN";
})(MetricReduction = exports.MetricReduction || (exports.MetricReduction = {}));
var GraphRunner = (function () {
    function GraphRunner(math, session, eventObserver) {
        this.math = math;
        this.session = session;
        this.eventObserver = eventObserver;
        this.lastCostTimestamp = 0;
        this.lastEvalTimestamp = 0;
        this.totalIdleTimeMs = 0;
        this.resetStatistics();
        this.zeroScalar = ndarray_1.Scalar.new(0);
    }
    GraphRunner.prototype.resetStatistics = function () {
        this.totalBatchesTrained = 0;
        this.totalIdleTimeMs = 0;
        this.lastStopTimestamp = null;
    };
    GraphRunner.prototype.train = function (costTensor, trainFeedEntries, batchSize, optimizer, numBatches, metricTensor, metricFeedEntries, metricBatchSize, metricReduction, evalIntervalMs, costIntervalMs) {
        if (metricReduction === void 0) { metricReduction = MetricReduction.MEAN; }
        if (evalIntervalMs === void 0) { evalIntervalMs = DEFAULT_EVAL_INTERVAL_MS; }
        if (costIntervalMs === void 0) { costIntervalMs = DEFAULT_COST_INTERVAL_MS; }
        this.costTensor = costTensor;
        this.trainFeedEntries = trainFeedEntries;
        this.metricTensor = metricTensor;
        this.metricFeedEntries = metricFeedEntries;
        if (metricBatchSize != null && this.metricBatchSize !== metricBatchSize) {
            if (this.metricBatchSizeScalar != null) {
                this.metricBatchSizeScalar.dispose();
            }
            this.metricBatchSizeScalar = ndarray_1.Scalar.new(metricBatchSize);
        }
        this.metricBatchSize = metricBatchSize;
        this.metricReduction = metricReduction;
        this.batchSize = batchSize;
        this.optimizer = optimizer;
        this.metricIntervalMs = evalIntervalMs;
        this.costIntervalMs = costIntervalMs;
        this.currentTrainLoopNumBatches = numBatches;
        this.batchesTrainedThisRun = 0;
        this.isTraining = true;
        this.trainStartTimestamp = performance.now();
        this.trainNetwork();
    };
    GraphRunner.prototype.stopTraining = function () {
        this.isTraining = false;
        this.lastStopTimestamp = performance.now();
    };
    GraphRunner.prototype.resumeTraining = function () {
        this.isTraining = true;
        if (this.lastStopTimestamp != null) {
            this.totalIdleTimeMs += performance.now() - this.lastStopTimestamp;
        }
        this.trainNetwork();
    };
    GraphRunner.prototype.trainNetwork = function () {
        var _this = this;
        if (this.batchesTrainedThisRun === this.currentTrainLoopNumBatches) {
            this.stopTraining();
        }
        if (!this.isTraining) {
            if (this.eventObserver.doneTrainingCallback != null) {
                this.eventObserver.doneTrainingCallback();
            }
            return;
        }
        var start = performance.now();
        var shouldComputeCost = this.eventObserver.avgCostCallback != null &&
            (start - this.lastCostTimestamp > this.costIntervalMs);
        if (shouldComputeCost) {
            this.lastCostTimestamp = start;
        }
        var costReduction = shouldComputeCost ? session_1.CostReduction.MEAN : session_1.CostReduction.NONE;
        this.math.scope(function (keep) {
            var avgCost = _this.session.train(_this.costTensor, _this.trainFeedEntries, _this.batchSize, _this.optimizer, costReduction);
            if (shouldComputeCost) {
                var trainTime = performance.now() - start;
                _this.eventObserver.avgCostCallback(avgCost);
                if (_this.eventObserver.trainExamplesPerSecCallback != null) {
                    var examplesPerSec = (_this.batchSize * 1000 / trainTime);
                    _this.eventObserver.trainExamplesPerSecCallback(examplesPerSec);
                }
            }
            if (_this.eventObserver.metricCallback != null &&
                _this.metricFeedEntries != null &&
                start - _this.lastEvalTimestamp > _this.metricIntervalMs) {
                _this.lastEvalTimestamp = start;
                if (_this.lastComputedMetric != null) {
                    _this.lastComputedMetric.dispose();
                }
                _this.lastComputedMetric = _this.computeMetric();
                _this.eventObserver.metricCallback(_this.lastComputedMetric);
            }
            if (_this.eventObserver.totalTimeCallback != null) {
                _this.eventObserver.totalTimeCallback((start - _this.trainStartTimestamp) / 1000);
            }
            _this.batchesTrainedThisRun++;
            _this.totalBatchesTrained++;
            if (_this.eventObserver.batchesTrainedCallback != null) {
                _this.eventObserver.batchesTrainedCallback(_this.totalBatchesTrained);
            }
        });
        requestAnimationFrame(function () { return _this.trainNetwork(); });
    };
    GraphRunner.prototype.infer = function (inferenceTensor, inferenceFeedEntries, inferenceExampleIntervalMs, inferenceExampleCount, numPasses) {
        var _this = this;
        if (inferenceExampleIntervalMs === void 0) { inferenceExampleIntervalMs = DEFAULT_INFERENCE_EXAMPLE_INTERVAL_MS; }
        if (inferenceExampleCount === void 0) { inferenceExampleCount = 5; }
        if (this.eventObserver.inferenceExamplesCallback == null &&
            this.eventObserver.inferenceExamplesPerSecCallback == null) {
            throw new Error('Cannot start inference loop, no inference example or ' +
                'examples/sec observer provided.');
        }
        for (var i = 0; i < inferenceFeedEntries.length; i++) {
            var feedEntry = inferenceFeedEntries[i];
            if (feedEntry.data instanceof ndarray_1.NDArray) {
                throw new Error('Cannot start inference on the model runner with feed entries of ' +
                    'type NDArray. Please use InputProviders.');
            }
        }
        this.inferenceExampleIntervalMs = inferenceExampleIntervalMs;
        this.inferenceTensor = inferenceTensor;
        this.inferenceFeedEntries = inferenceFeedEntries;
        this.inferenceExampleCount = inferenceExampleCount;
        this.currentInferenceLoopNumPasses = numPasses;
        if (!this.isInferring) {
            this.inferencePassesThisRun = 0;
            requestAnimationFrame(function () { return _this.inferNetwork(); });
        }
        this.isInferring = true;
    };
    GraphRunner.prototype.inferNetwork = function () {
        var _this = this;
        if (!this.isInferring ||
            this.inferencePassesThisRun === this.currentInferenceLoopNumPasses) {
            return;
        }
        this.math.scope(function (keep, track) {
            var feeds = [];
            var inferenceValues = [];
            var start = performance.now();
            for (var i = 0; i < _this.inferenceExampleCount; i++) {
                var ndarrayFeedEntries = [];
                for (var j = 0; j < _this.inferenceFeedEntries.length; j++) {
                    var feedEntry = _this.inferenceFeedEntries[j];
                    var nextCopy = feedEntry.data.getNextCopy(_this.math);
                    ndarrayFeedEntries.push({ tensor: feedEntry.tensor, data: track(nextCopy) });
                }
                feeds.push(ndarrayFeedEntries);
                inferenceValues.push(_this.session.eval(_this.inferenceTensor, ndarrayFeedEntries));
            }
            if (_this.eventObserver.inferenceExamplesPerSecCallback != null) {
                inferenceValues[inferenceValues.length - 1].getValues();
                var inferenceExamplesPerSecTime = performance.now() - start;
                var examplesPerSec = (_this.inferenceExampleCount * 1000 / inferenceExamplesPerSecTime);
                _this.eventObserver.inferenceExamplesPerSecCallback(examplesPerSec);
            }
            if (_this.eventObserver.inferenceExamplesCallback != null) {
                _this.eventObserver.inferenceExamplesCallback(feeds, inferenceValues);
            }
            _this.inferencePassesThisRun++;
        });
        this.lastInferTimeoutID = window.setTimeout(function () { return _this.inferNetwork(); }, this.inferenceExampleIntervalMs);
    };
    GraphRunner.prototype.stopInferring = function () {
        this.isInferring = false;
        window.clearTimeout(this.lastInferTimeoutID);
    };
    GraphRunner.prototype.isInferenceRunning = function () {
        return this.isInferring;
    };
    GraphRunner.prototype.computeMetric = function () {
        var _this = this;
        if (this.metricFeedEntries == null) {
            throw new Error('Cannot compute metric, no metric FeedEntries provided.');
        }
        var metric = this.zeroScalar;
        return this.math.scope(function (keep) {
            for (var i = 0; i < _this.metricBatchSize; i++) {
                var metricValue = _this.session.eval(_this.metricTensor, _this.metricFeedEntries);
                metric = _this.math.add(metric, metricValue);
            }
            if (_this.metricReduction === MetricReduction.MEAN) {
                metric = _this.math.divide(metric, _this.metricBatchSizeScalar);
            }
            return metric;
        });
    };
    GraphRunner.prototype.getTotalBatchesTrained = function () {
        return this.totalBatchesTrained;
    };
    GraphRunner.prototype.getLastComputedMetric = function () {
        return this.lastComputedMetric;
    };
    GraphRunner.prototype.setMath = function (math) {
        this.math = math;
    };
    GraphRunner.prototype.setSession = function (session) {
        this.session = session;
    };
    GraphRunner.prototype.setInferenceTensor = function (inferenceTensor) {
        this.inferenceTensor = inferenceTensor;
    };
    GraphRunner.prototype.setInferenceExampleCount = function (inferenceExampleCount) {
        this.inferenceExampleCount = inferenceExampleCount;
    };
    return GraphRunner;
}());
exports.GraphRunner = GraphRunner;

},{"./graph/session":39,"./math/ndarray":55}],43:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var xhr_dataset = require("./data/xhr-dataset");
exports.xhr_dataset = xhr_dataset;
var environment = require("./environment");
exports.environment = environment;
var conv_util = require("./math/conv_util");
exports.conv_util = conv_util;
var gpgpu_util = require("./math/webgl/gpgpu_util");
exports.gpgpu_util = gpgpu_util;
var render_ndarray_gpu_util = require("./math/webgl/render_ndarray_gpu_util");
exports.render_ndarray_gpu_util = render_ndarray_gpu_util;
var webgl_util = require("./math/webgl/webgl_util");
exports.webgl_util = webgl_util;
var test_util = require("./test_util");
exports.test_util = test_util;
var util = require("./util");
exports.util = util;
var version_1 = require("./version");
exports.version = version_1.version;
var checkpoint_loader_1 = require("./data/checkpoint_loader");
exports.CheckpointLoader = checkpoint_loader_1.CheckpointLoader;
var dataset_1 = require("./data/dataset");
exports.InMemoryDataset = dataset_1.InMemoryDataset;
var input_provider_1 = require("./data/input_provider");
exports.InCPUMemoryShuffledInputProviderBuilder = input_provider_1.InCPUMemoryShuffledInputProviderBuilder;
exports.InGPUMemoryShuffledInputProviderBuilder = input_provider_1.InGPUMemoryShuffledInputProviderBuilder;
var xhr_dataset_1 = require("./data/xhr-dataset");
exports.XhrDataset = xhr_dataset_1.XhrDataset;
var environment_1 = require("./environment");
exports.ENV = environment_1.ENV;
exports.Environment = environment_1.Environment;
var graph_1 = require("./graph/graph");
exports.Graph = graph_1.Graph;
exports.Tensor = graph_1.Tensor;
var adadelta_optimizer_1 = require("./graph/optimizers/adadelta_optimizer");
exports.AdadeltaOptimizer = adadelta_optimizer_1.AdadeltaOptimizer;
var adagrad_optimizer_1 = require("./graph/optimizers/adagrad_optimizer");
exports.AdagradOptimizer = adagrad_optimizer_1.AdagradOptimizer;
var adam_optimizer_1 = require("./graph/optimizers/adam_optimizer");
exports.AdamOptimizer = adam_optimizer_1.AdamOptimizer;
var adamax_optimizer_1 = require("./graph/optimizers/adamax_optimizer");
exports.AdamaxOptimizer = adamax_optimizer_1.AdamaxOptimizer;
var momentum_optimizer_1 = require("./graph/optimizers/momentum_optimizer");
exports.MomentumOptimizer = momentum_optimizer_1.MomentumOptimizer;
var optimizer_1 = require("./graph/optimizers/optimizer");
exports.Optimizer = optimizer_1.Optimizer;
var rmsprop_optimizer_1 = require("./graph/optimizers/rmsprop_optimizer");
exports.RMSPropOptimizer = rmsprop_optimizer_1.RMSPropOptimizer;
var sgd_optimizer_1 = require("./graph/optimizers/sgd_optimizer");
exports.SGDOptimizer = sgd_optimizer_1.SGDOptimizer;
var session_1 = require("./graph/session");
exports.CostReduction = session_1.CostReduction;
exports.Session = session_1.Session;
var graph_runner_1 = require("./graph_runner");
exports.GraphRunner = graph_runner_1.GraphRunner;
exports.MetricReduction = graph_runner_1.MetricReduction;
var initializers_1 = require("./initializers");
exports.ConstantInitializer = initializers_1.ConstantInitializer;
exports.NDArrayInitializer = initializers_1.NDArrayInitializer;
exports.OnesInitializer = initializers_1.OnesInitializer;
exports.RandomNormalInitializer = initializers_1.RandomNormalInitializer;
exports.RandomTruncatedNormalInitializer = initializers_1.RandomTruncatedNormalInitializer;
exports.RandomUniformInitializer = initializers_1.RandomUniformInitializer;
exports.VarianceScalingInitializer = initializers_1.VarianceScalingInitializer;
exports.ZerosInitializer = initializers_1.ZerosInitializer;
var math_1 = require("./math/math");
exports.MatrixOrientation = math_1.MatrixOrientation;
exports.NDArrayMath = math_1.NDArrayMath;
var math_cpu_1 = require("./math/math_cpu");
exports.NDArrayMathCPU = math_cpu_1.NDArrayMathCPU;
var math_gpu_1 = require("./math/math_gpu");
exports.NDArrayMathGPU = math_gpu_1.NDArrayMathGPU;
var ndarray_1 = require("./math/ndarray");
exports.initializeGPU = ndarray_1.initializeGPU;
var ndarray_2 = require("./math/ndarray");
exports.Array1D = ndarray_2.Array1D;
exports.Array2D = ndarray_2.Array2D;
exports.Array3D = ndarray_2.Array3D;
exports.Array4D = ndarray_2.Array4D;
exports.NDArray = ndarray_2.NDArray;
exports.Scalar = ndarray_2.Scalar;
var gpgpu_context_1 = require("./math/webgl/gpgpu_context");
exports.GPGPUContext = gpgpu_context_1.GPGPUContext;

},{"./data/checkpoint_loader":2,"./data/dataset":3,"./data/input_provider":4,"./data/xhr-dataset":5,"./environment":7,"./graph/graph":8,"./graph/optimizers/adadelta_optimizer":30,"./graph/optimizers/adagrad_optimizer":31,"./graph/optimizers/adam_optimizer":32,"./graph/optimizers/adamax_optimizer":33,"./graph/optimizers/momentum_optimizer":34,"./graph/optimizers/optimizer":35,"./graph/optimizers/rmsprop_optimizer":36,"./graph/optimizers/sgd_optimizer":37,"./graph/session":39,"./graph_runner":42,"./initializers":44,"./math/conv_util":49,"./math/math":52,"./math/math_cpu":53,"./math/math_gpu":54,"./math/ndarray":55,"./math/webgl/gpgpu_context":68,"./math/webgl/gpgpu_util":70,"./math/webgl/render_ndarray_gpu_util":77,"./math/webgl/webgl_util":86,"./test_util":87,"./util":88,"./version":89}],44:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ndarray_1 = require("./math/ndarray");
var VarianceScalingInitializer = (function () {
    function VarianceScalingInitializer(scale, mode, distribution) {
        if (scale === void 0) { scale = 1.0; }
        if (mode === void 0) { mode = 'fan_in'; }
        if (distribution === void 0) { distribution = 'normal'; }
        this.scale = scale;
        this.mode = mode;
        this.distribution = distribution;
    }
    VarianceScalingInitializer.prototype.initialize = function (weightsShape, inputUnits, outputUnits) {
        var n = 0;
        if (this.mode === 'fan_in') {
            n = inputUnits;
        }
        else if (this.mode === 'fan_out') {
            n = outputUnits;
        }
        else if (this.mode === 'fan_avg') {
            n = (inputUnits + outputUnits) / 2;
        }
        else {
            throw new Error("Unexpected mode for variance scaling initializer: " + this.mode);
        }
        if (this.distribution === 'normal') {
            return ndarray_1.NDArray.randTruncatedNormal(weightsShape, 0.0, Math.sqrt(this.scale / n));
        }
        else if (this.distribution === 'uniform') {
            return ndarray_1.NDArray.randUniform(weightsShape, 0.0, Math.sqrt(3 * this.scale / n));
        }
        else {
            throw new Error("Unexpected distribution for variance scaling initializer: " +
                ("" + this.distribution));
        }
    };
    return VarianceScalingInitializer;
}());
exports.VarianceScalingInitializer = VarianceScalingInitializer;
var ZerosInitializer = (function () {
    function ZerosInitializer() {
    }
    ZerosInitializer.prototype.initialize = function (weightsShape, inputUnits, outputUnits) {
        return ndarray_1.NDArray.zeros(weightsShape);
    };
    return ZerosInitializer;
}());
exports.ZerosInitializer = ZerosInitializer;
var OnesInitializer = (function () {
    function OnesInitializer() {
    }
    OnesInitializer.prototype.initialize = function (weightsShape, inputUnits, outputUnits) {
        var values = ndarray_1.NDArray.zeros(weightsShape);
        values.fill(1);
        return values;
    };
    return OnesInitializer;
}());
exports.OnesInitializer = OnesInitializer;
var ConstantInitializer = (function () {
    function ConstantInitializer(value) {
        if (value === void 0) { value = 0; }
        this.value = value;
    }
    ConstantInitializer.prototype.initialize = function (weightsShape, inputUnits, outputUnits) {
        var values = ndarray_1.NDArray.zeros(weightsShape);
        values.fill(this.value);
        return values;
    };
    return ConstantInitializer;
}());
exports.ConstantInitializer = ConstantInitializer;
var NDArrayInitializer = (function () {
    function NDArrayInitializer(ndarray) {
        this.ndarray = ndarray;
    }
    NDArrayInitializer.prototype.initialize = function (weightsShape, inputUnits, outputUnits) {
        return this.ndarray;
    };
    return NDArrayInitializer;
}());
exports.NDArrayInitializer = NDArrayInitializer;
var RandomNormalInitializer = (function () {
    function RandomNormalInitializer(mean, stdev) {
        if (mean === void 0) { mean = 0; }
        if (stdev === void 0) { stdev = .05; }
        this.mean = mean;
        this.stdev = stdev;
    }
    RandomNormalInitializer.prototype.initialize = function (weightsShape, inputUnits, outputUnits) {
        return ndarray_1.NDArray.randNormal(weightsShape, this.mean, this.stdev);
    };
    return RandomNormalInitializer;
}());
exports.RandomNormalInitializer = RandomNormalInitializer;
var RandomTruncatedNormalInitializer = (function () {
    function RandomTruncatedNormalInitializer(mean, stdev) {
        if (mean === void 0) { mean = 0; }
        if (stdev === void 0) { stdev = .05; }
        this.mean = mean;
        this.stdev = stdev;
    }
    RandomTruncatedNormalInitializer.prototype.initialize = function (weightsShape, inputUnits, outputUnits) {
        return ndarray_1.NDArray.randTruncatedNormal(weightsShape, this.mean, this.stdev);
    };
    return RandomTruncatedNormalInitializer;
}());
exports.RandomTruncatedNormalInitializer = RandomTruncatedNormalInitializer;
var RandomUniformInitializer = (function () {
    function RandomUniformInitializer(minval, maxval) {
        if (minval === void 0) { minval = -.05; }
        if (maxval === void 0) { maxval = .05; }
        this.minval = minval;
        this.maxval = maxval;
    }
    RandomUniformInitializer.prototype.initialize = function (weightsShape, inputUnits, outputUnits) {
        return ndarray_1.NDArray.randUniform(weightsShape, this.minval, this.maxval);
    };
    return RandomUniformInitializer;
}());
exports.RandomUniformInitializer = RandomUniformInitializer;

},{"./math/ndarray":55}],45:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ndarray_1 = require("./ndarray");
var TanHFunc = (function () {
    function TanHFunc() {
    }
    TanHFunc.prototype.output = function (math, x) {
        return math.scope(function () {
            return math.tanh(x);
        });
    };
    TanHFunc.prototype.der = function (math, x, y) {
        return math.scope(function () {
            var ySquared = math.elementWiseMul(y, y);
            return math.scalarMinusArray(ndarray_1.Scalar.ONE, ySquared);
        });
    };
    TanHFunc.prototype.dispose = function () { };
    return TanHFunc;
}());
exports.TanHFunc = TanHFunc;
var ReLUFunc = (function () {
    function ReLUFunc() {
    }
    ReLUFunc.prototype.output = function (math, x) {
        return math.scope(function () {
            return math.relu(x);
        });
    };
    ReLUFunc.prototype.der = function (math, x, y) {
        return math.scope(function () {
            return math.step(x);
        });
    };
    ReLUFunc.prototype.dispose = function () { };
    return ReLUFunc;
}());
exports.ReLUFunc = ReLUFunc;
var LeakyReluFunc = (function () {
    function LeakyReluFunc(alpha) {
        this.alpha = alpha;
    }
    LeakyReluFunc.prototype.output = function (math, x) {
        return math.leakyRelu(x, this.alpha);
    };
    LeakyReluFunc.prototype.der = function (math, x, y) {
        return math.step(x, this.alpha);
    };
    LeakyReluFunc.prototype.dispose = function () { };
    return LeakyReluFunc;
}());
exports.LeakyReluFunc = LeakyReluFunc;
var SigmoidFunc = (function () {
    function SigmoidFunc() {
    }
    SigmoidFunc.prototype.output = function (math, x) {
        return math.scope(function () {
            return math.sigmoid(x);
        });
    };
    SigmoidFunc.prototype.der = function (math, x, y) {
        return math.scope(function () {
            var ySquared = math.elementWiseMul(y, y);
            return math.subStrict(y, ySquared);
        });
    };
    SigmoidFunc.prototype.dispose = function () { };
    return SigmoidFunc;
}());
exports.SigmoidFunc = SigmoidFunc;
var SquareFunc = (function () {
    function SquareFunc() {
    }
    SquareFunc.prototype.output = function (math, x) {
        return math.scope(function () {
            return math.elementWiseMul(x, x);
        });
    };
    SquareFunc.prototype.der = function (math, x, y) {
        return math.scope(function () {
            return math.scalarTimesArray(ndarray_1.Scalar.TWO, x);
        });
    };
    SquareFunc.prototype.dispose = function () { };
    return SquareFunc;
}());
exports.SquareFunc = SquareFunc;

},{"./ndarray":55}],46:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function axesAreInnerMostDims(axes, rank) {
    for (var i = 0; i < axes.length; ++i) {
        if (axes[axes.length - i - 1] !== rank - 1 - i) {
            return false;
        }
    }
    return true;
}
exports.axesAreInnerMostDims = axesAreInnerMostDims;
function combineLocations(outputLoc, reduceLoc, axes) {
    var rank = outputLoc.length + reduceLoc.length;
    var loc = [];
    var outIdx = 0;
    var reduceIdx = 0;
    for (var dim = 0; dim < rank; dim++) {
        if (axes.indexOf(dim) === -1) {
            loc.push(outputLoc[outIdx++]);
        }
        else {
            loc.push(reduceLoc[reduceIdx++]);
        }
    }
    return loc;
}
exports.combineLocations = combineLocations;
function computeOutAndReduceShapes(aShape, axes) {
    var outShape = [];
    var rank = aShape.length;
    for (var dim = 0; dim < rank; dim++) {
        if (axes.indexOf(dim) === -1) {
            outShape.push(aShape[dim]);
        }
    }
    var reduceShape = axes.map(function (dim) { return aShape[dim]; });
    return [outShape, reduceShape];
}
exports.computeOutAndReduceShapes = computeOutAndReduceShapes;
function expandShapeToKeepDim(shape, axes) {
    var reduceSubShape = axes.map(function (x) { return 1; });
    return combineLocations(shape, reduceSubShape, axes);
}
exports.expandShapeToKeepDim = expandShapeToKeepDim;
function parseAxisParam(axis, shape) {
    if (axis == null) {
        axis = shape.map(function (s, i) { return i; });
    }
    else if (typeof (axis) === 'number') {
        axis = [axis];
    }
    return axis;
}
exports.parseAxisParam = parseAxisParam;
function assertAxesAreInnerMostDims(msg, axes, rank) {
    if (!axesAreInnerMostDims(axes, rank)) {
        throw new Error(msg + " supports only inner-most axes for now. " +
            ("Got axes " + axes + " and rank-" + rank + " input."));
    }
}
exports.assertAxesAreInnerMostDims = assertAxesAreInnerMostDims;
function getPermutedAxes(axes, rank) {
    if (axesAreInnerMostDims(axes, rank)) {
        return null;
    }
    var result = [];
    for (var i = 0; i < rank; ++i) {
        if (axes.indexOf(i) === -1) {
            result.push(i);
        }
    }
    axes.forEach(function (axis) { return result.push(axis); });
    return result;
}
exports.getPermutedAxes = getPermutedAxes;
function getInnerMostAxes(numAxes, rank) {
    var res = [];
    for (var i = rank - numAxes; i < rank; ++i) {
        res.push(i);
    }
    return res;
}
exports.getInnerMostAxes = getInnerMostAxes;

},{}],47:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function getBroadcastDims(inShape, outShape) {
    var inRank = inShape.length;
    var dims = [];
    for (var i = 0; i < inRank; i++) {
        var dim = inRank - 1 - i;
        var a = inShape[dim] || 1;
        var b = outShape[outShape.length - 1 - i] || 1;
        if (b > 1 && a === 1) {
            dims.unshift(dim);
        }
    }
    return dims;
}
exports.getBroadcastDims = getBroadcastDims;
function broadcastDimsAreOuter(dims) {
    for (var i = 0; i < dims.length; i++) {
        if (dims[i] !== i) {
            return false;
        }
    }
    return true;
}
exports.broadcastDimsAreOuter = broadcastDimsAreOuter;
function assertAndGetBroadcastShape(shapeA, shapeB) {
    var result = [];
    var errMsg = "Operands could not be broadcast together with shapes " +
        (shapeA + " and " + shapeB + ".");
    var l = Math.max(shapeA.length, shapeB.length);
    for (var i = 0; i < l; i++) {
        var a = shapeA[shapeA.length - i - 1] || 1;
        var b = shapeB[shapeB.length - i - 1] || 1;
        if (a > 1 && b > 1 && a !== b) {
            throw Error(errMsg);
        }
        result.unshift(Math.max(a, b));
    }
    return result;
}
exports.assertAndGetBroadcastShape = assertAndGetBroadcastShape;

},{}],48:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var util = require("../util");
function assertParams(aShape, bShape, axis) {
    var aRank = aShape.length;
    var bRank = bShape.length;
    util.assert(aShape.length === bShape.length, "Error in concat" + aRank + "D: rank of x1 (" + aRank + ") and x2 (" + bRank + ") " +
        "must be the same.");
    util.assert(axis >= 0 && axis < aRank, "Error in concat" + aRank + "D: axis must be " +
        ("between 0 and " + (aRank - 1) + "."));
    for (var i = 0; i < aRank; i++) {
        util.assert((i === axis) || (aShape[i] === bShape[i]), "Error in concat" + aRank + "D: Shape (" + aShape + ") does not match " +
            ("(" + bShape + ") along the non-concatenated axis " + i + "."));
    }
}
exports.assertParams = assertParams;
function computeOutShape(x1Shape, x2Shape, axis) {
    util.assert(x1Shape.length === x2Shape.length, 'x1 and x2 should have the same rank.');
    var outputShape = x1Shape.slice();
    outputShape[axis] += x2Shape[axis];
    return outputShape;
}
exports.computeOutShape = computeOutShape;

},{"../util":88}],49:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var util = require("../util");
function computeDepthwiseConv2DInfo(inShape, filterShape, strides, pad) {
    var filterHeight = filterShape[0], filterWidth = filterShape[1], inChannels = filterShape[2], channelMul = filterShape[3];
    var _a = parseTupleParam(strides), strideHeight = _a[0], strideWidth = _a[1];
    var inHeight = inShape[1];
    var inWidth = inShape[2];
    var batchSize = inShape[0];
    var _b = getPadAndOutInfo(pad, inHeight, inWidth, strideHeight, strideWidth, filterHeight, filterWidth), padInfo = _b.padInfo, outHeight = _b.outHeight, outWidth = _b.outWidth;
    var outChannels = inChannels * channelMul;
    var outShape = [batchSize, outHeight, outWidth, outChannels];
    return {
        inShape: inShape,
        outShape: outShape,
        channelMul: channelMul,
        strideHeight: strideHeight,
        strideWidth: strideWidth,
        filterHeight: filterHeight,
        filterWidth: filterWidth,
        padInfo: padInfo
    };
}
exports.computeDepthwiseConv2DInfo = computeDepthwiseConv2DInfo;
function computeConv2DInfo(inShape, filterHeight, filterWidth, outDepth, strideHeight, strideWidth, pad) {
    var inHeight = inShape[0];
    var inWidth = inShape[1];
    var _a = getPadAndOutInfo(pad, inHeight, inWidth, strideHeight, strideWidth, filterHeight, filterWidth), padInfo = _a.padInfo, outHeight = _a.outHeight, outWidth = _a.outWidth;
    var outShape = [outHeight, outWidth, outDepth];
    return {
        inShape: inShape,
        outShape: outShape,
        padInfo: padInfo,
        strideHeight: strideHeight,
        strideWidth: strideWidth,
        filterHeight: filterHeight,
        filterWidth: filterWidth
    };
}
exports.computeConv2DInfo = computeConv2DInfo;
function computeOutputShape3D(inShape, fieldSize, outDepth, stride, zeroPad) {
    if (zeroPad == null) {
        zeroPad = computeDefaultPad(inShape, fieldSize, stride);
    }
    var inputRows = inShape[0];
    var inputCols = inShape[1];
    var outputRows = (inputRows - fieldSize + 2 * zeroPad) / stride + 1;
    util.assert(util.isInt(outputRows), "The output # of rows (" + outputRows + ") must be an integer. Change the " +
        "stride and/or zero pad parameters");
    var outputCols = (inputCols - fieldSize + 2 * zeroPad) / stride + 1;
    util.assert(util.isInt(outputCols), "The output # of columns (" + outputCols + ") must be an integer. Change " +
        "the stride and/or zero pad parameters");
    return [outputRows, outputCols, outDepth];
}
exports.computeOutputShape3D = computeOutputShape3D;
function computeDefaultPad(inputShape, fieldSize, stride) {
    return Math.floor((inputShape[0] * (stride - 1) - stride + fieldSize) / 2);
}
exports.computeDefaultPad = computeDefaultPad;
function computeWeightsShape4D(inputDepth, outputDepth, filterHeight, filterWidth) {
    return [filterHeight, filterWidth, inputDepth, outputDepth];
}
exports.computeWeightsShape4D = computeWeightsShape4D;
function computeDilatedRC(rc, origStride) {
    var rowsDilated = (rc[0] - 1) * origStride + 1;
    var colsDilated = (rc[1] - 1) * origStride + 1;
    return [rowsDilated, colsDilated];
}
exports.computeDilatedRC = computeDilatedRC;
function parseTupleParam(param) {
    return typeof param === 'number' ? [param, param] : param;
}
function getPadAndOutInfo(pad, inHeight, inWidth, strideHeight, strideWidth, filterHeight, filterWidth) {
    var padInfo;
    var outHeight;
    var outWidth;
    if (typeof pad === 'number') {
        padInfo = { top: pad, bottom: pad, left: pad, right: pad };
        var outShape = computeOutputShape3D([inHeight, inWidth, 1], filterHeight, 1, strideHeight, pad);
        outHeight = outShape[0];
        outWidth = outShape[1];
    }
    else if (pad === 'same') {
        outHeight = Math.ceil(inHeight / strideHeight);
        outWidth = Math.ceil(inWidth / strideWidth);
        var padAlongHeight = (outHeight - 1) * strideHeight + filterHeight - inHeight;
        var padAlongWidth = (outWidth - 1) * strideWidth + filterWidth - inWidth;
        var top_1 = Math.floor(padAlongHeight / 2);
        var bottom = padAlongHeight - top_1;
        var left = Math.floor(padAlongWidth / 2);
        var right = padAlongWidth - left;
        padInfo = { top: top_1, bottom: bottom, left: left, right: right };
    }
    else if (pad === 'valid') {
        padInfo = { top: 0, bottom: 0, left: 0, right: 0 };
        outHeight = Math.ceil((inHeight - filterHeight + 1) / strideHeight);
        outWidth = Math.ceil((inWidth - filterWidth + 1) / strideWidth);
    }
    else {
        throw Error("Unknown padding parameter: " + pad);
    }
    return { padInfo: padInfo, outHeight: outHeight, outWidth: outWidth };
}

},{"../util":88}],50:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function validateShapes(sourceSize, destSize) {
    var srcArea = sourceSize[0] * sourceSize[1];
    var dstArea = destSize[0] * destSize[1];
    if (srcArea !== dstArea) {
        var srcStr = "[" + sourceSize[0] + ", " + sourceSize[1] + "]";
        var dstStr = "[" + destSize[0] + ", " + destSize[1] + "]";
        throw new Error("copy2D shapes have different areas:\n  sourceSize " + srcStr +
            (", area " + srcArea + "\n  destSize " + dstStr + ", area " + dstArea));
    }
}
exports.validateShapes = validateShapes;

},{}],51:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ndarray_1 = require("./ndarray");
var SquareCostFunc = (function () {
    function SquareCostFunc() {
        this.halfOne = ndarray_1.Scalar.new(0.5);
    }
    SquareCostFunc.prototype.cost = function (math, x1, x2) {
        var diff = math.subStrict(x1, x2);
        var diffSquared = math.elementWiseMul(diff, diff);
        var result = math.scalarTimesArray(this.halfOne, diffSquared);
        diff.dispose();
        diffSquared.dispose();
        return result;
    };
    SquareCostFunc.prototype.der = function (math, x1, x2) {
        return math.subStrict(x1, x2);
    };
    SquareCostFunc.prototype.dispose = function () {
        this.halfOne.dispose();
    };
    return SquareCostFunc;
}());
exports.SquareCostFunc = SquareCostFunc;

},{"./ndarray":55}],52:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var util = require("../util");
var axis_util = require("./axis_util");
var broadcast_util = require("./broadcast_util");
var concat_util = require("./concat_util");
var conv_util = require("./conv_util");
var copy2d_util = require("./copy2d_util");
var ndarray_1 = require("./ndarray");
var slice_util = require("./slice_util");
var SumTypesMap;
(function (SumTypesMap) {
    SumTypesMap["float32"] = "float32";
    SumTypesMap["int32"] = "int32";
    SumTypesMap["bool"] = "int32";
})(SumTypesMap = exports.SumTypesMap || (exports.SumTypesMap = {}));
var NDArrayMath = (function () {
    function NDArrayMath(safeMode) {
        this.safeMode = safeMode;
        this.ndarrayScopes = [];
        this.ndarraysToKeep = [];
        this.activeScopeNDArraysToKeep = [];
        this.debugMode = false;
    }
    NDArrayMath.prototype.scope = function (scopeFn) {
        var _this = this;
        this.startScope();
        var keepFn = function (ndarray) { return _this.keep(ndarray); };
        var trackFn = function (ndarray) { return _this.track(ndarray); };
        var result = scopeFn(keepFn, trackFn);
        if (result instanceof Promise) {
            result.then(function (r) { return _this.endScope(r); });
            return result;
        }
        else {
            this.endScope(result);
            return result;
        }
    };
    NDArrayMath.prototype.enableDebugMode = function () {
        this.debugMode = true;
        console.warn('Debugging mode is ON. The output of every math call will ' +
            'be downloaded to CPU and checked for NaNs. ' +
            'This significantly impacts performance.');
    };
    NDArrayMath.prototype.startScope = function () {
        var newScope = [];
        this.ndarrayScopes.push(newScope);
        this.activeScope = newScope;
        var newNDArraysToKeep = [];
        this.ndarraysToKeep.push(newNDArraysToKeep);
        this.activeScopeNDArraysToKeep = newNDArraysToKeep;
    };
    NDArrayMath.prototype.extractNDArraysFromScopeResult = function (result) {
        if (result == null) {
            return [];
        }
        if (result instanceof ndarray_1.NDArray) {
            return [result];
        }
        var list = [];
        var resultObj = result;
        for (var k in resultObj) {
            var val = resultObj[k];
            if (val instanceof ndarray_1.NDArray) {
                list.push(val);
            }
        }
        return list;
    };
    NDArrayMath.prototype.endScope = function (result) {
        var _this = this;
        var arraysToKeep = this.activeScopeNDArraysToKeep;
        var resultArrays = this.extractNDArraysFromScopeResult(result);
        arraysToKeep = arraysToKeep.concat(resultArrays);
        for (var i = 0; i < this.activeScope.length; i++) {
            var ndarray = this.activeScope[i];
            if (this.isNDArrayDataInList(ndarray, arraysToKeep)) {
                continue;
            }
            ndarray.dispose();
        }
        this.ndarrayScopes.pop();
        this.activeScope = this.ndarrayScopes.length === 0 ?
            null :
            this.ndarrayScopes[this.ndarrayScopes.length - 1];
        resultArrays.forEach(function (val) {
            if (!_this.isNDArrayDataInList(val, _this.activeScopeNDArraysToKeep)) {
                _this.track(val);
            }
        });
        this.ndarraysToKeep.pop();
        this.activeScopeNDArraysToKeep = this.ndarraysToKeep.length === 0 ?
            null :
            this.ndarraysToKeep[this.ndarraysToKeep.length - 1];
    };
    NDArrayMath.prototype.isNDArrayDataInList = function (ndarray, ndarrayList) {
        for (var i = 0; i < ndarrayList.length; i++) {
            if (ndarrayList[i].getData() === ndarray.getData()) {
                return true;
            }
        }
        return false;
    };
    NDArrayMath.prototype.keep = function (result) {
        if (this.activeScope == null) {
            if (this.safeMode) {
                throw new Error('You are using math in safe mode. Enclose all ' +
                    'math.method() calls inside a scope: ' +
                    'math.scope(() => {math.method();...}) to avoid memory ' +
                    'leaks.');
            }
            return result;
        }
        this.activeScopeNDArraysToKeep.push(result);
        return result;
    };
    NDArrayMath.prototype.checkForNaN = function (vals, dtype, name) {
        for (var i = 0; i < vals.length; i++) {
            if (util.isValNaN(vals[i], dtype)) {
                throw Error("The result of the last math." + name + " has NaNs.");
            }
        }
    };
    NDArrayMath.prototype.track = function (result) {
        if (this.activeScope == null) {
            if (this.safeMode) {
                throw new Error('You are using math in safe mode. Enclose all ' +
                    'math.method() calls inside a scope: ' +
                    'math.scope(() => {math.method();...}) to avoid memory ' +
                    'leaks.');
            }
            return result;
        }
        this.activeScope.push(result);
        return result;
    };
    NDArrayMath.prototype.dispose = function () { };
    NDArrayMath.prototype.matMul = function (a, b, aOrientation, bOrientation) {
        var _this = this;
        if (aOrientation === void 0) { aOrientation = MatrixOrientation.REGULAR; }
        if (bOrientation === void 0) { bOrientation = MatrixOrientation.REGULAR; }
        var innerShapeA = (aOrientation === MatrixOrientation.REGULAR) ? a.shape[1] : a.shape[0];
        var innerShapeB = (bOrientation === MatrixOrientation.REGULAR) ? b.shape[0] : b.shape[1];
        util.assert(a.rank === 2 && b.rank === 2, "Error in matMul: inputs must be rank 2, got ranks " + a.rank +
            (" and " + b.rank + "."));
        util.assert(innerShapeA === innerShapeB, "Error in matMul: inner shapes (" + innerShapeA + ") and (" +
            (innerShapeB + ") of NDArrays with shapes " + a.shape + " and ") +
            (b.shape + " and orientations " + MatrixOrientation[aOrientation]) +
            (" and " + MatrixOrientation[bOrientation] + " must match."));
        return this.executeOp('matMul', function () { return _this.matMulInternal(a, b, aOrientation, bOrientation); });
    };
    NDArrayMath.prototype.executeOp = function (name, f) {
        var start;
        if (this.debugMode) {
            start = performance.now();
        }
        var result = f();
        if (this.debugMode) {
            var vals = result.getValues();
            var time = util.rightPad(performance.now() - start + "ms", 9);
            var paddedName = util.rightPad(name, 25);
            var rank = result.rank;
            var size = result.size;
            var shape = util.rightPad(result.shape.toString(), 14);
            console.log("%c" + paddedName + "\t%c" + time + "\t%c" + rank + "D " + shape + "\t%c" + size, 'font-weight:bold', 'color:red', 'color:blue', 'color: orange');
            this.checkForNaN(vals, result.dtype, name);
        }
        return this.track(result);
    };
    NDArrayMath.prototype.vectorTimesMatrix = function (v, matrix) {
        util.assert(v.rank === 1, "Error in vectorTimesMatrix: first input must be rank 1, but got " +
            ("rank " + v.rank + "."));
        util.assert(matrix.rank === 2, "Error in vectorTimesMatrix: second input must be rank 2, but got " +
            ("rank " + matrix.rank + "."));
        util.assert(v.size === matrix.shape[0], "Error in vectorTimesMatrix: size of vector (" + v.size + ") " +
            ("must match first dimension of matrix (" + matrix.shape[0] + ")"));
        return this.matMul(v.as2D(1, -1), matrix).as1D();
    };
    NDArrayMath.prototype.matrixTimesVector = function (matrix, v) {
        util.assert(v.rank === 1, "Error in matrixTimesVector: second input must rank 1, but got " +
            ("rank " + v.rank + "."));
        util.assert(matrix.rank === 2, "Error in matrixTimesVector: first input must be a rank 2, but got " +
            ("rank " + matrix.rank + "."));
        util.assert(v.size === matrix.shape[1], "Error in matrixTimesVector: size of first rank 1 input " + v.size + " " +
            "must match inner dimension of second rank 2 input, but got " +
            ("shape " + matrix.shape + "."));
        return this.matMul(matrix, v.as2D(-1, 1)).as1D();
    };
    NDArrayMath.prototype.dotProduct = function (v1, v2) {
        util.assert(v1.rank === 1 && v2.rank === 1, "Error in dotProduct: inputs must be rank 1, but got ranks " +
            (v1.rank + " and " + v2.rank + "."));
        util.assert(v1.size === v2.size, "Error in dotProduct: size of inputs (" + v1.size + ") and (" +
            (v2.size + ") must match."));
        return this.matMul(v1.as2D(1, -1), v2.as2D(-1, 1)).asScalar();
    };
    NDArrayMath.prototype.outerProduct = function (v1, v2) {
        util.assert(v1.rank === 1 && v2.rank === 1, "Error in outerProduct: inputs must be rank 1, but got ranks " +
            (v1.rank + " and " + v2.rank + "."));
        return this.matMul(v1.as2D(-1, 1), v2.as2D(1, -1));
    };
    NDArrayMath.prototype.clone = function (ndarray) {
        var _this = this;
        return this.executeOp('clone', function () { return _this.cloneInternal(ndarray); });
    };
    NDArrayMath.prototype.reshape = function (ndarray, newShape) {
        console.warn('math.reshape() is deprecated. Please call reshape() ' +
            'directly on the ndarray object');
        return ndarray.reshape(newShape);
    };
    NDArrayMath.prototype.slice1D = function (input, begin, size) {
        var _this = this;
        slice_util.assertParamsValid(input, [begin], [size]);
        return this.executeOp('slice1D', function () { return _this.slice1DInternal(input, begin, size); });
    };
    NDArrayMath.prototype.slice2D = function (input, begin, size) {
        var _this = this;
        slice_util.assertParamsValid(input, begin, size);
        return this.executeOp('slice2D', function () { return _this.slice2DInternal(input, begin, size); });
    };
    NDArrayMath.prototype.slice3D = function (input, begin, size) {
        var _this = this;
        slice_util.assertParamsValid(input, begin, size);
        return this.executeOp('slice3D', function () { return _this.slice3DInternal(input, begin, size); });
    };
    NDArrayMath.prototype.slice4D = function (input, begin, size) {
        var _this = this;
        slice_util.assertParamsValid(input, begin, size);
        return this.executeOp('slice4D', function () { return _this.slice4DInternal(input, begin, size); });
    };
    NDArrayMath.prototype.copy2D = function (source, sourceBegin, sourceSize, dest, destBegin, destSize) {
        var _this = this;
        util.assert(sourceBegin[0] + sourceSize[0] <= source.shape[0] &&
            sourceBegin[1] + sourceSize[1] <= source.shape[1], "Error in copy2D: requested source start position " + sourceBegin + " " +
            ("and source size " + sourceSize + " would overflow source NDArray") +
            ("of shape " + source.shape + "."));
        util.assert(destBegin[0] + destSize[0] <= dest.shape[0] &&
            destBegin[1] + destSize[1] <= dest.shape[1], "Error in copy2D: requested dest start position " + destBegin + " " +
            ("and source size " + destSize + " would overflow dest NDArray of") +
            ("shape " + dest.shape + "."));
        copy2d_util.validateShapes(sourceSize, destSize);
        this.executeOp('copy2D', function () {
            _this.copy2DInternal(source, sourceBegin, sourceSize, dest, destBegin, destSize);
            return dest;
        });
    };
    NDArrayMath.prototype.concat1D = function (a, b) {
        var _this = this;
        concat_util.assertParams(a.shape, b.shape, 0);
        return this.executeOp('concat1D', function () { return _this.concat1DInternal(a, b); });
    };
    NDArrayMath.prototype.concat2D = function (a, b, axis) {
        var _this = this;
        concat_util.assertParams(a.shape, b.shape, axis);
        return this.executeOp('concat2D', function () { return _this.concat2DInternal(a, b, axis); });
    };
    NDArrayMath.prototype.concat3D = function (ndarray1, ndarray2, axis) {
        var _this = this;
        concat_util.assertParams(ndarray1.shape, ndarray2.shape, axis);
        return this.executeOp('concat3D', function () { return _this.concat3DInternal(ndarray1, ndarray2, axis); });
    };
    NDArrayMath.prototype.concat4D = function (ndarray1, ndarray2, axis) {
        var _this = this;
        concat_util.assertParams(ndarray1.shape, ndarray2.shape, axis);
        return this.executeOp('concat4D', function () { return _this.concat4DInternal(ndarray1, ndarray2, axis); });
    };
    NDArrayMath.prototype.logSumExp = function (input, axis, keepDims) {
        var _this = this;
        if (axis === void 0) { axis = null; }
        if (keepDims === void 0) { keepDims = false; }
        var axes = axis_util.parseAxisParam(axis, input.shape);
        return this.executeOp('logSumExp', function () {
            var xMax = _this.max(input, axes, true);
            var a = _this.subtract(input, xMax);
            var b = _this.exp(a);
            var c = _this.sum(b, axes);
            var d = _this.log(c);
            var res = _this.add(xMax.reshape(d.shape), d);
            if (keepDims) {
                var newShape = axis_util.expandShapeToKeepDim(res.shape, axes);
                return res.reshape(newShape);
            }
            return res;
        });
    };
    NDArrayMath.prototype.sum = function (input, axis, keepDims) {
        var _this = this;
        if (axis === void 0) { axis = null; }
        if (keepDims === void 0) { keepDims = false; }
        var origAxes = axis_util.parseAxisParam(axis, input.shape);
        var axes = origAxes;
        var permutedAxes = axis_util.getPermutedAxes(axes, input.rank);
        return this.executeOp('sum', function () {
            if (permutedAxes != null) {
                input = _this.transpose(input, permutedAxes);
                axes = axis_util.getInnerMostAxes(axes.length, input.rank);
            }
            var res = _this.sumInternal(input, axes);
            if (keepDims) {
                var newShape = axis_util.expandShapeToKeepDim(res.shape, origAxes);
                return res.reshape(newShape);
            }
            return res;
        });
    };
    NDArrayMath.prototype.mean = function (x, axis, keepDims) {
        var _this = this;
        if (axis === void 0) { axis = null; }
        if (keepDims === void 0) { keepDims = false; }
        var axes = axis_util.parseAxisParam(axis, x.shape);
        var shapes = axis_util.computeOutAndReduceShapes(x.shape, axes);
        var reduceShape = shapes[1];
        var reduceSize = util.sizeFromShape(reduceShape);
        return this.executeOp('mean', function () {
            return _this.scope(function (keep, track) {
                var res = _this.divide(x, track(ndarray_1.Scalar.new(reduceSize)));
                return _this.sum(res, axis, keepDims);
            });
        });
    };
    NDArrayMath.prototype.argMin = function (input, axis) {
        var _this = this;
        if (axis === void 0) { axis = null; }
        var axes = axis_util.parseAxisParam(axis, input.shape);
        var permutedAxes = axis_util.getPermutedAxes(axes, input.rank);
        return this.executeOp('argMin', function () {
            if (permutedAxes != null) {
                input = _this.transpose(input, permutedAxes);
                axes = axis_util.getInnerMostAxes(axes.length, input.rank);
            }
            return _this.argMinInternal(input, axes);
        });
    };
    NDArrayMath.prototype.argMax = function (input, axis) {
        var _this = this;
        if (axis === void 0) { axis = null; }
        var axes = axis_util.parseAxisParam(axis, input.shape);
        var permutedAxes = axis_util.getPermutedAxes(axes, input.rank);
        return this.executeOp('argMax', function () {
            if (permutedAxes != null) {
                input = _this.transpose(input, permutedAxes);
                axes = axis_util.getInnerMostAxes(axes.length, input.rank);
            }
            return _this.argMaxInternal(input, axes);
        });
    };
    NDArrayMath.prototype.argMaxEquals = function (x1, x2) {
        var _this = this;
        util.assertShapesMatch(x1.shape, x2.shape, 'Error in argMaxEquals: ');
        return this.executeOp('argMaxEquals', function () { return _this.scope(function () {
            return _this.equal(_this.argMax(x1), _this.argMax(x2));
        }); });
    };
    NDArrayMath.prototype.equal = function (x, y) {
        var _this = this;
        return this.executeOp('equal', function () { return _this.equalInternal(x, y); });
    };
    NDArrayMath.prototype.equalStrict = function (x, y) {
        util.assertShapesMatch(x.shape, y.shape, 'Error in equalStrict: ');
        return this.equal(x, y);
    };
    NDArrayMath.prototype.topK = function (ndarray, k) {
        var _this = this;
        util.assert(k <= ndarray.size, "Error in topK: k value (" + k + ") must be less than size of input " +
            ("ndarray, got shape " + ndarray.shape + "."));
        var result;
        this.executeOp('topK', function () {
            result = _this.topKInternal(ndarray, k);
            return result.values;
        });
        this.track(result.indices);
        return result;
    };
    NDArrayMath.prototype.min = function (input, axis, keepDims) {
        var _this = this;
        if (axis === void 0) { axis = null; }
        if (keepDims === void 0) { keepDims = false; }
        var origAxes = axis_util.parseAxisParam(axis, input.shape);
        var axes = origAxes;
        var permutedAxes = axis_util.getPermutedAxes(axes, input.rank);
        return this.executeOp('min', function () {
            if (permutedAxes != null) {
                input = _this.transpose(input, permutedAxes);
                axes = axis_util.getInnerMostAxes(axes.length, input.rank);
            }
            var res = _this.minInternal(input, axes);
            if (keepDims) {
                var newShape = axis_util.expandShapeToKeepDim(res.shape, origAxes);
                return res.reshape(newShape);
            }
            return res;
        });
    };
    NDArrayMath.prototype.max = function (input, axis, keepDims) {
        var _this = this;
        if (axis === void 0) { axis = null; }
        if (keepDims === void 0) { keepDims = false; }
        var origAxes = axis_util.parseAxisParam(axis, input.shape);
        var axes = origAxes;
        var permutedAxes = axis_util.getPermutedAxes(axes, input.rank);
        return this.executeOp('max', function () {
            if (permutedAxes != null) {
                input = _this.transpose(input, permutedAxes);
                axes = axis_util.getInnerMostAxes(axes.length, input.rank);
            }
            var res = _this.maxInternal(input, axes);
            if (keepDims) {
                var newShape = axis_util.expandShapeToKeepDim(res.shape, origAxes);
                return res.reshape(newShape);
            }
            return res;
        });
    };
    NDArrayMath.prototype.softmax = function (logits, dim) {
        var _this = this;
        if (dim === void 0) { dim = -1; }
        if (dim === -1) {
            dim = logits.rank - 1;
        }
        if (dim !== logits.rank - 1) {
            throw Error('Softmax along a non-last dimension is not yet supported. ' +
                ("Logits was rank " + logits.rank + " and dim was " + dim));
        }
        return this.executeOp('softmax', function () {
            return _this.scope(function () {
                var lse = _this.logSumExp(logits, [dim], true);
                var logResult = _this.subtract(logits, lse);
                return _this.exp(logResult);
            });
        });
    };
    NDArrayMath.prototype.switchDim = function (a, newDim) {
        return this.transpose(a, newDim);
    };
    NDArrayMath.prototype.tile = function (a, reps) {
        var _this = this;
        util.assert(a.rank === reps.length, "Error in transpose: rank of input " + a.rank + " " +
            ("must match length of reps " + reps + "."));
        return this.executeOp('tile', function () { return _this.tileInternal(a, reps); });
    };
    NDArrayMath.prototype.transpose = function (a, perm) {
        var _this = this;
        if (perm == null) {
            perm = a.shape.map(function (s, i) { return i; }).reverse();
        }
        util.assert(a.rank === perm.length, "Error in transpose: rank of input " + a.rank + " " +
            ("must match length of perm " + perm + "."));
        return this.executeOp('transpose', function () { return _this.transposeInternal(a, perm); });
    };
    NDArrayMath.prototype.scalarPlusArray = function (c, a) {
        util.assert(c.size === 1, "Error in scalarPlusArray: first argument must be rank 0, but got " +
            ("rank " + c.rank + "."));
        return this.add(c, a);
    };
    NDArrayMath.prototype.scalarMinusArray = function (c, a) {
        util.assert(c.size === 1, "Error in scalarMinusArray: first argument must be rank 0, but got " +
            ("rank " + c.rank + "."));
        return this.subtract(c, a);
    };
    NDArrayMath.prototype.arrayMinusScalar = function (a, c) {
        util.assert(c.size === 1, "Error in arrayMinusScalar: second argument must be rank 0, but " +
            ("got rank " + c.rank + "."));
        return this.subtract(a, c);
    };
    NDArrayMath.prototype.neg = function (a) {
        var _this = this;
        return this.executeOp('neg', function () { return _this.negInternal(a); });
    };
    NDArrayMath.prototype.add = function (a, b) {
        var _this = this;
        broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);
        return this.executeOp('add', function () { return _this.addInternal(a, b); });
    };
    NDArrayMath.prototype.addStrict = function (a, b) {
        util.assertShapesMatch(a.shape, b.shape, 'Error in addStrict: ');
        return this.add(a, b);
    };
    NDArrayMath.prototype.subtract = function (a, b) {
        var _this = this;
        broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);
        return this.executeOp('subtract', function () { return _this.subtractInternal(a, b); });
    };
    NDArrayMath.prototype.sub = function (a, b) {
        return this.subtract(a, b);
    };
    NDArrayMath.prototype.subStrict = function (a, b) {
        util.assertShapesMatch(a.shape, b.shape, 'Error in subStrict: ');
        return this.subtract(a, b);
    };
    NDArrayMath.prototype.multiply = function (a, b) {
        var _this = this;
        broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);
        return this.executeOp('multiply', function () { return _this.multiplyInternal(a, b); });
    };
    NDArrayMath.prototype.elementWiseMul = function (a, b) {
        return this.multiplyStrict(a, b);
    };
    NDArrayMath.prototype.multiplyStrict = function (a, b) {
        util.assertShapesMatch(a.shape, b.shape, 'Error in multiplyStrict: ');
        return this.multiply(a, b);
    };
    NDArrayMath.prototype.divide = function (a, b) {
        var _this = this;
        broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);
        return this.executeOp('divide', function () { return _this.divideInternal(a, b); });
    };
    NDArrayMath.prototype.divideStrict = function (a, b) {
        util.assertShapesMatch(a.shape, b.shape, 'Error in divideStrict: ');
        return this.divide(a, b);
    };
    NDArrayMath.prototype.scalarDividedByArray = function (c, a) {
        util.assert(c.size === 1, "Error in scalarDividedByArray: first argument must be rank 0, but " +
            ("got NDArray of rank " + c.rank + "."));
        return this.divide(c, a);
    };
    NDArrayMath.prototype.arrayDividedByScalar = function (a, c) {
        util.assert(c.size === 1, "Error in arrayDividedByScalar: second argument must be rank 0, " +
            ("but got NDArray of rank " + c.rank + "."));
        return this.divide(a, c);
    };
    NDArrayMath.prototype.ceil = function (ndarray) {
        var _this = this;
        return this.executeOp('ceil', function () { return _this.ceilInternal(ndarray); });
    };
    NDArrayMath.prototype.floor = function (ndarray) {
        var _this = this;
        return this.executeOp('floor', function () { return _this.floorInternal(ndarray); });
    };
    NDArrayMath.prototype.exp = function (ndarray) {
        var _this = this;
        return this.executeOp('exp', function () { return _this.expInternal(ndarray); });
    };
    NDArrayMath.prototype.log = function (ndarray) {
        var _this = this;
        return this.executeOp('log', function () { return _this.logInternal(ndarray); });
    };
    NDArrayMath.prototype.sqrt = function (ndarray) {
        var _this = this;
        return this.executeOp('sqrt', function () { return _this.sqrtInternal(ndarray); });
    };
    NDArrayMath.prototype.square = function (x) {
        var _this = this;
        return this.executeOp('square', function () { return _this.squareInternal(x); });
    };
    NDArrayMath.prototype.abs = function (ndarray) {
        var _this = this;
        return this.executeOp('abs', function () { return _this.absInternal(ndarray); });
    };
    NDArrayMath.prototype.clip = function (ndarray, min, max) {
        var _this = this;
        util.assert((min <= max), "Error in clip: min (" + min + ") must be" +
            ("less than or equal to max (" + max + ")."));
        return this.executeOp('clip', function () { return _this.clipInternal(ndarray, min, max); });
    };
    NDArrayMath.prototype.relu = function (ndarray) {
        var _this = this;
        return this.executeOp('relu', function () { return _this.reluInternal(ndarray); });
    };
    NDArrayMath.prototype.elu = function (ndarray) {
        var _this = this;
        return this.executeOp('elu', function () { return _this.eluInternal(ndarray); });
    };
    NDArrayMath.prototype.leakyRelu = function (ndarray, alpha) {
        var _this = this;
        if (alpha === void 0) { alpha = 0.2; }
        return this.executeOp('leakyRelu', function () { return _this.leakyReluInternal(ndarray, alpha); });
    };
    NDArrayMath.prototype.sigmoid = function (ndarray) {
        var _this = this;
        return this.executeOp('sigmoid', function () { return _this.sigmoidInternal(ndarray); });
    };
    NDArrayMath.prototype.sin = function (ndarray) {
        var _this = this;
        return this.executeOp('sin', function () { return _this.sinInternal(ndarray); });
    };
    NDArrayMath.prototype.cos = function (ndarray) {
        var _this = this;
        return this.executeOp('cos', function () { return _this.cosInternal(ndarray); });
    };
    NDArrayMath.prototype.tan = function (ndarray) {
        var _this = this;
        return this.executeOp('tan', function () { return _this.tanInternal(ndarray); });
    };
    NDArrayMath.prototype.asin = function (ndarray) {
        var _this = this;
        return this.executeOp('asin', function () { return _this.asinInternal(ndarray); });
    };
    NDArrayMath.prototype.acos = function (ndarray) {
        var _this = this;
        return this.executeOp('acos', function () { return _this.acosInternal(ndarray); });
    };
    NDArrayMath.prototype.atan = function (ndarray) {
        var _this = this;
        return this.executeOp('atan', function () { return _this.atanInternal(ndarray); });
    };
    NDArrayMath.prototype.sinh = function (ndarray) {
        var _this = this;
        return this.executeOp('sinh', function () { return _this.sinhInternal(ndarray); });
    };
    NDArrayMath.prototype.cosh = function (ndarray) {
        var _this = this;
        return this.executeOp('cosh', function () { return _this.coshInternal(ndarray); });
    };
    NDArrayMath.prototype.tanh = function (ndarray) {
        var _this = this;
        return this.executeOp('tanh', function () { return _this.tanhInternal(ndarray); });
    };
    NDArrayMath.prototype.step = function (ndarray, alpha) {
        var _this = this;
        if (alpha === void 0) { alpha = 0.0; }
        return this.executeOp('step', function () { return _this.stepInternal(ndarray, alpha); });
    };
    NDArrayMath.prototype.scaledArrayAdd = function (c1, a, c2, b) {
        var _this = this;
        util.assert(c1.size === 1, "Error in scaledArrayAdd: first argument must rank 0, but got " +
            (" rank " + c1.rank + "."));
        util.assert(c2.size === 1, "Error in scaledArrayAdd: third argument must be rank 0, but got " +
            ("NDArray of rank " + c2.rank + "."));
        util.assertShapesMatch(a.shape, b.shape, 'Error in scaledArrayAdd: ');
        return this.executeOp('scaledArrayAdd', function () { return _this.scaledArrayAddInternal(c1, a, c2, b); });
    };
    NDArrayMath.prototype.scalarTimesArray = function (c, a) {
        util.assert(c.size === 1, "Error in arrayDividedByScalar: first argument must be rank 0, but " +
            ("got rank " + c.rank + "."));
        return this.multiply(c, a);
    };
    NDArrayMath.prototype.elementWiseMulBroadcast = function (a, b) {
        util.assert(a.rank === 2, "Error in elementWiseMulBroadcast: first argument must be " +
            ("rank 2, but got rank " + a.rank + "."));
        util.assert(b.rank === 2, "Error in elementWiseMulBroadcast: second argument must be " +
            ("rank 2, but got rank " + b.rank + "."));
        return this.multiply(a, b);
    };
    NDArrayMath.prototype.conv2d = function (x, filter, bias, strides, pad) {
        var _this = this;
        util.assert(x.rank === 3, "Error in conv2d: x must be rank 3, but got rank " + x.rank + ".");
        util.assert(filter.rank === 4, "Error in conv2d: filter must be rank 4, but got rank " +
            (filter.rank + "."));
        if (bias != null) {
            util.assert(bias.rank === 1, "Error in conv2d: bias must be rank 1, but got rank " +
                (bias.rank + "."));
        }
        util.assert(x.shape[2] === filter.shape[2], "Error in conv2d: depth of input (" + x.shape[2] + ") must match  " +
            ("input depth for filter " + filter.shape[2] + "."));
        var filterHeight = filter.shape[0];
        var filterWidth = filter.shape[1];
        var outDepth = filter.shape[3];
        var _a = parseTupleParam(strides), strideHeight = _a[0], strideWidth = _a[1];
        var convInfo = conv_util.computeConv2DInfo(x.shape, filterHeight, filterWidth, outDepth, strideHeight, strideWidth, pad);
        return this.executeOp('conv2d', function () { return _this.conv2dInternal(x, filter, bias, convInfo); });
    };
    NDArrayMath.prototype.conv2dBackProp = function (x, dy, filter, strides, pad) {
        var dw = this.conv2dDerFilter(x, dy, filter.shape, strides, pad);
        var db = this.conv2dDerBias(dy);
        var dx = this.conv2dDerInput(x.shape, dy, filter, strides, pad);
        return { db: db, dw: dw, dx: dx };
    };
    NDArrayMath.prototype.conv2dDerInput = function (inShape, dy, filter, strides, pad) {
        var _this = this;
        var inDepth = inShape[2];
        var outDepth = dy.shape[2];
        util.assert(inShape.length === 3, "Error in conv2dDerInput: x must be rank 3, but got rank " +
            (inShape.length + "."));
        util.assert(dy.rank === 3, "Error in conv2dDerInput: dy must be rank 3, but got " +
            ("rank " + dy.rank));
        util.assert(filter.rank === 4, "Error in conv2dDerInput: filter must be rank 4, but got " +
            ("rank " + filter.rank));
        util.assert(inDepth === filter.shape[2], "Error in conv2dDerInput: depth of input (" + inDepth + ") must " +
            ("match input depth for filter " + filter.shape[2] + "."));
        util.assert(outDepth === filter.shape[3], "Error in conv2dDerInput: depth of output (" + outDepth + ") must" +
            ("match output depth for filter " + filter.shape[3] + "."));
        var filterHeight = filter.shape[0];
        var filterWidth = filter.shape[1];
        var _a = parseTupleParam(strides), strideHeight = _a[0], strideWidth = _a[1];
        var convInfo = conv_util.computeConv2DInfo(inShape, filterHeight, filterWidth, outDepth, strideHeight, strideWidth, pad);
        return this.executeOp('conv2dDerInput', function () { return _this.conv2dDerInputInternal(dy, filter, convInfo); });
    };
    NDArrayMath.prototype.conv2dDerBias = function (dy) {
        return this.track(this.conv2dDerBiasInternal(dy));
    };
    NDArrayMath.prototype.conv2dDerFilter = function (x, dy, filterSize, strides, pad) {
        util.assert(x.rank === 3, "Error in conv2dDerFilter: x must be rank 3, but got shape " +
            (x.shape + "."));
        util.assert(dy.rank === 3, "Error in conv2dDerFilter: dy must be rank 3, but got shape " +
            (dy.shape + "."));
        util.assert(filterSize.length === 4, "Error in conv2dDerFilter: filterSize must be length 4, but got " +
            (filterSize + "."));
        util.assert(x.shape[2] === filterSize[2], "Error in conv2dDerFilter: depth of x " + x.shape[2] + ") must " +
            ("match input depth in filter (" + filterSize[2] + "."));
        util.assert(dy.shape[2] === filterSize[3], "Error in conv2dDerFilter: depth of dy (" + dy.shape[2] + ") must " +
            ("match output depth for filter (" + filterSize[3] + ")."));
        var filterHeight = filterSize[0];
        var filterWidth = filterSize[1];
        var outDepth = filterSize[3];
        var _a = parseTupleParam(strides), strideHeight = _a[0], strideWidth = _a[1];
        var convInfo = conv_util.computeConv2DInfo(x.shape, filterHeight, filterWidth, outDepth, strideHeight, strideWidth, pad);
        return this.track(this.conv2dDerFilterInternal(x, dy, convInfo));
    };
    NDArrayMath.prototype.conv2dTranspose = function (x, filter, outputShape, strides, pad) {
        return this.conv2dDerInput(outputShape, x, filter, strides, pad);
    };
    NDArrayMath.prototype.depthwiseConv2D = function (input, filter, strides, pad, rates) {
        var _this = this;
        if (rates === void 0) { rates = [1, 1]; }
        var input4D = input;
        var reshapedTo4D = false;
        if (input.rank === 3) {
            reshapedTo4D = true;
            input4D = input.as4D(1, input.shape[0], input.shape[1], input.shape[2]);
        }
        util.assert(input4D.rank === 4, "Error in depthwiseConv2D: input must be rank 4, but got " +
            ("rank " + input4D.rank + "."));
        util.assert(filter.rank === 4, "Error in depthwiseConv2D: filter must be rank 4, but got rank " +
            (filter.rank + "."));
        util.assert(input4D.shape[3] === filter.shape[2], "Error in depthwiseConv2D: number of input channels " +
            ("(" + input4D.shape[3] + ") must match the inChannels dimension in ") +
            ("filter " + filter.shape[2] + "."));
        rates = rates || [1, 1];
        var _a = parseTupleParam(rates), rateHeight = _a[0], rateWidth = _a[1];
        util.assert(rateHeight === 1 && rateWidth === 1, 'Error in depthwiseConv2D: rates greater than 1 are not yet ' +
            ("supported. Got rates '" + rates + "'"));
        var convInfo = conv_util.computeDepthwiseConv2DInfo(input4D.shape, filter.shape, strides, pad);
        return this.executeOp('depthwiseConv2D', function () {
            var res = _this.depthwiseConv2DInternal(input4D, filter, convInfo);
            if (reshapedTo4D) {
                return res.as3D(res.shape[1], res.shape[2], res.shape[3]);
            }
            return res;
        });
    };
    NDArrayMath.prototype.maxPool = function (x, filterSize, strides, pad) {
        var _this = this;
        util.assert(x.rank === 3, "Error in maxPool: x must be rank 3 but got rank " + x.rank + ".");
        var _a = parseTupleParam(filterSize), filterHeight = _a[0], filterWidth = _a[1];
        var outDepth = x.shape[2];
        var _b = parseTupleParam(strides), strideHeight = _b[0], strideWidth = _b[1];
        var convInfo = conv_util.computeConv2DInfo(x.shape, filterHeight, filterWidth, outDepth, strideHeight, strideWidth, pad);
        return this.executeOp('maxPool', function () { return _this.maxPoolInternal(x, convInfo); });
    };
    NDArrayMath.prototype.maxPoolBackprop = function (dy, x, filterSize, strides, pad) {
        var _this = this;
        util.assert(dy.rank === 3, "Error in maxPoolBackprop: dy must be rank 3 but got rank " +
            (dy.rank + "."));
        util.assert(x.rank === 3, "Error in maxPoolBackprop: x must be rank 3 but got rank " +
            (x.rank + "."));
        var _a = parseTupleParam(filterSize), filterHeight = _a[0], filterWidth = _a[1];
        var outDepth = x.shape[2];
        var _b = parseTupleParam(strides), strideHeight = _b[0], strideWidth = _b[1];
        var convInfo = conv_util.computeConv2DInfo(x.shape, filterHeight, filterWidth, outDepth, strideHeight, strideWidth, pad);
        return this.executeOp('maxPoolBackprop', function () { return _this.maxPoolBackpropInternal(dy, x, convInfo); });
    };
    NDArrayMath.prototype.minPool = function (x, filterSize, strides, pad) {
        var _this = this;
        util.assert(x.rank === 3, "Error in minPool: x must be rank 3 but got rank " + x.rank + ".");
        var _a = parseTupleParam(filterSize), filterHeight = _a[0], filterWidth = _a[1];
        var outDepth = x.shape[2];
        var _b = parseTupleParam(strides), strideHeight = _b[0], strideWidth = _b[1];
        var convInfo = conv_util.computeConv2DInfo(x.shape, filterHeight, filterWidth, outDepth, strideHeight, strideWidth, pad);
        return this.executeOp('minPool', function () { return _this.minPoolInternal(x, convInfo); });
    };
    NDArrayMath.prototype.avgPool = function (x, filterSize, strides, pad) {
        var _this = this;
        util.assert(x.rank === 3, "Error in avgPool: x must be rank 3 but got rank " + x.rank + ".");
        var _a = parseTupleParam(filterSize), filterHeight = _a[0], filterWidth = _a[1];
        var outDepth = x.shape[2];
        var _b = parseTupleParam(strides), strideHeight = _b[0], strideWidth = _b[1];
        var convInfo = conv_util.computeConv2DInfo(x.shape, filterHeight, filterWidth, outDepth, strideHeight, strideWidth, pad);
        return this.executeOp('avgPool', function () { return _this.avgPoolInternal(x, convInfo); });
    };
    NDArrayMath.prototype.resizeBilinear3D = function (x, newShape2D, alignCorners) {
        var _this = this;
        if (alignCorners === void 0) { alignCorners = false; }
        util.assert(x.rank === 3, "Error in resizeBilinear3D: x must be rank 3 but got rank " + x.rank + ".");
        util.assert(newShape2D.length === 2, "Error in resizeBilinear3D: new shape must 2D, but got shape " +
            (newShape2D + "."));
        return this.executeOp('resizeBilinear3D', function () { return _this.resizeBilinear3DInternal(x, newShape2D, alignCorners); });
    };
    NDArrayMath.prototype.batchNormalization2D = function (x, mean, variance, varianceEpsilon, scale, offset) {
        var _this = this;
        if (varianceEpsilon === void 0) { varianceEpsilon = .001; }
        util.assert(x.rank === 2, "Error in batchNormalization3D: x must be rank 3 but got rank " +
            (x.rank + "."));
        util.assert(mean.rank === 2 || mean.rank === 1, "Error in batchNormalization2D: mean must be rank 2 or rank 1 but " +
            ("got rank " + mean.rank + "."));
        util.assert(variance.rank === 2 || variance.rank === 1, "Error in batchNormalization2D: variance must be rank 2 or rank 1 " +
            ("but got rank " + variance.rank + "."));
        if (scale != null) {
            util.assert(scale.rank === 2 || scale.rank === 1, "Error in batchNormalization2D: scale must be rank 2 or rank 1 " +
                ("but got rank " + scale.rank + "."));
        }
        if (offset != null) {
            util.assert(offset.rank === 2 || offset.rank === 1, "Error in batchNormalization2D: offset must be rank 2 or rank 1 " +
                ("but got rank " + offset.rank + "."));
        }
        return this.executeOp('batchNorm2D', function () { return _this.batchNormalization2DInternal(x, mean, variance, varianceEpsilon, scale, offset); });
    };
    NDArrayMath.prototype.batchNormalization3D = function (x, mean, variance, varianceEpsilon, scale, offset) {
        var _this = this;
        if (varianceEpsilon === void 0) { varianceEpsilon = .001; }
        util.assert(x.rank === 3, "Error in batchNormalization3D: x must be rank 3 but got rank " +
            (x.rank + "."));
        util.assert(mean.rank === 3 || mean.rank === 1, "Error in batchNormalization3D: mean must be rank 3 or rank 1 but " +
            ("got rank " + mean.rank + "."));
        util.assert(variance.rank === 3 || variance.rank === 1, "Error in batchNormalization3D: variance must be rank 3 or rank 1 " +
            ("but got rank " + variance.rank + "."));
        if (scale != null) {
            util.assert(scale.rank === 3 || scale.rank === 1, "Error in batchNormalization3D: scale must be rank 3 or rank 1 " +
                ("but got rank " + scale.rank + "."));
        }
        if (offset != null) {
            util.assert(offset.rank === 3 || offset.rank === 1, "Error in batchNormalization3D: offset must be rank 3 or rank 1 " +
                ("but got rank " + offset.rank + "."));
        }
        return this.executeOp('batchNorm3D', function () { return _this.batchNormalization3DInternal(x, mean, variance, varianceEpsilon, scale, offset); });
    };
    NDArrayMath.prototype.multiRNNCell = function (lstmCells, data, c, h) {
        var res = this.scope(function () {
            var input = data;
            var newStates = [];
            for (var i = 0; i < lstmCells.length; i++) {
                var output = lstmCells[i](input, c[i], h[i]);
                newStates.push(output[0]);
                newStates.push(output[1]);
                input = output[1];
            }
            return newStates;
        });
        var newC = [];
        var newH = [];
        for (var i = 0; i < res.length; i += 2) {
            newC.push(res[i]);
            newH.push(res[i + 1]);
        }
        return [newC, newH];
    };
    NDArrayMath.prototype.basicLSTMCell = function (forgetBias, lstmKernel, lstmBias, data, c, h) {
        var _this = this;
        var res = this.scope(function () {
            var combined = _this.concat2D(data, h, 1);
            var weighted = _this.matMul(combined, lstmKernel);
            var res = _this.add(weighted, lstmBias);
            var batchSize = res.shape[0];
            var sliceCols = res.shape[1] / 4;
            var sliceSize = [batchSize, sliceCols];
            var i = _this.slice2D(res, [0, 0], sliceSize);
            var j = _this.slice2D(res, [0, sliceCols], sliceSize);
            var f = _this.slice2D(res, [0, sliceCols * 2], sliceSize);
            var o = _this.slice2D(res, [0, sliceCols * 3], sliceSize);
            var newC = _this.addStrict(_this.multiplyStrict(c, _this.sigmoid(_this.scalarPlusArray(forgetBias, f))), _this.multiplyStrict(_this.sigmoid(i), _this.tanh(j)));
            var newH = _this.multiplyStrict(_this.tanh(newC), _this.sigmoid(o));
            return [newC, newH];
        });
        return [res[0], res[1]];
    };
    NDArrayMath.prototype.multinomial = function (probabilities, numSamples, seed) {
        var _this = this;
        var numOutcomes = probabilities.size;
        if (numOutcomes < 2) {
            throw new Error("Error in multinomial: you need at least 2 outcomes, but got " +
                (numOutcomes + "."));
        }
        if (probabilities.rank > 2) {
            throw new Error("Rank of probabilities must be 1 or 2, but is " + probabilities.rank);
        }
        seed = seed || Math.random();
        var origRank = probabilities.rank;
        if (probabilities.rank === 1) {
            probabilities = probabilities.as2D(1, -1);
        }
        return this.executeOp('multinomial', function () {
            var res = _this.multinomialInternal(probabilities, numSamples, seed);
            if (origRank === 1) {
                return res.as1D();
            }
            return res;
        });
    };
    NDArrayMath.prototype.oneHot = function (indices, depth, onValue, offValue) {
        var _this = this;
        if (onValue === void 0) { onValue = 1; }
        if (offValue === void 0) { offValue = 0; }
        if (depth < 2) {
            throw new Error("Error in oneHot: depth must be >=2, but it is " + depth);
        }
        return this.executeOp('oneHot', function () { return _this.oneHotInternal(indices, depth, onValue, offValue); });
    };
    NDArrayMath.prototype.moments = function (x, axis, keepDims) {
        var _this = this;
        if (axis === void 0) { axis = null; }
        if (keepDims === void 0) { keepDims = false; }
        var axes = axis_util.parseAxisParam(axis, x.shape);
        var result = this.scope(function () {
            var mean = _this.mean(x, axes, keepDims);
            var keepDimsShape = mean.shape;
            if (!keepDims) {
                keepDimsShape = axis_util.expandShapeToKeepDim(mean.shape, axes);
            }
            var devSquared = _this.square(_this.subtract(x, mean.reshape(keepDimsShape)));
            var variance = _this.mean(devSquared, axes, keepDims);
            return { mean: mean, variance: variance };
        });
        return result;
    };
    return NDArrayMath;
}());
exports.NDArrayMath = NDArrayMath;
var MatrixOrientation;
(function (MatrixOrientation) {
    MatrixOrientation[MatrixOrientation["REGULAR"] = 0] = "REGULAR";
    MatrixOrientation[MatrixOrientation["TRANSPOSED"] = 1] = "TRANSPOSED";
})(MatrixOrientation = exports.MatrixOrientation || (exports.MatrixOrientation = {}));
function parseTupleParam(param) {
    return typeof param === 'number' ? [param, param] : param;
}

},{"../util":88,"./axis_util":46,"./broadcast_util":47,"./concat_util":48,"./conv_util":49,"./copy2d_util":50,"./ndarray":55,"./slice_util":57}],53:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var seedrandom = require("seedrandom");
var util = require("../util");
var axis_util = require("./axis_util");
var broadcast_util = require("./broadcast_util");
var concat_util = require("./concat_util");
var conv_util = require("./conv_util");
var copy2D_util = require("./copy2d_util");
var math_1 = require("./math");
var ndarray_1 = require("./ndarray");
var NDArrayMathCPU = (function (_super) {
    __extends(NDArrayMathCPU, _super);
    function NDArrayMathCPU(safeMode) {
        if (safeMode === void 0) { safeMode = false; }
        return _super.call(this, safeMode) || this;
    }
    NDArrayMathCPU.prototype.cloneInternal = function (ndarray) {
        return ndarray_1.NDArray.make(ndarray.shape, { values: new Float32Array(ndarray.getValues()) });
    };
    NDArrayMathCPU.prototype.slice1DInternal = function (input, begin, size) {
        var newVals = input.getValues().slice(begin, begin + size);
        return ndarray_1.Array1D.new(newVals);
    };
    NDArrayMathCPU.prototype.slice2DInternal = function (input, begin, size) {
        var result = ndarray_1.Array2D.zeros(size);
        var startI = begin[0], startJ = begin[1];
        for (var i = 0; i < size[0]; ++i) {
            for (var j = 0; j < size[1]; ++j) {
                var val = input.get(i + startI, j + startJ);
                result.set(val, i, j);
            }
        }
        return result;
    };
    NDArrayMathCPU.prototype.slice3DInternal = function (input, begin, size) {
        var result = ndarray_1.Array3D.zeros(size);
        var startI = begin[0], startJ = begin[1], startK = begin[2];
        for (var i = 0; i < size[0]; ++i) {
            for (var j = 0; j < size[1]; ++j) {
                for (var k = 0; k < size[2]; ++k) {
                    var val = input.get(i + startI, j + startJ, k + startK);
                    result.set(val, i, j, k);
                }
            }
        }
        return result;
    };
    NDArrayMathCPU.prototype.slice4DInternal = function (input, begin, size) {
        var result = ndarray_1.Array4D.zeros(size);
        var startI = begin[0], startJ = begin[1], startK = begin[2], startL = begin[3];
        for (var i = 0; i < size[0]; ++i) {
            for (var j = 0; j < size[1]; ++j) {
                for (var k = 0; k < size[2]; ++k) {
                    for (var l = 0; l < size[3]; ++l) {
                        var val = input.get(i + startI, j + startJ, k + startK, l + startL);
                        result.set(val, i, j, k, l);
                    }
                }
            }
        }
        return result;
    };
    NDArrayMathCPU.prototype.copy2DInternal = function (source, sourceBeginRowCol, sourceSizeRowCol, dest, destBeginRowCol, destSizeRowCol) {
        copy2D_util.validateShapes(sourceSizeRowCol, destSizeRowCol);
        var srcValues = source.getValues();
        var dstValues = dest.getValues();
        var n = sourceSizeRowCol[0] * sourceSizeRowCol[1];
        for (var i = 0; i < n; ++i) {
            var srcRow = sourceBeginRowCol[0] + Math.floor(i / sourceSizeRowCol[1]);
            var srcCol = sourceBeginRowCol[1] + (i % sourceSizeRowCol[1]);
            var srcOff = srcRow * source.shape[1] + srcCol;
            var dstRow = destBeginRowCol[0] + Math.floor(i / destSizeRowCol[1]);
            var dstCol = destBeginRowCol[1] + (i % destSizeRowCol[1]);
            var dstOff = dstRow * dest.shape[1] + dstCol;
            dstValues[dstOff] = srcValues[srcOff];
        }
    };
    NDArrayMathCPU.prototype.concat1DInternal = function (a, b) {
        var outShape = concat_util.computeOutShape(a.shape, b.shape, 0);
        var result = ndarray_1.Array1D.zeros(outShape);
        var aVals = a.getValues();
        var bVals = b.getValues();
        var vals = result.getValues();
        vals.set(aVals, 0);
        vals.set(bVals, a.size);
        return result;
    };
    NDArrayMathCPU.prototype.concat2DInternal = function (a, b, axis) {
        var outShape = concat_util.computeOutShape(a.shape, b.shape, axis);
        var result = ndarray_1.Array2D.zeros(outShape);
        if (axis === 0) {
            var aVals = a.getValues();
            var bVals = b.getValues();
            var vals = result.getValues();
            vals.set(aVals, 0);
            vals.set(bVals, a.size);
            return result;
        }
        for (var i = 0; i < outShape[0]; ++i) {
            for (var j = 0; j < outShape[1]; ++j) {
                var index = [i, j];
                var value = void 0;
                if (index[axis] < a.shape[axis]) {
                    value = a.get(i, j);
                }
                else {
                    index[axis] -= a.shape[axis];
                    var i2 = index[0], j2 = index[1];
                    value = b.get(i2, j2);
                }
                result.set(value, i, j);
            }
        }
        return result;
    };
    NDArrayMathCPU.prototype.concat3DInternal = function (a, b, axis) {
        var outShape = concat_util.computeOutShape(a.shape, b.shape, axis);
        var result = ndarray_1.Array3D.zeros(outShape);
        if (axis === 0) {
            var aVals = a.getValues();
            var bVals = b.getValues();
            var vals = result.getValues();
            vals.set(aVals, 0);
            vals.set(bVals, a.size);
            return result;
        }
        for (var i = 0; i < outShape[0]; ++i) {
            for (var j = 0; j < outShape[1]; ++j) {
                for (var k = 0; k < outShape[2]; ++k) {
                    var index = [i, j, k];
                    var value = void 0;
                    if (index[axis] < a.shape[axis]) {
                        value = a.get(i, j, k);
                    }
                    else {
                        index[axis] -= a.shape[axis];
                        var i2 = index[0], j2 = index[1], k2 = index[2];
                        value = b.get(i2, j2, k2);
                    }
                    result.set(value, i, j, k);
                }
            }
        }
        return result;
    };
    NDArrayMathCPU.prototype.concat4DInternal = function (a, b, axis) {
        var outShape = concat_util.computeOutShape(a.shape, b.shape, axis);
        var result = ndarray_1.Array4D.zeros(outShape);
        if (axis === 0) {
            var aVals = a.getValues();
            var bVals = b.getValues();
            var vals = result.getValues();
            vals.set(aVals, 0);
            vals.set(bVals, a.size);
            return result;
        }
        for (var i = 0; i < outShape[0]; ++i) {
            for (var j = 0; j < outShape[1]; ++j) {
                for (var k = 0; k < outShape[2]; ++k) {
                    for (var l = 0; l < outShape[3]; ++l) {
                        var index = [i, j, k, l];
                        var value = void 0;
                        if (index[axis] < a.shape[axis]) {
                            value = a.get(i, j, k, l);
                        }
                        else {
                            index[axis] -= a.shape[axis];
                            var i2 = index[0], j2 = index[1], k2 = index[2], l2 = index[3];
                            value = b.get(i2, j2, k2, l2);
                        }
                        result.set(value, i, j, k, l);
                    }
                }
            }
        }
        return result;
    };
    NDArrayMathCPU.prototype.scaledArrayAddInternal = function (c1, a, c2, b) {
        var c1Val = c1.get();
        var c2Val = c2.get();
        return this.broadcastedBinaryOp(a, b, 'float32', function (aVal, bVal) {
            return c1Val * aVal + c2Val * bVal;
        });
    };
    NDArrayMathCPU.prototype.negInternal = function (a) {
        return this.scalarTimesArray(ndarray_1.Scalar.NEG_ONE, a);
    };
    NDArrayMathCPU.prototype.addInternal = function (a, b) {
        return this.scaledArrayAddInternal(ndarray_1.Scalar.ONE, a, ndarray_1.Scalar.ONE, b);
    };
    NDArrayMathCPU.prototype.subtractInternal = function (a, b) {
        return this.scaledArrayAddInternal(ndarray_1.Scalar.ONE, a, ndarray_1.Scalar.NEG_ONE, b);
    };
    NDArrayMathCPU.prototype.matMulInternal = function (a, b, aOrientation, bOrientation) {
        if (aOrientation === void 0) { aOrientation = math_1.MatrixOrientation.REGULAR; }
        if (bOrientation === void 0) { bOrientation = math_1.MatrixOrientation.REGULAR; }
        var sharedDim = (aOrientation === math_1.MatrixOrientation.REGULAR) ? a.shape[1] : a.shape[0];
        var leftDim = (aOrientation === math_1.MatrixOrientation.REGULAR) ? a.shape[0] : a.shape[1];
        var rightDim = (bOrientation === math_1.MatrixOrientation.REGULAR) ? b.shape[1] : b.shape[0];
        var normalGetter = function (matrix, i, j) {
            return matrix.get(i, j);
        };
        var transposedGetter = function (matrix, i, j) {
            return matrix.get(j, i);
        };
        var aGetter = (aOrientation === math_1.MatrixOrientation.REGULAR) ?
            normalGetter :
            transposedGetter;
        var bGetter = (bOrientation === math_1.MatrixOrientation.REGULAR) ?
            normalGetter :
            transposedGetter;
        var values = new Float32Array(leftDim * rightDim);
        var index = 0;
        for (var i = 0; i < leftDim; ++i) {
            for (var j = 0; j < rightDim; ++j) {
                var sum = 0;
                for (var k = 0; k < sharedDim; ++k) {
                    sum += aGetter(a, i, k) * bGetter(b, k, j);
                }
                values[index++] = sum;
            }
        }
        return ndarray_1.Array2D.new([leftDim, rightDim], values);
    };
    NDArrayMathCPU.prototype.multiplyInternal = function (a, b) {
        var newShape = broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);
        var newValues = new Float32Array(util.sizeFromShape(newShape));
        var aValues = a.getValues();
        var bValues = b.getValues();
        for (var i = 0; i < newValues.length; ++i) {
            newValues[i] = aValues[i % a.size] * bValues[i % b.size];
        }
        return ndarray_1.NDArray.make(newShape, { values: newValues });
    };
    NDArrayMathCPU.prototype.divideInternal = function (a, b) {
        var newShape = broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);
        var newValues = new Float32Array(util.sizeFromShape(newShape));
        var aValues = a.getValues();
        var bValues = b.getValues();
        for (var i = 0; i < newValues.length; ++i) {
            newValues[i] = aValues[i % a.size] / bValues[i % b.size];
        }
        return ndarray_1.NDArray.make(newShape, { values: newValues }, 'float32');
    };
    NDArrayMathCPU.prototype.sumInternal = function (input, axes) {
        axis_util.assertAxesAreInnerMostDims('sum', axes, input.rank);
        var _a = axis_util.computeOutAndReduceShapes(input.shape, axes), outShape = _a[0], reduceShape = _a[1];
        var resultDtype = math_1.SumTypesMap[input.dtype];
        var result = ndarray_1.NDArray.zeros(outShape, resultDtype);
        var reduceSize = util.sizeFromShape(reduceShape);
        var vals = result.getValues();
        var aVals = input.getValues();
        for (var i = 0; i < vals.length; ++i) {
            var offset = i * reduceSize;
            var sum = 0;
            for (var j = 0; j < reduceSize; ++j) {
                sum += aVals[offset + j];
            }
            vals[i] = sum;
        }
        return result;
    };
    NDArrayMathCPU.prototype.argMinInternal = function (input, axes) {
        axis_util.assertAxesAreInnerMostDims('argMin', axes, input.rank);
        var _a = axis_util.computeOutAndReduceShapes(input.shape, axes), outShape = _a[0], reduceShape = _a[1];
        var result = ndarray_1.NDArray.zeros(outShape, 'int32');
        var reduceSize = util.sizeFromShape(reduceShape);
        var vals = result.getValues();
        var aVals = input.getValues();
        for (var i = 0; i < vals.length; ++i) {
            var offset = i * reduceSize;
            var min = aVals[offset];
            var minIndex = 0;
            for (var j = 0; j < reduceSize; ++j) {
                var value = aVals[offset + j];
                if (isNaN(value)) {
                    minIndex = util.NAN_INT32;
                    break;
                }
                if (value < min) {
                    min = value;
                    minIndex = j;
                }
            }
            vals[i] = minIndex;
        }
        return result;
    };
    NDArrayMathCPU.prototype.argMaxInternal = function (input, axes) {
        axis_util.assertAxesAreInnerMostDims('argMax', axes, input.rank);
        var _a = axis_util.computeOutAndReduceShapes(input.shape, axes), outShape = _a[0], reduceShape = _a[1];
        var result = ndarray_1.NDArray.zeros(outShape, 'int32');
        var reduceSize = util.sizeFromShape(reduceShape);
        var vals = result.getValues();
        var aVals = input.getValues();
        for (var i = 0; i < vals.length; ++i) {
            var offset = i * reduceSize;
            var max = aVals[offset];
            var maxIndex = 0;
            for (var j = 0; j < reduceSize; ++j) {
                var value = aVals[offset + j];
                if (isNaN(value)) {
                    maxIndex = util.NAN_INT32;
                    break;
                }
                if (value > max) {
                    max = value;
                    maxIndex = j;
                }
            }
            vals[i] = maxIndex;
        }
        return result;
    };
    NDArrayMathCPU.prototype.equalInternal = function (a, b) {
        return this.broadcastedBinaryOp(a, b, 'bool', function (aVal, bVal) {
            if (util.isValNaN(aVal, a.dtype) || util.isValNaN(bVal, b.dtype)) {
                return util.getNaN('bool');
            }
            else {
                return (aVal === bVal) ? 1 : 0;
            }
        });
    };
    NDArrayMathCPU.prototype.topKInternal = function (ndarray, k) {
        var values = ndarray.getValues();
        var valuesAndIndices = [];
        for (var i = 0; i < values.length; i++) {
            valuesAndIndices.push({ value: values[i], index: i });
        }
        valuesAndIndices.sort(function (a, b) {
            return b.value - a.value;
        });
        var topkValues = new Float32Array(k);
        var topkIndices = new Float32Array(k);
        for (var i = 0; i < k; i++) {
            topkValues[i] = valuesAndIndices[i].value;
            topkIndices[i] = valuesAndIndices[i].index;
        }
        return { values: ndarray_1.Array1D.new(topkValues), indices: ndarray_1.Array1D.new(topkIndices) };
    };
    NDArrayMathCPU.prototype.minInternal = function (input, axes) {
        axis_util.assertAxesAreInnerMostDims('min', axes, input.rank);
        var _a = axis_util.computeOutAndReduceShapes(input.shape, axes), outShape = _a[0], reduceShape = _a[1];
        var result = ndarray_1.NDArray.zeros(outShape, input.dtype);
        var reduceSize = util.sizeFromShape(reduceShape);
        var vals = result.getValues();
        var aVals = input.getValues();
        for (var i = 0; i < vals.length; ++i) {
            var offset = i * reduceSize;
            var min = aVals[0];
            for (var j = 0; j < reduceSize; ++j) {
                var value = aVals[offset + j];
                if (isNaN(value)) {
                    min = Number.NaN;
                    break;
                }
                if (value < min) {
                    min = value;
                }
            }
            vals[i] = min;
        }
        return result;
    };
    NDArrayMathCPU.prototype.maxInternal = function (input, axes) {
        axis_util.assertAxesAreInnerMostDims('max', axes, input.rank);
        var _a = axis_util.computeOutAndReduceShapes(input.shape, axes), outShape = _a[0], reduceShape = _a[1];
        var result = ndarray_1.NDArray.zeros(outShape, input.dtype);
        var reduceSize = util.sizeFromShape(reduceShape);
        var vals = result.getValues();
        var aVals = input.getValues();
        for (var i = 0; i < vals.length; ++i) {
            var offset = i * reduceSize;
            var max = aVals[offset];
            for (var j = 0; j < reduceSize; ++j) {
                var value = aVals[offset + j];
                if (isNaN(value)) {
                    max = Number.NaN;
                    break;
                }
                if (value > max) {
                    max = value;
                }
            }
            vals[i] = max;
        }
        return result;
    };
    NDArrayMathCPU.prototype.ceilInternal = function (ndarray) {
        var values = ndarray.getValues();
        var newValues = new Float32Array(values.length);
        for (var i = 0; i < values.length; ++i) {
            newValues[i] = Math.ceil(values[i]);
        }
        return ndarray_1.NDArray.make(ndarray.shape, { values: newValues });
    };
    NDArrayMathCPU.prototype.floorInternal = function (ndarray) {
        var values = ndarray.getValues();
        var newValues = new Float32Array(values.length);
        for (var i = 0; i < values.length; ++i) {
            newValues[i] = Math.floor(values[i]);
        }
        return ndarray_1.NDArray.make(ndarray.shape, { values: newValues });
    };
    NDArrayMathCPU.prototype.expInternal = function (ndarray) {
        var values = ndarray.getValues();
        var newValues = new Float32Array(values.length);
        for (var i = 0; i < values.length; ++i) {
            newValues[i] = Math.exp(values[i]);
        }
        return ndarray_1.NDArray.make(ndarray.shape, { values: newValues });
    };
    NDArrayMathCPU.prototype.logInternal = function (ndarray) {
        var values = ndarray.getValues();
        var newValues = new Float32Array(values.length);
        for (var i = 0; i < values.length; ++i) {
            var value = values[i];
            newValues[i] = Math.log(value);
        }
        return ndarray_1.NDArray.make(ndarray.shape, { values: newValues });
    };
    NDArrayMathCPU.prototype.sqrtInternal = function (ndarray) {
        var values = ndarray.getValues();
        var newValues = new Float32Array(values.length);
        for (var i = 0; i < values.length; ++i) {
            var value = values[i];
            newValues[i] = Math.sqrt(value);
        }
        return ndarray_1.NDArray.make(ndarray.shape, { values: newValues });
    };
    NDArrayMathCPU.prototype.squareInternal = function (x) {
        var values = x.getValues();
        var newValues = new Float32Array(values.length);
        for (var i = 0; i < values.length; ++i) {
            var value = values[i];
            newValues[i] = value * value;
        }
        return ndarray_1.NDArray.make(x.shape, { values: newValues });
    };
    NDArrayMathCPU.prototype.reluInternal = function (input) {
        var res = ndarray_1.NDArray.zeros(input.shape, input.dtype);
        var resVals = res.getValues();
        var inVals = input.getValues();
        for (var i = 0; i < inVals.length; ++i) {
            var val = inVals[i];
            if (util.isValNaN(val, input.dtype)) {
                resVals[i] = util.getNaN(res.dtype);
            }
            else {
                resVals[i] = Math.max(0, inVals[i]);
            }
        }
        return res;
    };
    NDArrayMathCPU.prototype.eluInternal = function (ndarray) {
        var resultValues = new Float32Array(ndarray.size);
        var values = ndarray.dataSync();
        for (var i = 0; i < values.length; ++i) {
            var v = values[i];
            if (v >= 0) {
                resultValues[i] = v;
            }
            else {
                resultValues[i] = (Math.exp(v) - 1);
            }
        }
        return ndarray_1.NDArray.make(ndarray.shape, { values: resultValues });
    };
    NDArrayMathCPU.prototype.leakyReluInternal = function (ndarray, alpha) {
        var resultValues = new Float32Array(ndarray.size);
        var values = ndarray.dataSync();
        for (var i = 0; i < values.length; i++) {
            var v = values[i];
            if (v >= 0) {
                resultValues[i] = v;
            }
            else {
                resultValues[i] = alpha * v;
            }
        }
        return ndarray_1.NDArray.make(ndarray.shape, { values: resultValues });
    };
    NDArrayMathCPU.prototype.clipInternal = function (ndarray, min, max) {
        var resultValues = new Float32Array(ndarray.size);
        var values = ndarray.getValues();
        for (var i = 0; i < values.length; ++i) {
            resultValues[i] = Math.min(max, Math.max(min, values[i]));
        }
        return ndarray_1.NDArray.make(ndarray.shape, { values: resultValues });
    };
    NDArrayMathCPU.prototype.absInternal = function (ndarray) {
        var resultValues = new Float32Array(ndarray.size);
        var values = ndarray.getValues();
        for (var i = 0; i < values.length; ++i) {
            resultValues[i] = Math.abs(values[i]);
        }
        return ndarray_1.NDArray.make(ndarray.shape, { values: resultValues });
    };
    NDArrayMathCPU.prototype.sigmoidInternal = function (ndarray) {
        var resultValues = new Float32Array(ndarray.size);
        var values = ndarray.getValues();
        for (var i = 0; i < values.length; ++i) {
            resultValues[i] = 1 / (1 + Math.exp(-values[i]));
        }
        return ndarray_1.NDArray.make(ndarray.shape, { values: resultValues });
    };
    NDArrayMathCPU.prototype.sinInternal = function (ndarray) {
        var resultValues = new Float32Array(ndarray.size);
        var values = ndarray.getValues();
        for (var i = 0; i < values.length; ++i) {
            resultValues[i] = Math.sin(values[i]);
        }
        return ndarray_1.NDArray.make(ndarray.shape, { values: resultValues });
    };
    NDArrayMathCPU.prototype.cosInternal = function (ndarray) {
        var resultValues = new Float32Array(ndarray.size);
        var values = ndarray.getValues();
        for (var i = 0; i < values.length; ++i) {
            resultValues[i] = Math.cos(values[i]);
        }
        return ndarray_1.NDArray.make(ndarray.shape, { values: resultValues });
    };
    NDArrayMathCPU.prototype.tanInternal = function (ndarray) {
        var resultValues = new Float32Array(ndarray.size);
        var values = ndarray.getValues();
        for (var i = 0; i < values.length; ++i) {
            resultValues[i] = Math.tan(values[i]);
        }
        return ndarray_1.NDArray.make(ndarray.shape, { values: resultValues });
    };
    NDArrayMathCPU.prototype.asinInternal = function (ndarray) {
        var resultValues = new Float32Array(ndarray.size);
        var values = ndarray.getValues();
        for (var i = 0; i < values.length; ++i) {
            resultValues[i] = Math.asin(values[i]);
        }
        return ndarray_1.NDArray.make(ndarray.shape, { values: resultValues });
    };
    NDArrayMathCPU.prototype.acosInternal = function (ndarray) {
        var resultValues = new Float32Array(ndarray.size);
        var values = ndarray.getValues();
        for (var i = 0; i < values.length; ++i) {
            resultValues[i] = Math.acos(values[i]);
        }
        return ndarray_1.NDArray.make(ndarray.shape, { values: resultValues });
    };
    NDArrayMathCPU.prototype.atanInternal = function (ndarray) {
        var resultValues = new Float32Array(ndarray.size);
        var values = ndarray.getValues();
        for (var i = 0; i < values.length; ++i) {
            resultValues[i] = Math.atan(values[i]);
        }
        return ndarray_1.NDArray.make(ndarray.shape, { values: resultValues });
    };
    NDArrayMathCPU.prototype.sinhInternal = function (ndarray) {
        var resultValues = new Float32Array(ndarray.size);
        var values = ndarray.getValues();
        for (var i = 0; i < values.length; ++i) {
            resultValues[i] = Math.sinh(values[i]);
        }
        return ndarray_1.NDArray.make(ndarray.shape, { values: resultValues });
    };
    NDArrayMathCPU.prototype.coshInternal = function (ndarray) {
        var resultValues = new Float32Array(ndarray.size);
        var values = ndarray.getValues();
        for (var i = 0; i < values.length; ++i) {
            resultValues[i] = Math.cosh(values[i]);
        }
        return ndarray_1.NDArray.make(ndarray.shape, { values: resultValues });
    };
    NDArrayMathCPU.prototype.tanhInternal = function (ndarray) {
        var resultValues = new Float32Array(ndarray.size);
        var values = ndarray.getValues();
        for (var i = 0; i < values.length; ++i) {
            resultValues[i] = util.tanh(values[i]);
        }
        return ndarray_1.NDArray.make(ndarray.shape, { values: resultValues });
    };
    NDArrayMathCPU.prototype.stepInternal = function (ndarray, alpha) {
        if (alpha === void 0) { alpha = 0; }
        var resultValues = new Float32Array(ndarray.size);
        var values = ndarray.getValues();
        for (var i = 0; i < values.length; ++i) {
            var value = values[i];
            resultValues[i] = value > 0 ? 1 : (value < 0 ? alpha : value);
        }
        return ndarray_1.NDArray.make(ndarray.shape, { values: resultValues });
    };
    NDArrayMathCPU.prototype.conv2dInternal = function (x, filter, bias, convInfo) {
        var _a = x.shape, xRows = _a[0], xCols = _a[1], inputDepth = _a[2];
        var filterHeight = filter.shape[0];
        var filterWidth = filter.shape[1];
        var outDepth = filter.shape[3];
        var padLeft = convInfo.padInfo.left;
        var padTop = convInfo.padInfo.top;
        var y = ndarray_1.Array3D.zeros(convInfo.outShape);
        for (var d2 = 0; d2 < outDepth; ++d2) {
            for (var yR = 0; yR < y.shape[0]; ++yR) {
                var xRCorner = yR * convInfo.strideHeight - padLeft;
                var xRMin = Math.max(0, xRCorner);
                var xRMax = Math.min(xRows, filterHeight + xRCorner);
                for (var yC = 0; yC < y.shape[1]; ++yC) {
                    var xCCorner = yC * convInfo.strideWidth - padTop;
                    var xCMin = Math.max(0, xCCorner);
                    var xCMax = Math.min(xCols, filterWidth + xCCorner);
                    var dotProd = 0;
                    for (var xR = xRMin; xR < xRMax; ++xR) {
                        var wR = xR - xRCorner;
                        for (var xC = xCMin; xC < xCMax; ++xC) {
                            var wC = xC - xCCorner;
                            for (var d1 = 0; d1 < inputDepth; ++d1) {
                                var pixel = x.get(xR, xC, d1);
                                var weight = filter.get(wR, wC, d1, d2);
                                dotProd += pixel * weight;
                            }
                        }
                    }
                    var biasVal = (bias != null) ? bias.get(d2) : 0;
                    y.set(dotProd + biasVal, yR, yC, d2);
                }
            }
        }
        return y;
    };
    NDArrayMathCPU.prototype.conv2dDerInputInternal = function (dy, filter, convInfo) {
        var inDepth = filter.shape[2];
        var outDepth = filter.shape[3];
        var yRows = dy.shape[0];
        var yCols = dy.shape[1];
        var filterHeight = filter.shape[0];
        var filterWidth = filter.shape[1];
        var topPad = filterHeight - 1 - convInfo.padInfo.top;
        var leftPad = filterWidth - 1 - convInfo.padInfo.left;
        var strideHeight = convInfo.strideHeight;
        var strideWidth = convInfo.strideWidth;
        var dx = ndarray_1.Array3D.zeros(convInfo.inShape);
        for (var d1 = 0; d1 < inDepth; ++d1) {
            for (var xR = 0; xR < dx.shape[0]; ++xR) {
                var xRCorner = xR - leftPad;
                var xRMin = Math.max(0, Math.ceil(xRCorner / strideHeight));
                var yRMax = Math.min(yRows, (filterHeight + xRCorner) / strideHeight);
                for (var xC = 0; xC < dx.shape[1]; ++xC) {
                    var xCCorner = xC - topPad;
                    var xCMin = Math.max(0, Math.ceil(xCCorner / strideWidth));
                    var yCMax = Math.min(yCols, (filterWidth + xCCorner) / strideWidth);
                    var dotProd = 0;
                    for (var yR = xRMin; yR < yRMax; ++yR) {
                        var wR = yR * strideHeight - xRCorner;
                        for (var yC = xCMin; yC < yCMax; ++yC) {
                            var wC = yC * strideWidth - xCCorner;
                            for (var d2 = 0; d2 < outDepth; ++d2) {
                                var pixel = dy.get(yR, yC, d2);
                                var weight = filter.get(filterHeight - 1 - wR, filterWidth - 1 - wC, d1, d2);
                                dotProd += pixel * weight;
                            }
                        }
                    }
                    dx.set(dotProd, xR, xC, d1);
                }
            }
        }
        return dx;
    };
    NDArrayMathCPU.prototype.conv2dDerFilterInternal = function (x, dY, convInfo) {
        var inputDepth = x.shape[2];
        var outputDepth = dY.shape[2];
        var strideHeight = convInfo.strideHeight;
        var strideWidth = convInfo.strideWidth;
        var filterHeight = convInfo.filterHeight;
        var filterWidth = convInfo.filterWidth;
        var weightsShape = conv_util.computeWeightsShape4D(inputDepth, outputDepth, filterHeight, filterWidth);
        var dW = ndarray_1.Array4D.zeros(weightsShape);
        var yNumRows = dY.shape[0];
        var yNumCols = dY.shape[1];
        var xNumRows = x.shape[0];
        var xNumCols = x.shape[1];
        var leftPad = convInfo.padInfo.left;
        var topPad = convInfo.padInfo.top;
        for (var wR = 0; wR < filterHeight; ++wR) {
            var yRMin = Math.max(0, Math.ceil((topPad - wR) / strideHeight));
            var yRMax = Math.min(yNumRows, (xNumRows + topPad - wR) / strideHeight);
            for (var wC = 0; wC < filterWidth; ++wC) {
                var yCMin = Math.max(0, Math.ceil((leftPad - wC) / strideWidth));
                var yCMax = Math.min(yNumCols, (xNumCols + leftPad - wC) / strideWidth);
                for (var d1 = 0; d1 < inputDepth; ++d1) {
                    for (var d2 = 0; d2 < outputDepth; ++d2) {
                        var dotProd = 0;
                        for (var yR = yRMin; yR < yRMax; ++yR) {
                            var xR = wR + yR * strideHeight - topPad;
                            for (var yC = yCMin; yC < yCMax; ++yC) {
                                var xC = wC + yC * strideWidth - leftPad;
                                dotProd += x.get(xR, xC, d1) * dY.get(yR, yC, d2);
                            }
                        }
                        dW.set(dotProd, wR, wC, d1, d2);
                    }
                }
            }
        }
        return dW;
    };
    NDArrayMathCPU.prototype.conv2dDerBiasInternal = function (dY) {
        var outputDepth = dY.shape[2];
        var numRows = dY.shape[0];
        var numCols = dY.shape[1];
        var values = new Float32Array(outputDepth);
        for (var d2 = 0; d2 < outputDepth; ++d2) {
            var sum = 0;
            for (var r = 0; r < numRows; ++r) {
                for (var c = 0; c < numCols; ++c) {
                    sum += dY.get(r, c, d2);
                }
            }
            values[d2] = sum;
        }
        return ndarray_1.Array1D.new(values);
    };
    NDArrayMathCPU.prototype.depthwiseConv2DInternal = function (input, filter, convInfo) {
        var _a = convInfo.inShape, numBatches = _a[0], xRows = _a[1], xCols = _a[2], inChannels = _a[3];
        var filterHeight = convInfo.filterHeight;
        var filterWidth = convInfo.filterWidth;
        var padLeft = convInfo.padInfo.left;
        var padTop = convInfo.padInfo.top;
        var yRows = convInfo.outShape[1];
        var yCols = convInfo.outShape[2];
        var chMul = convInfo.channelMul;
        var y = ndarray_1.Array4D.zeros(convInfo.outShape);
        for (var b = 0; b < numBatches; ++b) {
            for (var d1 = 0; d1 < inChannels; ++d1) {
                for (var yR = 0; yR < yRows; ++yR) {
                    var xRCorner = yR * convInfo.strideHeight - padLeft;
                    var xRMin = Math.max(0, xRCorner);
                    var xRMax = Math.min(xRows, filterHeight + xRCorner);
                    for (var yC = 0; yC < yCols; ++yC) {
                        var xCCorner = yC * convInfo.strideWidth - padTop;
                        var xCMin = Math.max(0, xCCorner);
                        var xCMax = Math.min(xCols, filterWidth + xCCorner);
                        for (var q = 0; q < chMul; ++q) {
                            var dotProd = 0;
                            for (var xR = xRMin; xR < xRMax; ++xR) {
                                var wR = xR - xRCorner;
                                for (var xC = xCMin; xC < xCMax; ++xC) {
                                    var wC = xC - xCCorner;
                                    var pixel = input.get(b, xR, xC, d1);
                                    var weight = filter.get(wR, wC, d1, q);
                                    dotProd += pixel * weight;
                                }
                            }
                            y.set(dotProd, b, yR, yC, d1 * chMul + q);
                        }
                    }
                }
            }
        }
        return y;
    };
    NDArrayMathCPU.prototype.tileInternal = function (a, reps) {
        var newShape = new Array(a.rank);
        for (var i = 0; i < newShape.length; i++) {
            newShape[i] = a.shape[i] * reps[i];
        }
        var dtype;
        if (a.dtype === 'float32') {
            dtype = Float32Array;
        }
        else if (a.dtype === 'int32') {
            dtype = Int32Array;
        }
        else if (a.dtype === 'bool') {
            dtype = Uint8Array;
        }
        else {
            throw new Error("Dtype " + a.dtype + " not supported for tile");
        }
        var resultValues = new dtype(util.sizeFromShape(newShape));
        var result = ndarray_1.NDArray.make(newShape, { values: resultValues }, a.dtype);
        var values = a.getValues();
        for (var i = 0; i < result.size; ++i) {
            var newLoc = result.indexToLoc(i);
            var originalLoc = new Array(a.rank);
            for (var i_1 = 0; i_1 < originalLoc.length; i_1++) {
                originalLoc[i_1] = newLoc[i_1] % a.shape[i_1];
            }
            var originalIndex = a.locToIndex(originalLoc);
            resultValues[i] = values[originalIndex];
        }
        return result;
    };
    NDArrayMathCPU.prototype.transposeInternal = function (a, perm) {
        var newShape = new Array(a.rank);
        for (var i = 0; i < newShape.length; i++) {
            newShape[i] = a.shape[perm[i]];
        }
        var resultValues = new Float32Array(a.size);
        var values = a.getValues();
        var result = ndarray_1.NDArray.make(newShape, { values: resultValues });
        for (var i = 0; i < a.size; ++i) {
            var loc = a.indexToLoc(i);
            var newLoc = new Array(loc.length);
            for (var i_2 = 0; i_2 < newLoc.length; i_2++) {
                newLoc[i_2] = loc[perm[i_2]];
            }
            var newIndex = result.locToIndex(newLoc);
            resultValues[newIndex] = values[i];
        }
        return result;
    };
    NDArrayMathCPU.prototype.pool = function (x, convInfo, poolType) {
        var _a = x.shape, xRows = _a[0], xCols = _a[1], depth = _a[2];
        var strideHeight = convInfo.strideHeight;
        var strideWidth = convInfo.strideWidth;
        var filterHeight = convInfo.filterHeight;
        var filterWidth = convInfo.filterWidth;
        var y = ndarray_1.Array3D.zeros(convInfo.outShape);
        var padTop = convInfo.padInfo.top;
        var padLeft = convInfo.padInfo.left;
        for (var d = 0; d < depth; ++d) {
            for (var yR = 0; yR < y.shape[0]; ++yR) {
                var xRCorner = yR * strideHeight - padTop;
                var xRMin = Math.max(0, xRCorner);
                var xRMax = Math.min(xRows, filterHeight + xRCorner);
                for (var yC = 0; yC < y.shape[1]; ++yC) {
                    var xCCorner = yC * strideWidth - padLeft;
                    var xCMin = Math.max(0, xCCorner);
                    var xCMax = Math.min(xCols, filterWidth + xCCorner);
                    var minMaxValue = (poolType === 'max' ? Number.NEGATIVE_INFINITY :
                        Number.POSITIVE_INFINITY);
                    var avgValue = 0;
                    for (var xR = xRMin; xR < xRMax; ++xR) {
                        for (var xC = xCMin; xC < xCMax; ++xC) {
                            var pixel = x.get(xR, xC, d);
                            if (isNaN(pixel)) {
                                minMaxValue = NaN;
                                avgValue = NaN;
                                break;
                            }
                            if ((poolType === 'max' && pixel > minMaxValue) ||
                                (poolType === 'min' && pixel < minMaxValue)) {
                                minMaxValue = pixel;
                            }
                            else if (poolType === 'avg') {
                                avgValue += pixel / (filterHeight * filterWidth);
                            }
                        }
                        if (isNaN(minMaxValue)) {
                            break;
                        }
                    }
                    y.set(poolType === 'avg' ? avgValue : minMaxValue, yR, yC, d);
                }
            }
        }
        return y;
    };
    NDArrayMathCPU.prototype.maxPoolInternal = function (x, convInfo) {
        return this.pool(x, convInfo, 'max');
    };
    NDArrayMathCPU.prototype.maxPoolPositions = function (x, convInfo) {
        var _a = x.shape, xRows = _a[0], xCols = _a[1], depth = _a[2];
        var outputShape = convInfo.outShape;
        var maxPositions = ndarray_1.Array3D.zeros(outputShape);
        var strideHeight = convInfo.strideHeight;
        var strideWidth = convInfo.strideWidth;
        var filterHeight = convInfo.filterHeight;
        var filterWidth = convInfo.filterWidth;
        var padTop = convInfo.padInfo.top;
        var padLeft = convInfo.padInfo.left;
        for (var d = 0; d < depth; ++d) {
            for (var yR = 0; yR < outputShape[0]; ++yR) {
                var xRCorner = yR * strideHeight - padTop;
                var xRMin = Math.max(0, xRCorner);
                var xRMax = Math.min(xRows, filterHeight + xRCorner);
                for (var yC = 0; yC < outputShape[1]; ++yC) {
                    var xCCorner = yC * strideWidth - padLeft;
                    var xCMin = Math.max(0, xCCorner);
                    var xCMax = Math.min(xCols, filterWidth + xCCorner);
                    var maxValue = Number.NEGATIVE_INFINITY;
                    var maxPosition = -1;
                    for (var xR = xRMin; xR < xRMax; ++xR) {
                        var wR = xR - xRCorner;
                        for (var xC = xCMin; xC < xCMax; ++xC) {
                            var wC = xC - xCCorner;
                            var pixel = x.get(xR, xC, d);
                            if (pixel > maxValue) {
                                maxValue = pixel;
                                maxPosition = wR * filterWidth + wC;
                            }
                        }
                    }
                    maxPositions.set(maxPosition, yR, yC, d);
                }
            }
        }
        return maxPositions;
    };
    NDArrayMathCPU.prototype.maxPoolBackpropInternal = function (dy, x, convInfo) {
        var maxPositions = this.maxPoolPositions(x, convInfo);
        var strideHeight = convInfo.strideHeight;
        var strideWidth = convInfo.strideWidth;
        var filterHeight = convInfo.filterHeight;
        var filterWidth = convInfo.filterWidth;
        var padLeft = filterWidth - 1 - convInfo.padInfo.left;
        var padTop = filterHeight - 1 - convInfo.padInfo.top;
        var _a = dy.shape, dyRows = _a[0], dyCols = _a[1], depth = _a[2];
        var dx = ndarray_1.Array3D.zeros(x.shape);
        for (var d = 0; d < depth; ++d) {
            for (var dxR = 0; dxR < dx.shape[0]; ++dxR) {
                for (var dxC = 0; dxC < dx.shape[1]; ++dxC) {
                    var dyRCorner = dxR - padTop;
                    var dyCCorner = dxC - padLeft;
                    var dotProd = 0;
                    for (var wR = 0; wR < filterHeight; ++wR) {
                        var dyR = (dyRCorner + wR) / strideHeight;
                        if (dyR < 0 || dyR >= dyRows || Math.floor(dyR) !== dyR) {
                            continue;
                        }
                        for (var wC = 0; wC < filterWidth; ++wC) {
                            var dyC = (dyCCorner + wC) / strideWidth;
                            if (dyC < 0 || dyC >= dyCols || Math.floor(dyC) !== dyC) {
                                continue;
                            }
                            var maxPos = filterHeight * filterWidth - 1 -
                                maxPositions.get(dyR, dyC, d);
                            var curPos = wR * filterWidth + wC;
                            var mask = maxPos === curPos ? 1 : 0;
                            if (mask === 0) {
                                continue;
                            }
                            var pixel = dy.get(dyR, dyC, d);
                            dotProd += pixel * mask;
                        }
                    }
                    dx.set(dotProd, dxR, dxC, d);
                }
            }
        }
        return dx;
    };
    NDArrayMathCPU.prototype.minPoolInternal = function (x, convInfo) {
        return this.pool(x, convInfo, 'min');
    };
    NDArrayMathCPU.prototype.avgPoolInternal = function (x, convInfo) {
        return this.pool(x, convInfo, 'avg');
    };
    NDArrayMathCPU.prototype.resizeBilinear3DInternal = function (x, newShape2D, alignCorners) {
        var output = ndarray_1.Array3D.zeros([newShape2D[0], newShape2D[1], x.shape[2]]);
        var effectiveInputSize = alignCorners ? [x.shape[0] - 1, x.shape[1] - 1, x.shape[2]] : x.shape;
        var effectiveOutputSize = alignCorners ?
            [output.shape[0] - 1, output.shape[1] - 1, output.shape[2]] :
            output.shape;
        for (var r = 0; r < output.shape[0]; r++) {
            for (var c = 0; c < output.shape[1]; c++) {
                for (var d = 0; d < output.shape[2]; d++) {
                    var sourceFracRow = (effectiveInputSize[0]) * r / (effectiveOutputSize[0]);
                    var sourceFracCol = (effectiveInputSize[1]) * c / (effectiveOutputSize[1]);
                    var sourceRowFloor = Math.floor(sourceFracRow);
                    var sourceRowCeil = Math.min(x.shape[0] - 1, Math.ceil(sourceFracRow));
                    var sourceColFloor = Math.floor(sourceFracCol);
                    var sourceColCeil = Math.min(x.shape[1] - 1, Math.ceil(sourceFracCol));
                    var topLeft = x.get(sourceRowFloor, sourceColFloor, d);
                    var bottomLeft = x.get(sourceRowCeil, sourceColFloor, d);
                    var topRight = x.get(sourceRowFloor, sourceColCeil, d);
                    var bottomRight = x.get(sourceRowCeil, sourceColCeil, d);
                    var rowFrac = sourceFracRow - sourceRowFloor;
                    var colFrac = sourceFracCol - sourceColFloor;
                    var top_1 = topLeft + (topRight - topLeft) * colFrac;
                    var bottom = bottomLeft + (bottomRight - bottomLeft) * colFrac;
                    var newValue = top_1 + (bottom - top_1) * rowFrac;
                    output.set(newValue, r, c, d);
                }
            }
        }
        return output;
    };
    NDArrayMathCPU.prototype.batchNormalization2DInternal = function (x, mean, variance, varianceEpsilon, scale, offset) {
        var xValues = x.getValues();
        var meanValues = mean.getValues();
        var varianceValues = variance.getValues();
        var scaleValues = scale ? scale.getValues() : new Float32Array([1]);
        var offsetValues = offset ? offset.getValues() : new Float32Array([0]);
        var outValues = new Float32Array(xValues.length);
        for (var i = 0; i < xValues.length; i++) {
            outValues[i] = offsetValues[i % offsetValues.length] +
                (xValues[i] - meanValues[i % meanValues.length]) *
                    scaleValues[i % scaleValues.length] /
                    Math.sqrt(varianceValues[i % varianceValues.length] + varianceEpsilon);
        }
        return ndarray_1.Array2D.new(x.shape, outValues);
    };
    NDArrayMathCPU.prototype.batchNormalization3DInternal = function (x, mean, variance, varianceEpsilon, scale, offset) {
        var xValues = x.getValues();
        var meanValues = mean.getValues();
        var varianceValues = variance.getValues();
        var scaleValues = scale ? scale.getValues() : new Float32Array([1]);
        var offsetValues = offset ? offset.getValues() : new Float32Array([0]);
        var outValues = new Float32Array(xValues.length);
        for (var i = 0; i < xValues.length; i++) {
            outValues[i] = offsetValues[i % offsetValues.length] +
                (xValues[i] - meanValues[i % meanValues.length]) *
                    scaleValues[i % scaleValues.length] /
                    Math.sqrt(varianceValues[i % varianceValues.length] + varianceEpsilon);
        }
        return ndarray_1.Array3D.new(x.shape, outValues);
    };
    NDArrayMathCPU.prototype.multinomialInternal = function (probabilities, numSamples, seed) {
        var batchSize = probabilities.shape[0];
        var numEvents = probabilities.shape[1];
        var res = ndarray_1.Array2D.zeros([batchSize, numSamples], 'int32');
        var resVals = res.getValues();
        var probVals = probabilities.getValues();
        for (var b = 0; b < batchSize; ++b) {
            var offset = b * numEvents;
            var cdf = new Float32Array(numEvents - 1);
            cdf[0] = probVals[offset];
            for (var event_1 = 1; event_1 < cdf.length; ++event_1) {
                cdf[event_1] = cdf[event_1 - 1] + probVals[offset + event_1];
            }
            var random = seedrandom.alea(seed.toString());
            var outOffset = b * numSamples;
            for (var sampleId = 0; sampleId < numSamples; ++sampleId) {
                var r = random();
                resVals[outOffset + sampleId] = cdf.length;
                for (var event_2 = 0; event_2 < cdf.length; event_2++) {
                    if (r < cdf[event_2]) {
                        resVals[outOffset + sampleId] = event_2;
                        break;
                    }
                }
            }
        }
        return res;
    };
    NDArrayMathCPU.prototype.oneHotInternal = function (indices, depth, onValue, offValue) {
        var res = new Float32Array(indices.size * depth);
        res.fill(offValue);
        for (var event_3 = 0; event_3 < indices.size; ++event_3) {
            res[event_3 * depth + indices.get(event_3)] = onValue;
        }
        return ndarray_1.Array2D.new([indices.size, depth], res);
    };
    NDArrayMathCPU.prototype.broadcastedBinaryOp = function (a, b, dtype, op) {
        var newShape = broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);
        var result = ndarray_1.NDArray.zeros(newShape, dtype);
        var newValues = result.getValues();
        var aValues = a.getValues();
        var bValues = b.getValues();
        var aBroadcastDims = broadcast_util.getBroadcastDims(a.shape, newShape);
        var bBroadcastDims = broadcast_util.getBroadcastDims(b.shape, newShape);
        var _loop_1 = function (i) {
            var loc = result.indexToLoc(i);
            var aLoc = loc.slice(-a.rank);
            aBroadcastDims.forEach(function (d) { return aLoc[d] = 0; });
            var aIndex = a.locToIndex(aLoc);
            var bLoc = loc.slice(-b.rank);
            bBroadcastDims.forEach(function (d) { return bLoc[d] = 0; });
            var bIndex = b.locToIndex(bLoc);
            newValues[i] = op(aValues[aIndex], bValues[bIndex]);
        };
        for (var i = 0; i < newValues.length; ++i) {
            _loop_1(i);
        }
        return result;
    };
    return NDArrayMathCPU;
}(math_1.NDArrayMath));
exports.NDArrayMathCPU = NDArrayMathCPU;

},{"../util":88,"./axis_util":46,"./broadcast_util":47,"./concat_util":48,"./conv_util":49,"./copy2d_util":50,"./math":52,"./ndarray":55,"seedrandom":90}],54:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var util = require("../util");
var axis_util = require("./axis_util");
var math_1 = require("./math");
var ndarray = require("./ndarray");
var ndarray_1 = require("./ndarray");
var reduce_util = require("./reduce_util");
var addscaledmat_gpu_1 = require("./webgl/addscaledmat_gpu");
var argminmax_gpu_1 = require("./webgl/argminmax_gpu");
var batchnorm_gpu_1 = require("./webgl/batchnorm_gpu");
var binaryop_gpu = require("./webgl/binaryop_gpu");
var binaryop_gpu_1 = require("./webgl/binaryop_gpu");
var clip_gpu_1 = require("./webgl/clip_gpu");
var concat_gpu_1 = require("./webgl/concat_gpu");
var conv_backprop_gpu_1 = require("./webgl/conv_backprop_gpu");
var conv_gpu_1 = require("./webgl/conv_gpu");
var conv_gpu_depthwise_1 = require("./webgl/conv_gpu_depthwise");
var copy_gpu_1 = require("./webgl/copy_gpu");
var gpgpu_context_1 = require("./webgl/gpgpu_context");
var gpgpu_math = require("./webgl/gpgpu_math");
var gpgpu_util = require("./webgl/gpgpu_util");
var max_pool_backprop_gpu_1 = require("./webgl/max_pool_backprop_gpu");
var mulmat_gpu_1 = require("./webgl/mulmat_gpu");
var multinomial_gpu_1 = require("./webgl/multinomial_gpu");
var onehot_gpu_1 = require("./webgl/onehot_gpu");
var pool_gpu_1 = require("./webgl/pool_gpu");
var reduce_gpu_1 = require("./webgl/reduce_gpu");
var resize_bilinear_gpu_1 = require("./webgl/resize_bilinear_gpu");
var slice_gpu_1 = require("./webgl/slice_gpu");
var texture_manager_1 = require("./webgl/texture_manager");
var tile_gpu_1 = require("./webgl/tile_gpu");
var transpose_gpu_1 = require("./webgl/transpose_gpu");
var unary_op = require("./webgl/unaryop_gpu");
var unaryop_gpu_1 = require("./webgl/unaryop_gpu");
var webgl_util = require("./webgl/webgl_util");
var NDArrayMathGPU = (function (_super) {
    __extends(NDArrayMathGPU, _super);
    function NDArrayMathGPU(gpgpu, safeMode) {
        if (safeMode === void 0) { safeMode = false; }
        var _this = _super.call(this, safeMode) || this;
        _this.binaryCache = {};
        if (gpgpu == null) {
            var gl = gpgpu_util.createWebGLContext();
            _this.gpgpu = new gpgpu_context_1.GPGPUContext(gl);
            _this.gpgpuCreatedLocally = true;
        }
        else {
            _this.gpgpu = gpgpu;
            _this.gpgpuCreatedLocally = false;
        }
        _this.textureManager = new texture_manager_1.TextureManager(_this.gpgpu);
        ndarray.initializeGPU(_this.gpgpu, _this.textureManager);
        return _this;
    }
    NDArrayMathGPU.prototype.getGPGPUContext = function () {
        return this.gpgpu;
    };
    NDArrayMathGPU.prototype.cloneInternal = function (a) {
        var texShape = a.getTextureShapeRC();
        var source = a.as2D(texShape[0], texShape[1]);
        var output = this.makeOutputArray(texShape, a.dtype);
        this.copy2D(source, [0, 0], texShape, output, [0, 0], texShape);
        return output.reshape(a.shape);
    };
    NDArrayMathGPU.prototype.slice1DInternal = function (input, begin, size) {
        var program = new slice_gpu_1.SliceProgram([size]);
        var customSetup = program.getCustomSetupFunc([begin]);
        return this.compileAndRun(program, [input], null, customSetup);
    };
    NDArrayMathGPU.prototype.slice2DInternal = function (input, begin, size) {
        var program = new slice_gpu_1.SliceProgram(size);
        var customSetup = program.getCustomSetupFunc(begin);
        return this.compileAndRun(program, [input], null, customSetup);
    };
    NDArrayMathGPU.prototype.slice3DInternal = function (input, begin, size) {
        var program = new slice_gpu_1.SliceProgram(size);
        var customSetup = program.getCustomSetupFunc(begin);
        return this.compileAndRun(program, [input], null, customSetup);
    };
    NDArrayMathGPU.prototype.slice4DInternal = function (input, begin, size) {
        var program = new slice_gpu_1.SliceProgram(size);
        var customSetup = program.getCustomSetupFunc(begin);
        return this.compileAndRun(program, [input], null, customSetup);
    };
    NDArrayMathGPU.prototype.copy2DInternal = function (source, sourceBeginRowCol, sourceSizeRowCol, dest, destBeginRowCol, destSizeRowCol) {
        var program = new copy_gpu_1.Copy2DProgram(sourceSizeRowCol[1], destSizeRowCol[1]);
        var customSetup = program.getCustomSetupFunc(sourceBeginRowCol, destBeginRowCol, destSizeRowCol);
        this.compileAndRun(program, [source], dest, customSetup);
    };
    NDArrayMathGPU.prototype.concat1DInternal = function (a, b) {
        var program = new concat_gpu_1.ConcatProgram(a.shape, b.shape, 0);
        return this.compileAndRun(program, [a, b]);
    };
    NDArrayMathGPU.prototype.concat2DInternal = function (a, b, axis) {
        var program = new concat_gpu_1.ConcatProgram(a.shape, b.shape, axis);
        return this.compileAndRun(program, [a, b]);
    };
    NDArrayMathGPU.prototype.concat3DInternal = function (x1, x2, axis) {
        var program = new concat_gpu_1.ConcatProgram(x1.shape, x2.shape, axis);
        return this.compileAndRun(program, [x1, x2]);
    };
    NDArrayMathGPU.prototype.concat4DInternal = function (x1, x2, axis) {
        var program = new concat_gpu_1.ConcatProgram(x1.shape, x2.shape, axis);
        return this.compileAndRun(program, [x1, x2]);
    };
    NDArrayMathGPU.prototype.scaledArrayAddInternal = function (c1, a, c2, b) {
        var program = new addscaledmat_gpu_1.AddScaledMatProgram(a.shape, b.shape);
        return this.compileAndRun(program, [a, b, c1, c2]);
    };
    NDArrayMathGPU.prototype.negInternal = function (a) {
        var program = new unaryop_gpu_1.UnaryOpProgram(a.shape, unary_op.NEG);
        return this.compileAndRun(program, [a]);
    };
    NDArrayMathGPU.prototype.makeOutputArray = function (shape, dtype) {
        var textureShapeRC = webgl_util.getTextureShapeFromLogicalShape(this.gpgpu.gl, shape);
        var texture = this.textureManager.acquireTexture(textureShapeRC);
        return ndarray_1.NDArray.make(shape, { texture: texture, textureShapeRC: textureShapeRC }, dtype);
    };
    NDArrayMathGPU.prototype.compileAndRun = function (program, inputs, output, customSetup) {
        var _this = this;
        if (output == null) {
            output = this.makeOutputArray(program.outputShape, inputs[0].dtype);
        }
        var key = gpgpu_math.makeShaderKey(program, inputs, output);
        var binary = this.getAndSaveBinary(key, function () {
            return gpgpu_math.compileProgram(_this.gpgpu, program, inputs, output);
        });
        gpgpu_math.runProgram(binary, inputs, output, customSetup);
        return output;
    };
    NDArrayMathGPU.prototype.matMulInternal = function (a, b, aOrientation, bOrientation) {
        var program = new mulmat_gpu_1.MatMulProgram(a.shape, b.shape, aOrientation, bOrientation);
        return this.compileAndRun(program, [a, b]);
    };
    NDArrayMathGPU.prototype.multiplyInternal = function (a, b) {
        var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.MUL, a.shape, b.shape);
        return this.compileAndRun(program, [a, b]);
    };
    NDArrayMathGPU.prototype.batchNormalization2DInternal = function (x, mean, variance, varianceEpsilon, scale, offset) {
        var inputs = [x, mean, variance];
        var offsetShape = null;
        if (offset != null) {
            offsetShape = offset.shape;
            inputs.push(offset);
        }
        var scaleShape = null;
        if (scale != null) {
            scaleShape = scale.shape;
            inputs.push(scale);
        }
        var program = new batchnorm_gpu_1.BatchNormProgram(x.shape, mean.shape, variance.shape, offsetShape, scaleShape, varianceEpsilon);
        return this.compileAndRun(program, inputs);
    };
    NDArrayMathGPU.prototype.batchNormalization3DInternal = function (x, mean, variance, varianceEpsilon, scale, offset) {
        var inputs = [x, mean, variance];
        var offsetShape = null;
        if (offset != null) {
            offsetShape = offset.shape;
            inputs.push(offset);
        }
        var scaleShape = null;
        if (scale != null) {
            scaleShape = scale.shape;
            inputs.push(scale);
        }
        var program = new batchnorm_gpu_1.BatchNormProgram(x.shape, mean.shape, variance.shape, offsetShape, scaleShape, varianceEpsilon);
        return this.compileAndRun(program, inputs);
    };
    NDArrayMathGPU.prototype.tileInternal = function (a, reps) {
        var program = new tile_gpu_1.TileProgram(a.shape, reps);
        return this.compileAndRun(program, [a]);
    };
    NDArrayMathGPU.prototype.transposeInternal = function (a, perm) {
        var program = new transpose_gpu_1.TransposeProgram(a.shape, perm);
        return this.compileAndRun(program, [a]);
    };
    NDArrayMathGPU.prototype.reduce = function (a, reduceType, dtype) {
        var batchSize = a.shape[0];
        var inSize = a.shape[1];
        var windowSize = reduce_util.computeOptimalWindowSize(inSize);
        var reduceInfo = { windowSize: windowSize, inSize: inSize, batchSize: batchSize };
        var program = new reduce_gpu_1.ReduceProgram(reduceInfo, reduceType);
        var _a = program.outputShape, rows = _a[0], cols = _a[1];
        var output = this.makeOutputArray(program.outputShape, dtype).as2D(rows, cols);
        this.compileAndRun(program, [a], output);
        if (output.shape[1] === 1) {
            return output;
        }
        return this.reduce(output, reduceType, dtype);
    };
    NDArrayMathGPU.prototype.argReduce = function (a, reduceType, bestIndicesA) {
        if (bestIndicesA === void 0) { bestIndicesA = null; }
        var batchSize = a.shape[0];
        var inSize = a.shape[1];
        if (bestIndicesA != null) {
            batchSize = bestIndicesA.shape[0];
            inSize = bestIndicesA.shape[1];
        }
        var windowSize = reduce_util.computeOptimalWindowSize(inSize);
        var reduceInfo = { windowSize: windowSize, inSize: inSize, batchSize: batchSize };
        var program = new argminmax_gpu_1.ArgMinMaxProgram(reduceInfo, reduceType, bestIndicesA == null);
        var _a = program.outputShape, rows = _a[0], cols = _a[1];
        var output = this.makeOutputArray(program.outputShape, 'int32').as2D(rows, cols);
        var inputs = [a];
        if (bestIndicesA != null) {
            inputs.push(bestIndicesA);
        }
        this.compileAndRun(program, inputs, output);
        if (output.shape[1] === 1) {
            return output;
        }
        return this.argReduce(a, reduceType, output);
    };
    NDArrayMathGPU.prototype.sumInternal = function (a, axes) {
        axis_util.assertAxesAreInnerMostDims('sum', axes, a.rank);
        var _a = axis_util.computeOutAndReduceShapes(a.shape, axes), outShape = _a[0], reduceShape = _a[1];
        var inSize = util.sizeFromShape(reduceShape);
        var a2D = a.as2D(-1, inSize);
        var outputDType = math_1.SumTypesMap[a.dtype];
        return this.reduce(a2D, 'sum', outputDType).reshape(outShape);
    };
    NDArrayMathGPU.prototype.argMinInternal = function (a, axes) {
        axis_util.assertAxesAreInnerMostDims('argMin', axes, a.rank);
        var _a = axis_util.computeOutAndReduceShapes(a.shape, axes), outShape = _a[0], reduceShape = _a[1];
        var inSize = util.sizeFromShape(reduceShape);
        var a2D = a.as2D(-1, inSize);
        return this.argReduce(a2D, 'min').reshape(outShape);
    };
    NDArrayMathGPU.prototype.argMaxInternal = function (a, axes) {
        axis_util.assertAxesAreInnerMostDims('argMax', axes, a.rank);
        var _a = axis_util.computeOutAndReduceShapes(a.shape, axes), outShape = _a[0], reduceShape = _a[1];
        var inSize = util.sizeFromShape(reduceShape);
        var a2D = a.as2D(-1, inSize);
        return this.argReduce(a2D, 'max').reshape(outShape);
    };
    NDArrayMathGPU.prototype.equalInternal = function (x, y) {
        var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.EQUAL, x.shape, y.shape);
        var output = this.makeOutputArray(program.outputShape, 'bool');
        return this.compileAndRun(program, [x, y], output);
    };
    NDArrayMathGPU.prototype.topKInternal = function (ndarray, k) {
        throw new Error('topK GPU not yet implemented!');
    };
    NDArrayMathGPU.prototype.minInternal = function (a, axes) {
        axis_util.assertAxesAreInnerMostDims('min', axes, a.rank);
        var _a = axis_util.computeOutAndReduceShapes(a.shape, axes), outShape = _a[0], reduceShape = _a[1];
        var inSize = util.sizeFromShape(reduceShape);
        var a2D = a.as2D(-1, inSize);
        return this.reduce(a2D, 'min', a2D.dtype).reshape(outShape);
    };
    NDArrayMathGPU.prototype.maxInternal = function (a, axes) {
        axis_util.assertAxesAreInnerMostDims('max', axes, a.rank);
        var _a = axis_util.computeOutAndReduceShapes(a.shape, axes), outShape = _a[0], reduceShape = _a[1];
        var inSize = util.sizeFromShape(reduceShape);
        var a2D = a.as2D(-1, inSize);
        return this.reduce(a2D, 'max', a2D.dtype).reshape(outShape);
    };
    NDArrayMathGPU.prototype.divideInternal = function (a, b) {
        var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.DIV, a.shape, b.shape);
        var output = this.makeOutputArray(program.outputShape, 'float32');
        return this.compileAndRun(program, [a, b], output);
    };
    NDArrayMathGPU.prototype.addInternal = function (a, b) {
        var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.ADD, a.shape, b.shape);
        return this.compileAndRun(program, [a, b]);
    };
    NDArrayMathGPU.prototype.subtractInternal = function (a, b) {
        var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.SUB, a.shape, b.shape);
        return this.compileAndRun(program, [a, b]);
    };
    NDArrayMathGPU.prototype.ceilInternal = function (a) {
        var program = new unaryop_gpu_1.UnaryOpProgram(a.shape, unary_op.CEIL);
        return this.compileAndRun(program, [a]);
    };
    NDArrayMathGPU.prototype.floorInternal = function (a) {
        var program = new unaryop_gpu_1.UnaryOpProgram(a.shape, unary_op.FLOOR);
        return this.compileAndRun(program, [a]);
    };
    NDArrayMathGPU.prototype.expInternal = function (a) {
        var program = new unaryop_gpu_1.UnaryOpProgram(a.shape, unary_op.EXP);
        return this.compileAndRun(program, [a]);
    };
    NDArrayMathGPU.prototype.logInternal = function (a) {
        var program = new unaryop_gpu_1.UnaryOpProgram(a.shape, unary_op.LOG);
        return this.compileAndRun(program, [a]);
    };
    NDArrayMathGPU.prototype.sqrtInternal = function (a) {
        var program = new unaryop_gpu_1.UnaryOpProgram(a.shape, unary_op.SQRT);
        return this.compileAndRun(program, [a]);
    };
    NDArrayMathGPU.prototype.squareInternal = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.SQUARE);
        return this.compileAndRun(program, [x]);
    };
    NDArrayMathGPU.prototype.reluInternal = function (a) {
        var program = new unaryop_gpu_1.UnaryOpProgram(a.shape, unary_op.RELU);
        return this.compileAndRun(program, [a]);
    };
    NDArrayMathGPU.prototype.eluInternal = function (a) {
        var program = new unaryop_gpu_1.UnaryOpProgram(a.shape, unary_op.ELU);
        return this.compileAndRun(program, [a]);
    };
    NDArrayMathGPU.prototype.leakyReluInternal = function (a, alpha) {
        var program = new unaryop_gpu_1.UnaryOpProgram(a.shape, unary_op.LEAKY_RELU(alpha));
        return this.compileAndRun(program, [a]);
    };
    NDArrayMathGPU.prototype.clipInternal = function (a, min, max) {
        var program = new clip_gpu_1.ClipProgram(a.shape, min, max);
        return this.compileAndRun(program, [a]);
    };
    NDArrayMathGPU.prototype.absInternal = function (a) {
        var program = new unaryop_gpu_1.UnaryOpProgram(a.shape, unary_op.ABS);
        return this.compileAndRun(program, [a]);
    };
    NDArrayMathGPU.prototype.sigmoidInternal = function (a) {
        var program = new unaryop_gpu_1.UnaryOpProgram(a.shape, unary_op.SIGMOID);
        return this.compileAndRun(program, [a]);
    };
    NDArrayMathGPU.prototype.sinInternal = function (a) {
        var program = new unaryop_gpu_1.UnaryOpProgram(a.shape, unary_op.SIN);
        return this.compileAndRun(program, [a]);
    };
    NDArrayMathGPU.prototype.cosInternal = function (a) {
        var program = new unaryop_gpu_1.UnaryOpProgram(a.shape, unary_op.COS);
        return this.compileAndRun(program, [a]);
    };
    NDArrayMathGPU.prototype.tanInternal = function (a) {
        var program = new unaryop_gpu_1.UnaryOpProgram(a.shape, unary_op.TAN);
        return this.compileAndRun(program, [a]);
    };
    NDArrayMathGPU.prototype.asinInternal = function (a) {
        var program = new unaryop_gpu_1.UnaryOpProgram(a.shape, unary_op.ASIN);
        return this.compileAndRun(program, [a]);
    };
    NDArrayMathGPU.prototype.acosInternal = function (a) {
        var program = new unaryop_gpu_1.UnaryOpProgram(a.shape, unary_op.ACOS);
        return this.compileAndRun(program, [a]);
    };
    NDArrayMathGPU.prototype.atanInternal = function (a) {
        var program = new unaryop_gpu_1.UnaryOpProgram(a.shape, unary_op.ATAN);
        return this.compileAndRun(program, [a]);
    };
    NDArrayMathGPU.prototype.sinhInternal = function (a) {
        var program = new unaryop_gpu_1.UnaryOpProgram(a.shape, unary_op.SINH);
        return this.compileAndRun(program, [a]);
    };
    NDArrayMathGPU.prototype.coshInternal = function (a) {
        var program = new unaryop_gpu_1.UnaryOpProgram(a.shape, unary_op.COSH);
        return this.compileAndRun(program, [a]);
    };
    NDArrayMathGPU.prototype.tanhInternal = function (a) {
        var program = new unaryop_gpu_1.UnaryOpProgram(a.shape, unary_op.TANH);
        return this.compileAndRun(program, [a]);
    };
    NDArrayMathGPU.prototype.stepInternal = function (a, alpha) {
        var program = new unaryop_gpu_1.UnaryOpProgram(a.shape, unary_op.STEP(alpha));
        return this.compileAndRun(program, [a]);
    };
    NDArrayMathGPU.prototype.conv2dInternal = function (x, filter, bias, convInfo) {
        var program = new conv_gpu_1.Conv2DProgram(convInfo, bias != null);
        var inputs = bias != null ? [x, filter, bias] : [x, filter];
        return this.compileAndRun(program, inputs);
    };
    NDArrayMathGPU.prototype.conv2dDerInputInternal = function (dy, filter, convInfo) {
        var program = new conv_backprop_gpu_1.Conv2DDerInputProgram(convInfo);
        return this.compileAndRun(program, [dy, filter]);
    };
    NDArrayMathGPU.prototype.conv2dDerFilterInternal = function (x, dY, convInfo) {
        var program = new conv_backprop_gpu_1.Conv2DDerWeightsProgram(convInfo);
        return this.compileAndRun(program, [x, dY]);
    };
    NDArrayMathGPU.prototype.conv2dDerBiasInternal = function (dY) {
        var program = new conv_backprop_gpu_1.Conv2DDerBiasProgram(dY.shape);
        return this.compileAndRun(program, [dY]);
    };
    NDArrayMathGPU.prototype.depthwiseConv2DInternal = function (input, filter, convInfo) {
        var program = new conv_gpu_depthwise_1.DepthwiseConv2DProgram(convInfo);
        return this.compileAndRun(program, [input, filter]);
    };
    NDArrayMathGPU.prototype.maxPoolInternal = function (x, convInfo) {
        var program = new pool_gpu_1.Pool2DProgram(convInfo, 'max', false);
        return this.compileAndRun(program, [x]);
    };
    NDArrayMathGPU.prototype.minPoolInternal = function (x, convInfo) {
        var program = new pool_gpu_1.Pool2DProgram(convInfo, 'min', false);
        return this.compileAndRun(program, [x]);
    };
    NDArrayMathGPU.prototype.avgPoolInternal = function (x, convInfo) {
        var program = new pool_gpu_1.Pool2DProgram(convInfo, 'avg', false);
        return this.compileAndRun(program, [x]);
    };
    NDArrayMathGPU.prototype.maxPoolBackpropInternal = function (dy, x, convInfo) {
        var getPositions = true;
        var maxPoolPositionsProgram = new pool_gpu_1.Pool2DProgram(convInfo, 'max', getPositions);
        var maxPoolPositions = this.compileAndRun(maxPoolPositionsProgram, [x]);
        var maxPoolBackPropProgram = new max_pool_backprop_gpu_1.MaxPool2DBackpropProgram(convInfo);
        var result = this.compileAndRun(maxPoolBackPropProgram, [dy, maxPoolPositions]);
        maxPoolPositions.dispose();
        return result;
    };
    NDArrayMathGPU.prototype.resizeBilinear3DInternal = function (x, newShape2D, alignCorners) {
        var program = new resize_bilinear_gpu_1.ResizeBilinear3DProgram(x.shape, newShape2D, alignCorners);
        return this.compileAndRun(program, [x]);
    };
    NDArrayMathGPU.prototype.multinomialInternal = function (probs, numSamples, seed) {
        var batchSize = probs.shape[0];
        var numOutcomes = probs.shape[1];
        var program = new multinomial_gpu_1.MultinomialProgram(batchSize, numOutcomes, numSamples);
        var output = this.makeOutputArray(program.outputShape, 'int32');
        var customSetup = program.getCustomSetupFunc(seed);
        return this.compileAndRun(program, [probs], output, customSetup);
    };
    NDArrayMathGPU.prototype.oneHotInternal = function (indices, depth, onValue, offValue) {
        var program = new onehot_gpu_1.OneHotProgram(indices.size, depth, onValue, offValue);
        return this.compileAndRun(program, [indices]);
    };
    NDArrayMathGPU.prototype.getAndSaveBinary = function (key, getBinary) {
        if (!(key in this.binaryCache)) {
            this.binaryCache[key] = getBinary();
        }
        return this.binaryCache[key];
    };
    NDArrayMathGPU.prototype.getTextureManager = function () {
        return this.textureManager;
    };
    NDArrayMathGPU.prototype.dispose = function () {
        for (var key in this.binaryCache) {
            this.gpgpu.deleteProgram(this.binaryCache[key].webGLProgram);
        }
        this.textureManager.dispose();
        if (this.gpgpuCreatedLocally) {
            this.gpgpu.dispose();
        }
    };
    return NDArrayMathGPU;
}(math_1.NDArrayMath));
exports.NDArrayMathGPU = NDArrayMathGPU;

},{"../util":88,"./axis_util":46,"./math":52,"./ndarray":55,"./reduce_util":56,"./webgl/addscaledmat_gpu":58,"./webgl/argminmax_gpu":59,"./webgl/batchnorm_gpu":60,"./webgl/binaryop_gpu":61,"./webgl/clip_gpu":62,"./webgl/concat_gpu":63,"./webgl/conv_backprop_gpu":64,"./webgl/conv_gpu":65,"./webgl/conv_gpu_depthwise":66,"./webgl/copy_gpu":67,"./webgl/gpgpu_context":68,"./webgl/gpgpu_math":69,"./webgl/gpgpu_util":70,"./webgl/max_pool_backprop_gpu":71,"./webgl/mulmat_gpu":72,"./webgl/multinomial_gpu":73,"./webgl/onehot_gpu":74,"./webgl/pool_gpu":75,"./webgl/reduce_gpu":76,"./webgl/resize_bilinear_gpu":78,"./webgl/slice_gpu":80,"./webgl/texture_manager":82,"./webgl/tile_gpu":83,"./webgl/transpose_gpu":84,"./webgl/unaryop_gpu":85,"./webgl/webgl_util":86}],55:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var environment_1 = require("../environment");
var util = require("../util");
var tex_util_1 = require("./webgl/tex_util");
var webgl_util = require("./webgl/webgl_util");
exports.GPGPU = null;
exports.TEXTURE_MANAGER = null;
var DType;
(function (DType) {
    DType["float32"] = "float32";
    DType["int32"] = "int32";
    DType["bool"] = "bool";
})(DType = exports.DType || (exports.DType = {}));
function initializeGPU(gpgpu, textureManager) {
    exports.GPGPU = gpgpu;
    exports.TEXTURE_MANAGER = textureManager;
}
exports.initializeGPU = initializeGPU;
function throwIfGPUNotInitialized() {
    if (exports.GPGPU == null || exports.TEXTURE_MANAGER == null) {
        throw new Error('GPU not intialized.');
    }
}
var NDArray = (function () {
    function NDArray(shape, data, dtype) {
        util.assert(data.values != null || data.texture != null, 'Either `values` or `texture` must be defined');
        util.assert(data.texture == null || (data.textureShapeRC != null), '`textureShape` must be defined when `texture` is defined');
        this.size = util.sizeFromShape(shape);
        if (data.values != null) {
            util.assert(this.size === data.values.length, "Constructing ndarray of shape (" + this.size + ") should match the " +
                ("length of values (" + data.values.length + ")"));
        }
        this.shape = shape;
        if (data.textureType == null) {
            data.textureType = tex_util_1.TextureType.DEFAULT;
        }
        this.ndarrayData = data;
        this.dtype = dtype || 'float32';
        var dim = this.shape.length;
        if (dim < 2) {
            this.strides = [];
        }
        else {
            this.strides = new Array(dim - 1);
            this.strides[dim - 2] = this.shape[dim - 1];
            for (var i = dim - 3; i >= 0; --i) {
                this.strides[i] = this.strides[i + 1] * this.shape[i + 1];
            }
        }
    }
    NDArray.zeros = function (shape, dtype) {
        var values = makeZerosTypedArray(util.sizeFromShape(shape), dtype);
        return NDArray.make(shape, { values: values }, dtype);
    };
    NDArray.zerosLike = function (another) {
        return NDArray.zeros(another.shape, another.dtype);
    };
    NDArray.like = function (another) {
        var newValues = copyTypedArray(another.getValues(), another.dtype);
        return NDArray.make(another.shape, { values: newValues }, another.dtype);
    };
    NDArray.make = function (shape, data, dtype) {
        if (data.isDisposed) {
            throw new Error("Cannot make new NDArray from disposed NDArrayData.");
        }
        switch (shape.length) {
            case 0:
                return new Scalar(data, dtype);
            case 1:
                return new Array1D(data, dtype);
            case 2:
                return new Array2D(shape, data, dtype);
            case 3:
                return new Array3D(shape, data, dtype);
            case 4:
                return new Array4D(shape, data, dtype);
            default:
                return new NDArray(shape, data, dtype);
        }
    };
    NDArray.fromPixels = function (pixels, numChannels) {
        if (numChannels === void 0) { numChannels = 3; }
        if (numChannels > 4) {
            throw new Error('Cannot construct NDArray with more than 4 channels from pixels.');
        }
        var shape = [pixels.height, pixels.width, numChannels];
        var textureShapeRC = [shape[0], shape[1]];
        var texture = exports.TEXTURE_MANAGER.acquireTexture(textureShapeRC);
        var textureType = tex_util_1.TextureType.RGBA_COLOR;
        exports.GPGPU.uploadPixelDataToTexture(texture, pixels);
        return Array3D.make(shape, { texture: texture, textureShapeRC: textureShapeRC, textureType: textureType });
    };
    NDArray.prototype.reshape = function (newShape) {
        this.throwIfDisposed();
        newShape = util.inferFromImplicitShape(newShape, this.size);
        if (util.arraysEqual(this.shape, newShape)) {
            return this;
        }
        util.assert(this.size === util.sizeFromShape(newShape), 'new shape and old shape must have the same number of elements.');
        return NDArray.make(newShape, this.ndarrayData, this.dtype);
    };
    NDArray.prototype.flatten = function () {
        if (this instanceof Array1D) {
            return this;
        }
        return this.as1D();
    };
    NDArray.prototype.asScalar = function () {
        util.assert(this.size === 1, 'The array must have only 1 element.');
        return this.reshape([]);
    };
    NDArray.prototype.as1D = function () {
        return this.reshape([this.size]);
    };
    NDArray.prototype.as2D = function (rows, columns) {
        return this.reshape([rows, columns]);
    };
    NDArray.prototype.as3D = function (rows, columns, depth) {
        return this.reshape([rows, columns, depth]);
    };
    NDArray.prototype.as4D = function (rows, columns, depth, depth2) {
        return this.reshape([rows, columns, depth, depth2]);
    };
    NDArray.prototype.asType = function (dtype) {
        this.throwIfDisposed();
        var newData = this.getData();
        if (newData.values != null) {
            newData = { values: toTypedArray(newData.values, dtype) };
        }
        return NDArray.make(this.shape, newData, dtype);
    };
    Object.defineProperty(NDArray.prototype, "rank", {
        get: function () {
            this.throwIfDisposed();
            return this.shape.length;
        },
        enumerable: true,
        configurable: true
    });
    NDArray.prototype.get = function () {
        var locs = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            locs[_i] = arguments[_i];
        }
        this.throwIfDisposed();
        var index = locs[locs.length - 1];
        for (var i = 0; i < locs.length - 1; ++i) {
            index += this.strides[i] * locs[i];
        }
        return this.getValues()[index];
    };
    NDArray.prototype.add = function (value) {
        var locs = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            locs[_i - 1] = arguments[_i];
        }
        this.throwIfDisposed();
        this.set.apply(this, [this.get.apply(this, locs) + value].concat(locs));
    };
    NDArray.prototype.set = function (value) {
        var locs = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            locs[_i - 1] = arguments[_i];
        }
        this.throwIfDisposed();
        var index = locs[locs.length - 1];
        for (var i = 0; i < locs.length - 1; ++i) {
            index += this.strides[i] * locs[i];
        }
        this.getValues()[index] = value;
    };
    NDArray.prototype.val = function () {
        var locs = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            locs[_i] = arguments[_i];
        }
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this.throwIfDisposed();
                        return [4, this.data()];
                    case 1:
                        _a.sent();
                        return [2, this.get.apply(this, locs)];
                }
            });
        });
    };
    NDArray.prototype.locToIndex = function (locs) {
        var index = locs[locs.length - 1];
        for (var i = 0; i < locs.length - 1; ++i) {
            index += this.strides[i] * locs[i];
        }
        return index;
    };
    NDArray.prototype.indexToLoc = function (index) {
        var locs = new Array(this.shape.length);
        for (var i = 0; i < locs.length - 1; ++i) {
            locs[i] = Math.floor(index / this.strides[i]);
            index -= locs[i] * this.strides[i];
        }
        locs[locs.length - 1] = index;
        return locs;
    };
    NDArray.prototype.fill = function (value) {
        this.throwIfDisposed();
        this.getValues().fill(value);
    };
    NDArray.prototype.getData = function () {
        return this.ndarrayData;
    };
    NDArray.prototype.getValues = function () {
        return this.dataSync();
    };
    NDArray.prototype.getValuesAsync = function () {
        return this.data();
    };
    NDArray.prototype.data = function () {
        return __awaiter(this, void 0, void 0, function () {
            var _a, queryFn;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        this.throwIfDisposed();
                        if (this.ndarrayData.values != null) {
                            return [2, this.ndarrayData.values];
                        }
                        if (!(environment_1.ENV.get('WEBGL_GET_BUFFER_SUB_DATA_ASYNC_EXTENSION_ENABLED') &&
                            this.ndarrayData.textureType === tex_util_1.TextureType.DEFAULT)) return [3, 2];
                        _a = this.ndarrayData;
                        return [4, exports.GPGPU.downloadMatrixFromTextureAsync(this.ndarrayData.texture, this.ndarrayData.textureShapeRC[0], this.ndarrayData.textureShapeRC[1])];
                    case 1:
                        _a.values = _b.sent();
                        return [2, this.ndarrayData.values];
                    case 2:
                        if (!!environment_1.ENV.get('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_ENABLED')) return [3, 4];
                        return [4, this.dataSync()];
                    case 3: return [2, _b.sent()];
                    case 4:
                        queryFn = function () { };
                        return [4, exports.GPGPU.runQuery(queryFn)];
                    case 5:
                        _b.sent();
                        return [2, this.dataSync()];
                }
            });
        });
    };
    NDArray.prototype.dataSync = function () {
        this.throwIfDisposed();
        if (this.ndarrayData.values == null) {
            throwIfGPUNotInitialized();
            var values = void 0;
            if (this.ndarrayData.textureType === tex_util_1.TextureType.DEFAULT) {
                values = exports.GPGPU.downloadMatrixFromTexture(this.ndarrayData.texture, this.ndarrayData.textureShapeRC[0], this.ndarrayData.textureShapeRC[1]);
            }
            else {
                values = exports.GPGPU.downloadMatrixFromRGBAColorTexture(this.ndarrayData.texture, this.ndarrayData.textureShapeRC[0], this.ndarrayData.textureShapeRC[1], this.shape[2]);
            }
            this.ndarrayData.values = float32ToTypedArray(values, this.dtype);
            this.disposeTexture();
        }
        return this.ndarrayData.values;
    };
    NDArray.prototype.uploadToGPU = function () {
        throwIfGPUNotInitialized();
        this.throwIfDisposed();
        this.ndarrayData.textureShapeRC =
            webgl_util.getTextureShapeFromLogicalShape(exports.GPGPU.gl, this.shape);
        this.ndarrayData.texture =
            exports.TEXTURE_MANAGER.acquireTexture(this.ndarrayData.textureShapeRC);
        this.ndarrayData.textureType = tex_util_1.TextureType.DEFAULT;
        exports.GPGPU.uploadMatrixToTexture(this.ndarrayData.texture, this.ndarrayData.textureShapeRC[0], this.ndarrayData.textureShapeRC[1], typedArrayToFloat32(this.ndarrayData.values, this.dtype));
        this.ndarrayData.values = null;
    };
    NDArray.prototype.getTexture = function () {
        this.throwIfDisposed();
        if (this.ndarrayData.texture == null) {
            this.uploadToGPU();
        }
        return this.ndarrayData.texture;
    };
    NDArray.prototype.getTextureShapeRC = function () {
        this.throwIfDisposed();
        if (this.ndarrayData.textureShapeRC == null) {
            this.uploadToGPU();
        }
        return this.ndarrayData.textureShapeRC;
    };
    NDArray.prototype.throwIfDisposed = function () {
        if (this.ndarrayData.isDisposed) {
            throw new Error("NDArray is disposed.");
        }
    };
    NDArray.prototype.dispose = function () {
        this.ndarrayData.values = null;
        this.shape = null;
        this.ndarrayData.isDisposed = true;
        if (this.ndarrayData.texture != null) {
            this.disposeTexture();
        }
    };
    NDArray.prototype.disposeTexture = function () {
        throwIfGPUNotInitialized();
        exports.TEXTURE_MANAGER.releaseTexture(this.ndarrayData.texture, this.ndarrayData.textureShapeRC);
        this.ndarrayData.texture = null;
        this.ndarrayData.textureShapeRC = null;
        this.ndarrayData.textureType = null;
    };
    NDArray.prototype.inGPU = function () {
        this.throwIfDisposed();
        return this.ndarrayData.texture != null;
    };
    NDArray.prototype.equals = function (t) {
        this.throwIfDisposed();
        return this.dtype === t.dtype && util.arraysEqual(this.shape, t.shape) &&
            util.arraysEqual(this.getValues(), t.getValues());
    };
    NDArray.rand = function (shape, randFunction) {
        var size = util.sizeFromShape(shape);
        var values = new Float32Array(size);
        for (var i = 0; i < size; i++) {
            values[i] = randFunction();
        }
        return NDArray.make(shape, { values: values });
    };
    NDArray.randNormal = function (shape, mean, stdDev) {
        if (mean === void 0) { mean = 0; }
        if (stdDev === void 0) { stdDev = 1; }
        return NDArray.rand(shape, function () { return util.randGauss(mean, stdDev); });
    };
    NDArray.randTruncatedNormal = function (shape, mean, stdDev) {
        if (mean === void 0) { mean = 0; }
        if (stdDev === void 0) { stdDev = 1; }
        return NDArray.rand(shape, function () { return util.randGauss(mean, stdDev, true); });
    };
    NDArray.randUniform = function (shape, a, b) {
        return NDArray.rand(shape, function () { return util.randUniform(a, b); });
    };
    return NDArray;
}());
exports.NDArray = NDArray;
var Scalar = (function (_super) {
    __extends(Scalar, _super);
    function Scalar(data, dtype) {
        var _this = this;
        if (data.texture != null) {
            data.textureShapeRC = [1, 1];
        }
        _this = _super.call(this, [], data, dtype) || this;
        return _this;
    }
    Scalar.new = function (value, dtype) {
        var values = [value];
        return new Scalar({ values: toTypedArray(values, dtype) }, dtype);
    };
    Scalar.prototype.get = function () {
        return this.getValues()[0];
    };
    Scalar.prototype.val = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4, this.data()];
                    case 1:
                        _a.sent();
                        return [2, this.get()];
                }
            });
        });
    };
    Scalar.prototype.set = function (value) {
        this.getValues()[0] = value;
    };
    Scalar.prototype.add = function (value) {
        this.getValues()[0] += value;
    };
    Scalar.prototype.asType = function (dtype) {
        return _super.prototype.asType.call(this, dtype);
    };
    Scalar.prototype.locToIndex = function (loc) {
        return 0;
    };
    Scalar.prototype.indexToLoc = function (index) {
        return [];
    };
    Scalar.ZERO = Scalar.new(0);
    Scalar.ONE = Scalar.new(1);
    Scalar.TWO = Scalar.new(2);
    Scalar.NEG_ONE = Scalar.new(-1);
    return Scalar;
}(NDArray));
exports.Scalar = Scalar;
var Array1D = (function (_super) {
    __extends(Array1D, _super);
    function Array1D(data, dtype) {
        var _this = this;
        var shape = (data.values != null) ?
            [data.values.length] :
            [util.sizeFromShape(data.textureShapeRC)];
        _this = _super.call(this, shape, data, dtype) || this;
        return _this;
    }
    Array1D.new = function (values, dtype) {
        if (!instanceofTypedArray(values)) {
            var inferredShape = util.inferShape(values);
            util.assert(inferredShape.length === 1, "Error constructing Array1D. Shape of values " + inferredShape + " is " +
                "not 1 dimensional.");
        }
        return new Array1D({ values: toTypedArray(values, dtype) }, dtype);
    };
    Array1D.prototype.get = function (i) {
        return this.getValues()[i];
    };
    Array1D.prototype.set = function (value, i) {
        this.getValues()[i] = value;
    };
    Array1D.prototype.val = function (i) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4, this.data()];
                    case 1:
                        _a.sent();
                        return [2, this.get(i)];
                }
            });
        });
    };
    Array1D.prototype.add = function (value, i) {
        this.getValues()[i] += value;
    };
    Array1D.prototype.locToIndex = function (loc) {
        return loc[0];
    };
    Array1D.prototype.indexToLoc = function (index) {
        return [index];
    };
    Array1D.prototype.asType = function (dtype) {
        return _super.prototype.asType.call(this, dtype);
    };
    Array1D.zeros = function (shape, dtype) {
        return NDArray.zeros(shape, dtype);
    };
    Array1D.randNormal = function (shape, mean, stdDev) {
        if (mean === void 0) { mean = 0; }
        if (stdDev === void 0) { stdDev = 1; }
        return NDArray.rand(shape, function () { return util.randGauss(mean, stdDev); });
    };
    Array1D.randTruncatedNormal = function (shape, mean, stdDev) {
        if (mean === void 0) { mean = 0; }
        if (stdDev === void 0) { stdDev = 1; }
        return NDArray.rand(shape, function () { return util.randGauss(mean, stdDev, true); });
    };
    Array1D.randUniform = function (shape, a, b) {
        return NDArray.rand(shape, function () { return util.randUniform(a, b); });
    };
    return Array1D;
}(NDArray));
exports.Array1D = Array1D;
var Array2D = (function (_super) {
    __extends(Array2D, _super);
    function Array2D(shape, data, dtype) {
        var _this = this;
        util.assert(shape.length === 2, 'Shape should be of length 2');
        _this = _super.call(this, shape, data, dtype) || this;
        _this.stride0 = _this.strides[0];
        return _this;
    }
    Array2D.new = function (shape, values, dtype) {
        if (!instanceofTypedArray(values)) {
            var inferredShape = util.inferShape(values);
            if (inferredShape.length > 1) {
                util.assertShapesMatch(shape, inferredShape, "Error when constructing Array2D. Shape of values " +
                    (inferredShape + " does not match the provided shape ") +
                    (shape + ". "));
            }
        }
        return new Array2D(shape, { values: toTypedArray(values, dtype) }, dtype);
    };
    Array2D.prototype.get = function (i, j) {
        return this.getValues()[this.stride0 * i + j];
    };
    Array2D.prototype.set = function (value, i, j) {
        this.getValues()[this.stride0 * i + j] = value;
    };
    Array2D.prototype.add = function (value, i, j) {
        this.getValues()[this.stride0 * i + j] += value;
    };
    Array2D.prototype.val = function (i, j) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4, this.data()];
                    case 1:
                        _a.sent();
                        return [2, this.get(i, j)];
                }
            });
        });
    };
    Array2D.prototype.locToIndex = function (locs) {
        return this.stride0 * locs[0] + locs[1];
    };
    Array2D.prototype.indexToLoc = function (index) {
        return [Math.floor(index / this.stride0), index % this.stride0];
    };
    Array2D.prototype.asType = function (dtype) {
        return _super.prototype.asType.call(this, dtype);
    };
    Array2D.zeros = function (shape, dtype) {
        return NDArray.zeros(shape, dtype);
    };
    Array2D.randNormal = function (shape, mean, stdDev) {
        if (mean === void 0) { mean = 0; }
        if (stdDev === void 0) { stdDev = 1; }
        return NDArray.rand(shape, function () { return util.randGauss(mean, stdDev); });
    };
    Array2D.randTruncatedNormal = function (shape, mean, stdDev) {
        if (mean === void 0) { mean = 0; }
        if (stdDev === void 0) { stdDev = 1; }
        return NDArray.rand(shape, function () { return util.randGauss(mean, stdDev, true); });
    };
    Array2D.randUniform = function (shape, a, b) {
        return NDArray.rand(shape, function () { return util.randUniform(a, b); });
    };
    return Array2D;
}(NDArray));
exports.Array2D = Array2D;
var Array3D = (function (_super) {
    __extends(Array3D, _super);
    function Array3D(shape, data, dtype) {
        var _this = this;
        util.assert(shape.length === 3, 'Shape should be of length 3');
        _this = _super.call(this, shape, data, dtype) || this;
        _this.stride0 = _this.strides[0];
        _this.stride1 = _this.strides[1];
        return _this;
    }
    Array3D.new = function (shape, values, dtype) {
        if (!instanceofTypedArray(values)) {
            var inferredShape = util.inferShape(values);
            if (inferredShape.length > 1) {
                util.assertShapesMatch(shape, inferredShape, "Error when constructing Array3D. Shape of values " +
                    (inferredShape + " does not match the provided shape ") +
                    (shape + ". "));
            }
        }
        return new Array3D(shape, { values: toTypedArray(values, dtype) }, dtype);
    };
    Array3D.prototype.get = function (i, j, k) {
        return this.getValues()[this.stride0 * i + this.stride1 * j + k];
    };
    Array3D.prototype.set = function (value, i, j, k) {
        this.getValues()[this.stride0 * i + this.stride1 * j + k] = value;
    };
    Array3D.prototype.val = function (i, j, k) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4, this.data()];
                    case 1:
                        _a.sent();
                        return [2, this.get(i, j, k)];
                }
            });
        });
    };
    Array3D.prototype.add = function (value, i, j, k) {
        this.getValues()[this.stride0 * i + this.stride1 * j + k] += value;
    };
    Array3D.prototype.locToIndex = function (locs) {
        return this.stride0 * locs[0] + this.stride1 * locs[1] + locs[2];
    };
    Array3D.prototype.indexToLoc = function (index) {
        var i = Math.floor(index / this.stride0);
        index -= i * this.stride0;
        return [i, Math.floor(index / this.stride1), index % this.stride1];
    };
    Array3D.prototype.asType = function (dtype) {
        return _super.prototype.asType.call(this, dtype);
    };
    Array3D.zeros = function (shape, dtype) {
        return NDArray.zeros(shape, dtype);
    };
    Array3D.randNormal = function (shape, mean, stdDev) {
        if (mean === void 0) { mean = 0; }
        if (stdDev === void 0) { stdDev = 1; }
        return NDArray.rand(shape, function () { return util.randGauss(mean, stdDev); });
    };
    Array3D.randTruncatedNormal = function (shape, mean, stdDev) {
        if (mean === void 0) { mean = 0; }
        if (stdDev === void 0) { stdDev = 1; }
        return NDArray.rand(shape, function () { return util.randGauss(mean, stdDev, true); });
    };
    Array3D.randUniform = function (shape, a, b) {
        return NDArray.rand(shape, function () { return util.randUniform(a, b); });
    };
    return Array3D;
}(NDArray));
exports.Array3D = Array3D;
var Array4D = (function (_super) {
    __extends(Array4D, _super);
    function Array4D(shape, data, dtype) {
        var _this = this;
        util.assert(shape.length === 4, 'Shape should be of length 4');
        _this = _super.call(this, shape, data, dtype) || this;
        _this.stride0 = _this.strides[0];
        _this.stride1 = _this.strides[1];
        _this.stride2 = _this.strides[2];
        return _this;
    }
    Array4D.new = function (shape, values, dtype) {
        if (!instanceofTypedArray(values)) {
            var inferredShape = util.inferShape(values);
            if (inferredShape.length > 1) {
                util.assertShapesMatch(shape, inferredShape, "Error when constructing Array4D. Shape of values " +
                    (inferredShape + " does not match the provided shape ") +
                    (shape + ". "));
            }
        }
        return new Array4D(shape, { values: toTypedArray(values, dtype) }, dtype);
    };
    Array4D.prototype.get = function (i, j, k, l) {
        return this.getValues()[this.stride0 * i + this.stride1 * j + this.stride2 * k + l];
    };
    Array4D.prototype.set = function (value, i, j, k, l) {
        this.getValues()[this.stride0 * i + this.stride1 * j + this.stride2 * k + l] = value;
    };
    Array4D.prototype.val = function (i, j, k, l) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4, this.data()];
                    case 1:
                        _a.sent();
                        return [2, this.get(i, j, k, l)];
                }
            });
        });
    };
    Array4D.prototype.add = function (value, i, j, k, l) {
        this.getValues()[this.stride0 * i + this.stride1 * j + this.stride2 * k + l] += value;
    };
    Array4D.prototype.locToIndex = function (locs) {
        return this.stride0 * locs[0] + this.stride1 * locs[1] +
            this.stride2 * locs[2] + locs[3];
    };
    Array4D.prototype.indexToLoc = function (index) {
        var i = Math.floor(index / this.stride0);
        index -= i * this.stride0;
        var j = Math.floor(index / this.stride1);
        index -= j * this.stride1;
        return [i, j, Math.floor(index / this.stride2), index % this.stride2];
    };
    Array4D.prototype.asType = function (dtype) {
        return _super.prototype.asType.call(this, dtype);
    };
    Array4D.zeros = function (shape, dtype) {
        return NDArray.zeros(shape, dtype);
    };
    Array4D.randNormal = function (shape, mean, stdDev) {
        if (mean === void 0) { mean = 0; }
        if (stdDev === void 0) { stdDev = 1; }
        return NDArray.rand(shape, function () { return util.randGauss(mean, stdDev); });
    };
    Array4D.randTruncatedNormal = function (shape, mean, stdDev) {
        if (mean === void 0) { mean = 0; }
        if (stdDev === void 0) { stdDev = 1; }
        return NDArray.rand(shape, function () { return util.randGauss(mean, stdDev, true); });
    };
    Array4D.randUniform = function (shape, a, b) {
        return NDArray.rand(shape, function () { return util.randUniform(a, b); });
    };
    return Array4D;
}(NDArray));
exports.Array4D = Array4D;
function copyTypedArray(array, dtype) {
    if (dtype == null || dtype === 'float32') {
        return new Float32Array(array);
    }
    else if (dtype === 'int32') {
        return new Int32Array(array);
    }
    else if (dtype === 'bool') {
        var bool = new Uint8Array(array.length);
        for (var i = 0; i < bool.length; ++i) {
            var val = array[i];
            if (util.isValNaN(val, 'bool')) {
                bool[i] = util.getNaN('bool');
            }
            else if (val) {
                bool[i] = 1;
            }
        }
        return bool;
    }
    else {
        throw new Error("Unknown data type " + dtype);
    }
}
function instanceofTypedArray(a) {
    return a instanceof Float32Array || a instanceof Int32Array ||
        a instanceof Uint8Array;
}
function noConversionNeeded(a, dtype) {
    return (a instanceof Float32Array && dtype === 'float32') ||
        (a instanceof Int32Array && dtype === 'int32') ||
        (a instanceof Uint8Array && dtype === 'bool');
}
function toTypedArray(a, dtype) {
    if (noConversionNeeded(a, dtype)) {
        return a;
    }
    if (Array.isArray(a)) {
        a = util.flatten(a);
    }
    return copyTypedArray(a, dtype);
}
function makeZerosTypedArray(size, dtype) {
    if (dtype == null || dtype === 'float32') {
        return new Float32Array(size);
    }
    else if (dtype === 'int32') {
        return new Int32Array(size);
    }
    else if (dtype === 'bool') {
        return new Uint8Array(size);
    }
    else {
        throw new Error("Unknown data type " + dtype);
    }
}
function typedArrayToFloat32(a, dtype) {
    if (a instanceof Float32Array) {
        return a;
    }
    else {
        var res = new Float32Array(a.length);
        for (var i = 0; i < res.length; i++) {
            var val = a[i];
            res[i] = util.isValNaN(val, dtype) ? NaN : val;
        }
        return res;
    }
}
function float32ToTypedArray(a, dtype) {
    if (dtype === 'float32') {
        return a;
    }
    else if (dtype === 'int32' || dtype === 'bool') {
        var result = (dtype === 'int32') ? new Int32Array(a.length) :
            new Uint8Array(a.length);
        for (var i = 0; i < result.length; ++i) {
            var val = a[i];
            val = isNaN(val) ? util.getNaN(dtype) : Math.round(val);
            result[i] = val;
        }
        return result;
    }
    else {
        throw new Error("Unknown dtype " + dtype);
    }
}

},{"../environment":7,"../util":88,"./webgl/tex_util":81,"./webgl/webgl_util":86}],56:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PARALLELIZE_THRESHOLD = 30;
function computeOptimalWindowSize(inSize) {
    if (inSize <= exports.PARALLELIZE_THRESHOLD) {
        return inSize;
    }
    return nearestDivisor(inSize, Math.floor(Math.sqrt(inSize)));
}
exports.computeOptimalWindowSize = computeOptimalWindowSize;
function nearestDivisor(size, start) {
    for (var i = start; i < size; ++i) {
        if (size % i === 0) {
            return i;
        }
    }
    return size;
}

},{}],57:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var util = require("../util");
function assertParamsValid(input, begin, size) {
    util.assert(input.rank === begin.length, "Error in slice" + input.rank + "D: Length of begin " + begin + " must " +
        ("match the rank of the array (" + input.rank + ")."));
    util.assert(input.rank === size.length, "Error in slice" + input.rank + "D: Length of size " + size + " must " +
        ("match the rank of the array (" + input.rank + ")."));
    for (var i = 0; i < input.rank; ++i) {
        util.assert(begin[i] + size[i] <= input.shape[i], "Error in slice" + input.rank + "D: begin[" + i + "] + size[" + i + "] " +
            ("(" + (begin[i] + size[i]) + ") would overflow input.shape[" + i + "] (" + input.shape[i] + ")"));
    }
}
exports.assertParamsValid = assertParamsValid;

},{"../util":88}],58:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var broadcast_util = require("../broadcast_util");
var AddScaledMatProgram = (function () {
    function AddScaledMatProgram(aShape, bShape) {
        this.variableNames = ['A', 'B', 'c1', 'c2'];
        this.supportsBroadcasting = true;
        this.outputShape =
            broadcast_util.assertAndGetBroadcastShape(aShape, bShape);
        this.userCode = "\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        float c1 = getC1();\n        float c2 = getC2();\n        setOutput(dot(vec2(c1, c2), vec2(a, b)));\n      }\n    ";
    }
    return AddScaledMatProgram;
}());
exports.AddScaledMatProgram = AddScaledMatProgram;

},{"../broadcast_util":47}],59:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ArgMinMaxProgram = (function () {
    function ArgMinMaxProgram(reduceInfo, op, firstPass) {
        this.variableNames = ['A'];
        var windowSize = reduceInfo.windowSize;
        var batchSize = reduceInfo.batchSize;
        var inSize = reduceInfo.inSize;
        var outSize = Math.ceil(inSize / windowSize);
        if (!firstPass) {
            this.variableNames.push('bestIndicesA');
        }
        this.outputShape = [batchSize, outSize];
        var compOp = (op === 'max') ? '>' : '<';
        var indexSnippet = firstPass ?
            'inOffset + i;' :
            'round(getBestIndicesA(batch, inOffset + i));';
        this.userCode = "\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * " + windowSize + ";\n\n        int bestIndex = 0;\n        float bestValue = getA(batch, inOffset);\n\n        for (int i = 0; i < " + windowSize + "; i++) {\n          int inIdx = " + indexSnippet + ";\n          float candidate = getA(batch, inIdx);\n          if (isNaN(candidate)) {\n            setOutput(candidate);\n            return;\n          }\n          if (candidate " + compOp + " bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    ";
    }
    return ArgMinMaxProgram;
}());
exports.ArgMinMaxProgram = ArgMinMaxProgram;

},{}],60:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var broadcast_util = require("../broadcast_util");
var BatchNormProgram = (function () {
    function BatchNormProgram(xShape, meanShape, varianceShape, offsetShape, scaleShape, varianceEpsilon) {
        this.outputShape = [];
        this.supportsBroadcasting = true;
        this.variableNames = ['x', 'mean', 'variance'];
        broadcast_util.assertAndGetBroadcastShape(xShape, meanShape);
        broadcast_util.assertAndGetBroadcastShape(xShape, varianceShape);
        var offsetSnippet = '0.0';
        if (offsetShape != null) {
            broadcast_util.assertAndGetBroadcastShape(xShape, offsetShape);
            this.variableNames.push('offset');
            offsetSnippet = 'getOffsetAtOutCoords()';
        }
        var scaleSnippet = '1.0';
        if (scaleShape != null) {
            broadcast_util.assertAndGetBroadcastShape(xShape, scaleShape);
            this.variableNames.push('scale');
            scaleSnippet = 'getScaleAtOutCoords()';
        }
        this.outputShape = xShape;
        this.userCode = "\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = " + offsetSnippet + ";\n        float scale = " + scaleSnippet + ";\n        float inv = scale / sqrt(variance + float(" + varianceEpsilon + "));\n        setOutput((x - mean) * inv + offset);\n      }\n    ";
    }
    return BatchNormProgram;
}());
exports.BatchNormProgram = BatchNormProgram;

},{"../broadcast_util":47}],61:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var broadcast_util = require("../broadcast_util");
exports.ADD = 'return a + b;';
exports.SUB = 'return a - b;';
exports.MUL = 'return a * b;';
exports.DIV = 'return a / b;';
exports.EQUAL = "\n  if (isNaN(a)) return a;\n  if (isNaN(b)) return b;\n  return float(a == b);\n";
var BinaryOpProgram = (function () {
    function BinaryOpProgram(op, aShape, bShape) {
        this.variableNames = ['A', 'B'];
        this.supportsBroadcasting = true;
        this.outputShape =
            broadcast_util.assertAndGetBroadcastShape(aShape, bShape);
        this.userCode = "\n      float binaryOperation(float a, float b) {\n        " + op + "\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    ";
    }
    return BinaryOpProgram;
}());
exports.BinaryOpProgram = BinaryOpProgram;

},{"../broadcast_util":47}],62:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ClipProgram = (function () {
    function ClipProgram(aShape, min, max) {
        this.variableNames = ['A'];
        this.outputShape = aShape;
        var minFixed = min.toFixed(20);
        var maxFixed = max.toFixed(20);
        this.userCode = "\n      void main() {\n        float value = getAAtOutCoords();\n        if (isNaN(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, " + minFixed + ", " + maxFixed + "));\n      }\n    ";
    }
    return ClipProgram;
}());
exports.ClipProgram = ClipProgram;

},{}],63:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var concat_util = require("../concat_util");
var shader_compiler_1 = require("./shader_compiler");
var ConcatProgram = (function () {
    function ConcatProgram(aShape, bShape, axis) {
        this.variableNames = ['A', 'B'];
        this.outputShape = [];
        var yAxes = ['yR', 'yC', 'yD', 'yW'];
        var concatAxis = yAxes[axis];
        this.outputShape = concat_util.computeOutShape(aShape, bShape, axis);
        var dType = shader_compiler_1.getCoordsDataType(aShape.length);
        var unpackSnippet = getUnpack(aShape.length);
        var sampleCoords = getSampleCoords(aShape.length);
        this.userCode = "\n      void main() {\n        " + dType + " coords = getOutputCoords();\n        " + unpackSnippet + "\n\n        float value = 0.0;\n        if (" + concatAxis + " < " + aShape[axis] + ") {\n          value = getA(" + sampleCoords + ");\n        } else {\n          " + concatAxis + " -= " + aShape[axis] + ";\n          value = getB(" + sampleCoords + ");\n        }\n\n        setOutput(value);\n      }\n    ";
    }
    return ConcatProgram;
}());
exports.ConcatProgram = ConcatProgram;
function getSampleCoords(rank) {
    if (rank === 1) {
        return 'yR';
    }
    else if (rank === 2) {
        return 'yR, yC';
    }
    else if (rank === 3) {
        return 'yR, yC, yD';
    }
    else if (rank === 4) {
        return 'yR, yC, yD, yW';
    }
    else {
        throw Error("Concat for rank " + rank + " is not yet supported");
    }
}
function getUnpack(rank) {
    var res = rank === 1 ? 'int yR = coords;' : 'int yR = coords.x;';
    if (rank > 1) {
        res += '\nint yC = coords.y;';
    }
    if (rank > 2) {
        res += '\nint yD = coords.z;';
    }
    if (rank > 3) {
        res += '\nint yW = coords.w;';
    }
    if (rank > 4) {
        throw Error("Concat for rank " + rank + " is not yet supported");
    }
    return res;
}

},{"../concat_util":48,"./shader_compiler":79}],64:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var conv_util = require("../conv_util");
var Conv2DDerWeightsProgram = (function () {
    function Conv2DDerWeightsProgram(convInfo) {
        this.variableNames = ['x', 'dy'];
        var _a = convInfo.outShape, yNumRows = _a[0], yNumCols = _a[1], outDepth = _a[2];
        var _b = convInfo.inShape, xNumRows = _b[0], xNumCols = _b[1], inDepth = _b[2];
        var strideHeight = convInfo.strideHeight;
        var strideWidth = convInfo.strideWidth;
        this.outputShape = conv_util.computeWeightsShape4D(inDepth, outDepth, convInfo.filterHeight, convInfo.filterWidth);
        var padTop = convInfo.padInfo.top;
        var padLeft = convInfo.padInfo.left;
        this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int yR = 0; yR < " + yNumRows + "; yR++) {\n          int xR = wR + yR * " + strideHeight + " - " + padTop + ";\n\n          if (xR < 0 || xR >= " + xNumRows + ") {\n            continue;\n          }\n\n          for (int yC = 0; yC < " + yNumCols + "; yC++) {\n            int xC = wC + yC * " + strideWidth + " - " + padLeft + ";\n\n            if (xC < 0 || xC >= " + xNumCols + ") {\n              continue;\n            }\n\n            float dyValue = getDy(yR, yC, d2);\n            float xValue = getX(xR, xC, d1);\n            dotProd += (xValue * dyValue);\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
    }
    return Conv2DDerWeightsProgram;
}());
exports.Conv2DDerWeightsProgram = Conv2DDerWeightsProgram;
var Conv2DDerInputProgram = (function () {
    function Conv2DDerInputProgram(convInfo) {
        this.variableNames = ['dy', 'W'];
        var _a = convInfo.outShape, yRows = _a[0], yCols = _a[1], outDepth = _a[2];
        this.outputShape = convInfo.inShape;
        var filterHeight = convInfo.filterHeight;
        var filterWidth = convInfo.filterWidth;
        var strideHeight = convInfo.strideHeight;
        var strideWidth = convInfo.strideWidth;
        var padTop = filterHeight - 1 - convInfo.padInfo.top;
        var padLeft = filterWidth - 1 - convInfo.padInfo.left;
        this.userCode = "\n      const ivec2 pads = ivec2(" + padTop + ", " + padLeft + ");\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int d1 = coords.z;\n\n        ivec2 dyCorner = coords.xy - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < " + filterHeight + "; wR++) {\n          float dyR = float(dyRCorner + wR) / " + strideHeight + ".0;\n\n          if (dyR < 0.0 || dyR >= " + yRows + ".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = " + filterHeight + " - 1 - wR;\n\n          for (int wC = 0; wC < " + filterWidth + "; wC++) {\n            float dyC = float(dyCCorner + wC) / " + strideWidth + ".0;\n\n            if (dyC < 0.0 || dyC >= " + yCols + ".0 || fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = " + filterWidth + " - 1 - wC;\n\n            for (int d2 = 0; d2 < " + outDepth + "; d2++) {\n              float xValue = getDy(idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, d2);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
    }
    return Conv2DDerInputProgram;
}());
exports.Conv2DDerInputProgram = Conv2DDerInputProgram;
var Conv2DDerBiasProgram = (function () {
    function Conv2DDerBiasProgram(yShape) {
        this.variableNames = ['dy'];
        var yNumRows = yShape[0], yNumCols = yShape[1], outputDepth = yShape[2];
        this.outputShape = [outputDepth];
        this.userCode = "\n      void main() {\n        int d2 = getOutputCoords();\n\n        float derBias = 0.0;\n        for (int yR = 0; yR < " + yNumRows + "; yR++) {\n          for (int yC = 0; yC < " + yNumCols + "; yC++) {\n            derBias += getDy(yR, yC, d2);\n          }\n        }\n        setOutput(derBias);\n      }\n    ";
    }
    return Conv2DDerBiasProgram;
}());
exports.Conv2DDerBiasProgram = Conv2DDerBiasProgram;

},{"../conv_util":49}],65:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Conv2DProgram = (function () {
    function Conv2DProgram(convInfo, hasBias) {
        this.variableNames = ['x', 'W'];
        if (hasBias) {
            this.variableNames.push('bias');
        }
        this.outputShape = convInfo.outShape;
        var biasSnippet = hasBias ? 'dotProd += getBias(d2);' : '';
        var _a = convInfo.inShape, xNumRows = _a[0], xNumCols = _a[1], inputDepth = _a[2];
        var padTop = convInfo.padInfo.top;
        var padLeft = convInfo.padInfo.left;
        var strideHeight = convInfo.strideHeight;
        var strideWidth = convInfo.strideWidth;
        var filterHeight = convInfo.filterHeight;
        var filterWidth = convInfo.filterWidth;
        var inputDepthNearestVec4 = Math.floor(inputDepth / 4) * 4;
        var inputDepthVec4Remainder = inputDepth % 4;
        this.userCode = "\n      const ivec2 strides = ivec2(" + strideHeight + ", " + strideWidth + ");\n      const ivec2 pads = ivec2(" + padTop + ", " + padLeft + ");\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int d2 = coords.z;\n\n        ivec2 xRCCorner = coords.xy * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < " + filterHeight + "; wR++) {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= " + xNumRows + ") {\n            continue;\n          }\n\n          for (int wC = 0; wC < " + filterWidth + "; wC++) {\n            int xC = xCCorner + wC;\n\n            if (xC < 0 || xC >= " + xNumCols + ") {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < " + inputDepthNearestVec4 + "; d1 += 4) {\n              vec4 xValues = vec4(\n                getX(xR, xC, d1),\n                getX(xR, xC, d1 + 1),\n                getX(xR, xC, d1 + 2),\n                getX(xR, xC, d1 + 3)\n              );\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              dotProd += dot(xValues, wValues);\n            }\n\n            if (" + (inputDepthVec4Remainder === 1) + ") {\n              dotProd +=\n                getX(xR, xC, " + inputDepthNearestVec4 + ") *\n                getW(wR, wC, " + inputDepthNearestVec4 + ", d2);\n            } else if (" + (inputDepthVec4Remainder === 2) + ") {\n              vec2 xValues = vec2(\n                getX(xR, xC, " + inputDepthNearestVec4 + "),\n                getX(xR, xC, " + inputDepthNearestVec4 + " + 1)\n              );\n              vec2 wValues = vec2(\n                getW(wR, wC, " + inputDepthNearestVec4 + ", d2),\n                getW(wR, wC, " + inputDepthNearestVec4 + " + 1, d2)\n              );\n              dotProd += dot(xValues, wValues);\n            } else if (" + (inputDepthVec4Remainder === 3) + ") {\n              vec3 xValues = vec3(\n                getX(xR, xC, " + inputDepthNearestVec4 + "),\n                getX(xR, xC, " + inputDepthNearestVec4 + " + 1),\n                getX(xR, xC, " + inputDepthNearestVec4 + " + 2)\n              );\n              vec3 wValues = vec3(\n                getW(wR, wC, " + inputDepthNearestVec4 + ", d2),\n                getW(wR, wC, " + inputDepthNearestVec4 + " + 1, d2),\n                getW(wR, wC, " + inputDepthNearestVec4 + " + 2, d2)\n              );\n              dotProd += dot(xValues, wValues);\n            }\n          }\n        }\n        " + biasSnippet + "\n        setOutput(dotProd);\n      }\n    ";
    }
    return Conv2DProgram;
}());
exports.Conv2DProgram = Conv2DProgram;

},{}],66:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var DepthwiseConv2DProgram = (function () {
    function DepthwiseConv2DProgram(convInfo) {
        this.variableNames = ['x', 'W'];
        this.outputShape = convInfo.outShape;
        var xNumRows = convInfo.inShape[1];
        var xNumCols = convInfo.inShape[2];
        var padTop = convInfo.padInfo.top;
        var padLeft = convInfo.padInfo.left;
        var strideHeight = convInfo.strideHeight;
        var strideWidth = convInfo.strideWidth;
        var filterHeight = convInfo.filterHeight;
        var filterWidth = convInfo.filterWidth;
        var channelMul = convInfo.channelMul;
        this.userCode = "\n      const ivec2 strides = ivec2(" + strideHeight + ", " + strideWidth + ");\n      const ivec2 pads = ivec2(" + padTop + ", " + padLeft + ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / " + channelMul + ";\n        int q = d2 - d1 * " + channelMul + ";\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TODO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < " + filterHeight + "; wR++) {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= " + xNumRows + ") {\n            continue;\n          }\n\n          for (int wC = 0; wC < " + filterWidth + "; wC++) {\n            int xC = xCCorner + wC;\n\n            if (xC < 0 || xC >= " + xNumCols + ") {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
    }
    return DepthwiseConv2DProgram;
}());
exports.DepthwiseConv2DProgram = DepthwiseConv2DProgram;

},{}],67:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Copy2DProgram = (function () {
    function Copy2DProgram(srcNumCols, destNumCols) {
        this.variableNames = ['source'];
        this.outputShape = null;
        this.userCode = "\n      uniform ivec2 sourceStart;\n      uniform ivec2 destStart;\n\n      void main() {\n        ivec2 destCoords = getOutputCoords() - destStart;\n        int index = destCoords.x * " + destNumCols + " + destCoords.y;\n        int r = index / " + srcNumCols + ";\n        ivec2 sourceCoords = sourceStart + ivec2(r, index - r * " + srcNumCols + ");\n        setOutput(getSource(sourceCoords.x, sourceCoords.y));\n      }\n    ";
    }
    Copy2DProgram.prototype.getCustomSetupFunc = function (sourceStart, destStart, destSize) {
        return function (gpgpu, webGLProgram) {
            gpgpu.setOutputMatrixWriteRegion(destStart[0], destSize[0], destStart[1], destSize[1]);
            var sourceStartCRLoc = gpgpu.getUniformLocation(webGLProgram, 'sourceStart');
            gpgpu.gl.uniform2i(sourceStartCRLoc, sourceStart[0], sourceStart[1]);
            var destStartCRLoc = gpgpu.getUniformLocation(webGLProgram, 'destStart');
            gpgpu.gl.uniform2i(destStartCRLoc, destStart[0], destStart[1]);
        };
    };
    return Copy2DProgram;
}());
exports.Copy2DProgram = Copy2DProgram;

},{}],68:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var environment_1 = require("../../environment");
var util = require("../../util");
var gpgpu_util = require("./gpgpu_util");
var tex_util = require("./tex_util");
var webgl_util = require("./webgl_util");
var GPGPUContext = (function () {
    function GPGPUContext(gl) {
        this.outputTexture = null;
        this.program = null;
        this.disposed = false;
        this.autoDebugValidate = false;
        if (gl != null) {
            this.gl = gl;
        }
        else {
            this.gl = gpgpu_util.createWebGLContext();
        }
        if (environment_1.ENV.get('WEBGL_VERSION') === 1) {
            this.textureFloatExtension =
                webgl_util.getExtensionOrThrow(this.gl, 'OES_texture_float');
            this.colorBufferFloatExtension =
                this.gl.getExtension('WEBGL_color_buffer_float');
        }
        else {
            this.colorBufferFloatExtension =
                webgl_util.getExtensionOrThrow(this.gl, 'EXT_color_buffer_float');
        }
        this.loseContextExtension =
            webgl_util.getExtensionOrThrow(this.gl, 'WEBGL_lose_context');
        if (environment_1.ENV.get('WEBGL_GET_BUFFER_SUB_DATA_ASYNC_EXTENSION_ENABLED')) {
            this.getBufferSubDataAsyncExtension =
                this.gl.getExtension('WEBGL_get_buffer_sub_data_async');
        }
        this.vertexBuffer = gpgpu_util.createVertexBuffer(this.gl);
        this.indexBuffer = gpgpu_util.createIndexBuffer(this.gl);
        this.framebuffer = webgl_util.createFramebuffer(this.gl);
    }
    GPGPUContext.prototype.dispose = function () {
        var _this = this;
        this.throwIfDisposed();
        if (this.program != null) {
            console.warn('Disposing a GPGPUContext that still has a bound WebGLProgram.' +
                ' This is probably a resource leak, delete the program with ' +
                'GPGPUContext.deleteProgram before disposing.');
        }
        if (this.outputTexture != null) {
            console.warn('Disposing a GPGPUContext that still has a bound output matrix ' +
                'texture.  This is probably a resource leak, delete the output ' +
                'matrix texture with GPGPUContext.deleteMatrixTexture before ' +
                'disposing.');
        }
        var gl = this.gl;
        webgl_util.callAndCheck(gl, function () { return gl.finish(); });
        webgl_util.callAndCheck(gl, function () { return gl.bindFramebuffer(gl.FRAMEBUFFER, null); });
        webgl_util.callAndCheck(gl, function () { return gl.deleteFramebuffer(_this.framebuffer); });
        webgl_util.callAndCheck(gl, function () { return gl.bindBuffer(gl.ARRAY_BUFFER, null); });
        webgl_util.callAndCheck(gl, function () { return gl.deleteBuffer(_this.vertexBuffer); });
        webgl_util.callAndCheck(gl, function () { return gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null); });
        webgl_util.callAndCheck(gl, function () { return gl.deleteBuffer(_this.indexBuffer); });
        this.loseContextExtension.loseContext();
        this.disposed = true;
    };
    GPGPUContext.prototype.enableAutomaticDebugValidation = function (enabled) {
        this.autoDebugValidate = enabled;
        webgl_util.enableDebugWebGLErrorChecking(enabled);
    };
    GPGPUContext.prototype.createMatrixTexture = function (rows, columns) {
        this.throwIfDisposed();
        return gpgpu_util.createMatrixTexture(this.gl, rows, columns);
    };
    GPGPUContext.prototype.uploadPixelDataToTexture = function (texture, pixels) {
        this.throwIfDisposed();
        gpgpu_util.uploadPixelDataToTexture(this.gl, texture, pixels);
    };
    GPGPUContext.prototype.createPackedMatrixTexture = function (rows, columns) {
        this.throwIfDisposed();
        return gpgpu_util.createPackedMatrixTexture(this.gl, rows, columns);
    };
    GPGPUContext.prototype.deleteMatrixTexture = function (texture) {
        var _this = this;
        this.throwIfDisposed();
        if (this.outputTexture === texture) {
            webgl_util.unbindColorTextureFromFramebuffer(this.gl, this.framebuffer);
            this.outputTexture = null;
        }
        webgl_util.callAndCheck(this.gl, function () { return _this.gl.deleteTexture(texture); });
    };
    GPGPUContext.prototype.uploadMatrixToTexture = function (texture, rows, columns, matrix) {
        this.throwIfDisposed();
        var numChannels = 1;
        return gpgpu_util.uploadMatrixToTexture(this.gl, texture, rows, columns, matrix, numChannels);
    };
    GPGPUContext.prototype.uploadMatrixToPackedTexture = function (texture, rows, columns, matrix) {
        this.throwIfDisposed();
        return gpgpu_util.uploadMatrixToPackedTexture(this.gl, texture, rows, columns, matrix);
    };
    GPGPUContext.prototype.downloadMatrixFromTexture = function (texture, rows, columns) {
        var _this = this;
        return this.downloadMatrixDriver(texture, function () {
            return gpgpu_util.downloadMatrixFromOutputTexture(_this.gl, rows, columns);
        });
    };
    GPGPUContext.prototype.downloadMatrixFromTextureAsync = function (texture, rows, columns) {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                if (this.getBufferSubDataAsyncExtension == null) {
                    throw new Error("Cannot download matrix from output texture asynchronously, " +
                        "WEBGL_get_buffer_sub_data_async is not enabled.");
                }
                return [2, this.downloadMatrixDriverAsync(texture, function () { return gpgpu_util.downloadMatrixFromOutputTextureAsync(_this.gl, _this.getBufferSubDataAsyncExtension, rows, columns); })];
            });
        });
    };
    GPGPUContext.prototype.downloadMatrixFromRGBAColorTexture = function (texture, rows, columns, channels) {
        var _this = this;
        return this.downloadMatrixDriver(texture, function () { return gpgpu_util.downloadMatrixFromRGBAColorTexture(_this.gl, rows, columns, channels); });
    };
    GPGPUContext.prototype.downloadMatrixFromPackedTexture = function (texture, rows, columns) {
        var _this = this;
        return this.downloadMatrixDriver(texture, function () { return gpgpu_util.downloadMatrixFromPackedOutputTexture(_this.gl, rows, columns); });
    };
    GPGPUContext.prototype.createProgram = function (fragmentShaderSource) {
        this.throwIfDisposed();
        var gl = this.gl;
        var fragmentShader = webgl_util.createFragmentShader(gl, fragmentShaderSource);
        var vertexShader = gpgpu_util.createVertexShader(gl);
        var program = webgl_util.createProgram(gl);
        webgl_util.callAndCheck(gl, function () { return gl.attachShader(program, vertexShader); });
        webgl_util.callAndCheck(gl, function () { return gl.attachShader(program, fragmentShader); });
        webgl_util.linkProgram(gl, program);
        if (this.autoDebugValidate) {
            webgl_util.validateProgram(gl, program);
        }
        return program;
    };
    GPGPUContext.prototype.deleteProgram = function (program) {
        var _this = this;
        this.throwIfDisposed();
        if (program === this.program) {
            this.program = null;
        }
        if (program != null) {
            webgl_util.callAndCheck(this.gl, function () { return _this.gl.deleteProgram(program); });
        }
    };
    GPGPUContext.prototype.setProgram = function (program) {
        var _this = this;
        this.throwIfDisposed();
        this.program = program;
        if ((this.program != null) && this.autoDebugValidate) {
            webgl_util.validateProgram(this.gl, this.program);
        }
        webgl_util.callAndCheck(this.gl, function () { return _this.gl.useProgram(program); });
    };
    GPGPUContext.prototype.getUniformLocation = function (program, uniformName) {
        this.throwIfDisposed();
        return webgl_util.getProgramUniformLocationOrThrow(this.gl, program, uniformName);
    };
    GPGPUContext.prototype.getAttributeLocation = function (program, attribute) {
        var _this = this;
        this.throwIfDisposed();
        return webgl_util.callAndCheck(this.gl, function () { return _this.gl.getAttribLocation(program, attribute); });
    };
    GPGPUContext.prototype.getUniformLocationNoThrow = function (program, uniformName) {
        this.throwIfDisposed();
        return this.gl.getUniformLocation(program, uniformName);
    };
    GPGPUContext.prototype.setInputMatrixTexture = function (inputMatrixTexture, uniformLocation, textureUnit) {
        this.throwIfDisposed();
        this.throwIfNoProgram();
        webgl_util.bindTextureToProgramUniformSampler(this.gl, this.program, inputMatrixTexture, uniformLocation, textureUnit);
    };
    GPGPUContext.prototype.setOutputMatrixTexture = function (outputMatrixTexture, rows, columns) {
        this.setOutputMatrixTextureDriver(outputMatrixTexture, columns, rows);
    };
    GPGPUContext.prototype.setOutputPackedMatrixTexture = function (outputPackedMatrixTexture, rows, columns) {
        this.throwIfDisposed();
        var _a = tex_util.getPackedMatrixTextureShapeWidthHeight(rows, columns), width = _a[0], height = _a[1];
        this.setOutputMatrixTextureDriver(outputPackedMatrixTexture, width, height);
    };
    GPGPUContext.prototype.setOutputMatrixWriteRegion = function (startRow, numRows, startColumn, numColumns) {
        this.setOutputMatrixWriteRegionDriver(startColumn, startRow, numColumns, numRows);
    };
    GPGPUContext.prototype.setOutputPackedMatrixWriteRegion = function (startRow, numRows, startColumn, numColumns) {
        throw new Error('setOutputPackedMatrixWriteRegion not implemented.');
    };
    GPGPUContext.prototype.debugValidate = function () {
        if (this.program != null) {
            webgl_util.validateProgram(this.gl, this.program);
        }
        webgl_util.validateFramebuffer(this.gl);
    };
    GPGPUContext.prototype.executeProgram = function (attribLocations) {
        this.throwIfDisposed();
        this.throwIfNoProgram();
        var gl = this.gl;
        gpgpu_util.bindVertexProgramAttributeStreams(gl, this.program, this.vertexBuffer, attribLocations);
        if (this.autoDebugValidate) {
            this.debugValidate();
        }
        webgl_util.callAndCheck(gl, function () { return gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0); });
    };
    GPGPUContext.prototype.blockUntilAllProgramsCompleted = function () {
        var _this = this;
        this.throwIfDisposed();
        webgl_util.callAndCheck(this.gl, function () { return _this.gl.finish(); });
    };
    GPGPUContext.prototype.runQuery = function (queryFn) {
        if (environment_1.ENV.get('WEBGL_VERSION') === 2) {
            return this.runQueryWebGL2(queryFn);
        }
        return this.runQueryWebGL1(queryFn);
    };
    GPGPUContext.prototype.runQueryWebGL2 = function (benchmark) {
        var _this = this;
        var ext = webgl_util.getExtensionOrThrow(this.gl, 'EXT_disjoint_timer_query_webgl2');
        var query = this.gl.createQuery();
        this.gl.beginQuery(ext.TIME_ELAPSED_EXT, query);
        benchmark();
        this.gl.endQuery(ext.TIME_ELAPSED_EXT);
        return new Promise(function (resolve, reject) {
            var queryGPU = function () {
                var available = _this.gl
                    .getQueryParameter(query, _this.gl.QUERY_RESULT_AVAILABLE);
                var disjoint = _this.gl.getParameter(ext.GPU_DISJOINT_EXT);
                return available && !disjoint;
            };
            var getTimeElapsed = function () {
                var timeElapsedNanos = _this.gl
                    .getQueryParameter(query, _this.gl.QUERY_RESULT);
                resolve(timeElapsedNanos / 1000000);
            };
            var resolveWithWarning = function () {
                console.warn('Disjoint query timer never available.');
                resolve(-1);
            };
            util.repeatedTry(queryGPU).then(getTimeElapsed).catch(resolveWithWarning);
        });
    };
    GPGPUContext.prototype.runQueryWebGL1 = function (benchmark) {
        var _this = this;
        var ext = webgl_util.getExtensionOrThrow(this.gl, 'EXT_disjoint_timer_query');
        var query = ext.createQueryEXT();
        ext.beginQueryEXT(ext.TIME_ELAPSED_EXT, query);
        benchmark();
        ext.endQueryEXT(ext.TIME_ELAPSED_EXT);
        return new Promise(function (resolve, reject) {
            var queryGPU = function () {
                var available = ext.getQueryObjectEXT(query, ext.QUERY_RESULT_AVAILABLE_EXT);
                var disjoint = _this.gl.getParameter(ext.GPU_DISJOINT_EXT);
                return available && !disjoint;
            };
            var getTimeElapsed = function () {
                var timeElapsedNanos = ext.getQueryObjectEXT(query, ext.QUERY_RESULT_EXT);
                resolve(timeElapsedNanos / 1000000);
            };
            var resolveWithWarning = function () {
                console.warn('Disjoint query timer never available.');
                resolve(-1);
            };
            util.repeatedTry(queryGPU).then(getTimeElapsed).catch(resolveWithWarning);
        });
    };
    GPGPUContext.prototype.downloadMatrixDriverSetup = function (texture) {
        this.throwIfDisposed();
        webgl_util.bindColorTextureToFramebuffer(this.gl, texture, this.framebuffer);
        if (this.autoDebugValidate) {
            webgl_util.validateFramebuffer(this.gl);
        }
    };
    GPGPUContext.prototype.downloadMatrixDriverTeardown = function () {
        if (this.outputTexture != null) {
            webgl_util.bindColorTextureToFramebuffer(this.gl, this.outputTexture, this.framebuffer);
            if (this.autoDebugValidate) {
                webgl_util.validateFramebuffer(this.gl);
            }
        }
        else {
            webgl_util.unbindColorTextureFromFramebuffer(this.gl, this.framebuffer);
        }
    };
    GPGPUContext.prototype.downloadMatrixDriver = function (texture, downloadAndDecode) {
        this.downloadMatrixDriverSetup(texture);
        var result = downloadAndDecode();
        this.downloadMatrixDriverTeardown();
        return result;
    };
    GPGPUContext.prototype.downloadMatrixDriverAsync = function (texture, downloadAndDecode) {
        return __awaiter(this, void 0, void 0, function () {
            var result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this.downloadMatrixDriverSetup(texture);
                        return [4, downloadAndDecode()];
                    case 1:
                        result = _a.sent();
                        this.downloadMatrixDriverTeardown();
                        return [2, result];
                }
            });
        });
    };
    GPGPUContext.prototype.setOutputMatrixTextureDriver = function (outputMatrixTextureMaybePacked, width, height) {
        this.throwIfDisposed();
        var gl = this.gl;
        webgl_util.bindColorTextureToFramebuffer(gl, outputMatrixTextureMaybePacked, this.framebuffer);
        if (this.autoDebugValidate) {
            webgl_util.validateFramebuffer(gl);
        }
        this.outputTexture = outputMatrixTextureMaybePacked;
        webgl_util.callAndCheck(gl, function () { return gl.viewport(0, 0, width, height); });
        webgl_util.callAndCheck(gl, function () { return gl.scissor(0, 0, width, height); });
    };
    GPGPUContext.prototype.setOutputMatrixWriteRegionDriver = function (x, y, width, height) {
        var _this = this;
        this.throwIfDisposed();
        webgl_util.callAndCheck(this.gl, function () { return _this.gl.scissor(x, y, width, height); });
    };
    GPGPUContext.prototype.throwIfDisposed = function () {
        if (this.disposed) {
            throw new Error('Attempted to use disposed GPGPUContext.');
        }
    };
    GPGPUContext.prototype.throwIfNoProgram = function () {
        if (this.program == null) {
            throw new Error('No GPU program is currently set.');
        }
    };
    return GPGPUContext;
}());
exports.GPGPUContext = GPGPUContext;

},{"../../environment":7,"../../util":88,"./gpgpu_util":70,"./tex_util":81,"./webgl_util":86}],69:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var environment_1 = require("../../environment");
var util = require("../../util");
var shader_compiler = require("./shader_compiler");
var ATTRIBUTE_NAMES = ['uv', 'clipSpacePos'];
var NAN_UNIFORM_NAME = 'NaN';
function shouldUploadNaNUniform() {
    return !environment_1.ENV.get('WEBGL_FLOAT_TEXTURE_ENABLED');
}
function compileProgram(gpgpu, program, inputs, output) {
    var userCode = program.userCode;
    var inputInfos = inputs.map(function (input, i) {
        var shapeInfo = {
            logicalShape: input.shape,
            texShape: input.getTextureShapeRC(),
            textureType: input.getData().textureType
        };
        return { name: program.variableNames[i], shapeInfo: shapeInfo };
    });
    var inShapeInfos = inputInfos.map(function (x) { return x.shapeInfo; });
    var outShapeInfo = {
        logicalShape: output.shape,
        texShape: output.getTextureShapeRC(),
        textureType: output.getData().textureType
    };
    var source = shader_compiler.makeShader(inputInfos, outShapeInfo, userCode, program.supportsBroadcasting === true);
    var webGLProgram = gpgpu.createProgram(source);
    var uniformLocations = {};
    for (var i = 0; i < program.variableNames.length; i++) {
        var uniformName = program.variableNames[i];
        uniformLocations[uniformName] =
            gpgpu.getUniformLocation(webGLProgram, uniformName);
    }
    var attributeLocations = {};
    ATTRIBUTE_NAMES.forEach(function (attribute) {
        attributeLocations[attribute] =
            gpgpu.getAttributeLocation(webGLProgram, attribute);
    });
    if (shouldUploadNaNUniform()) {
        uniformLocations[NAN_UNIFORM_NAME] =
            gpgpu.getUniformLocation(webGLProgram, NAN_UNIFORM_NAME);
    }
    return {
        program: program,
        source: source,
        webGLProgram: webGLProgram,
        uniformLocations: uniformLocations,
        attributeLocations: attributeLocations,
        gpgpu: gpgpu,
        inShapeInfos: inShapeInfos,
        outShapeInfo: outShapeInfo
    };
}
exports.compileProgram = compileProgram;
function validateBinaryAndProgram(shapeInfos, inputs) {
    if (shapeInfos.length !== inputs.length) {
        throw Error("Binary was compiled with " + shapeInfos.length + " inputs, but " +
            ("was executed with " + inputs.length + " inputs"));
    }
    shapeInfos.forEach(function (s, i) {
        var shapeA = s.logicalShape;
        var texShapeA = s.texShape;
        var shapeB = inputs[i].shape;
        var texShapeB = inputs[i].getTextureShapeRC();
        if (!util.arraysEqual(shapeA, shapeB)) {
            throw Error("Binary was compiled with different shapes than " +
                ("the current args. Shapes " + shapeA + " and " + shapeB + " must match"));
        }
        if (!util.arraysEqual(texShapeA, texShapeB)) {
            throw Error("Binary was compiled with different texture shapes than the" +
                (" current args. Shape " + texShapeA + " and " + texShapeB + " must match"));
        }
    });
}
function runProgram(binary, inputs, output, customSetup) {
    validateBinaryAndProgram(binary.inShapeInfos, inputs);
    validateBinaryAndProgram([binary.outShapeInfo], [output]);
    var outTex = output.getTexture();
    var outTexShape = output.getTextureShapeRC();
    var gpgpu = binary.gpgpu;
    gpgpu.setOutputMatrixTexture(outTex, outTexShape[0], outTexShape[1]);
    gpgpu.setProgram(binary.webGLProgram);
    inputs.forEach(function (input, i) {
        var tex = input.getTexture();
        var variableName = binary.program.variableNames[i];
        var variableUniformLocation = binary.uniformLocations[variableName];
        gpgpu.setInputMatrixTexture(tex, variableUniformLocation, i);
    });
    if (shouldUploadNaNUniform()) {
        gpgpu.gl.uniform1f(binary.uniformLocations[NAN_UNIFORM_NAME], NaN);
    }
    if (customSetup != null) {
        customSetup(gpgpu, binary.webGLProgram);
    }
    gpgpu.executeProgram(binary.attributeLocations);
}
exports.runProgram = runProgram;
function makeShaderKey(program, inputs, output) {
    var keyInputs = '';
    inputs.concat(output).forEach(function (x) {
        keyInputs += x.shape + "_" + x.getTextureShapeRC();
    });
    var keyUserCode = program.userCode;
    var keyBroadcast = (program.supportsBroadcasting === true).toString();
    var key = program.constructor.name;
    key += '_' + keyBroadcast + '_' + keyInputs + '_' + keyUserCode;
    return key;
}
exports.makeShaderKey = makeShaderKey;

},{"../../environment":7,"../../util":88,"./shader_compiler":79}],70:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var environment_1 = require("../../environment");
var tex_util = require("./tex_util");
var webgl_util = require("./webgl_util");
function getWebGLContextAttributes() {
    return {
        alpha: false,
        antialias: false,
        premultipliedAlpha: false,
        preserveDrawingBuffer: false,
        depth: false,
        stencil: false,
        failIfMajorPerformanceCaveat: true
    };
}
exports.getWebGLContextAttributes = getWebGLContextAttributes;
function createWebGLContext(canvas) {
    var attributes = getWebGLContextAttributes();
    var gl;
    if (canvas != null) {
        gl = webgl_util.createWebGLRenderingContextFromCanvas(canvas, attributes);
    }
    else {
        gl = webgl_util.createWebGLRenderingContext(attributes);
    }
    webgl_util.callAndCheck(gl, function () { return gl.disable(gl.DEPTH_TEST); });
    webgl_util.callAndCheck(gl, function () { return gl.disable(gl.STENCIL_TEST); });
    webgl_util.callAndCheck(gl, function () { return gl.disable(gl.BLEND); });
    webgl_util.callAndCheck(gl, function () { return gl.disable(gl.DITHER); });
    webgl_util.callAndCheck(gl, function () { return gl.disable(gl.POLYGON_OFFSET_FILL); });
    webgl_util.callAndCheck(gl, function () { return gl.disable(gl.SAMPLE_COVERAGE); });
    webgl_util.callAndCheck(gl, function () { return gl.enable(gl.SCISSOR_TEST); });
    webgl_util.callAndCheck(gl, function () { return gl.enable(gl.CULL_FACE); });
    webgl_util.callAndCheck(gl, function () { return gl.cullFace(gl.BACK); });
    return gl;
}
exports.createWebGLContext = createWebGLContext;
function createVertexShader(gl) {
    var vertexShaderSource = "\n    precision highp float;\n    attribute vec3 clipSpacePos;\n    attribute vec2 uv;\n    varying vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }";
    return webgl_util.createVertexShader(gl, vertexShaderSource);
}
exports.createVertexShader = createVertexShader;
function createVertexBuffer(gl) {
    var vertexArray = new Float32Array([-1, 1, 0, 0, 1, -1, -1, 0, 0, 0, 1, 1, 0, 1, 1, 1, -1, 0, 1, 0]);
    return webgl_util.createStaticVertexBuffer(gl, vertexArray);
}
exports.createVertexBuffer = createVertexBuffer;
function createIndexBuffer(gl) {
    var triangleVertexIndices = new Uint16Array([0, 1, 2, 2, 1, 3]);
    return webgl_util.createStaticIndexBuffer(gl, triangleVertexIndices);
}
exports.createIndexBuffer = createIndexBuffer;
function getTextureInternalFormat(gl, numChannels) {
    if (!environment_1.ENV.get('WEBGL_FLOAT_TEXTURE_ENABLED')) {
        return gl.RGBA;
    }
    if (environment_1.ENV.get('WEBGL_VERSION') === 2) {
        if (numChannels === 4) {
            return gl.RGBA32F;
        }
        return gl.R32F;
    }
    return gl.RGBA;
}
function getTextureFormat(gl, numChannels) {
    if (!environment_1.ENV.get('WEBGL_FLOAT_TEXTURE_ENABLED')) {
        return gl.RGBA;
    }
    if (environment_1.ENV.get('WEBGL_VERSION') === 2) {
        if (numChannels === 4) {
            return gl.RGBA;
        }
        return gl.RED;
    }
    return gl.RGBA;
}
function getTextureType(gl) {
    if (!environment_1.ENV.get('WEBGL_FLOAT_TEXTURE_ENABLED')) {
        return gl.UNSIGNED_BYTE;
    }
    return gl.FLOAT;
}
function createAndConfigureTexture(gl, width, height, numChannels) {
    webgl_util.validateTextureSize(gl, width, height);
    var texture = webgl_util.createTexture(gl);
    var tex2d = gl.TEXTURE_2D;
    var internalFormat = getTextureInternalFormat(gl, numChannels);
    var format = getTextureFormat(gl, numChannels);
    webgl_util.callAndCheck(gl, function () { return gl.bindTexture(tex2d, texture); });
    webgl_util.callAndCheck(gl, function () { return gl.texParameteri(tex2d, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE); });
    webgl_util.callAndCheck(gl, function () { return gl.texParameteri(tex2d, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE); });
    webgl_util.callAndCheck(gl, function () { return gl.texParameteri(tex2d, gl.TEXTURE_MIN_FILTER, gl.NEAREST); });
    webgl_util.callAndCheck(gl, function () { return gl.texParameteri(tex2d, gl.TEXTURE_MAG_FILTER, gl.NEAREST); });
    webgl_util.callAndCheck(gl, function () { return gl.texImage2D(tex2d, 0, internalFormat, width, height, 0, format, getTextureType(gl), null); });
    webgl_util.callAndCheck(gl, function () { return gl.bindTexture(gl.TEXTURE_2D, null); });
    return texture;
}
function createMatrixTexture(gl, rows, columns) {
    var _a = tex_util.getUnpackedMatrixTextureShapeWidthHeight(rows, columns), width = _a[0], height = _a[1];
    var numChannels = 1;
    return createAndConfigureTexture(gl, width, height, numChannels);
}
exports.createMatrixTexture = createMatrixTexture;
function createColorMatrixTexture(gl, rows, columns) {
    var _a = tex_util.getColorMatrixTextureShapeWidthHeight(rows, columns), width = _a[0], height = _a[1];
    var numChannels = 4;
    return createAndConfigureTexture(gl, width, height, numChannels);
}
exports.createColorMatrixTexture = createColorMatrixTexture;
function createPackedMatrixTexture(gl, rows, columns) {
    var _a = tex_util.getPackedMatrixTextureShapeWidthHeight(rows, columns), width = _a[0], height = _a[1];
    var numChannels = 4;
    return createAndConfigureTexture(gl, width, height, numChannels);
}
exports.createPackedMatrixTexture = createPackedMatrixTexture;
function bindVertexProgramAttributeStreams(gl, program, vertexBuffer, attribLocations) {
    var posOffset = 0;
    var uvOffset = 3 * 4;
    var stride = (3 * 4) + (2 * 4);
    webgl_util.callAndCheck(gl, function () { return gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer); });
    webgl_util.bindVertexBufferToProgramAttribute(gl, program, 'clipSpacePos', vertexBuffer, 3, stride, posOffset, attribLocations);
    webgl_util.bindVertexBufferToProgramAttribute(gl, program, 'uv', vertexBuffer, 2, stride, uvOffset, attribLocations);
}
exports.bindVertexProgramAttributeStreams = bindVertexProgramAttributeStreams;
function uploadPixelDataToTexture(gl, texture, pixels) {
    webgl_util.callAndCheck(gl, function () { return gl.bindTexture(gl.TEXTURE_2D, texture); });
    webgl_util.callAndCheck(gl, function () { return gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, pixels); });
    webgl_util.callAndCheck(gl, function () { return gl.bindTexture(gl.TEXTURE_2D, null); });
}
exports.uploadPixelDataToTexture = uploadPixelDataToTexture;
function uploadDataToTexture(gl, texture, width, height, data, numChannels) {
    var textureFormat = getTextureFormat(gl, numChannels);
    webgl_util.validateTextureSize(gl, width, height);
    webgl_util.callAndCheck(gl, function () { return gl.bindTexture(gl.TEXTURE_2D, texture); });
    webgl_util.callAndCheck(gl, function () { return gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, width, height, textureFormat, getTextureType(gl), data); });
    webgl_util.callAndCheck(gl, function () { return gl.bindTexture(gl.TEXTURE_2D, null); });
}
function uploadMatrixToTexture(gl, texture, rows, columns, matrix, numChannels) {
    var _a = tex_util.getUnpackedMatrixTextureShapeWidthHeight(rows, columns), w = _a[0], h = _a[1];
    var unpackedArray;
    if (environment_1.ENV.get('WEBGL_FLOAT_TEXTURE_ENABLED')) {
        var channelsPerTexture = numChannels === 1 ? webgl_util.getChannelsPerTexture() : numChannels;
        if (channelsPerTexture === 1) {
            unpackedArray = matrix;
        }
        else {
            unpackedArray =
                new Float32Array(tex_util.getUnpackedArraySizeFromMatrixSize(matrix.length, channelsPerTexture));
            tex_util.encodeMatrixToUnpackedArray(matrix, unpackedArray, channelsPerTexture);
        }
    }
    else {
        unpackedArray = tex_util.encodeFloatArray(matrix);
    }
    uploadDataToTexture(gl, texture, w, h, unpackedArray, numChannels);
}
exports.uploadMatrixToTexture = uploadMatrixToTexture;
function uploadMatrixToPackedTexture(gl, texture, rows, columns, matrix) {
    var _a = tex_util.getPackedMatrixTextureShapeWidthHeight(rows, columns), w = _a[0], h = _a[1];
    var packedRGBA = new Float32Array(tex_util.getPackedRGBAArraySizeFromMatrixShape(rows, columns));
    tex_util.encodeMatrixToPackedRGBA(matrix, rows, columns, packedRGBA);
    var numChannels = 4;
    uploadDataToTexture(gl, texture, w, h, packedRGBA, numChannels);
}
exports.uploadMatrixToPackedTexture = uploadMatrixToPackedTexture;
function getDownloadTargetArrayBuffer(rows, columns, channelsPerTexture) {
    var isFloatTexture = environment_1.ENV.get('WEBGL_FLOAT_TEXTURE_ENABLED');
    var downloadTarget;
    if (isFloatTexture) {
        downloadTarget =
            new Float32Array(tex_util.getUnpackedArraySizeFromMatrixSize(rows * columns, channelsPerTexture));
    }
    else {
        downloadTarget = new Uint8Array(rows * columns * channelsPerTexture);
    }
    return downloadTarget;
}
function decodeDownloadTargetArrayBuffer(downloadTarget, rows, columns, channelsPerPixel) {
    var isFloatTexture = environment_1.ENV.get('WEBGL_FLOAT_TEXTURE_ENABLED');
    if (isFloatTexture) {
        var matrix = new Float32Array(rows * columns);
        tex_util.decodeMatrixFromUnpackedArray(downloadTarget, matrix, channelsPerPixel);
        return matrix;
    }
    else {
        return tex_util.decodeToFloatArray(downloadTarget);
    }
}
function downloadMatrixFromOutputTextureAsync(gl, getBufferSubDataAsyncExtension, rows, columns) {
    return __awaiter(this, void 0, void 0, function () {
        var gl2, channelsPerPixel, downloadTarget, bufferSizeBytes, buffer;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    gl2 = gl;
                    channelsPerPixel = 4;
                    downloadTarget = getDownloadTargetArrayBuffer(rows, columns, channelsPerPixel);
                    bufferSizeBytes = downloadTarget instanceof Float32Array ?
                        downloadTarget.length * 4 :
                        downloadTarget;
                    buffer = gl.createBuffer();
                    webgl_util.callAndCheck(gl, function () { return gl.bindBuffer(gl2.PIXEL_PACK_BUFFER, buffer); });
                    webgl_util.callAndCheck(gl, function () { return gl.bufferData(gl2.PIXEL_PACK_BUFFER, bufferSizeBytes, gl.STATIC_DRAW); });
                    webgl_util.callAndCheck(gl, function () {
                        return gl2.readPixels(0, 0, columns, rows, gl.RGBA, getTextureType(gl), 0);
                    });
                    return [4, getBufferSubDataAsyncExtension.getBufferSubDataAsync(gl2.PIXEL_PACK_BUFFER, 0, downloadTarget)];
                case 1:
                    _a.sent();
                    return [2, decodeDownloadTargetArrayBuffer(downloadTarget, rows, columns, channelsPerPixel)];
            }
        });
    });
}
exports.downloadMatrixFromOutputTextureAsync = downloadMatrixFromOutputTextureAsync;
function downloadMatrixFromOutputTexture(gl, rows, columns) {
    var _a = tex_util.getUnpackedMatrixTextureShapeWidthHeight(rows, columns), w = _a[0], h = _a[1];
    var channelsPerPixel = 4;
    var downloadTarget = getDownloadTargetArrayBuffer(rows, columns, channelsPerPixel);
    webgl_util.callAndCheck(gl, function () { return gl.readPixels(0, 0, w, h, gl.RGBA, getTextureType(gl), downloadTarget); });
    return decodeDownloadTargetArrayBuffer(downloadTarget, rows, columns, channelsPerPixel);
}
exports.downloadMatrixFromOutputTexture = downloadMatrixFromOutputTexture;
function downloadMatrixFromRGBAColorTexture(gl, rows, columns, channels) {
    var size = rows * columns * 4;
    var downloadTarget = new Uint8Array(size);
    webgl_util.callAndCheck(gl, function () { return gl.readPixels(0, 0, columns, rows, gl.RGBA, gl.UNSIGNED_BYTE, downloadTarget); });
    var packedRGBA = new Float32Array(size);
    for (var i = 0; i < downloadTarget.length; i++) {
        packedRGBA[i] = downloadTarget[i];
    }
    var matrix = new Float32Array(rows * columns * channels);
    tex_util.decodeMatrixFromUnpackedColorRGBAArray(packedRGBA, matrix, channels);
    return matrix;
}
exports.downloadMatrixFromRGBAColorTexture = downloadMatrixFromRGBAColorTexture;
function downloadMatrixFromPackedOutputTexture(gl, rows, columns) {
    var _a = tex_util.getPackedMatrixTextureShapeWidthHeight(rows, columns), w = _a[0], h = _a[1];
    var packedRGBA = new Float32Array(tex_util.getPackedRGBAArraySizeFromMatrixShape(rows, columns));
    webgl_util.callAndCheck(gl, function () { return gl.readPixels(0, 0, w, h, gl.RGBA, getTextureType(gl), packedRGBA); });
    var matrix = new Float32Array(rows * columns);
    return tex_util.decodeMatrixFromPackedRGBA(packedRGBA, rows, columns, matrix);
}
exports.downloadMatrixFromPackedOutputTexture = downloadMatrixFromPackedOutputTexture;

},{"../../environment":7,"./tex_util":81,"./webgl_util":86}],71:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var MaxPool2DBackpropProgram = (function () {
    function MaxPool2DBackpropProgram(convInfo) {
        this.variableNames = ['dy', 'maxPos'];
        this.outputShape = convInfo.inShape;
        var dyRows = convInfo.outShape[0];
        var dyCols = convInfo.outShape[1];
        var filterHeight = convInfo.filterHeight;
        var filterWidth = convInfo.filterWidth;
        var strideHeight = convInfo.strideHeight;
        var strideWidth = convInfo.strideWidth;
        var padTop = filterHeight - 1 - convInfo.padInfo.top;
        var padLeft = filterWidth - 1 - convInfo.padInfo.left;
        var lastIndex = filterHeight * filterWidth - 1;
        this.userCode = "\n      const ivec2 pads = ivec2(" + padTop + ", " + padLeft + ");\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int d = coords.z;\n\n        ivec2 dyRCCorner = coords.xy - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < " + filterHeight + "; wR++) {\n          float dyR = float(dyRCorner + wR) / " + strideHeight + ".0;\n\n          if (dyR < 0.0 || dyR >= " + dyRows + ".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < " + filterWidth + "; wC++) {\n            float dyC = float(dyCCorner + wC) / " + strideWidth + ".0;\n\n            if (dyC < 0.0 || dyC >= " + dyCols + ".0 || fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(idyR, idyC, d);\n            int maxPosValue = " + lastIndex + " - int(getMaxPos(idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * " + filterWidth + " + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
    }
    return MaxPool2DBackpropProgram;
}());
exports.MaxPool2DBackpropProgram = MaxPool2DBackpropProgram;

},{}],72:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var math_1 = require("../math");
var MatMulProgram = (function () {
    function MatMulProgram(aShape, bShape, aOrient, bOrient) {
        if (aOrient === void 0) { aOrient = math_1.MatrixOrientation.REGULAR; }
        if (bOrient === void 0) { bOrient = math_1.MatrixOrientation.REGULAR; }
        this.variableNames = ['matrixA', 'matrixB'];
        var outerShapeA = (aOrient === math_1.MatrixOrientation.REGULAR) ? aShape[0] : aShape[1];
        var outerShapeB = (bOrient === math_1.MatrixOrientation.REGULAR) ? bShape[1] : bShape[0];
        this.outputShape = [outerShapeA, outerShapeB];
        var sharedDim = (aOrient === math_1.MatrixOrientation.REGULAR ? aShape[1] : aShape[0]);
        var aSnippetFromOffset = function (vec4Offset, indexVar) {
            return (aOrient === math_1.MatrixOrientation.REGULAR) ?
                "aRow, " + indexVar + " + " + vec4Offset :
                indexVar + " + " + vec4Offset + ", aRow";
        };
        var bSnippetFromOffset = function (vec4Offset, indexVar) {
            return (bOrient === math_1.MatrixOrientation.REGULAR) ?
                indexVar + " + " + vec4Offset + ", bCol" :
                "bCol, " + indexVar + " + " + vec4Offset;
        };
        var sharedDimNearestVec4 = Math.floor(sharedDim / 4) * 4;
        var sharedDimVec4Remainder = sharedDim % 4;
        this.userCode = " float dotARowBCol(int aRow, int bCol) {\n      float result = 0.0;\n      for (int i = 0; i < " + sharedDimNearestVec4 + "; i += 4) {\n        vec4 a = vec4(\n          getMatrixA(" + aSnippetFromOffset(0, 'i') + "),\n          getMatrixA(" + aSnippetFromOffset(1, 'i') + "),\n          getMatrixA(" + aSnippetFromOffset(2, 'i') + "),\n          getMatrixA(" + aSnippetFromOffset(3, 'i') + ")\n        );\n        vec4 b = vec4(\n          getMatrixB(" + bSnippetFromOffset(0, 'i') + "),\n          getMatrixB(" + bSnippetFromOffset(1, 'i') + "),\n          getMatrixB(" + bSnippetFromOffset(2, 'i') + "),\n          getMatrixB(" + bSnippetFromOffset(3, 'i') + ")\n        );\n\n        result += dot(a, b);\n      }\n\n      if (" + (sharedDimVec4Remainder === 1) + ") {\n        result += getMatrixA(" + aSnippetFromOffset(0, sharedDimNearestVec4) + ") *\n          getMatrixB(" + bSnippetFromOffset(0, sharedDimNearestVec4) + ");\n      } else if (" + (sharedDimVec4Remainder === 2) + ") {\n        vec2 a = vec2(\n          getMatrixA(" + aSnippetFromOffset(0, sharedDimNearestVec4) + "),\n          getMatrixA(" + aSnippetFromOffset(1, sharedDimNearestVec4) + ")\n        );\n        vec2 b = vec2(\n          getMatrixB(" + bSnippetFromOffset(0, sharedDimNearestVec4) + "),\n          getMatrixB(" + bSnippetFromOffset(1, sharedDimNearestVec4) + ")\n        );\n        result += dot(a, b);\n      } else if (" + (sharedDimVec4Remainder === 3) + ") {\n        vec3 a = vec3(\n          getMatrixA(" + aSnippetFromOffset(0, sharedDimNearestVec4) + "),\n          getMatrixA(" + aSnippetFromOffset(1, sharedDimNearestVec4) + "),\n          getMatrixA(" + aSnippetFromOffset(2, sharedDimNearestVec4) + ")\n        );\n        vec3 b = vec3(\n          getMatrixB(" + bSnippetFromOffset(0, sharedDimNearestVec4) + "),\n          getMatrixB(" + bSnippetFromOffset(1, sharedDimNearestVec4) + "),\n          getMatrixB(" + bSnippetFromOffset(2, sharedDimNearestVec4) + ")\n        );\n        result += dot(a, b);\n      }\n\n      return result;\n    }\n\n    void main() {\n      ivec2 resRC = getOutputCoords();\n      setOutput(dotARowBCol(resRC.x, resRC.y));\n    }\n    ";
    }
    return MatMulProgram;
}());
exports.MatMulProgram = MatMulProgram;

},{"../math":52}],73:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var MultinomialProgram = (function () {
    function MultinomialProgram(batchSize, numOutcomes, numSamples) {
        this.variableNames = ['probs'];
        this.outputShape = [batchSize, numSamples];
        this.userCode = "\n      uniform float seed;\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < " + (numOutcomes - 1) + "; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(" + (numOutcomes - 1) + "));\n      }\n    ";
    }
    MultinomialProgram.prototype.getCustomSetupFunc = function (seed) {
        var _this = this;
        return function (gpgpu, webGLProgram) {
            if (_this.seedLoc == null) {
                _this.seedLoc = gpgpu.getUniformLocation(webGLProgram, 'seed');
            }
            gpgpu.gl.uniform1f(_this.seedLoc, seed);
        };
    };
    return MultinomialProgram;
}());
exports.MultinomialProgram = MultinomialProgram;

},{}],74:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var OneHotProgram = (function () {
    function OneHotProgram(numIndices, depth, onValue, offValue) {
        this.variableNames = ['indices'];
        this.outputShape = [numIndices, depth];
        this.userCode = "\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(" + offValue + "), float(" + onValue + "),\n                      float(index == coords.y)));\n      }\n    ";
    }
    OneHotProgram.prototype.getCustomSetupFunc = function (seed) {
        var _this = this;
        return function (gpgpu, webGLProgram) {
            if (_this.seedLoc == null) {
                _this.seedLoc = gpgpu.getUniformLocation(webGLProgram, 'seed');
            }
            gpgpu.gl.uniform1f(_this.seedLoc, seed);
        };
    };
    return OneHotProgram;
}());
exports.OneHotProgram = OneHotProgram;

},{}],75:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Pool2DProgram = (function () {
    function Pool2DProgram(convInfo, poolType, computePositions) {
        this.variableNames = ['x'];
        if (poolType === 'avg' && computePositions) {
            throw new Error('Cannot compute positions for average pool.');
        }
        var filterHeight = convInfo.filterHeight;
        var filterWidth = convInfo.filterWidth;
        var strideHeight = convInfo.strideHeight;
        var strideWidth = convInfo.strideWidth;
        var xNumRows = convInfo.inShape[0];
        var xNumCols = convInfo.inShape[1];
        var padTop = convInfo.padInfo.top;
        var padLeft = convInfo.padInfo.left;
        this.outputShape = convInfo.outShape;
        var isAvgPool = poolType === 'avg';
        var initializationValue = '0.0';
        if (!isAvgPool) {
            if (poolType === 'min') {
                initializationValue = '1.0 / 0.0';
            }
            else {
                initializationValue = '-1.0 / 0.0';
            }
        }
        if (computePositions) {
            var compareOp_1 = poolType === 'min' ? '<=' : '>=';
            this.userCode = "\n        const ivec2 strides = ivec2(" + strideHeight + ", " + strideWidth + ");\n        const ivec2 pads = ivec2(" + padTop + ", " + padLeft + ");\n\n        void main() {\n          ivec3 coords = getOutputCoords();\n          int d = coords.z;\n\n          ivec2 xRCCorner = coords.xy * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < " + filterHeight + "; wR++) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= " + xNumRows + ") {\n              continue;\n            }\n\n            for (int wC = 0; wC < " + filterWidth + "; wC++) {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= " + xNumCols + ") {\n                continue;\n              }\n\n              float value = getX(xR, xC, d);\n\n              if (isNaN(value)) {\n                setOutput(value);\n                return;\n              }\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value " + compareOp_1 + " currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = wR * " + filterWidth + " + wC;\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      ";
            return;
        }
        var compareOp = poolType === 'min' ? 'min' : 'max';
        var returnValue = poolType + "(" + poolType + "(" + poolType + "(" +
            'minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])';
        if (poolType === 'avg') {
            returnValue = "avgValue / " + filterHeight * filterWidth + ".0";
        }
        var filterWidthNearestVec4 = Math.floor(filterWidth / 4) * 4;
        var filterWidthVec4Remainder = filterWidth % 4;
        var updateSnippet = "\n      if (hasNaN(values)) {\n        setOutput(getNaN(values));\n        return;\n      }\n      if (" + isAvgPool + ") {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = " + compareOp + "(values, minMaxValue);\n      }\n    ";
        this.userCode = "\n      const ivec2 strides = ivec2(" + strideHeight + ", " + strideWidth + ");\n      const ivec2 pads = ivec2(" + padTop + ", " + padLeft + ");\n      const float initializationValue = " + initializationValue + ";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int xR, int xC, int d) {\n        if (xC < 0 || xC >= " + xNumCols + ") {\n          return initializationValue;\n        }\n        return getX(xR, xC, d);\n      }\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int d = coords.z;\n\n        ivec2 xRCCorner = coords.xy * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(" + initializationValue + ");\n        float avgValue = 0.0;\n\n        for (int wR = 0; wR < " + filterHeight + "; wR++) {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= " + xNumRows + ") {\n            continue;\n          }\n\n          for (int wC = 0; wC < " + filterWidthNearestVec4 + "; wC += 4) {\n            int xC = xCCorner + wC;\n\n            vec4 values = vec4(\n              getValue(xR, xC, d),\n              getValue(xR, xC + 1, d),\n              getValue(xR, xC + 2, d),\n              getValue(xR, xC + 3, d)\n            );\n\n            " + updateSnippet + "\n          }\n\n          int xC = xCCorner + " + filterWidthNearestVec4 + ";\n          if (" + (filterWidthVec4Remainder === 1) + ") {\n            vec4 values = vec4(\n              getValue(xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n            " + updateSnippet + "\n          } else if (" + (filterWidthVec4Remainder === 2) + ") {\n            vec4 values = vec4(\n              getValue(xR, xC, d),\n              getValue(xR, xC + 1, d),\n              initializationValue,\n              initializationValue\n            );\n\n            " + updateSnippet + "\n          } else if (" + (filterWidthVec4Remainder === 3) + ") {\n            vec4 values = vec4(\n              getValue(xR, xC, d),\n              getValue(xR, xC + 1, d),\n              getValue(xR, xC + 2, d),\n              initializationValue\n            );\n\n            " + updateSnippet + "\n          }\n        }\n        setOutput(" + returnValue + ");\n      }\n    ";
    }
    return Pool2DProgram;
}());
exports.Pool2DProgram = Pool2DProgram;

},{}],76:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ReduceProgram = (function () {
    function ReduceProgram(reduceInfo, reduceType) {
        this.variableNames = ['x'];
        var windowSize = reduceInfo.windowSize;
        var batchSize = reduceInfo.batchSize;
        var inSize = reduceInfo.inSize;
        var outSize = Math.ceil(inSize / windowSize);
        this.outputShape = [batchSize, outSize];
        var isReduceSum = reduceType === 'sum';
        var initializationValue = '0.0';
        if (!isReduceSum) {
            if (reduceType === 'min') {
                initializationValue = '1.0 / 0.0';
            }
            else {
                initializationValue = '-1.0 / 0.0';
            }
        }
        var compareOp = reduceType === 'min' ? 'min' : 'max';
        var returnValue = reduceType + "(" + reduceType + "(" + reduceType + "(" +
            'minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])';
        if (reduceType === 'sum') {
            returnValue = "sumValue";
        }
        var windowSizeNearestVec4 = Math.floor(windowSize / 4) * 4;
        var windowSizeVec4Remainder = windowSize % 4;
        var updateSnippet = "\n      if (" + isReduceSum + ") {\n        sumValue += dot(values, ones);\n      } else {\n        if (hasNaN(values)) {\n          setOutput(getNaN(values));\n          return;\n        }\n        minMaxValue = " + compareOp + "(values, minMaxValue);\n      }\n    ";
        var checkOutOfBounds = '';
        if (inSize % windowSize > 0) {
            checkOutOfBounds = "\n        if (inIdx < 0 || inIdx >= " + inSize + ") {\n          return initializationValue;\n        }\n      ";
        }
        this.userCode = "\n      const float initializationValue = " + initializationValue + ";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        " + checkOutOfBounds + "\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * " + windowSize + ";\n\n        vec4 minMaxValue = vec4(" + initializationValue + ");\n        float sumValue = 0.0;\n\n        for (int i = 0; i < " + windowSizeNearestVec4 + "; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          " + updateSnippet + "\n        }\n\n        int inIdx = inOffset + " + windowSizeNearestVec4 + ";\n        if (" + (windowSizeVec4Remainder === 1) + ") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n          " + updateSnippet + "\n        } else if (" + (windowSizeVec4Remainder === 2) + ") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n          " + updateSnippet + "\n        } else if (" + (windowSizeVec4Remainder === 3) + ") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n          " + updateSnippet + "\n        }\n        setOutput(" + returnValue + ");\n      }\n    ";
    }
    return ReduceProgram;
}());
exports.ReduceProgram = ReduceProgram;

},{}],77:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var webgl_util = require("./webgl_util");
function getRenderRGBShader(gpgpu, destinationWidth) {
    var fragmentShaderSource = "\n    precision highp float;\n    uniform sampler2D source;\n    varying vec2 resultUV;\n\n    const float destinationWidth = " + destinationWidth + ".0;\n    const float a = 1.0;\n\n    void main() {\n      float xr = floor(resultUV.s * destinationWidth) * 3.0;\n      vec3 x = xr + vec3(0, 1, 2);\n\n      float sourceWidth = destinationWidth * 3.0;\n      vec3 u = (x + 0.5) / sourceWidth;\n      float v = 1.0 - resultUV.t;\n\n      float r = texture2D(source, vec2(u[0], v)).r;\n      float g = texture2D(source, vec2(u[1], v)).r;\n      float b = texture2D(source, vec2(u[2], v)).r;\n\n      gl_FragColor = vec4(r, g, b, a);\n    }";
    return gpgpu.createProgram(fragmentShaderSource);
}
exports.getRenderRGBShader = getRenderRGBShader;
function renderToCanvas(gpgpu, renderShader, sourceTex) {
    webgl_util.bindCanvasToFramebuffer(gpgpu.gl);
    renderToFramebuffer(gpgpu, renderShader, sourceTex);
}
exports.renderToCanvas = renderToCanvas;
function renderToFramebuffer(gpgpu, renderShader, sourceTex) {
    gpgpu.setProgram(renderShader);
    var sourceSamplerLocation = webgl_util.getProgramUniformLocationOrThrow(gpgpu.gl, renderShader, 'source');
    gpgpu.setInputMatrixTexture(sourceTex, sourceSamplerLocation, 0);
    gpgpu.executeProgram();
}
exports.renderToFramebuffer = renderToFramebuffer;

},{"./webgl_util":86}],78:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ResizeBilinear3DProgram = (function () {
    function ResizeBilinear3DProgram(inputShape, outputDimensionsRowCol, alignCorners) {
        this.variableNames = ['A'];
        this.outputShape = [];
        var depth = inputShape[2];
        this.outputShape =
            [outputDimensionsRowCol[0], outputDimensionsRowCol[1], depth];
        var effectiveInputShape = alignCorners ?
            [inputShape[0] - 1, inputShape[1] - 1, depth] :
            inputShape;
        var effectiveOutputShape = alignCorners ?
            [this.outputShape[0] - 1, this.outputShape[1] - 1, depth] :
            this.outputShape;
        this.userCode = "\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          " + effectiveInputShape[0] / effectiveOutputShape[0] + ",\n          " + effectiveInputShape[1] / effectiveOutputShape[1] + ");\n      const vec2 inputShapeRC = vec2(" + inputShape[0] + ".0, " + inputShape[1] + ".0);\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        ivec2 yRC = coords.xy;\n        int d = coords.z;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = vec2(yRC) * effectiveInputOverOutputRatioRC;\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(sourceFracIndexRC);\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    ";
    }
    return ResizeBilinear3DProgram;
}());
exports.ResizeBilinear3DProgram = ResizeBilinear3DProgram;

},{}],79:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var environment_1 = require("../../environment");
var util = require("../../util");
var broadcast_util = require("../broadcast_util");
var tex_util = require("./tex_util");
var tex_util_1 = require("./tex_util");
function makeShader(inputsInfo, outputShape, userCode, broadcast) {
    var sampleSnippet = getSampleSnippet();
    var setOutputSnippet = getSetOutputSnippet();
    var inputPrefixSnippet = inputsInfo.map(function (x) { return "uniform sampler2D " + x.name + ";"; }).join('\n');
    var inputSamplingSnippet = inputsInfo.map(function (x) { return getInputSamplingSnippet(x, outputShape, broadcast); })
        .join('\n');
    var outTexShape = outputShape.texShape;
    var outputSamplingSnippet = getOutputSamplingSnippet(outputShape.logicalShape, outTexShape);
    var source = [
        SHADER_PREFIX, sampleSnippet, setOutputSnippet, inputPrefixSnippet,
        outputSamplingSnippet, inputSamplingSnippet, userCode
    ].join('\n');
    return source;
}
exports.makeShader = makeShader;
function getSampleSnippet() {
    return environment_1.ENV.get('WEBGL_FLOAT_TEXTURE_ENABLED') ?
        FLOAT_TEXTURE_SAMPLE_SNIPPET :
        UNSIGNED_BYTE_TEXTURE_SAMPLE_SNIPPET;
}
function getSetOutputSnippet() {
    return environment_1.ENV.get('WEBGL_FLOAT_TEXTURE_ENABLED') ?
        FLOAT_TEXTURE_SETOUTPUT_SNIPPET :
        UNSIGNED_BYTE_TEXTURE_SETOUTPUT_SNIPPET;
}
function getSamplerFromInInfo(inInfo) {
    var shape = inInfo.shapeInfo.logicalShape;
    switch (shape.length) {
        case 0:
            return getSamplerScalar(inInfo);
        case 1:
            return getSampler1D(inInfo);
        case 2:
            return getSampler2D(inInfo);
        case 3:
            return getSampler3D(inInfo);
        case 4:
            return getSampler4D(inInfo);
        default:
            throw new Error(shape.length + "-D input sampling" +
                " is not yet supported");
    }
}
function getInputSamplingSnippet(inInfo, outShapeInfo, broadcast) {
    var res = getSamplerFlat(inInfo);
    res += getSamplerFromInInfo(inInfo);
    if (broadcast ||
        util.arraysEqual(inInfo.shapeInfo.logicalShape, outShapeInfo.logicalShape)) {
        res += getSamplerAtOutputCoords(inInfo, outShapeInfo, broadcast);
    }
    return res;
}
function getOutputSamplingSnippet(outShape, outTexShape) {
    switch (outShape.length) {
        case 0:
            return getOutputScalarCoords();
        case 1:
            return getOutput1DCoords(outShape, outTexShape);
        case 2:
            return getOutput2DCoords(outShape, outTexShape);
        case 3:
            return getOutput3DCoords(outShape, outTexShape);
        case 4:
            return getOutput4DCoords(outShape, outTexShape);
        default:
            throw new Error(outShape.length + "-D output sampling is not yet supported");
    }
}
var SAMPLE_1D_SNIPPET = "\nvec2 UVfrom1D(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n";
var SAMPLE_2D_SNIPPET = "\nvec2 UVfrom2D(int texNumR, int texNumC, int numC, int row, int col) {\n  int index = row * numC + col;\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n";
var SAMPLE_3D_SNIPPET = "\nvec2 UVfrom3D(int texNumR, int texNumC, int stride0,\n    int stride1, int row, int col, int depth) {\n  // Explicitly use integer operations as dot() only works on floats.\n  int index = row * stride0 + col * stride1 + depth;\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n";
var SAMPLE_4D_SNIPPET = "\nvec2 UVfrom4D(int texNumR, int texNumC, int stride0,\n    int stride1, int stride2, int row, int col, int depth,\n    int depth2) {\n  // Explicitly use integer operations as dot() only works on floats.\n  int index = row * stride0 + col * stride1 + depth * stride2 + depth2;\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n";
var UNSIGNED_BYTE_TEXTURE_SAMPLE_SNIPPET = "\n  uniform float NaN;\n\n  const vec4 floatDeltas = vec4(\n      1.0,\n      1.0 / 255.0,\n      1.0 / (255.0 * 255.0),\n      1.0 / (255.0 * 255.0 * 255.0)\n  );\n  const float minValue = " + tex_util.FLOAT_MIN + ".0;\n  const float maxValue = " + tex_util.FLOAT_MAX + ".0;\n  const float range = (maxValue - minValue) / 255.0;\n  const vec2 dotRange = vec2(1.0, range);\n\n  float sample(sampler2D texture, vec2 uv) {\n    vec4 sampleValue = texture2D(texture, uv);\n    if (all(equal(sampleValue, vec4(" + tex_util.BYTE_NAN_VALUE + ")))) {\n      return NaN;\n    }\n\n    vec4 encValue = floor(sampleValue * 255.0 + 0.5);\n    float decodedValue = dot(encValue, floatDeltas);\n    return dot(vec2(minValue, decodedValue), dotRange);\n  }\n";
var UNSIGNED_BYTE_TEXTURE_SETOUTPUT_SNIPPET = "\n  const vec4 floatPowers = vec4(\n    1.0,\n    255.0,\n    255.0 * 255.0,\n    255.0 * 255.0 * 255.0\n  );\n  const vec2 recipRange = vec2(1.0/range);\n  const vec2 recipRange255 = vec2(1.0/(maxValue - minValue));\n\n  void setOutput(float decodedValue) {\n    if (isNaN(decodedValue)) {\n      gl_FragColor = vec4(" + tex_util.BYTE_NAN_VALUE + ");\n      return;\n    }\n\n    float a = dot(vec2(decodedValue, -minValue), recipRange);\n    float b = fract(a) * 255.0;\n    float c = fract(b) * 255.0;\n    float d = fract(c) * 255.0;\n    gl_FragColor = floor(vec4(a, b, c, d)) / 255.0;\n\n    // TODO(dsmilkov): Version above gets better accuracy but probably slower\n    // than the version below. Benchmark to determine if the accuracy is worth\n    // the cost.\n\n    // float normValue = dot(vec2(decodedValue, -minValue), recipRange255);\n    // vec4 f = normValue * floatPowers;\n    // gl_FragColor = floor(fract(f) * 255.0) / 255.0;\n  }\n";
var FLOAT_TEXTURE_SAMPLE_SNIPPET = "\n  float sample(sampler2D texture, vec2 uv) {\n    return texture2D(texture, uv).r;\n  }\n";
var FLOAT_TEXTURE_SETOUTPUT_SNIPPET = "\n  void setOutput(float val) {\n    gl_FragColor = vec4(val, 0, 0, 0);\n  }\n";
var SHADER_PREFIX = "\n  precision highp float;\n  precision highp int;\n  varying vec2 resultUV;\n  const vec2 halfCR = vec2(0.5, 0.5);\n\n  bool isNaN(float val) {\n    return val == val ? false : true;\n  }\n\n  bool hasNaN(vec4 values) {\n    return any(notEqual(values, values));\n  }\n\n  float getNaN(vec4 values) {\n    return dot(vec4(1), values);\n  }\n\n  int round(float value) {\n    return int(floor(value + 0.5));\n  }\n\n  int imod(int x, int y) {\n    return x - y * (x / y);\n  }\n\n  const vec2 randomConst = vec2(\n    23.14069263277926, // e^pi (Gelfond's constant)\n     2.665144142690225 // 2^sqrt(2) (Gelfond\u2013Schneider constant)\n  );\n\n  float random(float seed) {\n      return fract(cos(dot(resultUV * seed, randomConst)) * 12345.6789);\n  }\n\n  float sampleUVAndDepth(sampler2D texture, vec2 uv, int depth) {\n    float value;\n    if (depth == 0) {\n      value = texture2D(texture, uv).r;\n    } else if (depth == 1) {\n      value = texture2D(texture, uv).g;\n    } else if (depth == 2) {\n      value = texture2D(texture, uv).b;\n    } else if (depth == 3) {\n      value = texture2D(texture, uv).a;\n    }\n    return floor(value * 255.0 + 0.5);\n  }\n\n  " + SAMPLE_1D_SNIPPET + "\n  " + SAMPLE_2D_SNIPPET + "\n  " + SAMPLE_3D_SNIPPET + "\n  " + SAMPLE_4D_SNIPPET + "\n";
function getOutputScalarCoords() {
    return "\n    int getOutputCoords() {\n      return 0;\n    }\n  ";
}
function getOutput1DCoords(shape, texShape) {
    if (texShape[0] === 1) {
        return "\n      int getOutputCoords() {\n        return int(resultUV.x * " + texShape[1] + ".0);\n      }\n    ";
    }
    if (texShape[1] === 1) {
        return "\n      int getOutputCoords() {\n        return int(resultUV.y * " + texShape[0] + ".0);\n      }\n    ";
    }
    return "\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" + texShape[0] + ", " + texShape[1] + "));\n      return resTexRC.x * " + texShape[1] + " + resTexRC.y;\n    }\n  ";
}
function getOutput3DCoords(shape, texShape) {
    var stride0 = shape[1] * shape[2];
    var stride1 = shape[2];
    return "\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" + texShape[0] + ", " + texShape[1] + "));\n      int index = resTexRC.x * " + texShape[1] + " + resTexRC.y;\n      int r = index / " + stride0 + ";\n      index -= r * " + stride0 + ";\n      int c = index / " + stride1 + ";\n      int d = index - c * " + stride1 + ";\n      return ivec3(r, c, d);\n    }\n  ";
}
function getOutput4DCoords(shape, texShape) {
    var stride2 = shape[3];
    var stride1 = shape[2] * stride2;
    var stride0 = shape[1] * stride1;
    return "\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(" + texShape[0] + ", " + texShape[1] + "));\n      int index = resTexRC.x * " + texShape[1] + " + resTexRC.y;\n\n      int r = index / " + stride0 + ";\n      index -= r * " + stride0 + ";\n\n      int c = index / " + stride1 + ";\n      index -= c * " + stride1 + ";\n\n      int d = index / " + stride2 + ";\n      int d2 = index - d * " + stride2 + ";\n\n      return ivec4(r, c, d, d2);\n    }\n  ";
}
function getOutput2DCoords(shape, texShape) {
    if (util.arraysEqual(shape, texShape)) {
        return "\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(" + texShape[0] + ", " + texShape[1] + "));\n      }\n    ";
    }
    if (shape[1] === 1) {
        return "\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(" + texShape[0] + ", " + texShape[1] + "));\n        int index = resTexRC.x * " + texShape[1] + " + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    ";
    }
    if (shape[0] === 1) {
        return "\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(" + texShape[0] + ", " + texShape[1] + "));\n        int index = resTexRC.x * " + texShape[1] + " + resTexRC.y;\n        return ivec2(0, index);\n      }\n    ";
    }
    return "\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" + texShape[0] + ", " + texShape[1] + "));\n      int index = resTexRC.x * " + texShape[1] + " + resTexRC.y;\n      int r = index / " + shape[1] + ";\n      int c = index - r * " + shape[1] + ";\n      return ivec2(r, c);\n    }\n  ";
}
function getSamplerScalar(inputInfo) {
    var texName = inputInfo.name;
    var funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);
    return "\n    float " + funcName + "() {\n      return sample(" + texName + ", halfCR);\n    }\n  ";
}
function getSampler1D(inputInfo) {
    var texName = inputInfo.name;
    var funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);
    return "\n    float " + funcName + "(int index) {\n      return " + funcName + "Flat(index);\n    }\n  ";
}
function getSampler2D(inputInfo) {
    var shape = inputInfo.shapeInfo.logicalShape;
    var texShape = inputInfo.shapeInfo.texShape;
    var texName = inputInfo.name;
    var funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);
    var texNumR = texShape[0];
    var texNumC = texShape[1];
    if (util.arraysEqual(shape, texShape)) {
        return "\n    float " + funcName + "(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(" + texNumC + ".0, " + texNumR + ".0);\n      return sample(" + texName + ", uv);\n    }\n  ";
    }
    var _a = util.squeezeShape(shape), newShape = _a.newShape, keptDims = _a.keptDims;
    var squeezedShape = newShape;
    if (squeezedShape.length < shape.length) {
        var newInputInfo = squeezeInputInfo(inputInfo, squeezedShape);
        var params = ['row', 'col'];
        return "\n      " + getSamplerFromInInfo(newInputInfo) + "\n      float " + funcName + "(int row, int col) {\n        return " + funcName + "(" + getSqueezedParams(params, keptDims) + ");\n      }\n    ";
    }
    if (texNumC === 1) {
        return "\n    float " + funcName + "(int row, int col) {\n      int index = row * " + shape[1] + " + col;\n      vec2 uv = vec2(0.5, (float(index) + 0.5) / " + texNumR + ".0);\n      return sample(" + texName + ", uv);\n    }\n  ";
    }
    if (texNumR === 1) {
        return "\n    float " + funcName + "(int row, int col) {\n      int index = row * " + shape[1] + " + col;\n      vec2 uv = vec2((float(index) + 0.5) / " + texNumC + ".0, 0.5);\n      return sample(" + texName + ", uv);\n    }\n  ";
    }
    return "\n  float " + funcName + "(int row, int col) {\n    vec2 uv = UVfrom2D(" + texNumR + ", " + texNumC + ", " + shape[1] + ", row, col);\n    return sample(" + texName + ", uv);\n  }\n";
}
function getSampler3D(inputInfo) {
    var texShape = inputInfo.shapeInfo.texShape;
    var shape = inputInfo.shapeInfo.logicalShape;
    var texName = inputInfo.name;
    var funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);
    var texNumR = texShape[0];
    var texNumC = texShape[1];
    var stride0 = shape[1] * shape[2];
    var stride1 = shape[2];
    var texType = inputInfo.shapeInfo.textureType;
    if (texType === tex_util_1.TextureType.DEFAULT) {
        var _a = util.squeezeShape(shape), newShape = _a.newShape, keptDims = _a.keptDims;
        var squeezedShape = newShape;
        if (squeezedShape.length < shape.length) {
            var newInputInfo = squeezeInputInfo(inputInfo, squeezedShape);
            var params = ['row', 'col', 'depth'];
            return "\n        " + getSamplerFromInInfo(newInputInfo) + "\n        float " + funcName + "(int row, int col, int depth) {\n          return " + funcName + "(" + getSqueezedParams(params, keptDims) + ");\n        }\n      ";
        }
    }
    if (texNumC === stride0) {
        if (texType === tex_util_1.TextureType.DEFAULT) {
            return "\n        float " + funcName + "(int row, int col, int depth) {\n          int texR = row;\n          int texC = col * " + stride1 + " + depth;\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(" + texNumC + ".0, " + texNumR + ".0);\n          return sample(" + texName + ", uv);\n        }\n      ";
        }
        else if (texType === tex_util_1.TextureType.RGBA_COLOR) {
            return "\n        float " + funcName + "(int row, int col, int depth) {\n          vec2 uv = (vec2(col, row) + halfCR) /\n                     vec2(" + texNumC + ".0, " + texNumR + ".0);\n          return sampleUVAndDepth(" + texName + ", uv, depth);\n        }\n      ";
        }
        else {
            throw new Error("Unknown TextureType " + texType + ".");
        }
    }
    if (texNumC === stride1 && texType === tex_util_1.TextureType.DEFAULT) {
        return "\n    float " + funcName + "(int row, int col, int depth) {\n      int texR = row * " + shape[1] + " + col;\n      int texC = depth;\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(" + texNumC + ".0, " + texNumR + ".0);\n      return sample(" + texName + ", uv);\n    }\n  ";
    }
    if (texType === tex_util_1.TextureType.DEFAULT) {
        return "\n      float " + funcName + "(int row, int col, int depth) {\n        vec2 uv = UVfrom3D(\n            " + texNumR + ", " + texNumC + ", " + stride0 + ", " + stride1 + ", row, col, depth);\n        return sample(" + texName + ", uv);\n      }\n  ";
    }
    else if (texType === tex_util_1.TextureType.RGBA_COLOR) {
        return "\n      float " + funcName + "(int row, int col, int depth) {\n        vec2 uv = UVfrom2D(" + texNumR + ", " + texNumC + ", " + shape[1] + ", row, col);\n        return sampleUVAndDepth(" + texName + ", uv, depth);\n      }\n    ";
    }
    else {
        throw new Error("Unknown TextureType " + texType + ".");
    }
}
function getSampler4D(inputInfo) {
    var shape = inputInfo.shapeInfo.logicalShape;
    var texShape = inputInfo.shapeInfo.texShape;
    var texName = inputInfo.name;
    var funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);
    var texNumR = texShape[0];
    var texNumC = texShape[1];
    var stride2 = shape[3];
    var stride1 = shape[2] * stride2;
    var stride0 = shape[1] * stride1;
    var _a = util.squeezeShape(shape), newShape = _a.newShape, keptDims = _a.keptDims;
    if (newShape.length < shape.length) {
        var newInputInfo = squeezeInputInfo(inputInfo, newShape);
        var params = ['row', 'col', 'depth', 'depth2'];
        return "\n      " + getSamplerFromInInfo(newInputInfo) + "\n      float " + funcName + "(int row, int col, int depth, int depth2) {\n        return " + funcName + "(" + getSqueezedParams(params, keptDims) + ");\n      }\n    ";
    }
    if (texNumC === stride0) {
        return "\n      float " + funcName + "(int row, int col, int depth, int depth2) {\n        int texR = row;\n        int texC = col * " + stride1 + " + depth * " + stride2 + " + depth2;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(" + texNumC + ".0, " + texNumR + ".0);\n        return sample(" + texName + ", uv);\n      }\n    ";
    }
    if (texNumC === stride2) {
        return "\n      float " + funcName + "(int row, int col, int depth, int depth2) {\n        int texR = row * " + shape[1] * shape[2] + " + col * " + shape[2] + " + depth;\n        int texC = depth2;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(" + texNumC + ".0, " + texNumR + ".0);\n        return sample(" + texName + ", uv);\n      }\n    ";
    }
    return "\n    float " + funcName + "(int row, int col, int depth, int depth2) {\n      vec2 uv = UVfrom4D(" + texNumR + ", " + texNumC + ", " + stride0 + ", " + stride1 + ",\n          " + stride2 + ", row, col, depth, depth2);\n      return sample(" + texName + ", uv);\n    }\n  ";
}
function getSamplerFlat(inputInfo) {
    var texName = inputInfo.name;
    var texShape = inputInfo.shapeInfo.texShape;
    var funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1) + 'Flat';
    var tNumR = texShape[0];
    var tNumC = texShape[1];
    if (tNumC === 1 && tNumR === 1) {
        return "\n      float " + funcName + "(int index) {\n        return sample(" + texName + ", halfCR);\n      }\n    ";
    }
    if (tNumC === 1) {
        return "\n      float " + funcName + "(int index) {\n        vec2 uv = vec2(0.5, (float(index) + 0.5) / " + tNumR + ".0);\n        return sample(" + texName + ", uv);\n      }\n    ";
    }
    if (tNumR === 1) {
        return "\n      float " + funcName + "(int index) {\n        vec2 uv = vec2((float(index) + 0.5) / " + tNumC + ".0, 0.5);\n        return sample(" + texName + ", uv);\n      }\n    ";
    }
    return "\n    float " + funcName + "(int index) {\n      vec2 uv = UVfrom1D(" + tNumR + ", " + tNumC + ", index);\n      return sample(" + texName + ", uv);\n    }\n  ";
}
function getBroadcastOutputCoordsSampler(inputInfo, outShapeInfo, texFuncSnippet, funcName) {
    var inRank = inputInfo.shapeInfo.logicalShape.length;
    var outRank = outShapeInfo.logicalShape.length;
    var type = 'int';
    if (outRank === 2) {
        type = 'ivec2';
    }
    else if (outRank === 3) {
        type = 'ivec3';
    }
    else if (outRank === 4) {
        type = 'ivec4';
    }
    var broadcastDims = broadcast_util.getBroadcastDims(inputInfo.shapeInfo.logicalShape, outShapeInfo.logicalShape);
    var rankDiff = outRank - inRank;
    var coordsSnippet;
    if (inRank === 0) {
        coordsSnippet = '';
    }
    else if (outRank < 2 && broadcastDims.length >= 1) {
        coordsSnippet = 'coords = 0;';
    }
    else {
        coordsSnippet =
            broadcastDims.map(function (d) { return "coords[" + (d + rankDiff) + "] = 0;"; }).join('\n');
    }
    var unpackedCoordsSnippet = '';
    if (outRank < 2 && inRank > 0) {
        unpackedCoordsSnippet = 'coords';
    }
    else {
        unpackedCoordsSnippet = inputInfo.shapeInfo.logicalShape
            .map(function (s, i) { return "coords[" + (i + rankDiff) + "]"; })
            .join(', ');
    }
    return "\n    float " + funcName + "() {\n      " + type + " coords = getOutputCoords();\n      " + coordsSnippet + "\n      return get" + texFuncSnippet + "(" + unpackedCoordsSnippet + ");\n    }\n  ";
}
function getSamplerAtOutputCoords(inputInfo, outShapeInfo, supportsBroadcasting) {
    var inTexShape = inputInfo.shapeInfo.texShape;
    var texName = inputInfo.name;
    var isRGBAColorTexture = inputInfo.shapeInfo.textureType === tex_util_1.TextureType.RGBA_COLOR;
    var texFuncSnippet = texName.charAt(0).toUpperCase() + texName.slice(1);
    var funcName = 'get' + texFuncSnippet + 'AtOutCoords';
    var broadcastDims = broadcast_util.getBroadcastDims(inputInfo.shapeInfo.logicalShape, outShapeInfo.logicalShape);
    var inRank = inputInfo.shapeInfo.logicalShape.length;
    var outRank = outShapeInfo.logicalShape.length;
    var doBroadcast = supportsBroadcasting && ((outRank > inRank) || broadcastDims.length > 0);
    var broadcastOverOuter = broadcast_util.broadcastDimsAreOuter(broadcastDims);
    if (doBroadcast && !broadcastOverOuter) {
        return getBroadcastOutputCoordsSampler(inputInfo, outShapeInfo, texFuncSnippet, funcName);
    }
    var outTexShape = outShapeInfo.texShape;
    if (util.arraysEqual(inTexShape, outTexShape) && !isRGBAColorTexture) {
        return "\n      float " + funcName + "() {\n        return sample(" + texName + ", resultUV);\n      }\n    ";
    }
    var inTexExpandedShape = isRGBAColorTexture ?
        [inTexShape[0], inTexShape[1] * inputInfo.shapeInfo.logicalShape[2]] :
        inTexShape;
    var sampleSnippet = "return sample(" + texName + ", uv);";
    var rgbaColorSnippet = '';
    if (isRGBAColorTexture) {
        rgbaColorSnippet = "\n      int col = texC / " + inputInfo.shapeInfo.logicalShape[2] + ";\n      int texD = texC - col * " + inputInfo.shapeInfo.logicalShape[2] + ";\n      texC = col;\n    ";
        sampleSnippet = "return sampleUVAndDepth(" + texName + ", uv, texD);";
    }
    var inSize = util.sizeFromShape(inTexExpandedShape);
    var broadcastSnippet = '';
    if (doBroadcast && broadcastOverOuter) {
        broadcastSnippet = "\n        int mainPart = index / " + inSize + ";\n        index -= mainPart * " + inSize + ";\n      ";
    }
    return "\n    float " + funcName + "() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" + outTexShape[0] + ", " + outTexShape[1] + "));\n      int index = resTexRC.x * " + outTexShape[1] + " + resTexRC.y;\n      " + broadcastSnippet + "\n      int texR = index / " + inTexExpandedShape[1] + ";\n      int texC = index - texR * " + inTexExpandedShape[1] + ";\n\n      " + rgbaColorSnippet + "\n\n      vec2 uv = (vec2(texC, texR) + halfCR) /\n                 vec2(" + inTexShape[1] + ".0, " + inTexShape[0] + ".0);\n\n      " + sampleSnippet + "\n    }\n  ";
}
function getCoordsDataType(rank) {
    if (rank === 1) {
        return 'int';
    }
    else if (rank === 2) {
        return 'ivec2';
    }
    else if (rank === 3) {
        return 'ivec3';
    }
    else if (rank === 4) {
        return 'ivec4';
    }
    else {
        throw Error("GPU for rank " + rank + " is not yet supported");
    }
}
exports.getCoordsDataType = getCoordsDataType;
function squeezeInputInfo(inInfo, squeezedShape) {
    var newInputInfo = JSON.parse(JSON.stringify(inInfo));
    newInputInfo.shapeInfo.logicalShape = squeezedShape;
    return newInputInfo;
}
function getSqueezedParams(params, keptDims) {
    return keptDims.map(function (d) { return params[d]; }).join(', ');
}

},{"../../environment":7,"../../util":88,"../broadcast_util":47,"./tex_util":81}],80:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var shader_compiler_1 = require("./shader_compiler");
var SliceProgram = (function () {
    function SliceProgram(destSize) {
        this.variableNames = ['source'];
        this.outputShape = destSize;
        this.rank = destSize.length;
        var dtype = shader_compiler_1.getCoordsDataType(this.rank);
        var sourceCoords = getCoords(this.rank);
        this.userCode = "\n      uniform " + dtype + " start;\n\n      void main() {\n        " + dtype + " sourceLoc = start + getOutputCoords();\n        setOutput(getSource(" + sourceCoords + "));\n      }\n    ";
    }
    SliceProgram.prototype.getCustomSetupFunc = function (start) {
        var _this = this;
        if (start.length !== this.rank) {
            throw Error("The rank (" + this.rank + ") of the program must match the " +
                ("length of start (" + start.length + ")"));
        }
        return function (gpgpu, webGLProgram) {
            if (_this.startLoc == null) {
                _this.startLoc = gpgpu.getUniformLocationNoThrow(webGLProgram, 'start');
                if (_this.startLoc == null) {
                    return;
                }
            }
            if (_this.rank === 1) {
                gpgpu.gl.uniform1i(_this.startLoc, start[0]);
            }
            else if (_this.rank === 2) {
                gpgpu.gl.uniform2i(_this.startLoc, start[0], start[1]);
            }
            else if (_this.rank === 3) {
                gpgpu.gl.uniform3i(_this.startLoc, start[0], start[1], start[2]);
            }
            else if (_this.rank === 4) {
                gpgpu.gl.uniform4i(_this.startLoc, start[0], start[1], start[2], start[3]);
            }
            else {
                throw Error("Slicing for rank " + _this.rank + " is not yet supported");
            }
        };
    };
    return SliceProgram;
}());
exports.SliceProgram = SliceProgram;
function getCoords(rank) {
    if (rank === 1) {
        return 'sourceLoc';
    }
    else if (rank === 2) {
        return 'sourceLoc.x, sourceLoc.y';
    }
    else if (rank === 3) {
        return 'sourceLoc.x, sourceLoc.y, sourceLoc.z';
    }
    else if (rank === 4) {
        return 'sourceLoc.x, sourceLoc.y, sourceLoc.z, sourceLoc.w';
    }
    else {
        throw Error("Slicing for rank " + rank + " is not yet supported");
    }
}

},{"./shader_compiler":79}],81:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var TextureType;
(function (TextureType) {
    TextureType[TextureType["DEFAULT"] = 0] = "DEFAULT";
    TextureType[TextureType["RGBA_COLOR"] = 1] = "RGBA_COLOR";
})(TextureType = exports.TextureType || (exports.TextureType = {}));
function getUnpackedMatrixTextureShapeWidthHeight(rows, columns) {
    return [columns, rows];
}
exports.getUnpackedMatrixTextureShapeWidthHeight = getUnpackedMatrixTextureShapeWidthHeight;
function getUnpackedArraySizeFromMatrixSize(matrixSize, channelsPerTexture) {
    return matrixSize * channelsPerTexture;
}
exports.getUnpackedArraySizeFromMatrixSize = getUnpackedArraySizeFromMatrixSize;
function getColorMatrixTextureShapeWidthHeight(rows, columns) {
    return [columns * 4, rows];
}
exports.getColorMatrixTextureShapeWidthHeight = getColorMatrixTextureShapeWidthHeight;
function getMatrixSizeFromUnpackedArraySize(unpackedSize, channelsPerTexture) {
    if (unpackedSize % channelsPerTexture !== 0) {
        throw new Error("unpackedSize (" + unpackedSize + ") must be a multiple of " +
            ("" + channelsPerTexture));
    }
    return unpackedSize / channelsPerTexture;
}
exports.getMatrixSizeFromUnpackedArraySize = getMatrixSizeFromUnpackedArraySize;
function encodeMatrixToUnpackedArray(matrix, unpackedArray, channelsPerTexture) {
    var requiredSize = getUnpackedArraySizeFromMatrixSize(matrix.length, channelsPerTexture);
    if (unpackedArray.length < requiredSize) {
        throw new Error("unpackedArray length (" + unpackedArray.length + ") must be >= " +
            ("" + requiredSize));
    }
    var dst = 0;
    for (var src = 0; src < matrix.length; ++src) {
        unpackedArray[dst] = matrix[src];
        dst += channelsPerTexture;
    }
}
exports.encodeMatrixToUnpackedArray = encodeMatrixToUnpackedArray;
exports.FLOAT_MAX = 20000;
exports.FLOAT_MIN = -exports.FLOAT_MAX;
var FLOAT_RANGE = (exports.FLOAT_MAX - exports.FLOAT_MIN) / 255;
var FLOAT_DELTAS = [1, 1 / 255, 1 / (255 * 255), 1 / (255 * 255 * 255)];
var FLOAT_POWERS = [1, 255, 255 * 255];
exports.BYTE_NAN_VALUE = 0;
function encodeFloatArray(floatArray) {
    var uintArray = new Uint8Array(floatArray.length * 4);
    var _loop_1 = function (i) {
        var value = floatArray[i / 4];
        if (isNaN(value)) {
            uintArray[i] = exports.BYTE_NAN_VALUE;
            uintArray[i + 1] = exports.BYTE_NAN_VALUE;
            uintArray[i + 2] = exports.BYTE_NAN_VALUE;
            uintArray[i + 3] = exports.BYTE_NAN_VALUE;
            return "continue";
        }
        var normalizedValue = (value - exports.FLOAT_MIN) / FLOAT_RANGE;
        var enc = FLOAT_POWERS.map(function (pow) { return pow * normalizedValue; });
        var buckets = enc.map(function (value) { return Math.floor((value % 1) * 255); });
        uintArray[i] = Math.floor(normalizedValue);
        uintArray[i + 1] = buckets[0];
        uintArray[i + 2] = buckets[1];
        uintArray[i + 3] = buckets[2];
    };
    for (var i = 0; i < uintArray.length; i += 4) {
        _loop_1(i);
    }
    return uintArray;
}
exports.encodeFloatArray = encodeFloatArray;
function decodeToFloatArray(uintArray) {
    var floatArray = new Float32Array(uintArray.length / 4);
    var _loop_2 = function (i) {
        if (uintArray[i] === exports.BYTE_NAN_VALUE &&
            uintArray[i + 1] === exports.BYTE_NAN_VALUE &&
            uintArray[i + 2] === exports.BYTE_NAN_VALUE &&
            uintArray[i + 3] === exports.BYTE_NAN_VALUE) {
            floatArray[i / 4] = NaN;
            return "continue";
        }
        var dot = 0;
        FLOAT_DELTAS.forEach(function (delta, j) {
            dot += delta * uintArray[i + j];
        });
        var value = dot * FLOAT_RANGE + exports.FLOAT_MIN;
        floatArray[i / 4] = value;
    };
    for (var i = 0; i < uintArray.length; i += 4) {
        _loop_2(i);
    }
    return floatArray;
}
exports.decodeToFloatArray = decodeToFloatArray;
function decodeMatrixFromUnpackedArray(unpackedArray, matrix, channelsPerTexture) {
    var requiredSize = getMatrixSizeFromUnpackedArraySize(unpackedArray.length, channelsPerTexture);
    if (matrix.length < requiredSize) {
        throw new Error("matrix length (" + matrix.length + ") must be >= " + requiredSize);
    }
    var dst = 0;
    for (var src = 0; src < unpackedArray.length; src += channelsPerTexture) {
        matrix[dst++] = unpackedArray[src];
    }
}
exports.decodeMatrixFromUnpackedArray = decodeMatrixFromUnpackedArray;
function decodeMatrixFromUnpackedColorRGBAArray(unpackedArray, matrix, channels) {
    var requiredSize = unpackedArray.length * channels / 4;
    if (matrix.length < requiredSize) {
        throw new Error("matrix length (" + matrix.length + ") must be >= " + requiredSize);
    }
    var dst = 0;
    for (var src = 0; src < unpackedArray.length; src += 4) {
        for (var c = 0; c < channels; c++) {
            matrix[dst++] = unpackedArray[src + c];
        }
    }
}
exports.decodeMatrixFromUnpackedColorRGBAArray = decodeMatrixFromUnpackedColorRGBAArray;
function getPackedMatrixTextureShapeWidthHeight(rows, columns) {
    return [Math.ceil(columns / 2), Math.ceil(rows / 2)];
}
exports.getPackedMatrixTextureShapeWidthHeight = getPackedMatrixTextureShapeWidthHeight;
function getPackedRGBAArraySizeFromMatrixShape(rows, columns) {
    var _a = getPackedMatrixTextureShapeWidthHeight(rows, columns), w = _a[0], h = _a[1];
    return w * h * 4;
}
exports.getPackedRGBAArraySizeFromMatrixShape = getPackedRGBAArraySizeFromMatrixShape;
function encodeMatrixToPackedRGBA(matrix, rows, columns, packedRGBA) {
    var requiredSize = getPackedRGBAArraySizeFromMatrixShape(rows, columns);
    if (packedRGBA.length < requiredSize) {
        throw new Error("packedRGBA length (" + packedRGBA.length + ") must be >= " + requiredSize);
    }
    var _a = getPackedMatrixTextureShapeWidthHeight(rows, columns), textureWidth = _a[0], textureHeight = _a[1];
    var oddWidth = (columns % 2) === 1;
    var oddHeight = (rows % 2) === 1;
    var widthInFullBlocks = Math.floor(columns / 2);
    var heightInFullBlocks = Math.floor(rows / 2);
    {
        var dstStride = (oddWidth ? 4 : 0);
        var oneRow = columns;
        var dst = 0;
        for (var blockY = 0; blockY < heightInFullBlocks; ++blockY) {
            var matrixSrcRow = (blockY * 2 * columns);
            for (var blockX = 0; blockX < widthInFullBlocks; ++blockX) {
                var matrixSrcCol = blockX * 2;
                var src = matrixSrcRow + matrixSrcCol;
                packedRGBA[dst] = matrix[src];
                packedRGBA[dst + 1] = matrix[src + 1];
                packedRGBA[dst + 2] = matrix[src + oneRow];
                packedRGBA[dst + 3] = matrix[src + oneRow + 1];
                dst += 4;
            }
            dst += dstStride;
        }
    }
    if (oddWidth) {
        var src = columns - 1;
        var dst = (textureWidth - 1) * 4;
        var srcStride = 2 * columns;
        var dstStride = textureWidth * 4;
        for (var blockY = 0; blockY < heightInFullBlocks; ++blockY) {
            packedRGBA[dst] = matrix[src];
            packedRGBA[dst + 2] = matrix[src + columns];
            src += srcStride;
            dst += dstStride;
        }
    }
    if (oddHeight) {
        var src = (rows - 1) * columns;
        var dst = (textureHeight - 1) * textureWidth * 4;
        for (var blockX = 0; blockX < widthInFullBlocks; ++blockX) {
            packedRGBA[dst++] = matrix[src++];
            packedRGBA[dst++] = matrix[src++];
            dst += 2;
        }
    }
    if (oddWidth && oddHeight) {
        packedRGBA[packedRGBA.length - 4] = matrix[matrix.length - 1];
    }
    return packedRGBA;
}
exports.encodeMatrixToPackedRGBA = encodeMatrixToPackedRGBA;
function decodeMatrixFromPackedRGBA(packedRGBA, rows, columns, matrix) {
    var requiredSize = rows * columns;
    if (requiredSize < matrix.length) {
        throw new Error("matrix length (" + matrix.length + ") must be >= " + requiredSize);
    }
    var oddWidth = (columns % 2) === 1;
    var oddHeight = (rows % 2) === 1;
    var widthInFullBlocks = Math.floor(columns / 2);
    var heightInFullBlocks = Math.floor(rows / 2);
    var _a = getPackedMatrixTextureShapeWidthHeight(rows, columns), textureWidth = _a[0], textureHeight = _a[1];
    {
        var srcStride = oddWidth ? 4 : 0;
        var dstStride = columns + (oddWidth ? 1 : 0);
        var src = 0;
        var dstRow1 = 0;
        var dstRow2 = columns;
        for (var blockY = 0; blockY < heightInFullBlocks; ++blockY) {
            for (var blockX = 0; blockX < widthInFullBlocks; ++blockX) {
                matrix[dstRow1++] = packedRGBA[src++];
                matrix[dstRow1++] = packedRGBA[src++];
                matrix[dstRow2++] = packedRGBA[src++];
                matrix[dstRow2++] = packedRGBA[src++];
            }
            src += srcStride;
            dstRow1 += dstStride;
            dstRow2 += dstStride;
        }
    }
    if (oddWidth) {
        var src = (textureWidth - 1) * 4;
        var dst = columns - 1;
        var srcStride = textureWidth * 4;
        var dstStride = 2 * columns;
        for (var blockY = 0; blockY < heightInFullBlocks; ++blockY) {
            matrix[dst] = packedRGBA[src];
            matrix[dst + columns] = packedRGBA[src + 2];
            src += srcStride;
            dst += dstStride;
        }
    }
    if (oddHeight) {
        var src = (textureHeight - 1) * textureWidth * 4;
        var dst = (rows - 1) * columns;
        for (var blockX = 0; blockX < widthInFullBlocks; ++blockX) {
            matrix[dst++] = packedRGBA[src++];
            matrix[dst++] = packedRGBA[src++];
            src += 2;
        }
    }
    if (oddWidth && oddHeight) {
        matrix[matrix.length - 1] = packedRGBA[packedRGBA.length - 4];
    }
    return matrix;
}
exports.decodeMatrixFromPackedRGBA = decodeMatrixFromPackedRGBA;

},{}],82:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var TextureManager = (function () {
    function TextureManager(gpgpu) {
        this.gpgpu = gpgpu;
        this.numUsedTextures = 0;
        this.numFreeTextures = 0;
        this.freeTextures = {};
        this.logEnabled = false;
        this.usedTextureCount = {};
    }
    TextureManager.prototype.acquireTexture = function (shapeRC) {
        var shapeKey = getKeyFromTextureShape(shapeRC);
        if (!(shapeKey in this.freeTextures)) {
            this.freeTextures[shapeKey] = [];
        }
        if (!(shapeKey in this.usedTextureCount)) {
            this.usedTextureCount[shapeKey] = 0;
        }
        this.usedTextureCount[shapeKey]++;
        if (this.freeTextures[shapeKey].length > 0) {
            this.numFreeTextures--;
            this.numUsedTextures++;
            this.log();
            return this.freeTextures[shapeKey].shift();
        }
        this.numUsedTextures++;
        this.log();
        return this.gpgpu.createMatrixTexture(shapeRC[0], shapeRC[1]);
    };
    TextureManager.prototype.releaseTexture = function (texture, shape) {
        var shapeKey = getKeyFromTextureShape(shape);
        if (!(shapeKey in this.freeTextures)) {
            this.freeTextures[shapeKey] = [];
        }
        this.freeTextures[shapeKey].push(texture);
        this.numFreeTextures++;
        this.numUsedTextures--;
        this.usedTextureCount[shapeKey]--;
        this.log();
    };
    TextureManager.prototype.log = function () {
        if (!this.logEnabled) {
            return;
        }
        var total = this.numFreeTextures + this.numUsedTextures;
        console.log('Free/Used', this.numFreeTextures + " / " + this.numUsedTextures, "(" + total + ")");
    };
    TextureManager.prototype.getNumUsedTextures = function () {
        return this.numUsedTextures;
    };
    TextureManager.prototype.getNumFreeTextures = function () {
        return this.numFreeTextures;
    };
    TextureManager.prototype.dispose = function () {
        for (var shape in this.freeTextures) {
            if (this.freeTextures.hasOwnProperty(shape)) {
                for (var i = 0; i < this.freeTextures[shape].length; i++) {
                    this.gpgpu.deleteMatrixTexture(this.freeTextures[shape][i]);
                }
            }
        }
    };
    return TextureManager;
}());
exports.TextureManager = TextureManager;
function getKeyFromTextureShape(shapeRowsCol) {
    return shapeRowsCol[0] + "_" + shapeRowsCol[1];
}

},{}],83:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var shader_compiler_1 = require("./shader_compiler");
var TileProgram = (function () {
    function TileProgram(aShape, reps) {
        this.variableNames = ['A'];
        var outputShape = new Array(aShape.length);
        for (var i = 0; i < outputShape.length; i++) {
            outputShape[i] = aShape[i] * reps[i];
        }
        this.outputShape = outputShape;
        this.rank = outputShape.length;
        var dtype = shader_compiler_1.getCoordsDataType(this.rank);
        var sourceCoords = getSourceCoords(aShape);
        this.userCode = "\n      void main() {\n        " + dtype + " resRC = getOutputCoords();\n        setOutput(getA(" + sourceCoords + "));\n      }\n    ";
    }
    return TileProgram;
}());
exports.TileProgram = TileProgram;
function getSourceCoords(aShape) {
    var rank = aShape.length;
    if (rank > 4) {
        throw Error("Tile for rank " + rank + " is not yet supported");
    }
    if (rank === 1) {
        return "imod(resRC, " + aShape[0] + ")";
    }
    var currentCoords = ['resRC.x', 'resRC.y', 'resRC.z', 'resRC.w'];
    var sourceCoords = [];
    for (var i = 0; i < aShape.length; i++) {
        sourceCoords.push("imod(" + currentCoords[i] + ", " + aShape[i] + ")");
    }
    return sourceCoords.join();
}

},{"./shader_compiler":79}],84:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var shader_compiler_1 = require("./shader_compiler");
var TransposeProgram = (function () {
    function TransposeProgram(aShape, newDim) {
        this.variableNames = ['A'];
        var outputShape = new Array(aShape.length);
        for (var i = 0; i < outputShape.length; i++) {
            outputShape[i] = aShape[newDim[i]];
        }
        this.outputShape = outputShape;
        this.rank = outputShape.length;
        var dtype = shader_compiler_1.getCoordsDataType(this.rank);
        var switched = getSwitchedCoords(newDim);
        this.userCode = "\n    void main() {\n      " + dtype + " resRC = getOutputCoords();\n      setOutput(getA(" + switched + "));\n    }\n    ";
    }
    return TransposeProgram;
}());
exports.TransposeProgram = TransposeProgram;
function getSwitchedCoords(newDim) {
    var rank = newDim.length;
    if (rank > 4) {
        throw Error("Transpose for rank " + rank + " is not yet supported");
    }
    var originalOrder = ['resRC.x', 'resRC.y', 'resRC.z', 'resRC.w'];
    var switchedCoords = new Array(rank);
    for (var i = 0; i < newDim.length; i++) {
        switchedCoords[newDim[i]] = originalOrder[i];
    }
    return switchedCoords.join();
}

},{"./shader_compiler":79}],85:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var UnaryOpProgram = (function () {
    function UnaryOpProgram(aShape, opSnippet) {
        this.variableNames = ['A'];
        this.outputShape = aShape;
        this.userCode = "\n      float unaryOperation(float x) {\n        " + opSnippet + "\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    ";
    }
    return UnaryOpProgram;
}());
exports.UnaryOpProgram = UnaryOpProgram;
exports.CHECK_NAN_SNIPPET = "\n  if (isNaN(x)) {\n    return x;\n  }\n";
exports.ABS = "\n  return abs(x);\n";
exports.RELU = "\n  return (x < 0.0) ? 0.0 : x;\n";
exports.ELU = "\n  return (x >= 0.0) ? x : (exp(x) - 1.0);\n";
function LEAKY_RELU(alpha) {
    return "\n    return (x >= 0.0) ? x : " + alpha + " * x;\n  ";
}
exports.LEAKY_RELU = LEAKY_RELU;
function STEP(alpha) {
    if (alpha === void 0) { alpha = 0.0; }
    return "\n    return (x == x) ? (x > 0.0 ? 1.0 : float(" + alpha + ")) : x;\n  ";
}
exports.STEP = STEP;
exports.NEG = "\n  return -x;\n";
exports.CEIL = "\n  return ceil(x);\n";
exports.FLOOR = "\n  return floor(x);\n";
exports.EXP = "\n  return exp(x);\n";
exports.LOG = "\n  return log(x);\n";
exports.SQRT = exports.CHECK_NAN_SNIPPET + "\n  return sqrt(x);\n";
exports.SIGMOID = "\n  return 1.0 / (1.0 + exp(-1.0 * x));\n";
exports.SIN = exports.CHECK_NAN_SNIPPET + "\n  return sin(x);\n";
exports.COS = exports.CHECK_NAN_SNIPPET + "\n  return cos(x);\n";
exports.TAN = "\n  return tan(x);\n";
exports.ASIN = exports.CHECK_NAN_SNIPPET + "\n  return asin(x);\n";
exports.ACOS = exports.CHECK_NAN_SNIPPET + "\n  return acos(x);\n";
exports.ATAN = exports.CHECK_NAN_SNIPPET + "\n  return atan(x);\n";
exports.SINH = "\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n";
exports.COSH = "\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n";
exports.TANH = "\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n";
exports.SQUARE = "\n  return x * x;\n";

},{}],86:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var MAX_TEXTURE_SIZE = null;
var util = require("../../util");
var environment_1 = require("../../environment");
function createWebGLRenderingContext(attributes) {
    var canvas = document.createElement('canvas');
    canvas.width = 1;
    canvas.height = 1;
    return createWebGLRenderingContextFromCanvas(canvas, attributes);
}
exports.createWebGLRenderingContext = createWebGLRenderingContext;
function createWebGLRenderingContextFromCanvas(canvas, attributes) {
    var gl;
    var webglVersion = environment_1.ENV.get('WEBGL_VERSION');
    if (webglVersion === 2) {
        gl = canvas.getContext('webgl2', attributes);
    }
    else if (webglVersion === 1) {
        gl = (canvas.getContext('webgl', attributes) ||
            canvas.getContext('experimental-webgl', attributes));
    }
    if (webglVersion === 0 || gl == null) {
        throw new Error('This browser does not support WebGL.');
    }
    return gl;
}
exports.createWebGLRenderingContextFromCanvas = createWebGLRenderingContextFromCanvas;
function callAndCheck(gl, func) {
    var returnValue = func();
    checkWebGLError(gl);
    return returnValue;
}
exports.callAndCheck = callAndCheck;
var webGLDebugErrorCheckingEnabled = false;
function enableDebugWebGLErrorChecking(enabled) {
    webGLDebugErrorCheckingEnabled = enabled;
}
exports.enableDebugWebGLErrorChecking = enableDebugWebGLErrorChecking;
function checkWebGLError(gl) {
    if (webGLDebugErrorCheckingEnabled) {
        var error = gl.getError();
        if (error !== gl.NO_ERROR) {
            throw new Error('WebGL Error: ' + getWebGLErrorMessage(gl, error));
        }
    }
}
exports.checkWebGLError = checkWebGLError;
function getWebGLErrorMessage(gl, status) {
    switch (status) {
        case gl.NO_ERROR:
            return 'NO_ERROR';
        case gl.INVALID_ENUM:
            return 'INVALID_ENUM';
        case gl.INVALID_VALUE:
            return 'INVALID_VALUE';
        case gl.INVALID_OPERATION:
            return 'INVALID_OPERATION';
        case gl.INVALID_FRAMEBUFFER_OPERATION:
            return 'INVALID_FRAMEBUFFER_OPERATION';
        case gl.OUT_OF_MEMORY:
            return 'OUT_OF_MEMORY';
        case gl.CONTEXT_LOST_WEBGL:
            return 'CONTEXT_LOST_WEBGL';
        default:
            return "Unknown error code " + status;
    }
}
exports.getWebGLErrorMessage = getWebGLErrorMessage;
function getExtensionOrThrow(gl, extensionName) {
    return throwIfNull(gl, function () { return gl.getExtension(extensionName); }, 'Extension "' + extensionName + '" not supported on this browser.');
}
exports.getExtensionOrThrow = getExtensionOrThrow;
function createVertexShader(gl, vertexShaderSource) {
    var vertexShader = throwIfNull(gl, function () { return gl.createShader(gl.VERTEX_SHADER); }, 'Unable to create vertex WebGLShader.');
    callAndCheck(gl, function () { return gl.shaderSource(vertexShader, vertexShaderSource); });
    callAndCheck(gl, function () { return gl.compileShader(vertexShader); });
    if (gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS) === false) {
        console.log(gl.getShaderInfoLog(vertexShader));
        throw new Error('Failed to compile vertex shader.');
    }
    return vertexShader;
}
exports.createVertexShader = createVertexShader;
function createFragmentShader(gl, fragmentShaderSource) {
    var fragmentShader = throwIfNull(gl, function () { return gl.createShader(gl.FRAGMENT_SHADER); }, 'Unable to create fragment WebGLShader.');
    callAndCheck(gl, function () { return gl.shaderSource(fragmentShader, fragmentShaderSource); });
    callAndCheck(gl, function () { return gl.compileShader(fragmentShader); });
    if (gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS) === false) {
        logShaderSourceAndInfoLog(fragmentShaderSource, gl.getShaderInfoLog(fragmentShader));
        throw new Error('Failed to compile fragment shader.');
    }
    return fragmentShader;
}
exports.createFragmentShader = createFragmentShader;
var lineNumberRegex = /ERROR: [0-9]+:([0-9]+):/g;
function logShaderSourceAndInfoLog(shaderSource, shaderInfoLog) {
    var lineNumberRegexResult = lineNumberRegex.exec(shaderInfoLog);
    if (lineNumberRegexResult == null) {
        console.log("Couldn't parse line number in error: " + shaderInfoLog);
        console.log(shaderSource);
        return;
    }
    var lineNumber = +lineNumberRegexResult[1];
    var shaderLines = shaderSource.split('\n');
    var pad = shaderLines.length.toString().length + 2;
    var linesWithLineNumbers = shaderLines.map(function (line, lineNumber) {
        return util.rightPad((lineNumber + 1).toString(), pad) + line;
    });
    var maxLineLength = 0;
    for (var i = 0; i < linesWithLineNumbers.length; i++) {
        maxLineLength = Math.max(linesWithLineNumbers[i].length, maxLineLength);
    }
    var beforeErrorLines = linesWithLineNumbers.slice(0, lineNumber - 1);
    var errorLine = linesWithLineNumbers.slice(lineNumber - 1, lineNumber);
    var afterErrorLines = linesWithLineNumbers.slice(lineNumber);
    console.log(beforeErrorLines.join('\n'));
    console.log(shaderInfoLog.split('\n')[0]);
    console.log("%c " + util.rightPad(errorLine[0], maxLineLength), 'border:1px solid red; background-color:#e3d2d2; color:#a61717');
    console.log(afterErrorLines.join('\n'));
}
function createProgram(gl) {
    return throwIfNull(gl, function () { return gl.createProgram(); }, 'Unable to create WebGLProgram.');
}
exports.createProgram = createProgram;
function linkProgram(gl, program) {
    callAndCheck(gl, function () { return gl.linkProgram(program); });
    if (gl.getProgramParameter(program, gl.LINK_STATUS) === false) {
        console.log(gl.getProgramInfoLog(program));
        throw new Error('Failed to link vertex and fragment shaders.');
    }
}
exports.linkProgram = linkProgram;
function validateProgram(gl, program) {
    callAndCheck(gl, function () { return gl.validateProgram(program); });
    if (gl.getProgramParameter(program, gl.VALIDATE_STATUS) === false) {
        console.log(gl.getProgramInfoLog(program));
        throw new Error('Shader program validation failed.');
    }
}
exports.validateProgram = validateProgram;
function createStaticVertexBuffer(gl, data) {
    var buffer = throwIfNull(gl, function () { return gl.createBuffer(); }, 'Unable to create WebGLBuffer');
    callAndCheck(gl, function () { return gl.bindBuffer(gl.ARRAY_BUFFER, buffer); });
    callAndCheck(gl, function () { return gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW); });
    return buffer;
}
exports.createStaticVertexBuffer = createStaticVertexBuffer;
function createStaticIndexBuffer(gl, data) {
    var buffer = throwIfNull(gl, function () { return gl.createBuffer(); }, 'Unable to create WebGLBuffer');
    callAndCheck(gl, function () { return gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer); });
    callAndCheck(gl, function () { return gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, data, gl.STATIC_DRAW); });
    return buffer;
}
exports.createStaticIndexBuffer = createStaticIndexBuffer;
function queryMaxTextureSize(gl) {
    if (MAX_TEXTURE_SIZE != null) {
        return MAX_TEXTURE_SIZE;
    }
    MAX_TEXTURE_SIZE =
        callAndCheck(gl, function () { return gl.getParameter(gl.MAX_TEXTURE_SIZE); });
    return MAX_TEXTURE_SIZE;
}
exports.queryMaxTextureSize = queryMaxTextureSize;
function getChannelsPerTexture() {
    if (!environment_1.ENV.get('WEBGL_FLOAT_TEXTURE_ENABLED')) {
        return 4;
    }
    if (environment_1.ENV.get('WEBGL_VERSION') === 2) {
        return 1;
    }
    return 4;
}
exports.getChannelsPerTexture = getChannelsPerTexture;
function createTexture(gl) {
    return throwIfNull(gl, function () { return gl.createTexture(); }, 'Unable to create WebGLTexture.');
}
exports.createTexture = createTexture;
function validateTextureSize(gl, width, height) {
    var maxTextureSize = queryMaxTextureSize(gl);
    if ((width <= 0) || (height <= 0)) {
        var requested = "[" + width + "x" + height + "]";
        throw new Error('Requested texture size ' + requested + ' is invalid.');
    }
    if ((width > maxTextureSize) || (height > maxTextureSize)) {
        var requested = "[" + width + "x" + height + "]";
        var max = "[" + maxTextureSize + "x" + maxTextureSize + "]";
        throw new Error('Requested texture size ' + requested +
            ' greater than WebGL maximum on this browser / GPU ' + max + '.');
    }
}
exports.validateTextureSize = validateTextureSize;
function createFramebuffer(gl) {
    return throwIfNull(gl, function () { return gl.createFramebuffer(); }, 'Unable to create WebGLFramebuffer.');
}
exports.createFramebuffer = createFramebuffer;
function bindVertexBufferToProgramAttribute(gl, program, attribute, buffer, arrayEntriesPerItem, itemStrideInBytes, itemOffsetInBytes, attribLocations) {
    var loc = -1;
    if ((attribLocations != null) && (attribute in attribLocations)) {
        loc = attribLocations[attribute];
    }
    else {
        loc = gl.getAttribLocation(program, attribute);
    }
    if (loc === -1) {
        return;
    }
    callAndCheck(gl, function () { return gl.bindBuffer(gl.ARRAY_BUFFER, buffer); });
    callAndCheck(gl, function () { return gl.vertexAttribPointer(loc, arrayEntriesPerItem, gl.FLOAT, false, itemStrideInBytes, itemOffsetInBytes); });
    callAndCheck(gl, function () { return gl.enableVertexAttribArray(loc); });
}
exports.bindVertexBufferToProgramAttribute = bindVertexBufferToProgramAttribute;
function bindTextureUnit(gl, texture, textureUnit) {
    validateTextureUnit(gl, textureUnit);
    callAndCheck(gl, function () { return gl.activeTexture(gl.TEXTURE0 + textureUnit); });
    callAndCheck(gl, function () { return gl.bindTexture(gl.TEXTURE_2D, texture); });
}
exports.bindTextureUnit = bindTextureUnit;
function unbindTextureUnit(gl, textureUnit) {
    validateTextureUnit(gl, textureUnit);
    callAndCheck(gl, function () { return gl.activeTexture(gl.TEXTURE0 + textureUnit); });
    callAndCheck(gl, function () { return gl.bindTexture(gl.TEXTURE_2D, null); });
}
exports.unbindTextureUnit = unbindTextureUnit;
function getProgramUniformLocationOrThrow(gl, program, uniformName) {
    return throwIfNull(gl, function () { return gl.getUniformLocation(program, uniformName); }, 'uniform "' + uniformName + '" not present in program.');
}
exports.getProgramUniformLocationOrThrow = getProgramUniformLocationOrThrow;
function bindTextureToProgramUniformSampler(gl, program, texture, uniformSamplerLocation, textureUnit) {
    callAndCheck(gl, function () { return bindTextureUnit(gl, texture, textureUnit); });
    callAndCheck(gl, function () { return gl.uniform1i(uniformSamplerLocation, textureUnit); });
}
exports.bindTextureToProgramUniformSampler = bindTextureToProgramUniformSampler;
function bindCanvasToFramebuffer(gl) {
    callAndCheck(gl, function () { return gl.bindFramebuffer(gl.FRAMEBUFFER, null); });
    callAndCheck(gl, function () { return gl.viewport(0, 0, gl.canvas.width, gl.canvas.height); });
    callAndCheck(gl, function () { return gl.scissor(0, 0, gl.canvas.width, gl.canvas.height); });
}
exports.bindCanvasToFramebuffer = bindCanvasToFramebuffer;
function bindColorTextureToFramebuffer(gl, texture, framebuffer) {
    callAndCheck(gl, function () { return gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer); });
    callAndCheck(gl, function () { return gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0); });
}
exports.bindColorTextureToFramebuffer = bindColorTextureToFramebuffer;
function unbindColorTextureFromFramebuffer(gl, framebuffer) {
    callAndCheck(gl, function () { return gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer); });
    callAndCheck(gl, function () { return gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, null, 0); });
}
exports.unbindColorTextureFromFramebuffer = unbindColorTextureFromFramebuffer;
function validateFramebuffer(gl) {
    var status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
    if (status !== gl.FRAMEBUFFER_COMPLETE) {
        throw new Error('Error binding framebuffer: ' + getFramebufferErrorMessage(gl, status));
    }
}
exports.validateFramebuffer = validateFramebuffer;
function getFramebufferErrorMessage(gl, status) {
    switch (status) {
        case gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
            return 'FRAMEBUFFER_INCOMPLETE_ATTACHMENT';
        case gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
            return 'FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT';
        case gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
            return 'FRAMEBUFFER_INCOMPLETE_DIMENSIONS';
        case gl.FRAMEBUFFER_UNSUPPORTED:
            return 'FRAMEBUFFER_UNSUPPORTED';
        default:
            return "unknown error " + status;
    }
}
exports.getFramebufferErrorMessage = getFramebufferErrorMessage;
function throwIfNull(gl, returnTOrNull, failureMessage) {
    var tOrNull = callAndCheck(gl, function () { return returnTOrNull(); });
    if (tOrNull == null) {
        throw new Error(failureMessage);
    }
    return tOrNull;
}
function validateTextureUnit(gl, textureUnit) {
    var maxTextureUnit = gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS - 1;
    var glTextureUnit = textureUnit + gl.TEXTURE0;
    if (glTextureUnit < gl.TEXTURE0 || glTextureUnit > maxTextureUnit) {
        var textureUnitRange = "[gl.TEXTURE0, gl.TEXTURE" + maxTextureUnit + "]";
        throw new Error("textureUnit must be in " + textureUnitRange + ".");
    }
}
function getTextureShapeFromLogicalShape(gl, logShape) {
    if (logShape.length !== 2) {
        var squeezeResult = util.squeezeShape(logShape);
        logShape = squeezeResult.newShape;
    }
    var maxTexSize = queryMaxTextureSize(gl);
    var size = util.sizeFromShape(logShape);
    if (logShape.length <= 1 && size <= maxTexSize) {
        return [size, 1];
    }
    else if (logShape.length === 2 && logShape[0] <= maxTexSize &&
        logShape[1] <= maxTexSize) {
        return logShape;
    }
    else if (logShape.length === 3 && logShape[0] <= maxTexSize &&
        logShape[1] * logShape[2] <= maxTexSize) {
        return [logShape[0], logShape[1] * logShape[2]];
    }
    else if (logShape.length === 4 && logShape[0] <= maxTexSize &&
        logShape[1] * logShape[2] * logShape[3] <= maxTexSize) {
        return [logShape[0], logShape[1] * logShape[2] * logShape[3]];
    }
    else {
        return util.sizeToSquarishShape(size);
    }
}
exports.getTextureShapeFromLogicalShape = getTextureShapeFromLogicalShape;

},{"../../environment":7,"../../util":88}],87:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var environment = require("./environment");
var environment_1 = require("./environment");
var math_cpu_1 = require("./math/math_cpu");
var math_gpu_1 = require("./math/math_gpu");
var util = require("./util");
exports.TEST_EPSILON = 1e-2;
function mean(values) {
    var sum = 0;
    for (var i = 0; i < values.length; i++) {
        sum += values[i];
    }
    return sum / values.length;
}
exports.mean = mean;
function standardDeviation(values, mean) {
    var squareDiffSum = 0;
    for (var i = 0; i < values.length; i++) {
        var diff = values[i] - mean;
        squareDiffSum += diff * diff;
    }
    return Math.sqrt(squareDiffSum / values.length);
}
exports.standardDeviation = standardDeviation;
function kurtosis(values) {
    var valuesMean = mean(values);
    var n = values.length;
    var sum2 = 0;
    var sum4 = 0;
    for (var i = 0; i < n; i++) {
        var v = values[i] - valuesMean;
        sum2 += Math.pow(v, 2);
        sum4 += Math.pow(v, 4);
    }
    return (1 / n) * sum4 / Math.pow((1 / n) * sum2, 2) - 3;
}
exports.kurtosis = kurtosis;
function skewness(values) {
    var valuesMean = mean(values);
    var n = values.length;
    var sum2 = 0;
    var sum3 = 0;
    var i = -1;
    while (++i < n) {
        var v = values[i] - valuesMean;
        sum2 += Math.pow(v, 2);
        sum3 += Math.pow(v, 3);
    }
    return (1 / n) * sum3 / Math.pow((1 / (n - 1)) * sum2, 3 / 2);
}
exports.skewness = skewness;
function jarqueBeraNormalityTest(values) {
    var s = skewness(values);
    var k = kurtosis(values);
    var jb = values.length * ((Math.pow(s, 2) / 6) + (Math.pow(k, 2) / 24));
    var CHI_SQUARE_2DEG = 5.991;
    if (jb > CHI_SQUARE_2DEG) {
        throw new Error("Invalid p-value for JB: " + jb);
    }
}
exports.jarqueBeraNormalityTest = jarqueBeraNormalityTest;
function expectArrayInMeanStdRange(actual, expectedMean, expectedStdDev, epsilon) {
    if (epsilon === void 0) { epsilon = exports.TEST_EPSILON; }
    var actualMean = mean(actual);
    expectNumbersClose(actualMean, expectedMean, epsilon);
    expectNumbersClose(standardDeviation(actual, actualMean), expectedStdDev, epsilon);
}
exports.expectArrayInMeanStdRange = expectArrayInMeanStdRange;
function expectArraysClose(actual, expected, epsilon) {
    if (epsilon === void 0) { epsilon = exports.TEST_EPSILON; }
    var aType = actual.constructor.name;
    var bType = expected.constructor.name;
    if (aType !== bType) {
        throw new Error("Arrays are of different type " + aType + " vs " + bType);
    }
    if (actual.length !== expected.length) {
        throw new Error("Matrices have different lengths (" + actual.length + " vs " +
            (expected.length + ")."));
    }
    for (var i = 0; i < expected.length; ++i) {
        var a = actual[i];
        var e = expected[i];
        if (!areClose(a, e, epsilon)) {
            var actualStr = "actual[" + i + "] === " + a;
            var expectedStr = "expected[" + i + "] === " + e;
            throw new Error('Arrays differ: ' + actualStr + ', ' + expectedStr);
        }
    }
}
exports.expectArraysClose = expectArraysClose;
function expectNumbersClose(a, e, epsilon) {
    if (epsilon === void 0) { epsilon = exports.TEST_EPSILON; }
    if (!areClose(a, e, epsilon)) {
        throw new Error("Numbers differ: actual === " + a + ", expected === " + e);
    }
}
exports.expectNumbersClose = expectNumbersClose;
function areClose(a, e, epsilon) {
    if (isNaN(a) && isNaN(e)) {
        return true;
    }
    if (isNaN(a) || isNaN(e) || Math.abs(a - e) > epsilon) {
        return false;
    }
    return true;
}
function expectValuesInRange(actual, low, high) {
    for (var i = 0; i < actual.length; i++) {
        if (actual[i] < low || actual[i] > high) {
            throw new Error("Value out of range:" + actual[i] + " low: " + low + ", high: " + high);
        }
    }
}
exports.expectValuesInRange = expectValuesInRange;
function randomArrayInRange(n, minValue, maxValue) {
    var v = new Float32Array(n);
    var range = maxValue - minValue;
    for (var i = 0; i < n; ++i) {
        v[i] = (Math.random() * range) + minValue;
    }
    return v;
}
exports.randomArrayInRange = randomArrayInRange;
function makeIdentity(n) {
    var i = new Float32Array(n * n);
    for (var j = 0; j < n; ++j) {
        i[(j * n) + j] = 1;
    }
    return i;
}
exports.makeIdentity = makeIdentity;
function cpuMultiplyMatrix(a, aRow, aCol, b, bRow, bCol) {
    var result = new Float32Array(aRow * bCol);
    for (var r = 0; r < aRow; ++r) {
        var aOffset = (r * aCol);
        var cOffset = (r * bCol);
        for (var c = 0; c < bCol; ++c) {
            var d = 0;
            for (var k = 0; k < aCol; ++k) {
                d += a[aOffset + k] * b[(k * bCol) + c];
            }
            result[cOffset + c] = d;
        }
    }
    return result;
}
exports.cpuMultiplyMatrix = cpuMultiplyMatrix;
function cpuDotProduct(a, b) {
    if (a.length !== b.length) {
        throw new Error('cpuDotProduct: incompatible vectors.');
    }
    var d = 0;
    for (var i = 0; i < a.length; ++i) {
        d += a[i] * b[i];
    }
    return d;
}
exports.cpuDotProduct = cpuDotProduct;
function describeMathCPU(name, tests, featuresList) {
    var testNameBase = 'math_cpu.' + name;
    describeWithFeaturesAndExecutor(testNameBase, tests, function (testName, tests, features) { return executeMathTests(testName, tests, function () { return new math_cpu_1.NDArrayMathCPU(); }, features); }, featuresList);
}
exports.describeMathCPU = describeMathCPU;
function describeMathGPU(name, tests, featuresList) {
    var testNameBase = 'math_gpu.' + name;
    describeWithFeaturesAndExecutor(testNameBase, tests, function (testName, tests, features) { return executeMathTests(testName, tests, function () { return new math_gpu_1.NDArrayMathGPU(); }, features); }, featuresList);
}
exports.describeMathGPU = describeMathGPU;
function describeCustom(name, tests, featuresList, customBeforeEach, customAfterEach) {
    describeWithFeaturesAndExecutor(name, [tests], function (testName, tests, features) { return executeTests(testName, tests, features, customBeforeEach, customAfterEach); }, featuresList);
}
exports.describeCustom = describeCustom;
function describeWithFeaturesAndExecutor(testNameBase, tests, executor, featuresList) {
    if (featuresList != null) {
        featuresList.forEach(function (features) {
            var testName = testNameBase + ' ' + JSON.stringify(features);
            executor(testName, tests, features);
        });
    }
    else {
        executor(testNameBase, tests);
    }
}
var PROMISE_IT = function (name, testFunc) {
    it(name, function (done) {
        var result = testFunc();
        if (result instanceof Promise) {
            result.then(done, function (e) {
                fail(e);
                done();
            });
        }
        else {
            done();
        }
    });
};
function executeMathTests(testName, tests, mathFactory, features) {
    var math;
    var customBeforeEach = function () {
        math = mathFactory();
        math.startScope();
    };
    var customAfterEach = function () {
        math.endScope(null);
        math.dispose();
    };
    var customIt = function (name, testFunc) {
        PROMISE_IT(name, function () { return testFunc(math); });
    };
    executeTests(testName, tests, features, customBeforeEach, customAfterEach, customIt);
}
exports.executeMathTests = executeMathTests;
function executeTests(testName, tests, features, customBeforeEach, customAfterEach, customIt) {
    if (customIt === void 0) { customIt = PROMISE_IT; }
    describe(testName, function () {
        beforeEach(function () {
            if (features != null) {
                environment.setEnvironment(new environment_1.Environment(features));
            }
            if (customBeforeEach != null) {
                customBeforeEach();
            }
        });
        afterEach(function () {
            if (customAfterEach != null) {
                customAfterEach();
            }
            if (features != null) {
                environment.setEnvironment(new environment_1.Environment());
            }
        });
        tests.forEach(function (test) { return test(customIt); });
    });
}
exports.executeTests = executeTests;
function assertIsNan(val, dtype) {
    if (!util.isValNaN(val, dtype)) {
        throw new Error("Value " + val + " does not represent NaN for dtype " + dtype);
    }
}
exports.assertIsNan = assertIsNan;

},{"./environment":7,"./math/math_cpu":53,"./math/math_gpu":54,"./util":88}],88:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function shuffle(array) {
    var counter = array.length;
    var temp = 0;
    var index = 0;
    while (counter > 0) {
        index = (Math.random() * counter) | 0;
        counter--;
        temp = array[counter];
        array[counter] = array[index];
        array[index] = temp;
    }
}
exports.shuffle = shuffle;
function clamp(min, x, max) {
    return Math.max(min, Math.min(x, max));
}
exports.clamp = clamp;
function randUniform(a, b) {
    return Math.random() * (b - a) + a;
}
exports.randUniform = randUniform;
function randGauss(mean, stdDev, truncated) {
    if (mean === void 0) { mean = 0; }
    if (stdDev === void 0) { stdDev = 1; }
    if (truncated === void 0) { truncated = false; }
    var v1, v2, s;
    do {
        v1 = 2 * Math.random() - 1;
        v2 = 2 * Math.random() - 1;
        s = v1 * v1 + v2 * v2;
    } while (s > 1);
    var result = Math.sqrt(-2 * Math.log(s) / s) * v1;
    if (truncated && Math.abs(result) > 2) {
        return randGauss(mean, stdDev, true);
    }
    return mean + stdDev * result;
}
exports.randGauss = randGauss;
function distSquared(a, b) {
    var result = 0;
    for (var i = 0; i < a.length; i++) {
        var diff = Number(a[i]) - Number(b[i]);
        result += diff * diff;
    }
    return result;
}
exports.distSquared = distSquared;
function assert(expr, msg) {
    if (!expr) {
        throw new Error(msg);
    }
}
exports.assert = assert;
function assertShapesMatch(shapeA, shapeB, errorMessagePrefix) {
    if (errorMessagePrefix === void 0) { errorMessagePrefix = ''; }
    assert(arraysEqual(shapeA, shapeB), errorMessagePrefix + ("Shapes " + shapeA + " and " + shapeB + " must match"));
}
exports.assertShapesMatch = assertShapesMatch;
function flatten(arr, ret) {
    if (ret === void 0) { ret = []; }
    if (Array.isArray(arr)) {
        for (var i = 0; i < arr.length; ++i) {
            flatten(arr[i], ret);
        }
    }
    else {
        ret.push(arr);
    }
    return ret;
}
exports.flatten = flatten;
function inferShape(arr) {
    var shape = [];
    while (arr instanceof Array) {
        shape.push(arr.length);
        arr = arr[0];
    }
    return shape;
}
exports.inferShape = inferShape;
function sizeFromShape(shape) {
    if (shape.length === 0) {
        return 1;
    }
    var size = shape[0];
    for (var i = 1; i < shape.length; i++) {
        size *= shape[i];
    }
    return size;
}
exports.sizeFromShape = sizeFromShape;
function isScalarShape(shape) {
    return shape.length === 0;
}
exports.isScalarShape = isScalarShape;
function arraysEqual(n1, n2) {
    if (n1.length !== n2.length) {
        return false;
    }
    for (var i = 0; i < n1.length; i++) {
        if (n1[i] !== n2[i]) {
            return false;
        }
    }
    return true;
}
exports.arraysEqual = arraysEqual;
function isInt(a) {
    return a % 1 === 0;
}
exports.isInt = isInt;
function tanh(x) {
    if (Math.tanh != null) {
        return Math.tanh(x);
    }
    if (x === Infinity) {
        return 1;
    }
    else if (x === -Infinity) {
        return -1;
    }
    else {
        var e2x = Math.exp(2 * x);
        return (e2x - 1) / (e2x + 1);
    }
}
exports.tanh = tanh;
function sizeToSquarishShape(size) {
    for (var a = Math.floor(Math.sqrt(size)); a > 1; --a) {
        if (size % a === 0) {
            return [a, size / a];
        }
    }
    return [1, size];
}
exports.sizeToSquarishShape = sizeToSquarishShape;
function createShuffledIndices(n) {
    var shuffledIndices = new Uint32Array(n);
    for (var i = 0; i < n; ++i) {
        shuffledIndices[i] = i;
    }
    shuffle(shuffledIndices);
    return shuffledIndices;
}
exports.createShuffledIndices = createShuffledIndices;
function rightPad(a, size) {
    if (size <= a.length) {
        return a;
    }
    return a + ' '.repeat(size - a.length);
}
exports.rightPad = rightPad;
function repeatedTry(checkFn, delayFn, maxCounter) {
    if (delayFn === void 0) { delayFn = function (counter) { return 0; }; }
    return new Promise(function (resolve, reject) {
        var tryCount = 0;
        var tryFn = function () {
            if (checkFn()) {
                resolve();
                return;
            }
            tryCount++;
            var nextBackoff = delayFn(tryCount);
            if (maxCounter != null && tryCount >= maxCounter) {
                reject();
                return;
            }
            setTimeout(tryFn, nextBackoff);
        };
        setTimeout(tryFn, 0);
    });
}
exports.repeatedTry = repeatedTry;
function getQueryParams(queryString) {
    var params = {};
    queryString.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g, function (s) {
        var t = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            t[_i - 1] = arguments[_i];
        }
        decodeParam(params, t[0], t[1]);
        return t.join('=');
    });
    return params;
}
exports.getQueryParams = getQueryParams;
function decodeParam(params, name, value) {
    params[decodeURIComponent(name)] = decodeURIComponent(value || '');
}
function inferFromImplicitShape(shape, size) {
    var shapeProd = 1;
    var implicitIdx = -1;
    for (var i = 0; i < shape.length; ++i) {
        if (shape[i] > 0) {
            shapeProd *= shape[i];
        }
        else if (shape[i] === -1) {
            if (implicitIdx !== -1) {
                throw Error("Shapes can only have 1 implicit size. " +
                    ("Found -1 at dim " + implicitIdx + " and dim " + i));
            }
            implicitIdx = i;
        }
        else if (shape[i] <= 0) {
            throw Error("Shapes can not be <= 0. Found " + shape[i] + " at dim " + i);
        }
    }
    if (implicitIdx === -1) {
        if (size > 0 && size !== shapeProd) {
            throw Error("Size (" + size + ") must match the product of shape " + shape);
        }
        return shape;
    }
    if (size % shapeProd !== 0) {
        throw Error("The implicit shape can't be a fractional number. " +
            ("Got " + size + " / " + shapeProd));
    }
    var newShape = shape.slice();
    newShape[implicitIdx] = size / shapeProd;
    return newShape;
}
exports.inferFromImplicitShape = inferFromImplicitShape;
exports.NAN_INT32 = 1 << 31;
exports.NAN_BOOL = 255;
exports.NAN_FLOAT32 = NaN;
function getNaN(dtype) {
    if (dtype === 'float32') {
        return exports.NAN_FLOAT32;
    }
    else if (dtype === 'int32') {
        return exports.NAN_INT32;
    }
    else if (dtype === 'bool') {
        return exports.NAN_BOOL;
    }
    else {
        throw new Error("Unknown dtype " + dtype);
    }
}
exports.getNaN = getNaN;
function isValNaN(val, dtype) {
    if (dtype === 'float32') {
        return isNaN(val);
    }
    else if (dtype === 'int32') {
        return val === exports.NAN_INT32;
    }
    else if (dtype === 'bool') {
        return val === exports.NAN_BOOL;
    }
    else {
        throw new Error("Unknown dtype " + dtype);
    }
}
exports.isValNaN = isValNaN;
function squeezeShape(shape) {
    var newShape = [];
    var keptDims = [];
    for (var i = 0; i < shape.length; ++i) {
        if (shape[i] > 1) {
            newShape.push(shape[i]);
            keptDims.push(i);
        }
    }
    return { newShape: newShape, keptDims: keptDims };
}
exports.squeezeShape = squeezeShape;

},{}],89:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var version = '0.3.11';
exports.version = version;

},{}],90:[function(require,module,exports){
// A library of seedable RNGs implemented in Javascript.
//
// Usage:
//
// var seedrandom = require('seedrandom');
// var random = seedrandom(1); // or any seed.
// var x = random();       // 0 <= x < 1.  Every bit is random.
// var x = random.quick(); // 0 <= x < 1.  32 bits of randomness.

// alea, a 53-bit multiply-with-carry generator by Johannes Baagøe.
// Period: ~2^116
// Reported to pass all BigCrush tests.
var alea = require('./lib/alea');

// xor128, a pure xor-shift generator by George Marsaglia.
// Period: 2^128-1.
// Reported to fail: MatrixRank and LinearComp.
var xor128 = require('./lib/xor128');

// xorwow, George Marsaglia's 160-bit xor-shift combined plus weyl.
// Period: 2^192-2^32
// Reported to fail: CollisionOver, SimpPoker, and LinearComp.
var xorwow = require('./lib/xorwow');

// xorshift7, by François Panneton and Pierre L'ecuyer, takes
// a different approach: it adds robustness by allowing more shifts
// than Marsaglia's original three.  It is a 7-shift generator
// with 256 bits, that passes BigCrush with no systmatic failures.
// Period 2^256-1.
// No systematic BigCrush failures reported.
var xorshift7 = require('./lib/xorshift7');

// xor4096, by Richard Brent, is a 4096-bit xor-shift with a
// very long period that also adds a Weyl generator. It also passes
// BigCrush with no systematic failures.  Its long period may
// be useful if you have many generators and need to avoid
// collisions.
// Period: 2^4128-2^32.
// No systematic BigCrush failures reported.
var xor4096 = require('./lib/xor4096');

// Tyche-i, by Samuel Neves and Filipe Araujo, is a bit-shifting random
// number generator derived from ChaCha, a modern stream cipher.
// https://eden.dei.uc.pt/~sneves/pubs/2011-snfa2.pdf
// Period: ~2^127
// No systematic BigCrush failures reported.
var tychei = require('./lib/tychei');

// The original ARC4-based prng included in this library.
// Period: ~2^1600
var sr = require('./seedrandom');

sr.alea = alea;
sr.xor128 = xor128;
sr.xorwow = xorwow;
sr.xorshift7 = xorshift7;
sr.xor4096 = xor4096;
sr.tychei = tychei;

module.exports = sr;

},{"./lib/alea":91,"./lib/tychei":92,"./lib/xor128":93,"./lib/xor4096":94,"./lib/xorshift7":95,"./lib/xorwow":96,"./seedrandom":97}],91:[function(require,module,exports){
// A port of an algorithm by Johannes Baagøe <baagoe@baagoe.com>, 2010
// http://baagoe.com/en/RandomMusings/javascript/
// https://github.com/nquinlan/better-random-numbers-for-javascript-mirror
// Original work is under MIT license -

// Copyright (C) 2010 by Johannes Baagøe <baagoe@baagoe.org>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.



(function(global, module, define) {

function Alea(seed) {
  var me = this, mash = Mash();

  me.next = function() {
    var t = 2091639 * me.s0 + me.c * 2.3283064365386963e-10; // 2^-32
    me.s0 = me.s1;
    me.s1 = me.s2;
    return me.s2 = t - (me.c = t | 0);
  };

  // Apply the seeding algorithm from Baagoe.
  me.c = 1;
  me.s0 = mash(' ');
  me.s1 = mash(' ');
  me.s2 = mash(' ');
  me.s0 -= mash(seed);
  if (me.s0 < 0) { me.s0 += 1; }
  me.s1 -= mash(seed);
  if (me.s1 < 0) { me.s1 += 1; }
  me.s2 -= mash(seed);
  if (me.s2 < 0) { me.s2 += 1; }
  mash = null;
}

function copy(f, t) {
  t.c = f.c;
  t.s0 = f.s0;
  t.s1 = f.s1;
  t.s2 = f.s2;
  return t;
}

function impl(seed, opts) {
  var xg = new Alea(seed),
      state = opts && opts.state,
      prng = xg.next;
  prng.int32 = function() { return (xg.next() * 0x100000000) | 0; }
  prng.double = function() {
    return prng() + (prng() * 0x200000 | 0) * 1.1102230246251565e-16; // 2^-53
  };
  prng.quick = prng;
  if (state) {
    if (typeof(state) == 'object') copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

function Mash() {
  var n = 0xefc8249d;

  var mash = function(data) {
    data = data.toString();
    for (var i = 0; i < data.length; i++) {
      n += data.charCodeAt(i);
      var h = 0.02519603282416938 * n;
      n = h >>> 0;
      h -= n;
      h *= n;
      n = h >>> 0;
      h -= n;
      n += h * 0x100000000; // 2^32
    }
    return (n >>> 0) * 2.3283064365386963e-10; // 2^-32
  };

  return mash;
}


if (module && module.exports) {
  module.exports = impl;
} else if (define && define.amd) {
  define(function() { return impl; });
} else {
  this.alea = impl;
}

})(
  this,
  (typeof module) == 'object' && module,    // present in node.js
  (typeof define) == 'function' && define   // present with an AMD loader
);



},{}],92:[function(require,module,exports){
// A Javascript implementaion of the "Tyche-i" prng algorithm by
// Samuel Neves and Filipe Araujo.
// See https://eden.dei.uc.pt/~sneves/pubs/2011-snfa2.pdf

(function(global, module, define) {

function XorGen(seed) {
  var me = this, strseed = '';

  // Set up generator function.
  me.next = function() {
    var b = me.b, c = me.c, d = me.d, a = me.a;
    b = (b << 25) ^ (b >>> 7) ^ c;
    c = (c - d) | 0;
    d = (d << 24) ^ (d >>> 8) ^ a;
    a = (a - b) | 0;
    me.b = b = (b << 20) ^ (b >>> 12) ^ c;
    me.c = c = (c - d) | 0;
    me.d = (d << 16) ^ (c >>> 16) ^ a;
    return me.a = (a - b) | 0;
  };

  /* The following is non-inverted tyche, which has better internal
   * bit diffusion, but which is about 25% slower than tyche-i in JS.
  me.next = function() {
    var a = me.a, b = me.b, c = me.c, d = me.d;
    a = (me.a + me.b | 0) >>> 0;
    d = me.d ^ a; d = d << 16 ^ d >>> 16;
    c = me.c + d | 0;
    b = me.b ^ c; b = b << 12 ^ d >>> 20;
    me.a = a = a + b | 0;
    d = d ^ a; me.d = d = d << 8 ^ d >>> 24;
    me.c = c = c + d | 0;
    b = b ^ c;
    return me.b = (b << 7 ^ b >>> 25);
  }
  */

  me.a = 0;
  me.b = 0;
  me.c = 2654435769 | 0;
  me.d = 1367130551;

  if (seed === Math.floor(seed)) {
    // Integer seed.
    me.a = (seed / 0x100000000) | 0;
    me.b = seed | 0;
  } else {
    // String seed.
    strseed += seed;
  }

  // Mix in string seed, then discard an initial batch of 64 values.
  for (var k = 0; k < strseed.length + 20; k++) {
    me.b ^= strseed.charCodeAt(k) | 0;
    me.next();
  }
}

function copy(f, t) {
  t.a = f.a;
  t.b = f.b;
  t.c = f.c;
  t.d = f.d;
  return t;
};

function impl(seed, opts) {
  var xg = new XorGen(seed),
      state = opts && opts.state,
      prng = function() { return (xg.next() >>> 0) / 0x100000000; };
  prng.double = function() {
    do {
      var top = xg.next() >>> 11,
          bot = (xg.next() >>> 0) / 0x100000000,
          result = (top + bot) / (1 << 21);
    } while (result === 0);
    return result;
  };
  prng.int32 = xg.next;
  prng.quick = prng;
  if (state) {
    if (typeof(state) == 'object') copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

if (module && module.exports) {
  module.exports = impl;
} else if (define && define.amd) {
  define(function() { return impl; });
} else {
  this.tychei = impl;
}

})(
  this,
  (typeof module) == 'object' && module,    // present in node.js
  (typeof define) == 'function' && define   // present with an AMD loader
);



},{}],93:[function(require,module,exports){
// A Javascript implementaion of the "xor128" prng algorithm by
// George Marsaglia.  See http://www.jstatsoft.org/v08/i14/paper

(function(global, module, define) {

function XorGen(seed) {
  var me = this, strseed = '';

  me.x = 0;
  me.y = 0;
  me.z = 0;
  me.w = 0;

  // Set up generator function.
  me.next = function() {
    var t = me.x ^ (me.x << 11);
    me.x = me.y;
    me.y = me.z;
    me.z = me.w;
    return me.w ^= (me.w >>> 19) ^ t ^ (t >>> 8);
  };

  if (seed === (seed | 0)) {
    // Integer seed.
    me.x = seed;
  } else {
    // String seed.
    strseed += seed;
  }

  // Mix in string seed, then discard an initial batch of 64 values.
  for (var k = 0; k < strseed.length + 64; k++) {
    me.x ^= strseed.charCodeAt(k) | 0;
    me.next();
  }
}

function copy(f, t) {
  t.x = f.x;
  t.y = f.y;
  t.z = f.z;
  t.w = f.w;
  return t;
}

function impl(seed, opts) {
  var xg = new XorGen(seed),
      state = opts && opts.state,
      prng = function() { return (xg.next() >>> 0) / 0x100000000; };
  prng.double = function() {
    do {
      var top = xg.next() >>> 11,
          bot = (xg.next() >>> 0) / 0x100000000,
          result = (top + bot) / (1 << 21);
    } while (result === 0);
    return result;
  };
  prng.int32 = xg.next;
  prng.quick = prng;
  if (state) {
    if (typeof(state) == 'object') copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

if (module && module.exports) {
  module.exports = impl;
} else if (define && define.amd) {
  define(function() { return impl; });
} else {
  this.xor128 = impl;
}

})(
  this,
  (typeof module) == 'object' && module,    // present in node.js
  (typeof define) == 'function' && define   // present with an AMD loader
);



},{}],94:[function(require,module,exports){
// A Javascript implementaion of Richard Brent's Xorgens xor4096 algorithm.
//
// This fast non-cryptographic random number generator is designed for
// use in Monte-Carlo algorithms. It combines a long-period xorshift
// generator with a Weyl generator, and it passes all common batteries
// of stasticial tests for randomness while consuming only a few nanoseconds
// for each prng generated.  For background on the generator, see Brent's
// paper: "Some long-period random number generators using shifts and xors."
// http://arxiv.org/pdf/1004.3115v1.pdf
//
// Usage:
//
// var xor4096 = require('xor4096');
// random = xor4096(1);                        // Seed with int32 or string.
// assert.equal(random(), 0.1520436450538547); // (0, 1) range, 53 bits.
// assert.equal(random.int32(), 1806534897);   // signed int32, 32 bits.
//
// For nonzero numeric keys, this impelementation provides a sequence
// identical to that by Brent's xorgens 3 implementaion in C.  This
// implementation also provides for initalizing the generator with
// string seeds, or for saving and restoring the state of the generator.
//
// On Chrome, this prng benchmarks about 2.1 times slower than
// Javascript's built-in Math.random().

(function(global, module, define) {

function XorGen(seed) {
  var me = this;

  // Set up generator function.
  me.next = function() {
    var w = me.w,
        X = me.X, i = me.i, t, v;
    // Update Weyl generator.
    me.w = w = (w + 0x61c88647) | 0;
    // Update xor generator.
    v = X[(i + 34) & 127];
    t = X[i = ((i + 1) & 127)];
    v ^= v << 13;
    t ^= t << 17;
    v ^= v >>> 15;
    t ^= t >>> 12;
    // Update Xor generator array state.
    v = X[i] = v ^ t;
    me.i = i;
    // Result is the combination.
    return (v + (w ^ (w >>> 16))) | 0;
  };

  function init(me, seed) {
    var t, v, i, j, w, X = [], limit = 128;
    if (seed === (seed | 0)) {
      // Numeric seeds initialize v, which is used to generates X.
      v = seed;
      seed = null;
    } else {
      // String seeds are mixed into v and X one character at a time.
      seed = seed + '\0';
      v = 0;
      limit = Math.max(limit, seed.length);
    }
    // Initialize circular array and weyl value.
    for (i = 0, j = -32; j < limit; ++j) {
      // Put the unicode characters into the array, and shuffle them.
      if (seed) v ^= seed.charCodeAt((j + 32) % seed.length);
      // After 32 shuffles, take v as the starting w value.
      if (j === 0) w = v;
      v ^= v << 10;
      v ^= v >>> 15;
      v ^= v << 4;
      v ^= v >>> 13;
      if (j >= 0) {
        w = (w + 0x61c88647) | 0;     // Weyl.
        t = (X[j & 127] ^= (v + w));  // Combine xor and weyl to init array.
        i = (0 == t) ? i + 1 : 0;     // Count zeroes.
      }
    }
    // We have detected all zeroes; make the key nonzero.
    if (i >= 128) {
      X[(seed && seed.length || 0) & 127] = -1;
    }
    // Run the generator 512 times to further mix the state before using it.
    // Factoring this as a function slows the main generator, so it is just
    // unrolled here.  The weyl generator is not advanced while warming up.
    i = 127;
    for (j = 4 * 128; j > 0; --j) {
      v = X[(i + 34) & 127];
      t = X[i = ((i + 1) & 127)];
      v ^= v << 13;
      t ^= t << 17;
      v ^= v >>> 15;
      t ^= t >>> 12;
      X[i] = v ^ t;
    }
    // Storing state as object members is faster than using closure variables.
    me.w = w;
    me.X = X;
    me.i = i;
  }

  init(me, seed);
}

function copy(f, t) {
  t.i = f.i;
  t.w = f.w;
  t.X = f.X.slice();
  return t;
};

function impl(seed, opts) {
  if (seed == null) seed = +(new Date);
  var xg = new XorGen(seed),
      state = opts && opts.state,
      prng = function() { return (xg.next() >>> 0) / 0x100000000; };
  prng.double = function() {
    do {
      var top = xg.next() >>> 11,
          bot = (xg.next() >>> 0) / 0x100000000,
          result = (top + bot) / (1 << 21);
    } while (result === 0);
    return result;
  };
  prng.int32 = xg.next;
  prng.quick = prng;
  if (state) {
    if (state.X) copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

if (module && module.exports) {
  module.exports = impl;
} else if (define && define.amd) {
  define(function() { return impl; });
} else {
  this.xor4096 = impl;
}

})(
  this,                                     // window object or global
  (typeof module) == 'object' && module,    // present in node.js
  (typeof define) == 'function' && define   // present with an AMD loader
);

},{}],95:[function(require,module,exports){
// A Javascript implementaion of the "xorshift7" algorithm by
// François Panneton and Pierre L'ecuyer:
// "On the Xorgshift Random Number Generators"
// http://saluc.engr.uconn.edu/refs/crypto/rng/panneton05onthexorshift.pdf

(function(global, module, define) {

function XorGen(seed) {
  var me = this;

  // Set up generator function.
  me.next = function() {
    // Update xor generator.
    var X = me.x, i = me.i, t, v, w;
    t = X[i]; t ^= (t >>> 7); v = t ^ (t << 24);
    t = X[(i + 1) & 7]; v ^= t ^ (t >>> 10);
    t = X[(i + 3) & 7]; v ^= t ^ (t >>> 3);
    t = X[(i + 4) & 7]; v ^= t ^ (t << 7);
    t = X[(i + 7) & 7]; t = t ^ (t << 13); v ^= t ^ (t << 9);
    X[i] = v;
    me.i = (i + 1) & 7;
    return v;
  };

  function init(me, seed) {
    var j, w, X = [];

    if (seed === (seed | 0)) {
      // Seed state array using a 32-bit integer.
      w = X[0] = seed;
    } else {
      // Seed state using a string.
      seed = '' + seed;
      for (j = 0; j < seed.length; ++j) {
        X[j & 7] = (X[j & 7] << 15) ^
            (seed.charCodeAt(j) + X[(j + 1) & 7] << 13);
      }
    }
    // Enforce an array length of 8, not all zeroes.
    while (X.length < 8) X.push(0);
    for (j = 0; j < 8 && X[j] === 0; ++j);
    if (j == 8) w = X[7] = -1; else w = X[j];

    me.x = X;
    me.i = 0;

    // Discard an initial 256 values.
    for (j = 256; j > 0; --j) {
      me.next();
    }
  }

  init(me, seed);
}

function copy(f, t) {
  t.x = f.x.slice();
  t.i = f.i;
  return t;
}

function impl(seed, opts) {
  if (seed == null) seed = +(new Date);
  var xg = new XorGen(seed),
      state = opts && opts.state,
      prng = function() { return (xg.next() >>> 0) / 0x100000000; };
  prng.double = function() {
    do {
      var top = xg.next() >>> 11,
          bot = (xg.next() >>> 0) / 0x100000000,
          result = (top + bot) / (1 << 21);
    } while (result === 0);
    return result;
  };
  prng.int32 = xg.next;
  prng.quick = prng;
  if (state) {
    if (state.x) copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

if (module && module.exports) {
  module.exports = impl;
} else if (define && define.amd) {
  define(function() { return impl; });
} else {
  this.xorshift7 = impl;
}

})(
  this,
  (typeof module) == 'object' && module,    // present in node.js
  (typeof define) == 'function' && define   // present with an AMD loader
);


},{}],96:[function(require,module,exports){
// A Javascript implementaion of the "xorwow" prng algorithm by
// George Marsaglia.  See http://www.jstatsoft.org/v08/i14/paper

(function(global, module, define) {

function XorGen(seed) {
  var me = this, strseed = '';

  // Set up generator function.
  me.next = function() {
    var t = (me.x ^ (me.x >>> 2));
    me.x = me.y; me.y = me.z; me.z = me.w; me.w = me.v;
    return (me.d = (me.d + 362437 | 0)) +
       (me.v = (me.v ^ (me.v << 4)) ^ (t ^ (t << 1))) | 0;
  };

  me.x = 0;
  me.y = 0;
  me.z = 0;
  me.w = 0;
  me.v = 0;

  if (seed === (seed | 0)) {
    // Integer seed.
    me.x = seed;
  } else {
    // String seed.
    strseed += seed;
  }

  // Mix in string seed, then discard an initial batch of 64 values.
  for (var k = 0; k < strseed.length + 64; k++) {
    me.x ^= strseed.charCodeAt(k) | 0;
    if (k == strseed.length) {
      me.d = me.x << 10 ^ me.x >>> 4;
    }
    me.next();
  }
}

function copy(f, t) {
  t.x = f.x;
  t.y = f.y;
  t.z = f.z;
  t.w = f.w;
  t.v = f.v;
  t.d = f.d;
  return t;
}

function impl(seed, opts) {
  var xg = new XorGen(seed),
      state = opts && opts.state,
      prng = function() { return (xg.next() >>> 0) / 0x100000000; };
  prng.double = function() {
    do {
      var top = xg.next() >>> 11,
          bot = (xg.next() >>> 0) / 0x100000000,
          result = (top + bot) / (1 << 21);
    } while (result === 0);
    return result;
  };
  prng.int32 = xg.next;
  prng.quick = prng;
  if (state) {
    if (typeof(state) == 'object') copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

if (module && module.exports) {
  module.exports = impl;
} else if (define && define.amd) {
  define(function() { return impl; });
} else {
  this.xorwow = impl;
}

})(
  this,
  (typeof module) == 'object' && module,    // present in node.js
  (typeof define) == 'function' && define   // present with an AMD loader
);



},{}],97:[function(require,module,exports){
/*
Copyright 2014 David Bau.

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

*/

(function (pool, math) {
//
// The following constants are related to IEEE 754 limits.
//
var global = this,
    width = 256,        // each RC4 output is 0 <= x < 256
    chunks = 6,         // at least six RC4 outputs for each double
    digits = 52,        // there are 52 significant digits in a double
    rngname = 'random', // rngname: name for Math.random and Math.seedrandom
    startdenom = math.pow(width, chunks),
    significance = math.pow(2, digits),
    overflow = significance * 2,
    mask = width - 1,
    nodecrypto;         // node.js crypto module, initialized at the bottom.

//
// seedrandom()
// This is the seedrandom function described above.
//
function seedrandom(seed, options, callback) {
  var key = [];
  options = (options == true) ? { entropy: true } : (options || {});

  // Flatten the seed string or build one from local entropy if needed.
  var shortseed = mixkey(flatten(
    options.entropy ? [seed, tostring(pool)] :
    (seed == null) ? autoseed() : seed, 3), key);

  // Use the seed to initialize an ARC4 generator.
  var arc4 = new ARC4(key);

  // This function returns a random double in [0, 1) that contains
  // randomness in every bit of the mantissa of the IEEE 754 value.
  var prng = function() {
    var n = arc4.g(chunks),             // Start with a numerator n < 2 ^ 48
        d = startdenom,                 //   and denominator d = 2 ^ 48.
        x = 0;                          //   and no 'extra last byte'.
    while (n < significance) {          // Fill up all significant digits by
      n = (n + x) * width;              //   shifting numerator and
      d *= width;                       //   denominator and generating a
      x = arc4.g(1);                    //   new least-significant-byte.
    }
    while (n >= overflow) {             // To avoid rounding up, before adding
      n /= 2;                           //   last byte, shift everything
      d /= 2;                           //   right using integer math until
      x >>>= 1;                         //   we have exactly the desired bits.
    }
    return (n + x) / d;                 // Form the number within [0, 1).
  };

  prng.int32 = function() { return arc4.g(4) | 0; }
  prng.quick = function() { return arc4.g(4) / 0x100000000; }
  prng.double = prng;

  // Mix the randomness into accumulated entropy.
  mixkey(tostring(arc4.S), pool);

  // Calling convention: what to return as a function of prng, seed, is_math.
  return (options.pass || callback ||
      function(prng, seed, is_math_call, state) {
        if (state) {
          // Load the arc4 state from the given state if it has an S array.
          if (state.S) { copy(state, arc4); }
          // Only provide the .state method if requested via options.state.
          prng.state = function() { return copy(arc4, {}); }
        }

        // If called as a method of Math (Math.seedrandom()), mutate
        // Math.random because that is how seedrandom.js has worked since v1.0.
        if (is_math_call) { math[rngname] = prng; return seed; }

        // Otherwise, it is a newer calling convention, so return the
        // prng directly.
        else return prng;
      })(
  prng,
  shortseed,
  'global' in options ? options.global : (this == math),
  options.state);
}
math['seed' + rngname] = seedrandom;

//
// ARC4
//
// An ARC4 implementation.  The constructor takes a key in the form of
// an array of at most (width) integers that should be 0 <= x < (width).
//
// The g(count) method returns a pseudorandom integer that concatenates
// the next (count) outputs from ARC4.  Its return value is a number x
// that is in the range 0 <= x < (width ^ count).
//
function ARC4(key) {
  var t, keylen = key.length,
      me = this, i = 0, j = me.i = me.j = 0, s = me.S = [];

  // The empty key [] is treated as [0].
  if (!keylen) { key = [keylen++]; }

  // Set up S using the standard key scheduling algorithm.
  while (i < width) {
    s[i] = i++;
  }
  for (i = 0; i < width; i++) {
    s[i] = s[j = mask & (j + key[i % keylen] + (t = s[i]))];
    s[j] = t;
  }

  // The "g" method returns the next (count) outputs as one number.
  (me.g = function(count) {
    // Using instance members instead of closure state nearly doubles speed.
    var t, r = 0,
        i = me.i, j = me.j, s = me.S;
    while (count--) {
      t = s[i = mask & (i + 1)];
      r = r * width + s[mask & ((s[i] = s[j = mask & (j + t)]) + (s[j] = t))];
    }
    me.i = i; me.j = j;
    return r;
    // For robust unpredictability, the function call below automatically
    // discards an initial batch of values.  This is called RC4-drop[256].
    // See http://google.com/search?q=rsa+fluhrer+response&btnI
  })(width);
}

//
// copy()
// Copies internal state of ARC4 to or from a plain object.
//
function copy(f, t) {
  t.i = f.i;
  t.j = f.j;
  t.S = f.S.slice();
  return t;
};

//
// flatten()
// Converts an object tree to nested arrays of strings.
//
function flatten(obj, depth) {
  var result = [], typ = (typeof obj), prop;
  if (depth && typ == 'object') {
    for (prop in obj) {
      try { result.push(flatten(obj[prop], depth - 1)); } catch (e) {}
    }
  }
  return (result.length ? result : typ == 'string' ? obj : obj + '\0');
}

//
// mixkey()
// Mixes a string seed into a key that is an array of integers, and
// returns a shortened string seed that is equivalent to the result key.
//
function mixkey(seed, key) {
  var stringseed = seed + '', smear, j = 0;
  while (j < stringseed.length) {
    key[mask & j] =
      mask & ((smear ^= key[mask & j] * 19) + stringseed.charCodeAt(j++));
  }
  return tostring(key);
}

//
// autoseed()
// Returns an object for autoseeding, using window.crypto and Node crypto
// module if available.
//
function autoseed() {
  try {
    var out;
    if (nodecrypto && (out = nodecrypto.randomBytes)) {
      // The use of 'out' to remember randomBytes makes tight minified code.
      out = out(width);
    } else {
      out = new Uint8Array(width);
      (global.crypto || global.msCrypto).getRandomValues(out);
    }
    return tostring(out);
  } catch (e) {
    var browser = global.navigator,
        plugins = browser && browser.plugins;
    return [+new Date, global, plugins, global.screen, tostring(pool)];
  }
}

//
// tostring()
// Converts an array of charcodes to a string
//
function tostring(a) {
  return String.fromCharCode.apply(0, a);
}

//
// When seedrandom.js is loaded, we immediately mix a few bits
// from the built-in RNG into the entropy pool.  Because we do
// not want to interfere with deterministic PRNG state later,
// seedrandom will not call math.random on its own again after
// initialization.
//
mixkey(math.random(), pool);

//
// Nodejs and AMD support: export the implementation as a module using
// either convention.
//
if ((typeof module) == 'object' && module.exports) {
  module.exports = seedrandom;
  // When in node.js, try using crypto package for autoseeding.
  try {
    nodecrypto = require('crypto');
  } catch (ex) {}
} else if ((typeof define) == 'function' && define.amd) {
  define(function() { return seedrandom; });
}

// End anonymous scope, and pass initial values.
})(
  [],     // pool: entropy pool starts empty
  Math    // math: package containing random, pow, and seedrandom
);

},{"crypto":1}],98:[function(require,module,exports){
!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t(require("tone")):"function"==typeof define&&define.amd?define(["tone"],t):"object"==typeof exports?exports.Piano=t(require("tone")):e.Piano=t(e.tone)}(this,function(e){return function(e){function t(o){if(n[o])return n[o].exports;var r=n[o]={i:o,l:!1,exports:{}};return e[o].call(r.exports,r,r.exports,t),r.l=!0,r.exports}var n={};return t.m=e,t.c=n,t.i=function(e){return e},t.d=function(e,n,o){t.o(e,n)||Object.defineProperty(e,n,{configurable:!1,enumerable:!0,get:o})},t.n=function(e){var n=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(n,"a",n),n},t.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},t.p="",t(t.s=8)}([function(t,n){t.exports=e},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var o=n(2);t.default={getReleasesUrl:function(e){return"rel"+(e-20)+".mp3?"+(100*Math.random()).toFixed(0)},getHarmonicsUrl:function(e){return"harmL"+(0,o.midiToNote)(e).replace("#","s")+".mp3?"+(100*Math.random()).toFixed(0)},getNotesUrl:function(e,t){return(0,o.midiToNote)(e).replace("#","s")+"v"+t+".mp3?"+(100*Math.random()).toFixed(0)}}},function(e,t,n){"use strict";function o(e){return(0,s.Frequency)(e).toMidi()}function r(e){return(0,s.Frequency)(e,"midi").toNote()}function i(e){var t=e%3;return 1===t?[e-1,c.default.intervalToFrequencyRatio(1)]:2===t?[e+1,c.default.intervalToFrequencyRatio(-1)]:[e,1]}function u(e){return new s.BufferSource(e)}function a(e,t){return Math.random()*(t-e)+e}Object.defineProperty(t,"__esModule",{value:!0}),t.randomBetween=t.midiToFrequencyRatio=t.createSource=t.noteToMidi=t.midiToNote=void 0;var s=n(0),c=function(e){return e&&e.__esModule?e:{default:e}}(s);t.midiToNote=r,t.noteToMidi=o,t.createSource=u,t.midiToFrequencyRatio=i,t.randomBetween=a},function(e,t,n){"use strict";function o(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function r(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!t||"object"!=typeof t&&"function"!=typeof t?e:t}function i(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t)}Object.defineProperty(t,"__esModule",{value:!0});var u=function(){function e(e,t){for(var n=0;n<t.length;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o)}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),a=n(0),s=function(e){return e&&e.__esModule?e:{default:e}}(a),c=function(e){function t(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;o(this,t);var n=r(this,(t.__proto__||Object.getPrototypeOf(t)).call(this));return n.createInsOuts(0,1),n.volume=e,n}return i(t,e),u(t,[{key:"volume",get:function(){return s.default.gainToDb(this.output.gain.value)},set:function(e){this.output.gain.value=s.default.dbToGain(e)}}]),t}(a.AudioNode);t.default=c},function(e,t,n){"use strict";function o(e){return e&&e.__esModule?e:{default:e}}function r(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function i(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!t||"object"!=typeof t&&"function"!=typeof t?e:t}function u(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t)}Object.defineProperty(t,"__esModule",{value:!0});var a=function(){function e(e,t){for(var n=0;n<t.length;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o)}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),s=n(1),c=o(s),l=n(3),f=o(l),p=n(2),h=n(0),d=[21,24,27,30,33,36,39,42,45,48,51,54,57,60,63,66,69,72,75,78,81,84,87],_=function(e){function t(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[21,108];r(this,t);var n=i(this,(t.__proto__||Object.getPrototypeOf(t)).call(this)),o=d.findIndex(function(t){return t>=e[0]}),u=d.findIndex(function(t){return t>=e[1]});u=-1===u?u=d.length:u;var a=d.slice(o,u);n._samples={};var s=!0,l=!1,f=void 0;try{for(var p,h=a[Symbol.iterator]();!(s=(p=h.next()).done);s=!0){var _=p.value;n._samples[_]=c.default.getHarmonicsUrl(_)}}catch(e){l=!0,f=e}finally{try{!s&&h.return&&h.return()}finally{if(l)throw f}}return n}return u(t,e),a(t,[{key:"start",value:function(e,t,n){this._sampler.triggerAttack((0,p.midiToNote)(e),t,n*(0,p.randomBetween)(.5,1))}},{key:"load",value:function(e){var t=this;return new Promise(function(n,o){t._sampler=new h.Sampler(t._samples,n,e).connect(t.output),t._sampler.release=1})}}]),t}(f.default);t.default=_},function(e,t,n){"use strict";function o(e){return e&&e.__esModule?e:{default:e}}function r(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function i(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!t||"object"!=typeof t&&"function"!=typeof t?e:t}function u(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t)}Object.defineProperty(t,"__esModule",{value:!0}),t.Notes=void 0;var a=function(){function e(e,t){var n=[],o=!0,r=!1,i=void 0;try{for(var u,a=e[Symbol.iterator]();!(o=(u=a.next()).done)&&(n.push(u.value),!t||n.length!==t);o=!0);}catch(e){r=!0,i=e}finally{try{!o&&a.return&&a.return()}finally{if(r)throw i}}return n}return function(t,n){if(Array.isArray(t))return t;if(Symbol.iterator in Object(t))return e(t,n);throw new TypeError("Invalid attempt to destructure non-iterable instance")}}(),s=function(){function e(e,t){for(var n=0;n<t.length;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o)}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),c=n(0),l=(o(c),n(1)),f=o(l),p=n(3),h=o(p),d=n(2),_={1:[8],2:[6,12],3:[1,8,15],4:[1,5,10,15],5:[1,4,8,12,16],6:[1,3,7,10,13,16],7:[1,3,6,9,11,13,16],8:[1,3,5,7,9,11,13,15],9:[1,3,5,7,9,11,13,15,16],10:[1,2,3,5,7,9,11,13,15,16],11:[1,2,3,5,7,9,11,13,14,15,16],12:[1,2,3,4,5,7,9,11,13,14,15,16],13:[1,2,3,4,5,7,9,11,12,13,14,15,16],14:[1,2,3,4,5,6,7,9,11,12,13,14,15,16],15:[1,2,3,4,5,6,7,9,10,11,12,13,14,15,16],16:[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]},y=[21,24,27,30,33,36,39,42,45,48,51,54,57,60,63,66,69,72,75,78,81,84,87,90,93,96,99,102,105,108];t.Notes=function(e){function t(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[21,108],n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;r(this,t);var o=i(this,(t.__proto__||Object.getPrototypeOf(t)).call(this)),u=y.findIndex(function(t){return t>=e[0]}),a=y.findIndex(function(t){return t>=e[1]});a=-1===a?a=y.length:a+1;var s=y.slice(u,a);return o._samplers=_[n].slice(),o._activeNotes=new Map,o._samplers.forEach(function(e,t){o._samplers[t]={},s.forEach(function(n){o._samplers[t][n]=f.default.getNotesUrl(n,e)})}),o}return u(t,e),s(t,[{key:"_hasNote",value:function(e,t){return this._samplers.hasOwnProperty(t)&&this._samplers[t].has(e)}},{key:"_getNote",value:function(e,t){return this._samplers[t].get(e)}},{key:"stop",value:function(e,t,n){this._activeNotes.has(e)&&(this._activeNotes.get(e).forEach(function(e){e.stop(t+.25,.25)}),this._activeNotes.delete(e))}},{key:"start",value:function(e,t,n){var o=n*(this._samplers.length-1),r=Math.round(o),i=r-o,u=1-.5*i,s=(0,d.midiToFrequencyRatio)(e),c=a(s,2),l=c[0],f=c[1];if(this._hasNote(l,r)){var p=(0,d.createSource)(this._getNote(l,r));p.playbackRate.value=f,p.connect(this.output),p.start(t,0,void 0,u,0),this._activeNotes.has(e)||this._activeNotes.set(e,[]),this._activeNotes.get(e).push(p)}}},{key:"load",value:function(e){var t=this,n=[];return this._samplers.forEach(function(o,r){var i=new Promise(function(n){t._samplers[r]=new c.Buffers(o,n,e)});n.push(i)}),Promise.all(n)}}]),t}(h.default)},function(e,t,n){"use strict";function o(e){return e&&e.__esModule?e:{default:e}}function r(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function i(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!t||"object"!=typeof t&&"function"!=typeof t?e:t}function u(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t)}Object.defineProperty(t,"__esModule",{value:!0});var a=function(){function e(e,t){for(var n=0;n<t.length;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o)}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),s=n(3),c=o(s),l=n(1),f=(o(l),n(2)),p=n(0),h=(o(p),function(e){function t(){r(this,t);var e=i(this,(t.__proto__||Object.getPrototypeOf(t)).call(this));return e._downTime=1/0,e._currentSound=null,e._buffers=null,e}return u(t,e),a(t,[{key:"load",value:function(e){var t=this;return new Promise(function(n){t._buffers=new p.Buffers({up:"pedalU1.mp3",down:"pedalD1.mp3"},n,e)})}},{key:"_squash",value:function(e){this._currentSound&&this._currentSound.stop(e,.1),this._currentSound=null}},{key:"_playSample",value:function(e,t){this._currentSound=(0,f.createSource)(this._buffers.get(t)),this._currentSound.connect(this.output).start(e,(0,f.randomBetween)(0,.1),void 0,.2*(0,f.randomBetween)(.5,1),.05)}},{key:"down",value:function(e){this._squash(e),this._downTime=e,this._playSample(e,"down")}},{key:"up",value:function(e){this._squash(e),this._downTime=1/0,this._playSample(e,"up")}},{key:"isDown",value:function(e){return e>this._downTime}}]),t}(c.default));t.default=h},function(e,t,n){"use strict";function o(e){return e&&e.__esModule?e:{default:e}}function r(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function i(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!t||"object"!=typeof t&&"function"!=typeof t?e:t}function u(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t)}Object.defineProperty(t,"__esModule",{value:!0});var a=function(){function e(e,t){for(var n=0;n<t.length;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o)}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),s=n(1),c=o(s),l=n(3),f=o(l),p=n(2),h=n(0),d=function(e){function t(e){r(this,t);var n=i(this,(t.__proto__||Object.getPrototypeOf(t)).call(this));n._buffers={};for(var o=e[0];o<=e[1];o++)n._buffers[o]=c.default.getReleasesUrl(o);return n}return u(t,e),a(t,[{key:"load",value:function(e){var t=this;return new Promise(function(n){t._buffers=new h.Buffers(t._buffers,n,e)})}},{key:"start",value:function(e,t,n){if(this._buffers.has(e)){var o=(0,p.createSource)(this._buffers.get(e)).connect(this.output);n*=(0,p.randomBetween)(.5,1),o.start(t,0,void 0,.01*n,0)}}}]),t}(f.default);t.default=d},function(e,t,n){"use strict";function o(e){return e&&e.__esModule?e:{default:e}}function r(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function i(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!t||"object"!=typeof t&&"function"!=typeof t?e:t}function u(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t)}Object.defineProperty(t,"__esModule",{value:!0}),t.Piano=void 0;var a=function(){function e(e,t){for(var n=0;n<t.length;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o)}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),s=n(0),c=o(s),l=n(6),f=o(l),p=n(5),h=n(4),d=o(h),_=n(7),y=o(_),v=n(1);o(v),t.Piano=function(e){function t(){r(this,t);var e=c.default.defaults(arguments,["range","velocities"],{velocities:1,range:[21,108],release:!0}),n=i(this,(t.__proto__||Object.getPrototypeOf(t)).call(this));return n.createInsOuts(0,1),n._loaded=!1,n._heldNotes=new Map,n._sustainedNotes=new Map,n._notes=new p.Notes(e.range,e.velocities).connect(n.output),n._pedal=(new f.default).connect(n.output),e.release&&(n._harmonics=new d.default(e.range).connect(n.output),n._release=new y.default(e.range).connect(n.output)),n}return u(t,e),a(t,[{key:"load",value:function(e){var t=this,n=[this._notes.load(e),this._pedal.load(e)];return this._harmonics&&n.push(this._harmonics.load(e)),this._release&&n.push(this._release.load(e)),Promise.all(n).then(function(){t._loaded=!0})}},{key:"pedalDown",value:function(e){return this.loaded&&(e=this.toSeconds(e),this._pedal.isDown(e)||this._pedal.down(e)),this}},{key:"pedalUp",value:function(e){var t=this;return this.loaded&&(e=this.toSeconds(e),this._pedal.isDown(e)&&(this._pedal.up(e),this._sustainedNotes.forEach(function(n,o){t._heldNotes.has(o)||t._notes.stop(o,e)}),this._sustainedNotes.clear())),this}},{key:"keyDown",value:function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:c.default.now(),n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:.8;return this.loaded&&(t=this.toSeconds(t),c.default.isString(e)&&(e=Math.round((0,s.Frequency)(e).toMidi())),this._heldNotes.has(e)||(this._heldNotes.set(e,{time:t,velocity:n}),this._notes.start(e,t,n))),this}},{key:"keyUp",value:function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:c.default.now(),n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:.8;if(this.loaded&&(t=this.toSeconds(t),c.default.isString(e)&&(e=Math.round((0,s.Frequency)(e).toMidi())),this._heldNotes.has(e))){var o=this._heldNotes.get(e);this._heldNotes.delete(e),this._release&&this._release.start(e,t,n);var r=t-o.time,i=o.velocity,u=.5/Math.max(r,.1)+i+n;u=Math.pow(Math.log(Math.max(u,1)),2)/2,this._pedal.isDown(t)?this._sustainedNotes.has(e)||this._sustainedNotes.set(e,t):(this._notes.stop(e,t,n),this._harmonics&&this._harmonics.start(e,t,u))}return this}},{key:"setVolume",value:function(e,t){switch(e){case"note":this._notes.volume=t;break;case"pedal":this._pedal.volume=t;break;case"release":this._release&&(this._release.volume=t);break;case"harmonics":this._harmonics&&(this._harmonics.volume=t)}return this}},{key:"loaded",get:function(){return this._loaded}}]),t}(s.AudioNode)}])});

},{"tone":99}],99:[function(require,module,exports){
(function(root, factory){

	//UMD
	if ( typeof define === "function" && define.amd ) {
		define(function() {
			return factory();
		});
	} else if (typeof module === "object") {
		module.exports = factory();
 	} else {
		root.Tone = factory();
	}

}(this, function(){

	"use strict";
	
	var Tone;
	//constructs the main Tone object
	function Main(func){
		Tone = func();
	}
	//invokes each of the modules with the main Tone object as the argument
	function Module(func){
		func(Tone);
	}	/**
	 *  Tone.js
	 *  @author Yotam Mann
	 *  @license http://opensource.org/licenses/MIT MIT License
	 *  @copyright 2014-2017 Yotam Mann
	 */
	Main(function () {
	    
	    ///////////////////////////////////////////////////////////////////////////
	    //	TONE
	    ///////////////////////////////////////////////////////////////////////////
	    /**
		 *  @class  Tone is the base class of all other classes.
		 *  @constructor
		 */
	    var Tone = function () {
	    };
	    /**
		 *  @memberOf Tone#
		 *  @returns {string} returns the name of the class as a string
		 */
	    Tone.prototype.toString = function () {
	        for (var className in Tone) {
	            var isLetter = className[0].match(/^[A-Z]$/);
	            var sameConstructor = Tone[className] === this.constructor;
	            if (Tone.isFunction(Tone[className]) && isLetter && sameConstructor) {
	                return className;
	            }
	        }
	        return 'Tone';
	    };
	    /**
		 *  @memberOf Tone#
		 *  disconnect and dispose
		 *  @returns {Tone} this
		 */
	    Tone.prototype.dispose = function () {
	        return this;
	    };
	    ///////////////////////////////////////////////////////////////////////////
	    //	GET/SET
	    ///////////////////////////////////////////////////////////////////////////
	    /**
		 *  Set the parameters at once. Either pass in an
		 *  object mapping parameters to values, or to set a
		 *  single parameter, by passing in a string and value.
		 *  The last argument is an optional ramp time which
		 *  will ramp any signal values to their destination value
		 *  over the duration of the rampTime.
		 *  @param {Object|string} params
		 *  @param {number=} value
		 *  @param {Time=} rampTime
		 *  @returns {Tone} this
		 *  @memberOf Tone#
		 *  @example
		 * //set values using an object
		 * filter.set({
		 * 	"frequency" : 300,
		 * 	"type" : highpass
		 * });
		 *  @example
		 * filter.set("type", "highpass");
		 *  @example
		 * //ramp to the value 220 over 3 seconds.
		 * oscillator.set({
		 * 	"frequency" : 220
		 * }, 3);
		 */
	    Tone.prototype.set = function (params, value, rampTime) {
	        if (Tone.isObject(params)) {
	            rampTime = value;
	        } else if (Tone.isString(params)) {
	            var tmpObj = {};
	            tmpObj[params] = value;
	            params = tmpObj;
	        }
	        paramLoop:
	            for (var attr in params) {
	                value = params[attr];
	                var parent = this;
	                if (attr.indexOf('.') !== -1) {
	                    var attrSplit = attr.split('.');
	                    for (var i = 0; i < attrSplit.length - 1; i++) {
	                        parent = parent[attrSplit[i]];
	                        if (parent instanceof Tone) {
	                            attrSplit.splice(0, i + 1);
	                            var innerParam = attrSplit.join('.');
	                            parent.set(innerParam, value);
	                            continue paramLoop;
	                        }
	                    }
	                    attr = attrSplit[attrSplit.length - 1];
	                }
	                var param = parent[attr];
	                if (Tone.isUndef(param)) {
	                    continue;
	                }
	                if (Tone.Signal && param instanceof Tone.Signal || Tone.Param && param instanceof Tone.Param) {
	                    if (param.value !== value) {
	                        if (Tone.isUndef(rampTime)) {
	                            param.value = value;
	                        } else {
	                            param.rampTo(value, rampTime);
	                        }
	                    }
	                } else if (param instanceof AudioParam) {
	                    if (param.value !== value) {
	                        param.value = value;
	                    }
	                } else if (param instanceof Tone) {
	                    param.set(value);
	                } else if (param !== value) {
	                    parent[attr] = value;
	                }
	            }
	        return this;
	    };
	    /**
		 *  Get the object's attributes. Given no arguments get
		 *  will return all available object properties and their corresponding
		 *  values. Pass in a single attribute to retrieve or an array
		 *  of attributes. The attribute strings can also include a "."
		 *  to access deeper properties.
		 *  @memberOf Tone#
		 *  @example
		 * osc.get();
		 * //returns {"type" : "sine", "frequency" : 440, ...etc}
		 *  @example
		 * osc.get("type");
		 * //returns { "type" : "sine"}
		 * @example
		 * //use dot notation to access deep properties
		 * synth.get(["envelope.attack", "envelope.release"]);
		 * //returns {"envelope" : {"attack" : 0.2, "release" : 0.4}}
		 *  @param {Array=|string|undefined} params the parameters to get, otherwise will return
		 *  					                  all available.
		 *  @returns {Object}
		 */
	    Tone.prototype.get = function (params) {
	        if (Tone.isUndef(params)) {
	            params = this._collectDefaults(this.constructor);
	        } else if (Tone.isString(params)) {
	            params = [params];
	        }
	        var ret = {};
	        for (var i = 0; i < params.length; i++) {
	            var attr = params[i];
	            var parent = this;
	            var subRet = ret;
	            if (attr.indexOf('.') !== -1) {
	                var attrSplit = attr.split('.');
	                for (var j = 0; j < attrSplit.length - 1; j++) {
	                    var subAttr = attrSplit[j];
	                    subRet[subAttr] = subRet[subAttr] || {};
	                    subRet = subRet[subAttr];
	                    parent = parent[subAttr];
	                }
	                attr = attrSplit[attrSplit.length - 1];
	            }
	            var param = parent[attr];
	            if (Tone.isObject(params[attr])) {
	                subRet[attr] = param.get();
	            } else if (Tone.Signal && param instanceof Tone.Signal) {
	                subRet[attr] = param.value;
	            } else if (Tone.Param && param instanceof Tone.Param) {
	                subRet[attr] = param.value;
	            } else if (param instanceof AudioParam) {
	                subRet[attr] = param.value;
	            } else if (param instanceof Tone) {
	                subRet[attr] = param.get();
	            } else if (!Tone.isFunction(param) && !Tone.isUndef(param)) {
	                subRet[attr] = param;
	            }
	        }
	        return ret;
	    };
	    /**
		 *  collect all of the default attributes in one
		 *  @private
		 *  @param {function} constr the constructor to find the defaults from
		 *  @return {Array} all of the attributes which belong to the class
		 */
	    Tone.prototype._collectDefaults = function (constr) {
	        var ret = [];
	        if (!Tone.isUndef(constr.defaults)) {
	            ret = Object.keys(constr.defaults);
	        }
	        if (!Tone.isUndef(constr._super)) {
	            var superDefs = this._collectDefaults(constr._super);
	            //filter out repeats
	            for (var i = 0; i < superDefs.length; i++) {
	                if (ret.indexOf(superDefs[i]) === -1) {
	                    ret.push(superDefs[i]);
	                }
	            }
	        }
	        return ret;
	    };
	    ///////////////////////////////////////////////////////////////////////////
	    //	DEFAULTS
	    ///////////////////////////////////////////////////////////////////////////
	    /**
		 *  @memberOf Tone
		 *  @param  {Array}  values  The arguments array
		 *  @param  {Array}  keys    The names of the arguments
		 *  @param {Function|Object} constr The class constructor
		 *  @return  {Object}  An object composed of the  defaults between the class' defaults
		 *                        and the passed in arguments.
		 */
	    Tone.defaults = function (values, keys, constr) {
	        var options = {};
	        if (values.length === 1 && Tone.isObject(values[0])) {
	            options = values[0];
	        } else {
	            for (var i = 0; i < keys.length; i++) {
	                options[keys[i]] = values[i];
	            }
	        }
	        if (!Tone.isUndef(constr.defaults)) {
	            return Tone.defaultArg(options, constr.defaults);
	        } else if (Tone.isObject(constr)) {
	            return Tone.defaultArg(options, constr);
	        } else {
	            return options;
	        }
	    };
	    /**
		 *  If the `given` parameter is undefined, use the `fallback`.
		 *  If both `given` and `fallback` are object literals, it will
		 *  return a deep copy which includes all of the parameters from both
		 *  objects. If a parameter is undefined in given, it will return
		 *  the fallback property.
		 *  <br><br>
		 *  WARNING: if object is self referential, it will go into an an
		 *  infinite recursive loop.
		 *  @memberOf Tone
		 *  @param  {*} given
		 *  @param  {*} fallback
		 *  @return {*}
		 */
	    Tone.defaultArg = function (given, fallback) {
	        if (Tone.isObject(given) && Tone.isObject(fallback)) {
	            var ret = {};
	            //make a deep copy of the given object
	            for (var givenProp in given) {
	                ret[givenProp] = Tone.defaultArg(fallback[givenProp], given[givenProp]);
	            }
	            for (var fallbackProp in fallback) {
	                ret[fallbackProp] = Tone.defaultArg(given[fallbackProp], fallback[fallbackProp]);
	            }
	            return ret;
	        } else {
	            return Tone.isUndef(given) ? fallback : given;
	        }
	    };
	    ///////////////////////////////////////////////////////////////////////////
	    //	CONNECTIONS
	    ///////////////////////////////////////////////////////////////////////////
	    /**
		 *  connect together all of the arguments in series
		 *  @param {...AudioParam|Tone|AudioNode} nodes
		 *  @returns {Tone}
		 *  @memberOf Tone
		 *  @static
		 */
	    Tone.connectSeries = function () {
	        var currentUnit = arguments[0];
	        for (var i = 1; i < arguments.length; i++) {
	            var toUnit = arguments[i];
	            currentUnit.connect(toUnit);
	            currentUnit = toUnit;
	        }
	        return Tone;
	    };
	    ///////////////////////////////////////////////////////////////////////////
	    // TYPE CHECKING
	    ///////////////////////////////////////////////////////////////////////////
	    /**
		 *  test if the arg is undefined
		 *  @param {*} arg the argument to test
		 *  @returns {boolean} true if the arg is undefined
		 *  @static
		 *  @memberOf Tone
		 */
	    Tone.isUndef = function (val) {
	        return typeof val === 'undefined';
	    };
	    /**
		 *  test if the arg is a function
		 *  @param {*} arg the argument to test
		 *  @returns {boolean} true if the arg is a function
		 *  @static
		 *  @memberOf Tone
		 */
	    Tone.isFunction = function (val) {
	        return typeof val === 'function';
	    };
	    /**
		 *  Test if the argument is a number.
		 *  @param {*} arg the argument to test
		 *  @returns {boolean} true if the arg is a number
		 *  @static
		 *  @memberOf Tone
		 */
	    Tone.isNumber = function (arg) {
	        return typeof arg === 'number';
	    };
	    /**
		 *  Test if the given argument is an object literal (i.e. `{}`);
		 *  @param {*} arg the argument to test
		 *  @returns {boolean} true if the arg is an object literal.
		 *  @static
		 *  @memberOf Tone
		 */
	    Tone.isObject = function (arg) {
	        return Object.prototype.toString.call(arg) === '[object Object]' && arg.constructor === Object;
	    };
	    /**
		 *  Test if the argument is a boolean.
		 *  @param {*} arg the argument to test
		 *  @returns {boolean} true if the arg is a boolean
		 *  @static
		 *  @memberOf Tone
		 */
	    Tone.isBoolean = function (arg) {
	        return typeof arg === 'boolean';
	    };
	    /**
		 *  Test if the argument is an Array
		 *  @param {*} arg the argument to test
		 *  @returns {boolean} true if the arg is an array
		 *  @static
		 *  @memberOf Tone
		 */
	    Tone.isArray = function (arg) {
	        return Array.isArray(arg);
	    };
	    /**
		 *  Test if the argument is a string.
		 *  @param {*} arg the argument to test
		 *  @returns {boolean} true if the arg is a string
		 *  @static
		 *  @memberOf Tone
		 */
	    Tone.isString = function (arg) {
	        return typeof arg === 'string';
	    };
	    /**
		 *  Test if the argument is in the form of a note in scientific pitch notation.
		 *  e.g. "C4"
		 *  @param {*} arg the argument to test
		 *  @returns {boolean} true if the arg is a string
		 *  @static
		 *  @memberOf Tone
		 */
	    Tone.isNote = function (arg) {
	        return Tone.isString(arg) && /^([a-g]{1}(?:b|#|x|bb)?)(-?[0-9]+)/i.test(arg);
	    };
	    /**
		 *  An empty function.
		 *  @static
		 */
	    Tone.noOp = function () {
	    };
	    /**
		 *  Make the property not writable. Internal use only.
		 *  @private
		 *  @param  {string}  property  the property to make not writable
		 */
	    Tone.prototype._readOnly = function (property) {
	        if (Array.isArray(property)) {
	            for (var i = 0; i < property.length; i++) {
	                this._readOnly(property[i]);
	            }
	        } else {
	            Object.defineProperty(this, property, {
	                writable: false,
	                enumerable: true
	            });
	        }
	    };
	    /**
		 *  Make an attribute writeable. Interal use only.
		 *  @private
		 *  @param  {string}  property  the property to make writable
		 */
	    Tone.prototype._writable = function (property) {
	        if (Array.isArray(property)) {
	            for (var i = 0; i < property.length; i++) {
	                this._writable(property[i]);
	            }
	        } else {
	            Object.defineProperty(this, property, { writable: true });
	        }
	    };
	    /**
		 * Possible play states.
		 * @enum {string}
		 */
	    Tone.State = {
	        Started: 'started',
	        Stopped: 'stopped',
	        Paused: 'paused'
	    };
	    ///////////////////////////////////////////////////////////////////////////
	    // CONVERSIONS
	    ///////////////////////////////////////////////////////////////////////////
	    /**
		 *  Equal power gain scale. Good for cross-fading.
		 *  @param  {NormalRange} percent (0-1)
		 *  @return {Number}         output gain (0-1)
		 *  @static
		 *  @memberOf Tone
		 */
	    Tone.equalPowerScale = function (percent) {
	        var piFactor = 0.5 * Math.PI;
	        return Math.sin(percent * piFactor);
	    };
	    /**
		 *  Convert decibels into gain.
		 *  @param  {Decibels} db
		 *  @return {Number}
		 *  @static
		 *  @memberOf Tone
		 */
	    Tone.dbToGain = function (db) {
	        return Math.pow(2, db / 6);
	    };
	    /**
		 *  Convert gain to decibels.
		 *  @param  {Number} gain (0-1)
		 *  @return {Decibels}
		 *  @static
		 *  @memberOf Tone
		 */
	    Tone.gainToDb = function (gain) {
	        return 20 * (Math.log(gain) / Math.LN10);
	    };
	    /**
		 *  Convert an interval (in semitones) to a frequency ratio.
		 *  @param  {Interval} interval the number of semitones above the base note
		 *  @return {number}          the frequency ratio
		 *  @static
		 *  @memberOf Tone
		 *  @example
		 * tone.intervalToFrequencyRatio(0); // 1
		 * tone.intervalToFrequencyRatio(12); // 2
		 * tone.intervalToFrequencyRatio(-12); // 0.5
		 */
	    Tone.intervalToFrequencyRatio = function (interval) {
	        return Math.pow(2, interval / 12);
	    };
	    ///////////////////////////////////////////////////////////////////////////
	    //	TIMING
	    ///////////////////////////////////////////////////////////////////////////
	    /**
		 *  Return the current time of the AudioContext clock.
		 *  @return {Number} the currentTime from the AudioContext
		 *  @memberOf Tone#
		 */
	    Tone.prototype.now = function () {
	        return Tone.context.now();
	    };
	    /**
		 *  Return the current time of the AudioContext clock.
		 *  @return {Number} the currentTime from the AudioContext
		 *  @static
		 *  @memberOf Tone
		 */
	    Tone.now = function () {
	        return Tone.context.now();
	    };
	    ///////////////////////////////////////////////////////////////////////////
	    //	INHERITANCE
	    ///////////////////////////////////////////////////////////////////////////
	    /**
		 *  have a child inherit all of Tone's (or a parent's) prototype
		 *  to inherit the parent's properties, make sure to call
		 *  Parent.call(this) in the child's constructor
		 *
		 *  based on closure library's inherit function
		 *
		 *  @memberOf Tone
		 *  @static
		 *  @param  {function} 	child
		 *  @param  {function=} parent (optional) parent to inherit from
		 *                             if no parent is supplied, the child
		 *                             will inherit from Tone
		 */
	    Tone.extend = function (child, parent) {
	        if (Tone.isUndef(parent)) {
	            parent = Tone;
	        }
	        function TempConstructor() {
	        }
	        TempConstructor.prototype = parent.prototype;
	        child.prototype = new TempConstructor();
	        /** @override */
	        child.prototype.constructor = child;
	        child._super = parent;
	    };
	    ///////////////////////////////////////////////////////////////////////////
	    //	CONTEXT
	    ///////////////////////////////////////////////////////////////////////////
	    /**
		 *  The private audio context shared by all Tone Nodes.
		 *  @private
		 *  @type {Tone.Context}
		 */
	    var audioContext = null;
	    /**
		 *  A static pointer to the audio context accessible as Tone.context.
		 *  @type {Tone.Context}
		 *  @name context
		 *  @memberOf Tone
		 */
	    Object.defineProperty(Tone, 'context', {
	        get: function () {
	            return audioContext;
	        },
	        set: function (context) {
	            if (Tone.Context && context instanceof Tone.Context) {
	                audioContext = context;
	            } else {
	                audioContext = new Tone.Context(context);
	            }
	            //initialize the new audio context
	            Tone.Context.emit('init', audioContext);
	        }
	    });
	    /**
		 *  The AudioContext
		 *  @type {Tone.Context}
		 *  @name context
		 *  @memberOf Tone#
		 *  @readOnly
		 */
	    Object.defineProperty(Tone.prototype, 'context', {
	        get: function () {
	            return Tone.context;
	        }
	    });
	    /**
		 *  Tone automatically creates a context on init, but if you are working
		 *  with other libraries which also create an AudioContext, it can be
		 *  useful to set your own. If you are going to set your own context,
		 *  be sure to do it at the start of your code, before creating any objects.
		 *  @static
		 *  @param {AudioContext} ctx The new audio context to set
		 */
	    Tone.setContext = function (ctx) {
	        Tone.context = ctx;
	    };
	    ///////////////////////////////////////////////////////////////////////////
	    //	ATTRIBUTES
	    ///////////////////////////////////////////////////////////////////////////
	    /**
		 *  The number of seconds of 1 processing block (128 samples)
		 *  @type {Number}
		 *  @name blockTime
		 *  @memberOf Tone
		 *  @static
		 *  @readOnly
		 */
	    Object.defineProperty(Tone.prototype, 'blockTime', {
	        get: function () {
	            return 128 / this.context.sampleRate;
	        }
	    });
	    /**
		 *  The duration in seconds of one sample.
		 *  @type {Number}
		 *  @name sampleTime
		 *  @memberOf Tone
		 *  @static
		 *  @readOnly
		 */
	    Object.defineProperty(Tone.prototype, 'sampleTime', {
	        get: function () {
	            return 1 / this.context.sampleRate;
	        }
	    });
	    /**
		 *  Whether or not all the technologies that Tone.js relies on are supported by the current browser.
		 *  @type {Boolean}
		 *  @name supported
		 *  @memberOf Tone
		 *  @readOnly
		 *  @static
		 */
	    Object.defineProperty(Tone, 'supported', {
	        get: function () {
	            var hasAudioContext = window.hasOwnProperty('AudioContext') || window.hasOwnProperty('webkitAudioContext');
	            var hasPromises = window.hasOwnProperty('Promise');
	            var hasWorkers = window.hasOwnProperty('Worker');
	            return hasAudioContext && hasPromises && hasWorkers;
	        }
	    });
	    /**
		 *  Boolean value if the audio context has been initialized.
		 *  @type {Boolean}
		 *  @memberOf Tone
		 *  @static
		 *  @name initialized
		 */
	    Object.defineProperty(Tone, 'initialized', {
	        get: function () {
	            return audioContext !== null;
	        }
	    });
	    /**
		 *  Get the context when it becomes available
		 *  @param  {Function}  resolve  Callback when the context is initialized
		 *  @return  {Tone}
		 */
	    Tone.getContext = function (resolve) {
	        if (Tone.initialized) {
	            resolve(Tone.context);
	        } else {
	            var resCallback = function () {
	                resolve(Tone.context);
	                Tone.Context.off('init', resCallback);
	            };
	            Tone.Context.on('init', resCallback);
	        }
	        return Tone;
	    };
	    /**
		 * The version number
		 * @type {String}
		 * @static
		 */
	    Tone.version = 'r11';
	    // allow optional silencing of this log
	    if (!window.TONE_SILENCE_VERSION_LOGGING) {
	        console.log('%c * Tone.js ' + Tone.version + ' * ', 'background: #000; color: #fff');
	    }
	    return Tone;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Tone.Emitter gives classes which extend it
		 *         the ability to listen for and emit events. 
		 *         Inspiration and reference from Jerome Etienne's [MicroEvent](https://github.com/jeromeetienne/microevent.js).
		 *         MIT (c) 2011 Jerome Etienne.
		 *         
		 *  @extends {Tone}
		 */
	    Tone.Emitter = function () {
	        Tone.call(this);
	        /**
			 *  Contains all of the events.
			 *  @private
			 *  @type  {Object}
			 */
	        this._events = {};
	    };
	    Tone.extend(Tone.Emitter);
	    /**
		 *  Bind a callback to a specific event.
		 *  @param  {String}    event     The name of the event to listen for.
		 *  @param  {Function}  callback  The callback to invoke when the
		 *                                event is emitted
		 *  @return  {Tone.Emitter}    this
		 */
	    Tone.Emitter.prototype.on = function (event, callback) {
	        //split the event
	        var events = event.split(/\W+/);
	        for (var i = 0; i < events.length; i++) {
	            var eventName = events[i];
	            if (!this._events.hasOwnProperty(eventName)) {
	                this._events[eventName] = [];
	            }
	            this._events[eventName].push(callback);
	        }
	        return this;
	    };
	    /**
		 *  Remove the event listener.
		 *  @param  {String}    event     The event to stop listening to.
		 *  @param  {Function=}  callback  The callback which was bound to 
		 *                                the event with Tone.Emitter.on.
		 *                                If no callback is given, all callbacks
		 *                                events are removed.
		 *  @return  {Tone.Emitter}    this
		 */
	    Tone.Emitter.prototype.off = function (event, callback) {
	        var events = event.split(/\W+/);
	        for (var ev = 0; ev < events.length; ev++) {
	            event = events[ev];
	            if (this._events.hasOwnProperty(event)) {
	                if (Tone.isUndef(callback)) {
	                    this._events[event] = [];
	                } else {
	                    var eventList = this._events[event];
	                    for (var i = 0; i < eventList.length; i++) {
	                        if (eventList[i] === callback) {
	                            eventList.splice(i, 1);
	                        }
	                    }
	                }
	            }
	        }
	        return this;
	    };
	    /**
		 *  Invoke all of the callbacks bound to the event
		 *  with any arguments passed in. 
		 *  @param  {String}  event  The name of the event.
		 *  @param {*} args... The arguments to pass to the functions listening.
		 *  @return  {Tone.Emitter}  this
		 */
	    Tone.Emitter.prototype.emit = function (event) {
	        if (this._events) {
	            var args = Array.apply(null, arguments).slice(1);
	            if (this._events.hasOwnProperty(event)) {
	                var eventList = this._events[event];
	                for (var i = 0, len = eventList.length; i < len; i++) {
	                    eventList[i].apply(this, args);
	                }
	            }
	        }
	        return this;
	    };
	    /**
		 *  Add Emitter functions (on/off/emit) to the object
		 *  @param  {Object|Function}  object  The object or class to extend.
		 *  @returns {Tone.Emitter}
		 */
	    Tone.Emitter.mixin = function (object) {
	        var functions = [
	            'on',
	            'off',
	            'emit'
	        ];
	        object._events = {};
	        for (var i = 0; i < functions.length; i++) {
	            var func = functions[i];
	            var emitterFunc = Tone.Emitter.prototype[func];
	            object[func] = emitterFunc;
	        }
	        return Tone.Emitter;
	    };
	    /**
		 *  Clean up
		 *  @return  {Tone.Emitter}  this
		 */
	    Tone.Emitter.prototype.dispose = function () {
	        Tone.prototype.dispose.call(this);
	        this._events = null;
	        return this;
	    };
	    return Tone.Emitter;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class A Timeline class for scheduling and maintaining state
		 *         along a timeline. All events must have a "time" property. 
		 *         Internally, events are stored in time order for fast 
		 *         retrieval.
		 *  @extends {Tone}
		 *  @param {Positive} [memory=Infinity] The number of previous events that are retained.
		 */
	    Tone.Timeline = function () {
	        var options = Tone.defaults(arguments, ['memory'], Tone.Timeline);
	        Tone.call(this);
	        /**
			 *  The array of scheduled timeline events
			 *  @type  {Array}
			 *  @private
			 */
	        this._timeline = [];
	        /**
			 *  An array of items to remove from the list. 
			 *  @type {Array}
			 *  @private
			 */
	        this._toRemove = [];
	        /**
			 *  Flag if the timeline is mid iteration
			 *  @private
			 *  @type {Boolean}
			 */
	        this._iterating = false;
	        /**
			 *  The memory of the timeline, i.e.
			 *  how many events in the past it will retain
			 *  @type {Positive}
			 */
	        this.memory = options.memory;
	    };
	    Tone.extend(Tone.Timeline);
	    /**
		 *  the default parameters
		 *  @static
		 *  @const
		 */
	    Tone.Timeline.defaults = { 'memory': Infinity };
	    /**
		 *  The number of items in the timeline.
		 *  @type {Number}
		 *  @memberOf Tone.Timeline#
		 *  @name length
		 *  @readOnly
		 */
	    Object.defineProperty(Tone.Timeline.prototype, 'length', {
	        get: function () {
	            return this._timeline.length;
	        }
	    });
	    /**
		 *  Insert an event object onto the timeline. Events must have a "time" attribute.
		 *  @param  {Object}  event  The event object to insert into the 
		 *                           timeline. 
		 *  @returns {Tone.Timeline} this
		 */
	    Tone.Timeline.prototype.add = function (event) {
	        //the event needs to have a time attribute
	        if (Tone.isUndef(event.time)) {
	            throw new Error('Tone.Timeline: events must have a time attribute');
	        }
	        if (this._timeline.length) {
	            var index = this._search(event.time);
	            this._timeline.splice(index + 1, 0, event);
	        } else {
	            this._timeline.push(event);
	        }
	        //if the length is more than the memory, remove the previous ones
	        if (this.length > this.memory) {
	            var diff = this.length - this.memory;
	            this._timeline.splice(0, diff);
	        }
	        return this;
	    };
	    /**
		 *  Remove an event from the timeline.
		 *  @param  {Object}  event  The event object to remove from the list.
		 *  @returns {Tone.Timeline} this
		 */
	    Tone.Timeline.prototype.remove = function (event) {
	        if (this._iterating) {
	            this._toRemove.push(event);
	        } else {
	            var index = this._timeline.indexOf(event);
	            if (index !== -1) {
	                this._timeline.splice(index, 1);
	            }
	        }
	        return this;
	    };
	    /**
		 *  Get the nearest event whose time is less than or equal to the given time.
		 *  @param  {Number}  time  The time to query.
		 *  @param  {String}  comparitor Which value in the object to compare
		 *  @returns {Object} The event object set after that time.
		 */
	    Tone.Timeline.prototype.get = function (time, comparitor) {
	        comparitor = Tone.defaultArg(comparitor, 'time');
	        var index = this._search(time, comparitor);
	        if (index !== -1) {
	            return this._timeline[index];
	        } else {
	            return null;
	        }
	    };
	    /**
		 *  Return the first event in the timeline without removing it
		 *  @returns {Object} The first event object
		 */
	    Tone.Timeline.prototype.peek = function () {
	        return this._timeline[0];
	    };
	    /**
		 *  Return the first event in the timeline and remove it
		 *  @returns {Object} The first event object
		 */
	    Tone.Timeline.prototype.shift = function () {
	        return this._timeline.shift();
	    };
	    /**
		 *  Get the event which is scheduled after the given time.
		 *  @param  {Number}  time  The time to query.
		 *  @param  {String}  comparitor Which value in the object to compare
		 *  @returns {Object} The event object after the given time
		 */
	    Tone.Timeline.prototype.getAfter = function (time, comparitor) {
	        comparitor = Tone.defaultArg(comparitor, 'time');
	        var index = this._search(time, comparitor);
	        if (index + 1 < this._timeline.length) {
	            return this._timeline[index + 1];
	        } else {
	            return null;
	        }
	    };
	    /**
		 *  Get the event before the event at the given time.
		 *  @param  {Number}  time  The time to query.
		 *  @param  {String}  comparitor Which value in the object to compare
		 *  @returns {Object} The event object before the given time
		 */
	    Tone.Timeline.prototype.getBefore = function (time, comparitor) {
	        comparitor = Tone.defaultArg(comparitor, 'time');
	        var len = this._timeline.length;
	        //if it's after the last item, return the last item
	        if (len > 0 && this._timeline[len - 1][comparitor] < time) {
	            return this._timeline[len - 1];
	        }
	        var index = this._search(time, comparitor);
	        if (index - 1 >= 0) {
	            return this._timeline[index - 1];
	        } else {
	            return null;
	        }
	    };
	    /**
		 *  Cancel events after the given time
		 *  @param  {Number}  time  The time to query.
		 *  @returns {Tone.Timeline} this
		 */
	    Tone.Timeline.prototype.cancel = function (after) {
	        if (this._timeline.length > 1) {
	            var index = this._search(after);
	            if (index >= 0) {
	                if (this._timeline[index].time === after) {
	                    //get the first item with that time
	                    for (var i = index; i >= 0; i--) {
	                        if (this._timeline[i].time === after) {
	                            index = i;
	                        } else {
	                            break;
	                        }
	                    }
	                    this._timeline = this._timeline.slice(0, index);
	                } else {
	                    this._timeline = this._timeline.slice(0, index + 1);
	                }
	            } else {
	                this._timeline = [];
	            }
	        } else if (this._timeline.length === 1) {
	            //the first item's time
	            if (this._timeline[0].time >= after) {
	                this._timeline = [];
	            }
	        }
	        return this;
	    };
	    /**
		 *  Cancel events before or equal to the given time.
		 *  @param  {Number}  time  The time to cancel before.
		 *  @returns {Tone.Timeline} this
		 */
	    Tone.Timeline.prototype.cancelBefore = function (time) {
	        if (this._timeline.length) {
	            var index = this._search(time);
	            if (index >= 0) {
	                this._timeline = this._timeline.slice(index + 1);
	            }
	        }
	        return this;
	    };
	    /**
		 * Returns the previous event if there is one. null otherwise
		 * @param  {Object} event The event to find the previous one of
		 * @return {Object}       The event right before the given event
		 */
	    Tone.Timeline.prototype.previousEvent = function (event) {
	        var index = this._timeline.indexOf(event);
	        if (index > 0) {
	            return this._timeline[index - 1];
	        } else {
	            return null;
	        }
	    };
	    /**
		 *  Does a binary serach on the timeline array and returns the 
		 *  nearest event index whose time is after or equal to the given time.
		 *  If a time is searched before the first index in the timeline, -1 is returned.
		 *  If the time is after the end, the index of the last item is returned.
		 *  @param  {Number}  time  
		 *  @param  {String}  comparitor Which value in the object to compare
		 *  @return  {Number} the index in the timeline array 
		 *  @private
		 */
	    Tone.Timeline.prototype._search = function (time, comparitor) {
	        comparitor = Tone.defaultArg(comparitor, 'time');
	        var beginning = 0;
	        var len = this._timeline.length;
	        var end = len;
	        if (len > 0 && this._timeline[len - 1][comparitor] <= time) {
	            return len - 1;
	        }
	        while (beginning < end) {
	            // calculate the midpoint for roughly equal partition
	            var midPoint = Math.floor(beginning + (end - beginning) / 2);
	            var event = this._timeline[midPoint];
	            var nextEvent = this._timeline[midPoint + 1];
	            if (event[comparitor] === time) {
	                //choose the last one that has the same time
	                for (var i = midPoint; i < this._timeline.length; i++) {
	                    var testEvent = this._timeline[i];
	                    if (testEvent[comparitor] === time) {
	                        midPoint = i;
	                    }
	                }
	                return midPoint;
	            } else if (event[comparitor] < time && nextEvent[comparitor] > time) {
	                return midPoint;
	            } else if (event[comparitor] > time) {
	                //search lower
	                end = midPoint;
	            } else {
	                //search upper
	                beginning = midPoint + 1;
	            }
	        }
	        return -1;
	    };
	    /**
		 *  Internal iterator. Applies extra safety checks for 
		 *  removing items from the array. 
		 *  @param  {Function}  callback 
		 *  @param  {Number=}    lowerBound     
		 *  @param  {Number=}    upperBound    
		 *  @private
		 */
	    Tone.Timeline.prototype._iterate = function (callback, lowerBound, upperBound) {
	        this._iterating = true;
	        lowerBound = Tone.defaultArg(lowerBound, 0);
	        upperBound = Tone.defaultArg(upperBound, this._timeline.length - 1);
	        for (var i = lowerBound; i <= upperBound; i++) {
	            callback.call(this, this._timeline[i]);
	        }
	        this._iterating = false;
	        if (this._toRemove.length > 0) {
	            for (var j = 0; j < this._toRemove.length; j++) {
	                var index = this._timeline.indexOf(this._toRemove[j]);
	                if (index !== -1) {
	                    this._timeline.splice(index, 1);
	                }
	            }
	            this._toRemove = [];
	        }
	    };
	    /**
		 *  Iterate over everything in the array
		 *  @param  {Function}  callback The callback to invoke with every item
		 *  @returns {Tone.Timeline} this
		 */
	    Tone.Timeline.prototype.forEach = function (callback) {
	        this._iterate(callback);
	        return this;
	    };
	    /**
		 *  Iterate over everything in the array at or before the given time.
		 *  @param  {Number}  time The time to check if items are before
		 *  @param  {Function}  callback The callback to invoke with every item
		 *  @returns {Tone.Timeline} this
		 */
	    Tone.Timeline.prototype.forEachBefore = function (time, callback) {
	        //iterate over the items in reverse so that removing an item doesn't break things
	        var upperBound = this._search(time);
	        if (upperBound !== -1) {
	            this._iterate(callback, 0, upperBound);
	        }
	        return this;
	    };
	    /**
		 *  Iterate over everything in the array after the given time.
		 *  @param  {Number}  time The time to check if items are before
		 *  @param  {Function}  callback The callback to invoke with every item
		 *  @returns {Tone.Timeline} this
		 */
	    Tone.Timeline.prototype.forEachAfter = function (time, callback) {
	        //iterate over the items in reverse so that removing an item doesn't break things
	        var lowerBound = this._search(time);
	        this._iterate(callback, lowerBound + 1);
	        return this;
	    };
	    /**
		 *  Iterate over everything in the array at or after the given time. Similar to 
		 *  forEachAfter, but includes the item(s) at the given time.
		 *  @param  {Number}  time The time to check if items are before
		 *  @param  {Function}  callback The callback to invoke with every item
		 *  @returns {Tone.Timeline} this
		 */
	    Tone.Timeline.prototype.forEachFrom = function (time, callback) {
	        //iterate over the items in reverse so that removing an item doesn't break things
	        var lowerBound = this._search(time);
	        //work backwards until the event time is less than time
	        while (lowerBound >= 0 && this._timeline[lowerBound].time >= time) {
	            lowerBound--;
	        }
	        this._iterate(callback, lowerBound + 1);
	        return this;
	    };
	    /**
		 *  Iterate over everything in the array at the given time
		 *  @param  {Number}  time The time to check if items are before
		 *  @param  {Function}  callback The callback to invoke with every item
		 *  @returns {Tone.Timeline} this
		 */
	    Tone.Timeline.prototype.forEachAtTime = function (time, callback) {
	        //iterate over the items in reverse so that removing an item doesn't break things
	        var upperBound = this._search(time);
	        if (upperBound !== -1) {
	            this._iterate(function (event) {
	                if (event.time === time) {
	                    callback.call(this, event);
	                }
	            }, 0, upperBound);
	        }
	        return this;
	    };
	    /**
		 *  Clean up.
		 *  @return  {Tone.Timeline}  this
		 */
	    Tone.Timeline.prototype.dispose = function () {
	        Tone.prototype.dispose.call(this);
	        this._timeline = null;
	        this._toRemove = null;
	        return this;
	    };
	    return Tone.Timeline;
	});
	Module(function (Tone) {
	    /**
		 *  shim
		 *  @private
		 */
	    if (!window.hasOwnProperty('AudioContext') && window.hasOwnProperty('webkitAudioContext')) {
	        window.AudioContext = window.webkitAudioContext;
	    }
	    /**
		 *  @class Wrapper around the native AudioContext.
		 *  @extends {Tone.Emitter}
		 *  @param {AudioContext=} context optionally pass in a context
		 */
	    Tone.Context = function () {
	        Tone.Emitter.call(this);
	        var options = Tone.defaults(arguments, ['context'], Tone.Context);
	        if (!options.context) {
	            options.context = new window.AudioContext();
	        }
	        this._context = options.context;
	        // extend all of the methods
	        for (var prop in this._context) {
	            this._defineProperty(this._context, prop);
	        }
	        /**
			 *  The default latency hint
			 *  @type  {String}
			 *  @private
			 */
	        this._latencyHint = options.latencyHint;
	        /**
			 *  An object containing all of the constants AudioBufferSourceNodes
			 *  @type  {Object}
			 *  @private
			 */
	        this._constants = {};
	        ///////////////////////////////////////////////////////////////////////
	        // WORKER
	        ///////////////////////////////////////////////////////////////////////
	        /**
			 *  The amount of time events are scheduled
			 *  into the future
			 *  @type  {Number}
			 *  @private
			 */
	        this.lookAhead = options.lookAhead;
	        /**
			 *  A reference to the actual computed update interval
			 *  @type  {Number}
			 *  @private
			 */
	        this._computedUpdateInterval = 0;
	        /**
			 *  A reliable callback method
			 *  @private
			 *  @type  {Ticker}
			 */
	        this._ticker = new Ticker(this.emit.bind(this, 'tick'), options.clockSource, options.updateInterval);
	        ///////////////////////////////////////////////////////////////////////
	        // TIMEOUTS
	        ///////////////////////////////////////////////////////////////////////
	        /**
			 *  All of the setTimeout events.
			 *  @type  {Tone.Timeline}
			 *  @private
			 */
	        this._timeouts = new Tone.Timeline();
	        /**
			 *  The timeout id counter
			 *  @private
			 *  @type {Number}
			 */
	        this._timeoutIds = 0;
	        this.on('tick', this._timeoutLoop.bind(this));
	    };
	    Tone.extend(Tone.Context, Tone.Emitter);
	    Tone.Emitter.mixin(Tone.Context);
	    /**
		 * defaults
		 * @static
		 * @type {Object}
		 */
	    Tone.Context.defaults = {
	        'clockSource': 'worker',
	        'latencyHint': 'interactive',
	        'lookAhead': 0.1,
	        'updateInterval': 0.03
	    };
	    /**
		 *  Define a property on this Tone.Context. 
		 *  This is used to extend the native AudioContext
		 *  @param  {AudioContext}  context
		 *  @param  {String}  prop 
		 *  @private
		 */
	    Tone.Context.prototype._defineProperty = function (context, prop) {
	        if (Tone.isUndef(this[prop])) {
	            Object.defineProperty(this, prop, {
	                get: function () {
	                    if (typeof context[prop] === 'function') {
	                        return context[prop].bind(context);
	                    } else {
	                        return context[prop];
	                    }
	                },
	                set: function (val) {
	                    context[prop] = val;
	                }
	            });
	        }
	    };
	    /**
		 *  The current audio context time
		 *  @return  {Number}
		 */
	    Tone.Context.prototype.now = function () {
	        return this._context.currentTime + this.lookAhead;
	    };
	    /**
		 *  Generate a looped buffer at some constant value.
		 *  @param  {Number}  val
		 *  @return  {BufferSourceNode}
		 */
	    Tone.Context.prototype.getConstant = function (val) {
	        if (this._constants[val]) {
	            return this._constants[val];
	        } else {
	            var buffer = this._context.createBuffer(1, 128, this._context.sampleRate);
	            var arr = buffer.getChannelData(0);
	            for (var i = 0; i < arr.length; i++) {
	                arr[i] = val;
	            }
	            var constant = this._context.createBufferSource();
	            constant.channelCount = 1;
	            constant.channelCountMode = 'explicit';
	            constant.buffer = buffer;
	            constant.loop = true;
	            constant.start(0);
	            this._constants[val] = constant;
	            return constant;
	        }
	    };
	    /**
		 *  The private loop which keeps track of the context scheduled timeouts
		 *  Is invoked from the clock source
		 *  @private
		 */
	    Tone.Context.prototype._timeoutLoop = function () {
	        var now = this.now();
	        while (this._timeouts && this._timeouts.length && this._timeouts.peek().time <= now) {
	            this._timeouts.shift().callback();
	        }
	    };
	    /**
		 *  A setTimeout which is gaurenteed by the clock source. 
		 *  Also runs in the offline context.
		 *  @param  {Function}  fn       The callback to invoke
		 *  @param  {Seconds}    timeout  The timeout in seconds
		 *  @returns {Number} ID to use when invoking Tone.Context.clearTimeout
		 */
	    Tone.Context.prototype.setTimeout = function (fn, timeout) {
	        this._timeoutIds++;
	        var now = this.now();
	        this._timeouts.add({
	            callback: fn,
	            time: now + timeout,
	            id: this._timeoutIds
	        });
	        return this._timeoutIds;
	    };
	    /**
		 *  Clears a previously scheduled timeout with Tone.context.setTimeout
		 *  @param  {Number}  id  The ID returned from setTimeout
		 *  @return  {Tone.Context}  this
		 */
	    Tone.Context.prototype.clearTimeout = function (id) {
	        this._timeouts.forEach(function (event) {
	            if (event.id === id) {
	                this.remove(event);
	            }
	        });
	        return this;
	    };
	    /**
		 *  How often the Web Worker callback is invoked.
		 *  This number corresponds to how responsive the scheduling
		 *  can be. Context.updateInterval + Context.lookAhead gives you the
		 *  total latency between scheduling an event and hearing it.
		 *  @type {Number}
		 *  @memberOf Tone.Context#
		 *  @name updateInterval
		 */
	    Object.defineProperty(Tone.Context.prototype, 'updateInterval', {
	        get: function () {
	            return this._ticker.updateInterval;
	        },
	        set: function (interval) {
	            this._ticker.updateInterval = interval;
	        }
	    });
	    /**
		 *  What the source of the clock is, either "worker" (Web Worker [default]), 
		 *  "timeout" (setTimeout), or "offline" (none). 
		 *  @type {String}
		 *  @memberOf Tone.Context#
		 *  @name clockSource
		 */
	    Object.defineProperty(Tone.Context.prototype, 'clockSource', {
	        get: function () {
	            return this._ticker.type;
	        },
	        set: function (type) {
	            this._ticker.type = type;
	        }
	    });
	    /**
		 *  The type of playback, which affects tradeoffs between audio 
		 *  output latency and responsiveness. 
		 *  
		 *  In addition to setting the value in seconds, the latencyHint also
		 *  accepts the strings "interactive" (prioritizes low latency), 
		 *  "playback" (prioritizes sustained playback), "balanced" (balances
		 *  latency and performance), and "fastest" (lowest latency, might glitch more often). 
		 *  @type {String|Seconds}
		 *  @memberOf Tone.Context#
		 *  @name latencyHint
		 *  @example
		 * //set the lookAhead to 0.3 seconds
		 * Tone.context.latencyHint = 0.3;
		 */
	    Object.defineProperty(Tone.Context.prototype, 'latencyHint', {
	        get: function () {
	            return this._latencyHint;
	        },
	        set: function (hint) {
	            var lookAhead = hint;
	            this._latencyHint = hint;
	            if (Tone.isString(hint)) {
	                switch (hint) {
	                case 'interactive':
	                    lookAhead = 0.1;
	                    this._context.latencyHint = hint;
	                    break;
	                case 'playback':
	                    lookAhead = 0.8;
	                    this._context.latencyHint = hint;
	                    break;
	                case 'balanced':
	                    lookAhead = 0.25;
	                    this._context.latencyHint = hint;
	                    break;
	                case 'fastest':
	                    this._context.latencyHint = 'interactive';
	                    lookAhead = 0.01;
	                    break;
	                }
	            }
	            this.lookAhead = lookAhead;
	            this.updateInterval = lookAhead / 3;
	        }
	    });
	    /**
		 *  Clean up
		 *  @returns {Tone.Context} this
		 */
	    Tone.Context.prototype.dispose = function () {
	        Tone.Context.emit('close', this);
	        Tone.Emitter.prototype.dispose.call(this);
	        this._ticker.dispose();
	        this._ticker = null;
	        this._timeouts.dispose();
	        this._timeouts = null;
	        for (var con in this._constants) {
	            this._constants[con].disconnect();
	        }
	        this._constants = null;
	        this.close();
	        return this;
	    };
	    /**
		 * @class A class which provides a reliable callback using either
		 *        a Web Worker, or if that isn't supported, falls back to setTimeout.
		 * @private
		 */
	    var Ticker = function (callback, type, updateInterval) {
	        /**
			 * Either "worker" or "timeout"
			 * @type {String}
			 * @private
			 */
	        this._type = type;
	        /**
			 * The update interval of the worker
			 * @private
			 * @type {Number}
			 */
	        this._updateInterval = updateInterval;
	        /**
			 * The callback to invoke at regular intervals
			 * @type {Function}
			 * @private
			 */
	        this._callback = Tone.defaultArg(callback, Tone.noOp);
	        //create the clock source for the first time
	        this._createClock();
	    };
	    /**
		 * The possible ticker types
		 * @private
		 * @type {Object}
		 */
	    Ticker.Type = {
	        Worker: 'worker',
	        Timeout: 'timeout',
	        Offline: 'offline'
	    };
	    /**
		 *  Generate a web worker
		 *  @return  {WebWorker}
		 *  @private
		 */
	    Ticker.prototype._createWorker = function () {
	        //URL Shim
	        window.URL = window.URL || window.webkitURL;
	        var blob = new Blob([//the initial timeout time
	            'var timeoutTime = ' + (this._updateInterval * 1000).toFixed(1) + ';' + //onmessage callback
	            'self.onmessage = function(msg){' + '\ttimeoutTime = parseInt(msg.data);' + '};' + //the tick function which posts a message
	            //and schedules a new tick
	            'function tick(){' + '\tsetTimeout(tick, timeoutTime);' + '\tself.postMessage(\'tick\');' + '}' + //call tick initially
	            'tick();']);
	        var blobUrl = URL.createObjectURL(blob);
	        var worker = new Worker(blobUrl);
	        worker.onmessage = this._callback.bind(this);
	        this._worker = worker;
	    };
	    /**
		 * Create a timeout loop
		 * @private
		 */
	    Ticker.prototype._createTimeout = function () {
	        this._timeout = setTimeout(function () {
	            this._createTimeout();
	            this._callback();
	        }.bind(this), this._updateInterval * 1000);
	    };
	    /**
		 * Create the clock source.
		 * @private
		 */
	    Ticker.prototype._createClock = function () {
	        if (this._type === Ticker.Type.Worker) {
	            try {
	                this._createWorker();
	            } catch (e) {
	                // workers not supported, fallback to timeout
	                this._type = Ticker.Type.Timeout;
	                this._createClock();
	            }
	        } else if (this._type === Ticker.Type.Timeout) {
	            this._createTimeout();
	        }
	    };
	    /**
		 * @memberOf Ticker#
		 * @type {Number}
		 * @name updateInterval
		 * @private
		 */
	    Object.defineProperty(Ticker.prototype, 'updateInterval', {
	        get: function () {
	            return this._updateInterval;
	        },
	        set: function (interval) {
	            this._updateInterval = Math.max(interval, 128 / 44100);
	            if (this._type === Ticker.Type.Worker) {
	                this._worker.postMessage(Math.max(interval * 1000, 1));
	            }
	        }
	    });
	    /**
		 * The type of the ticker, either a worker or a timeout
		 * @memberOf Ticker#
		 * @type {Number}
		 * @name type
		 * @private
		 */
	    Object.defineProperty(Ticker.prototype, 'type', {
	        get: function () {
	            return this._type;
	        },
	        set: function (type) {
	            this._disposeClock();
	            this._type = type;
	            this._createClock();
	        }
	    });
	    /**
		 * Clean up the current clock source
		 * @private
		 */
	    Ticker.prototype._disposeClock = function () {
	        if (this._timeout) {
	            clearTimeout(this._timeout);
	            this._timeout = null;
	        }
	        if (this._worker) {
	            this._worker.terminate();
	            this._worker.onmessage = null;
	            this._worker = null;
	        }
	    };
	    /**
		 * Clean up
		 * @private
		 */
	    Ticker.prototype.dispose = function () {
	        this._disposeClock();
	        this._callback = null;
	    };
	    /**
		 *  Shim all connect/disconnect and some deprecated methods which are still in
		 *  some older implementations.
		 *  @private
		 */
	    Tone.getContext(function () {
	        var nativeConnect = AudioNode.prototype.connect;
	        var nativeDisconnect = AudioNode.prototype.disconnect;
	        //replace the old connect method
	        function toneConnect(B, outNum, inNum) {
	            if (B.input) {
	                inNum = Tone.defaultArg(inNum, 0);
	                if (Tone.isArray(B.input)) {
	                    this.connect(B.input[inNum]);
	                } else {
	                    this.connect(B.input, outNum, inNum);
	                }
	            } else {
	                try {
	                    if (B instanceof AudioNode) {
	                        nativeConnect.call(this, B, outNum, inNum);
	                    } else {
	                        nativeConnect.call(this, B, outNum);
	                    }
	                } catch (e) {
	                    throw new Error('error connecting to node: ' + B + '\n' + e);
	                }
	            }
	        }
	        //replace the old disconnect method
	        function toneDisconnect(B, outNum, inNum) {
	            if (B && B.input && Tone.isArray(B.input)) {
	                inNum = Tone.defaultArg(inNum, 0);
	                this.disconnect(B.input[inNum], outNum, 0);
	            } else if (B && B.input) {
	                this.disconnect(B.input, outNum, inNum);
	            } else {
	                try {
	                    nativeDisconnect.apply(this, arguments);
	                } catch (e) {
	                    throw new Error('error disconnecting node: ' + B + '\n' + e);
	                }
	            }
	        }
	        if (AudioNode.prototype.connect !== toneConnect) {
	            AudioNode.prototype.connect = toneConnect;
	            AudioNode.prototype.disconnect = toneDisconnect;
	        }
	    });
	    // set the audio context initially
	    if (Tone.supported) {
	        Tone.context = new Tone.Context();
	    } else {
	        console.warn('This browser does not support Tone.js');
	    }
	    return Tone.Context;
	});
	Module(function (Tone) {
	    /**
		 *  @class Tone.AudioNode is a base class for classes which process audio.
		 *         AudioNodes have inputs and outputs.
		 *  @param	{AudioContext=} context	The audio context to use with the class
		 *  @extends {Tone}
		 */
	    Tone.AudioNode = function () {
	        Tone.call(this);
	        //use the default context if one is not passed in
	        var options = Tone.defaults(arguments, ['context'], { 'context': Tone.context });
	        /**
			 * The AudioContext of this instance
			 * @private
			 * @type {AudioContext}
			 */
	        this._context = options.context;
	    };
	    Tone.extend(Tone.AudioNode);
	    /**
		 * Get the audio context belonging to this instance.
		 * @type {AudioNode}
		 * @memberOf Tone.AudioNode#
		 * @name context
		 * @readOnly
		 */
	    Object.defineProperty(Tone.AudioNode.prototype, 'context', {
	        get: function () {
	            return this._context;
	        }
	    });
	    /**
		 *  Create input and outputs for this object.
		 *  @param  {Number}  [input=0]   The number of inputs
		 *  @param  {Number}  [outputs=0]  The number of outputs
		 *  @return  {Tone.AudioNode}  this
		 *  @private
		 */
	    Tone.AudioNode.prototype.createInsOuts = function (inputs, outputs) {
	        if (inputs === 1) {
	            this.input = this.context.createGain();
	        } else if (inputs > 1) {
	            this.input = new Array(inputs);
	        }
	        if (outputs === 1) {
	            this.output = this.context.createGain();
	        } else if (outputs > 1) {
	            this.output = new Array(outputs);
	        }
	    };
	    /**
		 *  The number of inputs feeding into the AudioNode.
		 *  For source nodes, this will be 0.
		 *  @type {Number}
		 *  @name numberOfInputs
		 *  @readOnly
		 */
	    Object.defineProperty(Tone.AudioNode.prototype, 'numberOfInputs', {
	        get: function () {
	            if (this.input) {
	                if (Tone.isArray(this.input)) {
	                    return this.input.length;
	                } else {
	                    return 1;
	                }
	            } else {
	                return 0;
	            }
	        }
	    });
	    /**
		 *  The number of outputs coming out of the AudioNode.
		 *  @type {Number}
		 *  @name numberOfOutputs
		 *  @readOnly
		 */
	    Object.defineProperty(Tone.AudioNode.prototype, 'numberOfOutputs', {
	        get: function () {
	            if (this.output) {
	                if (Tone.isArray(this.output)) {
	                    return this.output.length;
	                } else {
	                    return 1;
	                }
	            } else {
	                return 0;
	            }
	        }
	    });
	    /**
		 *  connect the output of a ToneNode to an AudioParam, AudioNode, or ToneNode
		 *  @param  {Tone | AudioParam | AudioNode} unit
		 *  @param {number} [outputNum=0] optionally which output to connect from
		 *  @param {number} [inputNum=0] optionally which input to connect to
		 *  @returns {Tone.AudioNode} this
		 */
	    Tone.AudioNode.prototype.connect = function (unit, outputNum, inputNum) {
	        if (Tone.isArray(this.output)) {
	            outputNum = Tone.defaultArg(outputNum, 0);
	            this.output[outputNum].connect(unit, 0, inputNum);
	        } else {
	            this.output.connect(unit, outputNum, inputNum);
	        }
	        return this;
	    };
	    /**
		 *  disconnect the output
		 *  @param {Number|AudioNode} output Either the output index to disconnect
		 *                                   if the output is an array, or the
		 *                                   node to disconnect from.
		 *  @returns {Tone.AudioNode} this
		 */
	    Tone.AudioNode.prototype.disconnect = function (destination, outputNum, inputNum) {
	        if (Tone.isArray(this.output)) {
	            if (Tone.isNumber(destination)) {
	                this.output[destination].disconnect();
	            } else {
	                outputNum = Tone.defaultArg(outputNum, 0);
	                this.output[outputNum].disconnect(destination, 0, inputNum);
	            }
	        } else {
	            this.output.disconnect.apply(this.output, arguments);
	        }
	    };
	    /**
		 *  Connect the output of this node to the rest of the nodes in series.
		 *  @example
		 *  //connect a node to an effect, panVol and then to the master output
		 *  node.chain(effect, panVol, Tone.Master);
		 *  @param {...AudioParam|Tone|AudioNode} nodes
		 *  @returns {Tone.AudioNode} this
		 */
	    Tone.AudioNode.prototype.chain = function () {
	        var currentUnit = this;
	        for (var i = 0; i < arguments.length; i++) {
	            var toUnit = arguments[i];
	            currentUnit.connect(toUnit);
	            currentUnit = toUnit;
	        }
	        return this;
	    };
	    /**
		 *  connect the output of this node to the rest of the nodes in parallel.
		 *  @param {...AudioParam|Tone|AudioNode} nodes
		 *  @returns {Tone.AudioNode} this
		 */
	    Tone.AudioNode.prototype.fan = function () {
	        for (var i = 0; i < arguments.length; i++) {
	            this.connect(arguments[i]);
	        }
	        return this;
	    };
	    if (window.AudioNode) {
	        //give native nodes chain and fan methods
	        AudioNode.prototype.chain = Tone.AudioNode.prototype.chain;
	        AudioNode.prototype.fan = Tone.AudioNode.prototype.fan;
	    }
	    /**
		 * Dispose and disconnect
		 * @return {Tone.AudioNode} this
		 */
	    Tone.AudioNode.prototype.dispose = function () {
	        if (!Tone.isUndef(this.input)) {
	            if (this.input instanceof AudioNode) {
	                this.input.disconnect();
	            }
	            this.input = null;
	        }
	        if (!Tone.isUndef(this.output)) {
	            if (this.output instanceof AudioNode) {
	                this.output.disconnect();
	            }
	            this.output = null;
	        }
	        this._context = null;
	        return this;
	    };
	    return Tone.AudioNode;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class  Base class for all Signals. Used Internally.
		 *
		 *  @constructor
		 *  @extends {Tone}
		 */
	    Tone.SignalBase = function () {
	        Tone.AudioNode.call(this);
	    };
	    Tone.extend(Tone.SignalBase, Tone.AudioNode);
	    /**
		 *  When signals connect to other signals or AudioParams,
		 *  they take over the output value of that signal or AudioParam.
		 *  For all other nodes, the behavior is the same as a default <code>connect</code>.
		 *
		 *  @override
		 *  @param {AudioParam|AudioNode|Tone.Signal|Tone} node
		 *  @param {number} [outputNumber=0] The output number to connect from.
		 *  @param {number} [inputNumber=0] The input number to connect to.
		 *  @returns {Tone.SignalBase} this
		 */
	    Tone.SignalBase.prototype.connect = function (node, outputNumber, inputNumber) {
	        //zero it out so that the signal can have full control
	        if (Tone.Signal && Tone.Signal === node.constructor || Tone.Param && Tone.Param === node.constructor || Tone.TimelineSignal && Tone.TimelineSignal === node.constructor) {
	            //cancel changes
	            node._param.cancelScheduledValues(0);
	            //reset the value
	            node._param.value = 0;
	            //mark the value as overridden
	            node.overridden = true;
	        } else if (node instanceof AudioParam) {
	            node.cancelScheduledValues(0);
	            node.value = 0;
	        }
	        Tone.AudioNode.prototype.connect.call(this, node, outputNumber, inputNumber);
	        return this;
	    };
	    return Tone.SignalBase;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Wraps the native Web Audio API 
		 *         [WaveShaperNode](http://webaudio.github.io/web-audio-api/#the-waveshapernode-interface).
		 *
		 *  @extends {Tone.SignalBase}
		 *  @constructor
		 *  @param {function|Array|Number} mapping The function used to define the values. 
		 *                                    The mapping function should take two arguments: 
		 *                                    the first is the value at the current position 
		 *                                    and the second is the array position. 
		 *                                    If the argument is an array, that array will be
		 *                                    set as the wave shaping function. The input
		 *                                    signal is an AudioRange [-1, 1] value and the output
		 *                                    signal can take on any numerical values. 
		 *                                    
		 *  @param {Number} [bufferLen=1024] The length of the WaveShaperNode buffer.
		 *  @example
		 * var timesTwo = new Tone.WaveShaper(function(val){
		 * 	return val * 2;
		 * }, 2048);
		 *  @example
		 * //a waveshaper can also be constructed with an array of values
		 * var invert = new Tone.WaveShaper([1, -1]);
		 */
	    Tone.WaveShaper = function (mapping, bufferLen) {
	        Tone.SignalBase.call(this);
	        /**
			 *  the waveshaper
			 *  @type {WaveShaperNode}
			 *  @private
			 */
	        this._shaper = this.input = this.output = this.context.createWaveShaper();
	        /**
			 *  the waveshapers curve
			 *  @type {Float32Array}
			 *  @private
			 */
	        this._curve = null;
	        if (Array.isArray(mapping)) {
	            this.curve = mapping;
	        } else if (isFinite(mapping) || Tone.isUndef(mapping)) {
	            this._curve = new Float32Array(Tone.defaultArg(mapping, 1024));
	        } else if (Tone.isFunction(mapping)) {
	            this._curve = new Float32Array(Tone.defaultArg(bufferLen, 1024));
	            this.setMap(mapping);
	        }
	    };
	    Tone.extend(Tone.WaveShaper, Tone.SignalBase);
	    /**
		 *  Uses a mapping function to set the value of the curve. 
		 *  @param {function} mapping The function used to define the values. 
		 *                            The mapping function take two arguments: 
		 *                            the first is the value at the current position 
		 *                            which goes from -1 to 1 over the number of elements
		 *                            in the curve array. The second argument is the array position. 
		 *  @returns {Tone.WaveShaper} this
		 *  @example
		 * //map the input signal from [-1, 1] to [0, 10]
		 * shaper.setMap(function(val, index){
		 * 	return (val + 1) * 5;
		 * })
		 */
	    Tone.WaveShaper.prototype.setMap = function (mapping) {
	        for (var i = 0, len = this._curve.length; i < len; i++) {
	            var normalized = i / (len - 1) * 2 - 1;
	            this._curve[i] = mapping(normalized, i);
	        }
	        this._shaper.curve = this._curve;
	        return this;
	    };
	    /**
		 * The array to set as the waveshaper curve. For linear curves
		 * array length does not make much difference, but for complex curves
		 * longer arrays will provide smoother interpolation. 
		 * @memberOf Tone.WaveShaper#
		 * @type {Array}
		 * @name curve
		 */
	    Object.defineProperty(Tone.WaveShaper.prototype, 'curve', {
	        get: function () {
	            return this._shaper.curve;
	        },
	        set: function (mapping) {
	            this._curve = new Float32Array(mapping);
	            this._shaper.curve = this._curve;
	        }
	    });
	    /**
		 * Specifies what type of oversampling (if any) should be used when 
		 * applying the shaping curve. Can either be "none", "2x" or "4x". 
		 * @memberOf Tone.WaveShaper#
		 * @type {string}
		 * @name oversample
		 */
	    Object.defineProperty(Tone.WaveShaper.prototype, 'oversample', {
	        get: function () {
	            return this._shaper.oversample;
	        },
	        set: function (oversampling) {
	            if ([
	                    'none',
	                    '2x',
	                    '4x'
	                ].indexOf(oversampling) !== -1) {
	                this._shaper.oversample = oversampling;
	            } else {
	                throw new RangeError('Tone.WaveShaper: oversampling must be either \'none\', \'2x\', or \'4x\'');
	            }
	        }
	    });
	    /**
		 *  Clean up.
		 *  @returns {Tone.WaveShaper} this
		 */
	    Tone.WaveShaper.prototype.dispose = function () {
	        Tone.SignalBase.prototype.dispose.call(this);
	        this._shaper.disconnect();
	        this._shaper = null;
	        this._curve = null;
	        return this;
	    };
	    return Tone.WaveShaper;
	});
	Module(function (Tone) {
	    /**
		 *  @class Tone.TimeBase is a flexible encoding of time
		 *         which can be evaluated to and from a string.
		 *         Parsing code modified from https://code.google.com/p/tapdigit/
		 *         Copyright 2011 2012 Ariya Hidayat, New BSD License
		 *  @extends {Tone}
		 *  @param  {Time}  val    The time value as a number or string
		 *  @param  {String=}  units  Unit values
		 *  @example
		 * Tone.TimeBase(4, "n")
		 * Tone.TimeBase(2, "t")
		 * Tone.TimeBase("2t").add("1m")
		 * Tone.TimeBase("2t + 1m");
		 */
	    Tone.TimeBase = function (val, units) {
	        //allows it to be constructed with or without 'new'
	        if (this instanceof Tone.TimeBase) {
	            /**
				 *  Any expressions parsed from the Time
				 *  @type  {Array}
				 *  @private
				 */
	            this._expr = this._noOp;
	            if (val instanceof Tone.TimeBase) {
	                this.copy(val);
	            } else if (!Tone.isUndef(units) || Tone.isNumber(val)) {
	                //default units
	                units = Tone.defaultArg(units, this._defaultUnits);
	                var method = this._primaryExpressions[units].method;
	                this._expr = method.bind(this, val);
	            } else if (Tone.isString(val)) {
	                this.set(val);
	            } else if (Tone.isUndef(val)) {
	                //default expression
	                this._expr = this._defaultExpr();
	            }
	        } else {
	            return new Tone.TimeBase(val, units);
	        }
	    };
	    Tone.extend(Tone.TimeBase);
	    /**
		 *  Repalce the current time value with the value
		 *  given by the expression string.
		 *  @param  {String}  exprString
		 *  @return {Tone.TimeBase} this
		 */
	    Tone.TimeBase.prototype.set = function (exprString) {
	        this._expr = this._parseExprString(exprString);
	        return this;
	    };
	    /**
		 *  Return a clone of the TimeBase object.
		 *  @return  {Tone.TimeBase} The new cloned Tone.TimeBase
		 */
	    Tone.TimeBase.prototype.clone = function () {
	        var instance = new this.constructor();
	        instance.copy(this);
	        return instance;
	    };
	    /**
		 *  Copies the value of time to this Time
		 *  @param {Tone.TimeBase} time
		 *  @return  {TimeBase}
		 */
	    Tone.TimeBase.prototype.copy = function (time) {
	        var val = time._expr();
	        return this.set(val);
	    };
	    ///////////////////////////////////////////////////////////////////////////
	    //	ABSTRACT SYNTAX TREE PARSER
	    ///////////////////////////////////////////////////////////////////////////
	    /**
		 *  All the primary expressions.
		 *  @private
		 *  @type  {Object}
		 */
	    Tone.TimeBase.prototype._primaryExpressions = {
	        'n': {
	            regexp: /^(\d+)n/i,
	            method: function (value) {
	                value = parseInt(value);
	                if (value === 1) {
	                    return this._beatsToUnits(this._timeSignature());
	                } else {
	                    return this._beatsToUnits(4 / value);
	                }
	            }
	        },
	        't': {
	            regexp: /^(\d+)t/i,
	            method: function (value) {
	                value = parseInt(value);
	                return this._beatsToUnits(8 / (parseInt(value) * 3));
	            }
	        },
	        'm': {
	            regexp: /^(\d+)m/i,
	            method: function (value) {
	                return this._beatsToUnits(parseInt(value) * this._timeSignature());
	            }
	        },
	        'i': {
	            regexp: /^(\d+)i/i,
	            method: function (value) {
	                return this._ticksToUnits(parseInt(value));
	            }
	        },
	        'hz': {
	            regexp: /^(\d+(?:\.\d+)?)hz/i,
	            method: function (value) {
	                return this._frequencyToUnits(parseFloat(value));
	            }
	        },
	        'tr': {
	            regexp: /^(\d+(?:\.\d+)?):(\d+(?:\.\d+)?):?(\d+(?:\.\d+)?)?/,
	            method: function (m, q, s) {
	                var total = 0;
	                if (m && m !== '0') {
	                    total += this._beatsToUnits(this._timeSignature() * parseFloat(m));
	                }
	                if (q && q !== '0') {
	                    total += this._beatsToUnits(parseFloat(q));
	                }
	                if (s && s !== '0') {
	                    total += this._beatsToUnits(parseFloat(s) / 4);
	                }
	                return total;
	            }
	        },
	        's': {
	            regexp: /^(\d+(?:\.\d+)?s)/,
	            method: function (value) {
	                return this._secondsToUnits(parseFloat(value));
	            }
	        },
	        'samples': {
	            regexp: /^(\d+)samples/,
	            method: function (value) {
	                return parseInt(value) / this.context.sampleRate;
	            }
	        },
	        'default': {
	            regexp: /^(\d+(?:\.\d+)?)/,
	            method: function (value) {
	                return this._primaryExpressions[this._defaultUnits].method.call(this, value);
	            }
	        }
	    };
	    /**
		 *  All the binary expressions that TimeBase can accept.
		 *  @private
		 *  @type  {Object}
		 */
	    Tone.TimeBase.prototype._binaryExpressions = {
	        '+': {
	            regexp: /^\+/,
	            precedence: 2,
	            method: function (lh, rh) {
	                return lh() + rh();
	            }
	        },
	        '-': {
	            regexp: /^\-/,
	            precedence: 2,
	            method: function (lh, rh) {
	                return lh() - rh();
	            }
	        },
	        '*': {
	            regexp: /^\*/,
	            precedence: 1,
	            method: function (lh, rh) {
	                return lh() * rh();
	            }
	        },
	        '/': {
	            regexp: /^\//,
	            precedence: 1,
	            method: function (lh, rh) {
	                return lh() / rh();
	            }
	        }
	    };
	    /**
		 *  All the unary expressions.
		 *  @private
		 *  @type  {Object}
		 */
	    Tone.TimeBase.prototype._unaryExpressions = {
	        'neg': {
	            regexp: /^\-/,
	            method: function (lh) {
	                return -lh();
	            }
	        }
	    };
	    /**
		 *  Syntactic glue which holds expressions together
		 *  @private
		 *  @type  {Object}
		 */
	    Tone.TimeBase.prototype._syntaxGlue = {
	        '(': { regexp: /^\(/ },
	        ')': { regexp: /^\)/ }
	    };
	    /**
		 *  tokenize the expression based on the Expressions object
		 *  @param   {string} expr 
		 *  @return  {Object}      returns two methods on the tokenized list, next and peek
		 *  @private
		 */
	    Tone.TimeBase.prototype._tokenize = function (expr) {
	        var position = -1;
	        var tokens = [];
	        while (expr.length > 0) {
	            expr = expr.trim();
	            var token = getNextToken(expr, this);
	            tokens.push(token);
	            expr = expr.substr(token.value.length);
	        }
	        function getNextToken(expr, context) {
	            var expressions = [
	                '_binaryExpressions',
	                '_unaryExpressions',
	                '_primaryExpressions',
	                '_syntaxGlue'
	            ];
	            for (var i = 0; i < expressions.length; i++) {
	                var group = context[expressions[i]];
	                for (var opName in group) {
	                    var op = group[opName];
	                    var reg = op.regexp;
	                    var match = expr.match(reg);
	                    if (match !== null) {
	                        return {
	                            method: op.method,
	                            precedence: op.precedence,
	                            regexp: op.regexp,
	                            value: match[0]
	                        };
	                    }
	                }
	            }
	            throw new SyntaxError('Tone.TimeBase: Unexpected token ' + expr);
	        }
	        return {
	            next: function () {
	                return tokens[++position];
	            },
	            peek: function () {
	                return tokens[position + 1];
	            }
	        };
	    };
	    /**
		 *  Given a token, find the value within the groupName
		 *  @param {Object} token
		 *  @param {String} groupName
		 *  @param {Number} precedence
		 *  @private
		 */
	    Tone.TimeBase.prototype._matchGroup = function (token, group, prec) {
	        var ret = false;
	        if (!Tone.isUndef(token)) {
	            for (var opName in group) {
	                var op = group[opName];
	                if (op.regexp.test(token.value)) {
	                    if (!Tone.isUndef(prec)) {
	                        if (op.precedence === prec) {
	                            return op;
	                        }
	                    } else {
	                        return op;
	                    }
	                }
	            }
	        }
	        return ret;
	    };
	    /**
		 *  Match a binary expression given the token and the precedence
		 *  @param {Lexer} lexer
		 *  @param {Number} precedence
		 *  @private
		 */
	    Tone.TimeBase.prototype._parseBinary = function (lexer, precedence) {
	        if (Tone.isUndef(precedence)) {
	            precedence = 2;
	        }
	        var expr;
	        if (precedence < 0) {
	            expr = this._parseUnary(lexer);
	        } else {
	            expr = this._parseBinary(lexer, precedence - 1);
	        }
	        var token = lexer.peek();
	        while (token && this._matchGroup(token, this._binaryExpressions, precedence)) {
	            token = lexer.next();
	            expr = token.method.bind(this, expr, this._parseBinary(lexer, precedence - 1));
	            token = lexer.peek();
	        }
	        return expr;
	    };
	    /**
		 *  Match a unary expression.
		 *  @param {Lexer} lexer
		 *  @private
		 */
	    Tone.TimeBase.prototype._parseUnary = function (lexer) {
	        var token, expr;
	        token = lexer.peek();
	        var op = this._matchGroup(token, this._unaryExpressions);
	        if (op) {
	            token = lexer.next();
	            expr = this._parseUnary(lexer);
	            return op.method.bind(this, expr);
	        }
	        return this._parsePrimary(lexer);
	    };
	    /**
		 *  Match a primary expression (a value).
		 *  @param {Lexer} lexer
		 *  @private
		 */
	    Tone.TimeBase.prototype._parsePrimary = function (lexer) {
	        var token, expr;
	        token = lexer.peek();
	        if (Tone.isUndef(token)) {
	            throw new SyntaxError('Tone.TimeBase: Unexpected end of expression');
	        }
	        if (this._matchGroup(token, this._primaryExpressions)) {
	            token = lexer.next();
	            var matching = token.value.match(token.regexp);
	            return token.method.bind(this, matching[1], matching[2], matching[3]);
	        }
	        if (token && token.value === '(') {
	            lexer.next();
	            expr = this._parseBinary(lexer);
	            token = lexer.next();
	            if (!(token && token.value === ')')) {
	                throw new SyntaxError('Expected )');
	            }
	            return expr;
	        }
	        throw new SyntaxError('Tone.TimeBase: Cannot process token ' + token.value);
	    };
	    /**
		 *  Recursively parse the string expression into a syntax tree.
		 *  @param   {string} expr 
		 *  @return  {Function} the bound method to be evaluated later
		 *  @private
		 */
	    Tone.TimeBase.prototype._parseExprString = function (exprString) {
	        if (!Tone.isString(exprString)) {
	            exprString = exprString.toString();
	        }
	        var lexer = this._tokenize(exprString);
	        var tree = this._parseBinary(lexer);
	        return tree;
	    };
	    ///////////////////////////////////////////////////////////////////////////
	    //	DEFAULTS
	    ///////////////////////////////////////////////////////////////////////////
	    /**
		 *  The initial expression value
		 *  @return  {Number}  The initial value 0
		 *  @private
		 */
	    Tone.TimeBase.prototype._noOp = function () {
	        return 0;
	    };
	    /**
		 *  The default expression value if no arguments are given
		 *  @private
		 */
	    Tone.TimeBase.prototype._defaultExpr = function () {
	        return this._noOp;
	    };
	    /**
		 *  The default units if none are given.
		 *  @private
		 */
	    Tone.TimeBase.prototype._defaultUnits = 's';
	    ///////////////////////////////////////////////////////////////////////////
	    //	UNIT CONVERSIONS
	    ///////////////////////////////////////////////////////////////////////////
	    /**
		 *  Returns the value of a frequency in the current units
		 *  @param {Frequency} freq
		 *  @return  {Number}
		 *  @private
		 */
	    Tone.TimeBase.prototype._frequencyToUnits = function (freq) {
	        return 1 / freq;
	    };
	    /**
		 *  Return the value of the beats in the current units
		 *  @param {Number} beats
		 *  @return  {Number}
		 *  @private
		 */
	    Tone.TimeBase.prototype._beatsToUnits = function (beats) {
	        return 60 / Tone.Transport.bpm.value * beats;
	    };
	    /**
		 *  Returns the value of a second in the current units
		 *  @param {Seconds} seconds
		 *  @return  {Number}
		 *  @private
		 */
	    Tone.TimeBase.prototype._secondsToUnits = function (seconds) {
	        return seconds;
	    };
	    /**
		 *  Returns the value of a tick in the current time units
		 *  @param {Ticks} ticks
		 *  @return  {Number}
		 *  @private
		 */
	    Tone.TimeBase.prototype._ticksToUnits = function (ticks) {
	        return ticks * (this._beatsToUnits(1) / Tone.Transport.PPQ);
	    };
	    /**
		 *  Return the time signature.
		 *  @return  {Number}
		 *  @private
		 */
	    Tone.TimeBase.prototype._timeSignature = function () {
	        return Tone.Transport.timeSignature;
	    };
	    ///////////////////////////////////////////////////////////////////////////
	    //	EXPRESSIONS
	    ///////////////////////////////////////////////////////////////////////////
	    /**
		 *  Push an expression onto the expression list
		 *  @param  {Time}  val
		 *  @param  {String}  type
		 *  @param  {String}  units
		 *  @return  {Tone.TimeBase} 
		 *  @private
		 */
	    Tone.TimeBase.prototype._pushExpr = function (val, name, units) {
	        //create the expression
	        if (!(val instanceof Tone.TimeBase)) {
	            val = new this.constructor(val, units);
	        }
	        this._expr = this._binaryExpressions[name].method.bind(this, this._expr, val._expr);
	        return this;
	    };
	    /**
		 *  Add to the current value.
		 *  @param  {Time}  val    The value to add
		 *  @param  {String=}  units  Optional units to use with the value.
		 *  @return  {Tone.TimeBase}  this
		 *  @example
		 * Tone.TimeBase("2m").add("1m"); //"3m"
		 */
	    Tone.TimeBase.prototype.add = function (val, units) {
	        return this._pushExpr(val, '+', units);
	    };
	    /**
		 *  Subtract the value from the current time.
		 *  @param  {Time}  val    The value to subtract
		 *  @param  {String=}  units  Optional units to use with the value.
		 *  @return  {Tone.TimeBase}  this
		 *  @example
		 * Tone.TimeBase("2m").sub("1m"); //"1m"
		 */
	    Tone.TimeBase.prototype.sub = function (val, units) {
	        return this._pushExpr(val, '-', units);
	    };
	    /**
		 *  Multiply the current value by the given time.
		 *  @param  {Time}  val    The value to multiply
		 *  @param  {String=}  units  Optional units to use with the value.
		 *  @return  {Tone.TimeBase}  this
		 *  @example
		 * Tone.TimeBase("2m").mult("2"); //"4m"
		 */
	    Tone.TimeBase.prototype.mult = function (val, units) {
	        return this._pushExpr(val, '*', units);
	    };
	    /**
		 *  Divide the current value by the given time.
		 *  @param  {Time}  val    The value to divide by
		 *  @param  {String=}  units  Optional units to use with the value.
		 *  @return  {Tone.TimeBase}  this
		 *  @example
		 * Tone.TimeBase("2m").div(2); //"1m"
		 */
	    Tone.TimeBase.prototype.div = function (val, units) {
	        return this._pushExpr(val, '/', units);
	    };
	    /**
		 *  Evaluate the time value. Returns the time
		 *  in seconds.
		 *  @return  {Seconds} 
		 */
	    Tone.TimeBase.prototype.valueOf = function () {
	        return this._expr();
	    };
	    /**
		 *  Clean up
		 *  @return {Tone.TimeBase} this
		 */
	    Tone.TimeBase.prototype.dispose = function () {
	        this._expr = null;
	    };
	    return Tone.TimeBase;
	});
	Module(function (Tone) {
	    /**
		 *  @class Tone.Time is a primitive type for encoding Time values. 
		 *         Eventually all time values are evaluated to seconds
		 *         using the `eval` method. Tone.Time can be constructed
		 *         with or without the `new` keyword. Tone.Time can be passed
		 *         into the parameter of any method which takes time as an argument. 
		 *  @constructor
		 *  @extends {Tone.TimeBase}
		 *  @param  {String|Number}  val    The time value.
		 *  @param  {String=}  units  The units of the value.
		 *  @example
		 * var t = Tone.Time("4n");//encodes a quarter note
		 * t.mult(4); // multiply that value by 4
		 * t.toNotation(); //returns "1m"
		 */
	    Tone.Time = function (val, units) {
	        if (this instanceof Tone.Time) {
	            /**
				 *  If the current clock time should
				 *  be added to the output
				 *  @type  {Boolean}
				 *  @private
				 */
	            this._plusNow = false;
	            Tone.TimeBase.call(this, val, units);
	        } else {
	            return new Tone.Time(val, units);
	        }
	    };
	    Tone.extend(Tone.Time, Tone.TimeBase);
	    //clone the expressions so that 
	    //we can add more without modifying the original
	    Tone.Time.prototype._unaryExpressions = Object.create(Tone.TimeBase.prototype._unaryExpressions);
	    /*
		 *  Adds an additional unary expression
		 *  which quantizes values to the next subdivision
		 *  @type {Object}
		 *  @private
		 */
	    Tone.Time.prototype._unaryExpressions.quantize = {
	        regexp: /^@/,
	        method: function (rh) {
	            return Tone.Transport.nextSubdivision(rh());
	        }
	    };
	    /*
		 *  Adds an additional unary expression
		 *  which adds the current clock time.
		 *  @type {Object}
		 *  @private
		 */
	    Tone.Time.prototype._unaryExpressions.now = {
	        regexp: /^\+/,
	        method: function (lh) {
	            this._plusNow = true;
	            return lh();
	        }
	    };
	    /**
		 *  Quantize the time by the given subdivision. Optionally add a
		 *  percentage which will move the time value towards the ideal
		 *  quantized value by that percentage. 
		 *  @param  {Number|Time}  val    The subdivision to quantize to
		 *  @param  {NormalRange}  [percent=1]  Move the time value
		 *                                   towards the quantized value by
		 *                                   a percentage.
		 *  @return  {Tone.Time}  this
		 *  @example
		 * Tone.Time(21).quantize(2) //returns 22
		 * Tone.Time(0.6).quantize("4n", 0.5) //returns 0.55
		 */
	    Tone.Time.prototype.quantize = function (subdiv, percent) {
	        percent = Tone.defaultArg(percent, 1);
	        this._expr = function (expr, subdivision, percent) {
	            expr = expr();
	            subdivision = subdivision.toSeconds();
	            var multiple = Math.round(expr / subdivision);
	            var ideal = multiple * subdivision;
	            var diff = ideal - expr;
	            return expr + diff * percent;
	        }.bind(this, this._expr, new this.constructor(subdiv), percent);
	        return this;
	    };
	    /**
		 *  Adds the clock time to the time expression at the 
		 *  moment of evaluation. 
		 *  @return  {Tone.Time}  this
		 */
	    Tone.Time.prototype.addNow = function () {
	        this._plusNow = true;
	        return this;
	    };
	    /**
		 *  Override the default value return when no arguments are passed in.
		 *  The default value is 'now'
		 *  @override
		 *  @private
		 */
	    Tone.Time.prototype._defaultExpr = function () {
	        this._plusNow = true;
	        return this._noOp;
	    };
	    /**
		 *  Copies the value of time to this Time
		 *  @param {Tone.Time} time
		 *  @return  {Time}
		 */
	    Tone.Time.prototype.copy = function (time) {
	        Tone.TimeBase.prototype.copy.call(this, time);
	        this._plusNow = time._plusNow;
	        return this;
	    };
	    //CONVERSIONS//////////////////////////////////////////////////////////////
	    /**
		 *  Convert a Time to Notation. Values will be thresholded to the nearest 128th note. 
		 *  @return {Notation} 
		 *  @example
		 * //if the Transport is at 120bpm:
		 * Tone.Time(2).toNotation();//returns "1m"
		 */
	    Tone.Time.prototype.toNotation = function () {
	        var time = this.toSeconds();
	        var testNotations = [
	            '1m',
	            '2n',
	            '4n',
	            '8n',
	            '16n',
	            '32n',
	            '64n',
	            '128n'
	        ];
	        var retNotation = this._toNotationHelper(time, testNotations);
	        //try the same thing but with tripelets
	        var testTripletNotations = [
	            '1m',
	            '2n',
	            '2t',
	            '4n',
	            '4t',
	            '8n',
	            '8t',
	            '16n',
	            '16t',
	            '32n',
	            '32t',
	            '64n',
	            '64t',
	            '128n'
	        ];
	        var retTripletNotation = this._toNotationHelper(time, testTripletNotations);
	        //choose the simpler expression of the two
	        if (retTripletNotation.split('+').length < retNotation.split('+').length) {
	            return retTripletNotation;
	        } else {
	            return retNotation;
	        }
	    };
	    /**
		 *  Helper method for Tone.toNotation
		 *  @param {Number} units 
		 *  @param {Array} testNotations
		 *  @return {String}
		 *  @private
		 */
	    Tone.Time.prototype._toNotationHelper = function (units, testNotations) {
	        //the threshold is the last value in the array
	        var threshold = this._notationToUnits(testNotations[testNotations.length - 1]);
	        var retNotation = '';
	        for (var i = 0; i < testNotations.length; i++) {
	            var notationTime = this._notationToUnits(testNotations[i]);
	            //account for floating point errors (i.e. round up if the value is 0.999999)
	            var multiple = units / notationTime;
	            var floatingPointError = 0.000001;
	            if (1 - multiple % 1 < floatingPointError) {
	                multiple += floatingPointError;
	            }
	            multiple = Math.floor(multiple);
	            if (multiple > 0) {
	                if (multiple === 1) {
	                    retNotation += testNotations[i];
	                } else {
	                    retNotation += multiple.toString() + '*' + testNotations[i];
	                }
	                units -= multiple * notationTime;
	                if (units < threshold) {
	                    break;
	                } else {
	                    retNotation += ' + ';
	                }
	            }
	        }
	        if (retNotation === '') {
	            retNotation = '0';
	        }
	        return retNotation;
	    };
	    /**
		 *  Convert a notation value to the current units
		 *  @param  {Notation}  notation 
		 *  @return  {Number} 
		 *  @private
		 */
	    Tone.Time.prototype._notationToUnits = function (notation) {
	        var primaryExprs = this._primaryExpressions;
	        var notationExprs = [
	            primaryExprs.n,
	            primaryExprs.t,
	            primaryExprs.m
	        ];
	        for (var i = 0; i < notationExprs.length; i++) {
	            var expr = notationExprs[i];
	            var match = notation.match(expr.regexp);
	            if (match) {
	                return expr.method.call(this, match[1]);
	            }
	        }
	    };
	    /**
		 *  Return the time encoded as Bars:Beats:Sixteenths.
		 *  @return  {BarsBeatsSixteenths}
		 */
	    Tone.Time.prototype.toBarsBeatsSixteenths = function () {
	        var quarterTime = this._beatsToUnits(1);
	        var quarters = this.toSeconds() / quarterTime;
	        var measures = Math.floor(quarters / this._timeSignature());
	        var sixteenths = quarters % 1 * 4;
	        quarters = Math.floor(quarters) % this._timeSignature();
	        sixteenths = sixteenths.toString();
	        if (sixteenths.length > 3) {
	            // the additional parseFloat removes insignificant trailing zeroes
	            sixteenths = parseFloat(parseFloat(sixteenths).toFixed(3));
	        }
	        var progress = [
	            measures,
	            quarters,
	            sixteenths
	        ];
	        return progress.join(':');
	    };
	    /**
		 *  Return the time in ticks.
		 *  @return  {Ticks}
		 */
	    Tone.Time.prototype.toTicks = function () {
	        var quarterTime = this._beatsToUnits(1);
	        var quarters = this.valueOf() / quarterTime;
	        return Math.floor(quarters * Tone.Transport.PPQ);
	    };
	    /**
		 *  Return the time in samples
		 *  @return  {Samples}  
		 */
	    Tone.Time.prototype.toSamples = function () {
	        return this.toSeconds() * this.context.sampleRate;
	    };
	    /**
		 *  Return the time as a frequency value
		 *  @return  {Frequency} 
		 *  @example
		 * Tone.Time(2).toFrequency(); //0.5
		 */
	    Tone.Time.prototype.toFrequency = function () {
	        return 1 / this.toSeconds();
	    };
	    /**
		 *  Return the time in seconds.
		 *  @return  {Seconds} 
		 */
	    Tone.Time.prototype.toSeconds = function () {
	        return this.valueOf();
	    };
	    /**
		 *  Return the time in milliseconds.
		 *  @return  {Milliseconds} 
		 */
	    Tone.Time.prototype.toMilliseconds = function () {
	        return this.toSeconds() * 1000;
	    };
	    /**
		 *  Return the time in seconds.
		 *  @return  {Seconds} 
		 */
	    Tone.Time.prototype.valueOf = function () {
	        var val = this._expr();
	        return val + (this._plusNow ? this.now() : 0);
	    };
	    return Tone.Time;
	});
	Module(function (Tone) {
	    /**
		 *  @class Tone.Frequency is a primitive type for encoding Frequency values.
		 *         Eventually all time values are evaluated to hertz
		 *         using the `eval` method.
		 *  @constructor
		 *  @extends {Tone.TimeBase}
		 *  @param  {String|Number}  val    The time value.
		 *  @param  {String=}  units  The units of the value.
		 *  @example
		 * Tone.Frequency("C3") // 261
		 * Tone.Frequency(38, "midi") //
		 * Tone.Frequency("C3").transpose(4);
		 */
	    Tone.Frequency = function (val, units) {
	        if (this instanceof Tone.Frequency) {
	            Tone.TimeBase.call(this, val, units);
	        } else {
	            return new Tone.Frequency(val, units);
	        }
	    };
	    Tone.extend(Tone.Frequency, Tone.TimeBase);
	    ///////////////////////////////////////////////////////////////////////////
	    //	AUGMENT BASE EXPRESSIONS
	    ///////////////////////////////////////////////////////////////////////////
	    //clone the expressions so that
	    //we can add more without modifying the original
	    Tone.Frequency.prototype._primaryExpressions = Object.create(Tone.TimeBase.prototype._primaryExpressions);
	    /*
		 *  midi type primary expression
		 *  @type {Object}
		 *  @private
		 */
	    Tone.Frequency.prototype._primaryExpressions.midi = {
	        regexp: /^(\d+(?:\.\d+)?midi)/,
	        method: function (value) {
	            return this.midiToFrequency(value);
	        }
	    };
	    /*
		 *  note type primary expression
		 *  @type {Object}
		 *  @private
		 */
	    Tone.Frequency.prototype._primaryExpressions.note = {
	        regexp: /^([a-g]{1}(?:b|#|x|bb)?)(-?[0-9]+)/i,
	        method: function (pitch, octave) {
	            var index = noteToScaleIndex[pitch.toLowerCase()];
	            var noteNumber = index + (parseInt(octave) + 1) * 12;
	            return this.midiToFrequency(noteNumber);
	        }
	    };
	    /*
		 *  BeatsBarsSixteenths type primary expression
		 *  @type {Object}
		 *  @private
		 */
	    Tone.Frequency.prototype._primaryExpressions.tr = {
	        regexp: /^(\d+(?:\.\d+)?):(\d+(?:\.\d+)?):?(\d+(?:\.\d+)?)?/,
	        method: function (m, q, s) {
	            var total = 1;
	            if (m && m !== '0') {
	                total *= this._beatsToUnits(this._timeSignature() * parseFloat(m));
	            }
	            if (q && q !== '0') {
	                total *= this._beatsToUnits(parseFloat(q));
	            }
	            if (s && s !== '0') {
	                total *= this._beatsToUnits(parseFloat(s) / 4);
	            }
	            return total;
	        }
	    };
	    ///////////////////////////////////////////////////////////////////////////
	    //	EXPRESSIONS
	    ///////////////////////////////////////////////////////////////////////////
	    /**
		 *  Transposes the frequency by the given number of semitones.
		 *  @param  {Interval}  interval
		 *  @return  {Tone.Frequency} this
		 *  @example
		 * Tone.Frequency("A4").transpose(3); //"C5"
		 */
	    Tone.Frequency.prototype.transpose = function (interval) {
	        this._expr = function (expr, interval) {
	            var val = expr();
	            return val * Tone.intervalToFrequencyRatio(interval);
	        }.bind(this, this._expr, interval);
	        return this;
	    };
	    /**
		 *  Takes an array of semitone intervals and returns
		 *  an array of frequencies transposed by those intervals.
		 *  @param  {Array}  intervals
		 *  @return  {Tone.Frequency} this
		 *  @example
		 * Tone.Frequency("A4").harmonize([0, 3, 7]); //["A4", "C5", "E5"]
		 */
	    Tone.Frequency.prototype.harmonize = function (intervals) {
	        this._expr = function (expr, intervals) {
	            var val = expr();
	            var ret = [];
	            for (var i = 0; i < intervals.length; i++) {
	                ret[i] = val * Tone.intervalToFrequencyRatio(intervals[i]);
	            }
	            return ret;
	        }.bind(this, this._expr, intervals);
	        return this;
	    };
	    ///////////////////////////////////////////////////////////////////////////
	    //	UNIT CONVERSIONS
	    ///////////////////////////////////////////////////////////////////////////
	    /**
		 *  Return the value of the frequency as a MIDI note
		 *  @return  {MIDI}
		 *  @example
		 * Tone.Frequency("C4").toMidi(); //60
		 */
	    Tone.Frequency.prototype.toMidi = function () {
	        return this.frequencyToMidi(this.valueOf());
	    };
	    /**
		 *  Return the value of the frequency in Scientific Pitch Notation
		 *  @return  {Note}
		 *  @example
		 * Tone.Frequency(69, "midi").toNote(); //"A4"
		 */
	    Tone.Frequency.prototype.toNote = function () {
	        var freq = this.valueOf();
	        var log = Math.log(freq / Tone.Frequency.A4) / Math.LN2;
	        var noteNumber = Math.round(12 * log) + 57;
	        var octave = Math.floor(noteNumber / 12);
	        if (octave < 0) {
	            noteNumber += -12 * octave;
	        }
	        var noteName = scaleIndexToNote[noteNumber % 12];
	        return noteName + octave.toString();
	    };
	    /**
		 *  Return the duration of one cycle in seconds.
		 *  @return  {Seconds}
		 */
	    Tone.Frequency.prototype.toSeconds = function () {
	        return 1 / this.valueOf();
	    };
	    /**
		 *  Return the value in Hertz
		 *  @return  {Frequency}
		 */
	    Tone.Frequency.prototype.toFrequency = function () {
	        return this.valueOf();
	    };
	    /**
		 *  Return the duration of one cycle in ticks
		 *  @return  {Ticks}
		 */
	    Tone.Frequency.prototype.toTicks = function () {
	        var quarterTime = this._beatsToUnits(1);
	        var quarters = this.valueOf() / quarterTime;
	        return Math.floor(quarters * Tone.Transport.PPQ);
	    };
	    ///////////////////////////////////////////////////////////////////////////
	    //	UNIT CONVERSIONS HELPERS
	    ///////////////////////////////////////////////////////////////////////////
	    /**
		 *  Returns the value of a frequency in the current units
		 *  @param {Frequency} freq
		 *  @return  {Number}
		 *  @private
		 */
	    Tone.Frequency.prototype._frequencyToUnits = function (freq) {
	        return freq;
	    };
	    /**
		 *  Returns the value of a tick in the current time units
		 *  @param {Ticks} ticks
		 *  @return  {Number}
		 *  @private
		 */
	    Tone.Frequency.prototype._ticksToUnits = function (ticks) {
	        return 1 / (ticks * 60 / (Tone.Transport.bpm.value * Tone.Transport.PPQ));
	    };
	    /**
		 *  Return the value of the beats in the current units
		 *  @param {Number} beats
		 *  @return  {Number}
		 *  @private
		 */
	    Tone.Frequency.prototype._beatsToUnits = function (beats) {
	        return 1 / Tone.TimeBase.prototype._beatsToUnits.call(this, beats);
	    };
	    /**
		 *  Returns the value of a second in the current units
		 *  @param {Seconds} seconds
		 *  @return  {Number}
		 *  @private
		 */
	    Tone.Frequency.prototype._secondsToUnits = function (seconds) {
	        return 1 / seconds;
	    };
	    /**
		 *  The default units if none are given.
		 *  @private
		 */
	    Tone.Frequency.prototype._defaultUnits = 'hz';
	    ///////////////////////////////////////////////////////////////////////////
	    //	FREQUENCY CONVERSIONS
	    ///////////////////////////////////////////////////////////////////////////
	    /**
		 *  Note to scale index
		 *  @type  {Object}
		 */
	    var noteToScaleIndex = {
	        'cbb': -2,
	        'cb': -1,
	        'c': 0,
	        'c#': 1,
	        'cx': 2,
	        'dbb': 0,
	        'db': 1,
	        'd': 2,
	        'd#': 3,
	        'dx': 4,
	        'ebb': 2,
	        'eb': 3,
	        'e': 4,
	        'e#': 5,
	        'ex': 6,
	        'fbb': 3,
	        'fb': 4,
	        'f': 5,
	        'f#': 6,
	        'fx': 7,
	        'gbb': 5,
	        'gb': 6,
	        'g': 7,
	        'g#': 8,
	        'gx': 9,
	        'abb': 7,
	        'ab': 8,
	        'a': 9,
	        'a#': 10,
	        'ax': 11,
	        'bbb': 9,
	        'bb': 10,
	        'b': 11,
	        'b#': 12,
	        'bx': 13
	    };
	    /**
		 *  scale index to note (sharps)
		 *  @type  {Array}
		 */
	    var scaleIndexToNote = [
	        'C',
	        'C#',
	        'D',
	        'D#',
	        'E',
	        'F',
	        'F#',
	        'G',
	        'G#',
	        'A',
	        'A#',
	        'B'
	    ];
	    /**
		 *  The [concert pitch](https://en.wikipedia.org/wiki/Concert_pitch)
		 *  A4's values in Hertz.
		 *  @type {Frequency}
		 *  @static
		 */
	    Tone.Frequency.A4 = 440;
	    /**
		 *  Convert a MIDI note to frequency value.
		 *  @param  {MIDI} midi The midi number to convert.
		 *  @return {Frequency} the corresponding frequency value
		 *  @example
		 * tone.midiToFrequency(69); // returns 440
		 */
	    Tone.Frequency.prototype.midiToFrequency = function (midi) {
	        return Tone.Frequency.A4 * Math.pow(2, (midi - 69) / 12);
	    };
	    /**
		 *  Convert a frequency value to a MIDI note.
		 *  @param {Frequency} frequency The value to frequency value to convert.
		 *  @returns  {MIDI}
		 *  @example
		 * tone.midiToFrequency(440); // returns 69
		 */
	    Tone.Frequency.prototype.frequencyToMidi = function (frequency) {
	        return 69 + Math.round(12 * Math.log(frequency / Tone.Frequency.A4) / Math.LN2);
	    };
	    return Tone.Frequency;
	});
	Module(function (Tone) {
	    /**
		 *  @class Tone.TransportTime is a the time along the Transport's
		 *         timeline. It is similar to Tone.Time, but instead of evaluating
		 *         against the AudioContext's clock, it is evaluated against
		 *         the Transport's position. See [TransportTime wiki](https://github.com/Tonejs/Tone.js/wiki/TransportTime).
		 *  @constructor
		 *  @param  {Time}  val    The time value as a number or string
		 *  @param  {String=}  units  Unit values
		 *  @extends {Tone.Time}
		 */
	    Tone.TransportTime = function (val, units) {
	        if (this instanceof Tone.TransportTime) {
	            Tone.Time.call(this, val, units);
	        } else {
	            return new Tone.TransportTime(val, units);
	        }
	    };
	    Tone.extend(Tone.TransportTime, Tone.Time);
	    //clone the expressions so that 
	    //we can add more without modifying the original
	    Tone.TransportTime.prototype._unaryExpressions = Object.create(Tone.Time.prototype._unaryExpressions);
	    /**
		 *  Adds an additional unary expression
		 *  which quantizes values to the next subdivision
		 *  @type {Object}
		 *  @private
		 */
	    Tone.TransportTime.prototype._unaryExpressions.quantize = {
	        regexp: /^@/,
	        method: function (rh) {
	            var subdivision = this._secondsToTicks(rh());
	            var multiple = Math.ceil(Tone.Transport.ticks / subdivision);
	            return this._ticksToUnits(multiple * subdivision);
	        }
	    };
	    /**
		 *  Convert seconds into ticks
		 *  @param {Seconds} seconds
		 *  @return  {Ticks}
		 *  @private
		 */
	    Tone.TransportTime.prototype._secondsToTicks = function (seconds) {
	        var quarterTime = this._beatsToUnits(1);
	        var quarters = seconds / quarterTime;
	        return Math.round(quarters * Tone.Transport.PPQ);
	    };
	    /**
		 *  Evaluate the time expression. Returns values in ticks
		 *  @return {Ticks}
		 */
	    Tone.TransportTime.prototype.valueOf = function () {
	        var val = this._secondsToTicks(this._expr());
	        return val + (this._plusNow ? Tone.Transport.ticks : 0);
	    };
	    /**
		 *  Return the time in ticks.
		 *  @return  {Ticks}
		 */
	    Tone.TransportTime.prototype.toTicks = function () {
	        return this.valueOf();
	    };
	    /**
		 *  Return the time in seconds.
		 *  @return  {Seconds}
		 */
	    Tone.TransportTime.prototype.toSeconds = function () {
	        var val = this._expr();
	        return val + (this._plusNow ? Tone.Transport.seconds : 0);
	    };
	    /**
		 *  Return the time as a frequency value
		 *  @return  {Frequency} 
		 */
	    Tone.TransportTime.prototype.toFrequency = function () {
	        return 1 / this.toSeconds();
	    };
	    return Tone.TransportTime;
	});
	Module(function (Tone) {
	    ///////////////////////////////////////////////////////////////////////////
	    //	TYPES
	    ///////////////////////////////////////////////////////////////////////////
	    /**
		 * Units which a value can take on.
		 * @enum {String}
		 */
	    Tone.Type = {
	        /**
			 *  Default units
			 *  @typedef {Default}
			 */
	        Default: 'number',
	        /**
			 *  Time can be described in a number of ways. Read more [Time](https://github.com/Tonejs/Tone.js/wiki/Time).
			 *
			 *  * Numbers, which will be taken literally as the time (in seconds).
			 *  * Notation, ("4n", "8t") describes time in BPM and time signature relative values.
			 *  * TransportTime, ("4:3:2") will also provide tempo and time signature relative times
			 *  in the form BARS:QUARTERS:SIXTEENTHS.
			 *  * Frequency, ("8hz") is converted to the length of the cycle in seconds.
			 *  * Now-Relative, ("+1") prefix any of the above with "+" and it will be interpreted as
			 *  "the current time plus whatever expression follows".
			 *  * Expressions, ("3:0 + 2 - (1m / 7)") any of the above can also be combined
			 *  into a mathematical expression which will be evaluated to compute the desired time.
			 *  * No Argument, for methods which accept time, no argument will be interpreted as
			 *  "now" (i.e. the currentTime).
			 *
			 *  @typedef {Time}
			 */
	        Time: 'time',
	        /**
			 *  Frequency can be described similar to time, except ultimately the
			 *  values are converted to frequency instead of seconds. A number
			 *  is taken literally as the value in hertz. Additionally any of the
			 *  Time encodings can be used. Note names in the form
			 *  of NOTE OCTAVE (i.e. C4) are also accepted and converted to their
			 *  frequency value.
			 *  @typedef {Frequency}
			 */
	        Frequency: 'frequency',
	        /**
			 *  TransportTime describes a position along the Transport's timeline. It is
			 *  similar to Time in that it uses all the same encodings, but TransportTime specifically
			 *  pertains to the Transport's timeline, which is startable, stoppable, loopable, and seekable.
			 *  [Read more](https://github.com/Tonejs/Tone.js/wiki/TransportTime)
			 *  @typedef {TransportTime}
			 */
	        TransportTime: 'transportTime',
	        /**
			 *  Ticks are the basic subunit of the Transport. They are
			 *  the smallest unit of time that the Transport supports.
			 *  @typedef {Ticks}
			 */
	        Ticks: 'ticks',
	        /**
			 *  Normal values are within the range [0, 1].
			 *  @typedef {NormalRange}
			 */
	        NormalRange: 'normalRange',
	        /**
			 *  AudioRange values are between [-1, 1].
			 *  @typedef {AudioRange}
			 */
	        AudioRange: 'audioRange',
	        /**
			 *  Decibels are a logarithmic unit of measurement which is useful for volume
			 *  because of the logarithmic way that we perceive loudness. 0 decibels
			 *  means no change in volume. -10db is approximately half as loud and 10db
			 *  is twice is loud.
			 *  @typedef {Decibels}
			 */
	        Decibels: 'db',
	        /**
			 *  Half-step note increments, i.e. 12 is an octave above the root. and 1 is a half-step up.
			 *  @typedef {Interval}
			 */
	        Interval: 'interval',
	        /**
			 *  Beats per minute.
			 *  @typedef {BPM}
			 */
	        BPM: 'bpm',
	        /**
			 *  The value must be greater than or equal to 0.
			 *  @typedef {Positive}
			 */
	        Positive: 'positive',
	        /**
			 *  Gain is the ratio between input and output of a signal.
			 *  A gain of 0 is the same as silencing the signal. A gain of
			 *  1, causes no change to the incoming signal.
			 *  @typedef {Gain}
			 */
	        Gain: 'gain',
	        /**
			 *  A cent is a hundredth of a semitone.
			 *  @typedef {Cents}
			 */
	        Cents: 'cents',
	        /**
			 *  Angle between 0 and 360.
			 *  @typedef {Degrees}
			 */
	        Degrees: 'degrees',
	        /**
			 *  A number representing a midi note.
			 *  @typedef {MIDI}
			 */
	        MIDI: 'midi',
	        /**
			 *  A colon-separated representation of time in the form of
			 *  Bars:Beats:Sixteenths.
			 *  @typedef {BarsBeatsSixteenths}
			 */
	        BarsBeatsSixteenths: 'barsBeatsSixteenths',
	        /**
			 *  Sampling is the reduction of a continuous signal to a discrete signal.
			 *  Audio is typically sampled 44100 times per second.
			 *  @typedef {Samples}
			 */
	        Samples: 'samples',
	        /**
			 *  Hertz are a frequency representation defined as one cycle per second.
			 *  @typedef {Hertz}
			 */
	        Hertz: 'hertz',
	        /**
			 *  A frequency represented by a letter name,
			 *  accidental and octave. This system is known as
			 *  [Scientific Pitch Notation](https://en.wikipedia.org/wiki/Scientific_pitch_notation).
			 *  @typedef {Note}
			 */
	        Note: 'note',
	        /**
			 *  One millisecond is a thousandth of a second.
			 *  @typedef {Milliseconds}
			 */
	        Milliseconds: 'milliseconds',
	        /**
			 *  Seconds are the time unit of the AudioContext. In the end,
			 *  all values need to be evaluated to seconds.
			 *  @typedef {Seconds}
			 */
	        Seconds: 'seconds',
	        /**
			 *  A string representing a duration relative to a measure.
			 *  * "4n" = quarter note
			 *  * "2m" = two measures
			 *  * "8t" = eighth-note triplet
			 *  @typedef {Notation}
			 */
	        Notation: 'notation'
	    };
	    ///////////////////////////////////////////////////////////////////////////
	    // AUGMENT TONE's PROTOTYPE
	    ///////////////////////////////////////////////////////////////////////////
	    /**
		 *  Convert Time into seconds.
		 *
		 *  Unlike the method which it overrides, this takes into account
		 *  transporttime and musical notation.
		 *
		 *  Time : 1.40
		 *  Notation: 4n or 1m or 2t
		 *  Now Relative: +3n
		 *  Math: 3n+16n or even complicated expressions ((3n*2)/6 + 1)
		 *
		 *  @param  {Time} time
		 *  @return {Seconds}
		 */
	    Tone.prototype.toSeconds = function (time) {
	        if (Tone.isNumber(time)) {
	            return time;
	        } else if (Tone.isUndef(time)) {
	            return this.now();
	        } else if (Tone.isString(time)) {
	            return new Tone.Time(time).toSeconds();
	        } else if (time instanceof Tone.TimeBase) {
	            return time.toSeconds();
	        }
	    };
	    /**
		 *  Convert a frequency representation into a number.
		 *  @param  {Frequency} freq
		 *  @return {Hertz}      the frequency in hertz
		 */
	    Tone.prototype.toFrequency = function (freq) {
	        if (Tone.isNumber(freq)) {
	            return freq;
	        } else if (Tone.isString(freq) || Tone.isUndef(freq)) {
	            return new Tone.Frequency(freq).valueOf();
	        } else if (freq instanceof Tone.TimeBase) {
	            return freq.toFrequency();
	        }
	    };
	    /**
		 *  Convert a time representation into ticks.
		 *  @param  {Time} time
		 *  @return {Ticks}  the time in ticks
		 */
	    Tone.prototype.toTicks = function (time) {
	        if (Tone.isNumber(time) || Tone.isString(time)) {
	            return new Tone.TransportTime(time).toTicks();
	        } else if (Tone.isUndef(time)) {
	            return Tone.Transport.ticks;
	        } else if (time instanceof Tone.TimeBase) {
	            return time.toTicks();
	        }
	    };
	    return Tone;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Tone.Param wraps the native Web Audio's AudioParam to provide
		 *         additional unit conversion functionality. It also
		 *         serves as a base-class for classes which have a single,
		 *         automatable parameter.
		 *  @extends {Tone.AudioNode}
		 *  @param  {AudioParam}  param  The parameter to wrap.
		 *  @param  {Tone.Type} units The units of the audio param.
		 *  @param  {Boolean} convert If the param should be converted.
		 */
	    Tone.Param = function () {
	        var options = Tone.defaults(arguments, [
	            'param',
	            'units',
	            'convert'
	        ], Tone.Param);
	        Tone.AudioNode.call(this);
	        /**
			 *  The native parameter to control
			 *  @type  {AudioParam}
			 *  @private
			 */
	        this._param = this.input = options.param;
	        /**
			 *  The units of the parameter
			 *  @type {Tone.Type}
			 */
	        this.units = options.units;
	        /**
			 *  If the value should be converted or not
			 *  @type {Boolean}
			 */
	        this.convert = options.convert;
	        /**
			 *  True if the signal value is being overridden by
			 *  a connected signal.
			 *  @readOnly
			 *  @type  {boolean}
			 *  @private
			 */
	        this.overridden = false;
	        /**
			 *  If there is an LFO, this is where it is held.
			 *  @type  {Tone.LFO}
			 *  @private
			 */
	        this._lfo = null;
	        if (Tone.isObject(options.lfo)) {
	            this.value = options.lfo;
	        } else if (!Tone.isUndef(options.value)) {
	            this.value = options.value;
	        }
	    };
	    Tone.extend(Tone.Param, Tone.AudioNode);
	    /**
		 *  Defaults
		 *  @type  {Object}
		 *  @const
		 */
	    Tone.Param.defaults = {
	        'units': Tone.Type.Default,
	        'convert': true,
	        'param': undefined
	    };
	    /**
		 * The current value of the parameter.
		 * @memberOf Tone.Param#
		 * @type {Number}
		 * @name value
		 */
	    Object.defineProperty(Tone.Param.prototype, 'value', {
	        get: function () {
	            return this._toUnits(this._param.value);
	        },
	        set: function (value) {
	            if (Tone.isObject(value)) {
	                //throw an error if the LFO needs to be included
	                if (Tone.isUndef(Tone.LFO)) {
	                    throw new Error('Include \'Tone.LFO\' to use an LFO as a Param value.');
	                }
	                //remove the old one
	                if (this._lfo) {
	                    this._lfo.dispose();
	                }
	                this._lfo = new Tone.LFO(value).start();
	                this._lfo.connect(this.input);
	            } else {
	                var convertedVal = this._fromUnits(value);
	                this._param.cancelScheduledValues(0);
	                this._param.value = convertedVal;
	            }
	        }
	    });
	    /**
		 *  Convert the given value from the type specified by Tone.Param.units
		 *  into the destination value (such as Gain or Frequency).
		 *  @private
		 *  @param  {*} val the value to convert
		 *  @return {number}     the number which the value should be set to
		 */
	    Tone.Param.prototype._fromUnits = function (val) {
	        if (this.convert || Tone.isUndef(this.convert)) {
	            switch (this.units) {
	            case Tone.Type.Time:
	                return this.toSeconds(val);
	            case Tone.Type.Frequency:
	                return this.toFrequency(val);
	            case Tone.Type.Decibels:
	                return Tone.dbToGain(val);
	            case Tone.Type.NormalRange:
	                return Math.min(Math.max(val, 0), 1);
	            case Tone.Type.AudioRange:
	                return Math.min(Math.max(val, -1), 1);
	            case Tone.Type.Positive:
	                return Math.max(val, 0);
	            default:
	                return val;
	            }
	        } else {
	            return val;
	        }
	    };
	    /**
		 * Convert the parameters value into the units specified by Tone.Param.units.
		 * @private
		 * @param  {number} val the value to convert
		 * @return {number}
		 */
	    Tone.Param.prototype._toUnits = function (val) {
	        if (this.convert || Tone.isUndef(this.convert)) {
	            switch (this.units) {
	            case Tone.Type.Decibels:
	                return Tone.gainToDb(val);
	            default:
	                return val;
	            }
	        } else {
	            return val;
	        }
	    };
	    /**
		 *  the minimum output value
		 *  @type {Number}
		 *  @private
		 */
	    Tone.Param.prototype._minOutput = 0.00001;
	    /**
		 *  Schedules a parameter value change at the given time.
		 *  @param {*}	value The value to set the signal.
		 *  @param {Time}  time The time when the change should occur.
		 *  @returns {Tone.Param} this
		 *  @example
		 * //set the frequency to "G4" in exactly 1 second from now.
		 * freq.setValueAtTime("G4", "+1");
		 */
	    Tone.Param.prototype.setValueAtTime = function (value, time) {
	        this._param.setValueAtTime(this._fromUnits(value), this.toSeconds(time));
	        return this;
	    };
	    /**
		 *  Creates a schedule point with the current value at the current time.
		 *  This is useful for creating an automation anchor point in order to
		 *  schedule changes from the current value.
		 *
		 *  @param {number=} now (Optionally) pass the now value in.
		 *  @returns {Tone.Param} this
		 */
	    Tone.Param.prototype.setRampPoint = function (now) {
	        now = Tone.defaultArg(now, this.now());
	        var currentVal = this._param.value;
	        // exponentialRampToValueAt cannot ever ramp from or to 0
	        // More info: https://bugzilla.mozilla.org/show_bug.cgi?id=1125600#c2
	        if (currentVal === 0) {
	            currentVal = this._minOutput;
	        }
	        this._param.setValueAtTime(currentVal, now);
	        return this;
	    };
	    /**
		 *  Schedules a linear continuous change in parameter value from the
		 *  previous scheduled parameter value to the given value.
		 *
		 *  @param  {number} value
		 *  @param  {Time} endTime
		 *  @returns {Tone.Param} this
		 */
	    Tone.Param.prototype.linearRampToValueAtTime = function (value, endTime) {
	        value = this._fromUnits(value);
	        this._param.linearRampToValueAtTime(value, this.toSeconds(endTime));
	        return this;
	    };
	    /**
		 *  Schedules an exponential continuous change in parameter value from
		 *  the previous scheduled parameter value to the given value.
		 *
		 *  @param  {number} value
		 *  @param  {Time} endTime
		 *  @returns {Tone.Param} this
		 */
	    Tone.Param.prototype.exponentialRampToValueAtTime = function (value, endTime) {
	        value = this._fromUnits(value);
	        value = Math.max(this._minOutput, value);
	        this._param.exponentialRampToValueAtTime(value, this.toSeconds(endTime));
	        return this;
	    };
	    /**
		 *  Schedules an exponential continuous change in parameter value from
		 *  the current time and current value to the given value over the
		 *  duration of the rampTime.
		 *
		 *  @param  {number} value   The value to ramp to.
		 *  @param  {Time} rampTime the time that it takes the
		 *                               value to ramp from it's current value
		 *  @param {Time}	[startTime=now] 	When the ramp should start.
		 *  @returns {Tone.Param} this
		 *  @example
		 * //exponentially ramp to the value 2 over 4 seconds.
		 * signal.exponentialRampToValue(2, 4);
		 */
	    Tone.Param.prototype.exponentialRampToValue = function (value, rampTime, startTime) {
	        startTime = this.toSeconds(startTime);
	        this.setRampPoint(startTime);
	        this.exponentialRampToValueAtTime(value, startTime + this.toSeconds(rampTime));
	        return this;
	    };
	    /**
		 *  Schedules an linear continuous change in parameter value from
		 *  the current time and current value to the given value over the
		 *  duration of the rampTime.
		 *
		 *  @param  {number} value   The value to ramp to.
		 *  @param  {Time} rampTime the time that it takes the
		 *                               value to ramp from it's current value
		 *  @param {Time}	[startTime=now] 	When the ramp should start.
		 *  @returns {Tone.Param} this
		 *  @example
		 * //linearly ramp to the value 4 over 3 seconds.
		 * signal.linearRampToValue(4, 3);
		 */
	    Tone.Param.prototype.linearRampToValue = function (value, rampTime, startTime) {
	        startTime = this.toSeconds(startTime);
	        this.setRampPoint(startTime);
	        this.linearRampToValueAtTime(value, startTime + this.toSeconds(rampTime));
	        return this;
	    };
	    /**
		 *  Start exponentially approaching the target value at the given time with
		 *  a rate having the given time constant.
		 *  @param {number} value
		 *  @param {Time} startTime
		 *  @param {number} timeConstant
		 *  @returns {Tone.Param} this
		 */
	    Tone.Param.prototype.setTargetAtTime = function (value, startTime, timeConstant) {
	        value = this._fromUnits(value);
	        // The value will never be able to approach without timeConstant > 0.
	        // http://www.w3.org/TR/webaudio/#dfn-setTargetAtTime, where the equation
	        // is described. 0 results in a division by 0.
	        value = Math.max(this._minOutput, value);
	        timeConstant = Math.max(this._minOutput, timeConstant);
	        this._param.setTargetAtTime(value, this.toSeconds(startTime), timeConstant);
	        return this;
	    };
	    /**
		 *  Sets an array of arbitrary parameter values starting at the given time
		 *  for the given duration.
		 *
		 *  @param {Array} values
		 *  @param {Time} startTime
		 *  @param {Time} duration
		 *  @returns {Tone.Param} this
		 */
	    Tone.Param.prototype.setValueCurveAtTime = function (values, startTime, duration) {
	        duration = this.toSeconds(duration);
	        startTime = this.toSeconds(startTime);
	        this.setValueAtTime(values[0], startTime);
	        var segTime = duration / (values.length - 1);
	        for (var i = 1; i < values.length; i++) {
	            this._param.linearRampToValueAtTime(this._fromUnits(values[i]), startTime + i * segTime);
	        }
	        return this;
	    };
	    /**
		 *  Cancels all scheduled parameter changes with times greater than or
		 *  equal to startTime.
		 *
		 *  @param  {Time} startTime
		 *  @returns {Tone.Param} this
		 */
	    Tone.Param.prototype.cancelScheduledValues = function (startTime) {
	        this._param.cancelScheduledValues(this.toSeconds(startTime));
	        return this;
	    };
	    /**
		 *  Ramps to the given value over the duration of the rampTime.
		 *  Automatically selects the best ramp type (exponential or linear)
		 *  depending on the `units` of the signal
		 *
		 *  @param  {number} value
		 *  @param  {Time} rampTime 	The time that it takes the
		 *                              value to ramp from it's current value
		 *  @param {Time}	[startTime=now] 	When the ramp should start.
		 *  @returns {Tone.Param} this
		 *  @example
		 * //ramp to the value either linearly or exponentially
		 * //depending on the "units" value of the signal
		 * signal.rampTo(0, 10);
		 *  @example
		 * //schedule it to ramp starting at a specific time
		 * signal.rampTo(0, 10, 5)
		 */
	    Tone.Param.prototype.rampTo = function (value, rampTime, startTime) {
	        rampTime = Tone.defaultArg(rampTime, 0);
	        if (this.units === Tone.Type.Frequency || this.units === Tone.Type.BPM || this.units === Tone.Type.Decibels) {
	            this.exponentialRampToValue(value, rampTime, startTime);
	        } else {
	            this.linearRampToValue(value, rampTime, startTime);
	        }
	        return this;
	    };
	    /**
		 *  The LFO created by the signal instance. If none
		 *  was created, this is null.
		 *  @type {Tone.LFO}
		 *  @readOnly
		 *  @memberOf Tone.Param#
		 *  @name lfo
		 */
	    Object.defineProperty(Tone.Param.prototype, 'lfo', {
	        get: function () {
	            return this._lfo;
	        }
	    });
	    /**
		 *  Clean up
		 *  @returns {Tone.Param} this
		 */
	    Tone.Param.prototype.dispose = function () {
	        Tone.AudioNode.prototype.dispose.call(this);
	        this._param = null;
	        if (this._lfo) {
	            this._lfo.dispose();
	            this._lfo = null;
	        }
	        return this;
	    };
	    return Tone.Param;
	});
	Module(function (Tone) {
	    
	    /**
		 *  createGain shim
		 *  @private
		 */
	    if (window.GainNode && !AudioContext.prototype.createGain) {
	        AudioContext.prototype.createGain = AudioContext.prototype.createGainNode;
	    }
	    /**
		 *  @class A thin wrapper around the Native Web Audio GainNode.
		 *         The GainNode is a basic building block of the Web Audio
		 *         API and is useful for routing audio and adjusting gains.
		 *  @extends {Tone}
		 *  @param  {Number=}  gain  The initial gain of the GainNode
		 *  @param {Tone.Type=} units The units of the gain parameter.
		 */
	    Tone.Gain = function () {
	        var options = Tone.defaults(arguments, [
	            'gain',
	            'units'
	        ], Tone.Gain);
	        Tone.AudioNode.call(this);
	        /**
			 *  The GainNode
			 *  @type  {GainNode}
			 *  @private
			 */
	        this.input = this.output = this._gainNode = this.context.createGain();
	        /**
			 *  The gain parameter of the gain node.
			 *  @type {Gain}
			 *  @signal
			 */
	        this.gain = new Tone.Param({
	            'param': this._gainNode.gain,
	            'units': options.units,
	            'value': options.gain,
	            'convert': options.convert
	        });
	        this._readOnly('gain');
	    };
	    Tone.extend(Tone.Gain, Tone.AudioNode);
	    /**
		 *  The defaults
		 *  @const
		 *  @type  {Object}
		 */
	    Tone.Gain.defaults = {
	        'gain': 1,
	        'convert': true
	    };
	    /**
		 *  Clean up.
		 *  @return  {Tone.Gain}  this
		 */
	    Tone.Gain.prototype.dispose = function () {
	        Tone.AudioNode.prototype.dispose.call(this);
	        this._gainNode.disconnect();
	        this._gainNode = null;
	        this._writable('gain');
	        this.gain.dispose();
	        this.gain = null;
	    };
	    return Tone.Gain;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class  A signal is an audio-rate value. Tone.Signal is a core component of the library.
		 *          Unlike a number, Signals can be scheduled with sample-level accuracy. Tone.Signal
		 *          has all of the methods available to native Web Audio 
		 *          [AudioParam](http://webaudio.github.io/web-audio-api/#the-audioparam-interface)
		 *          as well as additional conveniences. Read more about working with signals 
		 *          [here](https://github.com/Tonejs/Tone.js/wiki/Signals).
		 *
		 *  @constructor
		 *  @extends {Tone.Param}
		 *  @param {Number|AudioParam} [value] Initial value of the signal. If an AudioParam
		 *                                     is passed in, that parameter will be wrapped
		 *                                     and controlled by the Signal. 
		 *  @param {string} [units=Number] unit The units the signal is in. 
		 *  @example
		 * var signal = new Tone.Signal(10);
		 */
	    Tone.Signal = function () {
	        var options = Tone.defaults(arguments, [
	            'value',
	            'units'
	        ], Tone.Signal);
	        var gainNode = Tone.context.createGain();
	        options.param = gainNode.gain;
	        Tone.Param.call(this, options);
	        /**
			 * The node where the constant signal value is scaled.
			 * @type {GainNode}
			 * @private
			 */
	        this.output = gainNode;
	        /**
			 * The node where the value is set.
			 * @type {Tone.Param}
			 * @private
			 */
	        this.input = this._param = this.output.gain;
	        //connect the const output to the node output
	        this.context.getConstant(1).connect(this.output);
	    };
	    Tone.extend(Tone.Signal, Tone.Param);
	    /**
		 *  The default values
		 *  @type  {Object}
		 *  @static
		 *  @const
		 */
	    Tone.Signal.defaults = {
	        'value': 0,
	        'units': Tone.Type.Default,
	        'convert': true
	    };
	    /**
		 *  When signals connect to other signals or AudioParams, 
		 *  they take over the output value of that signal or AudioParam. 
		 *  For all other nodes, the behavior is the same as a default <code>connect</code>. 
		 *
		 *  @override
		 *  @param {AudioParam|AudioNode|Tone.Signal|Tone} node 
		 *  @param {number} [outputNumber=0] The output number to connect from.
		 *  @param {number} [inputNumber=0] The input number to connect to.
		 *  @returns {Tone.SignalBase} this
		 *  @method
		 */
	    Tone.Signal.prototype.connect = Tone.SignalBase.prototype.connect;
	    /**
		 *  dispose and disconnect
		 *  @returns {Tone.Signal} this
		 */
	    Tone.Signal.prototype.dispose = function () {
	        Tone.Param.prototype.dispose.call(this);
	        return this;
	    };
	    return Tone.Signal;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class A signal which adds the method getValueAtTime. 
		 *         Code and inspiration from https://github.com/jsantell/web-audio-automation-timeline
		 *  @extends {Tone.Signal}
		 *  @param {Number=} value The initial value of the signal
		 *  @param {String=} units The conversion units of the signal.
		 */
	    Tone.TimelineSignal = function () {
	        var options = Tone.defaults(arguments, [
	            'value',
	            'units'
	        ], Tone.Signal);
	        Tone.Signal.call(this, options);
	        /**
			 *  The scheduled events
			 *  @type {Tone.Timeline}
			 *  @private
			 */
	        this._events = new Tone.Timeline(100);
	        /**
			 *  The initial scheduled value
			 *  @type {Number}
			 *  @private
			 */
	        this._initial = this._fromUnits(this._param.value);
	        this.value = options.value;
	        //delete the input node so that nothing can overwrite the signal value
	        delete this.input;
	    };
	    Tone.extend(Tone.TimelineSignal, Tone.Signal);
	    /**
		 *  The event types of a schedulable signal.
		 *  @enum {String}
		 *  @private
		 */
	    Tone.TimelineSignal.Type = {
	        Linear: 'linear',
	        Exponential: 'exponential',
	        Target: 'target',
	        Set: 'set'
	    };
	    /**
		 * The current value of the signal. 
		 * @memberOf Tone.TimelineSignal#
		 * @type {Number}
		 * @name value
		 */
	    Object.defineProperty(Tone.TimelineSignal.prototype, 'value', {
	        get: function () {
	            var now = this.now();
	            var val = this.getValueAtTime(now);
	            return this._toUnits(val);
	        },
	        set: function (value) {
	            if (this._events) {
	                var convertedVal = this._fromUnits(value);
	                this._initial = convertedVal;
	                this.cancelScheduledValues();
	                this._param.value = convertedVal;
	            }
	        }
	    });
	    ///////////////////////////////////////////////////////////////////////////
	    //	SCHEDULING
	    ///////////////////////////////////////////////////////////////////////////
	    /**
		 *  Schedules a parameter value change at the given time.
		 *  @param {*}	value The value to set the signal.
		 *  @param {Time}  time The time when the change should occur.
		 *  @returns {Tone.TimelineSignal} this
		 *  @example
		 * //set the frequency to "G4" in exactly 1 second from now. 
		 * freq.setValueAtTime("G4", "+1");
		 */
	    Tone.TimelineSignal.prototype.setValueAtTime = function (value, startTime) {
	        value = this._fromUnits(value);
	        startTime = this.toSeconds(startTime);
	        this._events.add({
	            'type': Tone.TimelineSignal.Type.Set,
	            'value': value,
	            'time': startTime
	        });
	        //invoke the original event
	        this._param.setValueAtTime(value, startTime);
	        return this;
	    };
	    /**
		 *  Schedules a linear continuous change in parameter value from the 
		 *  previous scheduled parameter value to the given value.
		 *  
		 *  @param  {number} value   
		 *  @param  {Time} endTime 
		 *  @returns {Tone.TimelineSignal} this
		 */
	    Tone.TimelineSignal.prototype.linearRampToValueAtTime = function (value, endTime) {
	        value = this._fromUnits(value);
	        endTime = this.toSeconds(endTime);
	        this._events.add({
	            'type': Tone.TimelineSignal.Type.Linear,
	            'value': value,
	            'time': endTime
	        });
	        this._param.linearRampToValueAtTime(value, endTime);
	        return this;
	    };
	    /**
		 *  Schedules an exponential continuous change in parameter value from 
		 *  the previous scheduled parameter value to the given value.
		 *  
		 *  @param  {number} value   
		 *  @param  {Time} endTime 
		 *  @returns {Tone.TimelineSignal} this
		 */
	    Tone.TimelineSignal.prototype.exponentialRampToValueAtTime = function (value, endTime) {
	        //get the previous event and make sure it's not starting from 0
	        endTime = this.toSeconds(endTime);
	        var beforeEvent = this._searchBefore(endTime);
	        if (beforeEvent && beforeEvent.value === 0) {
	            //reschedule that event
	            this.setValueAtTime(this._minOutput, beforeEvent.time);
	        }
	        value = this._fromUnits(value);
	        var setValue = Math.max(value, this._minOutput);
	        this._events.add({
	            'type': Tone.TimelineSignal.Type.Exponential,
	            'value': setValue,
	            'time': endTime
	        });
	        //if the ramped to value is 0, make it go to the min output, and then set to 0.
	        if (value < this._minOutput) {
	            this._param.exponentialRampToValueAtTime(this._minOutput, endTime - this.sampleTime);
	            this.setValueAtTime(0, endTime);
	        } else {
	            this._param.exponentialRampToValueAtTime(value, endTime);
	        }
	        return this;
	    };
	    /**
		 *  Start exponentially approaching the target value at the given time with
		 *  a rate having the given time constant.
		 *  @param {number} value        
		 *  @param {Time} startTime    
		 *  @param {number} timeConstant 
		 *  @returns {Tone.TimelineSignal} this 
		 */
	    Tone.TimelineSignal.prototype.setTargetAtTime = function (value, startTime, timeConstant) {
	        value = this._fromUnits(value);
	        value = Math.max(this._minOutput, value);
	        timeConstant = Math.max(this._minOutput, timeConstant);
	        startTime = this.toSeconds(startTime);
	        this._events.add({
	            'type': Tone.TimelineSignal.Type.Target,
	            'value': value,
	            'time': startTime,
	            'constant': timeConstant
	        });
	        this._param.setTargetAtTime(value, startTime, timeConstant);
	        return this;
	    };
	    /**
		 *  Set an array of arbitrary values starting at the given time for the given duration.
		 *  @param {Float32Array} values        
		 *  @param {Time} startTime    
		 *  @param {Time} duration
		 *  @param {NormalRange} [scaling=1] If the values in the curve should be scaled by some value
		 *  @returns {Tone.TimelineSignal} this 
		 */
	    Tone.TimelineSignal.prototype.setValueCurveAtTime = function (values, startTime, duration, scaling) {
	        scaling = Tone.defaultArg(scaling, 1);
	        duration = this.toSeconds(duration);
	        startTime = this.toSeconds(startTime);
	        var segTime = duration / (values.length - 1);
	        this.setValueAtTime(values[0] * scaling, startTime);
	        for (var i = 1; i < values.length; i++) {
	            this.linearRampToValueAtTime(values[i] * scaling, startTime + i * segTime);
	        }
	        return this;
	    };
	    /**
		 *  Cancels all scheduled parameter changes with times greater than or 
		 *  equal to startTime.
		 *  
		 *  @param  {Time} startTime
		 *  @returns {Tone.TimelineSignal} this
		 */
	    Tone.TimelineSignal.prototype.cancelScheduledValues = function (after) {
	        after = this.toSeconds(after);
	        this._events.cancel(after);
	        this._param.cancelScheduledValues(after);
	        return this;
	    };
	    /**
		 *  Sets the computed value at the given time. This provides
		 *  a point from which a linear or exponential curve
		 *  can be scheduled after. Will cancel events after 
		 *  the given time and shorten the currently scheduled
		 *  linear or exponential ramp so that it ends at `time` .
		 *  This is to avoid discontinuities and clicks in envelopes. 
		 *  @param {Time} time When to set the ramp point
		 *  @returns {Tone.TimelineSignal} this
		 */
	    Tone.TimelineSignal.prototype.setRampPoint = function (time) {
	        time = this.toSeconds(time);
	        //get the value at the given time
	        var val = this._toUnits(this.getValueAtTime(time));
	        //if there is an event at the given time
	        //and that even is not a "set"
	        var before = this._searchBefore(time);
	        if (before && before.time === time) {
	            //remove everything after
	            this.cancelScheduledValues(time + this.sampleTime);
	        } else {
	            //reschedule the next event to end at the given time
	            var after = this._searchAfter(time);
	            if (after) {
	                //cancel the next event(s)
	                this.cancelScheduledValues(time);
	                if (after.type === Tone.TimelineSignal.Type.Linear) {
	                    this.linearRampToValueAtTime(val, time);
	                } else if (after.type === Tone.TimelineSignal.Type.Exponential) {
	                    this.exponentialRampToValueAtTime(val, time);
	                }
	            }
	            this.setValueAtTime(val, time);
	        }
	        return this;
	    };
	    /**
		 *  Do a linear ramp to the given value between the start and finish times.
		 *  @param {Number} value The value to ramp to.
		 *  @param {Time} start The beginning anchor point to do the linear ramp
		 *  @param {Time} finish The ending anchor point by which the value of
		 *                       the signal will equal the given value.
		 *  @returns {Tone.TimelineSignal} this
		 */
	    Tone.TimelineSignal.prototype.linearRampToValueBetween = function (value, start, finish) {
	        this.setRampPoint(start);
	        this.linearRampToValueAtTime(value, finish);
	        return this;
	    };
	    /**
		 *  Do a exponential ramp to the given value between the start and finish times.
		 *  @param {Number} value The value to ramp to.
		 *  @param {Time} start The beginning anchor point to do the exponential ramp
		 *  @param {Time} finish The ending anchor point by which the value of
		 *                       the signal will equal the given value.
		 *  @returns {Tone.TimelineSignal} this
		 */
	    Tone.TimelineSignal.prototype.exponentialRampToValueBetween = function (value, start, finish) {
	        this.setRampPoint(start);
	        this.exponentialRampToValueAtTime(value, finish);
	        return this;
	    };
	    ///////////////////////////////////////////////////////////////////////////
	    //	GETTING SCHEDULED VALUES
	    ///////////////////////////////////////////////////////////////////////////
	    /**
		 *  Returns the value before or equal to the given time
		 *  @param  {Number}  time  The time to query
		 *  @return  {Object}  The event at or before the given time.
		 *  @private
		 */
	    Tone.TimelineSignal.prototype._searchBefore = function (time) {
	        return this._events.get(time);
	    };
	    /**
		 *  The event after the given time
		 *  @param  {Number}  time  The time to query.
		 *  @return  {Object}  The next event after the given time
		 *  @private
		 */
	    Tone.TimelineSignal.prototype._searchAfter = function (time) {
	        return this._events.getAfter(time);
	    };
	    /**
		 *  Get the scheduled value at the given time. This will
		 *  return the unconverted (raw) value.
		 *  @param  {Number}  time  The time in seconds.
		 *  @return  {Number}  The scheduled value at the given time.
		 */
	    Tone.TimelineSignal.prototype.getValueAtTime = function (time) {
	        time = this.toSeconds(time);
	        var after = this._searchAfter(time);
	        var before = this._searchBefore(time);
	        var value = this._initial;
	        //if it was set by
	        if (before === null) {
	            value = this._initial;
	        } else if (before.type === Tone.TimelineSignal.Type.Target) {
	            var previous = this._events.getBefore(before.time);
	            var previouVal;
	            if (previous === null) {
	                previouVal = this._initial;
	            } else {
	                previouVal = previous.value;
	            }
	            value = this._exponentialApproach(before.time, previouVal, before.value, before.constant, time);
	        } else if (after === null) {
	            value = before.value;
	        } else if (after.type === Tone.TimelineSignal.Type.Linear) {
	            value = this._linearInterpolate(before.time, before.value, after.time, after.value, time);
	        } else if (after.type === Tone.TimelineSignal.Type.Exponential) {
	            value = this._exponentialInterpolate(before.time, before.value, after.time, after.value, time);
	        } else {
	            value = before.value;
	        }
	        return value;
	    };
	    /**
		 *  When signals connect to other signals or AudioParams, 
		 *  they take over the output value of that signal or AudioParam. 
		 *  For all other nodes, the behavior is the same as a default <code>connect</code>. 
		 *
		 *  @override
		 *  @param {AudioParam|AudioNode|Tone.Signal|Tone} node 
		 *  @param {number} [outputNumber=0] The output number to connect from.
		 *  @param {number} [inputNumber=0] The input number to connect to.
		 *  @returns {Tone.TimelineSignal} this
		 *  @method
		 */
	    Tone.TimelineSignal.prototype.connect = Tone.SignalBase.prototype.connect;
	    ///////////////////////////////////////////////////////////////////////////
	    //	AUTOMATION CURVE CALCULATIONS
	    //	MIT License, copyright (c) 2014 Jordan Santell
	    ///////////////////////////////////////////////////////////////////////////
	    /**
		 *  Calculates the the value along the curve produced by setTargetAtTime
		 *  @private
		 */
	    Tone.TimelineSignal.prototype._exponentialApproach = function (t0, v0, v1, timeConstant, t) {
	        return v1 + (v0 - v1) * Math.exp(-(t - t0) / timeConstant);
	    };
	    /**
		 *  Calculates the the value along the curve produced by linearRampToValueAtTime
		 *  @private
		 */
	    Tone.TimelineSignal.prototype._linearInterpolate = function (t0, v0, t1, v1, t) {
	        return v0 + (v1 - v0) * ((t - t0) / (t1 - t0));
	    };
	    /**
		 *  Calculates the the value along the curve produced by exponentialRampToValueAtTime
		 *  @private
		 */
	    Tone.TimelineSignal.prototype._exponentialInterpolate = function (t0, v0, t1, v1, t) {
	        v0 = Math.max(this._minOutput, v0);
	        return v0 * Math.pow(v1 / v0, (t - t0) / (t1 - t0));
	    };
	    /**
		 *  Clean up.
		 *  @return {Tone.TimelineSignal} this
		 */
	    Tone.TimelineSignal.prototype.dispose = function () {
	        Tone.Signal.prototype.dispose.call(this);
	        this._events.dispose();
	        this._events = null;
	    };
	    return Tone.TimelineSignal;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Pow applies an exponent to the incoming signal. The incoming signal
		 *         must be AudioRange.
		 *
		 *  @extends {Tone.SignalBase}
		 *  @constructor
		 *  @param {Positive} exp The exponent to apply to the incoming signal, must be at least 2. 
		 *  @example
		 * var pow = new Tone.Pow(2);
		 * var sig = new Tone.Signal(0.5).connect(pow);
		 * //output of pow is 0.25. 
		 */
	    Tone.Pow = function (exp) {
	        Tone.SignalBase.call(this);
	        /**
			 * the exponent
			 * @private
			 * @type {number}
			 */
	        this._exp = Tone.defaultArg(exp, 1);
	        /**
			 *  @type {WaveShaperNode}
			 *  @private
			 */
	        this._expScaler = this.input = this.output = new Tone.WaveShaper(this._expFunc(this._exp), 8192);
	    };
	    Tone.extend(Tone.Pow, Tone.SignalBase);
	    /**
		 * The value of the exponent.
		 * @memberOf Tone.Pow#
		 * @type {number}
		 * @name value
		 */
	    Object.defineProperty(Tone.Pow.prototype, 'value', {
	        get: function () {
	            return this._exp;
	        },
	        set: function (exp) {
	            this._exp = exp;
	            this._expScaler.setMap(this._expFunc(this._exp));
	        }
	    });
	    /**
		 *  the function which maps the waveshaper
		 *  @param   {number} exp
		 *  @return {function}
		 *  @private
		 */
	    Tone.Pow.prototype._expFunc = function (exp) {
	        return function (val) {
	            return Math.pow(Math.abs(val), exp);
	        };
	    };
	    /**
		 *  Clean up.
		 *  @returns {Tone.Pow} this
		 */
	    Tone.Pow.prototype.dispose = function () {
	        Tone.SignalBase.prototype.dispose.call(this);
	        this._expScaler.dispose();
	        this._expScaler = null;
	        return this;
	    };
	    return Tone.Pow;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class  Tone.Envelope is an [ADSR](https://en.wikipedia.org/wiki/Synthesizer#ADSR_envelope)
		 *          envelope generator. Tone.Envelope outputs a signal which
		 *          can be connected to an AudioParam or Tone.Signal.
		 *          <img src="https://upload.wikimedia.org/wikipedia/commons/e/ea/ADSR_parameter.svg">
		 *
		 *  @constructor
		 *  @extends {Tone.AudioNode}
		 *  @param {Time} [attack] The amount of time it takes for the envelope to go from
		 *                         0 to it's maximum value.
		 *  @param {Time} [decay]	The period of time after the attack that it takes for the envelope
		 *                       	to fall to the sustain value.
		 *  @param {NormalRange} [sustain]	The percent of the maximum value that the envelope rests at until
		 *                                	the release is triggered.
		 *  @param {Time} [release]	The amount of time after the release is triggered it takes to reach 0.
		 *  @example
		 * //an amplitude envelope
		 * var gainNode = Tone.context.createGain();
		 * var env = new Tone.Envelope({
		 * 	"attack" : 0.1,
		 * 	"decay" : 0.2,
		 * 	"sustain" : 1,
		 * 	"release" : 0.8,
		 * });
		 * env.connect(gainNode.gain);
		 */
	    Tone.Envelope = function () {
	        //get all of the defaults
	        var options = Tone.defaults(arguments, [
	            'attack',
	            'decay',
	            'sustain',
	            'release'
	        ], Tone.Envelope);
	        Tone.AudioNode.call(this);
	        /**
			 *  When triggerAttack is called, the attack time is the amount of
			 *  time it takes for the envelope to reach it's maximum value.
			 *  @type {Time}
			 */
	        this.attack = options.attack;
	        /**
			 *  After the attack portion of the envelope, the value will fall
			 *  over the duration of the decay time to it's sustain value.
			 *  @type {Time}
			 */
	        this.decay = options.decay;
	        /**
			 * 	The sustain value is the value
			 * 	which the envelope rests at after triggerAttack is
			 * 	called, but before triggerRelease is invoked.
			 *  @type {NormalRange}
			 */
	        this.sustain = options.sustain;
	        /**
			 *  After triggerRelease is called, the envelope's
			 *  value will fall to it's miminum value over the
			 *  duration of the release time.
			 *  @type {Time}
			 */
	        this.release = options.release;
	        /**
			 *  the next time the envelope is at standby
			 *  @type {number}
			 *  @private
			 */
	        this._attackCurve = 'linear';
	        /**
			 *  the next time the envelope is at standby
			 *  @type {number}
			 *  @private
			 */
	        this._releaseCurve = 'exponential';
	        /**
			 *  the signal
			 *  @type {Tone.TimelineSignal}
			 *  @private
			 */
	        this._sig = this.output = new Tone.TimelineSignal();
	        this._sig.setValueAtTime(0, 0);
	        //set the attackCurve initially
	        this.attackCurve = options.attackCurve;
	        this.releaseCurve = options.releaseCurve;
	    };
	    Tone.extend(Tone.Envelope, Tone.AudioNode);
	    /**
		 *  the default parameters
		 *  @static
		 *  @const
		 */
	    Tone.Envelope.defaults = {
	        'attack': 0.01,
	        'decay': 0.1,
	        'sustain': 0.5,
	        'release': 1,
	        'attackCurve': 'linear',
	        'releaseCurve': 'exponential'
	    };
	    /**
		 * Read the current value of the envelope. Useful for
		 * syncronizing visual output to the envelope.
		 * @memberOf Tone.Envelope#
		 * @type {Number}
		 * @name value
		 * @readOnly
		 */
	    Object.defineProperty(Tone.Envelope.prototype, 'value', {
	        get: function () {
	            return this.getValueAtTime(this.now());
	        }
	    });
	    /**
		 * The shape of the attack.
		 * Can be any of these strings:
		 * <ul>
		 *   <li>linear</li>
		 *   <li>exponential</li>
		 *   <li>sine</li>
		 *   <li>cosine</li>
		 *   <li>bounce</li>
		 *   <li>ripple</li>
		 *   <li>step</li>
		 * </ul>
		 * Can also be an array which describes the curve. Values
		 * in the array are evenly subdivided and linearly
		 * interpolated over the duration of the attack.
		 * @memberOf Tone.Envelope#
		 * @type {String|Array}
		 * @name attackCurve
		 * @example
		 * env.attackCurve = "linear";
		 * @example
		 * //can also be an array
		 * env.attackCurve = [0, 0.2, 0.3, 0.4, 1]
		 */
	    Object.defineProperty(Tone.Envelope.prototype, 'attackCurve', {
	        get: function () {
	            if (Tone.isString(this._attackCurve)) {
	                return this._attackCurve;
	            } else if (Tone.isArray(this._attackCurve)) {
	                //look up the name in the curves array
	                for (var type in Tone.Envelope.Type) {
	                    if (Tone.Envelope.Type[type].In === this._attackCurve) {
	                        return type;
	                    }
	                }
	                //otherwise just return the array
	                return this._attackCurve;
	            }
	        },
	        set: function (curve) {
	            //check if it's a valid type
	            if (Tone.Envelope.Type.hasOwnProperty(curve)) {
	                var curveDef = Tone.Envelope.Type[curve];
	                if (Tone.isObject(curveDef)) {
	                    this._attackCurve = curveDef.In;
	                } else {
	                    this._attackCurve = curveDef;
	                }
	            } else if (Tone.isArray(curve)) {
	                this._attackCurve = curve;
	            } else {
	                throw new Error('Tone.Envelope: invalid curve: ' + curve);
	            }
	        }
	    });
	    /**
		 * The shape of the release. See the attack curve types.
		 * @memberOf Tone.Envelope#
		 * @type {String|Array}
		 * @name releaseCurve
		 * @example
		 * env.releaseCurve = "linear";
		 */
	    Object.defineProperty(Tone.Envelope.prototype, 'releaseCurve', {
	        get: function () {
	            if (Tone.isString(this._releaseCurve)) {
	                return this._releaseCurve;
	            } else if (Tone.isArray(this._releaseCurve)) {
	                //look up the name in the curves array
	                for (var type in Tone.Envelope.Type) {
	                    if (Tone.Envelope.Type[type].Out === this._releaseCurve) {
	                        return type;
	                    }
	                }
	                //otherwise just return the array
	                return this._releaseCurve;
	            }
	        },
	        set: function (curve) {
	            //check if it's a valid type
	            if (Tone.Envelope.Type.hasOwnProperty(curve)) {
	                var curveDef = Tone.Envelope.Type[curve];
	                if (Tone.isObject(curveDef)) {
	                    this._releaseCurve = curveDef.Out;
	                } else {
	                    this._releaseCurve = curveDef;
	                }
	            } else if (Tone.isArray(curve)) {
	                this._releaseCurve = curve;
	            } else {
	                throw new Error('Tone.Envelope: invalid curve: ' + curve);
	            }
	        }
	    });
	    /**
		 *  Trigger the attack/decay portion of the ADSR envelope.
		 *  @param  {Time} [time=now] When the attack should start.
		 *  @param {NormalRange} [velocity=1] The velocity of the envelope scales the vales.
		 *                               number between 0-1
		 *  @returns {Tone.Envelope} this
		 *  @example
		 *  //trigger the attack 0.5 seconds from now with a velocity of 0.2
		 *  env.triggerAttack("+0.5", 0.2);
		 */
	    Tone.Envelope.prototype.triggerAttack = function (time, velocity) {
	        time = this.toSeconds(time);
	        var originalAttack = this.toSeconds(this.attack);
	        var attack = originalAttack;
	        var decay = this.toSeconds(this.decay);
	        velocity = Tone.defaultArg(velocity, 1);
	        //check if it's not a complete attack
	        var currentValue = this.getValueAtTime(time);
	        if (currentValue > 0) {
	            //subtract the current value from the attack time
	            var attackRate = 1 / attack;
	            var remainingDistance = 1 - currentValue;
	            //the attack is now the remaining time
	            attack = remainingDistance / attackRate;
	        }
	        //attack
	        if (this._attackCurve === 'linear') {
	            this._sig.linearRampToValue(velocity, attack, time);
	        } else if (this._attackCurve === 'exponential') {
	            this._sig.exponentialRampToValue(velocity, attack, time);
	        } else if (attack > 0) {
	            this._sig.setRampPoint(time);
	            var curve = this._attackCurve;
	            //take only a portion of the curve
	            if (attack < originalAttack) {
	                var percentComplete = 1 - attack / originalAttack;
	                var sliceIndex = Math.floor(percentComplete * this._attackCurve.length);
	                curve = this._attackCurve.slice(sliceIndex);
	                //the first index is the current value
	                curve[0] = currentValue;
	            }
	            this._sig.setValueCurveAtTime(curve, time, attack, velocity);
	        }
	        //decay
	        this._sig.exponentialRampToValue(velocity * this.sustain, decay, attack + time);
	        return this;
	    };
	    /**
		 *  Triggers the release of the envelope.
		 *  @param  {Time} [time=now] When the release portion of the envelope should start.
		 *  @returns {Tone.Envelope} this
		 *  @example
		 *  //trigger release immediately
		 *  env.triggerRelease();
		 */
	    Tone.Envelope.prototype.triggerRelease = function (time) {
	        time = this.toSeconds(time);
	        var currentValue = this.getValueAtTime(time);
	        if (currentValue > 0) {
	            var release = this.toSeconds(this.release);
	            if (this._releaseCurve === 'linear') {
	                this._sig.linearRampToValue(0, release, time);
	            } else if (this._releaseCurve === 'exponential') {
	                this._sig.exponentialRampToValue(0, release, time);
	            } else {
	                var curve = this._releaseCurve;
	                if (Tone.isArray(curve)) {
	                    this._sig.setRampPoint(time);
	                    this._sig.setValueCurveAtTime(curve, time, release, currentValue);
	                }
	            }
	        }
	        return this;
	    };
	    /**
		 *  Get the scheduled value at the given time. This will
		 *  return the unconverted (raw) value.
		 *  @param  {Number}  time  The time in seconds.
		 *  @return  {Number}  The scheduled value at the given time.
		 */
	    Tone.Envelope.prototype.getValueAtTime = function (time) {
	        return this._sig.getValueAtTime(time);
	    };
	    /**
		 *  triggerAttackRelease is shorthand for triggerAttack, then waiting
		 *  some duration, then triggerRelease.
		 *  @param {Time} duration The duration of the sustain.
		 *  @param {Time} [time=now] When the attack should be triggered.
		 *  @param {number} [velocity=1] The velocity of the envelope.
		 *  @returns {Tone.Envelope} this
		 *  @example
		 * //trigger the attack and then the release after 0.6 seconds.
		 * env.triggerAttackRelease(0.6);
		 */
	    Tone.Envelope.prototype.triggerAttackRelease = function (duration, time, velocity) {
	        time = this.toSeconds(time);
	        this.triggerAttack(time, velocity);
	        this.triggerRelease(time + this.toSeconds(duration));
	        return this;
	    };
	    /**
		 *  Cancels all scheduled envelope changes after the given time.
		 *  @param  {Time} after
		 *  @returns {Tone.Envelope} this
		 */
	    Tone.Envelope.prototype.cancel = function (after) {
	        this._sig.cancelScheduledValues(after);
	        return this;
	    };
	    /**
		 *  Borrows the connect method from Tone.Signal.
		 *  @function
		 *  @private
		 */
	    Tone.Envelope.prototype.connect = Tone.Signal.prototype.connect;
	    /**
	 	 *  Generate some complex envelope curves.
	 	 */
	    (function _createCurves() {
	        var curveLen = 128;
	        var i, k;
	        //cosine curve
	        var cosineCurve = [];
	        for (i = 0; i < curveLen; i++) {
	            cosineCurve[i] = Math.sin(i / (curveLen - 1) * (Math.PI / 2));
	        }
	        //ripple curve
	        var rippleCurve = [];
	        var rippleCurveFreq = 6.4;
	        for (i = 0; i < curveLen - 1; i++) {
	            k = i / (curveLen - 1);
	            var sineWave = Math.sin(k * (Math.PI * 2) * rippleCurveFreq - Math.PI / 2) + 1;
	            rippleCurve[i] = sineWave / 10 + k * 0.83;
	        }
	        rippleCurve[curveLen - 1] = 1;
	        //stairs curve
	        var stairsCurve = [];
	        var steps = 5;
	        for (i = 0; i < curveLen; i++) {
	            stairsCurve[i] = Math.ceil(i / (curveLen - 1) * steps) / steps;
	        }
	        //in-out easing curve
	        var sineCurve = [];
	        for (i = 0; i < curveLen; i++) {
	            k = i / (curveLen - 1);
	            sineCurve[i] = 0.5 * (1 - Math.cos(Math.PI * k));
	        }
	        //a bounce curve
	        var bounceCurve = [];
	        for (i = 0; i < curveLen; i++) {
	            k = i / (curveLen - 1);
	            var freq = Math.pow(k, 3) * 4 + 0.2;
	            var val = Math.cos(freq * Math.PI * 2 * k);
	            bounceCurve[i] = Math.abs(val * (1 - k));
	        }
	        /**
			 *  Invert a value curve to make it work for the release
			 *  @private
			 */
	        function invertCurve(curve) {
	            var out = new Array(curve.length);
	            for (var j = 0; j < curve.length; j++) {
	                out[j] = 1 - curve[j];
	            }
	            return out;
	        }
	        /**
			 *  reverse the curve
			 *  @private
			 */
	        function reverseCurve(curve) {
	            return curve.slice(0).reverse();
	        }
	        /**
			 *  attack and release curve arrays
			 *  @type  {Object}
			 *  @private
			 */
	        Tone.Envelope.Type = {
	            'linear': 'linear',
	            'exponential': 'exponential',
	            'bounce': {
	                In: invertCurve(bounceCurve),
	                Out: bounceCurve
	            },
	            'cosine': {
	                In: cosineCurve,
	                Out: reverseCurve(cosineCurve)
	            },
	            'step': {
	                In: stairsCurve,
	                Out: invertCurve(stairsCurve)
	            },
	            'ripple': {
	                In: rippleCurve,
	                Out: invertCurve(rippleCurve)
	            },
	            'sine': {
	                In: sineCurve,
	                Out: invertCurve(sineCurve)
	            }
	        };
	    }());
	    /**
		 *  Disconnect and dispose.
		 *  @returns {Tone.Envelope} this
		 */
	    Tone.Envelope.prototype.dispose = function () {
	        Tone.AudioNode.prototype.dispose.call(this);
	        this._sig.dispose();
	        this._sig = null;
	        this._attackCurve = null;
	        this._releaseCurve = null;
	        return this;
	    };
	    return Tone.Envelope;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class  Tone.AmplitudeEnvelope is a Tone.Envelope connected to a gain node.
		 *          Unlike Tone.Envelope, which outputs the envelope's value, Tone.AmplitudeEnvelope accepts
		 *          an audio signal as the input and will apply the envelope to the amplitude
		 *          of the signal. Read more about ADSR Envelopes on [Wikipedia](https://en.wikipedia.org/wiki/Synthesizer#ADSR_envelope).
		 *
		 *  @constructor
		 *  @extends {Tone.Envelope}
		 *  @param {Time|Object} [attack] The amount of time it takes for the envelope to go from
		 *                               0 to it's maximum value.
		 *  @param {Time} [decay]	The period of time after the attack that it takes for the envelope
		 *                       	to fall to the sustain value.
		 *  @param {NormalRange} [sustain]	The percent of the maximum value that the envelope rests at until
		 *                                	the release is triggered.
		 *  @param {Time} [release]	The amount of time after the release is triggered it takes to reach 0.
		 *  @example
		 * var ampEnv = new Tone.AmplitudeEnvelope({
		 * 	"attack": 0.1,
		 * 	"decay": 0.2,
		 * 	"sustain": 1.0,
		 * 	"release": 0.8
		 * }).toMaster();
		 * //create an oscillator and connect it
		 * var osc = new Tone.Oscillator().connect(ampEnv).start();
		 * //trigger the envelopes attack and release "8t" apart
		 * ampEnv.triggerAttackRelease("8t");
		 */
	    Tone.AmplitudeEnvelope = function () {
	        Tone.Envelope.apply(this, arguments);
	        /**
			 *  the input node
			 *  @type {GainNode}
			 *  @private
			 */
	        this.input = this.output = new Tone.Gain();
	        this._sig.connect(this.output.gain);
	    };
	    Tone.extend(Tone.AmplitudeEnvelope, Tone.Envelope);
	    /**
		 *  Clean up
		 *  @return  {Tone.AmplitudeEnvelope}  this
		 */
	    Tone.AmplitudeEnvelope.prototype.dispose = function () {
	        Tone.Envelope.prototype.dispose.call(this);
	        return this;
	    };
	    return Tone.AmplitudeEnvelope;
	});
	Module(function (Tone) {
	    
	    /**
		 *  AnalyserNode.getFloatTimeDomainData polyfill
		 *  @private
		 */
	    if (window.AnalyserNode && !AnalyserNode.prototype.getFloatTimeDomainData) {
	        //referenced https://github.com/mohayonao/get-float-time-domain-data
	        AnalyserNode.prototype.getFloatTimeDomainData = function (array) {
	            var uint8 = new Uint8Array(array.length);
	            this.getByteTimeDomainData(uint8);
	            for (var i = 0; i < uint8.length; i++) {
	                array[i] = (uint8[i] - 128) / 128;
	            }
	        };
	    }
	    /**
		 *  @class  Wrapper around the native Web Audio's
		 *          [AnalyserNode](http://webaudio.github.io/web-audio-api/#idl-def-AnalyserNode).
		 *          Extracts FFT or Waveform data from the incoming signal.
		 *  @extends {Tone.AudioNode}
		 *  @param {String=} type The return type of the analysis, either "fft", or "waveform".
		 *  @param {Number=} size The size of the FFT. Value must be a power of
		 *                       two in the range 32 to 32768.
		 */
	    Tone.Analyser = function () {
	        var options = Tone.defaults(arguments, [
	            'type',
	            'size'
	        ], Tone.Analyser);
	        Tone.AudioNode.call(this);
	        /**
			 *  The analyser node.
			 *  @private
			 *  @type {AnalyserNode}
			 */
	        this._analyser = this.input = this.output = this.context.createAnalyser();
	        /**
			 *  The analysis type
			 *  @type {String}
			 *  @private
			 */
	        this._type = options.type;
	        /**
			 *  The buffer that the FFT data is written to
			 *  @type {TypedArray}
			 *  @private
			 */
	        this._buffer = null;
	        //set the values initially
	        this.size = options.size;
	        this.type = options.type;
	    };
	    Tone.extend(Tone.Analyser, Tone.AudioNode);
	    /**
		 *  The default values.
		 *  @type {Object}
		 *  @const
		 */
	    Tone.Analyser.defaults = {
	        'size': 1024,
	        'type': 'fft',
	        'smoothing': 0.8
	    };
	    /**
		 *  Possible return types of Tone.Analyser.analyse()
		 *  @enum {String}
		 */
	    Tone.Analyser.Type = {
	        Waveform: 'waveform',
	        FFT: 'fft'
	    };
	    /**
		 *  Run the analysis given the current settings and return the
		 *  result as a TypedArray.
		 *  @returns {TypedArray}
		 */
	    Tone.Analyser.prototype.analyse = function () {
	        if (this._type === Tone.Analyser.Type.FFT) {
	            this._analyser.getFloatFrequencyData(this._buffer);
	        } else if (this._type === Tone.Analyser.Type.Waveform) {
	            this._analyser.getFloatTimeDomainData(this._buffer);
	        }
	        return this._buffer;
	    };
	    /**
		 *  The size of analysis. This must be a power of two in the range 32 to 32768.
		 *  @memberOf Tone.Analyser#
		 *  @type {Number}
		 *  @name size
		 */
	    Object.defineProperty(Tone.Analyser.prototype, 'size', {
	        get: function () {
	            return this._analyser.frequencyBinCount;
	        },
	        set: function (size) {
	            this._analyser.fftSize = size * 2;
	            this._buffer = new Float32Array(size);
	        }
	    });
	    /**
		 *  The analysis function returned by Tone.Analyser.analyse(), either "fft" or "waveform".
		 *  @memberOf Tone.Analyser#
		 *  @type {String}
		 *  @name type
		 */
	    Object.defineProperty(Tone.Analyser.prototype, 'type', {
	        get: function () {
	            return this._type;
	        },
	        set: function (type) {
	            if (type !== Tone.Analyser.Type.Waveform && type !== Tone.Analyser.Type.FFT) {
	                throw new TypeError('Tone.Analyser: invalid type: ' + type);
	            }
	            this._type = type;
	        }
	    });
	    /**
		 *  0 represents no time averaging with the last analysis frame.
		 *  @memberOf Tone.Analyser#
		 *  @type {NormalRange}
		 *  @name smoothing
		 */
	    Object.defineProperty(Tone.Analyser.prototype, 'smoothing', {
	        get: function () {
	            return this._analyser.smoothingTimeConstant;
	        },
	        set: function (val) {
	            this._analyser.smoothingTimeConstant = val;
	        }
	    });
	    /**
		 *  Clean up.
		 *  @return  {Tone.Analyser}  this
		 */
	    Tone.Analyser.prototype.dispose = function () {
	        Tone.AudioNode.prototype.dispose.call(this);
	        this._analyser.disconnect();
	        this._analyser = null;
	        this._buffer = null;
	    };
	    return Tone.Analyser;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Tone.Compressor is a thin wrapper around the Web Audio
		 *         [DynamicsCompressorNode](http://webaudio.github.io/web-audio-api/#the-dynamicscompressornode-interface).
		 *         Compression reduces the volume of loud sounds or amplifies quiet sounds
		 *         by narrowing or "compressing" an audio signal's dynamic range.
		 *         Read more on [Wikipedia](https://en.wikipedia.org/wiki/Dynamic_range_compression).
		 *
		 *  @extends {Tone.AudioNode}
		 *  @constructor
		 *  @param {Decibels|Object} [threshold] The value above which the compression starts to be applied.
		 *  @param {Positive} [ratio] The gain reduction ratio.
		 *  @example
		 * var comp = new Tone.Compressor(-30, 3);
		 */
	    Tone.Compressor = function () {
	        var options = Tone.defaults(arguments, [
	            'threshold',
	            'ratio'
	        ], Tone.Compressor);
	        Tone.AudioNode.call(this);
	        /**
			 *  the compressor node
			 *  @type {DynamicsCompressorNode}
			 *  @private
			 */
	        this._compressor = this.input = this.output = this.context.createDynamicsCompressor();
	        /**
			 *  the threshold vaue
			 *  @type {Decibels}
			 *  @signal
			 */
	        this.threshold = new Tone.Param({
	            'param': this._compressor.threshold,
	            'units': Tone.Type.Decibels,
	            'convert': false
	        });
	        /**
			 *  The attack parameter
			 *  @type {Time}
			 *  @signal
			 */
	        this.attack = new Tone.Param(this._compressor.attack, Tone.Type.Time);
	        /**
			 *  The release parameter
			 *  @type {Time}
			 *  @signal
			 */
	        this.release = new Tone.Param(this._compressor.release, Tone.Type.Time);
	        /**
			 *  The knee parameter
			 *  @type {Decibels}
			 *  @signal
			 */
	        this.knee = new Tone.Param({
	            'param': this._compressor.knee,
	            'units': Tone.Type.Decibels,
	            'convert': false
	        });
	        /**
			 *  The ratio value
			 *  @type {Number}
			 *  @signal
			 */
	        this.ratio = new Tone.Param({
	            'param': this._compressor.ratio,
	            'convert': false
	        });
	        //set the defaults
	        this._readOnly([
	            'knee',
	            'release',
	            'attack',
	            'ratio',
	            'threshold'
	        ]);
	        this.set(options);
	    };
	    Tone.extend(Tone.Compressor, Tone.AudioNode);
	    /**
		 *  @static
		 *  @const
		 *  @type {Object}
		 */
	    Tone.Compressor.defaults = {
	        'ratio': 12,
	        'threshold': -24,
	        'release': 0.25,
	        'attack': 0.003,
	        'knee': 30
	    };
	    /**
		 *  clean up
		 *  @returns {Tone.Compressor} this
		 */
	    Tone.Compressor.prototype.dispose = function () {
	        Tone.AudioNode.prototype.dispose.call(this);
	        this._writable([
	            'knee',
	            'release',
	            'attack',
	            'ratio',
	            'threshold'
	        ]);
	        this._compressor.disconnect();
	        this._compressor = null;
	        this.attack.dispose();
	        this.attack = null;
	        this.release.dispose();
	        this.release = null;
	        this.threshold.dispose();
	        this.threshold = null;
	        this.ratio.dispose();
	        this.ratio = null;
	        this.knee.dispose();
	        this.knee = null;
	        return this;
	    };
	    return Tone.Compressor;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Add a signal and a number or two signals. When no value is
		 *         passed into the constructor, Tone.Add will sum <code>input[0]</code>
		 *         and <code>input[1]</code>. If a value is passed into the constructor, 
		 *         the it will be added to the input.
		 *  
		 *  @constructor
		 *  @extends {Tone.Signal}
		 *  @param {number=} value If no value is provided, Tone.Add will sum the first
		 *                         and second inputs. 
		 *  @example
		 * var signal = new Tone.Signal(2);
		 * var add = new Tone.Add(2);
		 * signal.connect(add);
		 * //the output of add equals 4
		 *  @example
		 * //if constructed with no arguments
		 * //it will add the first and second inputs
		 * var add = new Tone.Add();
		 * var sig0 = new Tone.Signal(3).connect(add, 0, 0);
		 * var sig1 = new Tone.Signal(4).connect(add, 0, 1);
		 * //the output of add equals 7. 
		 */
	    Tone.Add = function (value) {
	        Tone.Signal.call(this);
	        this.createInsOuts(2, 0);
	        /**
			 *  the summing node
			 *  @type {GainNode}
			 *  @private
			 */
	        this._sum = this.input[0] = this.input[1] = this.output = new Tone.Gain();
	        /**
			 *  @private
			 *  @type {Tone.Signal}
			 */
	        this._param = this.input[1] = new Tone.Signal(value);
	        this._param.connect(this._sum);
	    };
	    Tone.extend(Tone.Add, Tone.Signal);
	    /**
		 *  Clean up.
		 *  @returns {Tone.Add} this
		 */
	    Tone.Add.prototype.dispose = function () {
	        Tone.Signal.prototype.dispose.call(this);
	        this._sum.dispose();
	        this._sum = null;
	        return this;
	    };
	    return Tone.Add;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class  Multiply two incoming signals. Or, if a number is given in the constructor, 
		 *          multiplies the incoming signal by that value. 
		 *
		 *  @constructor
		 *  @extends {Tone.Signal}
		 *  @param {number=} value Constant value to multiple. If no value is provided,
		 *                         it will return the product of the first and second inputs
		 *  @example
		 * var mult = new Tone.Multiply();
		 * var sigA = new Tone.Signal(3);
		 * var sigB = new Tone.Signal(4);
		 * sigA.connect(mult, 0, 0);
		 * sigB.connect(mult, 0, 1);
		 * //output of mult is 12.
		 *  @example
		 * var mult = new Tone.Multiply(10);
		 * var sig = new Tone.Signal(2).connect(mult);
		 * //the output of mult is 20. 
		 */
	    Tone.Multiply = function (value) {
	        Tone.Signal.call(this);
	        this.createInsOuts(2, 0);
	        /**
			 *  the input node is the same as the output node
			 *  it is also the GainNode which handles the scaling of incoming signal
			 *  
			 *  @type {GainNode}
			 *  @private
			 */
	        this._mult = this.input[0] = this.output = new Tone.Gain();
	        /**
			 *  the scaling parameter
			 *  @type {AudioParam}
			 *  @private
			 */
	        this._param = this.input[1] = this.output.gain;
	        this._param.value = Tone.defaultArg(value, 0);
	    };
	    Tone.extend(Tone.Multiply, Tone.Signal);
	    /**
		 *  clean up
		 *  @returns {Tone.Multiply} this
		 */
	    Tone.Multiply.prototype.dispose = function () {
	        Tone.Signal.prototype.dispose.call(this);
	        this._mult.dispose();
	        this._mult = null;
	        this._param = null;
	        return this;
	    };
	    return Tone.Multiply;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Negate the incoming signal. i.e. an input signal of 10 will output -10
		 *
		 *  @constructor
		 *  @extends {Tone.SignalBase}
		 *  @example
		 * var neg = new Tone.Negate();
		 * var sig = new Tone.Signal(-2).connect(neg);
		 * //output of neg is positive 2. 
		 */
	    Tone.Negate = function () {
	        Tone.SignalBase.call(this);
	        /**
			 *  negation is done by multiplying by -1
			 *  @type {Tone.Multiply}
			 *  @private
			 */
	        this._multiply = this.input = this.output = new Tone.Multiply(-1);
	    };
	    Tone.extend(Tone.Negate, Tone.SignalBase);
	    /**
		 *  clean up
		 *  @returns {Tone.Negate} this
		 */
	    Tone.Negate.prototype.dispose = function () {
	        Tone.SignalBase.prototype.dispose.call(this);
	        this._multiply.dispose();
	        this._multiply = null;
	        return this;
	    };
	    return Tone.Negate;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Subtract the signal connected to <code>input[1]</code> from the signal connected 
		 *         to <code>input[0]</code>. If an argument is provided in the constructor, the 
		 *         signals <code>.value</code> will be subtracted from the incoming signal.
		 *
		 *  @extends {Tone.Signal}
		 *  @constructor
		 *  @param {number=} value The value to subtract from the incoming signal. If the value
		 *                         is omitted, it will subtract the second signal from the first.
		 *  @example
		 * var sub = new Tone.Subtract(1);
		 * var sig = new Tone.Signal(4).connect(sub);
		 * //the output of sub is 3. 
		 *  @example
		 * var sub = new Tone.Subtract();
		 * var sigA = new Tone.Signal(10);
		 * var sigB = new Tone.Signal(2.5);
		 * sigA.connect(sub, 0, 0);
		 * sigB.connect(sub, 0, 1);
		 * //output of sub is 7.5
		 */
	    Tone.Subtract = function (value) {
	        Tone.Signal.call(this);
	        this.createInsOuts(2, 0);
	        /**
			 *  the summing node
			 *  @type {GainNode}
			 *  @private
			 */
	        this._sum = this.input[0] = this.output = new Tone.Gain();
	        /**
			 *  negate the input of the second input before connecting it
			 *  to the summing node.
			 *  @type {Tone.Negate}
			 *  @private
			 */
	        this._neg = new Tone.Negate();
	        /**
			 *  the node where the value is set
			 *  @private
			 *  @type {Tone.Signal}
			 */
	        this._param = this.input[1] = new Tone.Signal(value);
	        this._param.chain(this._neg, this._sum);
	    };
	    Tone.extend(Tone.Subtract, Tone.Signal);
	    /**
		 *  Clean up.
		 *  @returns {Tone.SignalBase} this
		 */
	    Tone.Subtract.prototype.dispose = function () {
	        Tone.Signal.prototype.dispose.call(this);
	        this._neg.dispose();
	        this._neg = null;
	        this._sum.disconnect();
	        this._sum = null;
	        return this;
	    };
	    return Tone.Subtract;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class  GreaterThanZero outputs 1 when the input is strictly greater than zero
		 *  
		 *  @constructor
		 *  @extends {Tone.SignalBase}
		 *  @example
		 * var gt0 = new Tone.GreaterThanZero();
		 * var sig = new Tone.Signal(0.01).connect(gt0);
		 * //the output of gt0 is 1. 
		 * sig.value = 0;
		 * //the output of gt0 is 0. 
		 */
	    Tone.GreaterThanZero = function () {
	        Tone.SignalBase.call(this);
	        /**
			 *  @type {Tone.WaveShaper}
			 *  @private
			 */
	        this._thresh = this.output = new Tone.WaveShaper(function (val) {
	            if (val <= 0) {
	                return 0;
	            } else {
	                return 1;
	            }
	        }, 127);
	        /**
			 *  scale the first thresholded signal by a large value.
			 *  this will help with values which are very close to 0
			 *  @type {Tone.Multiply}
			 *  @private
			 */
	        this._scale = this.input = new Tone.Multiply(10000);
	        //connections
	        this._scale.connect(this._thresh);
	    };
	    Tone.extend(Tone.GreaterThanZero, Tone.SignalBase);
	    /**
		 *  dispose method
		 *  @returns {Tone.GreaterThanZero} this
		 */
	    Tone.GreaterThanZero.prototype.dispose = function () {
	        Tone.SignalBase.prototype.dispose.call(this);
	        this._scale.dispose();
	        this._scale = null;
	        this._thresh.dispose();
	        this._thresh = null;
	        return this;
	    };
	    return Tone.GreaterThanZero;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class  Output 1 if the signal is greater than the value, otherwise outputs 0.
		 *          can compare two signals or a signal and a number. 
		 *  
		 *  @constructor
		 *  @extends {Tone.Signal}
		 *  @param {number} [value=0] the value to compare to the incoming signal
		 *  @example
		 * var gt = new Tone.GreaterThan(2);
		 * var sig = new Tone.Signal(4).connect(gt);
		 * //output of gt is equal 1. 
		 */
	    Tone.GreaterThan = function (value) {
	        Tone.Signal.call(this);
	        this.createInsOuts(2, 0);
	        /**
			 *  subtract the amount from the incoming signal
			 *  @type {Tone.Subtract}
			 *  @private
			 */
	        this._param = this.input[0] = new Tone.Subtract(value);
	        this.input[1] = this._param.input[1];
	        /**
			 *  compare that amount to zero
			 *  @type {Tone.GreaterThanZero}
			 *  @private
			 */
	        this._gtz = this.output = new Tone.GreaterThanZero();
	        //connect
	        this._param.connect(this._gtz);
	    };
	    Tone.extend(Tone.GreaterThan, Tone.Signal);
	    /**
		 *  dispose method
		 *  @returns {Tone.GreaterThan} this
		 */
	    Tone.GreaterThan.prototype.dispose = function () {
	        Tone.Signal.prototype.dispose.call(this);
	        this._gtz.dispose();
	        this._gtz = null;
	        return this;
	    };
	    return Tone.GreaterThan;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Return the absolute value of an incoming signal. 
		 *  
		 *  @constructor
		 *  @extends {Tone.SignalBase}
		 *  @example
		 * var signal = new Tone.Signal(-1);
		 * var abs = new Tone.Abs();
		 * signal.connect(abs);
		 * //the output of abs is 1. 
		 */
	    Tone.Abs = function () {
	        Tone.SignalBase.call(this);
	        /**
			 *  @type {Tone.LessThan}
			 *  @private
			 */
	        this._abs = this.input = this.output = new Tone.WaveShaper(function (val) {
	            if (val === 0) {
	                return 0;
	            } else {
	                return Math.abs(val);
	            }
	        }, 127);
	    };
	    Tone.extend(Tone.Abs, Tone.SignalBase);
	    /**
		 *  dispose method
		 *  @returns {Tone.Abs} this
		 */
	    Tone.Abs.prototype.dispose = function () {
	        Tone.SignalBase.prototype.dispose.call(this);
	        this._abs.dispose();
	        this._abs = null;
	        return this;
	    };
	    return Tone.Abs;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Signal-rate modulo operator. Only works in AudioRange [-1, 1] and for modulus
		 *         values in the NormalRange. 
		 *
		 *  @constructor
		 *  @extends {Tone.SignalBase}
		 *  @param {NormalRange} modulus The modulus to apply.
		 *  @example
		 * var mod = new Tone.Modulo(0.2)
		 * var sig = new Tone.Signal(0.5).connect(mod);
		 * //mod outputs 0.1
		 */
	    Tone.Modulo = function (modulus) {
	        Tone.SignalBase.call(this);
	        this.createInsOuts(1, 0);
	        /**
			 *  A waveshaper gets the integer multiple of 
			 *  the input signal and the modulus.
			 *  @private
			 *  @type {Tone.WaveShaper}
			 */
	        this._shaper = new Tone.WaveShaper(Math.pow(2, 16));
	        /**
			 *  the integer multiple is multiplied by the modulus
			 *  @type  {Tone.Multiply}
			 *  @private
			 */
	        this._multiply = new Tone.Multiply();
	        /**
			 *  and subtracted from the input signal
			 *  @type  {Tone.Subtract}
			 *  @private
			 */
	        this._subtract = this.output = new Tone.Subtract();
	        /**
			 *  the modulus signal
			 *  @type  {Tone.Signal}
			 *  @private
			 */
	        this._modSignal = new Tone.Signal(modulus);
	        //connections
	        this.input.fan(this._shaper, this._subtract);
	        this._modSignal.connect(this._multiply, 0, 0);
	        this._shaper.connect(this._multiply, 0, 1);
	        this._multiply.connect(this._subtract, 0, 1);
	        this._setWaveShaper(modulus);
	    };
	    Tone.extend(Tone.Modulo, Tone.SignalBase);
	    /**
		 *  @param  {number}  mod  the modulus to apply
		 *  @private
		 */
	    Tone.Modulo.prototype._setWaveShaper = function (mod) {
	        this._shaper.setMap(function (val) {
	            var multiple = Math.floor((val + 0.0001) / mod);
	            return multiple;
	        });
	    };
	    /**
		 * The modulus value.
		 * @memberOf Tone.Modulo#
		 * @type {NormalRange}
		 * @name value
		 */
	    Object.defineProperty(Tone.Modulo.prototype, 'value', {
	        get: function () {
	            return this._modSignal.value;
	        },
	        set: function (mod) {
	            this._modSignal.value = mod;
	            this._setWaveShaper(mod);
	        }
	    });
	    /**
		 * clean up
		 *  @returns {Tone.Modulo} this
		 */
	    Tone.Modulo.prototype.dispose = function () {
	        Tone.SignalBase.prototype.dispose.call(this);
	        this._shaper.dispose();
	        this._shaper = null;
	        this._multiply.dispose();
	        this._multiply = null;
	        this._subtract.dispose();
	        this._subtract = null;
	        this._modSignal.dispose();
	        this._modSignal = null;
	        return this;
	    };
	    return Tone.Modulo;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class AudioToGain converts an input in AudioRange [-1,1] to NormalRange [0,1]. 
		 *         See Tone.GainToAudio.
		 *
		 *  @extends {Tone.SignalBase}
		 *  @constructor
		 *  @example
		 *  var a2g = new Tone.AudioToGain();
		 */
	    Tone.AudioToGain = function () {
	        Tone.SignalBase.call(this);
	        /**
			 *  @type {WaveShaperNode}
			 *  @private
			 */
	        this._norm = this.input = this.output = new Tone.WaveShaper(function (x) {
	            return (x + 1) / 2;
	        });
	    };
	    Tone.extend(Tone.AudioToGain, Tone.SignalBase);
	    /**
		 *  clean up
		 *  @returns {Tone.AudioToGain} this
		 */
	    Tone.AudioToGain.prototype.dispose = function () {
	        Tone.SignalBase.prototype.dispose.call(this);
	        this._norm.dispose();
	        this._norm = null;
	        return this;
	    };
	    return Tone.AudioToGain;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Evaluate an expression at audio rate. <br><br>
		 *         Parsing code modified from https://code.google.com/p/tapdigit/
		 *         Copyright 2011 2012 Ariya Hidayat, New BSD License
		 *
		 *  @extends {Tone.SignalBase}
		 *  @constructor
		 *  @param {string} expr the expression to generate
		 *  @example
		 * //adds the signals from input[0] and input[1].
		 * var expr = new Tone.Expr("$0 + $1");
		 */
	    Tone.Expr = function () {
	        Tone.SignalBase.call(this);
	        var expr = this._replacements(Array.prototype.slice.call(arguments));
	        var inputCount = this._parseInputs(expr);
	        /**
			 *  hold onto all of the nodes for disposal
			 *  @type {Array}
			 *  @private
			 */
	        this._nodes = [];
	        /**
			 *  The inputs. The length is determined by the expression. 
			 *  @type {Array}
			 */
	        this.input = new Array(inputCount);
	        //create a gain for each input
	        for (var i = 0; i < inputCount; i++) {
	            this.input[i] = this.context.createGain();
	        }
	        //parse the syntax tree
	        var tree = this._parseTree(expr);
	        //evaluate the results
	        var result;
	        try {
	            result = this._eval(tree);
	        } catch (e) {
	            this._disposeNodes();
	            throw new Error('Tone.Expr: Could evaluate expression: ' + expr);
	        }
	        /**
			 *  The output node is the result of the expression
			 *  @type {Tone}
			 */
	        this.output = result;
	    };
	    Tone.extend(Tone.Expr, Tone.SignalBase);
	    //some helpers to cut down the amount of code
	    function applyBinary(Constructor, args, self) {
	        var op = new Constructor();
	        self._eval(args[0]).connect(op, 0, 0);
	        self._eval(args[1]).connect(op, 0, 1);
	        return op;
	    }
	    function applyUnary(Constructor, args, self) {
	        var op = new Constructor();
	        self._eval(args[0]).connect(op, 0, 0);
	        return op;
	    }
	    function getNumber(arg) {
	        return arg ? parseFloat(arg) : undefined;
	    }
	    function literalNumber(arg) {
	        return arg && arg.args ? parseFloat(arg.args) : undefined;
	    }
	    /*
		 *  the Expressions that Tone.Expr can parse.
		 *
		 *  each expression belongs to a group and contains a regexp 
		 *  for selecting the operator as well as that operators method
		 *  
		 *  @type {Object}
		 *  @private
		 */
	    Tone.Expr._Expressions = {
	        //values
	        'value': {
	            'signal': {
	                regexp: /^\d+\.\d+|^\d+/,
	                method: function (arg) {
	                    var sig = new Tone.Signal(getNumber(arg));
	                    return sig;
	                }
	            },
	            'input': {
	                regexp: /^\$\d/,
	                method: function (arg, self) {
	                    return self.input[getNumber(arg.substr(1))];
	                }
	            }
	        },
	        //syntactic glue
	        'glue': {
	            '(': { regexp: /^\(/ },
	            ')': { regexp: /^\)/ },
	            ',': { regexp: /^,/ }
	        },
	        //functions
	        'func': {
	            'abs': {
	                regexp: /^abs/,
	                method: applyUnary.bind(this, Tone.Abs)
	            },
	            'mod': {
	                regexp: /^mod/,
	                method: function (args, self) {
	                    var modulus = literalNumber(args[1]);
	                    var op = new Tone.Modulo(modulus);
	                    self._eval(args[0]).connect(op);
	                    return op;
	                }
	            },
	            'pow': {
	                regexp: /^pow/,
	                method: function (args, self) {
	                    var exp = literalNumber(args[1]);
	                    var op = new Tone.Pow(exp);
	                    self._eval(args[0]).connect(op);
	                    return op;
	                }
	            },
	            'a2g': {
	                regexp: /^a2g/,
	                method: function (args, self) {
	                    var op = new Tone.AudioToGain();
	                    self._eval(args[0]).connect(op);
	                    return op;
	                }
	            }
	        },
	        //binary expressions
	        'binary': {
	            '+': {
	                regexp: /^\+/,
	                precedence: 1,
	                method: applyBinary.bind(this, Tone.Add)
	            },
	            '-': {
	                regexp: /^\-/,
	                precedence: 1,
	                method: function (args, self) {
	                    //both unary and binary op
	                    if (args.length === 1) {
	                        return applyUnary(Tone.Negate, args, self);
	                    } else {
	                        return applyBinary(Tone.Subtract, args, self);
	                    }
	                }
	            },
	            '*': {
	                regexp: /^\*/,
	                precedence: 0,
	                method: applyBinary.bind(this, Tone.Multiply)
	            }
	        },
	        //unary expressions
	        'unary': {
	            '-': {
	                regexp: /^\-/,
	                method: applyUnary.bind(this, Tone.Negate)
	            },
	            '!': {
	                regexp: /^\!/,
	                method: applyUnary.bind(this, Tone.NOT)
	            }
	        }
	    };
	    /**
		 *  @param   {string} expr the expression string
		 *  @return  {number}      the input count
		 *  @private
		 */
	    Tone.Expr.prototype._parseInputs = function (expr) {
	        var inputArray = expr.match(/\$\d/g);
	        var inputMax = 0;
	        if (inputArray !== null) {
	            for (var i = 0; i < inputArray.length; i++) {
	                var inputNum = parseInt(inputArray[i].substr(1)) + 1;
	                inputMax = Math.max(inputMax, inputNum);
	            }
	        }
	        return inputMax;
	    };
	    /**
		 *  @param   {Array} args 	an array of arguments
		 *  @return  {string} the results of the replacements being replaced
		 *  @private
		 */
	    Tone.Expr.prototype._replacements = function (args) {
	        var expr = args.shift();
	        for (var i = 0; i < args.length; i++) {
	            expr = expr.replace(/\%/i, args[i]);
	        }
	        return expr;
	    };
	    /**
		 *  tokenize the expression based on the Expressions object
		 *  @param   {string} expr 
		 *  @return  {Object}      returns two methods on the tokenized list, next and peek
		 *  @private
		 */
	    Tone.Expr.prototype._tokenize = function (expr) {
	        var position = -1;
	        var tokens = [];
	        while (expr.length > 0) {
	            expr = expr.trim();
	            var token = getNextToken(expr);
	            tokens.push(token);
	            expr = expr.substr(token.value.length);
	        }
	        function getNextToken(expr) {
	            for (var type in Tone.Expr._Expressions) {
	                var group = Tone.Expr._Expressions[type];
	                for (var opName in group) {
	                    var op = group[opName];
	                    var reg = op.regexp;
	                    var match = expr.match(reg);
	                    if (match !== null) {
	                        return {
	                            type: type,
	                            value: match[0],
	                            method: op.method
	                        };
	                    }
	                }
	            }
	            throw new SyntaxError('Tone.Expr: Unexpected token ' + expr);
	        }
	        return {
	            next: function () {
	                return tokens[++position];
	            },
	            peek: function () {
	                return tokens[position + 1];
	            }
	        };
	    };
	    /**
		 *  recursively parse the string expression into a syntax tree
		 *  
		 *  @param   {string} expr 
		 *  @return  {Object}
		 *  @private
		 */
	    Tone.Expr.prototype._parseTree = function (expr) {
	        var lexer = this._tokenize(expr);
	        var isUndef = Tone.isUndef.bind(this);
	        function matchSyntax(token, syn) {
	            return !isUndef(token) && token.type === 'glue' && token.value === syn;
	        }
	        function matchGroup(token, groupName, prec) {
	            var ret = false;
	            var group = Tone.Expr._Expressions[groupName];
	            if (!isUndef(token)) {
	                for (var opName in group) {
	                    var op = group[opName];
	                    if (op.regexp.test(token.value)) {
	                        if (!isUndef(prec)) {
	                            if (op.precedence === prec) {
	                                return true;
	                            }
	                        } else {
	                            return true;
	                        }
	                    }
	                }
	            }
	            return ret;
	        }
	        function parseExpression(precedence) {
	            if (isUndef(precedence)) {
	                precedence = 5;
	            }
	            var expr;
	            if (precedence < 0) {
	                expr = parseUnary();
	            } else {
	                expr = parseExpression(precedence - 1);
	            }
	            var token = lexer.peek();
	            while (matchGroup(token, 'binary', precedence)) {
	                token = lexer.next();
	                expr = {
	                    operator: token.value,
	                    method: token.method,
	                    args: [
	                        expr,
	                        parseExpression(precedence - 1)
	                    ]
	                };
	                token = lexer.peek();
	            }
	            return expr;
	        }
	        function parseUnary() {
	            var token, expr;
	            token = lexer.peek();
	            if (matchGroup(token, 'unary')) {
	                token = lexer.next();
	                expr = parseUnary();
	                return {
	                    operator: token.value,
	                    method: token.method,
	                    args: [expr]
	                };
	            }
	            return parsePrimary();
	        }
	        function parsePrimary() {
	            var token, expr;
	            token = lexer.peek();
	            if (isUndef(token)) {
	                throw new SyntaxError('Tone.Expr: Unexpected termination of expression');
	            }
	            if (token.type === 'func') {
	                token = lexer.next();
	                return parseFunctionCall(token);
	            }
	            if (token.type === 'value') {
	                token = lexer.next();
	                return {
	                    method: token.method,
	                    args: token.value
	                };
	            }
	            if (matchSyntax(token, '(')) {
	                lexer.next();
	                expr = parseExpression();
	                token = lexer.next();
	                if (!matchSyntax(token, ')')) {
	                    throw new SyntaxError('Expected )');
	                }
	                return expr;
	            }
	            throw new SyntaxError('Tone.Expr: Parse error, cannot process token ' + token.value);
	        }
	        function parseFunctionCall(func) {
	            var token, args = [];
	            token = lexer.next();
	            if (!matchSyntax(token, '(')) {
	                throw new SyntaxError('Tone.Expr: Expected ( in a function call "' + func.value + '"');
	            }
	            token = lexer.peek();
	            if (!matchSyntax(token, ')')) {
	                args = parseArgumentList();
	            }
	            token = lexer.next();
	            if (!matchSyntax(token, ')')) {
	                throw new SyntaxError('Tone.Expr: Expected ) in a function call "' + func.value + '"');
	            }
	            return {
	                method: func.method,
	                args: args,
	                name: name
	            };
	        }
	        function parseArgumentList() {
	            var token, expr, args = [];
	            while (true) {
	                expr = parseExpression();
	                if (isUndef(expr)) {
	                    // TODO maybe throw exception?
	                    break;
	                }
	                args.push(expr);
	                token = lexer.peek();
	                if (!matchSyntax(token, ',')) {
	                    break;
	                }
	                lexer.next();
	            }
	            return args;
	        }
	        return parseExpression();
	    };
	    /**
		 *  recursively evaluate the expression tree
		 *  @param   {Object} tree 
		 *  @return  {AudioNode}      the resulting audio node from the expression
		 *  @private
		 */
	    Tone.Expr.prototype._eval = function (tree) {
	        if (!Tone.isUndef(tree)) {
	            var node = tree.method(tree.args, this);
	            this._nodes.push(node);
	            return node;
	        }
	    };
	    /**
		 *  dispose all the nodes
		 *  @private
		 */
	    Tone.Expr.prototype._disposeNodes = function () {
	        for (var i = 0; i < this._nodes.length; i++) {
	            var node = this._nodes[i];
	            if (Tone.isFunction(node.dispose)) {
	                node.dispose();
	            } else if (Tone.isFunction(node.disconnect)) {
	                node.disconnect();
	            }
	            node = null;
	            this._nodes[i] = null;
	        }
	        this._nodes = null;
	    };
	    /**
		 *  clean up
		 */
	    Tone.Expr.prototype.dispose = function () {
	        Tone.SignalBase.prototype.dispose.call(this);
	        this._disposeNodes();
	    };
	    return Tone.Expr;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Convert an incoming signal between 0, 1 to an equal power gain scale.
		 *
		 *  @extends {Tone.SignalBase}
		 *  @constructor
		 *  @example
		 * var eqPowGain = new Tone.EqualPowerGain();
		 */
	    Tone.EqualPowerGain = function () {
	        Tone.SignalBase.call(this);
	        /**
			 *  @type {Tone.WaveShaper}
			 *  @private
			 */
	        this._eqPower = this.input = this.output = new Tone.WaveShaper(function (val) {
	            if (Math.abs(val) < 0.001) {
	                //should output 0 when input is 0
	                return 0;
	            } else {
	                return Tone.equalPowerScale(val);
	            }
	        }.bind(this), 4096);
	    };
	    Tone.extend(Tone.EqualPowerGain, Tone.SignalBase);
	    /**
		 *  clean up
		 *  @returns {Tone.EqualPowerGain} this
		 */
	    Tone.EqualPowerGain.prototype.dispose = function () {
	        Tone.SignalBase.prototype.dispose.call(this);
	        this._eqPower.dispose();
	        this._eqPower = null;
	        return this;
	    };
	    return Tone.EqualPowerGain;
	});
	Module(function (Tone) {
	    
	    /**
		 * @class  Tone.Crossfade provides equal power fading between two inputs.
		 *         More on crossfading technique [here](https://en.wikipedia.org/wiki/Fade_(audio_engineering)#Crossfading).
		 *
		 * @constructor
		 * @extends {Tone.AudioNode}
		 * @param {NormalRange} [initialFade=0.5]
		 * @example
		 * var crossFade = new Tone.CrossFade(0.5);
		 * //connect effect A to crossfade from
		 * //effect output 0 to crossfade input 0
		 * effectA.connect(crossFade, 0, 0);
		 * //connect effect B to crossfade from
		 * //effect output 0 to crossfade input 1
		 * effectB.connect(crossFade, 0, 1);
		 * crossFade.fade.value = 0;
		 * // ^ only effectA is output
		 * crossFade.fade.value = 1;
		 * // ^ only effectB is output
		 * crossFade.fade.value = 0.5;
		 * // ^ the two signals are mixed equally.
		 */
	    Tone.CrossFade = function (initialFade) {
	        Tone.AudioNode.call(this);
	        this.createInsOuts(2, 1);
	        /**
			 *  Alias for <code>input[0]</code>.
			 *  @type {Tone.Gain}
			 */
	        this.a = this.input[0] = new Tone.Gain();
	        /**
			 *  Alias for <code>input[1]</code>.
			 *  @type {Tone.Gain}
			 */
	        this.b = this.input[1] = new Tone.Gain();
	        /**
			 * 	The mix between the two inputs. A fade value of 0
			 * 	will output 100% <code>input[0]</code> and
			 * 	a value of 1 will output 100% <code>input[1]</code>.
			 *  @type {NormalRange}
			 *  @signal
			 */
	        this.fade = new Tone.Signal(Tone.defaultArg(initialFade, 0.5), Tone.Type.NormalRange);
	        /**
			 *  equal power gain cross fade
			 *  @private
			 *  @type {Tone.EqualPowerGain}
			 */
	        this._equalPowerA = new Tone.EqualPowerGain();
	        /**
			 *  equal power gain cross fade
			 *  @private
			 *  @type {Tone.EqualPowerGain}
			 */
	        this._equalPowerB = new Tone.EqualPowerGain();
	        /**
			 *  invert the incoming signal
			 *  @private
			 *  @type {Tone}
			 */
	        this._invert = new Tone.Expr('1 - $0');
	        //connections
	        this.a.connect(this.output);
	        this.b.connect(this.output);
	        this.fade.chain(this._equalPowerB, this.b.gain);
	        this.fade.chain(this._invert, this._equalPowerA, this.a.gain);
	        this._readOnly('fade');
	    };
	    Tone.extend(Tone.CrossFade, Tone.AudioNode);
	    /**
		 *  clean up
		 *  @returns {Tone.CrossFade} this
		 */
	    Tone.CrossFade.prototype.dispose = function () {
	        Tone.AudioNode.prototype.dispose.call(this);
	        this._writable('fade');
	        this._equalPowerA.dispose();
	        this._equalPowerA = null;
	        this._equalPowerB.dispose();
	        this._equalPowerB = null;
	        this.fade.dispose();
	        this.fade = null;
	        this._invert.dispose();
	        this._invert = null;
	        this.a.dispose();
	        this.a = null;
	        this.b.dispose();
	        this.b = null;
	        return this;
	    };
	    return Tone.CrossFade;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class  Tone.Filter is a filter which allows for all of the same native methods
		 *          as the [BiquadFilterNode](http://webaudio.github.io/web-audio-api/#the-biquadfilternode-interface).
		 *          Tone.Filter has the added ability to set the filter rolloff at -12
		 *          (default), -24 and -48.
		 *
		 *  @constructor
		 *  @extends {Tone.AudioNode}
		 *  @param {Frequency|Object} [frequency] The cutoff frequency of the filter.
		 *  @param {string=} type The type of filter.
		 *  @param {number=} rolloff The drop in decibels per octave after the cutoff frequency.
		 *                            3 choices: -12, -24, and -48
		 *  @example
		 *  var filter = new Tone.Filter(200, "highpass");
		 */
	    Tone.Filter = function () {
	        var options = Tone.defaults(arguments, [
	            'frequency',
	            'type',
	            'rolloff'
	        ], Tone.Filter);
	        Tone.AudioNode.call(this);
	        this.createInsOuts(1, 1);
	        /**
			 *  the filter(s)
			 *  @type {Array}
			 *  @private
			 */
	        this._filters = [];
	        /**
			 *  The cutoff frequency of the filter.
			 *  @type {Frequency}
			 *  @signal
			 */
	        this.frequency = new Tone.Signal(options.frequency, Tone.Type.Frequency);
	        /**
			 *  The detune parameter
			 *  @type {Cents}
			 *  @signal
			 */
	        this.detune = new Tone.Signal(0, Tone.Type.Cents);
	        /**
			 *  The gain of the filter, only used in certain filter types
			 *  @type {Number}
			 *  @signal
			 */
	        this.gain = new Tone.Signal({
	            'value': options.gain,
	            'convert': false
	        });
	        /**
			 *  The Q or Quality of the filter
			 *  @type {Positive}
			 *  @signal
			 */
	        this.Q = new Tone.Signal(options.Q);
	        /**
			 *  the type of the filter
			 *  @type {string}
			 *  @private
			 */
	        this._type = options.type;
	        /**
			 *  the rolloff value of the filter
			 *  @type {number}
			 *  @private
			 */
	        this._rolloff = options.rolloff;
	        //set the rolloff;
	        this.rolloff = options.rolloff;
	        this._readOnly([
	            'detune',
	            'frequency',
	            'gain',
	            'Q'
	        ]);
	    };
	    Tone.extend(Tone.Filter, Tone.AudioNode);
	    /**
		 *  the default parameters
		 *
		 *  @static
		 *  @type {Object}
		 */
	    Tone.Filter.defaults = {
	        'type': 'lowpass',
	        'frequency': 350,
	        'rolloff': -12,
	        'Q': 1,
	        'gain': 0
	    };
	    /**
		 * The type of the filter. Types: "lowpass", "highpass",
		 * "bandpass", "lowshelf", "highshelf", "notch", "allpass", or "peaking".
		 * @memberOf Tone.Filter#
		 * @type {string}
		 * @name type
		 */
	    Object.defineProperty(Tone.Filter.prototype, 'type', {
	        get: function () {
	            return this._type;
	        },
	        set: function (type) {
	            var types = [
	                'lowpass',
	                'highpass',
	                'bandpass',
	                'lowshelf',
	                'highshelf',
	                'notch',
	                'allpass',
	                'peaking'
	            ];
	            if (types.indexOf(type) === -1) {
	                throw new TypeError('Tone.Filter: invalid type ' + type);
	            }
	            this._type = type;
	            for (var i = 0; i < this._filters.length; i++) {
	                this._filters[i].type = type;
	            }
	        }
	    });
	    /**
		 * The rolloff of the filter which is the drop in db
		 * per octave. Implemented internally by cascading filters.
		 * Only accepts the values -12, -24, -48 and -96.
		 * @memberOf Tone.Filter#
		 * @type {number}
		 * @name rolloff
		 */
	    Object.defineProperty(Tone.Filter.prototype, 'rolloff', {
	        get: function () {
	            return this._rolloff;
	        },
	        set: function (rolloff) {
	            rolloff = parseInt(rolloff, 10);
	            var possibilities = [
	                -12,
	                -24,
	                -48,
	                -96
	            ];
	            var cascadingCount = possibilities.indexOf(rolloff);
	            //check the rolloff is valid
	            if (cascadingCount === -1) {
	                throw new RangeError('Tone.Filter: rolloff can only be -12, -24, -48 or -96');
	            }
	            cascadingCount += 1;
	            this._rolloff = rolloff;
	            //first disconnect the filters and throw them away
	            this.input.disconnect();
	            for (var i = 0; i < this._filters.length; i++) {
	                this._filters[i].disconnect();
	                this._filters[i] = null;
	            }
	            this._filters = new Array(cascadingCount);
	            for (var count = 0; count < cascadingCount; count++) {
	                var filter = this.context.createBiquadFilter();
	                filter.type = this._type;
	                this.frequency.connect(filter.frequency);
	                this.detune.connect(filter.detune);
	                this.Q.connect(filter.Q);
	                this.gain.connect(filter.gain);
	                this._filters[count] = filter;
	            }
	            //connect them up
	            var connectionChain = [this.input].concat(this._filters).concat([this.output]);
	            Tone.connectSeries.apply(Tone, connectionChain);
	        }
	    });
	    /**
		 *  Clean up.
		 *  @return {Tone.Filter} this
		 */
	    Tone.Filter.prototype.dispose = function () {
	        Tone.AudioNode.prototype.dispose.call(this);
	        for (var i = 0; i < this._filters.length; i++) {
	            this._filters[i].disconnect();
	            this._filters[i] = null;
	        }
	        this._filters = null;
	        this._writable([
	            'detune',
	            'frequency',
	            'gain',
	            'Q'
	        ]);
	        this.frequency.dispose();
	        this.Q.dispose();
	        this.frequency = null;
	        this.Q = null;
	        this.detune.dispose();
	        this.detune = null;
	        this.gain.dispose();
	        this.gain = null;
	        return this;
	    };
	    return Tone.Filter;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Split the incoming signal into three bands (low, mid, high)
		 *         with two crossover frequency controls.
		 *
		 *  @extends {Tone.AudioNode}
		 *  @constructor
		 *  @param {Frequency|Object} [lowFrequency] the low/mid crossover frequency
		 *  @param {Frequency} [highFrequency] the mid/high crossover frequency
		 */
	    Tone.MultibandSplit = function () {
	        var options = Tone.defaults(arguments, [
	            'lowFrequency',
	            'highFrequency'
	        ], Tone.MultibandSplit);
	        Tone.AudioNode.call(this);
	        /**
			 *  the input
			 *  @type {Tone.Gain}
			 *  @private
			 */
	        this.input = new Tone.Gain();
	        /**
			 *  the outputs
			 *  @type {Array}
			 *  @private
			 */
	        this.output = new Array(3);
	        /**
			 *  The low band. Alias for <code>output[0]</code>
			 *  @type {Tone.Filter}
			 */
	        this.low = this.output[0] = new Tone.Filter(0, 'lowpass');
	        /**
			 *  the lower filter of the mid band
			 *  @type {Tone.Filter}
			 *  @private
			 */
	        this._lowMidFilter = new Tone.Filter(0, 'highpass');
	        /**
			 *  The mid band output. Alias for <code>output[1]</code>
			 *  @type {Tone.Filter}
			 */
	        this.mid = this.output[1] = new Tone.Filter(0, 'lowpass');
	        /**
			 *  The high band output. Alias for <code>output[2]</code>
			 *  @type {Tone.Filter}
			 */
	        this.high = this.output[2] = new Tone.Filter(0, 'highpass');
	        /**
			 *  The low/mid crossover frequency.
			 *  @type {Frequency}
			 *  @signal
			 */
	        this.lowFrequency = new Tone.Signal(options.lowFrequency, Tone.Type.Frequency);
	        /**
			 *  The mid/high crossover frequency.
			 *  @type {Frequency}
			 *  @signal
			 */
	        this.highFrequency = new Tone.Signal(options.highFrequency, Tone.Type.Frequency);
	        /**
			 *  The quality of all the filters
			 *  @type {Number}
			 *  @signal
			 */
	        this.Q = new Tone.Signal(options.Q);
	        this.input.fan(this.low, this.high);
	        this.input.chain(this._lowMidFilter, this.mid);
	        //the frequency control signal
	        this.lowFrequency.connect(this.low.frequency);
	        this.lowFrequency.connect(this._lowMidFilter.frequency);
	        this.highFrequency.connect(this.mid.frequency);
	        this.highFrequency.connect(this.high.frequency);
	        //the Q value
	        this.Q.connect(this.low.Q);
	        this.Q.connect(this._lowMidFilter.Q);
	        this.Q.connect(this.mid.Q);
	        this.Q.connect(this.high.Q);
	        this._readOnly([
	            'high',
	            'mid',
	            'low',
	            'highFrequency',
	            'lowFrequency'
	        ]);
	    };
	    Tone.extend(Tone.MultibandSplit, Tone.AudioNode);
	    /**
		 *  @private
		 *  @static
		 *  @type {Object}
		 */
	    Tone.MultibandSplit.defaults = {
	        'lowFrequency': 400,
	        'highFrequency': 2500,
	        'Q': 1
	    };
	    /**
		 *  Clean up.
		 *  @returns {Tone.MultibandSplit} this
		 */
	    Tone.MultibandSplit.prototype.dispose = function () {
	        Tone.AudioNode.prototype.dispose.call(this);
	        this._writable([
	            'high',
	            'mid',
	            'low',
	            'highFrequency',
	            'lowFrequency'
	        ]);
	        this.low.dispose();
	        this.low = null;
	        this._lowMidFilter.dispose();
	        this._lowMidFilter = null;
	        this.mid.dispose();
	        this.mid = null;
	        this.high.dispose();
	        this.high = null;
	        this.lowFrequency.dispose();
	        this.lowFrequency = null;
	        this.highFrequency.dispose();
	        this.highFrequency = null;
	        this.Q.dispose();
	        this.Q = null;
	        return this;
	    };
	    return Tone.MultibandSplit;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Tone.EQ3 is a three band EQ with control over low, mid, and high gain as
		 *         well as the low and high crossover frequencies.
		 *
		 *  @constructor
		 *  @extends {Tone.AudioNode}
		 *
		 *  @param {Decibels|Object} [lowLevel] The gain applied to the lows.
		 *  @param {Decibels} [midLevel] The gain applied to the mid.
		 *  @param {Decibels} [highLevel] The gain applied to the high.
		 *  @example
		 * var eq = new Tone.EQ3(-10, 3, -20);
		 */
	    Tone.EQ3 = function () {
	        var options = Tone.defaults(arguments, [
	            'low',
	            'mid',
	            'high'
	        ], Tone.EQ3);
	        Tone.AudioNode.call(this);
	        /**
			 *  the output node
			 *  @type {GainNode}
			 *  @private
			 */
	        this.output = new Tone.Gain();
	        /**
			 *  the multiband split
			 *  @type {Tone.MultibandSplit}
			 *  @private
			 */
	        this._multibandSplit = this.input = new Tone.MultibandSplit({
	            'lowFrequency': options.lowFrequency,
	            'highFrequency': options.highFrequency
	        });
	        /**
			 *  The gain for the lower signals
			 *  @type  {Tone.Gain}
			 *  @private
			 */
	        this._lowGain = new Tone.Gain(options.low, Tone.Type.Decibels);
	        /**
			 *  The gain for the mid signals
			 *  @type  {Tone.Gain}
			 *  @private
			 */
	        this._midGain = new Tone.Gain(options.mid, Tone.Type.Decibels);
	        /**
			 * The gain in decibels of the high part
			 * @type {Tone.Gain}
			 * @private
			 */
	        this._highGain = new Tone.Gain(options.high, Tone.Type.Decibels);
	        /**
			 * The gain in decibels of the low part
			 * @type {Decibels}
			 * @signal
			 */
	        this.low = this._lowGain.gain;
	        /**
			 * The gain in decibels of the mid part
			 * @type {Decibels}
			 * @signal
			 */
	        this.mid = this._midGain.gain;
	        /**
			 * The gain in decibels of the high part
			 * @type {Decibels}
			 * @signal
			 */
	        this.high = this._highGain.gain;
	        /**
			 *  The Q value for all of the filters.
			 *  @type {Positive}
			 *  @signal
			 */
	        this.Q = this._multibandSplit.Q;
	        /**
			 *  The low/mid crossover frequency.
			 *  @type {Frequency}
			 *  @signal
			 */
	        this.lowFrequency = this._multibandSplit.lowFrequency;
	        /**
			 *  The mid/high crossover frequency.
			 *  @type {Frequency}
			 *  @signal
			 */
	        this.highFrequency = this._multibandSplit.highFrequency;
	        //the frequency bands
	        this._multibandSplit.low.chain(this._lowGain, this.output);
	        this._multibandSplit.mid.chain(this._midGain, this.output);
	        this._multibandSplit.high.chain(this._highGain, this.output);
	        this._readOnly([
	            'low',
	            'mid',
	            'high',
	            'lowFrequency',
	            'highFrequency'
	        ]);
	    };
	    Tone.extend(Tone.EQ3, Tone.AudioNode);
	    /**
		 *  the default values
		 */
	    Tone.EQ3.defaults = {
	        'low': 0,
	        'mid': 0,
	        'high': 0,
	        'lowFrequency': 400,
	        'highFrequency': 2500
	    };
	    /**
		 *  clean up
		 *  @returns {Tone.EQ3} this
		 */
	    Tone.EQ3.prototype.dispose = function () {
	        Tone.AudioNode.prototype.dispose.call(this);
	        this._writable([
	            'low',
	            'mid',
	            'high',
	            'lowFrequency',
	            'highFrequency'
	        ]);
	        this._multibandSplit.dispose();
	        this._multibandSplit = null;
	        this.lowFrequency = null;
	        this.highFrequency = null;
	        this._lowGain.dispose();
	        this._lowGain = null;
	        this._midGain.dispose();
	        this._midGain = null;
	        this._highGain.dispose();
	        this._highGain = null;
	        this.low = null;
	        this.mid = null;
	        this.high = null;
	        this.Q = null;
	        return this;
	    };
	    return Tone.EQ3;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class  Performs a linear scaling on an input signal.
		 *          Scales a NormalRange input to between
		 *          outputMin and outputMax.
		 *
		 *  @constructor
		 *  @extends {Tone.SignalBase}
		 *  @param {number} [outputMin=0] The output value when the input is 0. 
		 *  @param {number} [outputMax=1]	The output value when the input is 1. 
		 *  @example
		 * var scale = new Tone.Scale(50, 100);
		 * var signal = new Tone.Signal(0.5).connect(scale);
		 * //the output of scale equals 75
		 */
	    Tone.Scale = function (outputMin, outputMax) {
	        Tone.SignalBase.call(this);
	        /** 
			 *  @private
			 *  @type {number}
			 */
	        this._outputMin = Tone.defaultArg(outputMin, 0);
	        /** 
			 *  @private
			 *  @type {number}
			 */
	        this._outputMax = Tone.defaultArg(outputMax, 1);
	        /** 
			 *  @private
			 *  @type {Tone.Multiply}
			 *  @private
			 */
	        this._scale = this.input = new Tone.Multiply(1);
	        /** 
			 *  @private
			 *  @type {Tone.Add}
			 *  @private
			 */
	        this._add = this.output = new Tone.Add(0);
	        this._scale.connect(this._add);
	        this._setRange();
	    };
	    Tone.extend(Tone.Scale, Tone.SignalBase);
	    /**
		 * The minimum output value. This number is output when 
		 * the value input value is 0. 
		 * @memberOf Tone.Scale#
		 * @type {number}
		 * @name min
		 */
	    Object.defineProperty(Tone.Scale.prototype, 'min', {
	        get: function () {
	            return this._outputMin;
	        },
	        set: function (min) {
	            this._outputMin = min;
	            this._setRange();
	        }
	    });
	    /**
		 * The maximum output value. This number is output when 
		 * the value input value is 1. 
		 * @memberOf Tone.Scale#
		 * @type {number}
		 * @name max
		 */
	    Object.defineProperty(Tone.Scale.prototype, 'max', {
	        get: function () {
	            return this._outputMax;
	        },
	        set: function (max) {
	            this._outputMax = max;
	            this._setRange();
	        }
	    });
	    /**
		 *  set the values
		 *  @private
		 */
	    Tone.Scale.prototype._setRange = function () {
	        this._add.value = this._outputMin;
	        this._scale.value = this._outputMax - this._outputMin;
	    };
	    /**
		 *  Clean up.
		 *  @returns {Tone.Scale} this
		 */
	    Tone.Scale.prototype.dispose = function () {
	        Tone.SignalBase.prototype.dispose.call(this);
	        this._add.dispose();
	        this._add = null;
	        this._scale.dispose();
	        this._scale = null;
	        return this;
	    };
	    return Tone.Scale;
	});
	Module(function (Tone) {
	    /**
		 *  @class  Performs an exponential scaling on an input signal.
		 *          Scales a NormalRange value [0,1] exponentially
		 *          to the output range of outputMin to outputMax.
		 *
		 *  @constructor
		 *  @extends {Tone.SignalBase}
		 *  @param {number} [outputMin=0] The output value when the input is 0. 
		 *  @param {number} [outputMax=1]	The output value when the input is 1. 
		 *  @param {number} [exponent=2] The exponent which scales the incoming signal.
		 *  @example
		 * var scaleExp = new Tone.ScaleExp(0, 100, 2);
		 * var signal = new Tone.Signal(0.5).connect(scaleExp);
		 */
	    Tone.ScaleExp = function (outputMin, outputMax, exponent) {
	        Tone.SignalBase.call(this);
	        /**
			 *  scale the input to the output range
			 *  @type {Tone.Scale}
			 *  @private
			 */
	        this._scale = this.output = new Tone.Scale(outputMin, outputMax);
	        /**
			 *  @private
			 *  @type {Tone.Pow}
			 *  @private
			 */
	        this._exp = this.input = new Tone.Pow(Tone.defaultArg(exponent, 2));
	        this._exp.connect(this._scale);
	    };
	    Tone.extend(Tone.ScaleExp, Tone.SignalBase);
	    /**
		 * Instead of interpolating linearly between the <code>min</code> and 
		 * <code>max</code> values, setting the exponent will interpolate between
		 * the two values with an exponential curve. 
		 * @memberOf Tone.ScaleExp#
		 * @type {number}
		 * @name exponent
		 */
	    Object.defineProperty(Tone.ScaleExp.prototype, 'exponent', {
	        get: function () {
	            return this._exp.value;
	        },
	        set: function (exp) {
	            this._exp.value = exp;
	        }
	    });
	    /**
		 * The minimum output value. This number is output when 
		 * the value input value is 0. 
		 * @memberOf Tone.ScaleExp#
		 * @type {number}
		 * @name min
		 */
	    Object.defineProperty(Tone.ScaleExp.prototype, 'min', {
	        get: function () {
	            return this._scale.min;
	        },
	        set: function (min) {
	            this._scale.min = min;
	        }
	    });
	    /**
		 * The maximum output value. This number is output when 
		 * the value input value is 1. 
		 * @memberOf Tone.ScaleExp#
		 * @type {number}
		 * @name max
		 */
	    Object.defineProperty(Tone.ScaleExp.prototype, 'max', {
	        get: function () {
	            return this._scale.max;
	        },
	        set: function (max) {
	            this._scale.max = max;
	        }
	    });
	    /**
		 *  Clean up.
		 *  @returns {Tone.ScaleExp} this
		 */
	    Tone.ScaleExp.prototype.dispose = function () {
	        Tone.SignalBase.prototype.dispose.call(this);
	        this._scale.dispose();
	        this._scale = null;
	        this._exp.dispose();
	        this._exp = null;
	        return this;
	    };
	    return Tone.ScaleExp;
	});
	Module(function (Tone) {
	    
	    /**
		 *  createDelay shim
		 *  @private
		 */
	    if (window.DelayNode && !AudioContext.prototype.createDelay) {
	        AudioContext.prototype.createDelay = AudioContext.prototype.createDelayNode;
	    }
	    /**
		 *  @class Wrapper around Web Audio's native [DelayNode](http://webaudio.github.io/web-audio-api/#the-delaynode-interface).
		 *  @extends {Tone}
		 *  @param {Time=} delayTime The delay applied to the incoming signal.
		 *  @param {Time=} maxDelay The maximum delay time.
		 */
	    Tone.Delay = function () {
	        var options = Tone.defaults(arguments, [
	            'delayTime',
	            'maxDelay'
	        ], Tone.Delay);
	        Tone.AudioNode.call(this);
	        /**
			 *  The native delay node
			 *  @type {DelayNode}
			 *  @private
			 */
	        this._delayNode = this.input = this.output = this.context.createDelay(this.toSeconds(options.maxDelay));
	        /**
			 *  The amount of time the incoming signal is
			 *  delayed.
			 *  @type {Time}
			 *  @signal
			 */
	        this.delayTime = new Tone.Param({
	            'param': this._delayNode.delayTime,
	            'units': Tone.Type.Time,
	            'value': options.delayTime
	        });
	        this._readOnly('delayTime');
	    };
	    Tone.extend(Tone.Delay, Tone.AudioNode);
	    /**
		 *  The defaults
		 *  @const
		 *  @type  {Object}
		 */
	    Tone.Delay.defaults = {
	        'maxDelay': 1,
	        'delayTime': 0
	    };
	    /**
		 *  Clean up.
		 *  @return  {Tone.Delay}  this
		 */
	    Tone.Delay.prototype.dispose = function () {
	        Tone.AudioNode.prototype.dispose.call(this);
	        this._delayNode.disconnect();
	        this._delayNode = null;
	        this._writable('delayTime');
	        this.delayTime = null;
	        return this;
	    };
	    return Tone.Delay;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Comb filters are basic building blocks for physical modeling. Read more
		 *         about comb filters on [CCRMA's website](https://ccrma.stanford.edu/~jos/pasp/Feedback_Comb_Filters.html).
		 *
		 *  @extends {Tone.AudioNode}
		 *  @constructor
		 *  @param {Time|Object} [delayTime] The delay time of the filter.
		 *  @param {NormalRange=} resonance The amount of feedback the filter has.
		 */
	    Tone.FeedbackCombFilter = function () {
	        var options = Tone.defaults(arguments, [
	            'delayTime',
	            'resonance'
	        ], Tone.FeedbackCombFilter);
	        Tone.AudioNode.call(this);
	        /**
			 *  the delay node
			 *  @type {DelayNode}
			 *  @private
			 */
	        this._delay = this.input = this.output = new Tone.Delay(options.delayTime);
	        /**
			 *  The amount of delay of the comb filter.
			 *  @type {Time}
			 *  @signal
			 */
	        this.delayTime = this._delay.delayTime;
	        /**
			 *  the feedback node
			 *  @type {GainNode}
			 *  @private
			 */
	        this._feedback = new Tone.Gain(options.resonance, Tone.Type.NormalRange);
	        /**
			 *  The amount of feedback of the delayed signal.
			 *  @type {NormalRange}
			 *  @signal
			 */
	        this.resonance = this._feedback.gain;
	        this._delay.chain(this._feedback, this._delay);
	        this._readOnly([
	            'resonance',
	            'delayTime'
	        ]);
	    };
	    Tone.extend(Tone.FeedbackCombFilter, Tone.AudioNode);
	    /**
		 *  the default parameters
		 *  @static
		 *  @const
		 *  @type {Object}
		 */
	    Tone.FeedbackCombFilter.defaults = {
	        'delayTime': 0.1,
	        'resonance': 0.5
	    };
	    /**
		 *  clean up
		 *  @returns {Tone.FeedbackCombFilter} this
		 */
	    Tone.FeedbackCombFilter.prototype.dispose = function () {
	        Tone.AudioNode.prototype.dispose.call(this);
	        this._writable([
	            'resonance',
	            'delayTime'
	        ]);
	        this._delay.dispose();
	        this._delay = null;
	        this.delayTime = null;
	        this._feedback.dispose();
	        this._feedback = null;
	        this.resonance = null;
	        return this;
	    };
	    return Tone.FeedbackCombFilter;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class  Tone.Follower is a  crude envelope follower which will follow
		 *          the amplitude of an incoming signal.
		 *          Take care with small (< 0.02) attack or decay values
		 *          as follower has some ripple which is exaggerated
		 *          at these values. Read more about envelope followers (also known
		 *          as envelope detectors) on [Wikipedia](https://en.wikipedia.org/wiki/Envelope_detector).
		 *
		 *  @constructor
		 *  @extends {Tone.AudioNode}
		 *  @param {Time|Object} [attack] The rate at which the follower rises.
		 *  @param {Time=} release The rate at which the folower falls.
		 *  @example
		 * var follower = new Tone.Follower(0.2, 0.4);
		 */
	    Tone.Follower = function () {
	        var options = Tone.defaults(arguments, [
	            'attack',
	            'release'
	        ], Tone.Follower);
	        Tone.AudioNode.call(this);
	        this.createInsOuts(1, 1);
	        /**
			 *  @type {Tone.Abs}
			 *  @private
			 */
	        this._abs = new Tone.Abs();
	        /**
			 *  the lowpass filter which smooths the input
			 *  @type {BiquadFilterNode}
			 *  @private
			 */
	        this._filter = this.context.createBiquadFilter();
	        this._filter.type = 'lowpass';
	        this._filter.frequency.value = 0;
	        this._filter.Q.value = -100;
	        /**
			 *  @type {WaveShaperNode}
			 *  @private
			 */
	        this._frequencyValues = new Tone.WaveShaper();
	        /**
			 *  @type {Tone.Subtract}
			 *  @private
			 */
	        this._sub = new Tone.Subtract();
	        /**
			 *  @type {Tone.Delay}
			 *  @private
			 */
	        this._delay = new Tone.Delay(this.blockTime);
	        /**
			 *  this keeps it far from 0, even for very small differences
			 *  @type {Tone.Multiply}
			 *  @private
			 */
	        this._mult = new Tone.Multiply(10000);
	        /**
			 *  @private
			 *  @type {number}
			 */
	        this._attack = options.attack;
	        /**
			 *  @private
			 *  @type {number}
			 */
	        this._release = options.release;
	        //the smoothed signal to get the values
	        this.input.chain(this._abs, this._filter, this.output);
	        //the difference path
	        this._abs.connect(this._sub, 0, 1);
	        this._filter.chain(this._delay, this._sub);
	        //threshold the difference and use the thresh to set the frequency
	        this._sub.chain(this._mult, this._frequencyValues, this._filter.frequency);
	        //set the attack and release values in the table
	        this._setAttackRelease(this._attack, this._release);
	    };
	    Tone.extend(Tone.Follower, Tone.AudioNode);
	    /**
		 *  @static
		 *  @type {Object}
		 */
	    Tone.Follower.defaults = {
	        'attack': 0.05,
	        'release': 0.5
	    };
	    /**
		 *  sets the attack and release times in the wave shaper
		 *  @param   {Time} attack
		 *  @param   {Time} release
		 *  @private
		 */
	    Tone.Follower.prototype._setAttackRelease = function (attack, release) {
	        var minTime = this.blockTime;
	        attack = Tone.Time(attack).toFrequency();
	        release = Tone.Time(release).toFrequency();
	        attack = Math.max(attack, minTime);
	        release = Math.max(release, minTime);
	        this._frequencyValues.setMap(function (val) {
	            if (val <= 0) {
	                return attack;
	            } else {
	                return release;
	            }
	        });
	    };
	    /**
		 * The attack time.
		 * @memberOf Tone.Follower#
		 * @type {Time}
		 * @name attack
		 */
	    Object.defineProperty(Tone.Follower.prototype, 'attack', {
	        get: function () {
	            return this._attack;
	        },
	        set: function (attack) {
	            this._attack = attack;
	            this._setAttackRelease(this._attack, this._release);
	        }
	    });
	    /**
		 * The release time.
		 * @memberOf Tone.Follower#
		 * @type {Time}
		 * @name release
		 */
	    Object.defineProperty(Tone.Follower.prototype, 'release', {
	        get: function () {
	            return this._release;
	        },
	        set: function (release) {
	            this._release = release;
	            this._setAttackRelease(this._attack, this._release);
	        }
	    });
	    /**
		 *  Borrows the connect method from Signal so that the output can be used
		 *  as a Tone.Signal control signal.
		 *  @function
		 */
	    Tone.Follower.prototype.connect = Tone.Signal.prototype.connect;
	    /**
		 *  dispose
		 *  @returns {Tone.Follower} this
		 */
	    Tone.Follower.prototype.dispose = function () {
	        Tone.AudioNode.prototype.dispose.call(this);
	        this._filter.disconnect();
	        this._filter = null;
	        this._frequencyValues.disconnect();
	        this._frequencyValues = null;
	        this._delay.dispose();
	        this._delay = null;
	        this._sub.disconnect();
	        this._sub = null;
	        this._abs.dispose();
	        this._abs = null;
	        this._mult.dispose();
	        this._mult = null;
	        this._curve = null;
	        return this;
	    };
	    return Tone.Follower;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Tone.ScaledEnvelop is an envelope which can be scaled 
		 *         to any range. It's useful for applying an envelope 
		 *         to a frequency or any other non-NormalRange signal 
		 *         parameter. 
		 *
		 *  @extends {Tone.Envelope}
		 *  @constructor
		 *  @param {Time|Object} [attack]	the attack time in seconds
		 *  @param {Time} [decay]	the decay time in seconds
		 *  @param {number} [sustain] 	a percentage (0-1) of the full amplitude
		 *  @param {Time} [release]	the release time in seconds
		 *  @example
		 *  var scaledEnv = new Tone.ScaledEnvelope({
		 *  	"attack" : 0.2,
		 *  	"min" : 200,
		 *  	"max" : 2000
		 *  });
		 *  scaledEnv.connect(oscillator.frequency);
		 */
	    Tone.ScaledEnvelope = function () {
	        //get all of the defaults
	        var options = Tone.defaults(arguments, [
	            'attack',
	            'decay',
	            'sustain',
	            'release'
	        ], Tone.Envelope);
	        Tone.Envelope.call(this, options);
	        options = Tone.defaultArg(options, Tone.ScaledEnvelope.defaults);
	        /** 
			 *  scale the incoming signal by an exponent
			 *  @type {Tone.Pow}
			 *  @private
			 */
	        this._exp = this.output = new Tone.Pow(options.exponent);
	        /**
			 *  scale the signal to the desired range
			 *  @type {Tone.Multiply}
			 *  @private
			 */
	        this._scale = this.output = new Tone.Scale(options.min, options.max);
	        this._sig.chain(this._exp, this._scale);
	    };
	    Tone.extend(Tone.ScaledEnvelope, Tone.Envelope);
	    /**
		 *  the default parameters
		 *  @static
		 */
	    Tone.ScaledEnvelope.defaults = {
	        'min': 0,
	        'max': 1,
	        'exponent': 1
	    };
	    /**
		 * The envelope's min output value. This is the value which it
		 * starts at. 
		 * @memberOf Tone.ScaledEnvelope#
		 * @type {number}
		 * @name min
		 */
	    Object.defineProperty(Tone.ScaledEnvelope.prototype, 'min', {
	        get: function () {
	            return this._scale.min;
	        },
	        set: function (min) {
	            this._scale.min = min;
	        }
	    });
	    /**
		 * The envelope's max output value. In other words, the value
		 * at the peak of the attack portion of the envelope. 
		 * @memberOf Tone.ScaledEnvelope#
		 * @type {number}
		 * @name max
		 */
	    Object.defineProperty(Tone.ScaledEnvelope.prototype, 'max', {
	        get: function () {
	            return this._scale.max;
	        },
	        set: function (max) {
	            this._scale.max = max;
	        }
	    });
	    /**
		 * The envelope's exponent value. 
		 * @memberOf Tone.ScaledEnvelope#
		 * @type {number}
		 * @name exponent
		 */
	    Object.defineProperty(Tone.ScaledEnvelope.prototype, 'exponent', {
	        get: function () {
	            return this._exp.value;
	        },
	        set: function (exp) {
	            this._exp.value = exp;
	        }
	    });
	    /**
		 *  clean up
		 *  @returns {Tone.ScaledEnvelope} this
		 */
	    Tone.ScaledEnvelope.prototype.dispose = function () {
	        Tone.Envelope.prototype.dispose.call(this);
	        this._scale.dispose();
	        this._scale = null;
	        this._exp.dispose();
	        this._exp = null;
	        return this;
	    };
	    return Tone.ScaledEnvelope;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Tone.FrequencyEnvelope is a Tone.ScaledEnvelope, but instead of `min` and `max`
		 *         it's got a `baseFrequency` and `octaves` parameter. 
		 *
		 *  @extends {Tone.Envelope}
		 *  @constructor
		 *  @param {Time|Object} [attack]	the attack time in seconds
		 *  @param {Time} [decay]	the decay time in seconds
		 *  @param {number} [sustain] 	a percentage (0-1) of the full amplitude
		 *  @param {Time} [release]	the release time in seconds
		 *  @example
		 *  var env = new Tone.FrequencyEnvelope({
		 *  	"attack" : 0.2,
		 *  	"baseFrequency" : "C2",
		 *  	"octaves" : 4
		 *  });
		 *  scaledEnv.connect(oscillator.frequency);
		 */
	    Tone.FrequencyEnvelope = function () {
	        var options = Tone.defaults(arguments, [
	            'attack',
	            'decay',
	            'sustain',
	            'release'
	        ], Tone.Envelope);
	        Tone.ScaledEnvelope.call(this, options);
	        //merge it with the frequency envelope defaults
	        options = Tone.defaultArg(options, Tone.FrequencyEnvelope.defaults);
	        /**
			 *  Stores the octave value
			 *  @type {Positive}
			 *  @private
			 */
	        this._octaves = options.octaves;
	        //setup
	        this.baseFrequency = options.baseFrequency;
	        this.octaves = options.octaves;
	    };
	    Tone.extend(Tone.FrequencyEnvelope, Tone.Envelope);
	    /**
		 *  the default parameters
		 *  @static
		 */
	    Tone.FrequencyEnvelope.defaults = {
	        'baseFrequency': 200,
	        'octaves': 4,
	        'exponent': 2
	    };
	    /**
		 * The envelope's mininum output value. This is the value which it
		 * starts at. 
		 * @memberOf Tone.FrequencyEnvelope#
		 * @type {Frequency}
		 * @name baseFrequency
		 */
	    Object.defineProperty(Tone.FrequencyEnvelope.prototype, 'baseFrequency', {
	        get: function () {
	            return this._scale.min;
	        },
	        set: function (min) {
	            this._scale.min = this.toFrequency(min);
	            //also update the octaves
	            this.octaves = this._octaves;
	        }
	    });
	    /**
		 * The number of octaves above the baseFrequency that the
		 * envelope will scale to.
		 * @memberOf Tone.FrequencyEnvelope#
		 * @type {Positive}
		 * @name octaves
		 */
	    Object.defineProperty(Tone.FrequencyEnvelope.prototype, 'octaves', {
	        get: function () {
	            return this._octaves;
	        },
	        set: function (octaves) {
	            this._octaves = octaves;
	            this._scale.max = this.baseFrequency * Math.pow(2, octaves);
	        }
	    });
	    /**
		 * The envelope's exponent value. 
		 * @memberOf Tone.FrequencyEnvelope#
		 * @type {number}
		 * @name exponent
		 */
	    Object.defineProperty(Tone.FrequencyEnvelope.prototype, 'exponent', {
	        get: function () {
	            return this._exp.value;
	        },
	        set: function (exp) {
	            this._exp.value = exp;
	        }
	    });
	    /**
		 *  clean up
		 *  @returns {Tone.FrequencyEnvelope} this
		 */
	    Tone.FrequencyEnvelope.prototype.dispose = function () {
	        Tone.ScaledEnvelope.prototype.dispose.call(this);
	        return this;
	    };
	    return Tone.FrequencyEnvelope;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class  Tone.Gate only passes a signal through when the incoming
		 *          signal exceeds a specified threshold. To do this, Gate uses
		 *          a Tone.Follower to follow the amplitude of the incoming signal.
		 *          A common implementation of this class is a [Noise Gate](https://en.wikipedia.org/wiki/Noise_gate).
		 *
		 *  @constructor
		 *  @extends {Tone.AudioNode}
		 *  @param {Decibels|Object} [threshold] The threshold above which the gate will open.
		 *  @param {Time=} attack The follower's attack time
		 *  @param {Time=} release The follower's release time
		 *  @example
		 * var gate = new Tone.Gate(-30, 0.2, 0.3).toMaster();
		 * var mic = new Tone.UserMedia().connect(gate);
		 * //the gate will only pass through the incoming
		 * //signal when it's louder than -30db
		 */
	    Tone.Gate = function () {
	        var options = Tone.defaults(arguments, [
	            'threshold',
	            'attack',
	            'release'
	        ], Tone.Gate);
	        Tone.AudioNode.call(this);
	        this.createInsOuts(1, 1);
	        /**
			 *  @type {Tone.Follower}
			 *  @private
			 */
	        this._follower = new Tone.Follower(options.attack, options.release);
	        /**
			 *  @type {Tone.GreaterThan}
			 *  @private
			 */
	        this._gt = new Tone.GreaterThan(Tone.dbToGain(options.threshold));
	        //the connections
	        this.input.connect(this.output);
	        //the control signal
	        this.input.chain(this._gt, this._follower, this.output.gain);
	    };
	    Tone.extend(Tone.Gate, Tone.AudioNode);
	    /**
		 *  @const
		 *  @static
		 *  @type {Object}
		 */
	    Tone.Gate.defaults = {
	        'attack': 0.1,
	        'release': 0.1,
	        'threshold': -40
	    };
	    /**
		 * The threshold of the gate in decibels
		 * @memberOf Tone.Gate#
		 * @type {Decibels}
		 * @name threshold
		 */
	    Object.defineProperty(Tone.Gate.prototype, 'threshold', {
	        get: function () {
	            return Tone.gainToDb(this._gt.value);
	        },
	        set: function (thresh) {
	            this._gt.value = Tone.dbToGain(thresh);
	        }
	    });
	    /**
		 * The attack speed of the gate
		 * @memberOf Tone.Gate#
		 * @type {Time}
		 * @name attack
		 */
	    Object.defineProperty(Tone.Gate.prototype, 'attack', {
	        get: function () {
	            return this._follower.attack;
	        },
	        set: function (attackTime) {
	            this._follower.attack = attackTime;
	        }
	    });
	    /**
		 * The release speed of the gate
		 * @memberOf Tone.Gate#
		 * @type {Time}
		 * @name release
		 */
	    Object.defineProperty(Tone.Gate.prototype, 'release', {
	        get: function () {
	            return this._follower.release;
	        },
	        set: function (releaseTime) {
	            this._follower.release = releaseTime;
	        }
	    });
	    /**
		 *  Clean up.
		 *  @returns {Tone.Gate} this
		 */
	    Tone.Gate.prototype.dispose = function () {
	        Tone.AudioNode.prototype.dispose.call(this);
	        this._follower.dispose();
	        this._gt.dispose();
	        this._follower = null;
	        this._gt = null;
	        return this;
	    };
	    return Tone.Gate;
	});
	Module(function (Tone) {
	    /**
		 * @class Tone.TickSignal extends Tone.TimelineSignal, but adds the capability
		 *        to calculate the number of elapsed ticks. exponential and target curves
		 *        are approximated with multiple linear ramps.
		 *
		 *        Thank you Bruno Dias, H. Sofia Pinto, and David M. Matos, for your [WAC paper](https://smartech.gatech.edu/bitstream/handle/1853/54588/WAC2016-49.pdf)
		 *        describing integrating timing functions for tempo calculations.
		 *
		 * @param {Number} value The initial value of the signal
		 * @extends {Tone.TimelineSignal}
		 */
	    Tone.TickSignal = function (value) {
	        value = Tone.defaultArg(value, 1);
	        Tone.TimelineSignal.call(this, {
	            'units': Tone.Type.Ticks,
	            'value': value
	        });
	        //extend the memory
	        this._events.memory = Infinity;
	    };
	    Tone.extend(Tone.TickSignal, Tone.TimelineSignal);
	    /**
		 * Wraps Tone.TimelineSignal methods so that they also
		 * record the ticks.
		 * @param  {Function} method
		 * @return {Function}
		 * @private
		 */
	    function _wrapScheduleMethods(method) {
	        return function (value, time) {
	            time = this.toSeconds(time);
	            method.apply(this, arguments);
	            var event = this._events.get(time);
	            var previousEvent = this._events.previousEvent(event);
	            var ticksUntilTime = this._getTickUntilEvent(previousEvent, time - this.sampleTime);
	            event.ticks = Math.max(ticksUntilTime, 0);
	            return this;
	        };
	    }
	    Tone.TickSignal.prototype.setValueAtTime = _wrapScheduleMethods(Tone.TimelineSignal.prototype.setValueAtTime);
	    Tone.TickSignal.prototype.linearRampToValueAtTime = _wrapScheduleMethods(Tone.TimelineSignal.prototype.linearRampToValueAtTime);
	    /**
		 *  Start exponentially approaching the target value at the given time with
		 *  a rate having the given time constant.
		 *  @param {number} value
		 *  @param {Time} startTime
		 *  @param {number} timeConstant
		 *  @returns {Tone.TickSignal} this
		 */
	    Tone.TickSignal.prototype.setTargetAtTime = function (value, time, constant) {
	        //aproximate it with multiple linear ramps
	        time = this.toSeconds(time);
	        this.setRampPoint(time);
	        value = this._fromUnits(value);
	        //start from previously scheduled value
	        var prevEvent = this._events.get(time);
	        var segments = 5;
	        for (var i = 0; i <= segments; i++) {
	            var segTime = constant * i + time;
	            var rampVal = this._exponentialApproach(prevEvent.time, prevEvent.value, value, constant, segTime);
	            this.linearRampToValueAtTime(this._toUnits(rampVal), segTime);
	        }
	        return this;
	    };
	    /**
		 *  Schedules an exponential continuous change in parameter value from
		 *  the previous scheduled parameter value to the given value.
		 *  @param  {number} value
		 *  @param  {Time} endTime
		 *  @returns {Tone.TickSignal} this
		 */
	    Tone.TickSignal.prototype.exponentialRampToValueAtTime = function (value, time) {
	        //aproximate it with multiple linear ramps
	        time = this.toSeconds(time);
	        value = this._fromUnits(value);
	        //start from previously scheduled value
	        var prevEvent = this._events.get(time);
	        if (prevEvent === null) {
	            prevEvent = {
	                'value': this._initial,
	                'time': 0
	            };
	        }
	        var segments = 5;
	        var segmentDur = (time - prevEvent.time) / segments;
	        for (var i = 0; i <= segments; i++) {
	            var segTime = segmentDur * i + prevEvent.time;
	            var rampVal = this._exponentialInterpolate(prevEvent.time, prevEvent.value, time, value, segTime);
	            this.linearRampToValueAtTime(this._toUnits(rampVal), segTime);
	        }
	        return this;
	    };
	    /**
		 * Returns the tick value at the time. Takes into account
		 * any automation curves scheduled on the signal.
		 * @private
		 * @param  {Time} time The time to get the tick count at
		 * @return {Ticks}      The number of ticks which have elapsed at the time
		 *                          given any automations.
		 */
	    Tone.TickSignal.prototype._getTickUntilEvent = function (event, time) {
	        if (event === null) {
	            event = {
	                'ticks': 0,
	                'time': 0
	            };
	        }
	        var val0 = this.getValueAtTime(event.time);
	        var val1 = this.getValueAtTime(time);
	        return 0.5 * (time - event.time) * (val0 + val1) + event.ticks;
	    };
	    /**
		 * Returns the tick value at the time. Takes into account
		 * any automation curves scheduled on the signal.
		 * @param  {Time} time The time to get the tick count at
		 * @return {Ticks}      The number of ticks which have elapsed at the time
		 *                          given any automations.
		 */
	    Tone.TickSignal.prototype.getTickAtTime = function (time) {
	        time = this.toSeconds(time);
	        var event = this._events.get(time);
	        return this._getTickUntilEvent(event, time);
	    };
	    /**
		 * Return the elapsed time of the number of ticks from the given time
		 * @param {Ticks} ticks The number of ticks to calculate
		 * @param  {Time} time The time to get the next tick from
		 * @return {Seconds} The duration of the number of ticks from the given time in seconds
		 */
	    Tone.TickSignal.prototype.getDurationOfTicks = function (ticks, time) {
	        time = this.toSeconds(time);
	        var currentTick = this.getTickAtTime(time);
	        return this.getTimeOfTick(currentTick + ticks) - time;
	    };
	    /**
		 * Given a tick, returns the time that tick occurs at.
		 * @param  {Ticks} tick
		 * @return {Time}      The time that the tick occurs.
		 */
	    Tone.TickSignal.prototype.getTimeOfTick = function (tick) {
	        var before = this._events.get(tick, 'ticks');
	        var after = this._events.getAfter(tick, 'ticks');
	        if (before && before.ticks === tick) {
	            return before.time;
	        } else if (before && after && after.type === Tone.TimelineSignal.Type.Linear && before.value !== after.value) {
	            var val0 = this.getValueAtTime(before.time);
	            var val1 = this.getValueAtTime(after.time);
	            var delta = (val1 - val0) / (after.time - before.time);
	            var k = Math.sqrt(Math.pow(val0, 2) - 2 * delta * (before.ticks - tick));
	            var sol1 = (-val0 + k) / delta;
	            var sol2 = (-val0 - k) / delta;
	            return (sol1 > 0 ? sol1 : sol2) + before.time;
	        } else if (before) {
	            if (before.value === 0) {
	                return Infinity;
	            } else {
	                return before.time + (tick - before.ticks) / before.value;
	            }
	        } else {
	            return tick / this._initial;
	        }
	    };
	    return Tone.TickSignal;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class  A Timeline State. Provides the methods: <code>setStateAtTime("state", time)</code>
		 *          and <code>getValueAtTime(time)</code>.
		 *
		 *  @extends {Tone.Timeline}
		 *  @param {String} initial The initial state of the TimelineState. 
		 *                          Defaults to <code>undefined</code>
		 */
	    Tone.TimelineState = function (initial) {
	        Tone.Timeline.call(this);
	        /**
			 *  The initial state
			 *  @private
			 *  @type {String}
			 */
	        this._initial = initial;
	    };
	    Tone.extend(Tone.TimelineState, Tone.Timeline);
	    /**
		 *  Returns the scheduled state scheduled before or at
		 *  the given time.
		 *  @param  {Number}  time  The time to query.
		 *  @return  {String}  The name of the state input in setStateAtTime.
		 */
	    Tone.TimelineState.prototype.getValueAtTime = function (time) {
	        var event = this.get(time);
	        if (event !== null) {
	            return event.state;
	        } else {
	            return this._initial;
	        }
	    };
	    /**
		 *  Add a state to the timeline.
		 *  @param  {String}  state The name of the state to set.
		 *  @param  {Number}  time  The time to query.
		 *  @returns {Tone.TimelineState} this
		 */
	    Tone.TimelineState.prototype.setStateAtTime = function (state, time) {
	        this.add({
	            'state': state,
	            'time': time
	        });
	        return this;
	    };
	    return Tone.TimelineState;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class  A sample accurate clock which provides a callback at the given rate. 
		 *          While the callback is not sample-accurate (it is still susceptible to
		 *          loose JS timing), the time passed in as the argument to the callback
		 *          is precise. For most applications, it is better to use Tone.Transport
		 *          instead of the Clock by itself since you can synchronize multiple callbacks.
		 *
		 * 	@constructor
		 *  @extends {Tone.Emitter}
		 * 	@param {function} callback The callback to be invoked with the time of the audio event
		 * 	@param {Frequency} frequency The rate of the callback
		 * 	@example
		 * //the callback will be invoked approximately once a second
		 * //and will print the time exactly once a second apart.
		 * var clock = new Tone.Clock(function(time){
		 * 	console.log(time);
		 * }, 1);
		 */
	    Tone.Clock = function () {
	        var options = Tone.defaults(arguments, [
	            'callback',
	            'frequency'
	        ], Tone.Clock);
	        Tone.Emitter.call(this);
	        /**
			 *  The callback function to invoke at the scheduled tick.
			 *  @type  {Function}
			 */
	        this.callback = options.callback;
	        /**
			 *  The next time the callback is scheduled.
			 *  @type {Number}
			 *  @private
			 */
	        this._nextTick = 0;
	        /**
			 *  The last state of the clock.
			 *  @type  {State}
			 *  @private
			 */
	        this._lastState = Tone.State.Stopped;
	        /**
			 *  The rate the callback function should be invoked. 
			 *  @type  {BPM}
			 *  @signal
			 */
	        this.frequency = new Tone.TickSignal(options.frequency, Tone.Type.Frequency);
	        this._readOnly('frequency');
	        /**
			 *  The number of times the callback was invoked. Starts counting at 0
			 *  and increments after the callback was invoked. 
			 *  @type {Ticks}
			 *  @readOnly
			 */
	        this.ticks = 0;
	        /**
			 *  The state timeline
			 *  @type {Tone.TimelineState}
			 *  @private
			 */
	        this._state = new Tone.TimelineState(Tone.State.Stopped);
	        /**
			 *  The loop function bound to its context. 
			 *  This is necessary to remove the event in the end.
			 *  @type {Function}
			 *  @private
			 */
	        this._boundLoop = this._loop.bind(this);
	        //bind a callback to the worker thread
	        this.context.on('tick', this._boundLoop);
	    };
	    Tone.extend(Tone.Clock, Tone.Emitter);
	    /**
		 *  The defaults
		 *  @const
		 *  @type  {Object}
		 */
	    Tone.Clock.defaults = {
	        'callback': Tone.noOp,
	        'frequency': 1
	    };
	    /**
		 *  Returns the playback state of the source, either "started", "stopped" or "paused".
		 *  @type {Tone.State}
		 *  @readOnly
		 *  @memberOf Tone.Clock#
		 *  @name state
		 */
	    Object.defineProperty(Tone.Clock.prototype, 'state', {
	        get: function () {
	            return this._state.getValueAtTime(this.now());
	        }
	    });
	    /**
		 *  Start the clock at the given time. Optionally pass in an offset
		 *  of where to start the tick counter from.
		 *  @param  {Time=}  time    The time the clock should start
		 *  @param  {Ticks=}  offset  Where the tick counter starts counting from.
		 *  @return  {Tone.Clock}  this
		 */
	    Tone.Clock.prototype.start = function (time, offset) {
	        time = this.toSeconds(time);
	        if (this._state.getValueAtTime(time) !== Tone.State.Started) {
	            this._state.setStateAtTime(Tone.State.Started, time);
	            this._state.get(time).offset = offset;
	        }
	        return this;
	    };
	    /**
		 *  Stop the clock. Stopping the clock resets the tick counter to 0.
		 *  @param {Time} [time=now] The time when the clock should stop.
		 *  @returns {Tone.Clock} this
		 *  @example
		 * clock.stop();
		 */
	    Tone.Clock.prototype.stop = function (time) {
	        time = this.toSeconds(time);
	        this._state.cancel(time);
	        this._state.setStateAtTime(Tone.State.Stopped, time);
	        return this;
	    };
	    /**
		 *  Pause the clock. Pausing does not reset the tick counter.
		 *  @param {Time} [time=now] The time when the clock should stop.
		 *  @returns {Tone.Clock} this
		 */
	    Tone.Clock.prototype.pause = function (time) {
	        time = this.toSeconds(time);
	        if (this._state.getValueAtTime(time) === Tone.State.Started) {
	            this._state.setStateAtTime(Tone.State.Paused, time);
	        }
	        return this;
	    };
	    /**
		 *  The scheduling loop.
		 *  @private
		 */
	    Tone.Clock.prototype._loop = function () {
	        //the end of the update interval
	        var endTime = this.now() + this.context.updateInterval;
	        //the current event at the time of the loop
	        var event = this._state.get(endTime);
	        if (event) {
	            //state change events
	            if (event.state !== this._lastState) {
	                this._lastState = event.state;
	                switch (event.state) {
	                case Tone.State.Started:
	                    if (!Tone.isUndef(event.offset)) {
	                        this.ticks = event.offset;
	                    }
	                    this._nextTick = event.time;
	                    this.emit('start', event.time, this.ticks);
	                    break;
	                case Tone.State.Stopped:
	                    this.ticks = 0;
	                    this.emit('stop', event.time);
	                    break;
	                case Tone.State.Paused:
	                    this.emit('pause', event.time);
	                    break;
	                }
	            }
	            //all the tick events
	            while (endTime > this._nextTick && this._state) {
	                var tickTime = this._nextTick;
	                if (this.frequency) {
	                    this._nextTick += this.frequency.getDurationOfTicks(1, this._nextTick);
	                    if (event.state === Tone.State.Started) {
	                        try {
	                            this.callback(tickTime);
	                            this.ticks++;
	                        } catch (e) {
	                            this.ticks++;
	                            throw e;
	                        }
	                    }
	                }
	            }
	        }
	    };
	    /**
		 *  Returns the scheduled state at the given time.
		 *  @param  {Time}  time  The time to query.
		 *  @return  {String}  The name of the state input in setStateAtTime.
		 *  @example
		 * clock.start("+0.1");
		 * clock.getStateAtTime("+0.1"); //returns "started"
		 */
	    Tone.Clock.prototype.getStateAtTime = function (time) {
	        time = this.toSeconds(time);
	        return this._state.getValueAtTime(time);
	    };
	    /**
		 *  Clean up
		 *  @returns {Tone.Clock} this
		 */
	    Tone.Clock.prototype.dispose = function () {
	        Tone.Emitter.prototype.dispose.call(this);
	        this.context.off('tick', this._boundLoop);
	        this._writable('frequency');
	        this.frequency.dispose();
	        this.frequency = null;
	        this._boundLoop = null;
	        this._nextTick = Infinity;
	        this.callback = null;
	        this._state.dispose();
	        this._state = null;
	    };
	    return Tone.Clock;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Similar to Tone.Timeline, but all events represent
		 *         intervals with both "time" and "duration" times. The 
		 *         events are placed in a tree structure optimized
		 *         for querying an intersection point with the timeline
		 *         events. Internally uses an [Interval Tree](https://en.wikipedia.org/wiki/Interval_tree)
		 *         to represent the data.
		 *  @extends {Tone}
		 */
	    Tone.IntervalTimeline = function () {
	        Tone.call(this);
	        /**
			 *  The root node of the inteval tree
			 *  @type  {IntervalNode}
			 *  @private
			 */
	        this._root = null;
	        /**
			 *  Keep track of the length of the timeline.
			 *  @type  {Number}
			 *  @private
			 */
	        this._length = 0;
	    };
	    Tone.extend(Tone.IntervalTimeline);
	    /**
		 *  The event to add to the timeline. All events must 
		 *  have a time and duration value
		 *  @param  {Object}  event  The event to add to the timeline
		 *  @return  {Tone.IntervalTimeline}  this
		 */
	    Tone.IntervalTimeline.prototype.add = function (event) {
	        if (Tone.isUndef(event.time) || Tone.isUndef(event.duration)) {
	            throw new Error('Tone.IntervalTimeline: events must have time and duration parameters');
	        }
	        var node = new IntervalNode(event.time, event.time + event.duration, event);
	        if (this._root === null) {
	            this._root = node;
	        } else {
	            this._root.insert(node);
	        }
	        this._length++;
	        // Restructure tree to be balanced
	        while (node !== null) {
	            node.updateHeight();
	            node.updateMax();
	            this._rebalance(node);
	            node = node.parent;
	        }
	        return this;
	    };
	    /**
		 *  Remove an event from the timeline.
		 *  @param  {Object}  event  The event to remove from the timeline
		 *  @return  {Tone.IntervalTimeline}  this
		 */
	    Tone.IntervalTimeline.prototype.remove = function (event) {
	        if (this._root !== null) {
	            var results = [];
	            this._root.search(event.time, results);
	            for (var i = 0; i < results.length; i++) {
	                var node = results[i];
	                if (node.event === event) {
	                    this._removeNode(node);
	                    this._length--;
	                    break;
	                }
	            }
	        }
	        return this;
	    };
	    /**
		 *  The number of items in the timeline.
		 *  @type {Number}
		 *  @memberOf Tone.IntervalTimeline#
		 *  @name length
		 *  @readOnly
		 */
	    Object.defineProperty(Tone.IntervalTimeline.prototype, 'length', {
	        get: function () {
	            return this._length;
	        }
	    });
	    /**
		 *  Remove events whose time time is after the given time
		 *  @param  {Number}  time  The time to query.
		 *  @returns {Tone.IntervalTimeline} this
		 */
	    Tone.IntervalTimeline.prototype.cancel = function (after) {
	        this.forEachAfter(after, function (event) {
	            this.remove(event);
	        }.bind(this));
	        return this;
	    };
	    /**
		 *  Set the root node as the given node
		 *  @param {IntervalNode} node
		 *  @private
		 */
	    Tone.IntervalTimeline.prototype._setRoot = function (node) {
	        this._root = node;
	        if (this._root !== null) {
	            this._root.parent = null;
	        }
	    };
	    /**
		 *  Replace the references to the node in the node's parent
		 *  with the replacement node.
		 *  @param  {IntervalNode}  node        
		 *  @param  {IntervalNode}  replacement 
		 *  @private
		 */
	    Tone.IntervalTimeline.prototype._replaceNodeInParent = function (node, replacement) {
	        if (node.parent !== null) {
	            if (node.isLeftChild()) {
	                node.parent.left = replacement;
	            } else {
	                node.parent.right = replacement;
	            }
	            this._rebalance(node.parent);
	        } else {
	            this._setRoot(replacement);
	        }
	    };
	    /**
		 *  Remove the node from the tree and replace it with 
		 *  a successor which follows the schema.
		 *  @param  {IntervalNode}  node
		 *  @private
		 */
	    Tone.IntervalTimeline.prototype._removeNode = function (node) {
	        if (node.left === null && node.right === null) {
	            this._replaceNodeInParent(node, null);
	        } else if (node.right === null) {
	            this._replaceNodeInParent(node, node.left);
	        } else if (node.left === null) {
	            this._replaceNodeInParent(node, node.right);
	        } else {
	            var balance = node.getBalance();
	            var replacement, temp;
	            if (balance > 0) {
	                if (node.left.right === null) {
	                    replacement = node.left;
	                    replacement.right = node.right;
	                    temp = replacement;
	                } else {
	                    replacement = node.left.right;
	                    while (replacement.right !== null) {
	                        replacement = replacement.right;
	                    }
	                    replacement.parent.right = replacement.left;
	                    temp = replacement.parent;
	                    replacement.left = node.left;
	                    replacement.right = node.right;
	                }
	            } else {
	                if (node.right.left === null) {
	                    replacement = node.right;
	                    replacement.left = node.left;
	                    temp = replacement;
	                } else {
	                    replacement = node.right.left;
	                    while (replacement.left !== null) {
	                        replacement = replacement.left;
	                    }
	                    replacement.parent = replacement.parent;
	                    replacement.parent.left = replacement.right;
	                    temp = replacement.parent;
	                    replacement.left = node.left;
	                    replacement.right = node.right;
	                }
	            }
	            if (node.parent !== null) {
	                if (node.isLeftChild()) {
	                    node.parent.left = replacement;
	                } else {
	                    node.parent.right = replacement;
	                }
	            } else {
	                this._setRoot(replacement);
	            }
	            // this._replaceNodeInParent(node, replacement);
	            this._rebalance(temp);
	        }
	        node.dispose();
	    };
	    /**
		 *  Rotate the tree to the left
		 *  @param  {IntervalNode}  node
		 *  @private
		 */
	    Tone.IntervalTimeline.prototype._rotateLeft = function (node) {
	        var parent = node.parent;
	        var isLeftChild = node.isLeftChild();
	        // Make node.right the new root of this sub tree (instead of node)
	        var pivotNode = node.right;
	        node.right = pivotNode.left;
	        pivotNode.left = node;
	        if (parent !== null) {
	            if (isLeftChild) {
	                parent.left = pivotNode;
	            } else {
	                parent.right = pivotNode;
	            }
	        } else {
	            this._setRoot(pivotNode);
	        }
	    };
	    /**
		 *  Rotate the tree to the right
		 *  @param  {IntervalNode}  node
		 *  @private
		 */
	    Tone.IntervalTimeline.prototype._rotateRight = function (node) {
	        var parent = node.parent;
	        var isLeftChild = node.isLeftChild();
	        // Make node.left the new root of this sub tree (instead of node)
	        var pivotNode = node.left;
	        node.left = pivotNode.right;
	        pivotNode.right = node;
	        if (parent !== null) {
	            if (isLeftChild) {
	                parent.left = pivotNode;
	            } else {
	                parent.right = pivotNode;
	            }
	        } else {
	            this._setRoot(pivotNode);
	        }
	    };
	    /**
		 *  Balance the BST
		 *  @param  {IntervalNode}  node
		 *  @private
		 */
	    Tone.IntervalTimeline.prototype._rebalance = function (node) {
	        var balance = node.getBalance();
	        if (balance > 1) {
	            if (node.left.getBalance() < 0) {
	                this._rotateLeft(node.left);
	            } else {
	                this._rotateRight(node);
	            }
	        } else if (balance < -1) {
	            if (node.right.getBalance() > 0) {
	                this._rotateRight(node.right);
	            } else {
	                this._rotateLeft(node);
	            }
	        }
	    };
	    /**
		 *  Get an event whose time and duration span the give time. Will
		 *  return the match whose "time" value is closest to the given time.
		 *  @param  {Object}  event  The event to add to the timeline
		 *  @return  {Object}  The event which spans the desired time
		 */
	    Tone.IntervalTimeline.prototype.get = function (time) {
	        if (this._root !== null) {
	            var results = [];
	            this._root.search(time, results);
	            if (results.length > 0) {
	                var max = results[0];
	                for (var i = 1; i < results.length; i++) {
	                    if (results[i].low > max.low) {
	                        max = results[i];
	                    }
	                }
	                return max.event;
	            }
	        }
	        return null;
	    };
	    /**
		 *  Iterate over everything in the timeline.
		 *  @param  {Function}  callback The callback to invoke with every item
		 *  @returns {Tone.IntervalTimeline} this
		 */
	    Tone.IntervalTimeline.prototype.forEach = function (callback) {
	        if (this._root !== null) {
	            var allNodes = [];
	            this._root.traverse(function (node) {
	                allNodes.push(node);
	            });
	            for (var i = 0; i < allNodes.length; i++) {
	                var ev = allNodes[i].event;
	                if (ev) {
	                    callback(ev);
	                }
	            }
	        }
	        return this;
	    };
	    /**
		 *  Iterate over everything in the array in which the given time
		 *  overlaps with the time and duration time of the event.
		 *  @param  {Number}  time The time to check if items are overlapping
		 *  @param  {Function}  callback The callback to invoke with every item
		 *  @returns {Tone.IntervalTimeline} this
		 */
	    Tone.IntervalTimeline.prototype.forEachAtTime = function (time, callback) {
	        if (this._root !== null) {
	            var results = [];
	            this._root.search(time, results);
	            for (var i = results.length - 1; i >= 0; i--) {
	                var ev = results[i].event;
	                if (ev) {
	                    callback(ev);
	                }
	            }
	        }
	        return this;
	    };
	    /**
		 *  Iterate over everything in the array in which the time is greater
		 *  than the given time.
		 *  @param  {Number}  time The time to check if items are before
		 *  @param  {Function}  callback The callback to invoke with every item
		 *  @returns {Tone.IntervalTimeline} this
		 */
	    Tone.IntervalTimeline.prototype.forEachAfter = function (time, callback) {
	        if (this._root !== null) {
	            var results = [];
	            this._root.searchAfter(time, results);
	            for (var i = results.length - 1; i >= 0; i--) {
	                var ev = results[i].event;
	                callback(ev);
	            }
	        }
	        return this;
	    };
	    /**
		 *  Clean up
		 *  @return  {Tone.IntervalTimeline}  this
		 */
	    Tone.IntervalTimeline.prototype.dispose = function () {
	        var allNodes = [];
	        if (this._root !== null) {
	            this._root.traverse(function (node) {
	                allNodes.push(node);
	            });
	        }
	        for (var i = 0; i < allNodes.length; i++) {
	            allNodes[i].dispose();
	        }
	        allNodes = null;
	        this._root = null;
	        return this;
	    };
	    ///////////////////////////////////////////////////////////////////////////
	    //	INTERVAL NODE HELPER
	    ///////////////////////////////////////////////////////////////////////////
	    /**
		 *  Represents a node in the binary search tree, with the addition
		 *  of a "high" value which keeps track of the highest value of
		 *  its children. 
		 *  References: 
		 *  https://brooknovak.wordpress.com/2013/12/07/augmented-interval-tree-in-c/
		 *  http://www.mif.vu.lt/~valdas/ALGORITMAI/LITERATURA/Cormen/Cormen.pdf
		 *  @param {Number} low
		 *  @param {Number} high
		 *  @private
		 */
	    var IntervalNode = function (low, high, event) {
	        //the event container
	        this.event = event;
	        //the low value
	        this.low = low;
	        //the high value
	        this.high = high;
	        //the high value for this and all child nodes
	        this.max = this.high;
	        //the nodes to the left
	        this._left = null;
	        //the nodes to the right
	        this._right = null;
	        //the parent node
	        this.parent = null;
	        //the number of child nodes
	        this.height = 0;
	    };
	    /** 
		 *  Insert a node into the correct spot in the tree
		 *  @param  {IntervalNode}  node
		 */
	    IntervalNode.prototype.insert = function (node) {
	        if (node.low <= this.low) {
	            if (this.left === null) {
	                this.left = node;
	            } else {
	                this.left.insert(node);
	            }
	        } else {
	            if (this.right === null) {
	                this.right = node;
	            } else {
	                this.right.insert(node);
	            }
	        }
	    };
	    /**
		 *  Search the tree for nodes which overlap 
		 *  with the given point
		 *  @param  {Number}  point  The point to query
		 *  @param  {Array}  results  The array to put the results
		 */
	    IntervalNode.prototype.search = function (point, results) {
	        // If p is to the right of the rightmost point of any interval
	        // in this node and all children, there won't be any matches.
	        if (point > this.max) {
	            return;
	        }
	        // Search left children
	        if (this.left !== null) {
	            this.left.search(point, results);
	        }
	        // Check this node
	        if (this.low <= point && this.high > point) {
	            results.push(this);
	        }
	        // If p is to the left of the time of this interval,
	        // then it can't be in any child to the right.
	        if (this.low > point) {
	            return;
	        }
	        // Search right children
	        if (this.right !== null) {
	            this.right.search(point, results);
	        }
	    };
	    /**
		 *  Search the tree for nodes which are less 
		 *  than the given point
		 *  @param  {Number}  point  The point to query
		 *  @param  {Array}  results  The array to put the results
		 */
	    IntervalNode.prototype.searchAfter = function (point, results) {
	        // Check this node
	        if (this.low >= point) {
	            results.push(this);
	            if (this.left !== null) {
	                this.left.searchAfter(point, results);
	            }
	        }
	        // search the right side
	        if (this.right !== null) {
	            this.right.searchAfter(point, results);
	        }
	    };
	    /**
		 *  Invoke the callback on this element and both it's branches
		 *  @param  {Function}  callback
		 */
	    IntervalNode.prototype.traverse = function (callback) {
	        callback(this);
	        if (this.left !== null) {
	            this.left.traverse(callback);
	        }
	        if (this.right !== null) {
	            this.right.traverse(callback);
	        }
	    };
	    /**
		 *  Update the height of the node
		 */
	    IntervalNode.prototype.updateHeight = function () {
	        if (this.left !== null && this.right !== null) {
	            this.height = Math.max(this.left.height, this.right.height) + 1;
	        } else if (this.right !== null) {
	            this.height = this.right.height + 1;
	        } else if (this.left !== null) {
	            this.height = this.left.height + 1;
	        } else {
	            this.height = 0;
	        }
	    };
	    /**
		 *  Update the height of the node
		 */
	    IntervalNode.prototype.updateMax = function () {
	        this.max = this.high;
	        if (this.left !== null) {
	            this.max = Math.max(this.max, this.left.max);
	        }
	        if (this.right !== null) {
	            this.max = Math.max(this.max, this.right.max);
	        }
	    };
	    /**
		 *  The balance is how the leafs are distributed on the node
		 *  @return  {Number}  Negative numbers are balanced to the right
		 */
	    IntervalNode.prototype.getBalance = function () {
	        var balance = 0;
	        if (this.left !== null && this.right !== null) {
	            balance = this.left.height - this.right.height;
	        } else if (this.left !== null) {
	            balance = this.left.height + 1;
	        } else if (this.right !== null) {
	            balance = -(this.right.height + 1);
	        }
	        return balance;
	    };
	    /**
		 *  @returns {Boolean} true if this node is the left child
		 *  of its parent
		 */
	    IntervalNode.prototype.isLeftChild = function () {
	        return this.parent !== null && this.parent.left === this;
	    };
	    /**
		 *  get/set the left node
		 *  @type {IntervalNode}
		 */
	    Object.defineProperty(IntervalNode.prototype, 'left', {
	        get: function () {
	            return this._left;
	        },
	        set: function (node) {
	            this._left = node;
	            if (node !== null) {
	                node.parent = this;
	            }
	            this.updateHeight();
	            this.updateMax();
	        }
	    });
	    /**
		 *  get/set the right node
		 *  @type {IntervalNode}
		 */
	    Object.defineProperty(IntervalNode.prototype, 'right', {
	        get: function () {
	            return this._right;
	        },
	        set: function (node) {
	            this._right = node;
	            if (node !== null) {
	                node.parent = this;
	            }
	            this.updateHeight();
	            this.updateMax();
	        }
	    });
	    /**
		 *  null out references.
		 */
	    IntervalNode.prototype.dispose = function () {
	        this.parent = null;
	        this._left = null;
	        this._right = null;
	        this.event = null;
	    };
	    ///////////////////////////////////////////////////////////////////////////
	    //	END INTERVAL NODE HELPER
	    ///////////////////////////////////////////////////////////////////////////
	    return Tone.IntervalTimeline;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class  Transport for timing musical events.
		 *          Supports tempo curves and time changes. Unlike browser-based timing (setInterval, requestAnimationFrame)
		 *          Tone.Transport timing events pass in the exact time of the scheduled event
		 *          in the argument of the callback function. Pass that time value to the object
		 *          you're scheduling. <br><br>
		 *          A single transport is created for you when the library is initialized. 
		 *          <br><br>
		 *          The transport emits the events: "start", "stop", "pause", and "loop" which are
		 *          called with the time of that event as the argument. 
		 *
		 *  @extends {Tone.Emitter}
		 *  @singleton
		 *  @example
		 * //repeated event every 8th note
		 * Tone.Transport.scheduleRepeat(function(time){
		 * 	//do something with the time
		 * }, "8n");
		 *  @example
		 * //schedule an event on the 16th measure
		 * Tone.Transport.schedule(function(time){
		 * 	//do something with the time
		 * }, "16:0:0");
		 */
	    Tone.Transport = function () {
	        Tone.Emitter.call(this);
	        Tone.getContext(function () {
	            ///////////////////////////////////////////////////////////////////////
	            //	LOOPING
	            //////////////////////////////////////////////////////////////////////
	            /** 
				 * 	If the transport loops or not.
				 *  @type {boolean}
				 */
	            this.loop = false;
	            /** 
				 * 	The loop start position in ticks
				 *  @type {Ticks}
				 *  @private
				 */
	            this._loopStart = 0;
	            /** 
				 * 	The loop end position in ticks
				 *  @type {Ticks}
				 *  @private
				 */
	            this._loopEnd = 0;
	            ///////////////////////////////////////////////////////////////////////
	            //	CLOCK/TEMPO
	            //////////////////////////////////////////////////////////////////////
	            /**
				 *  Pulses per quarter is the number of ticks per quarter note.
				 *  @private
				 *  @type  {Number}
				 */
	            this._ppq = TransportConstructor.defaults.PPQ;
	            /**
				 *  watches the main oscillator for timing ticks
				 *  initially starts at 120bpm
				 *  @private
				 *  @type {Tone.Clock}
				 */
	            this._clock = new Tone.Clock({
	                'callback': this._processTick.bind(this),
	                'frequency': 0
	            });
	            this._bindClockEvents();
	            /**
				 *  The Beats Per Minute of the Transport. 
				 *  @type {BPM}
				 *  @signal
				 *  @example
				 * Tone.Transport.bpm.value = 80;
				 * //ramp the bpm to 120 over 10 seconds
				 * Tone.Transport.bpm.rampTo(120, 10);
				 */
	            this.bpm = this._clock.frequency;
	            this.bpm._toUnits = this._toUnits.bind(this);
	            this.bpm._fromUnits = this._fromUnits.bind(this);
	            this.bpm.units = Tone.Type.BPM;
	            this.bpm.value = TransportConstructor.defaults.bpm;
	            this._readOnly('bpm');
	            /**
				 *  The time signature, or more accurately the numerator
				 *  of the time signature over a denominator of 4. 
				 *  @type {Number}
				 *  @private
				 */
	            this._timeSignature = TransportConstructor.defaults.timeSignature;
	            ///////////////////////////////////////////////////////////////////////
	            //	TIMELINE EVENTS
	            //////////////////////////////////////////////////////////////////////
	            /**
				 *  All the events in an object to keep track by ID
				 *  @type {Object}
				 *  @private
				 */
	            this._scheduledEvents = {};
	            /**
				 *  The event ID counter
				 *  @type {Number}
				 *  @private
				 */
	            this._eventID = 0;
	            /**
				 * 	The scheduled events.
				 *  @type {Tone.Timeline}
				 *  @private
				 */
	            this._timeline = new Tone.Timeline();
	            /**
				 *  Repeated events
				 *  @type {Array}
				 *  @private
				 */
	            this._repeatedEvents = new Tone.IntervalTimeline();
	            /**
				 *  Events that occur once
				 *  @type {Array}
				 *  @private
				 */
	            this._onceEvents = new Tone.Timeline();
	            /** 
				 *  All of the synced Signals
				 *  @private 
				 *  @type {Array}
				 */
	            this._syncedSignals = [];
	            ///////////////////////////////////////////////////////////////////////
	            //	SWING
	            //////////////////////////////////////////////////////////////////////
	            /**
				 *  The subdivision of the swing
				 *  @type  {Ticks}
				 *  @private
				 */
	            this._swingTicks = TransportConstructor.defaults.PPQ / 2;
	            //8n
	            /**
				 *  The swing amount
				 *  @type {NormalRange}
				 *  @private
				 */
	            this._swingAmount = 0;
	        }.bind(this));
	    };
	    Tone.extend(Tone.Transport, Tone.Emitter);
	    /**
		 *  the defaults
		 *  @type {Object}
		 *  @const
		 *  @static
		 */
	    Tone.Transport.defaults = {
	        'bpm': 120,
	        'swing': 0,
	        'swingSubdivision': '8n',
	        'timeSignature': 4,
	        'loopStart': 0,
	        'loopEnd': '4m',
	        'PPQ': 192
	    };
	    ///////////////////////////////////////////////////////////////////////////////
	    //	TICKS
	    ///////////////////////////////////////////////////////////////////////////////
	    /**
		 *  called on every tick
		 *  @param   {number} tickTime clock relative tick time
		 *  @private
		 */
	    Tone.Transport.prototype._processTick = function (tickTime) {
	        var ticks = this._clock.ticks;
	        //handle swing
	        if (this._swingAmount > 0 && ticks % this._ppq !== 0 && //not on a downbeat
	            ticks % (this._swingTicks * 2) !== 0) {
	            //add some swing
	            var progress = ticks % (this._swingTicks * 2) / (this._swingTicks * 2);
	            var amount = Math.sin(progress * Math.PI) * this._swingAmount;
	            tickTime += Tone.Time(this._swingTicks * 2 / 3, 'i') * amount;
	        }
	        //do the loop test
	        if (this.loop) {
	            if (ticks >= this._loopEnd) {
	                this.emit('loopEnd', tickTime);
	                this._clock.ticks = this._loopStart;
	                ticks = this._loopStart;
	                this.emit('loopStart', tickTime, this.seconds);
	                this.emit('loop', tickTime);
	            }
	        }
	        //process the single occurrence events
	        this._onceEvents.forEachBefore(ticks, function (event) {
	            event.callback(tickTime);
	            //remove the event
	            delete this._scheduledEvents[event.id.toString()];
	        }.bind(this));
	        //and clear the single occurrence timeline
	        this._onceEvents.cancelBefore(ticks);
	        //fire the next tick events if their time has come
	        this._timeline.forEachAtTime(ticks, function (event) {
	            event.callback(tickTime);
	        });
	        //process the repeated events
	        this._repeatedEvents.forEachAtTime(ticks, function (event) {
	            if ((ticks - event.time) % event.interval === 0) {
	                event.callback(tickTime);
	            }
	        });
	    };
	    ///////////////////////////////////////////////////////////////////////////////
	    //	SCHEDULABLE EVENTS
	    ///////////////////////////////////////////////////////////////////////////////
	    /**
		 *  Schedule an event along the timeline.
		 *  @param {Function} callback The callback to be invoked at the time.
		 *  @param {TransportTime}  time The time to invoke the callback at.
		 *  @return {Number} The id of the event which can be used for canceling the event. 
		 *  @example
		 * //trigger the callback when the Transport reaches the desired time
		 * Tone.Transport.schedule(function(time){
		 * 	envelope.triggerAttack(time);
		 * }, "128i");
		 */
	    Tone.Transport.prototype.schedule = function (callback, time) {
	        var event = {
	            'time': this.toTicks(time),
	            'callback': callback
	        };
	        var id = this._eventID++;
	        this._scheduledEvents[id.toString()] = {
	            'event': event,
	            'timeline': this._timeline
	        };
	        this._timeline.add(event);
	        return id;
	    };
	    /**
		 *  Schedule a repeated event along the timeline. The event will fire
		 *  at the `interval` starting at the `startTime` and for the specified
		 *  `duration`. 
		 *  @param  {Function}  callback   The callback to invoke.
		 *  @param  {Time}    interval   The duration between successive
		 *                               callbacks.
		 *  @param  {TimelinePosition=}    startTime  When along the timeline the events should
		 *                               start being invoked.
		 *  @param {Time} [duration=Infinity] How long the event should repeat. 
		 *  @return  {Number}    The ID of the scheduled event. Use this to cancel
		 *                           the event. 
		 *  @example
		 * //a callback invoked every eighth note after the first measure
		 * Tone.Transport.scheduleRepeat(callback, "8n", "1m");
		 */
	    Tone.Transport.prototype.scheduleRepeat = function (callback, interval, startTime, duration) {
	        if (interval <= 0) {
	            throw new Error('Tone.Transport: repeat events must have an interval larger than 0');
	        }
	        var event = {
	            'time': this.toTicks(startTime),
	            'duration': this.toTicks(Tone.defaultArg(duration, Infinity)),
	            'interval': this.toTicks(interval),
	            'callback': callback
	        };
	        var id = this._eventID++;
	        this._scheduledEvents[id.toString()] = {
	            'event': event,
	            'timeline': this._repeatedEvents
	        };
	        this._repeatedEvents.add(event);
	        return id;
	    };
	    /**
		 *  Schedule an event that will be removed after it is invoked. 
		 *  Note that if the given time is less than the current transport time, 
		 *  the event will be invoked immediately. 
		 *  @param {Function} callback The callback to invoke once.
		 *  @param {TransportTime} time The time the callback should be invoked.
		 *  @returns {Number} The ID of the scheduled event. 
		 */
	    Tone.Transport.prototype.scheduleOnce = function (callback, time) {
	        var id = this._eventID++;
	        var event = {
	            'time': this.toTicks(time),
	            'callback': callback,
	            'id': id
	        };
	        this._scheduledEvents[id.toString()] = {
	            'event': event,
	            'timeline': this._onceEvents
	        };
	        this._onceEvents.add(event);
	        return id;
	    };
	    /**
		 *  Clear the passed in event id from the timeline
		 *  @param {Number} eventId The id of the event.
		 *  @returns {Tone.Transport} this
		 */
	    Tone.Transport.prototype.clear = function (eventId) {
	        if (this._scheduledEvents.hasOwnProperty(eventId)) {
	            var item = this._scheduledEvents[eventId.toString()];
	            item.timeline.remove(item.event);
	            delete this._scheduledEvents[eventId.toString()];
	        }
	        return this;
	    };
	    /**
		 *  Remove scheduled events from the timeline after
		 *  the given time. Repeated events will be removed
		 *  if their startTime is after the given time
		 *  @param {TransportTime} [after=0] Clear all events after
		 *                          this time. 
		 *  @returns {Tone.Transport} this
		 */
	    Tone.Transport.prototype.cancel = function (after) {
	        after = Tone.defaultArg(after, 0);
	        after = this.toTicks(after);
	        this._timeline.cancel(after);
	        this._onceEvents.cancel(after);
	        this._repeatedEvents.cancel(after);
	        return this;
	    };
	    ///////////////////////////////////////////////////////////////////////////////
	    //	START/STOP/PAUSE
	    ///////////////////////////////////////////////////////////////////////////////
	    /**
		 *  Bind start/stop/pause events from the clock and emit them.
		 *  @private
		 */
	    Tone.Transport.prototype._bindClockEvents = function () {
	        this._clock.on('start', function (time, offset) {
	            offset = Tone.Time(this._clock.ticks, 'i').toSeconds();
	            this.emit('start', time, offset);
	        }.bind(this));
	        this._clock.on('stop', function (time) {
	            this.emit('stop', time);
	        }.bind(this));
	        this._clock.on('pause', function (time) {
	            this.emit('pause', time);
	        }.bind(this));
	    };
	    /**
		 *  Returns the playback state of the source, either "started", "stopped", or "paused"
		 *  @type {Tone.State}
		 *  @readOnly
		 *  @memberOf Tone.Transport#
		 *  @name state
		 */
	    Object.defineProperty(Tone.Transport.prototype, 'state', {
	        get: function () {
	            return this._clock.getStateAtTime(this.now());
	        }
	    });
	    /**
		 *  Start the transport and all sources synced to the transport.
		 *  @param  {Time} [time=now] The time when the transport should start.
		 *  @param  {TransportTime=} offset The timeline offset to start the transport.
		 *  @returns {Tone.Transport} this
		 *  @example
		 * //start the transport in one second starting at beginning of the 5th measure. 
		 * Tone.Transport.start("+1", "4:0:0");
		 */
	    Tone.Transport.prototype.start = function (time, offset) {
	        //start the clock
	        if (!Tone.isUndef(offset)) {
	            offset = this.toTicks(offset);
	        }
	        this._clock.start(time, offset);
	        return this;
	    };
	    /**
		 *  Stop the transport and all sources synced to the transport.
		 *  @param  {Time} [time=now] The time when the transport should stop. 
		 *  @returns {Tone.Transport} this
		 *  @example
		 * Tone.Transport.stop();
		 */
	    Tone.Transport.prototype.stop = function (time) {
	        this._clock.stop(time);
	        return this;
	    };
	    /**
		 *  Pause the transport and all sources synced to the transport.
		 *  @param  {Time} [time=now]
		 *  @returns {Tone.Transport} this
		 */
	    Tone.Transport.prototype.pause = function (time) {
	        this._clock.pause(time);
	        return this;
	    };
	    /**
		 * Toggle the current state of the transport. If it is
		 * started, it will stop it, otherwise it will start the Transport.
		 * @param  {Time=} time The time of the event
		 * @return {Tone.Transport}      this
		 */
	    Tone.Transport.prototype.toggle = function (time) {
	        time = this.toSeconds(time);
	        if (this._clock.getStateAtTime(time) !== Tone.State.Started) {
	            this.start(time);
	        } else {
	            this.stop(time);
	        }
	        return this;
	    };
	    ///////////////////////////////////////////////////////////////////////////////
	    //	SETTERS/GETTERS
	    ///////////////////////////////////////////////////////////////////////////////
	    /**
		 *  The time signature as just the numerator over 4. 
		 *  For example 4/4 would be just 4 and 6/8 would be 3.
		 *  @memberOf Tone.Transport#
		 *  @type {Number|Array}
		 *  @name timeSignature
		 *  @example
		 * //common time
		 * Tone.Transport.timeSignature = 4;
		 * // 7/8
		 * Tone.Transport.timeSignature = [7, 8];
		 * //this will be reduced to a single number
		 * Tone.Transport.timeSignature; //returns 3.5
		 */
	    Object.defineProperty(Tone.Transport.prototype, 'timeSignature', {
	        get: function () {
	            return this._timeSignature;
	        },
	        set: function (timeSig) {
	            if (Tone.isArray(timeSig)) {
	                timeSig = timeSig[0] / timeSig[1] * 4;
	            }
	            this._timeSignature = timeSig;
	        }
	    });
	    /**
		 * When the Tone.Transport.loop = true, this is the starting position of the loop.
		 * @memberOf Tone.Transport#
		 * @type {TransportTime}
		 * @name loopStart
		 */
	    Object.defineProperty(Tone.Transport.prototype, 'loopStart', {
	        get: function () {
	            return Tone.TransportTime(this._loopStart, 'i').toSeconds();
	        },
	        set: function (startPosition) {
	            this._loopStart = this.toTicks(startPosition);
	        }
	    });
	    /**
		 * When the Tone.Transport.loop = true, this is the ending position of the loop.
		 * @memberOf Tone.Transport#
		 * @type {TransportTime}
		 * @name loopEnd
		 */
	    Object.defineProperty(Tone.Transport.prototype, 'loopEnd', {
	        get: function () {
	            return Tone.TransportTime(this._loopEnd, 'i').toSeconds();
	        },
	        set: function (endPosition) {
	            this._loopEnd = this.toTicks(endPosition);
	        }
	    });
	    /**
		 *  Set the loop start and stop at the same time. 
		 *  @param {TransportTime} startPosition 
		 *  @param {TransportTime} endPosition   
		 *  @returns {Tone.Transport} this
		 *  @example
		 * //loop over the first measure
		 * Tone.Transport.setLoopPoints(0, "1m");
		 * Tone.Transport.loop = true;
		 */
	    Tone.Transport.prototype.setLoopPoints = function (startPosition, endPosition) {
	        this.loopStart = startPosition;
	        this.loopEnd = endPosition;
	        return this;
	    };
	    /**
		 *  The swing value. Between 0-1 where 1 equal to 
		 *  the note + half the subdivision.
		 *  @memberOf Tone.Transport#
		 *  @type {NormalRange}
		 *  @name swing
		 */
	    Object.defineProperty(Tone.Transport.prototype, 'swing', {
	        get: function () {
	            return this._swingAmount;
	        },
	        set: function (amount) {
	            //scale the values to a normal range
	            this._swingAmount = amount;
	        }
	    });
	    /**
		 *  Set the subdivision which the swing will be applied to. 
		 *  The default value is an 8th note. Value must be less 
		 *  than a quarter note.
		 *  
		 *  @memberOf Tone.Transport#
		 *  @type {Time}
		 *  @name swingSubdivision
		 */
	    Object.defineProperty(Tone.Transport.prototype, 'swingSubdivision', {
	        get: function () {
	            return Tone.Time(this._swingTicks, 'i').toNotation();
	        },
	        set: function (subdivision) {
	            this._swingTicks = this.toTicks(subdivision);
	        }
	    });
	    /**
		 *  The Transport's position in Bars:Beats:Sixteenths.
		 *  Setting the value will jump to that position right away. 
		 *  @memberOf Tone.Transport#
		 *  @type {BarsBeatsSixteenths}
		 *  @name position
		 */
	    Object.defineProperty(Tone.Transport.prototype, 'position', {
	        get: function () {
	            return Tone.TransportTime(this.ticks, 'i').toBarsBeatsSixteenths();
	        },
	        set: function (progress) {
	            var ticks = this.toTicks(progress);
	            this.ticks = ticks;
	        }
	    });
	    /**
		 *  The Transport's position in seconds
		 *  Setting the value will jump to that position right away. 
		 *  @memberOf Tone.Transport#
		 *  @type {Seconds}
		 *  @name seconds
		 */
	    Object.defineProperty(Tone.Transport.prototype, 'seconds', {
	        get: function () {
	            return Tone.TransportTime(this.ticks, 'i').toSeconds();
	        },
	        set: function (progress) {
	            var ticks = this.toTicks(progress);
	            this.ticks = ticks;
	        }
	    });
	    /**
		 *  The Transport's loop position as a normalized value. Always
		 *  returns 0 if the transport if loop is not true. 
		 *  @memberOf Tone.Transport#
		 *  @name progress
		 *  @type {NormalRange}
		 */
	    Object.defineProperty(Tone.Transport.prototype, 'progress', {
	        get: function () {
	            if (this.loop) {
	                return (this.ticks - this._loopStart) / (this._loopEnd - this._loopStart);
	            } else {
	                return 0;
	            }
	        }
	    });
	    /**
		 *  The transports current tick position.
		 *  
		 *  @memberOf Tone.Transport#
		 *  @type {Ticks}
		 *  @name ticks
		 */
	    Object.defineProperty(Tone.Transport.prototype, 'ticks', {
	        get: function () {
	            return this._clock.ticks;
	        },
	        set: function (t) {
	            if (this._clock.ticks !== t) {
	                var now = this.now();
	                //stop everything synced to the transport
	                if (this.state === Tone.State.Started) {
	                    this.emit('stop', now);
	                    this._clock.ticks = t;
	                    //restart it with the new time
	                    this.emit('start', now, this.seconds);
	                } else {
	                    this._clock.ticks = t;
	                }
	            }
	        }
	    });
	    /**
		 *  Pulses Per Quarter note. This is the smallest resolution
		 *  the Transport timing supports. This should be set once
		 *  on initialization and not set again. Changing this value 
		 *  after other objects have been created can cause problems. 
		 *  
		 *  @memberOf Tone.Transport#
		 *  @type {Number}
		 *  @name PPQ
		 */
	    Object.defineProperty(Tone.Transport.prototype, 'PPQ', {
	        get: function () {
	            return this._ppq;
	        },
	        set: function (ppq) {
	            var bpm = this.bpm.value;
	            this._ppq = ppq;
	            this.bpm.value = bpm;
	        }
	    });
	    /**
		 *  Convert from BPM to frequency (factoring in PPQ)
		 *  @param  {BPM}  bpm The BPM value to convert to frequency
		 *  @return  {Frequency}  The BPM as a frequency with PPQ factored in.
		 *  @private
		 */
	    Tone.Transport.prototype._fromUnits = function (bpm) {
	        return 1 / (60 / bpm / this.PPQ);
	    };
	    /**
		 *  Convert from frequency (with PPQ) into BPM
		 *  @param  {Frequency}  freq The clocks frequency to convert to BPM
		 *  @return  {BPM}  The frequency value as BPM.
		 *  @private
		 */
	    Tone.Transport.prototype._toUnits = function (freq) {
	        return freq / this.PPQ * 60;
	    };
	    ///////////////////////////////////////////////////////////////////////////////
	    //	SYNCING
	    ///////////////////////////////////////////////////////////////////////////////
	    /**
		 *  Returns the time aligned to the next subdivision
		 *  of the Transport. If the Transport is not started,
		 *  it will return 0.
		 *  Note: this will not work precisely during tempo ramps.
		 *  @param  {Time}  subdivision  The subdivision to quantize to
		 *  @return  {Number}  The context time of the next subdivision.
		 *  @example
		 * Tone.Transport.start(); //the transport must be started
		 * Tone.Transport.nextSubdivision("4n");
		 */
	    Tone.Transport.prototype.nextSubdivision = function (subdivision) {
	        subdivision = this.toSeconds(subdivision);
	        //if the transport's not started, return 0
	        var now;
	        if (this.state === Tone.State.Started) {
	            now = this._clock._nextTick;
	        } else {
	            return 0;
	        }
	        var transportPos = Tone.Time(this.ticks, 'i');
	        var remainingTime = subdivision - transportPos % subdivision;
	        if (remainingTime === 0) {
	            remainingTime = subdivision;
	        }
	        return now + remainingTime;
	    };
	    /**
		 *  Attaches the signal to the tempo control signal so that 
		 *  any changes in the tempo will change the signal in the same
		 *  ratio. 
		 *  
		 *  @param  {Tone.Signal} signal 
		 *  @param {number=} ratio Optionally pass in the ratio between
		 *                         the two signals. Otherwise it will be computed
		 *                         based on their current values. 
		 *  @returns {Tone.Transport} this
		 */
	    Tone.Transport.prototype.syncSignal = function (signal, ratio) {
	        if (!ratio) {
	            //get the sync ratio
	            if (signal._param.value !== 0) {
	                ratio = signal._param.value / this.bpm._param.value;
	            } else {
	                ratio = 0;
	            }
	        }
	        var ratioSignal = new Tone.Gain(ratio);
	        this.bpm.chain(ratioSignal, signal._param);
	        this._syncedSignals.push({
	            'ratio': ratioSignal,
	            'signal': signal,
	            'initial': signal._param.value
	        });
	        signal._param.value = 0;
	        return this;
	    };
	    /**
		 *  Unsyncs a previously synced signal from the transport's control. 
		 *  See Tone.Transport.syncSignal.
		 *  @param  {Tone.Signal} signal 
		 *  @returns {Tone.Transport} this
		 */
	    Tone.Transport.prototype.unsyncSignal = function (signal) {
	        for (var i = this._syncedSignals.length - 1; i >= 0; i--) {
	            var syncedSignal = this._syncedSignals[i];
	            if (syncedSignal.signal === signal) {
	                syncedSignal.ratio.dispose();
	                syncedSignal.signal._param.value = syncedSignal.initial;
	                this._syncedSignals.splice(i, 1);
	            }
	        }
	        return this;
	    };
	    /**
		 *  Clean up. 
		 *  @returns {Tone.Transport} this
		 *  @private
		 */
	    Tone.Transport.prototype.dispose = function () {
	        Tone.Emitter.prototype.dispose.call(this);
	        this._clock.dispose();
	        this._clock = null;
	        this._writable('bpm');
	        this.bpm = null;
	        this._timeline.dispose();
	        this._timeline = null;
	        this._onceEvents.dispose();
	        this._onceEvents = null;
	        this._repeatedEvents.dispose();
	        this._repeatedEvents = null;
	        return this;
	    };
	    ///////////////////////////////////////////////////////////////////////////////
	    //	INITIALIZATION
	    ///////////////////////////////////////////////////////////////////////////////
	    var TransportConstructor = Tone.Transport;
	    Tone.Transport = new TransportConstructor();
	    Tone.Context.on('init', function (context) {
	        if (context.Transport instanceof TransportConstructor) {
	            Tone.Transport = context.Transport;
	        } else {
	            Tone.Transport = new TransportConstructor();
	        }
	        //store the Transport on the context so it can be retrieved later
	        context.Transport = Tone.Transport;
	    });
	    Tone.Context.on('close', function (context) {
	        if (context.Transport instanceof TransportConstructor) {
	            context.Transport.dispose();
	        }
	    });
	    return Tone.Transport;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Tone.Volume is a simple volume node, useful for creating a volume fader.
		 *
		 *  @extends {Tone.AudioNode}
		 *  @constructor
		 *  @param {Decibels} [volume=0] the initial volume
		 *  @example
		 * var vol = new Tone.Volume(-12);
		 * instrument.chain(vol, Tone.Master);
		 */
	    Tone.Volume = function () {
	        var options = Tone.defaults(arguments, ['volume'], Tone.Volume);
	        Tone.AudioNode.call(this);
	        /**
			 * the output node
			 * @type {GainNode}
			 * @private
			 */
	        this.output = this.input = new Tone.Gain(options.volume, Tone.Type.Decibels);
	        /**
			 * The unmuted volume
			 * @type {Decibels}
			 * @private
			 */
	        this._unmutedVolume = options.volume;
	        /**
			 *  The volume control in decibels.
			 *  @type {Decibels}
			 *  @signal
			 */
	        this.volume = this.output.gain;
	        this._readOnly('volume');
	        //set the mute initially
	        this.mute = options.mute;
	    };
	    Tone.extend(Tone.Volume, Tone.AudioNode);
	    /**
		 *  Defaults
		 *  @type  {Object}
		 *  @const
		 *  @static
		 */
	    Tone.Volume.defaults = {
	        'volume': 0,
	        'mute': false
	    };
	    /**
		 * Mute the output.
		 * @memberOf Tone.Volume#
		 * @type {boolean}
		 * @name mute
		 * @example
		 * //mute the output
		 * volume.mute = true;
		 */
	    Object.defineProperty(Tone.Volume.prototype, 'mute', {
	        get: function () {
	            return this.volume.value === -Infinity;
	        },
	        set: function (mute) {
	            if (!this.mute && mute) {
	                this._unmutedVolume = this.volume.value;
	                //maybe it should ramp here?
	                this.volume.value = -Infinity;
	            } else if (this.mute && !mute) {
	                this.volume.value = this._unmutedVolume;
	            }
	        }
	    });
	    /**
		 *  clean up
		 *  @returns {Tone.Volume} this
		 */
	    Tone.Volume.prototype.dispose = function () {
	        this.input.dispose();
	        Tone.AudioNode.prototype.dispose.call(this);
	        this._writable('volume');
	        this.volume.dispose();
	        this.volume = null;
	        return this;
	    };
	    return Tone.Volume;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class  A single master output which is connected to the
		 *          AudioDestinationNode (aka your speakers).
		 *          It provides useful conveniences such as the ability
		 *          to set the volume and mute the entire application.
		 *          It also gives you the ability to apply master effects to your application.
		 *          <br><br>
		 *          Like Tone.Transport, A single Tone.Master is created
		 *          on initialization and you do not need to explicitly construct one.
		 *
		 *  @constructor
		 *  @extends {Tone}
		 *  @singleton
		 *  @example
		 * //the audio will go from the oscillator to the speakers
		 * oscillator.connect(Tone.Master);
		 * //a convenience for connecting to the master output is also provided:
		 * oscillator.toMaster();
		 * //the above two examples are equivalent.
		 */
	    Tone.Master = function () {
	        Tone.AudioNode.call(this);
	        Tone.getContext(function () {
	            this.createInsOuts(1, 0);
	            /**
				 *  The private volume node
				 *  @type  {Tone.Volume}
				 *  @private
				 */
	            this._volume = this.output = new Tone.Volume();
	            /**
				 * The volume of the master output.
				 * @type {Decibels}
				 * @signal
				 */
	            this.volume = this._volume.volume;
	            this._readOnly('volume');
	            //connections
	            this.input.chain(this.output, this.context.destination);
	        }.bind(this));
	    };
	    Tone.extend(Tone.Master, Tone.AudioNode);
	    /**
		 *  @type {Object}
		 *  @const
		 */
	    Tone.Master.defaults = {
	        'volume': 0,
	        'mute': false
	    };
	    /**
		 * Mute the output.
		 * @memberOf Tone.Master#
		 * @type {boolean}
		 * @name mute
		 * @example
		 * //mute the output
		 * Tone.Master.mute = true;
		 */
	    Object.defineProperty(Tone.Master.prototype, 'mute', {
	        get: function () {
	            return this._volume.mute;
	        },
	        set: function (mute) {
	            this._volume.mute = mute;
	        }
	    });
	    /**
		 *  Add a master effects chain. NOTE: this will disconnect any nodes which were previously
		 *  chained in the master effects chain.
		 *  @param {AudioNode|Tone} args... All arguments will be connected in a row
		 *                                  and the Master will be routed through it.
		 *  @return  {Tone.Master}  this
		 *  @example
		 * //some overall compression to keep the levels in check
		 * var masterCompressor = new Tone.Compressor({
		 * 	"threshold" : -6,
		 * 	"ratio" : 3,
		 * 	"attack" : 0.5,
		 * 	"release" : 0.1
		 * });
		 * //give a little boost to the lows
		 * var lowBump = new Tone.Filter(200, "lowshelf");
		 * //route everything through the filter
		 * //and compressor before going to the speakers
		 * Tone.Master.chain(lowBump, masterCompressor);
		 */
	    Tone.Master.prototype.chain = function () {
	        this.input.disconnect();
	        this.input.chain.apply(this.input, arguments);
	        arguments[arguments.length - 1].connect(this.output);
	    };
	    /**
		 *  Clean up
		 *  @return  {Tone.Master}  this
		 */
	    Tone.Master.prototype.dispose = function () {
	        Tone.AudioNode.prototype.dispose.call(this);
	        this._writable('volume');
	        this._volume.dispose();
	        this._volume = null;
	        this.volume = null;
	    };
	    ///////////////////////////////////////////////////////////////////////////
	    //	AUGMENT TONE's PROTOTYPE
	    ///////////////////////////////////////////////////////////////////////////
	    /**
		 *  Connect 'this' to the master output. Shorthand for this.connect(Tone.Master)
		 *  @returns {Tone.AudioNode} this
		 *  @example
		 * //connect an oscillator to the master output
		 * var osc = new Tone.Oscillator().toMaster();
		 */
	    Tone.AudioNode.prototype.toMaster = function () {
	        this.connect(Tone.Master);
	        return this;
	    };
	    if (window.AudioNode) {
	        // Also augment AudioNode's prototype to include toMaster as a convenience
	        AudioNode.prototype.toMaster = function () {
	            this.connect(Tone.Master);
	            return this;
	        };
	    }
	    /**
		 *  initialize the module and listen for new audio contexts
		 */
	    var MasterConstructor = Tone.Master;
	    Tone.Master = new MasterConstructor();
	    Tone.Context.on('init', function (context) {
	        // if it already exists, just restore it
	        if (context.Master instanceof MasterConstructor) {
	            Tone.Master = context.Master;
	        } else {
	            Tone.Master = new MasterConstructor();
	        }
	        context.Master = Tone.Master;
	    });
	    Tone.Context.on('close', function (context) {
	        if (context.Master instanceof MasterConstructor) {
	            context.Master.dispose();
	        }
	    });
	    return Tone.Master;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class  Base class for sources. Sources have start/stop methods
		 *          and the ability to be synced to the
		 *          start/stop of Tone.Transport.
		 *
		 *  @constructor
		 *  @extends {Tone.AudioNode}
		 *  @example
		 * //Multiple state change events can be chained together,
		 * //but must be set in the correct order and with ascending times
		 *
		 * // OK
		 * state.start().stop("+0.2");
		 * // AND
		 * state.start().stop("+0.2").start("+0.4").stop("+0.7")
		 *
		 * // BAD
		 * state.stop("+0.2").start();
		 * // OR
		 * state.start("+0.3").stop("+0.2");
		 *
		 */
	    Tone.Source = function (options) {
	        options = Tone.defaultArg(options, Tone.Source.defaults);
	        Tone.AudioNode.call(this);
	        /**
			 *  The output volume node
			 *  @type  {Tone.Volume}
			 *  @private
			 */
	        this._volume = this.output = new Tone.Volume(options.volume);
	        /**
			 * The volume of the output in decibels.
			 * @type {Decibels}
			 * @signal
			 * @example
			 * source.volume.value = -6;
			 */
	        this.volume = this._volume.volume;
	        this._readOnly('volume');
	        /**
			 * 	Keep track of the scheduled state.
			 *  @type {Tone.TimelineState}
			 *  @private
			 */
	        this._state = new Tone.TimelineState(Tone.State.Stopped);
	        this._state.memory = 10;
	        /**
			 *  The synced `start` callback function from the transport
			 *  @type {Function}
			 *  @private
			 */
	        this._synced = false;
	        /**
			 *  Keep track of all of the scheduled event ids
			 *  @type  {Array}
			 *  @private
			 */
	        this._scheduled = [];
	        //make the output explicitly stereo
	        this._volume.output.output.channelCount = 2;
	        this._volume.output.output.channelCountMode = 'explicit';
	        //mute initially
	        this.mute = options.mute;
	    };
	    Tone.extend(Tone.Source, Tone.AudioNode);
	    /**
		 *  The default parameters
		 *  @static
		 *  @const
		 *  @type {Object}
		 */
	    Tone.Source.defaults = {
	        'volume': 0,
	        'mute': false
	    };
	    /**
		 *  Returns the playback state of the source, either "started" or "stopped".
		 *  @type {Tone.State}
		 *  @readOnly
		 *  @memberOf Tone.Source#
		 *  @name state
		 */
	    Object.defineProperty(Tone.Source.prototype, 'state', {
	        get: function () {
	            if (this._synced) {
	                if (Tone.Transport.state === Tone.State.Started) {
	                    return this._state.getValueAtTime(Tone.Transport.seconds);
	                } else {
	                    return Tone.State.Stopped;
	                }
	            } else {
	                return this._state.getValueAtTime(this.now());
	            }
	        }
	    });
	    /**
		 * Mute the output.
		 * @memberOf Tone.Source#
		 * @type {boolean}
		 * @name mute
		 * @example
		 * //mute the output
		 * source.mute = true;
		 */
	    Object.defineProperty(Tone.Source.prototype, 'mute', {
	        get: function () {
	            return this._volume.mute;
	        },
	        set: function (mute) {
	            this._volume.mute = mute;
	        }
	    });
	    //overwrite these functions
	    Tone.Source.prototype._start = Tone.noOp;
	    Tone.Source.prototype._stop = Tone.noOp;
	    /**
		 *  Start the source at the specified time. If no time is given,
		 *  start the source now.
		 *  @param  {Time} [time=now] When the source should be started.
		 *  @returns {Tone.Source} this
		 *  @example
		 * source.start("+0.5"); //starts the source 0.5 seconds from now
		 */
	    Tone.Source.prototype.start = function (time, offset, duration) {
	        if (Tone.isUndef(time) && this._synced) {
	            time = Tone.Transport.seconds;
	        } else {
	            time = this.toSeconds(time);
	        }
	        //if it's started, stop it and restart it
	        if (!this.retrigger && this._state.getValueAtTime(time) === Tone.State.Started) {
	            this.stop(time);
	        }
	        this._state.setStateAtTime(Tone.State.Started, time);
	        if (this._synced) {
	            // add the offset time to the event
	            var event = this._state.get(time);
	            event.offset = Tone.defaultArg(offset, 0);
	            event.duration = duration;
	            var sched = Tone.Transport.schedule(function (t) {
	                this._start(t, offset, duration);
	            }.bind(this), time);
	            this._scheduled.push(sched);
	        } else {
	            this._start.apply(this, arguments);
	        }
	        return this;
	    };
	    /**
		 *  Stop the source at the specified time. If no time is given,
		 *  stop the source now.
		 *  @param  {Time} [time=now] When the source should be stopped.
		 *  @returns {Tone.Source} this
		 *  @example
		 * source.stop(); // stops the source immediately
		 */
	    Tone.Source.prototype.stop = function (time) {
	        if (Tone.isUndef(time) && this._synced) {
	            time = Tone.Transport.seconds;
	        } else {
	            time = this.toSeconds(time);
	        }
	        this._state.cancel(time);
	        this._state.setStateAtTime(Tone.State.Stopped, time);
	        if (!this._synced) {
	            this._stop.apply(this, arguments);
	        } else {
	            var sched = Tone.Transport.schedule(this._stop.bind(this), time);
	            this._scheduled.push(sched);
	        }
	        return this;
	    };
	    /**
		 *  Sync the source to the Transport so that all subsequent
		 *  calls to `start` and `stop` are synced to the TransportTime
		 *  instead of the AudioContext time.
		 *
		 *  @returns {Tone.Source} this
		 *  @example
		 * //sync the source so that it plays between 0 and 0.3 on the Transport's timeline
		 * source.sync().start(0).stop(0.3);
		 * //start the transport.
		 * Tone.Transport.start();
		 *
		 *  @example
		 * //start the transport with an offset and the sync'ed sources
		 * //will start in the correct position
		 * source.sync().start(0.1);
		 * //the source will be invoked with an offset of 0.4
		 * Tone.Transport.start("+0.5", 0.5);
		 */
	    Tone.Source.prototype.sync = function () {
	        this._synced = true;
	        this._syncedStart = function (time, offset) {
	            if (offset > 0) {
	                // get the playback state at that time
	                var stateEvent = this._state.get(offset);
	                // listen for start events which may occur in the middle of the sync'ed time
	                if (stateEvent && stateEvent.state === Tone.State.Started && stateEvent.time !== offset) {
	                    // get the offset
	                    var startOffset = offset - this.toSeconds(stateEvent.time);
	                    var duration;
	                    if (stateEvent.duration) {
	                        duration = this.toSeconds(stateEvent.duration) - startOffset;
	                    }
	                    this._start(time, this.toSeconds(stateEvent.offset) + startOffset, duration);
	                }
	            }
	        }.bind(this);
	        this._syncedStop = function (time) {
	            if (this._state.getValueAtTime(Tone.Transport.seconds) === Tone.State.Started) {
	                this._stop(time);
	            }
	        }.bind(this);
	        Tone.Transport.on('start loopStart', this._syncedStart);
	        Tone.Transport.on('stop pause loopEnd', this._syncedStop);
	        return this;
	    };
	    /**
		 *  Unsync the source to the Transport. See Tone.Source.sync
		 *  @returns {Tone.Source} this
		 */
	    Tone.Source.prototype.unsync = function () {
	        if (this._synced) {
	            Tone.Transport.off('stop pause loopEnd', this._syncedStop);
	            Tone.Transport.off('start loopStart', this._syncedStart);
	        }
	        this._synced = false;
	        // clear all of the scheduled ids
	        for (var i = 0; i < this._scheduled.length; i++) {
	            var id = this._scheduled[i];
	            Tone.Transport.clear(id);
	        }
	        this._scheduled = [];
	        this._state.cancel(0);
	        return this;
	    };
	    /**
		 *	Clean up.
		 *  @return {Tone.Source} this
		 */
	    Tone.Source.prototype.dispose = function () {
	        Tone.AudioNode.prototype.dispose.call(this);
	        this.unsync();
	        this._scheduled = null;
	        this._writable('volume');
	        this._volume.dispose();
	        this._volume = null;
	        this.volume = null;
	        this._state.dispose();
	        this._state = null;
	    };
	    return Tone.Source;
	});
	Module(function (Tone) {
	    
	    /**
		 *  OscillatorNode shim
		 *  @private
		 */
	    if (window.OscillatorNode && !OscillatorNode.prototype.start) {
	        OscillatorNode.prototype.start = OscillatorNode.prototype.noteOn;
	        OscillatorNode.prototype.stop = OscillatorNode.prototype.noteOff;
	        if (!OscillatorNode.prototype.setPeriodicWave) {
	            OscillatorNode.prototype.setPeriodicWave = OscillatorNode.prototype.setWaveTable;
	        }
	        if (!AudioContext.prototype.createPeriodicWave) {
	            AudioContext.prototype.createPeriodicWave = AudioContext.prototype.createWaveTable;
	        }
	    }
	    /**
		 *  @class Tone.Oscillator supports a number of features including
		 *         phase rotation, multiple oscillator types (see Tone.Oscillator.type), 
		 *         and Transport syncing (see Tone.Oscillator.syncFrequency).
		 *
		 *  @constructor
		 *  @extends {Tone.Source}
		 *  @param {Frequency} [frequency] Starting frequency
		 *  @param {string} [type] The oscillator type. Read more about type below.
		 *  @example
		 * //make and start a 440hz sine tone
		 * var osc = new Tone.Oscillator(440, "sine").toMaster().start();
		 */
	    Tone.Oscillator = function () {
	        var options = Tone.defaults(arguments, [
	            'frequency',
	            'type'
	        ], Tone.Oscillator);
	        Tone.Source.call(this, options);
	        /**
			 *  the main oscillator
			 *  @type {OscillatorNode}
			 *  @private
			 */
	        this._oscillator = null;
	        /**
			 *  The frequency control.
			 *  @type {Frequency}
			 *  @signal
			 */
	        this.frequency = new Tone.Signal(options.frequency, Tone.Type.Frequency);
	        /**
			 *  The detune control signal.
			 *  @type {Cents}
			 *  @signal
			 */
	        this.detune = new Tone.Signal(options.detune, Tone.Type.Cents);
	        /**
			 *  the periodic wave
			 *  @type {PeriodicWave}
			 *  @private
			 */
	        this._wave = null;
	        /**
			 *  The partials of the oscillator
			 *  @type {Array}
			 *  @private
			 */
	        this._partials = Tone.defaultArg(options.partials, [1]);
	        /**
			 *  the phase of the oscillator
			 *  between 0 - 360
			 *  @type {number}
			 *  @private
			 */
	        this._phase = options.phase;
	        /**
			 *  the type of the oscillator
			 *  @type {string}
			 *  @private
			 */
	        this._type = null;
	        //setup
	        this.type = options.type;
	        this.phase = this._phase;
	        this._readOnly([
	            'frequency',
	            'detune'
	        ]);
	    };
	    Tone.extend(Tone.Oscillator, Tone.Source);
	    /**
		 *  the default parameters
		 *  @type {Object}
		 */
	    Tone.Oscillator.defaults = {
	        'type': 'sine',
	        'frequency': 440,
	        'detune': 0,
	        'phase': 0,
	        'partials': []
	    };
	    /**
		 *  The Oscillator types
		 *  @enum {String}
		 */
	    Tone.Oscillator.Type = {
	        Sine: 'sine',
	        Triangle: 'triangle',
	        Sawtooth: 'sawtooth',
	        Square: 'square',
	        Custom: 'custom'
	    };
	    /**
		 *  start the oscillator
		 *  @param  {Time} [time=now] 
		 *  @private
		 */
	    Tone.Oscillator.prototype._start = function (time) {
	        //new oscillator with previous values
	        this._oscillator = this.context.createOscillator();
	        this._oscillator.setPeriodicWave(this._wave);
	        //connect the control signal to the oscillator frequency & detune
	        this._oscillator.connect(this.output);
	        this.frequency.connect(this._oscillator.frequency);
	        this.detune.connect(this._oscillator.detune);
	        //start the oscillator
	        this._oscillator.start(this.toSeconds(time));
	    };
	    /**
		 *  stop the oscillator
		 *  @private
		 *  @param  {Time} [time=now] (optional) timing parameter
		 *  @returns {Tone.Oscillator} this
		 */
	    Tone.Oscillator.prototype._stop = function (time) {
	        if (this._oscillator) {
	            this._oscillator.stop(this.toSeconds(time));
	            this._oscillator = null;
	        }
	        return this;
	    };
	    /**
		 *  Sync the signal to the Transport's bpm. Any changes to the transports bpm,
		 *  will also affect the oscillators frequency. 
		 *  @returns {Tone.Oscillator} this
		 *  @example
		 * Tone.Transport.bpm.value = 120;
		 * osc.frequency.value = 440;
		 * //the ration between the bpm and the frequency will be maintained
		 * osc.syncFrequency();
		 * Tone.Transport.bpm.value = 240; 
		 * // the frequency of the oscillator is doubled to 880
		 */
	    Tone.Oscillator.prototype.syncFrequency = function () {
	        Tone.Transport.syncSignal(this.frequency);
	        return this;
	    };
	    /**
		 *  Unsync the oscillator's frequency from the Transport. 
		 *  See Tone.Oscillator.syncFrequency
		 *  @returns {Tone.Oscillator} this
		 */
	    Tone.Oscillator.prototype.unsyncFrequency = function () {
	        Tone.Transport.unsyncSignal(this.frequency);
	        return this;
	    };
	    /**
		 * The type of the oscillator: either sine, square, triangle, or sawtooth. Also capable of
		 * setting the first x number of partials of the oscillator. For example: "sine4" would
		 * set be the first 4 partials of the sine wave and "triangle8" would set the first
		 * 8 partials of the triangle wave.
		 * <br><br> 
		 * Uses PeriodicWave internally even for native types so that it can set the phase. 
		 * PeriodicWave equations are from the 
		 * [Webkit Web Audio implementation](https://code.google.com/p/chromium/codesearch#chromium/src/third_party/WebKit/Source/modules/webaudio/PeriodicWave.cpp&sq=package:chromium).
		 *  
		 * @memberOf Tone.Oscillator#
		 * @type {string}
		 * @name type
		 * @example
		 * //set it to a square wave
		 * osc.type = "square";
		 * @example
		 * //set the first 6 partials of a sawtooth wave
		 * osc.type = "sawtooth6";
		 */
	    Object.defineProperty(Tone.Oscillator.prototype, 'type', {
	        get: function () {
	            return this._type;
	        },
	        set: function (type) {
	            var coefs = this._getRealImaginary(type, this._phase);
	            var periodicWave = this.context.createPeriodicWave(coefs[0], coefs[1]);
	            this._wave = periodicWave;
	            if (this._oscillator !== null) {
	                this._oscillator.setPeriodicWave(this._wave);
	            }
	            this._type = type;
	        }
	    });
	    /**
		 *  Returns the real and imaginary components based 
		 *  on the oscillator type.
		 *  @returns {Array} [real, imaginary]
		 *  @private
		 */
	    Tone.Oscillator.prototype._getRealImaginary = function (type, phase) {
	        var fftSize = 4096;
	        var periodicWaveSize = fftSize / 2;
	        var real = new Float32Array(periodicWaveSize);
	        var imag = new Float32Array(periodicWaveSize);
	        var partialCount = 1;
	        if (type === Tone.Oscillator.Type.Custom) {
	            partialCount = this._partials.length + 1;
	            periodicWaveSize = partialCount;
	        } else {
	            var partial = /^(sine|triangle|square|sawtooth)(\d+)$/.exec(type);
	            if (partial) {
	                partialCount = parseInt(partial[2]) + 1;
	                type = partial[1];
	                partialCount = Math.max(partialCount, 2);
	                periodicWaveSize = partialCount;
	            }
	        }
	        for (var n = 1; n < periodicWaveSize; ++n) {
	            var piFactor = 2 / (n * Math.PI);
	            var b;
	            switch (type) {
	            case Tone.Oscillator.Type.Sine:
	                b = n <= partialCount ? 1 : 0;
	                break;
	            case Tone.Oscillator.Type.Square:
	                b = n & 1 ? 2 * piFactor : 0;
	                break;
	            case Tone.Oscillator.Type.Sawtooth:
	                b = piFactor * (n & 1 ? 1 : -1);
	                break;
	            case Tone.Oscillator.Type.Triangle:
	                if (n & 1) {
	                    b = 2 * (piFactor * piFactor) * (n - 1 >> 1 & 1 ? -1 : 1);
	                } else {
	                    b = 0;
	                }
	                break;
	            case Tone.Oscillator.Type.Custom:
	                b = this._partials[n - 1];
	                break;
	            default:
	                throw new TypeError('Tone.Oscillator: invalid type: ' + type);
	            }
	            if (b !== 0) {
	                real[n] = -b * Math.sin(phase * n);
	                imag[n] = b * Math.cos(phase * n);
	            } else {
	                real[n] = 0;
	                imag[n] = 0;
	            }
	        }
	        return [
	            real,
	            imag
	        ];
	    };
	    /**
		 *  Compute the inverse FFT for a given phase.	
		 *  @param  {Float32Array}  real
		 *  @param  {Float32Array}  imag 
		 *  @param  {NormalRange}  phase 
		 *  @return  {AudioRange}
		 *  @private
		 */
	    Tone.Oscillator.prototype._inverseFFT = function (real, imag, phase) {
	        var sum = 0;
	        var len = real.length;
	        for (var i = 0; i < len; i++) {
	            sum += real[i] * Math.cos(i * phase) + imag[i] * Math.sin(i * phase);
	        }
	        return sum;
	    };
	    /**
		 *  Returns the initial value of the oscillator.
		 *  @return  {AudioRange}
		 *  @private
		 */
	    Tone.Oscillator.prototype._getInitialValue = function () {
	        var coefs = this._getRealImaginary(this._type, 0);
	        var real = coefs[0];
	        var imag = coefs[1];
	        var maxValue = 0;
	        var twoPi = Math.PI * 2;
	        //check for peaks in 8 places
	        for (var i = 0; i < 8; i++) {
	            maxValue = Math.max(this._inverseFFT(real, imag, i / 8 * twoPi), maxValue);
	        }
	        return -this._inverseFFT(real, imag, this._phase) / maxValue;
	    };
	    /**
		 * The partials of the waveform. A partial represents 
		 * the amplitude at a harmonic. The first harmonic is the 
		 * fundamental frequency, the second is the octave and so on
		 * following the harmonic series. 
		 * Setting this value will automatically set the type to "custom". 
		 * The value is an empty array when the type is not "custom". 
		 * @memberOf Tone.Oscillator#
		 * @type {Array}
		 * @name partials
		 * @example
		 * osc.partials = [1, 0.2, 0.01];
		 */
	    Object.defineProperty(Tone.Oscillator.prototype, 'partials', {
	        get: function () {
	            if (this._type !== Tone.Oscillator.Type.Custom) {
	                return [];
	            } else {
	                return this._partials;
	            }
	        },
	        set: function (partials) {
	            this._partials = partials;
	            this.type = Tone.Oscillator.Type.Custom;
	        }
	    });
	    /**
		 * The phase of the oscillator in degrees. 
		 * @memberOf Tone.Oscillator#
		 * @type {Degrees}
		 * @name phase
		 * @example
		 * osc.phase = 180; //flips the phase of the oscillator
		 */
	    Object.defineProperty(Tone.Oscillator.prototype, 'phase', {
	        get: function () {
	            return this._phase * (180 / Math.PI);
	        },
	        set: function (phase) {
	            this._phase = phase * Math.PI / 180;
	            //reset the type
	            this.type = this._type;
	        }
	    });
	    /**
		 *  Dispose and disconnect.
		 *  @return {Tone.Oscillator} this
		 */
	    Tone.Oscillator.prototype.dispose = function () {
	        Tone.Source.prototype.dispose.call(this);
	        if (this._oscillator !== null) {
	            this._oscillator.disconnect();
	            this._oscillator = null;
	        }
	        this._wave = null;
	        this._writable([
	            'frequency',
	            'detune'
	        ]);
	        this.frequency.dispose();
	        this.frequency = null;
	        this.detune.dispose();
	        this.detune = null;
	        this._partials = null;
	        return this;
	    };
	    return Tone.Oscillator;
	});
	Module(function (Tone) {
	    /**
		 *  @class Tone.Zero outputs 0's at audio-rate. The reason this has to be
		 *         it's own class is that many browsers optimize out Tone.Signal
		 *         with a value of 0 and will not process nodes further down the graph.
		 *  @extends {Tone.SignalBase}
		 */
	    Tone.Zero = function () {
	        Tone.SignalBase.call(this);
	        /**
			 *  The gain node
			 *  @type  {Tone.Gain}
			 *  @private
			 */
	        this._gain = this.input = this.output = new Tone.Gain();
	        this.context.getConstant(0).connect(this._gain);
	    };
	    Tone.extend(Tone.Zero, Tone.SignalBase);
	    /**
		 *  clean up
		 *  @return  {Tone.Zero}  this
		 */
	    Tone.Zero.prototype.dispose = function () {
	        Tone.SignalBase.prototype.dispose.call(this);
	        this._gain.dispose();
	        this._gain = null;
	        return this;
	    };
	    return Tone.Zero;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class  LFO stands for low frequency oscillator. Tone.LFO produces an output signal
		 *          which can be attached to an AudioParam or Tone.Signal
		 *          in order to modulate that parameter with an oscillator. The LFO can
		 *          also be synced to the transport to start/stop and change when the tempo changes.
		 *
		 *  @constructor
		 *  @extends {Tone.AudioNode}
		 *  @param {Frequency|Object} [frequency] The frequency of the oscillation. Typically, LFOs will be
		 *                               in the frequency range of 0.1 to 10 hertz.
		 *  @param {number=} min The minimum output value of the LFO.
		 *  @param {number=} max The maximum value of the LFO.
		 *  @example
		 * var lfo = new Tone.LFO("4n", 400, 4000);
		 * lfo.connect(filter.frequency);
		 */
	    Tone.LFO = function () {
	        var options = Tone.defaults(arguments, [
	            'frequency',
	            'min',
	            'max'
	        ], Tone.LFO);
	        Tone.AudioNode.call(this);
	        /**
			 *  The oscillator.
			 *  @type {Tone.Oscillator}
			 *  @private
			 */
	        this._oscillator = new Tone.Oscillator({
	            'frequency': options.frequency,
	            'type': options.type
	        });
	        /**
			 *  the lfo's frequency
			 *  @type {Frequency}
			 *  @signal
			 */
	        this.frequency = this._oscillator.frequency;
	        /**
			 * The amplitude of the LFO, which controls the output range between
			 * the min and max output. For example if the min is -10 and the max
			 * is 10, setting the amplitude to 0.5 would make the LFO modulate
			 * between -5 and 5.
			 * @type {Number}
			 * @signal
			 */
	        this.amplitude = this._oscillator.volume;
	        this.amplitude.units = Tone.Type.NormalRange;
	        this.amplitude.value = options.amplitude;
	        /**
			 *  The signal which is output when the LFO is stopped
			 *  @type  {Tone.Signal}
			 *  @private
			 */
	        this._stoppedSignal = new Tone.Signal(0, Tone.Type.AudioRange);
	        /**
			 *  Just outputs zeros.
			 *  @type {Tone.Zero}
			 *  @private
			 */
	        this._zeros = new Tone.Zero();
	        /**
			 *  The value that the LFO outputs when it's stopped
			 *  @type {AudioRange}
			 *  @private
			 */
	        this._stoppedValue = 0;
	        /**
			 *  @type {Tone.AudioToGain}
			 *  @private
			 */
	        this._a2g = new Tone.AudioToGain();
	        /**
			 *  @type {Tone.Scale}
			 *  @private
			 */
	        this._scaler = this.output = new Tone.Scale(options.min, options.max);
	        /**
			 *  the units of the LFO (used for converting)
			 *  @type {Tone.Type}
			 *  @private
			 */
	        this._units = Tone.Type.Default;
	        this.units = options.units;
	        //connect it up
	        this._oscillator.chain(this._a2g, this._scaler);
	        this._zeros.connect(this._a2g);
	        this._stoppedSignal.connect(this._a2g);
	        this._readOnly([
	            'amplitude',
	            'frequency'
	        ]);
	        this.phase = options.phase;
	    };
	    Tone.extend(Tone.LFO, Tone.AudioNode);
	    /**
		 *  the default parameters
		 *
		 *  @static
		 *  @const
		 *  @type {Object}
		 */
	    Tone.LFO.defaults = {
	        'type': 'sine',
	        'min': 0,
	        'max': 1,
	        'phase': 0,
	        'frequency': '4n',
	        'amplitude': 1,
	        'units': Tone.Type.Default
	    };
	    /**
		 *  Start the LFO.
		 *  @param  {Time} [time=now] the time the LFO will start
		 *  @returns {Tone.LFO} this
		 */
	    Tone.LFO.prototype.start = function (time) {
	        time = this.toSeconds(time);
	        this._stoppedSignal.setValueAtTime(0, time);
	        this._oscillator.start(time);
	        return this;
	    };
	    /**
		 *  Stop the LFO.
		 *  @param  {Time} [time=now] the time the LFO will stop
		 *  @returns {Tone.LFO} this
		 */
	    Tone.LFO.prototype.stop = function (time) {
	        time = this.toSeconds(time);
	        this._stoppedSignal.setValueAtTime(this._stoppedValue, time);
	        this._oscillator.stop(time);
	        return this;
	    };
	    /**
		 *  Sync the start/stop/pause to the transport
		 *  and the frequency to the bpm of the transport
		 *  @returns {Tone.LFO} this
		 *  @example
		 *  lfo.frequency.value = "8n";
		 *  lfo.sync().start(0)
		 *  //the rate of the LFO will always be an eighth note,
		 *  //even as the tempo changes
		 */
	    Tone.LFO.prototype.sync = function () {
	        this._oscillator.sync();
	        this._oscillator.syncFrequency();
	        return this;
	    };
	    /**
		 *  unsync the LFO from transport control
		 *  @returns {Tone.LFO} this
		 */
	    Tone.LFO.prototype.unsync = function () {
	        this._oscillator.unsync();
	        this._oscillator.unsyncFrequency();
	        return this;
	    };
	    /**
		 * The miniumum output of the LFO.
		 * @memberOf Tone.LFO#
		 * @type {number}
		 * @name min
		 */
	    Object.defineProperty(Tone.LFO.prototype, 'min', {
	        get: function () {
	            return this._toUnits(this._scaler.min);
	        },
	        set: function (min) {
	            min = this._fromUnits(min);
	            this._scaler.min = min;
	        }
	    });
	    /**
		 * The maximum output of the LFO.
		 * @memberOf Tone.LFO#
		 * @type {number}
		 * @name max
		 */
	    Object.defineProperty(Tone.LFO.prototype, 'max', {
	        get: function () {
	            return this._toUnits(this._scaler.max);
	        },
	        set: function (max) {
	            max = this._fromUnits(max);
	            this._scaler.max = max;
	        }
	    });
	    /**
		 * The type of the oscillator: sine, square, sawtooth, triangle.
		 * @memberOf Tone.LFO#
		 * @type {string}
		 * @name type
		 */
	    Object.defineProperty(Tone.LFO.prototype, 'type', {
	        get: function () {
	            return this._oscillator.type;
	        },
	        set: function (type) {
	            this._oscillator.type = type;
	            this._stoppedValue = this._oscillator._getInitialValue();
	            this._stoppedSignal.value = this._stoppedValue;
	        }
	    });
	    /**
		 * The phase of the LFO.
		 * @memberOf Tone.LFO#
		 * @type {number}
		 * @name phase
		 */
	    Object.defineProperty(Tone.LFO.prototype, 'phase', {
	        get: function () {
	            return this._oscillator.phase;
	        },
	        set: function (phase) {
	            this._oscillator.phase = phase;
	            this._stoppedValue = this._oscillator._getInitialValue();
	            this._stoppedSignal.value = this._stoppedValue;
	        }
	    });
	    /**
		 * The output units of the LFO.
		 * @memberOf Tone.LFO#
		 * @type {Tone.Type}
		 * @name units
		 */
	    Object.defineProperty(Tone.LFO.prototype, 'units', {
	        get: function () {
	            return this._units;
	        },
	        set: function (val) {
	            var currentMin = this.min;
	            var currentMax = this.max;
	            //convert the min and the max
	            this._units = val;
	            this.min = currentMin;
	            this.max = currentMax;
	        }
	    });
	    /**
		 * Mute the output.
		 * @memberOf Tone.LFO#
		 * @type {Boolean}
		 * @name mute
		 */
	    Object.defineProperty(Tone.LFO.prototype, 'mute', {
	        get: function () {
	            return this._oscillator.mute;
	        },
	        set: function (mute) {
	            this._oscillator.mute = mute;
	        }
	    });
	    /**
		 *  Returns the playback state of the source, either "started" or "stopped".
		 *  @type {Tone.State}
		 *  @readOnly
		 *  @memberOf Tone.LFO#
		 *  @name state
		 */
	    Object.defineProperty(Tone.LFO.prototype, 'state', {
	        get: function () {
	            return this._oscillator.state;
	        }
	    });
	    /**
		 *  Connect the output of the LFO to an AudioParam, AudioNode, or Tone Node.
		 *  Tone.LFO will automatically convert to the destination units of the
		 *  will get the units from the connected node.
		 *  @param  {Tone | AudioParam | AudioNode} node
		 *  @param {number} [outputNum=0] optionally which output to connect from
		 *  @param {number} [inputNum=0] optionally which input to connect to
		 *  @returns {Tone.LFO} this
		 *  @private
		 */
	    Tone.LFO.prototype.connect = function (node) {
	        if (node.constructor === Tone.Signal || node.constructor === Tone.Param || node.constructor === Tone.TimelineSignal) {
	            this.convert = node.convert;
	            this.units = node.units;
	        }
	        Tone.Signal.prototype.connect.apply(this, arguments);
	        return this;
	    };
	    /**
		 *  private method borrowed from Param converts
		 *  units from their destination value
		 *  @function
		 *  @private
		 */
	    Tone.LFO.prototype._fromUnits = Tone.Param.prototype._fromUnits;
	    /**
		 *  private method borrowed from Param converts
		 *  units to their destination value
		 *  @function
		 *  @private
		 */
	    Tone.LFO.prototype._toUnits = Tone.Param.prototype._toUnits;
	    /**
		 *  disconnect and dispose
		 *  @returns {Tone.LFO} this
		 */
	    Tone.LFO.prototype.dispose = function () {
	        Tone.AudioNode.prototype.dispose.call(this);
	        this._writable([
	            'amplitude',
	            'frequency'
	        ]);
	        this._oscillator.dispose();
	        this._oscillator = null;
	        this._stoppedSignal.dispose();
	        this._stoppedSignal = null;
	        this._zeros.dispose();
	        this._zeros = null;
	        this._scaler.dispose();
	        this._scaler = null;
	        this._a2g.dispose();
	        this._a2g = null;
	        this.frequency = null;
	        this.amplitude = null;
	        return this;
	    };
	    return Tone.LFO;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Tone.Limiter will limit the loudness of an incoming signal.
		 *         It is composed of a Tone.Compressor with a fast attack
		 *         and release. Limiters are commonly used to safeguard against
		 *         signal clipping. Unlike a compressor, limiters do not provide
		 *         smooth gain reduction and almost completely prevent
		 *         additional gain above the threshold.
		 *
		 *  @extends {Tone.AudioNode}
		 *  @constructor
		 *  @param {number} threshold The theshold above which the limiting is applied.
		 *  @example
		 *  var limiter = new Tone.Limiter(-6);
		 */
	    Tone.Limiter = function () {
	        var options = Tone.defaults(arguments, ['threshold'], Tone.Limiter);
	        Tone.AudioNode.call(this);
	        /**
			 *  the compressor
			 *  @private
			 *  @type {Tone.Compressor}
			 */
	        this._compressor = this.input = this.output = new Tone.Compressor({
	            'attack': 0.001,
	            'decay': 0.001,
	            'threshold': options.threshold
	        });
	        /**
			 * The threshold of of the limiter
			 * @type {Decibel}
			 * @signal
			 */
	        this.threshold = this._compressor.threshold;
	        this._readOnly('threshold');
	    };
	    Tone.extend(Tone.Limiter, Tone.AudioNode);
	    /**
		 *  The default value
		 *  @type {Object}
		 *  @const
		 *  @static
		 */
	    Tone.Limiter.defaults = { 'threshold': -12 };
	    /**
		 *  Clean up.
		 *  @returns {Tone.Limiter} this
		 */
	    Tone.Limiter.prototype.dispose = function () {
	        Tone.AudioNode.prototype.dispose.call(this);
	        this._compressor.dispose();
	        this._compressor = null;
	        this._writable('threshold');
	        this.threshold = null;
	        return this;
	    };
	    return Tone.Limiter;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Tone.Lowpass is a lowpass feedback comb filter. It is similar to
		 *         Tone.FeedbackCombFilter, but includes a lowpass filter.
		 *
		 *  @extends {Tone.AudioNode}
		 *  @constructor
		 *  @param {Time|Object} [delayTime] The delay time of the comb filter
		 *  @param {NormalRange=} resonance The resonance (feedback) of the comb filter
		 *  @param {Frequency=} dampening The cutoff of the lowpass filter dampens the
		 *                                signal as it is fedback.
		 */
	    Tone.LowpassCombFilter = function () {
	        var options = Tone.defaults(arguments, [
	            'delayTime',
	            'resonance',
	            'dampening'
	        ], Tone.LowpassCombFilter);
	        Tone.AudioNode.call(this);
	        this.createInsOuts(1, 1);
	        /**
			 *  the delay node
			 *  @type {DelayNode}
			 *  @private
			 */
	        this._delay = this.input = new Tone.Delay(options.delayTime);
	        /**
			 *  The delayTime of the comb filter.
			 *  @type {Time}
			 *  @signal
			 */
	        this.delayTime = this._delay.delayTime;
	        /**
			 *  the lowpass filter
			 *  @type  {BiquadFilterNode}
			 *  @private
			 */
	        this._lowpass = this.output = this.context.createBiquadFilter();
	        this._lowpass.Q.value = -3.0102999566398125;
	        this._lowpass.type = 'lowpass';
	        /**
			 *  The dampening control of the feedback
			 *  @type {Frequency}
			 *  @signal
			 */
	        this.dampening = new Tone.Param({
	            'param': this._lowpass.frequency,
	            'units': Tone.Type.Frequency,
	            'value': options.dampening
	        });
	        /**
			 *  the feedback gain
			 *  @type {Tone.Gain}
			 *  @private
			 */
	        this._feedback = new Tone.Gain(options.resonance, Tone.Type.NormalRange);
	        /**
			 *  The amount of feedback of the delayed signal.
			 *  @type {NormalRange}
			 *  @signal
			 */
	        this.resonance = this._feedback.gain;
	        //connections
	        this._delay.chain(this._lowpass, this._feedback, this._delay);
	        this._readOnly([
	            'dampening',
	            'resonance',
	            'delayTime'
	        ]);
	    };
	    Tone.extend(Tone.LowpassCombFilter, Tone.AudioNode);
	    /**
		 *  the default parameters
		 *  @static
		 *  @const
		 *  @type {Object}
		 */
	    Tone.LowpassCombFilter.defaults = {
	        'delayTime': 0.1,
	        'resonance': 0.5,
	        'dampening': 3000
	    };
	    /**
		 *  Clean up.
		 *  @returns {Tone.LowpassCombFilter} this
		 */
	    Tone.LowpassCombFilter.prototype.dispose = function () {
	        Tone.AudioNode.prototype.dispose.call(this);
	        this._writable([
	            'dampening',
	            'resonance',
	            'delayTime'
	        ]);
	        this.dampening.dispose();
	        this.dampening = null;
	        this.resonance.dispose();
	        this.resonance = null;
	        this._delay.dispose();
	        this._delay = null;
	        this.delayTime = null;
	        this._lowpass.disconnect();
	        this._lowpass = null;
	        this._feedback.disconnect();
	        this._feedback = null;
	        return this;
	    };
	    return Tone.LowpassCombFilter;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class  Tone.Merge brings two signals into the left and right
		 *          channels of a single stereo channel.
		 *
		 *  @constructor
		 *  @extends {Tone.AudioNode}
		 *  @example
		 * var merge = new Tone.Merge().toMaster();
		 * //routing a sine tone in the left channel
		 * //and noise in the right channel
		 * var osc = new Tone.Oscillator().connect(merge.left);
		 * var noise = new Tone.Noise().connect(merge.right);
		 * //starting our oscillators
		 * noise.start();
		 * osc.start();
		 */
	    Tone.Merge = function () {
	        Tone.AudioNode.call(this);
	        this.createInsOuts(2, 0);
	        /**
			 *  The left input channel.
			 *  Alias for <code>input[0]</code>
			 *  @type {GainNode}
			 */
	        this.left = this.input[0] = new Tone.Gain();
	        /**
			 *  The right input channel.
			 *  Alias for <code>input[1]</code>.
			 *  @type {GainNode}
			 */
	        this.right = this.input[1] = new Tone.Gain();
	        /**
			 *  the merger node for the two channels
			 *  @type {ChannelMergerNode}
			 *  @private
			 */
	        this._merger = this.output = this.context.createChannelMerger(2);
	        //connections
	        this.left.connect(this._merger, 0, 0);
	        this.right.connect(this._merger, 0, 1);
	        this.left.channelCount = 1;
	        this.right.channelCount = 1;
	        this.left.channelCountMode = 'explicit';
	        this.right.channelCountMode = 'explicit';
	    };
	    Tone.extend(Tone.Merge, Tone.AudioNode);
	    /**
		 *  Clean up.
		 *  @returns {Tone.Merge} this
		 */
	    Tone.Merge.prototype.dispose = function () {
	        Tone.AudioNode.prototype.dispose.call(this);
	        this.left.dispose();
	        this.left = null;
	        this.right.dispose();
	        this.right = null;
	        this._merger.disconnect();
	        this._merger = null;
	        return this;
	    };
	    return Tone.Merge;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class  Tone.Meter gets the [RMS](https://en.wikipedia.org/wiki/Root_mean_square)
		 *          of an input signal with some averaging applied. It can also get the raw
		 *          value of the input signal.
		 *
		 *  @constructor
		 *  @extends {Tone.AudioNode}
		 *  @param {String} type Either "level" or "signal".
		 *  @param {Number} smoothing The amount of smoothing applied between frames.
		 *  @example
		 * var meter = new Tone.Meter();
		 * var mic = new Tone.UserMedia().open();
		 * //connect mic to the meter
		 * mic.connect(meter);
		 * //the current level of the mic input
		 * var level = meter.value;
		 */
	    Tone.Meter = function () {
	        var options = Tone.defaults(arguments, [
	            'type',
	            'smoothing'
	        ], Tone.Meter);
	        Tone.AudioNode.call(this);
	        /**
			 *  The type of the meter, either "level" or "signal".
			 *  A "level" meter will return the volume level (rms) of the
			 *  input signal and a "signal" meter will return
			 *  the signal value of the input.
			 *  @type  {String}
			 */
	        this.type = options.type;
	        /**
			 *  The analyser node which computes the levels.
			 *  @private
			 *  @type  {Tone.Analyser}
			 */
	        this.input = this.output = this._analyser = new Tone.Analyser('waveform', 512);
	        /**
			 *  The amount of carryover between the current and last frame.
			 *  Only applied meter for "level" type.
			 *  @type  {Number}
			 */
	        this.smoothing = options.smoothing;
	        /**
			 *  The last computed value
			 *  @type {Number}
			 *  @private
			 */
	        this._lastValue = 0;
	    };
	    Tone.extend(Tone.Meter, Tone.AudioNode);
	    /**
		 *  @private
		 *  @enum {String}
		 */
	    Tone.Meter.Type = {
	        Level: 'level',
	        Signal: 'signal'
	    };
	    /**
		 *  The defaults
		 *  @type {Object}
		 *  @static
		 *  @const
		 */
	    Tone.Meter.defaults = {
	        'smoothing': 0.8,
	        'type': Tone.Meter.Type.Level
	    };
	    /**
		 * The current value of the meter. A value of 1 is
		 * "unity".
		 * @memberOf Tone.Meter#
		 * @type {Number}
		 * @name value
		 * @readOnly
		 */
	    Object.defineProperty(Tone.Meter.prototype, 'value', {
	        get: function () {
	            var signal = this._analyser.analyse();
	            if (this.type === Tone.Meter.Type.Level) {
	                //rms
	                var sum = 0;
	                for (var i = 0; i < signal.length; i++) {
	                    sum += Math.pow(signal[i], 2);
	                }
	                var rms = Math.sqrt(sum / signal.length);
	                //smooth it
	                rms = Math.max(rms, this._lastValue * this.smoothing);
	                this._lastValue = rms;
	                //scale it
	                var unity = 0.35;
	                var val = rms / unity;
	                //scale the output curve
	                return Math.sqrt(val);
	            } else {
	                return signal[0];
	            }
	        }
	    });
	    /**
		 *  Clean up.
		 *  @returns {Tone.Meter} this
		 */
	    Tone.Meter.prototype.dispose = function () {
	        Tone.AudioNode.prototype.dispose.call(this);
	        this._analyser.dispose();
	        this._analyser = null;
	        return this;
	    };
	    return Tone.Meter;
	});
	Module(function (Tone) {
	    
	    /**
		 *	@class  Tone.Split splits an incoming signal into left and right channels.
		 *
		 *  @constructor
		 *  @extends {Tone.AudioNode}
		 *  @example
		 * var split = new Tone.Split();
		 * stereoSignal.connect(split);
		 */
	    Tone.Split = function () {
	        Tone.AudioNode.call(this);
	        this.createInsOuts(0, 2);
	        /**
			 *  @type {ChannelSplitterNode}
			 *  @private
			 */
	        this._splitter = this.input = this.context.createChannelSplitter(2);
	        this._splitter.channelCount = 2;
	        this._splitter.channelCountMode = 'explicit';
	        /**
			 *  Left channel output.
			 *  Alias for <code>output[0]</code>
			 *  @type {Tone.Gain}
			 */
	        this.left = this.output[0] = new Tone.Gain();
	        /**
			 *  Right channel output.
			 *  Alias for <code>output[1]</code>
			 *  @type {Tone.Gain}
			 */
	        this.right = this.output[1] = new Tone.Gain();
	        //connections
	        this._splitter.connect(this.left, 0, 0);
	        this._splitter.connect(this.right, 1, 0);
	    };
	    Tone.extend(Tone.Split, Tone.AudioNode);
	    /**
		 *  Clean up.
		 *  @returns {Tone.Split} this
		 */
	    Tone.Split.prototype.dispose = function () {
	        Tone.AudioNode.prototype.dispose.call(this);
	        this._splitter.disconnect();
	        this.left.dispose();
	        this.left = null;
	        this.right.dispose();
	        this.right = null;
	        this._splitter = null;
	        return this;
	    };
	    return Tone.Split;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Mid/Side processing separates the the 'mid' signal
		 *         (which comes out of both the left and the right channel)
		 *         and the 'side' (which only comes out of the the side channels). <br><br>
		 *         <code>
		 *         Mid = (Left+Right)/sqrt(2);   // obtain mid-signal from left and right<br>
		 *         Side = (Left-Right)/sqrt(2);   // obtain side-signal from left and righ<br>
		 *         </code>
		 *
		 *  @extends {Tone.AudioNode}
		 *  @constructor
		 */
	    Tone.MidSideSplit = function () {
	        Tone.AudioNode.call(this);
	        this.createInsOuts(0, 2);
	        /**
			 *  split the incoming signal into left and right channels
			 *  @type  {Tone.Split}
			 *  @private
			 */
	        this._split = this.input = new Tone.Split();
	        /**
			 *  The mid send. Connect to mid processing. Alias for
			 *  <code>output[0]</code>
			 *  @type {Tone.Expr}
			 */
	        this.mid = this.output[0] = new Tone.Expr('($0 + $1) * $2');
	        /**
			 *  The side output. Connect to side processing. Alias for
			 *  <code>output[1]</code>
			 *  @type {Tone.Expr}
			 */
	        this.side = this.output[1] = new Tone.Expr('($0 - $1) * $2');
	        this._split.connect(this.mid, 0, 0);
	        this._split.connect(this.mid, 1, 1);
	        this._split.connect(this.side, 0, 0);
	        this._split.connect(this.side, 1, 1);
	        this.context.getConstant(Math.SQRT1_2).connect(this.mid, 0, 2);
	        this.context.getConstant(Math.SQRT1_2).connect(this.side, 0, 2);
	    };
	    Tone.extend(Tone.MidSideSplit, Tone.AudioNode);
	    /**
		 *  clean up
		 *  @returns {Tone.MidSideSplit} this
		 */
	    Tone.MidSideSplit.prototype.dispose = function () {
	        Tone.AudioNode.prototype.dispose.call(this);
	        this.mid.dispose();
	        this.mid = null;
	        this.side.dispose();
	        this.side = null;
	        this._split.dispose();
	        this._split = null;
	        return this;
	    };
	    return Tone.MidSideSplit;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Mid/Side processing separates the the 'mid' signal
		 *         (which comes out of both the left and the right channel)
		 *         and the 'side' (which only comes out of the the side channels).
		 *         MidSideMerge merges the mid and side signal after they've been seperated
		 *         by Tone.MidSideSplit.<br><br>
		 *         <code>
		 *         Left = (Mid+Side)/sqrt(2);   // obtain left signal from mid and side<br>
		 *         Right = (Mid-Side)/sqrt(2);   // obtain right signal from mid and side<br>
		 *         </code>
		 *
		 *  @extends {Tone.AudioNode}
		 *  @constructor
		 */
	    Tone.MidSideMerge = function () {
	        Tone.AudioNode.call(this);
	        this.createInsOuts(2, 0);
	        /**
			 *  The mid signal input. Alias for
			 *  <code>input[0]</code>
			 *  @type  {Tone.Gain}
			 */
	        this.mid = this.input[0] = new Tone.Gain();
	        /**
			 *  recombine the mid/side into Left
			 *  @type {Tone.Expr}
			 *  @private
			 */
	        this._left = new Tone.Expr('($0 + $1) * $2');
	        /**
			 *  The side signal input. Alias for
			 *  <code>input[1]</code>
			 *  @type  {Tone.Gain}
			 */
	        this.side = this.input[1] = new Tone.Gain();
	        /**
			 *  recombine the mid/side into Right
			 *  @type {Tone.Expr}
			 *  @private
			 */
	        this._right = new Tone.Expr('($0 - $1) * $2');
	        /**
			 *  Merge the left/right signal back into a stereo signal.
			 *  @type {Tone.Merge}
			 *  @private
			 */
	        this._merge = this.output = new Tone.Merge();
	        this.mid.connect(this._left, 0, 0);
	        this.side.connect(this._left, 0, 1);
	        this.mid.connect(this._right, 0, 0);
	        this.side.connect(this._right, 0, 1);
	        this._left.connect(this._merge, 0, 0);
	        this._right.connect(this._merge, 0, 1);
	        this.context.getConstant(Math.SQRT1_2).connect(this._left, 0, 2);
	        this.context.getConstant(Math.SQRT1_2).connect(this._right, 0, 2);
	    };
	    Tone.extend(Tone.MidSideMerge, Tone.AudioNode);
	    /**
		 *  clean up
		 *  @returns {Tone.MidSideMerge} this
		 */
	    Tone.MidSideMerge.prototype.dispose = function () {
	        Tone.AudioNode.prototype.dispose.call(this);
	        this.mid.dispose();
	        this.mid = null;
	        this.side.dispose();
	        this.side = null;
	        this._left.dispose();
	        this._left = null;
	        this._right.dispose();
	        this._right = null;
	        this._merge.dispose();
	        this._merge = null;
	        return this;
	    };
	    return Tone.MidSideMerge;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Tone.MidSideCompressor applies two different compressors to the mid
		 *         and side signal components. See Tone.MidSideSplit.
		 *
		 *  @extends {Tone.AudioNode}
		 *  @param {Object} options The options that are passed to the mid and side
		 *                          compressors.
		 *  @constructor
		 */
	    Tone.MidSideCompressor = function (options) {
	        Tone.AudioNode.call(this);
	        options = Tone.defaultArg(options, Tone.MidSideCompressor.defaults);
	        /**
			 *  the mid/side split
			 *  @type  {Tone.MidSideSplit}
			 *  @private
			 */
	        this._midSideSplit = this.input = new Tone.MidSideSplit();
	        /**
			 *  the mid/side recombination
			 *  @type  {Tone.MidSideMerge}
			 *  @private
			 */
	        this._midSideMerge = this.output = new Tone.MidSideMerge();
	        /**
			 *  The compressor applied to the mid signal
			 *  @type  {Tone.Compressor}
			 */
	        this.mid = new Tone.Compressor(options.mid);
	        /**
			 *  The compressor applied to the side signal
			 *  @type  {Tone.Compressor}
			 */
	        this.side = new Tone.Compressor(options.side);
	        this._midSideSplit.mid.chain(this.mid, this._midSideMerge.mid);
	        this._midSideSplit.side.chain(this.side, this._midSideMerge.side);
	        this._readOnly([
	            'mid',
	            'side'
	        ]);
	    };
	    Tone.extend(Tone.MidSideCompressor, Tone.AudioNode);
	    /**
		 *  @const
		 *  @static
		 *  @type {Object}
		 */
	    Tone.MidSideCompressor.defaults = {
	        'mid': {
	            'ratio': 3,
	            'threshold': -24,
	            'release': 0.03,
	            'attack': 0.02,
	            'knee': 16
	        },
	        'side': {
	            'ratio': 6,
	            'threshold': -30,
	            'release': 0.25,
	            'attack': 0.03,
	            'knee': 10
	        }
	    };
	    /**
		 *  Clean up.
		 *  @returns {Tone.MidSideCompressor} this
		 */
	    Tone.MidSideCompressor.prototype.dispose = function () {
	        Tone.AudioNode.prototype.dispose.call(this);
	        this._writable([
	            'mid',
	            'side'
	        ]);
	        this.mid.dispose();
	        this.mid = null;
	        this.side.dispose();
	        this.side = null;
	        this._midSideSplit.dispose();
	        this._midSideSplit = null;
	        this._midSideMerge.dispose();
	        this._midSideMerge = null;
	        return this;
	    };
	    return Tone.MidSideCompressor;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Tone.Mono coerces the incoming mono or stereo signal into a mono signal
		 *         where both left and right channels have the same value. This can be useful
		 *         for [stereo imaging](https://en.wikipedia.org/wiki/Stereo_imaging).
		 *
		 *  @extends {Tone.AudioNode}
		 *  @constructor
		 */
	    Tone.Mono = function () {
	        Tone.AudioNode.call(this);
	        this.createInsOuts(1, 0);
	        /**
			 *  merge the signal
			 *  @type {Tone.Merge}
			 *  @private
			 */
	        this._merge = this.output = new Tone.Merge();
	        this.input.connect(this._merge, 0, 0);
	        this.input.connect(this._merge, 0, 1);
	        this.input.gain.value = Tone.dbToGain(-10);
	    };
	    Tone.extend(Tone.Mono);
	    /**
		 *  clean up
		 *  @returns {Tone.Mono} this
		 */
	    Tone.Mono.prototype.dispose = function () {
	        Tone.AudioNode.prototype.dispose.call(this);
	        this._merge.dispose();
	        this._merge = null;
	        return this;
	    };
	    return Tone.Mono;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class A compressor with seperate controls over low/mid/high dynamics
		 *
		 *  @extends {Tone.AudioNode}
		 *  @constructor
		 *  @param {Object} options The low/mid/high compressor settings.
		 *  @example
		 *  var multiband = new Tone.MultibandCompressor({
		 *  	"lowFrequency" : 200,
		 *  	"highFrequency" : 1300
		 *  	"low" : {
		 *  		"threshold" : -12
		 *  	}
		 *  })
		 */
	    Tone.MultibandCompressor = function (options) {
	        Tone.AudioNode.call(this);
	        options = Tone.defaultArg(arguments, Tone.MultibandCompressor.defaults);
	        /**
			 *  split the incoming signal into high/mid/low
			 *  @type {Tone.MultibandSplit}
			 *  @private
			 */
	        this._splitter = this.input = new Tone.MultibandSplit({
	            'lowFrequency': options.lowFrequency,
	            'highFrequency': options.highFrequency
	        });
	        /**
			 *  low/mid crossover frequency.
			 *  @type {Frequency}
			 *  @signal
			 */
	        this.lowFrequency = this._splitter.lowFrequency;
	        /**
			 *  mid/high crossover frequency.
			 *  @type {Frequency}
			 *  @signal
			 */
	        this.highFrequency = this._splitter.highFrequency;
	        /**
			 *  the output
			 *  @type {Tone.Gain}
			 *  @private
			 */
	        this.output = new Tone.Gain();
	        /**
			 *  The compressor applied to the low frequencies.
			 *  @type {Tone.Compressor}
			 */
	        this.low = new Tone.Compressor(options.low);
	        /**
			 *  The compressor applied to the mid frequencies.
			 *  @type {Tone.Compressor}
			 */
	        this.mid = new Tone.Compressor(options.mid);
	        /**
			 *  The compressor applied to the high frequencies.
			 *  @type {Tone.Compressor}
			 */
	        this.high = new Tone.Compressor(options.high);
	        //connect the compressor
	        this._splitter.low.chain(this.low, this.output);
	        this._splitter.mid.chain(this.mid, this.output);
	        this._splitter.high.chain(this.high, this.output);
	        this._readOnly([
	            'high',
	            'mid',
	            'low',
	            'highFrequency',
	            'lowFrequency'
	        ]);
	    };
	    Tone.extend(Tone.MultibandCompressor, Tone.AudioNode);
	    /**
		 *  @const
		 *  @static
		 *  @type {Object}
		 */
	    Tone.MultibandCompressor.defaults = {
	        'low': Tone.Compressor.defaults,
	        'mid': Tone.Compressor.defaults,
	        'high': Tone.Compressor.defaults,
	        'lowFrequency': 250,
	        'highFrequency': 2000
	    };
	    /**
		 *  clean up
		 *  @returns {Tone.MultibandCompressor} this
		 */
	    Tone.MultibandCompressor.prototype.dispose = function () {
	        Tone.AudioNode.prototype.dispose.call(this);
	        this._splitter.dispose();
	        this._writable([
	            'high',
	            'mid',
	            'low',
	            'highFrequency',
	            'lowFrequency'
	        ]);
	        this.low.dispose();
	        this.mid.dispose();
	        this.high.dispose();
	        this._splitter = null;
	        this.low = null;
	        this.mid = null;
	        this.high = null;
	        this.lowFrequency = null;
	        this.highFrequency = null;
	        return this;
	    };
	    return Tone.MultibandCompressor;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class  Tone.Panner is an equal power Left/Right Panner and does not
		 *          support 3D. Panner uses the StereoPannerNode when available.
		 *
		 *  @constructor
		 *  @extends {Tone.AudioNode}
		 *  @param {NormalRange} [initialPan=0] The initail panner value (center).
		 *  @example
		 *  //pan the input signal hard right.
		 *  var panner = new Tone.Panner(1);
		 */
	    Tone.Panner = function (initialPan) {
	        Tone.AudioNode.call(this);
	        if (Tone.Panner.hasStereoPanner) {
	            /**
				 *  the panner node
				 *  @type {StereoPannerNode}
				 *  @private
				 */
	            this._panner = this.input = this.output = this.context.createStereoPanner();
	            /**
				 *  The pan control. -1 = hard left, 1 = hard right.
				 *  @type {NormalRange}
				 *  @signal
				 */
	            this.pan = this._panner.pan;
	        } else {
	            /**
				 *  the dry/wet knob
				 *  @type {Tone.CrossFade}
				 *  @private
				 */
	            this._crossFade = new Tone.CrossFade();
	            /**
				 *  @type {Tone.Merge}
				 *  @private
				 */
	            this._merger = this.output = new Tone.Merge();
	            /**
				 *  @type {Tone.Split}
				 *  @private
				 */
	            this._splitter = this.input = new Tone.Split();
	            /**
				 *  The pan control. -1 = hard left, 1 = hard right.
				 *  @type {AudioRange}
				 *  @signal
				 */
	            this.pan = new Tone.Signal(0, Tone.Type.AudioRange);
	            /**
				 *  always sends 0
				 *  @type {Tone.Zero}
				 *  @private
				 */
	            this._zero = new Tone.Zero();
	            /**
				 *  The analog to gain conversion
				 *  @type  {Tone.AudioToGain}
				 *  @private
				 */
	            this._a2g = new Tone.AudioToGain();
	            //CONNECTIONS:
	            this._zero.connect(this._a2g);
	            this.pan.chain(this._a2g, this._crossFade.fade);
	            //left channel is a, right channel is b
	            this._splitter.connect(this._crossFade, 0, 0);
	            this._splitter.connect(this._crossFade, 1, 1);
	            //merge it back together
	            this._crossFade.a.connect(this._merger, 0, 0);
	            this._crossFade.b.connect(this._merger, 0, 1);
	        }
	        //initial value
	        this.pan.value = Tone.defaultArg(initialPan, 0);
	        this._readOnly('pan');
	    };
	    Tone.extend(Tone.Panner, Tone.AudioNode);
	    /**
		 *  Indicates if the panner is using the new StereoPannerNode internally
		 *  @type  {Boolean}
		 *  @static
		 *  @private
		 *  @readOnly
		 */
	    Tone.Panner.hasStereoPanner = Tone.context && Tone.isFunction(Tone.context.createStereoPanner);
	    /**
		 *  Clean up.
		 *  @returns {Tone.Panner} this
		 */
	    Tone.Panner.prototype.dispose = function () {
	        Tone.AudioNode.prototype.dispose.call(this);
	        this._writable('pan');
	        if (Tone.Panner.hasStereoPanner) {
	            this._panner.disconnect();
	            this._panner = null;
	            this.pan = null;
	        } else {
	            this._zero.dispose();
	            this._zero = null;
	            this._crossFade.dispose();
	            this._crossFade = null;
	            this._splitter.dispose();
	            this._splitter = null;
	            this._merger.dispose();
	            this._merger = null;
	            this.pan.dispose();
	            this.pan = null;
	            this._a2g.dispose();
	            this._a2g = null;
	        }
	        return this;
	    };
	    return Tone.Panner;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class  A spatialized panner node which supports equalpower or HRTF panning.
		 *          Tries to normalize the API across various browsers. See Tone.Listener
		 *
		 *  @constructor
		 *  @extends {Tone.AudioNode}
		 *  @param {Number} positionX The initial x position.
		 *  @param {Number} positionY The initial y position.
		 *  @param {Number} positionZ The initial z position.
		 */
	    Tone.Panner3D = function () {
	        var options = Tone.defaults(arguments, [
	            'positionX',
	            'positionY',
	            'positionZ'
	        ], Tone.Panner3D);
	        Tone.AudioNode.call(this);
	        /**
			 *  The panner node
			 *  @type {PannerNode}
			 *  @private
			 */
	        this._panner = this.input = this.output = this.context.createPanner();
	        //set some values
	        this._panner.panningModel = options.panningModel;
	        this._panner.maxDistance = options.maxDistance;
	        this._panner.distanceModel = options.distanceModel;
	        this._panner.coneOuterGain = options.coneOuterGain;
	        this._panner.coneOuterAngle = options.coneOuterAngle;
	        this._panner.coneInnerAngle = options.coneInnerAngle;
	        this._panner.refDistance = options.refDistance;
	        this._panner.rolloffFactor = options.rolloffFactor;
	        /**
			 *  Holds the current orientation
			 *  @type  {Array}
			 *  @private
			 */
	        this._orientation = [
	            options.orientationX,
	            options.orientationY,
	            options.orientationZ
	        ];
	        /**
			 *  Holds the current position
			 *  @type  {Array}
			 *  @private
			 */
	        this._position = [
	            options.positionX,
	            options.positionY,
	            options.positionZ
	        ];
	        // set the default position/orientation
	        this.orientationX = options.orientationX;
	        this.orientationY = options.orientationY;
	        this.orientationZ = options.orientationZ;
	        this.positionX = options.positionX;
	        this.positionY = options.positionY;
	        this.positionZ = options.positionZ;
	    };
	    Tone.extend(Tone.Panner3D, Tone.AudioNode);
	    /**
		 *  Defaults according to the specification
		 *  @static
		 *  @const
		 *  @type {Object}
		 */
	    Tone.Panner3D.defaults = {
	        'positionX': 0,
	        'positionY': 0,
	        'positionZ': 0,
	        'orientationX': 0,
	        'orientationY': 0,
	        'orientationZ': 0,
	        'panningModel': 'equalpower',
	        'maxDistance': 10000,
	        'distanceModel': 'inverse',
	        'coneOuterGain': 0,
	        'coneOuterAngle': 360,
	        'coneInnerAngle': 360,
	        'refDistance': 1,
	        'rolloffFactor': 1
	    };
	    /**
		 * The ramp time which is applied to the setTargetAtTime
		 * @type {Number}
		 * @private
		 */
	    Tone.Panner3D.prototype._rampTimeConstant = 0.01;
	    /**
		 *  Sets the position of the source in 3d space.
		 *  @param  {Number}  x
		 *  @param  {Number}  y
		 *  @param  {Number}  z
		 *  @return {Tone.Panner3D} this
		 */
	    Tone.Panner3D.prototype.setPosition = function (x, y, z) {
	        if (this._panner.positionX) {
	            var now = this.now();
	            this._panner.positionX.setTargetAtTime(x, now, this._rampTimeConstant);
	            this._panner.positionY.setTargetAtTime(y, now, this._rampTimeConstant);
	            this._panner.positionZ.setTargetAtTime(z, now, this._rampTimeConstant);
	        } else {
	            this._panner.setPosition(x, y, z);
	        }
	        this._position = Array.prototype.slice.call(arguments);
	        return this;
	    };
	    /**
		 *  Sets the orientation of the source in 3d space.
		 *  @param  {Number}  x
		 *  @param  {Number}  y
		 *  @param  {Number}  z
		 *  @return {Tone.Panner3D} this
		 */
	    Tone.Panner3D.prototype.setOrientation = function (x, y, z) {
	        if (this._panner.orientationX) {
	            var now = this.now();
	            this._panner.orientationX.setTargetAtTime(x, now, this._rampTimeConstant);
	            this._panner.orientationY.setTargetAtTime(y, now, this._rampTimeConstant);
	            this._panner.orientationZ.setTargetAtTime(z, now, this._rampTimeConstant);
	        } else {
	            this._panner.setOrientation(x, y, z);
	        }
	        this._orientation = Array.prototype.slice.call(arguments);
	        return this;
	    };
	    /**
		 *  The x position of the panner object.
		 *  @type {Number}
		 *  @memberOf Tone.Panner3D#
		 *  @name positionX
		 */
	    Object.defineProperty(Tone.Panner3D.prototype, 'positionX', {
	        set: function (pos) {
	            this._position[0] = pos;
	            this.setPosition.apply(this, this._position);
	        },
	        get: function () {
	            return this._position[0];
	        }
	    });
	    /**
		 *  The y position of the panner object.
		 *  @type {Number}
		 *  @memberOf Tone.Panner3D#
		 *  @name positionY
		 */
	    Object.defineProperty(Tone.Panner3D.prototype, 'positionY', {
	        set: function (pos) {
	            this._position[1] = pos;
	            this.setPosition.apply(this, this._position);
	        },
	        get: function () {
	            return this._position[1];
	        }
	    });
	    /**
		 *  The z position of the panner object.
		 *  @type {Number}
		 *  @memberOf Tone.Panner3D#
		 *  @name positionZ
		 */
	    Object.defineProperty(Tone.Panner3D.prototype, 'positionZ', {
	        set: function (pos) {
	            this._position[2] = pos;
	            this.setPosition.apply(this, this._position);
	        },
	        get: function () {
	            return this._position[2];
	        }
	    });
	    /**
		 *  The x orientation of the panner object.
		 *  @type {Number}
		 *  @memberOf Tone.Panner3D#
		 *  @name orientationX
		 */
	    Object.defineProperty(Tone.Panner3D.prototype, 'orientationX', {
	        set: function (pos) {
	            this._orientation[0] = pos;
	            this.setOrientation.apply(this, this._orientation);
	        },
	        get: function () {
	            return this._orientation[0];
	        }
	    });
	    /**
		 *  The y orientation of the panner object.
		 *  @type {Number}
		 *  @memberOf Tone.Panner3D#
		 *  @name orientationY
		 */
	    Object.defineProperty(Tone.Panner3D.prototype, 'orientationY', {
	        set: function (pos) {
	            this._orientation[1] = pos;
	            this.setOrientation.apply(this, this._orientation);
	        },
	        get: function () {
	            return this._orientation[1];
	        }
	    });
	    /**
		 *  The z orientation of the panner object.
		 *  @type {Number}
		 *  @memberOf Tone.Panner3D#
		 *  @name orientationZ
		 */
	    Object.defineProperty(Tone.Panner3D.prototype, 'orientationZ', {
	        set: function (pos) {
	            this._orientation[2] = pos;
	            this.setOrientation.apply(this, this._orientation);
	        },
	        get: function () {
	            return this._orientation[2];
	        }
	    });
	    /**
		 *  Proxy a property on the panner to an exposed public propery
		 *  @param  {String}  prop
		 *  @private
		 */
	    Tone.Panner3D._aliasProperty = function (prop) {
	        Object.defineProperty(Tone.Panner3D.prototype, prop, {
	            set: function (val) {
	                this._panner[prop] = val;
	            },
	            get: function () {
	                return this._panner[prop];
	            }
	        });
	    };
	    /**
		 *  The panning model. Either "equalpower" or "HRTF".
		 *  @type {String}
		 *  @memberOf Tone.Panner3D#
		 *  @name panningModel
		 */
	    Tone.Panner3D._aliasProperty('panningModel');
	    /**
		 *  A reference distance for reducing volume as source move further from the listener
		 *  @type {Number}
		 *  @memberOf Tone.Panner3D#
		 *  @name refDistance
		 */
	    Tone.Panner3D._aliasProperty('refDistance');
	    /**
		 *  Describes how quickly the volume is reduced as source moves away from listener.
		 *  @type {Number}
		 *  @memberOf Tone.Panner3D#
		 *  @name rolloffFactor
		 */
	    Tone.Panner3D._aliasProperty('rolloffFactor');
	    /**
		 *  The distance model used by,  "linear", "inverse", or "exponential".
		 *  @type {String}
		 *  @memberOf Tone.Panner3D#
		 *  @name distanceModel
		 */
	    Tone.Panner3D._aliasProperty('distanceModel');
	    /**
		 *  The angle, in degrees, inside of which there will be no volume reduction
		 *  @type {Degrees}
		 *  @memberOf Tone.Panner3D#
		 *  @name coneInnerAngle
		 */
	    Tone.Panner3D._aliasProperty('coneInnerAngle');
	    /**
		 *  The angle, in degrees, outside of which the volume will be reduced
		 *  to a constant value of coneOuterGain
		 *  @type {Degrees}
		 *  @memberOf Tone.Panner3D#
		 *  @name coneOuterAngle
		 */
	    Tone.Panner3D._aliasProperty('coneOuterAngle');
	    /**
		 *  The gain outside of the coneOuterAngle
		 *  @type {Gain}
		 *  @memberOf Tone.Panner3D#
		 *  @name coneOuterGain
		 */
	    Tone.Panner3D._aliasProperty('coneOuterGain');
	    /**
		 *  The maximum distance between source and listener,
		 *  after which the volume will not be reduced any further.
		 *  @type {Positive}
		 *  @memberOf Tone.Panner3D#
		 *  @name maxDistance
		 */
	    Tone.Panner3D._aliasProperty('maxDistance');
	    /**
		 *  Clean up.
		 *  @returns {Tone.Panner3D} this
		 */
	    Tone.Panner3D.prototype.dispose = function () {
	        Tone.AudioNode.prototype.dispose.call(this);
	        this._panner.disconnect();
	        this._panner = null;
	        this._orientation = null;
	        this._position = null;
	        return this;
	    };
	    return Tone.Panner3D;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Tone.PanVol is a Tone.Panner and Tone.Volume in one.
		 *
		 *  @extends {Tone.AudioNode}
		 *  @constructor
		 *  @param {AudioRange} pan the initial pan
		 *  @param {number} volume The output volume.
		 *  @example
		 * //pan the incoming signal left and drop the volume
		 * var panVol = new Tone.PanVol(-0.25, -12);
		 */
	    Tone.PanVol = function () {
	        var options = Tone.defaults(arguments, [
	            'pan',
	            'volume'
	        ], Tone.PanVol);
	        Tone.AudioNode.call(this);
	        /**
			 *  The panning node
			 *  @type {Tone.Panner}
			 *  @private
			 */
	        this._panner = this.input = new Tone.Panner(options.pan);
	        /**
			 *  The L/R panning control.
			 *  @type {AudioRange}
			 *  @signal
			 */
	        this.pan = this._panner.pan;
	        /**
			 *  The volume node
			 *  @type {Tone.Volume}
			 *  @private
			 */
	        this._volume = this.output = new Tone.Volume(options.volume);
	        /**
			 *  The volume control in decibels.
			 *  @type {Decibels}
			 *  @signal
			 */
	        this.volume = this._volume.volume;
	        //connections
	        this._panner.connect(this._volume);
	        this.mute = options.mute;
	        this._readOnly([
	            'pan',
	            'volume'
	        ]);
	    };
	    Tone.extend(Tone.PanVol, Tone.AudioNode);
	    /**
		 *  The defaults
		 *  @type  {Object}
		 *  @const
		 *  @static
		 */
	    Tone.PanVol.defaults = {
	        'pan': 0,
	        'volume': 0,
	        'mute': false
	    };
	    /**
		 * Mute/unmute the volume
		 * @memberOf Tone.PanVol#
		 * @name mute
		 * @type {Boolean}
		 */
	    Object.defineProperty(Tone.PanVol.prototype, 'mute', {
	        get: function () {
	            return this._volume.mute;
	        },
	        set: function (mute) {
	            this._volume.mute = mute;
	        }
	    });
	    /**
		 *  clean up
		 *  @returns {Tone.PanVol} this
		 */
	    Tone.PanVol.prototype.dispose = function () {
	        Tone.AudioNode.prototype.dispose.call(this);
	        this._writable([
	            'pan',
	            'volume'
	        ]);
	        this._panner.dispose();
	        this._panner = null;
	        this.pan = null;
	        this._volume.dispose();
	        this._volume = null;
	        this.volume = null;
	        return this;
	    };
	    return Tone.PanVol;
	});
	Module(function (Tone) {
	    /**
		 *  @class Tone.Solo lets you isolate a specific audio stream. When
		 *         an instance is set to `solo=true`, it will mute all other instances.
		 *  @extends {Tone.AudioNode}
		 *  @example
		 * var soloA = new Tone.Solo()
		 * var soloB = new Tone.Solo()
		 * soloA.solo = true
		 * //no audio will pass through soloB
		 */
	    Tone.Solo = function () {
	        var options = Tone.defaults(arguments, ['solo'], Tone.Solo);
	        Tone.AudioNode.call(this);
	        /**
			 *  The input and output node
			 *  @type  {Tone.Gain}
			 */
	        this.input = this.output = new Tone.Gain();
	        /**
			 *  A bound _soloed method
			 *  @type  {Function}
			 *  @private
			 */
	        this._soloBind = this._soloed.bind(this);
	        //listen for solo events class-wide.
	        this.context.on('solo', this._soloBind);
	        //set initially
	        this.solo = options.solo;
	    };
	    Tone.extend(Tone.Solo, Tone.AudioNode);
	    /**
		 *  The defaults
		 *  @type  {Object}
		 *  @static
		 */
	    Tone.Solo.defaults = { solo: false };
	    /**
		 *  Isolates this instance and mutes all other instances of Tone.Solo.
		 *  Only one instance can be soloed at a time. A soloed
		 *  instance will report `solo=false` when another instance is soloed.
		 *  @memberOf Tone.Solo#
		 *  @type {Boolean}
		 *  @name solo
		 */
	    Object.defineProperty(Tone.Solo.prototype, 'solo', {
	        get: function () {
	            return this._isSoloed();
	        },
	        set: function (solo) {
	            if (solo) {
	                this._addSolo();
	            } else {
	                this._removeSolo();
	            }
	            this.context.emit('solo', this);
	        }
	    });
	    /**
		 *  If the current instance is muted, i.e. another instance is soloed
		 *  @memberOf Tone.Solo#
		 *  @type {Boolean}
		 *  @name muted
		 *  @readOnly
		 */
	    Object.defineProperty(Tone.Solo.prototype, 'muted', {
	        get: function () {
	            return this.input.gain.value === 0;
	        }
	    });
	    /**
		 * Add this to the soloed array
		 * @private
		 */
	    Tone.Solo.prototype._addSolo = function () {
	        if (!Tone.isArray(this.context._currentSolo)) {
	            this.context._currentSolo = [];
	        }
	        if (!this._isSoloed()) {
	            this.context._currentSolo.push(this);
	        }
	    };
	    /**
		 * Remove this from the soloed array
		 * @private
		 */
	    Tone.Solo.prototype._removeSolo = function () {
	        if (this._isSoloed()) {
	            var index = this.context._currentSolo.indexOf(this);
	            this.context._currentSolo.splice(index, 1);
	        }
	    };
	    /**
		 * @return {Boolean} Is this on the soloed array
		 * @private
		 */
	    Tone.Solo.prototype._isSoloed = function () {
	        if (Tone.isArray(this.context._currentSolo)) {
	            return this.context._currentSolo.length !== 0 && this.context._currentSolo.indexOf(this) !== -1;
	        } else {
	            return false;
	        }
	    };
	    /**
		 * @return {Boolean} Returns true if no one is soloed
		 * @private
		 */
	    Tone.Solo.prototype._noSolos = function () {
	        return !Tone.isArray(this.context._currentSolo) || this.context._currentSolo.length === 0;
	    };
	    /**
		 *  Solo the current instance and unsolo all other instances.
		 *  @param  {Tone.Solo}  instance  The instance which is being soloed/unsoloed.
		 *  @private
		 */
	    Tone.Solo.prototype._soloed = function () {
	        if (this._isSoloed()) {
	            this.input.gain.value = 1;
	        } else if (this._noSolos()) {
	            //no one is soloed
	            this.input.gain.value = 1;
	        } else {
	            this.input.gain.value = 0;
	        }
	    };
	    /**
		 *  Clean up
		 *  @return  {Tone.Solo}  this
		 */
	    Tone.Solo.prototype.dispose = function () {
	        this.context.off('solo', this._soloBind);
	        this._removeSolo();
	        this._soloBind = null;
	        Tone.AudioNode.prototype.dispose.call(this);
	        return this;
	    };
	    return Tone.Solo;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Tone.CtrlInterpolate will interpolate between given values based
		 *         on the "index" property. Passing in an array or object literal
		 *         will interpolate each of the parameters. Note (i.e. "C3")
		 *         and Time (i.e. "4n + 2") can be interpolated. All other values are
		 *         assumed to be numbers. 
		 *  @example
		 * var interp = new Tone.CtrlInterpolate([0, 2, 9, 4]);
		 * interp.index = 0.75;
		 * interp.value; //returns 1.5
		 *
		 *  @example
		 * var interp = new Tone.CtrlInterpolate([
		 * 	[2, 4, 5],
		 * 	[9, 3, 2],
		 * ]);
		 * @param {Array} values The array of values to interpolate over
		 * @param {Positive} index The initial interpolation index.
		 * @extends {Tone}
		 */
	    Tone.CtrlInterpolate = function () {
	        var options = Tone.defaults(arguments, [
	            'values',
	            'index'
	        ], Tone.CtrlInterpolate);
	        Tone.call(this);
	        /**
			 *  The values to interpolate between
			 *  @type  {Array}
			 */
	        this.values = options.values;
	        /**
			 *  The interpolated index between values. For example: a value of 1.5
			 *  would interpolate equally between the value at index 1
			 *  and the value at index 2. 
			 *  @example
			 * interp.index = 0; 
			 * interp.value; //returns the value at 0
			 * interp.index = 0.5;
			 * interp.value; //returns the value between indices 0 and 1. 
			 *  @type  {Positive}
			 */
	        this.index = options.index;
	    };
	    Tone.extend(Tone.CtrlInterpolate);
	    /**
		 *  The defaults
		 *  @const
		 *  @type  {Object}
		 */
	    Tone.CtrlInterpolate.defaults = {
	        'index': 0,
	        'values': []
	    };
	    /**
		 *  The current interpolated value based on the index
		 *  @readOnly
		 *  @memberOf Tone.CtrlInterpolate#
		 *  @type {*}
		 *  @name value
		 */
	    Object.defineProperty(Tone.CtrlInterpolate.prototype, 'value', {
	        get: function () {
	            var index = this.index;
	            index = Math.min(index, this.values.length - 1);
	            var lowerPosition = Math.floor(index);
	            var lower = this.values[lowerPosition];
	            var upper = this.values[Math.ceil(index)];
	            return this._interpolate(index - lowerPosition, lower, upper);
	        }
	    });
	    /**
		 *  Internal interpolation routine
		 *  @param  {NormalRange}  index  The index between the lower and upper
		 *  @param  {*}  lower 
		 *  @param  {*}  upper 
		 *  @return  {*}  The interpolated value
		 *  @private
		 */
	    Tone.CtrlInterpolate.prototype._interpolate = function (index, lower, upper) {
	        if (Tone.isArray(lower)) {
	            var retArray = [];
	            for (var i = 0; i < lower.length; i++) {
	                retArray[i] = this._interpolate(index, lower[i], upper[i]);
	            }
	            return retArray;
	        } else if (Tone.isObject(lower)) {
	            var retObj = {};
	            for (var attr in lower) {
	                retObj[attr] = this._interpolate(index, lower[attr], upper[attr]);
	            }
	            return retObj;
	        } else {
	            lower = this._toNumber(lower);
	            upper = this._toNumber(upper);
	            return (1 - index) * lower + index * upper;
	        }
	    };
	    /**
		 *  Convert from the given type into a number
		 *  @param  {Number|String}  value
		 *  @return  {Number}
		 *  @private
		 */
	    Tone.CtrlInterpolate.prototype._toNumber = function (val) {
	        if (Tone.isNumber(val)) {
	            return val;
	        } else {
	            //otherwise assume that it's Time...
	            return this.toSeconds(val);
	        }
	    };
	    /**
		 *  Clean up
		 *  @return  {Tone.CtrlInterpolate}  this
		 */
	    Tone.CtrlInterpolate.prototype.dispose = function () {
	        this.values = null;
	    };
	    return Tone.CtrlInterpolate;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Tone.CtrlMarkov represents a Markov Chain where each call
		 *         to Tone.CtrlMarkov.next will move to the next state. If the next
		 *         state choice is an array, the next state is chosen randomly with
		 *         even probability for all of the choices. For a weighted probability
		 *         of the next choices, pass in an object with "state" and "probability" attributes. 
		 *         The probabilities will be normalized and then chosen. If no next options
		 *         are given for the current state, the state will stay there. 
		 *  @extends {Tone}
		 *  @example
		 * var chain = new Tone.CtrlMarkov({
		 * 	"beginning" : ["end", "middle"],
		 * 	"middle" : "end"
		 * });
		 * chain.value = "beginning";
		 * chain.next(); //returns "end" or "middle" with 50% probability
		 *
		 *  @example
		 * var chain = new Tone.CtrlMarkov({
		 * 	"beginning" : [{"value" : "end", "probability" : 0.8}, 
		 * 					{"value" : "middle", "probability" : 0.2}],
		 * 	"middle" : "end"
		 * });
		 * chain.value = "beginning";
		 * chain.next(); //returns "end" with 80% probability or "middle" with 20%.
		 *  @param {Object} values An object with the state names as the keys
		 *                         and the next state(s) as the values. 
		 */
	    Tone.CtrlMarkov = function (values, initial) {
	        Tone.call(this);
	        /**
			 *  The Markov values with states as the keys
			 *  and next state(s) as the values. 
			 *  @type {Object}
			 */
	        this.values = Tone.defaultArg(values, {});
	        /**
			 *  The current state of the Markov values. The next
			 *  state will be evaluated and returned when Tone.CtrlMarkov.next
			 *  is invoked.
			 *  @type {String}
			 */
	        this.value = Tone.defaultArg(initial, Object.keys(this.values)[0]);
	    };
	    Tone.extend(Tone.CtrlMarkov);
	    /**
		 *  Returns the next state of the Markov values. 
		 *  @return  {String}
		 */
	    Tone.CtrlMarkov.prototype.next = function () {
	        if (this.values.hasOwnProperty(this.value)) {
	            var next = this.values[this.value];
	            if (Tone.isArray(next)) {
	                var distribution = this._getProbDistribution(next);
	                var rand = Math.random();
	                var total = 0;
	                for (var i = 0; i < distribution.length; i++) {
	                    var dist = distribution[i];
	                    if (rand > total && rand < total + dist) {
	                        var chosen = next[i];
	                        if (Tone.isObject(chosen)) {
	                            this.value = chosen.value;
	                        } else {
	                            this.value = chosen;
	                        }
	                    }
	                    total += dist;
	                }
	            } else {
	                this.value = next;
	            }
	        }
	        return this.value;
	    };
	    /**
		 *  Choose randomly from an array weighted options in the form 
		 *  {"state" : string, "probability" : number} or an array of values
		 *  @param  {Array}  options 
		 *  @return  {Array}  The randomly selected choice
		 *  @private
		 */
	    Tone.CtrlMarkov.prototype._getProbDistribution = function (options) {
	        var distribution = [];
	        var total = 0;
	        var needsNormalizing = false;
	        for (var i = 0; i < options.length; i++) {
	            var option = options[i];
	            if (Tone.isObject(option)) {
	                needsNormalizing = true;
	                distribution[i] = option.probability;
	            } else {
	                distribution[i] = 1 / options.length;
	            }
	            total += distribution[i];
	        }
	        if (needsNormalizing) {
	            //normalize the values
	            for (var j = 0; j < distribution.length; j++) {
	                distribution[j] = distribution[j] / total;
	            }
	        }
	        return distribution;
	    };
	    /**
		 *  Clean up
		 *  @return  {Tone.CtrlMarkov}  this
		 */
	    Tone.CtrlMarkov.prototype.dispose = function () {
	        this.values = null;
	    };
	    return Tone.CtrlMarkov;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Generate patterns from an array of values.
		 *         Has a number of arpeggiation and randomized
		 *         selection patterns. 
		 *           <ul>
		 *  	        <li>"up" - cycles upward</li>
		 *  			<li>"down" - cycles downward</li>
		 *  			<li>"upDown" - up then and down</li>
		 *  			<li>"downUp" - cycles down then and up</li>
		 *  			<li>"alternateUp" - jump up two and down one</li>
		 *  			<li>"alternateDown" - jump down two and up one</li>
		 *  			<li>"random" - randomly select an index</li>
		 *  			<li>"randomWalk" - randomly moves one index away from the current position</li>
		 *  			<li>"randomOnce" - randomly select an index without repeating until all values have been chosen.</li>
		 *     		</ul>
		 *  @param  {Array}  values   An array of options to choose from.
		 *  @param  {Tone.CtrlPattern.Type=}  type  The name of the pattern.
		 *  @extends {Tone}
		 */
	    Tone.CtrlPattern = function () {
	        var options = Tone.defaults(arguments, [
	            'values',
	            'type'
	        ], Tone.CtrlPattern);
	        Tone.call(this);
	        /**
			 *  The array of values to arpeggiate over
			 *  @type {Array}
			 */
	        this.values = options.values;
	        /**
			 *  The current position in the values array
			 *  @type  {Number}
			 */
	        this.index = 0;
	        /**
			 *  The type placeholder
			 *  @type {Tone.CtrlPattern.Type}
			 *  @private
			 */
	        this._type = null;
	        /**
			 *  Shuffled values for the RandomOnce type
			 *  @type {Array}
			 *  @private
			 */
	        this._shuffled = null;
	        /**
			 *  The direction of the movement
			 *  @type {String}
			 *  @private
			 */
	        this._direction = null;
	        this.type = options.type;
	    };
	    Tone.extend(Tone.CtrlPattern);
	    /**
		 *  The Control Patterns
		 *  @type  {Object}
		 *  @static
		 */
	    Tone.CtrlPattern.Type = {
	        Up: 'up',
	        Down: 'down',
	        UpDown: 'upDown',
	        DownUp: 'downUp',
	        AlternateUp: 'alternateUp',
	        AlternateDown: 'alternateDown',
	        Random: 'random',
	        RandomWalk: 'randomWalk',
	        RandomOnce: 'randomOnce'
	    };
	    /**
		 *  The default values. 
		 *  @type  {Object}
		 */
	    Tone.CtrlPattern.defaults = {
	        'type': Tone.CtrlPattern.Type.Up,
	        'values': []
	    };
	    /**
		 *  The value at the current index of the pattern.
		 *  @readOnly
		 *  @memberOf Tone.CtrlPattern#
		 *  @type {*}
		 *  @name value
		 */
	    Object.defineProperty(Tone.CtrlPattern.prototype, 'value', {
	        get: function () {
	            //some safeguards
	            if (this.values.length === 0) {
	                return;
	            } else if (this.values.length === 1) {
	                return this.values[0];
	            }
	            this.index = Math.min(this.index, this.values.length - 1);
	            var val = this.values[this.index];
	            if (this.type === Tone.CtrlPattern.Type.RandomOnce) {
	                if (this.values.length !== this._shuffled.length) {
	                    this._shuffleValues();
	                }
	                val = this.values[this._shuffled[this.index]];
	            }
	            return val;
	        }
	    });
	    /**
		 *  The pattern used to select the next
		 *  item from the values array
		 *  @memberOf Tone.CtrlPattern#
		 *  @type {Tone.CtrlPattern.Type}
		 *  @name type
		 */
	    Object.defineProperty(Tone.CtrlPattern.prototype, 'type', {
	        get: function () {
	            return this._type;
	        },
	        set: function (type) {
	            this._type = type;
	            this._shuffled = null;
	            //the first index
	            if (this._type === Tone.CtrlPattern.Type.Up || this._type === Tone.CtrlPattern.Type.UpDown || this._type === Tone.CtrlPattern.Type.RandomOnce || this._type === Tone.CtrlPattern.Type.AlternateUp) {
	                this.index = 0;
	            } else if (this._type === Tone.CtrlPattern.Type.Down || this._type === Tone.CtrlPattern.Type.DownUp || this._type === Tone.CtrlPattern.Type.AlternateDown) {
	                this.index = this.values.length - 1;
	            }
	            //the direction
	            if (this._type === Tone.CtrlPattern.Type.UpDown || this._type === Tone.CtrlPattern.Type.AlternateUp) {
	                this._direction = Tone.CtrlPattern.Type.Up;
	            } else if (this._type === Tone.CtrlPattern.Type.DownUp || this._type === Tone.CtrlPattern.Type.AlternateDown) {
	                this._direction = Tone.CtrlPattern.Type.Down;
	            }
	            //randoms
	            if (this._type === Tone.CtrlPattern.Type.RandomOnce) {
	                this._shuffleValues();
	            } else if (this._type === Tone.CtrlPattern.Random) {
	                this.index = Math.floor(Math.random() * this.values.length);
	            }
	        }
	    });
	    /**
		 *  Return the next value given the current position
		 *  and pattern.
		 *  @return {*} The next value
		 */
	    Tone.CtrlPattern.prototype.next = function () {
	        var type = this.type;
	        //choose the next index
	        if (type === Tone.CtrlPattern.Type.Up) {
	            this.index++;
	            if (this.index >= this.values.length) {
	                this.index = 0;
	            }
	        } else if (type === Tone.CtrlPattern.Type.Down) {
	            this.index--;
	            if (this.index < 0) {
	                this.index = this.values.length - 1;
	            }
	        } else if (type === Tone.CtrlPattern.Type.UpDown || type === Tone.CtrlPattern.Type.DownUp) {
	            if (this._direction === Tone.CtrlPattern.Type.Up) {
	                this.index++;
	            } else {
	                this.index--;
	            }
	            if (this.index < 0) {
	                this.index = 1;
	                this._direction = Tone.CtrlPattern.Type.Up;
	            } else if (this.index >= this.values.length) {
	                this.index = this.values.length - 2;
	                this._direction = Tone.CtrlPattern.Type.Down;
	            }
	        } else if (type === Tone.CtrlPattern.Type.Random) {
	            this.index = Math.floor(Math.random() * this.values.length);
	        } else if (type === Tone.CtrlPattern.Type.RandomWalk) {
	            if (Math.random() < 0.5) {
	                this.index--;
	                this.index = Math.max(this.index, 0);
	            } else {
	                this.index++;
	                this.index = Math.min(this.index, this.values.length - 1);
	            }
	        } else if (type === Tone.CtrlPattern.Type.RandomOnce) {
	            this.index++;
	            if (this.index >= this.values.length) {
	                this.index = 0;
	                //reshuffle the values for next time
	                this._shuffleValues();
	            }
	        } else if (type === Tone.CtrlPattern.Type.AlternateUp) {
	            if (this._direction === Tone.CtrlPattern.Type.Up) {
	                this.index += 2;
	                this._direction = Tone.CtrlPattern.Type.Down;
	            } else {
	                this.index -= 1;
	                this._direction = Tone.CtrlPattern.Type.Up;
	            }
	            if (this.index >= this.values.length) {
	                this.index = 0;
	                this._direction = Tone.CtrlPattern.Type.Up;
	            }
	        } else if (type === Tone.CtrlPattern.Type.AlternateDown) {
	            if (this._direction === Tone.CtrlPattern.Type.Up) {
	                this.index += 1;
	                this._direction = Tone.CtrlPattern.Type.Down;
	            } else {
	                this.index -= 2;
	                this._direction = Tone.CtrlPattern.Type.Up;
	            }
	            if (this.index < 0) {
	                this.index = this.values.length - 1;
	                this._direction = Tone.CtrlPattern.Type.Down;
	            }
	        }
	        return this.value;
	    };
	    /**
		 *  Shuffles the values and places the results into the _shuffled
		 *  @private
		 */
	    Tone.CtrlPattern.prototype._shuffleValues = function () {
	        var copy = [];
	        this._shuffled = [];
	        for (var i = 0; i < this.values.length; i++) {
	            copy[i] = i;
	        }
	        while (copy.length > 0) {
	            var randVal = copy.splice(Math.floor(copy.length * Math.random()), 1);
	            this._shuffled.push(randVal[0]);
	        }
	    };
	    /**
		 *  Clean up
		 *  @returns {Tone.CtrlPattern} this
		 */
	    Tone.CtrlPattern.prototype.dispose = function () {
	        this._shuffled = null;
	        this.values = null;
	    };
	    return Tone.CtrlPattern;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class  Choose a random value.
		 *  @extends {Tone}
		 *  @example
		 * var randomWalk = new Tone.CtrlRandom({
		 * 	"min" : 0,
		 * 	"max" : 10,
		 * 	"integer" : true
		 * });
		 * randomWalk.eval();
		 *
		 *  @param {Number|Time=} min The minimum return value.
		 *  @param {Number|Time=} max The maximum return value.
		 */
	    Tone.CtrlRandom = function () {
	        var options = Tone.defaults(arguments, [
	            'min',
	            'max'
	        ], Tone.CtrlRandom);
	        Tone.call(this);
	        /**
			 *  The minimum return value
			 *  @type  {Number|Time}
			 */
	        this.min = options.min;
	        /**
			 *  The maximum return value
			 *  @type  {Number|Time}
			 */
	        this.max = options.max;
	        /**
			 *  If the return value should be an integer
			 *  @type  {Boolean}
			 */
	        this.integer = options.integer;
	    };
	    Tone.extend(Tone.CtrlRandom);
	    /**
		 *  The defaults
		 *  @const
		 *  @type  {Object}
		 */
	    Tone.CtrlRandom.defaults = {
	        'min': 0,
	        'max': 1,
	        'integer': false
	    };
	    /**
		 *  Return a random value between min and max. 
		 *  @readOnly
		 *  @memberOf Tone.CtrlRandom#
		 *  @type {*}
		 *  @name value
		 */
	    Object.defineProperty(Tone.CtrlRandom.prototype, 'value', {
	        get: function () {
	            var min = this.toSeconds(this.min);
	            var max = this.toSeconds(this.max);
	            var rand = Math.random();
	            var val = rand * min + (1 - rand) * max;
	            if (this.integer) {
	                val = Math.floor(val);
	            }
	            return val;
	        }
	    });
	    return Tone.CtrlRandom;
	});
	Module(function (Tone) {
	    
	    /**
		 *  AudioBuffer.copyToChannel polyfill
		 *  @private
		 */
	    if (window.AudioBuffer && !AudioBuffer.prototype.copyToChannel) {
	        AudioBuffer.prototype.copyToChannel = function (src, chanNum, start) {
	            var channel = this.getChannelData(chanNum);
	            start = start || 0;
	            for (var i = 0; i < channel.length; i++) {
	                channel[i + start] = src[i];
	            }
	        };
	        AudioBuffer.prototype.copyFromChannel = function (dest, chanNum, start) {
	            var channel = this.getChannelData(chanNum);
	            start = start || 0;
	            for (var i = 0; i < dest.length; i++) {
	                dest[i] = channel[i + start];
	            }
	        };
	    }
	    /**
		 *  @class  Buffer loading and storage. Tone.Buffer is used internally by all 
		 *          classes that make requests for audio files such as Tone.Player,
		 *          Tone.Sampler and Tone.Convolver.
		 *          
		 *          Aside from load callbacks from individual buffers, Tone.Buffer 
		 *  		provides events which keep track of the loading progress 
		 *  		of _all_ of the buffers. These are Tone.Buffer.on("load" / "progress" / "error")
		 *
		 *  @constructor 
		 *  @extends {Tone}
		 *  @param {AudioBuffer|String} url The url to load, or the audio buffer to set. 
		 *  @param {Function=} onload A callback which is invoked after the buffer is loaded. 
		 *                            It's recommended to use `Tone.Buffer.on('load', callback)` instead 
		 *                            since it will give you a callback when _all_ buffers are loaded.
		 *  @param {Function=} onerror The callback to invoke if there is an error
		 *  @example
		 * var buffer = new Tone.Buffer("path/to/sound.mp3", function(){
		 * 	//the buffer is now available.
		 * 	var buff = buffer.get();
		 * });
		 *  @example
		 * //can load provide fallback extension types if the first type is not supported.
		 * var buffer = new Tone.Buffer("path/to/sound.[mp3|ogg|wav]");
		 */
	    Tone.Buffer = function () {
	        var options = Tone.defaults(arguments, [
	            'url',
	            'onload',
	            'onerror'
	        ], Tone.Buffer);
	        Tone.call(this);
	        /**
			 *  stores the loaded AudioBuffer
			 *  @type {AudioBuffer}
			 *  @private
			 */
	        this._buffer = null;
	        /**
			 *  indicates if the buffer should be reversed or not
			 *  @type {Boolean}
			 *  @private
			 */
	        this._reversed = options.reverse;
	        /**
			 *  The XHR
			 *  @type  {XMLHttpRequest}
			 *  @private
			 */
	        this._xhr = null;
	        if (options.url instanceof AudioBuffer || options.url instanceof Tone.Buffer) {
	            this.set(options.url);
	            // invoke the onload callback
	            if (options.onload) {
	                options.onload(this);
	            }
	        } else if (Tone.isString(options.url)) {
	            this.load(options.url, options.onload, options.onerror);
	        }
	    };
	    Tone.extend(Tone.Buffer);
	    /**
		 *  the default parameters
		 *  @type {Object}
		 */
	    Tone.Buffer.defaults = {
	        'url': undefined,
	        'reverse': false
	    };
	    /**
		 *  Pass in an AudioBuffer or Tone.Buffer to set the value
		 *  of this buffer.
		 *  @param {AudioBuffer|Tone.Buffer} buffer the buffer
		 *  @returns {Tone.Buffer} this
		 */
	    Tone.Buffer.prototype.set = function (buffer) {
	        if (buffer instanceof Tone.Buffer) {
	            this._buffer = buffer.get();
	        } else {
	            this._buffer = buffer;
	        }
	        return this;
	    };
	    /**
		 *  @return {AudioBuffer} The audio buffer stored in the object.
		 */
	    Tone.Buffer.prototype.get = function () {
	        return this._buffer;
	    };
	    /**
		 *  Makes an xhr reqest for the selected url then decodes
		 *  the file as an audio buffer. Invokes
		 *  the callback once the audio buffer loads.
		 *  @param {String} url The url of the buffer to load.
		 *                      filetype support depends on the
		 *                      browser.
		 *  @returns {Promise} returns a Promise which resolves with the Tone.Buffer
		 */
	    Tone.Buffer.prototype.load = function (url, onload, onerror) {
	        var promise = new Promise(function (load, error) {
	            this._xhr = Tone.Buffer.load(url, //success
	            function (buff) {
	                this._xhr = null;
	                this.set(buff);
	                load(this);
	                if (onload) {
	                    onload(this);
	                }
	            }.bind(this), //error
	            function (err) {
	                this._xhr = null;
	                error(err);
	                if (onerror) {
	                    onerror(err);
	                }
	            }.bind(this));
	        }.bind(this));
	        return promise;
	    };
	    /**
		 *  dispose and disconnect
		 *  @returns {Tone.Buffer} this
		 */
	    Tone.Buffer.prototype.dispose = function () {
	        Tone.prototype.dispose.call(this);
	        this._buffer = null;
	        if (this._xhr) {
	            Tone.Buffer._removeFromDownloadQueue(this._xhr);
	            this._xhr.abort();
	            this._xhr = null;
	        }
	        return this;
	    };
	    /**
		 * If the buffer is loaded or not
		 * @memberOf Tone.Buffer#
		 * @type {Boolean}
		 * @name loaded
		 * @readOnly
		 */
	    Object.defineProperty(Tone.Buffer.prototype, 'loaded', {
	        get: function () {
	            return this.length > 0;
	        }
	    });
	    /**
		 * The duration of the buffer. 
		 * @memberOf Tone.Buffer#
		 * @type {Number}
		 * @name duration
		 * @readOnly
		 */
	    Object.defineProperty(Tone.Buffer.prototype, 'duration', {
	        get: function () {
	            if (this._buffer) {
	                return this._buffer.duration;
	            } else {
	                return 0;
	            }
	        }
	    });
	    /**
		 * The length of the buffer in samples
		 * @memberOf Tone.Buffer#
		 * @type {Number}
		 * @name length
		 * @readOnly
		 */
	    Object.defineProperty(Tone.Buffer.prototype, 'length', {
	        get: function () {
	            if (this._buffer) {
	                return this._buffer.length;
	            } else {
	                return 0;
	            }
	        }
	    });
	    /**
		 * The number of discrete audio channels. Returns 0 if no buffer
		 * is loaded.
		 * @memberOf Tone.Buffer#
		 * @type {Number}
		 * @name numberOfChannels
		 * @readOnly
		 */
	    Object.defineProperty(Tone.Buffer.prototype, 'numberOfChannels', {
	        get: function () {
	            if (this._buffer) {
	                return this._buffer.numberOfChannels;
	            } else {
	                return 0;
	            }
	        }
	    });
	    /**
		 *  Set the audio buffer from the array. To create a multichannel AudioBuffer,
		 *  pass in a multidimensional array. 
		 *  @param {Float32Array} array The array to fill the audio buffer
		 *  @return {Tone.Buffer} this
		 */
	    Tone.Buffer.prototype.fromArray = function (array) {
	        var isMultidimensional = array[0].length > 0;
	        var channels = isMultidimensional ? array.length : 1;
	        var len = isMultidimensional ? array[0].length : array.length;
	        var buffer = this.context.createBuffer(channels, len, this.context.sampleRate);
	        if (!isMultidimensional && channels === 1) {
	            array = [array];
	        }
	        for (var c = 0; c < channels; c++) {
	            buffer.copyToChannel(array[c], c);
	        }
	        this._buffer = buffer;
	        return this;
	    };
	    /**
		 * 	Sums muliple channels into 1 channel
		 *  @param {Number=} channel Optionally only copy a single channel from the array.
		 *  @return {Array}
		 */
	    Tone.Buffer.prototype.toMono = function (chanNum) {
	        if (Tone.isNumber(chanNum)) {
	            this.fromArray(this.toArray(chanNum));
	        } else {
	            var outputArray = new Float32Array(this.length);
	            var numChannels = this.numberOfChannels;
	            for (var channel = 0; channel < numChannels; channel++) {
	                var channelArray = this.toArray(channel);
	                for (var i = 0; i < channelArray.length; i++) {
	                    outputArray[i] += channelArray[i];
	                }
	            }
	            //divide by the number of channels
	            outputArray = outputArray.map(function (sample) {
	                return sample / numChannels;
	            });
	            this.fromArray(outputArray);
	        }
	        return this;
	    };
	    /**
		 * 	Get the buffer as an array. Single channel buffers will return a 1-dimensional 
		 * 	Float32Array, and multichannel buffers will return multidimensional arrays.
		 *  @param {Number=} channel Optionally only copy a single channel from the array.
		 *  @return {Array}
		 */
	    Tone.Buffer.prototype.toArray = function (channel) {
	        if (Tone.isNumber(channel)) {
	            return this.getChannelData(channel);
	        } else if (this.numberOfChannels === 1) {
	            return this.toArray(0);
	        } else {
	            var ret = [];
	            for (var c = 0; c < this.numberOfChannels; c++) {
	                ret[c] = this.getChannelData(c);
	            }
	            return ret;
	        }
	    };
	    /**
		 *  Returns the Float32Array representing the PCM audio data for the specific channel.
		 *  @param  {Number}  channel  The channel number to return
		 *  @return  {Float32Array}  The audio as a TypedArray
		 */
	    Tone.Buffer.prototype.getChannelData = function (channel) {
	        return this._buffer.getChannelData(channel);
	    };
	    /**
		 *  Cut a subsection of the array and return a buffer of the
		 *  subsection. Does not modify the original buffer
		 *  @param {Time} start The time to start the slice
		 *  @param {Time=} end The end time to slice. If none is given
		 *                     will default to the end of the buffer
		 *  @return {Tone.Buffer} this
		 */
	    Tone.Buffer.prototype.slice = function (start, end) {
	        end = Tone.defaultArg(end, this.duration);
	        var startSamples = Math.floor(this.context.sampleRate * this.toSeconds(start));
	        var endSamples = Math.floor(this.context.sampleRate * this.toSeconds(end));
	        var replacement = [];
	        for (var i = 0; i < this.numberOfChannels; i++) {
	            replacement[i] = this.toArray(i).slice(startSamples, endSamples);
	        }
	        var retBuffer = new Tone.Buffer().fromArray(replacement);
	        return retBuffer;
	    };
	    /**
		 *  Reverse the buffer.
		 *  @private
		 *  @return {Tone.Buffer} this
		 */
	    Tone.Buffer.prototype._reverse = function () {
	        if (this.loaded) {
	            for (var i = 0; i < this.numberOfChannels; i++) {
	                Array.prototype.reverse.call(this.getChannelData(i));
	            }
	        }
	        return this;
	    };
	    /**
		 * Reverse the buffer.
		 * @memberOf Tone.Buffer#
		 * @type {Boolean}
		 * @name reverse
		 */
	    Object.defineProperty(Tone.Buffer.prototype, 'reverse', {
	        get: function () {
	            return this._reversed;
	        },
	        set: function (rev) {
	            if (this._reversed !== rev) {
	                this._reversed = rev;
	                this._reverse();
	            }
	        }
	    });
	    ///////////////////////////////////////////////////////////////////////////
	    // STATIC METHODS
	    ///////////////////////////////////////////////////////////////////////////
	    //statically inherits Emitter methods
	    Tone.Emitter.mixin(Tone.Buffer);
	    /**
		 *  the static queue for all of the xhr requests
		 *  @type {Array}
		 *  @private
		 */
	    Tone.Buffer._downloadQueue = [];
	    /**
		 *  A path which is prefixed before every url.
		 *  @type  {String}
		 *  @static
		 */
	    Tone.Buffer.baseUrl = '';
	    /**
		 *  Create a Tone.Buffer from the array. To create a multichannel AudioBuffer,
		 *  pass in a multidimensional array. 
		 *  @param {Float32Array} array The array to fill the audio buffer
		 *  @return {Tone.Buffer} A Tone.Buffer created from the array
		 */
	    Tone.Buffer.fromArray = function (array) {
	        return new Tone.Buffer().fromArray(array);
	    };
	    /**
		 * Remove an xhr request from the download queue
		 * @private
		 */
	    Tone.Buffer._removeFromDownloadQueue = function (request) {
	        var index = Tone.Buffer._downloadQueue.indexOf(request);
	        if (index !== -1) {
	            Tone.Buffer._downloadQueue.splice(index, 1);
	        }
	    };
	    /**
		 *  Loads a url using XMLHttpRequest.
		 *  @param {String} url
		 *  @param {Function} onload
		 *  @param {Function} onerror
		 *  @param {Function} onprogress
		 *  @return {XMLHttpRequest}
		 */
	    Tone.Buffer.load = function (url, onload, onerror) {
	        //default
	        onload = Tone.defaultArg(onload, Tone.noOp);
	        // test if the url contains multiple extensions
	        var matches = url.match(/\[(.+\|?)+\]$/);
	        if (matches) {
	            var extensions = matches[1].split('|');
	            var extension = extensions[0];
	            for (var i = 0; i < extensions.length; i++) {
	                if (Tone.Buffer.supportsType(extensions[i])) {
	                    extension = extensions[i];
	                    break;
	                }
	            }
	            url = url.replace(matches[0], extension);
	        }
	        function onError(e) {
	            Tone.Buffer._removeFromDownloadQueue(request);
	            Tone.Buffer.emit('error', e);
	            if (onerror) {
	                onerror(e);
	            } else {
	                throw e;
	            }
	        }
	        function onProgress() {
	            //calculate the progress
	            var totalProgress = 0;
	            for (var i = 0; i < Tone.Buffer._downloadQueue.length; i++) {
	                totalProgress += Tone.Buffer._downloadQueue[i].progress;
	            }
	            Tone.Buffer.emit('progress', totalProgress / Tone.Buffer._downloadQueue.length);
	        }
	        var request = new XMLHttpRequest();
	        request.open('GET', Tone.Buffer.baseUrl + url, true);
	        request.responseType = 'arraybuffer';
	        //start out as 0
	        request.progress = 0;
	        Tone.Buffer._downloadQueue.push(request);
	        request.addEventListener('load', function () {
	            if (request.status === 200) {
	                Tone.context.decodeAudioData(request.response, function (buff) {
	                    request.progress = 1;
	                    onProgress();
	                    onload(buff);
	                    Tone.Buffer._removeFromDownloadQueue(request);
	                    if (Tone.Buffer._downloadQueue.length === 0) {
	                        //emit the event at the end
	                        Tone.Buffer.emit('load');
	                    }
	                }, function () {
	                    Tone.Buffer._removeFromDownloadQueue(request);
	                    onError('Tone.Buffer: could not decode audio data: ' + url);
	                });
	            } else {
	                onError('Tone.Buffer: could not locate file: ' + url);
	            }
	        });
	        request.addEventListener('error', onError);
	        request.addEventListener('progress', function (event) {
	            if (event.lengthComputable) {
	                //only go to 95%, the last 5% is when the audio is decoded
	                request.progress = event.loaded / event.total * 0.95;
	                onProgress();
	            }
	        });
	        request.send();
	        return request;
	    };
	    /**
		 *  Stop all of the downloads in progress
		 *  @return {Tone.Buffer}
		 *  @static
		 */
	    Tone.Buffer.cancelDownloads = function () {
	        Tone.Buffer._downloadQueue.slice().forEach(function (request) {
	            Tone.Buffer._removeFromDownloadQueue(request);
	            request.abort();
	        });
	        return Tone.Buffer;
	    };
	    /**
		 *  Checks a url's extension to see if the current browser can play that file type.
		 *  @param {String} url The url/extension to test
		 *  @return {Boolean} If the file extension can be played
		 *  @static
		 *  @example
		 * Tone.Buffer.supportsType("wav"); //returns true
		 * Tone.Buffer.supportsType("path/to/file.wav"); //returns true
		 */
	    Tone.Buffer.supportsType = function (url) {
	        var extension = url.split('.');
	        extension = extension[extension.length - 1];
	        var response = document.createElement('audio').canPlayType('audio/' + extension);
	        return response !== '';
	    };
	    /**
		 *  Returns a Promise which resolves when all of the buffers have loaded
		 *  @return {Promise}
		 */
	    Tone.loaded = function () {
	        var onload, onerror;
	        function removeEvents() {
	            //remove the events when it's resolved
	            Tone.Buffer.off('load', onload);
	            Tone.Buffer.off('error', onerror);
	        }
	        return new Promise(function (success, fail) {
	            onload = function () {
	                success();
	            };
	            onerror = function () {
	                fail();
	            };
	            //add the event listeners
	            Tone.Buffer.on('load', onload);
	            Tone.Buffer.on('error', onerror);
	        }).then(removeEvents).catch(function (e) {
	            removeEvents();
	            throw new Error(e);
	        });
	    };
	    return Tone.Buffer;
	});
	Module(function (Tone) {
	    /**
		 *  @class A data structure for holding multiple buffers.
		 *  
		 *  @param  {Object|Array}    urls      An object literal or array
		 *                                      of urls to load.
		 *  @param  {Function=}  callback  The callback to invoke when
		 *                                 the buffers are loaded. 
		 *  @extends {Tone}
		 *  @example
		 * //load a whole bank of piano samples
		 * var pianoSamples = new Tone.Buffers({
		 * 	"C4" : "path/to/C4.mp3"
		 * 	"C#4" : "path/to/C#4.mp3"
		 * 	"D4" : "path/to/D4.mp3"
		 * 	"D#4" : "path/to/D#4.mp3"
		 * 	...
		 * }, function(){
		 * 	//play one of the samples when they all load
		 * 	player.buffer = pianoSamples.get("C4");
		 * 	player.start();
		 * });
		 * 	@example
		 * //To pass in additional parameters in the second parameter
		 * var buffers = new Tone.Buffers(urls, {
		 * 	"onload" : callback,
		 * 	"baseUrl" : "../path/to/audio/"
		 * })
		 */
	    Tone.Buffers = function (urls) {
	        //remove the urls from the options
	        var args = Array.prototype.slice.call(arguments);
	        args.shift();
	        var options = Tone.defaults(args, [
	            'onload',
	            'baseUrl'
	        ], Tone.Buffers);
	        Tone.call(this);
	        /**
			 *  All of the buffers
			 *  @type  {Object}
			 *  @private
			 */
	        this._buffers = {};
	        /**
			 *  A path which is prefixed before every url.
			 *  @type  {String}
			 */
	        this.baseUrl = options.baseUrl;
	        this._loadingCount = 0;
	        //add each one
	        for (var key in urls) {
	            this._loadingCount++;
	            this.add(key, urls[key], this._bufferLoaded.bind(this, options.onload));
	        }
	    };
	    Tone.extend(Tone.Buffers);
	    /**
		 *  Defaults
		 *  @type  {Object}
		 */
	    Tone.Buffers.defaults = {
	        'onload': Tone.noOp,
	        'baseUrl': ''
	    };
	    /**
		 *  True if the buffers object has a buffer by that name.
		 *  @param  {String|Number}  name  The key or index of the 
		 *                                 buffer.
		 *  @return  {Boolean}
		 */
	    Tone.Buffers.prototype.has = function (name) {
	        return this._buffers.hasOwnProperty(name);
	    };
	    /**
		 *  Get a buffer by name. If an array was loaded, 
		 *  then use the array index.
		 *  @param  {String|Number}  name  The key or index of the 
		 *                                 buffer.
		 *  @return  {Tone.Buffer}
		 */
	    Tone.Buffers.prototype.get = function (name) {
	        if (this.has(name)) {
	            return this._buffers[name];
	        } else {
	            throw new Error('Tone.Buffers: no buffer named ' + name);
	        }
	    };
	    /**
		 *  A buffer was loaded. decrement the counter.
		 *  @param  {Function}  callback 
		 *  @private
		 */
	    Tone.Buffers.prototype._bufferLoaded = function (callback) {
	        this._loadingCount--;
	        if (this._loadingCount === 0 && callback) {
	            callback(this);
	        }
	    };
	    /**
		 * If the buffers are loaded or not
		 * @memberOf Tone.Buffers#
		 * @type {Boolean}
		 * @name loaded
		 * @readOnly
		 */
	    Object.defineProperty(Tone.Buffers.prototype, 'loaded', {
	        get: function () {
	            var isLoaded = true;
	            for (var buffName in this._buffers) {
	                var buff = this.get(buffName);
	                isLoaded = isLoaded && buff.loaded;
	            }
	            return isLoaded;
	        }
	    });
	    /**
		 *  Add a buffer by name and url to the Buffers
		 *  @param  {String}    name      A unique name to give
		 *                                the buffer
		 *  @param  {String|Tone.Buffer|Audiobuffer}  url  Either the url of the bufer, 
		 *                                                 or a buffer which will be added
		 *                                                 with the given name.
		 *  @param  {Function=}  callback  The callback to invoke 
		 *                                 when the url is loaded.
		 */
	    Tone.Buffers.prototype.add = function (name, url, callback) {
	        callback = Tone.defaultArg(callback, Tone.noOp);
	        if (url instanceof Tone.Buffer) {
	            this._buffers[name] = url;
	            callback(this);
	        } else if (url instanceof AudioBuffer) {
	            this._buffers[name] = new Tone.Buffer(url);
	            callback(this);
	        } else if (Tone.isString(url)) {
	            this._buffers[name] = new Tone.Buffer(this.baseUrl + url, callback);
	        }
	        return this;
	    };
	    /**
		 *  Clean up.
		 *  @return  {Tone.Buffers} this
		 */
	    Tone.Buffers.prototype.dispose = function () {
	        Tone.prototype.dispose.call(this);
	        for (var name in this._buffers) {
	            this._buffers[name].dispose();
	        }
	        this._buffers = null;
	        return this;
	    };
	    return Tone.Buffers;
	});
	Module(function (Tone) {
	    
	    /**
		 *  buses are another way of routing audio
		 *
		 *  augments Tone.prototype to include send and recieve
		 */
	    /**
		  *  All of the routes
		  *  
		  *  @type {Object}
		  *  @static
		  *  @private
		  */
	    var Buses = {};
	    /**
		 *  Send this signal to the channel name. 
		 *  @param  {String} channelName A named channel to send the signal to.
		 *  @param  {Decibels} amount The amount of the source to send to the bus. 
		 *  @return {GainNode} The gain node which connects this node to the desired channel. 
		 *                     Can be used to adjust the levels of the send.
		 *  @example
		 * source.send("reverb", -12);
		 */
	    Tone.prototype.send = function (channelName, amount) {
	        if (!Buses.hasOwnProperty(channelName)) {
	            Buses[channelName] = this.context.createGain();
	        }
	        amount = Tone.defaultArg(amount, 0);
	        var sendKnob = new Tone.Gain(amount, Tone.Type.Decibels);
	        this.output.chain(sendKnob, Buses[channelName]);
	        return sendKnob;
	    };
	    /**
		 *  Recieve the input from the desired channelName to the input
		 *
		 *  @param  {String} channelName A named channel to send the signal to.
		 *  @param  {Number=} channelNumber The channel to connect to
		 *  @returns {Tone} this
		 *  @example
		 * reverbEffect.receive("reverb");
		 */
	    Tone.prototype.receive = function (channelName, inputNum) {
	        if (!Buses.hasOwnProperty(channelName)) {
	            Buses[channelName] = this.context.createGain();
	        }
	        Buses[channelName].connect(this, 0, inputNum);
	        return this;
	    };
	    //remove all the send/receives when a new audio context is passed in
	    Tone.Context.on('init', function (context) {
	        if (context.Buses) {
	            Buses = context.Buses;
	        } else {
	            Buses = {};
	            context.Buses = Buses;
	        }
	    });
	    return Tone;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Tone.Draw is useful for synchronizing visuals and audio events.
		 *         Callbacks from Tone.Transport or any of the Tone.Event classes
		 *         always happen _before_ the scheduled time and are not synchronized
		 *         to the animation frame so they are not good for triggering tightly
		 *         synchronized visuals and sound. Tone.Draw makes it easy to schedule
		 *         callbacks using the AudioContext time and uses requestAnimationFrame.
		 *         
		 *  @singleton
		 *  @extends {Tone}
		 *  @example
		 * Tone.Transport.schedule(function(time){
		 * 	//use the time argument to schedule a callback with Tone.Draw
		 * 	Tone.Draw.schedule(function(){
		 * 		//do drawing or DOM manipulation here
		 * 	}, time)
		 * }, "+0.5")
		 */
	    Tone.Draw = function () {
	        Tone.call(this);
	        /**
			 *  All of the events.
			 *  @type  {Tone.Timeline}
			 *  @private
			 */
	        this._events = new Tone.Timeline();
	        /**
			 *  The duration after which events are not invoked.
			 *  @type  {Number}
			 *  @default 0.25
			 */
	        this.expiration = 0.25;
	        /**
			 *  The amount of time before the scheduled time 
			 *  that the callback can be invoked. Default is
			 *  half the time of an animation frame (0.008 seconds).
			 *  @type  {Number}
			 *  @default 0.008
			 */
	        this.anticipation = 0.008;
	        /**
			 *  The draw loop
			 *  @type  {Function}
			 *  @private
			 */
	        this._boundDrawLoop = this._drawLoop.bind(this);
	    };
	    Tone.extend(Tone.Draw);
	    /**
		 *  Schedule a function at the given time to be invoked
		 *  on the nearest animation frame.
		 *  @param  {Function}  callback  Callback is invoked at the given time.
		 *  @param  {Time}    time      The time relative to the AudioContext time
		 *                              to invoke the callback.
		 *  @return  {Tone.Draw}    this
		 */
	    Tone.Draw.prototype.schedule = function (callback, time) {
	        this._events.add({
	            callback: callback,
	            time: this.toSeconds(time)
	        });
	        //start the draw loop on the first event
	        if (this._events.length === 1) {
	            requestAnimationFrame(this._boundDrawLoop);
	        }
	        return this;
	    };
	    /**
		 *  Cancel events scheduled after the given time
		 *  @param  {Time=}  after  Time after which scheduled events will 
		 *                          be removed from the scheduling timeline.
		 *  @return  {Tone.Draw}  this
		 */
	    Tone.Draw.prototype.cancel = function (after) {
	        this._events.cancel(this.toSeconds(after));
	        return this;
	    };
	    /**
		 *  The draw loop
		 *  @private
		 */
	    Tone.Draw.prototype._drawLoop = function () {
	        var now = Tone.now();
	        while (this._events.length && this._events.peek().time - this.anticipation <= now) {
	            var event = this._events.shift();
	            if (now - event.time <= this.expiration) {
	                event.callback();
	            }
	        }
	        if (this._events.length > 0) {
	            requestAnimationFrame(this._boundDrawLoop);
	        }
	    };
	    //make a singleton
	    Tone.Draw = new Tone.Draw();
	    return Tone.Draw;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class  Both Tone.Panner3D and Tone.Listener have a position in 3D space 
		 *          using a right-handed cartesian coordinate system. 
		 *          The units used in the coordinate system are not defined; 
		 *          these coordinates are independent/invariant of any particular 
		 *          units such as meters or feet. Tone.Panner3D objects have an forward 
		 *          vector representing the direction the sound is projecting. Additionally, 
		 *          they have a sound cone representing how directional the sound is. 
		 *          For example, the sound could be omnidirectional, in which case it would 
		 *          be heard anywhere regardless of its forward, or it can be more directional 
		 *          and heard only if it is facing the listener. Tone.Listener objects 
		 *          (representing a person's ears) have an forward and up vector 
		 *          representing in which direction the person is facing. Because both the 
		 *          source stream and the listener can be moving, they both have a velocity 
		 *          vector representing both the speed and direction of movement. Taken together, 
		 *          these two velocities can be used to generate a doppler shift effect which changes the pitch.
		 *          <br><br>
		 *          Note: the position of the Listener will have no effect on nodes not connected to a Tone.Panner3D
		 *  
		 *  @constructor
		 *  @extends {Tone}
		 *  @singleton
		 */
	    Tone.Listener = function () {
	        Tone.call(this);
	        /**
			 *  Holds the current forward orientation
			 *  @type  {Array}
			 *  @private
			 */
	        this._orientation = [
	            0,
	            0,
	            0,
	            0,
	            0,
	            0
	        ];
	        /**
			 *  Holds the current position
			 *  @type  {Array}
			 *  @private
			 */
	        this._position = [
	            0,
	            0,
	            0
	        ];
	        Tone.getContext(function () {
	            // set the default position/forward
	            this.set(ListenerConstructor.defaults);
	        }.bind(this));
	    };
	    Tone.extend(Tone.Listener);
	    /**
		 *  Defaults according to the specification
		 *  @static
		 *  @const
		 *  @type {Object}
		 */
	    Tone.Listener.defaults = {
	        'positionX': 0,
	        'positionY': 0,
	        'positionZ': 0,
	        'forwardX': 0,
	        'forwardY': 0,
	        'forwardZ': 1,
	        'upX': 0,
	        'upY': 1,
	        'upZ': 0
	    };
	    /**
		 * The ramp time which is applied to the setTargetAtTime
		 * @type {Number}
		 * @private
		 */
	    Tone.Listener.prototype._rampTimeConstant = 0.01;
	    /**
		 *  Sets the position of the listener in 3d space.	
		 *  @param  {Number}  x
		 *  @param  {Number}  y
		 *  @param  {Number}  z
		 *  @return {Tone.Listener} this
		 */
	    Tone.Listener.prototype.setPosition = function (x, y, z) {
	        if (this.context.listener.positionX) {
	            var now = this.now();
	            this.context.listener.positionX.setTargetAtTime(x, now, this._rampTimeConstant);
	            this.context.listener.positionY.setTargetAtTime(y, now, this._rampTimeConstant);
	            this.context.listener.positionZ.setTargetAtTime(z, now, this._rampTimeConstant);
	        } else {
	            this.context.listener.setPosition(x, y, z);
	        }
	        this._position = Array.prototype.slice.call(arguments);
	        return this;
	    };
	    /**
		 *  Sets the orientation of the listener using two vectors, the forward
		 *  vector (which direction the listener is facing) and the up vector 
		 *  (which the up direction of the listener). An up vector
		 *  of 0, 0, 1 is equivalent to the listener standing up in the Z direction. 
		 *  @param  {Number}  x
		 *  @param  {Number}  y
		 *  @param  {Number}  z
		 *  @param  {Number}  upX
		 *  @param  {Number}  upY
		 *  @param  {Number}  upZ
		 *  @return {Tone.Listener} this
		 */
	    Tone.Listener.prototype.setOrientation = function (x, y, z, upX, upY, upZ) {
	        if (this.context.listener.forwardX) {
	            var now = this.now();
	            this.context.listener.forwardX.setTargetAtTime(x, now, this._rampTimeConstant);
	            this.context.listener.forwardY.setTargetAtTime(y, now, this._rampTimeConstant);
	            this.context.listener.forwardZ.setTargetAtTime(z, now, this._rampTimeConstant);
	            this.context.listener.upX.setTargetAtTime(upX, now, this._rampTimeConstant);
	            this.context.listener.upY.setTargetAtTime(upY, now, this._rampTimeConstant);
	            this.context.listener.upZ.setTargetAtTime(upZ, now, this._rampTimeConstant);
	        } else {
	            this.context.listener.setOrientation(x, y, z, upX, upY, upZ);
	        }
	        this._orientation = Array.prototype.slice.call(arguments);
	        return this;
	    };
	    /**
		 *  The x position of the panner object.
		 *  @type {Number}
		 *  @memberOf Tone.Listener#
		 *  @name positionX
		 */
	    Object.defineProperty(Tone.Listener.prototype, 'positionX', {
	        set: function (pos) {
	            this._position[0] = pos;
	            this.setPosition.apply(this, this._position);
	        },
	        get: function () {
	            return this._position[0];
	        }
	    });
	    /**
		 *  The y position of the panner object.
		 *  @type {Number}
		 *  @memberOf Tone.Listener#
		 *  @name positionY
		 */
	    Object.defineProperty(Tone.Listener.prototype, 'positionY', {
	        set: function (pos) {
	            this._position[1] = pos;
	            this.setPosition.apply(this, this._position);
	        },
	        get: function () {
	            return this._position[1];
	        }
	    });
	    /**
		 *  The z position of the panner object.
		 *  @type {Number}
		 *  @memberOf Tone.Listener#
		 *  @name positionZ
		 */
	    Object.defineProperty(Tone.Listener.prototype, 'positionZ', {
	        set: function (pos) {
	            this._position[2] = pos;
	            this.setPosition.apply(this, this._position);
	        },
	        get: function () {
	            return this._position[2];
	        }
	    });
	    /**
		 *  The x coordinate of the listeners front direction. i.e. 
		 *  which way they are facing.
		 *  @type {Number}
		 *  @memberOf Tone.Listener#
		 *  @name forwardX
		 */
	    Object.defineProperty(Tone.Listener.prototype, 'forwardX', {
	        set: function (pos) {
	            this._orientation[0] = pos;
	            this.setOrientation.apply(this, this._orientation);
	        },
	        get: function () {
	            return this._orientation[0];
	        }
	    });
	    /**
		 *  The y coordinate of the listeners front direction. i.e. 
		 *  which way they are facing.
		 *  @type {Number}
		 *  @memberOf Tone.Listener#
		 *  @name forwardY
		 */
	    Object.defineProperty(Tone.Listener.prototype, 'forwardY', {
	        set: function (pos) {
	            this._orientation[1] = pos;
	            this.setOrientation.apply(this, this._orientation);
	        },
	        get: function () {
	            return this._orientation[1];
	        }
	    });
	    /**
		 *  The z coordinate of the listeners front direction. i.e. 
		 *  which way they are facing.
		 *  @type {Number}
		 *  @memberOf Tone.Listener#
		 *  @name forwardZ
		 */
	    Object.defineProperty(Tone.Listener.prototype, 'forwardZ', {
	        set: function (pos) {
	            this._orientation[2] = pos;
	            this.setOrientation.apply(this, this._orientation);
	        },
	        get: function () {
	            return this._orientation[2];
	        }
	    });
	    /**
		 *  The x coordinate of the listener's up direction. i.e.
		 *  the direction the listener is standing in.
		 *  @type {Number}
		 *  @memberOf Tone.Listener#
		 *  @name upX
		 */
	    Object.defineProperty(Tone.Listener.prototype, 'upX', {
	        set: function (pos) {
	            this._orientation[3] = pos;
	            this.setOrientation.apply(this, this._orientation);
	        },
	        get: function () {
	            return this._orientation[3];
	        }
	    });
	    /**
		 *  The y coordinate of the listener's up direction. i.e.
		 *  the direction the listener is standing in.
		 *  @type {Number}
		 *  @memberOf Tone.Listener#
		 *  @name upY
		 */
	    Object.defineProperty(Tone.Listener.prototype, 'upY', {
	        set: function (pos) {
	            this._orientation[4] = pos;
	            this.setOrientation.apply(this, this._orientation);
	        },
	        get: function () {
	            return this._orientation[4];
	        }
	    });
	    /**
		 *  The z coordinate of the listener's up direction. i.e.
		 *  the direction the listener is standing in.
		 *  @type {Number}
		 *  @memberOf Tone.Listener#
		 *  @name upZ
		 */
	    Object.defineProperty(Tone.Listener.prototype, 'upZ', {
	        set: function (pos) {
	            this._orientation[5] = pos;
	            this.setOrientation.apply(this, this._orientation);
	        },
	        get: function () {
	            return this._orientation[5];
	        }
	    });
	    /**
		 *  Clean up.
		 *  @returns {Tone.Listener} this
		 */
	    Tone.Listener.prototype.dispose = function () {
	        this._orientation = null;
	        this._position = null;
	        return this;
	    };
	    //SINGLETON SETUP
	    var ListenerConstructor = Tone.Listener;
	    Tone.Listener = new ListenerConstructor();
	    Tone.Context.on('init', function (context) {
	        if (context.Listener instanceof ListenerConstructor) {
	            //a single listener object
	            Tone.Listener = context.Listener;
	        } else {
	            //make new Listener insides
	            Tone.Listener = new ListenerConstructor();
	        }
	        context.Listener = Tone.Listener;
	    });
	    //END SINGLETON SETUP
	    return Tone.Listener;
	});
	Module(function (Tone) {
	    /**
		 *  shim
		 *  @private
		 */
	    if (!window.hasOwnProperty('OfflineAudioContext') && window.hasOwnProperty('webkitOfflineAudioContext')) {
	        window.OfflineAudioContext = window.webkitOfflineAudioContext;
	    }
	    /**
		 *  @class Wrapper around the OfflineAudioContext
		 *  @extends {Tone.Context}
		 *  @param  {Number}  channels  The number of channels to render
		 *  @param  {Number}  duration  The duration to render in samples
		 *  @param {Number} sampleRate the sample rate to render at
		 */
	    Tone.OfflineContext = function (channels, duration, sampleRate) {
	        /**
			 *  The offline context
			 *  @private
			 *  @type  {OfflineAudioContext}
			 */
	        var offlineContext = new OfflineAudioContext(channels, duration * sampleRate, sampleRate);
	        //wrap the methods/members
	        Tone.Context.call(this, {
	            'context': offlineContext,
	            'clockSource': 'offline',
	            'lookAhead': 0,
	            'updateInterval': 128 / sampleRate
	        });
	        /**
			 *  A private reference to the duration
			 *  @private
			 *  @type  {Number}
			 */
	        this._duration = duration;
	        /**
			 *  An artificial clock source
			 *  @type  {Number}
			 *  @private
			 */
	        this._currentTime = 0;
	    };
	    Tone.extend(Tone.OfflineContext, Tone.Context);
	    /**
		 *  Override the now method to point to the internal clock time
		 *  @return  {Number}
		 */
	    Tone.OfflineContext.prototype.now = function () {
	        return this._currentTime;
	    };
	    /**
		 *  Render the output of the OfflineContext
		 *  @return  {Promise}
		 */
	    Tone.OfflineContext.prototype.render = function () {
	        while (this._duration - this._currentTime >= 0) {
	            //invoke all the callbacks on that time
	            this.emit('tick');
	            //increment the clock
	            this._currentTime += this.blockTime;
	        }
	        //promise returned is not yet implemented in all browsers
	        return new Promise(function (done) {
	            this._context.oncomplete = function (e) {
	                done(e.renderedBuffer);
	            };
	            this._context.startRendering();
	        }.bind(this));
	    };
	    /**
		 *  Close the context
		 *  @return  {Number}
		 */
	    Tone.OfflineContext.prototype.close = function () {
	        this._context = null;
	    };
	    return Tone.OfflineContext;
	});
	Module(function (Tone) {
	    /**
		 *  Generate a buffer by rendering all of the Tone.js code within the callback using the OfflineAudioContext. 
		 *  The OfflineAudioContext is capable of rendering much faster than real time in many cases. 
		 *  The callback function also passes in an offline instance of Tone.Transport which can be used
		 *  to schedule events along the Transport. 
		 *  @param  {Function}  callback  All Tone.js nodes which are created and scheduled within this callback are recorded into the output Buffer.
		 *  @param  {Time}  duration     the amount of time to record for.
		 *  @return  {Promise}  The promise which is invoked with the Tone.Buffer of the recorded output.
		 *  @example
		 * //render 2 seconds of the oscillator
		 * Tone.Offline(function(){
		 * 	//only nodes created in this callback will be recorded
		 * 	var oscillator = new Tone.Oscillator().toMaster().start(0)
		 * 	//schedule their events
		 * }, 2).then(function(buffer){
		 * 	//do something with the output buffer
		 * })
		 * @example
		 * //can also schedule events along the Transport
		 * //using the passed in Offline Transport
		 * Tone.Offline(function(Transport){
		 * 	var osc = new Tone.Oscillator().toMaster()
		 * 	Transport.schedule(function(time){
		 * 		osc.start(time).stop(time + 0.1)
		 * 	}, 1)
		 * 	Transport.start(0.2)
		 * }, 4).then(function(buffer){
		 * 	//do something with the output buffer
		 * })
		 */
	    Tone.Offline = function (callback, duration) {
	        //set the OfflineAudioContext
	        var sampleRate = Tone.context.sampleRate;
	        var originalContext = Tone.context;
	        var context = new Tone.OfflineContext(2, duration, sampleRate);
	        Tone.context = context;
	        //invoke the callback/scheduling
	        callback(Tone.Transport);
	        //process the audio
	        var rendered = context.render();
	        //return the original AudioContext
	        Tone.context = originalContext;
	        //return the audio
	        return rendered.then(function (buffer) {
	            //wrap it in a Tone.Buffer
	            return new Tone.Buffer(buffer);
	        });
	    };
	    return Tone.Offline;
	});
	Module(function (Tone) {
	    
	    /**
		 * 	@class  Tone.Effect is the base class for effects. Connect the effect between
		 * 	        the effectSend and effectReturn GainNodes, then control the amount of
		 * 	        effect which goes to the output using the wet control.
		 *
		 *  @constructor
		 *  @extends {Tone.AudioNode}
		 *  @param {NormalRange|Object} [wet] The starting wet value.
		 */
	    Tone.Effect = function () {
	        var options = Tone.defaults(arguments, ['wet'], Tone.Effect);
	        Tone.AudioNode.call(this);
	        this.createInsOuts(1, 1);
	        /**
			 *  the drywet knob to control the amount of effect
			 *  @type {Tone.CrossFade}
			 *  @private
			 */
	        this._dryWet = new Tone.CrossFade(options.wet);
	        /**
			 *  The wet control is how much of the effected
			 *  will pass through to the output. 1 = 100% effected
			 *  signal, 0 = 100% dry signal.
			 *  @type {NormalRange}
			 *  @signal
			 */
	        this.wet = this._dryWet.fade;
	        /**
			 *  connect the effectSend to the input of hte effect
			 *  @type {Tone.Gain}
			 *  @private
			 */
	        this.effectSend = new Tone.Gain();
	        /**
			 *  connect the output of the effect to the effectReturn
			 *  @type {Tone.Gain}
			 *  @private
			 */
	        this.effectReturn = new Tone.Gain();
	        //connections
	        this.input.connect(this._dryWet.a);
	        this.input.connect(this.effectSend);
	        this.effectReturn.connect(this._dryWet.b);
	        this._dryWet.connect(this.output);
	        this._readOnly(['wet']);
	    };
	    Tone.extend(Tone.Effect, Tone.AudioNode);
	    /**
		 *  @static
		 *  @type {Object}
		 */
	    Tone.Effect.defaults = { 'wet': 1 };
	    /**
		 *  chains the effect in between the effectSend and effectReturn
		 *  @param  {Tone} effect
		 *  @private
		 *  @returns {Tone.Effect} this
		 */
	    Tone.Effect.prototype.connectEffect = function (effect) {
	        this.effectSend.chain(effect, this.effectReturn);
	        return this;
	    };
	    /**
		 *  Clean up.
		 *  @returns {Tone.Effect} this
		 */
	    Tone.Effect.prototype.dispose = function () {
	        Tone.AudioNode.prototype.dispose.call(this);
	        this._dryWet.dispose();
	        this._dryWet = null;
	        this.effectSend.dispose();
	        this.effectSend = null;
	        this.effectReturn.dispose();
	        this.effectReturn = null;
	        this._writable(['wet']);
	        this.wet = null;
	        return this;
	    };
	    return Tone.Effect;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Tone.AutoFilter is a Tone.Filter with a Tone.LFO connected to the filter cutoff frequency.
		 *         Setting the LFO rate and depth allows for control over the filter modulation rate 
		 *         and depth.
		 *
		 *  @constructor
		 *  @extends {Tone.Effect}
		 *  @param {Time|Object} [frequency] The rate of the LFO.
		 *  @param {Frequency=} baseFrequency The lower value of the LFOs oscillation
	 	 *  @param {Frequency=} octaves The number of octaves above the baseFrequency
		 *  @example
		 * //create an autofilter and start it's LFO
		 * var autoFilter = new Tone.AutoFilter("4n").toMaster().start();
		 * //route an oscillator through the filter and start it
		 * var oscillator = new Tone.Oscillator().connect(autoFilter).start();
		 */
	    Tone.AutoFilter = function () {
	        var options = Tone.defaults(arguments, [
	            'frequency',
	            'baseFrequency',
	            'octaves'
	        ], Tone.AutoFilter);
	        Tone.Effect.call(this, options);
	        /**
			 *  the lfo which drives the filter cutoff
			 *  @type {Tone.LFO}
			 *  @private
			 */
	        this._lfo = new Tone.LFO({
	            'frequency': options.frequency,
	            'amplitude': options.depth
	        });
	        /**
			 * The range of the filter modulating between the min and max frequency. 
			 * 0 = no modulation. 1 = full modulation.
			 * @type {NormalRange}
			 * @signal
			 */
	        this.depth = this._lfo.amplitude;
	        /**
			 * How fast the filter modulates between min and max. 
			 * @type {Frequency}
			 * @signal
			 */
	        this.frequency = this._lfo.frequency;
	        /**
			 *  The filter node
			 *  @type {Tone.Filter}
			 */
	        this.filter = new Tone.Filter(options.filter);
	        /**
			 *  The octaves placeholder
			 *  @type {Positive}
			 *  @private
			 */
	        this._octaves = 0;
	        //connections
	        this.connectEffect(this.filter);
	        this._lfo.connect(this.filter.frequency);
	        this.type = options.type;
	        this._readOnly([
	            'frequency',
	            'depth'
	        ]);
	        this.octaves = options.octaves;
	        this.baseFrequency = options.baseFrequency;
	    };
	    //extend Effect
	    Tone.extend(Tone.AutoFilter, Tone.Effect);
	    /**
		 *  defaults
		 *  @static
		 *  @type {Object}
		 */
	    Tone.AutoFilter.defaults = {
	        'frequency': 1,
	        'type': 'sine',
	        'depth': 1,
	        'baseFrequency': 200,
	        'octaves': 2.6,
	        'filter': {
	            'type': 'lowpass',
	            'rolloff': -12,
	            'Q': 1
	        }
	    };
	    /**
		 * Start the effect.
		 * @param {Time} [time=now] When the LFO will start. 
		 * @returns {Tone.AutoFilter} this
		 */
	    Tone.AutoFilter.prototype.start = function (time) {
	        this._lfo.start(time);
	        return this;
	    };
	    /**
		 * Stop the effect.
		 * @param {Time} [time=now] When the LFO will stop. 
		 * @returns {Tone.AutoFilter} this
		 */
	    Tone.AutoFilter.prototype.stop = function (time) {
	        this._lfo.stop(time);
	        return this;
	    };
	    /**
		 * Sync the filter to the transport.
		 * @param {Time} [delay=0] Delay time before starting the effect after the
		 *                               Transport has started. 
		 * @returns {Tone.AutoFilter} this
		 */
	    Tone.AutoFilter.prototype.sync = function (delay) {
	        this._lfo.sync(delay);
	        return this;
	    };
	    /**
		 * Unsync the filter from the transport.
		 * @returns {Tone.AutoFilter} this
		 */
	    Tone.AutoFilter.prototype.unsync = function () {
	        this._lfo.unsync();
	        return this;
	    };
	    /**
		 * Type of oscillator attached to the AutoFilter. 
		 * Possible values: "sine", "square", "triangle", "sawtooth".
		 * @memberOf Tone.AutoFilter#
		 * @type {string}
		 * @name type
		 */
	    Object.defineProperty(Tone.AutoFilter.prototype, 'type', {
	        get: function () {
	            return this._lfo.type;
	        },
	        set: function (type) {
	            this._lfo.type = type;
	        }
	    });
	    /**
		 * The minimum value of the filter's cutoff frequency.
		 * @memberOf Tone.AutoFilter#
		 * @type {Frequency}
		 * @name min
		 */
	    Object.defineProperty(Tone.AutoFilter.prototype, 'baseFrequency', {
	        get: function () {
	            return this._lfo.min;
	        },
	        set: function (freq) {
	            this._lfo.min = this.toFrequency(freq);
	            //and set the max
	            this.octaves = this._octaves;
	        }
	    });
	    /**
		 * The maximum value of the filter's cutoff frequency. 
		 * @memberOf Tone.AutoFilter#
		 * @type {Positive}
		 * @name octaves
		 */
	    Object.defineProperty(Tone.AutoFilter.prototype, 'octaves', {
	        get: function () {
	            return this._octaves;
	        },
	        set: function (oct) {
	            this._octaves = oct;
	            this._lfo.max = this.baseFrequency * Math.pow(2, oct);
	        }
	    });
	    /**
		 *  Clean up. 
		 *  @returns {Tone.AutoFilter} this
		 */
	    Tone.AutoFilter.prototype.dispose = function () {
	        Tone.Effect.prototype.dispose.call(this);
	        this._lfo.dispose();
	        this._lfo = null;
	        this.filter.dispose();
	        this.filter = null;
	        this._writable([
	            'frequency',
	            'depth'
	        ]);
	        this.frequency = null;
	        this.depth = null;
	        return this;
	    };
	    return Tone.AutoFilter;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Tone.AutoPanner is a Tone.Panner with an LFO connected to the pan amount. 
		 *         More on using autopanners [here](https://www.ableton.com/en/blog/autopan-chopper-effect-and-more-liveschool/).
		 *
		 *  @constructor
		 *  @extends {Tone.Effect}
		 *  @param {Frequency|Object} [frequency] Rate of left-right oscillation. 
		 *  @example
		 * //create an autopanner and start it's LFO
		 * var autoPanner = new Tone.AutoPanner("4n").toMaster().start();
		 * //route an oscillator through the panner and start it
		 * var oscillator = new Tone.Oscillator().connect(autoPanner).start();
		 */
	    Tone.AutoPanner = function () {
	        var options = Tone.defaults(arguments, ['frequency'], Tone.AutoPanner);
	        Tone.Effect.call(this, options);
	        /**
			 *  the lfo which drives the panning
			 *  @type {Tone.LFO}
			 *  @private
			 */
	        this._lfo = new Tone.LFO({
	            'frequency': options.frequency,
	            'amplitude': options.depth,
	            'min': -1,
	            'max': 1
	        });
	        /**
			 * The amount of panning between left and right. 
			 * 0 = always center. 1 = full range between left and right. 
			 * @type {NormalRange}
			 * @signal
			 */
	        this.depth = this._lfo.amplitude;
	        /**
			 *  the panner node which does the panning
			 *  @type {Tone.Panner}
			 *  @private
			 */
	        this._panner = new Tone.Panner();
	        /**
			 * How fast the panner modulates between left and right. 
			 * @type {Frequency}
			 * @signal
			 */
	        this.frequency = this._lfo.frequency;
	        //connections
	        this.connectEffect(this._panner);
	        this._lfo.connect(this._panner.pan);
	        this.type = options.type;
	        this._readOnly([
	            'depth',
	            'frequency'
	        ]);
	    };
	    //extend Effect
	    Tone.extend(Tone.AutoPanner, Tone.Effect);
	    /**
		 *  defaults
		 *  @static
		 *  @type {Object}
		 */
	    Tone.AutoPanner.defaults = {
	        'frequency': 1,
	        'type': 'sine',
	        'depth': 1
	    };
	    /**
		 * Start the effect.
		 * @param {Time} [time=now] When the LFO will start. 
		 * @returns {Tone.AutoPanner} this
		 */
	    Tone.AutoPanner.prototype.start = function (time) {
	        this._lfo.start(time);
	        return this;
	    };
	    /**
		 * Stop the effect.
		 * @param {Time} [time=now] When the LFO will stop. 
		 * @returns {Tone.AutoPanner} this
		 */
	    Tone.AutoPanner.prototype.stop = function (time) {
	        this._lfo.stop(time);
	        return this;
	    };
	    /**
		 * Sync the panner to the transport.
		 * @param {Time} [delay=0] Delay time before starting the effect after the
		 *                               Transport has started. 
		 * @returns {Tone.AutoPanner} this
		 */
	    Tone.AutoPanner.prototype.sync = function (delay) {
	        this._lfo.sync(delay);
	        return this;
	    };
	    /**
		 * Unsync the panner from the transport
		 * @returns {Tone.AutoPanner} this
		 */
	    Tone.AutoPanner.prototype.unsync = function () {
	        this._lfo.unsync();
	        return this;
	    };
	    /**
		 * Type of oscillator attached to the AutoFilter. 
		 * Possible values: "sine", "square", "triangle", "sawtooth".
		 * @memberOf Tone.AutoFilter#
		 * @type {string}
		 * @name type
		 */
	    Object.defineProperty(Tone.AutoPanner.prototype, 'type', {
	        get: function () {
	            return this._lfo.type;
	        },
	        set: function (type) {
	            this._lfo.type = type;
	        }
	    });
	    /**
		 *  clean up
		 *  @returns {Tone.AutoPanner} this
		 */
	    Tone.AutoPanner.prototype.dispose = function () {
	        Tone.Effect.prototype.dispose.call(this);
	        this._lfo.dispose();
	        this._lfo = null;
	        this._panner.dispose();
	        this._panner = null;
	        this._writable([
	            'depth',
	            'frequency'
	        ]);
	        this.frequency = null;
	        this.depth = null;
	        return this;
	    };
	    return Tone.AutoPanner;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class  Tone.AutoWah connects a Tone.Follower to a bandpass filter (Tone.Filter).
		 *          The frequency of the filter is adjusted proportionally to the 
		 *          incoming signal's amplitude. Inspiration from [Tuna.js](https://github.com/Dinahmoe/tuna).
		 *
		 *  @constructor
		 *  @extends {Tone.Effect}
		 *  @param {Frequency|Object} [baseFrequency] The frequency the filter is set 
		 *                                            to at the low point of the wah
		 *  @param {Positive} [octaves] The number of octaves above the baseFrequency
		 *                                the filter will sweep to when fully open
		 *  @param {Decibels} [sensitivity] The decibel threshold sensitivity for 
		 *                                   the incoming signal. Normal range of -40 to 0. 
		 *  @example
		 * var autoWah = new Tone.AutoWah(50, 6, -30).toMaster();
		 * //initialize the synth and connect to autowah
		 * var synth = new Synth.connect(autoWah);
		 * //Q value influences the effect of the wah - default is 2
		 * autoWah.Q.value = 6;
		 * //more audible on higher notes
		 * synth.triggerAttackRelease("C4", "8n")
		 */
	    Tone.AutoWah = function () {
	        var options = Tone.defaults(arguments, [
	            'baseFrequency',
	            'octaves',
	            'sensitivity'
	        ], Tone.AutoWah);
	        Tone.Effect.call(this, options);
	        /**
			 *  The envelope follower. Set the attack/release
			 *  timing to adjust how the envelope is followed. 
			 *  @type {Tone.Follower}
			 *  @private
			 */
	        this.follower = new Tone.Follower(options.follower);
	        /**
			 *  scales the follower value to the frequency domain
			 *  @type {Tone}
			 *  @private
			 */
	        this._sweepRange = new Tone.ScaleExp(0, 1, 0.5);
	        /**
			 *  @type {number}
			 *  @private
			 */
	        this._baseFrequency = options.baseFrequency;
	        /**
			 *  @type {number}
			 *  @private
			 */
	        this._octaves = options.octaves;
	        /**
			 *  the input gain to adjust the sensitivity
			 *  @type {Tone.Gain}
			 *  @private
			 */
	        this._inputBoost = new Tone.Gain();
	        /**
			 *  @type {BiquadFilterNode}
			 *  @private
			 */
	        this._bandpass = new Tone.Filter({
	            'rolloff': -48,
	            'frequency': 0,
	            'Q': options.Q
	        });
	        /**
			 *  @type {Tone.Filter}
			 *  @private
			 */
	        this._peaking = new Tone.Filter(0, 'peaking');
	        this._peaking.gain.value = options.gain;
	        /**
			 * The gain of the filter.
			 * @type {Number}
			 * @signal
			 */
	        this.gain = this._peaking.gain;
	        /**
			 * The quality of the filter.
			 * @type {Positive}
			 * @signal
			 */
	        this.Q = this._bandpass.Q;
	        //the control signal path
	        this.effectSend.chain(this._inputBoost, this.follower, this._sweepRange);
	        this._sweepRange.connect(this._bandpass.frequency);
	        this._sweepRange.connect(this._peaking.frequency);
	        //the filtered path
	        this.effectSend.chain(this._bandpass, this._peaking, this.effectReturn);
	        //set the initial value
	        this._setSweepRange();
	        this.sensitivity = options.sensitivity;
	        this._readOnly([
	            'gain',
	            'Q'
	        ]);
	    };
	    Tone.extend(Tone.AutoWah, Tone.Effect);
	    /**
		 *  @static
		 *  @type {Object}
		 */
	    Tone.AutoWah.defaults = {
	        'baseFrequency': 100,
	        'octaves': 6,
	        'sensitivity': 0,
	        'Q': 2,
	        'gain': 2,
	        'follower': {
	            'attack': 0.3,
	            'release': 0.5
	        }
	    };
	    /**
		 * The number of octaves that the filter will sweep above the 
		 * baseFrequency. 
		 * @memberOf Tone.AutoWah#
		 * @type {Number}
		 * @name octaves
		 */
	    Object.defineProperty(Tone.AutoWah.prototype, 'octaves', {
	        get: function () {
	            return this._octaves;
	        },
	        set: function (octaves) {
	            this._octaves = octaves;
	            this._setSweepRange();
	        }
	    });
	    /**
		 * The base frequency from which the sweep will start from.
		 * @memberOf Tone.AutoWah#
		 * @type {Frequency}
		 * @name baseFrequency
		 */
	    Object.defineProperty(Tone.AutoWah.prototype, 'baseFrequency', {
	        get: function () {
	            return this._baseFrequency;
	        },
	        set: function (baseFreq) {
	            this._baseFrequency = baseFreq;
	            this._setSweepRange();
	        }
	    });
	    /**
		 * The sensitivity to control how responsive to the input signal the filter is. 
		 * @memberOf Tone.AutoWah#
		 * @type {Decibels}
		 * @name sensitivity
		 */
	    Object.defineProperty(Tone.AutoWah.prototype, 'sensitivity', {
	        get: function () {
	            return Tone.gainToDb(1 / this._inputBoost.gain.value);
	        },
	        set: function (sensitivy) {
	            this._inputBoost.gain.value = 1 / Tone.dbToGain(sensitivy);
	        }
	    });
	    /**
		 *  sets the sweep range of the scaler
		 *  @private
		 */
	    Tone.AutoWah.prototype._setSweepRange = function () {
	        this._sweepRange.min = this._baseFrequency;
	        this._sweepRange.max = Math.min(this._baseFrequency * Math.pow(2, this._octaves), this.context.sampleRate / 2);
	    };
	    /**
		 *  Clean up.
		 *  @returns {Tone.AutoWah} this
		 */
	    Tone.AutoWah.prototype.dispose = function () {
	        Tone.Effect.prototype.dispose.call(this);
	        this.follower.dispose();
	        this.follower = null;
	        this._sweepRange.dispose();
	        this._sweepRange = null;
	        this._bandpass.dispose();
	        this._bandpass = null;
	        this._peaking.dispose();
	        this._peaking = null;
	        this._inputBoost.dispose();
	        this._inputBoost = null;
	        this._writable([
	            'gain',
	            'Q'
	        ]);
	        this.gain = null;
	        this.Q = null;
	        return this;
	    };
	    return Tone.AutoWah;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Tone.Bitcrusher downsamples the incoming signal to a different bitdepth. 
		 *         Lowering the bitdepth of the signal creates distortion. Read more about Bitcrushing
		 *         on [Wikipedia](https://en.wikipedia.org/wiki/Bitcrusher).
		 *
		 *  @constructor
		 *  @extends {Tone.Effect}
		 *  @param {Number} bits The number of bits to downsample the signal. Nominal range
		 *                       of 1 to 8. 
		 *  @example
		 * //initialize crusher and route a synth through it
		 * var crusher = new Tone.BitCrusher(4).toMaster();
		 * var synth = new Tone.MonoSynth().connect(crusher);
		 */
	    Tone.BitCrusher = function () {
	        var options = Tone.defaults(arguments, ['bits'], Tone.BitCrusher);
	        Tone.Effect.call(this, options);
	        var invStepSize = 1 / Math.pow(2, options.bits - 1);
	        /**
			 *  Subtract the input signal and the modulus of the input signal
			 *  @type {Tone.Subtract}
			 *  @private
			 */
	        this._subtract = new Tone.Subtract();
	        /**
			 *  The mod function
			 *  @type  {Tone.Modulo}
			 *  @private
			 */
	        this._modulo = new Tone.Modulo(invStepSize);
	        /**
			 *  keeps track of the bits
			 *  @type {number}
			 *  @private
			 */
	        this._bits = options.bits;
	        //connect it up
	        this.effectSend.fan(this._subtract, this._modulo);
	        this._modulo.connect(this._subtract, 0, 1);
	        this._subtract.connect(this.effectReturn);
	    };
	    Tone.extend(Tone.BitCrusher, Tone.Effect);
	    /**
		 *  the default values
		 *  @static
		 *  @type {Object}
		 */
	    Tone.BitCrusher.defaults = { 'bits': 4 };
	    /**
		 * The bit depth of the effect. Nominal range of 1-8. 
		 * @memberOf Tone.BitCrusher#
		 * @type {number}
		 * @name bits
		 */
	    Object.defineProperty(Tone.BitCrusher.prototype, 'bits', {
	        get: function () {
	            return this._bits;
	        },
	        set: function (bits) {
	            this._bits = bits;
	            var invStepSize = 1 / Math.pow(2, bits - 1);
	            this._modulo.value = invStepSize;
	        }
	    });
	    /**
		 *  Clean up. 
		 *  @returns {Tone.BitCrusher} this
		 */
	    Tone.BitCrusher.prototype.dispose = function () {
	        Tone.Effect.prototype.dispose.call(this);
	        this._subtract.dispose();
	        this._subtract = null;
	        this._modulo.dispose();
	        this._modulo = null;
	        return this;
	    };
	    return Tone.BitCrusher;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Tone.ChebyShev is a Chebyshev waveshaper, an effect which is good 
		 *         for making different types of distortion sounds.
		 *         Note that odd orders sound very different from even ones, 
		 *         and order = 1 is no change. 
		 *         Read more at [music.columbia.edu](http://music.columbia.edu/cmc/musicandcomputers/chapter4/04_06.php).
		 *
		 *  @extends {Tone.Effect}
		 *  @constructor
		 *  @param {Positive|Object} [order] The order of the chebyshev polynomial. Normal range between 1-100. 
		 *  @example
		 * //create a new cheby
		 * var cheby = new Tone.Chebyshev(50);
		 * //create a monosynth connected to our cheby
		 * synth = new Tone.MonoSynth().connect(cheby);
		 */
	    Tone.Chebyshev = function () {
	        var options = Tone.defaults(arguments, ['order'], Tone.Chebyshev);
	        Tone.Effect.call(this, options);
	        /**
			 *  @type {WaveShaperNode}
			 *  @private
			 */
	        this._shaper = new Tone.WaveShaper(4096);
	        /**
			 * holds onto the order of the filter
			 * @type {number}
			 * @private
			 */
	        this._order = options.order;
	        this.connectEffect(this._shaper);
	        this.order = options.order;
	        this.oversample = options.oversample;
	    };
	    Tone.extend(Tone.Chebyshev, Tone.Effect);
	    /**
		 *  @static
		 *  @const
		 *  @type {Object}
		 */
	    Tone.Chebyshev.defaults = {
	        'order': 1,
	        'oversample': 'none'
	    };
	    /**
		 *  get the coefficient for that degree
		 *  @param {number} x the x value
		 *  @param   {number} degree 
		 *  @param {Object} memo memoize the computed value. 
		 *                       this speeds up computation greatly. 
		 *  @return  {number}       the coefficient 
		 *  @private
		 */
	    Tone.Chebyshev.prototype._getCoefficient = function (x, degree, memo) {
	        if (memo.hasOwnProperty(degree)) {
	            return memo[degree];
	        } else if (degree === 0) {
	            memo[degree] = 0;
	        } else if (degree === 1) {
	            memo[degree] = x;
	        } else {
	            memo[degree] = 2 * x * this._getCoefficient(x, degree - 1, memo) - this._getCoefficient(x, degree - 2, memo);
	        }
	        return memo[degree];
	    };
	    /**
		 * The order of the Chebyshev polynomial which creates
		 * the equation which is applied to the incoming 
		 * signal through a Tone.WaveShaper. The equations
		 * are in the form:<br>
		 * order 2: 2x^2 + 1<br>
		 * order 3: 4x^3 + 3x <br>
		 * @memberOf Tone.Chebyshev#
		 * @type {Positive}
		 * @name order
		 */
	    Object.defineProperty(Tone.Chebyshev.prototype, 'order', {
	        get: function () {
	            return this._order;
	        },
	        set: function (order) {
	            this._order = order;
	            var curve = new Array(4096);
	            var len = curve.length;
	            for (var i = 0; i < len; ++i) {
	                var x = i * 2 / len - 1;
	                if (x === 0) {
	                    //should output 0 when input is 0
	                    curve[i] = 0;
	                } else {
	                    curve[i] = this._getCoefficient(x, order, {});
	                }
	            }
	            this._shaper.curve = curve;
	        }
	    });
	    /**
		 * The oversampling of the effect. Can either be "none", "2x" or "4x".
		 * @memberOf Tone.Chebyshev#
		 * @type {string}
		 * @name oversample
		 */
	    Object.defineProperty(Tone.Chebyshev.prototype, 'oversample', {
	        get: function () {
	            return this._shaper.oversample;
	        },
	        set: function (oversampling) {
	            this._shaper.oversample = oversampling;
	        }
	    });
	    /**
		 *  Clean up. 
		 *  @returns {Tone.Chebyshev} this
		 */
	    Tone.Chebyshev.prototype.dispose = function () {
	        Tone.Effect.prototype.dispose.call(this);
	        this._shaper.dispose();
	        this._shaper = null;
	        return this;
	    };
	    return Tone.Chebyshev;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Base class for Stereo effects. Provides effectSendL/R and effectReturnL/R.
		 *
		 *	@constructor
		 *	@extends {Tone.Effect}
		 */
	    Tone.StereoEffect = function () {
	        //get the defaults
	        Tone.AudioNode.call(this);
	        var options = Tone.defaults(arguments, ['wet'], Tone.Effect);
	        this.createInsOuts(1, 1);
	        /**
			 *  the drywet knob to control the amount of effect
			 *  @type {Tone.CrossFade}
			 *  @private
			 */
	        this._dryWet = new Tone.CrossFade(options.wet);
	        /**
			 *  The wet control, i.e. how much of the effected
			 *  will pass through to the output.
			 *  @type {NormalRange}
			 *  @signal
			 */
	        this.wet = this._dryWet.fade;
	        /**
			 *  then split it
			 *  @type {Tone.Split}
			 *  @private
			 */
	        this._split = new Tone.Split();
	        /**
			 *  the effects send LEFT
			 *  @type {GainNode}
			 *  @private
			 */
	        this.effectSendL = this._split.left;
	        /**
			 *  the effects send RIGHT
			 *  @type {GainNode}
			 *  @private
			 */
	        this.effectSendR = this._split.right;
	        /**
			 *  the stereo effect merger
			 *  @type {Tone.Merge}
			 *  @private
			 */
	        this._merge = new Tone.Merge();
	        /**
			 *  the effect return LEFT
			 *  @type {GainNode}
			 *  @private
			 */
	        this.effectReturnL = this._merge.left;
	        /**
			 *  the effect return RIGHT
			 *  @type {GainNode}
			 *  @private
			 */
	        this.effectReturnR = this._merge.right;
	        //connections
	        this.input.connect(this._split);
	        //dry wet connections
	        this.input.connect(this._dryWet, 0, 0);
	        this._merge.connect(this._dryWet, 0, 1);
	        this._dryWet.connect(this.output);
	        this._readOnly(['wet']);
	    };
	    Tone.extend(Tone.StereoEffect, Tone.Effect);
	    /**
		 *  Clean up.
		 *  @returns {Tone.StereoEffect} this
		 */
	    Tone.StereoEffect.prototype.dispose = function () {
	        Tone.AudioNode.prototype.dispose.call(this);
	        this._dryWet.dispose();
	        this._dryWet = null;
	        this._split.dispose();
	        this._split = null;
	        this._merge.dispose();
	        this._merge = null;
	        this.effectSendL = null;
	        this.effectSendR = null;
	        this.effectReturnL = null;
	        this.effectReturnR = null;
	        this._writable(['wet']);
	        this.wet = null;
	        return this;
	    };
	    return Tone.StereoEffect;
	});
	Module(function (Tone) {
	    
	    /**
		 * 	@class  Tone.FeedbackEffect provides a loop between an 
		 * 	        audio source and its own output. This is a base-class
		 * 	        for feedback effects. 
		 *
		 *  @constructor
		 *  @extends {Tone.Effect}
		 *  @param {NormalRange|Object} [feedback] The initial feedback value.
		 */
	    Tone.FeedbackEffect = function () {
	        var options = Tone.defaults(arguments, ['feedback'], Tone.FeedbackEffect);
	        Tone.Effect.call(this, options);
	        /**
			 *  the gain which controls the feedback
			 *  @type {Tone.Gain}
			 *  @private
			 */
	        this._feedbackGain = new Tone.Gain(options.feedback, Tone.Type.NormalRange);
	        /**
			 *  The amount of signal which is fed back into the effect input. 
			 *  @type {NormalRange}
			 *  @signal
			 */
	        this.feedback = this._feedbackGain.gain;
	        //the feedback loop
	        this.effectReturn.chain(this._feedbackGain, this.effectSend);
	        this._readOnly(['feedback']);
	    };
	    Tone.extend(Tone.FeedbackEffect, Tone.Effect);
	    /**
		 *  @static
		 *  @type {Object}
		 */
	    Tone.FeedbackEffect.defaults = { 'feedback': 0.125 };
	    /**
		 *  Clean up. 
		 *  @returns {Tone.FeedbackEffect} this
		 */
	    Tone.FeedbackEffect.prototype.dispose = function () {
	        Tone.Effect.prototype.dispose.call(this);
	        this._writable(['feedback']);
	        this._feedbackGain.dispose();
	        this._feedbackGain = null;
	        this.feedback = null;
	        return this;
	    };
	    return Tone.FeedbackEffect;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Just like a stereo feedback effect, but the feedback is routed from left to right
		 *         and right to left instead of on the same channel.
		 *
		 *	@constructor
		 *	@extends {Tone.StereoEffect}
		 */
	    Tone.StereoXFeedbackEffect = function () {
	        var options = Tone.defaults(arguments, ['feedback'], Tone.FeedbackEffect);
	        Tone.StereoEffect.call(this, options);
	        /**
			 *  The amount of feedback from the output
			 *  back into the input of the effect (routed
			 *  across left and right channels).
			 *  @type {NormalRange}
			 *  @signal
			 */
	        this.feedback = new Tone.Signal(options.feedback, Tone.Type.NormalRange);
	        /**
			 *  the left side feeback
			 *  @type {Tone.Gain}
			 *  @private
			 */
	        this._feedbackLR = new Tone.Gain();
	        /**
			 *  the right side feeback
			 *  @type {Tone.Gain}
			 *  @private
			 */
	        this._feedbackRL = new Tone.Gain();
	        //connect it up
	        this.effectReturnL.chain(this._feedbackLR, this.effectSendR);
	        this.effectReturnR.chain(this._feedbackRL, this.effectSendL);
	        this.feedback.fan(this._feedbackLR.gain, this._feedbackRL.gain);
	        this._readOnly(['feedback']);
	    };
	    Tone.extend(Tone.StereoXFeedbackEffect, Tone.StereoEffect);
	    /**
		 *  clean up
		 *  @returns {Tone.StereoXFeedbackEffect} this
		 */
	    Tone.StereoXFeedbackEffect.prototype.dispose = function () {
	        Tone.StereoEffect.prototype.dispose.call(this);
	        this._writable(['feedback']);
	        this.feedback.dispose();
	        this.feedback = null;
	        this._feedbackLR.dispose();
	        this._feedbackLR = null;
	        this._feedbackRL.dispose();
	        this._feedbackRL = null;
	        return this;
	    };
	    return Tone.StereoXFeedbackEffect;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Tone.Chorus is a stereo chorus effect with feedback composed of 
		 *         a left and right delay with a Tone.LFO applied to the delayTime of each channel. 
		 *         Inspiration from [Tuna.js](https://github.com/Dinahmoe/tuna/blob/master/tuna.js).
		 *         Read more on the chorus effect on [SoundOnSound](http://www.soundonsound.com/sos/jun04/articles/synthsecrets.htm).
		 *
		 *	@constructor
		 *	@extends {Tone.StereoXFeedbackEffect}
		 *	@param {Frequency|Object} [frequency] The frequency of the LFO.
		 *	@param {Milliseconds} [delayTime] The delay of the chorus effect in ms. 
		 *	@param {NormalRange} [depth] The depth of the chorus.
		 *	@example
		 * var chorus = new Tone.Chorus(4, 2.5, 0.5);
		 * var synth = new Tone.PolySynth(4, Tone.MonoSynth).connect(chorus);
		 * synth.triggerAttackRelease(["C3","E3","G3"], "8n");
		 */
	    Tone.Chorus = function () {
	        var options = Tone.defaults(arguments, [
	            'frequency',
	            'delayTime',
	            'depth'
	        ], Tone.Chorus);
	        Tone.StereoXFeedbackEffect.call(this, options);
	        /**
			 *  the depth of the chorus
			 *  @type {number}
			 *  @private
			 */
	        this._depth = options.depth;
	        /**
			 *  the delayTime
			 *  @type {number}
			 *  @private
			 */
	        this._delayTime = options.delayTime / 1000;
	        /**
			 *  the lfo which controls the delayTime
			 *  @type {Tone.LFO}
			 *  @private
			 */
	        this._lfoL = new Tone.LFO({
	            'frequency': options.frequency,
	            'min': 0,
	            'max': 1
	        });
	        /**
			 *  another LFO for the right side with a 180 degree phase diff
			 *  @type {Tone.LFO}
			 *  @private
			 */
	        this._lfoR = new Tone.LFO({
	            'frequency': options.frequency,
	            'min': 0,
	            'max': 1,
	            'phase': 180
	        });
	        /**
			 *  delay for left
			 *  @type {Tone.Delay}
			 *  @private
			 */
	        this._delayNodeL = new Tone.Delay();
	        /**
			 *  delay for right
			 *  @type {Tone.Delay}
			 *  @private
			 */
	        this._delayNodeR = new Tone.Delay();
	        /**
			 * The frequency of the LFO which modulates the delayTime. 
			 * @type {Frequency}
			 * @signal
			 */
	        this.frequency = this._lfoL.frequency;
	        //connections
	        this.effectSendL.chain(this._delayNodeL, this.effectReturnL);
	        this.effectSendR.chain(this._delayNodeR, this.effectReturnR);
	        //and pass through to make the detune apparent
	        this.effectSendL.connect(this.effectReturnL);
	        this.effectSendR.connect(this.effectReturnR);
	        //lfo setup
	        this._lfoL.connect(this._delayNodeL.delayTime);
	        this._lfoR.connect(this._delayNodeR.delayTime);
	        //start the lfo
	        this._lfoL.start();
	        this._lfoR.start();
	        //have one LFO frequency control the other
	        this._lfoL.frequency.connect(this._lfoR.frequency);
	        //set the initial values
	        this.depth = this._depth;
	        this.frequency.value = options.frequency;
	        this.type = options.type;
	        this._readOnly(['frequency']);
	        this.spread = options.spread;
	    };
	    Tone.extend(Tone.Chorus, Tone.StereoXFeedbackEffect);
	    /**
		 *  @static
		 *  @type {Object}
		 */
	    Tone.Chorus.defaults = {
	        'frequency': 1.5,
	        'delayTime': 3.5,
	        'depth': 0.7,
	        'feedback': 0.1,
	        'type': 'sine',
	        'spread': 180
	    };
	    /**
		 * The depth of the effect. A depth of 1 makes the delayTime
		 * modulate between 0 and 2*delayTime (centered around the delayTime). 
		 * @memberOf Tone.Chorus#
		 * @type {NormalRange}
		 * @name depth
		 */
	    Object.defineProperty(Tone.Chorus.prototype, 'depth', {
	        get: function () {
	            return this._depth;
	        },
	        set: function (depth) {
	            this._depth = depth;
	            var deviation = this._delayTime * depth;
	            this._lfoL.min = Math.max(this._delayTime - deviation, 0);
	            this._lfoL.max = this._delayTime + deviation;
	            this._lfoR.min = Math.max(this._delayTime - deviation, 0);
	            this._lfoR.max = this._delayTime + deviation;
	        }
	    });
	    /**
		 * The delayTime in milliseconds of the chorus. A larger delayTime
		 * will give a more pronounced effect. Nominal range a delayTime
		 * is between 2 and 20ms. 
		 * @memberOf Tone.Chorus#
		 * @type {Milliseconds}
		 * @name delayTime
		 */
	    Object.defineProperty(Tone.Chorus.prototype, 'delayTime', {
	        get: function () {
	            return this._delayTime * 1000;
	        },
	        set: function (delayTime) {
	            this._delayTime = delayTime / 1000;
	            this.depth = this._depth;
	        }
	    });
	    /**
		 * The oscillator type of the LFO. 
		 * @memberOf Tone.Chorus#
		 * @type {string}
		 * @name type
		 */
	    Object.defineProperty(Tone.Chorus.prototype, 'type', {
	        get: function () {
	            return this._lfoL.type;
	        },
	        set: function (type) {
	            this._lfoL.type = type;
	            this._lfoR.type = type;
	        }
	    });
	    /** 
		 * Amount of stereo spread. When set to 0, both LFO's will be panned centrally.
		 * When set to 180, LFO's will be panned hard left and right respectively.
		 * @memberOf Tone.Chorus#
		 * @type {Degrees}
		 * @name spread
		 */
	    Object.defineProperty(Tone.Chorus.prototype, 'spread', {
	        get: function () {
	            return this._lfoR.phase - this._lfoL.phase;
	        },
	        set: function (spread) {
	            this._lfoL.phase = 90 - spread / 2;
	            this._lfoR.phase = spread / 2 + 90;
	        }
	    });
	    /**
		 *  Clean up. 
		 *  @returns {Tone.Chorus} this
		 */
	    Tone.Chorus.prototype.dispose = function () {
	        Tone.StereoXFeedbackEffect.prototype.dispose.call(this);
	        this._lfoL.dispose();
	        this._lfoL = null;
	        this._lfoR.dispose();
	        this._lfoR = null;
	        this._delayNodeL.dispose();
	        this._delayNodeL = null;
	        this._delayNodeR.dispose();
	        this._delayNodeR = null;
	        this._writable('frequency');
	        this.frequency = null;
	        return this;
	    };
	    return Tone.Chorus;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class  Tone.Convolver is a wrapper around the Native Web Audio 
		 *          [ConvolverNode](http://webaudio.github.io/web-audio-api/#the-convolvernode-interface).
		 *          Convolution is useful for reverb and filter emulation. Read more about convolution reverb on
		 *          [Wikipedia](https://en.wikipedia.org/wiki/Convolution_reverb).
		 *  
		 *  @constructor
		 *  @extends {Tone.Effect}
		 *  @param {string|Tone.Buffer|Object} [url] The URL of the impulse response or the Tone.Buffer
		 *                                           contianing the impulse response. 
		 *  @param {Function} onload The callback to invoke when the url is loaded.
		 *  @example
		 * //initializing the convolver with an impulse response
		 * var convolver = new Tone.Convolver("./path/to/ir.wav").toMaster();
		 */
	    Tone.Convolver = function () {
	        var options = Tone.defaults(arguments, [
	            'url',
	            'onload'
	        ], Tone.Convolver);
	        Tone.Effect.call(this, options);
	        /**
			 *  convolver node
			 *  @type {ConvolverNode}
			 *  @private
			 */
	        this._convolver = this.context.createConvolver();
	        /**
			 *  the convolution buffer
			 *  @type {Tone.Buffer}
			 *  @private
			 */
	        this._buffer = new Tone.Buffer();
	        if (Tone.isString(options.url)) {
	            this._buffer.load(options.url, function (buffer) {
	                this.buffer = buffer;
	                options.onload();
	            }.bind(this));
	        } else if (options.url) {
	            this.buffer = options.url;
	            options.onload();
	        }
	        this.connectEffect(this._convolver);
	    };
	    Tone.extend(Tone.Convolver, Tone.Effect);
	    /**
		 *  @static
		 *  @const
		 *  @type  {Object}
		 */
	    Tone.Convolver.defaults = { 'onload': Tone.noOp };
	    /**
		 *  The convolver's buffer
		 *  @memberOf Tone.Convolver#
		 *  @type {AudioBuffer}
		 *  @name buffer
		 */
	    Object.defineProperty(Tone.Convolver.prototype, 'buffer', {
	        get: function () {
	            return this._buffer.get();
	        },
	        set: function (buffer) {
	            this._buffer.set(buffer);
	            this._convolver.buffer = this._buffer.get();
	        }
	    });
	    /**
		 *  Load an impulse response url as an audio buffer.
		 *  Decodes the audio asynchronously and invokes
		 *  the callback once the audio buffer loads.
		 *  @param {string} url The url of the buffer to load.
		 *                      filetype support depends on the
		 *                      browser.
		 *  @param  {function=} callback
		 *  @returns {Promise}
		 */
	    Tone.Convolver.prototype.load = function (url, callback) {
	        return this._buffer.load(url, function (buff) {
	            this.buffer = buff;
	            if (callback) {
	                callback();
	            }
	        }.bind(this));
	    };
	    /**
		 *  Clean up. 
		 *  @returns {Tone.Convolver} this
		 */
	    Tone.Convolver.prototype.dispose = function () {
	        Tone.Effect.prototype.dispose.call(this);
	        this._convolver.disconnect();
	        this._convolver = null;
	        this._buffer.dispose();
	        this._buffer = null;
	        return this;
	    };
	    return Tone.Convolver;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Tone.Distortion is a simple distortion effect using Tone.WaveShaper.
		 *         Algorithm from [a stackoverflow answer](http://stackoverflow.com/a/22313408).
		 *
		 *  @extends {Tone.Effect}
		 *  @constructor
		 *  @param {Number|Object} [distortion] The amount of distortion (nominal range of 0-1)
		 *  @example
		 * var dist = new Tone.Distortion(0.8).toMaster();
		 * var fm = new Tone.SimpleFM().connect(dist);
		 * //this sounds good on bass notes
		 * fm.triggerAttackRelease("A1", "8n");
		 */
	    Tone.Distortion = function () {
	        var options = Tone.defaults(arguments, ['distortion'], Tone.Distortion);
	        Tone.Effect.call(this, options);
	        /**
			 *  @type {Tone.WaveShaper}
			 *  @private
			 */
	        this._shaper = new Tone.WaveShaper(4096);
	        /**
			 * holds the distortion amount
			 * @type {number}
			 * @private
			 */
	        this._distortion = options.distortion;
	        this.connectEffect(this._shaper);
	        this.distortion = options.distortion;
	        this.oversample = options.oversample;
	    };
	    Tone.extend(Tone.Distortion, Tone.Effect);
	    /**
		 *  @static
		 *  @const
		 *  @type {Object}
		 */
	    Tone.Distortion.defaults = {
	        'distortion': 0.4,
	        'oversample': 'none'
	    };
	    /**
		 * The amount of distortion.
		 * @memberOf Tone.Distortion#
		 * @type {NormalRange}
		 * @name distortion
		 */
	    Object.defineProperty(Tone.Distortion.prototype, 'distortion', {
	        get: function () {
	            return this._distortion;
	        },
	        set: function (amount) {
	            this._distortion = amount;
	            var k = amount * 100;
	            var deg = Math.PI / 180;
	            this._shaper.setMap(function (x) {
	                if (Math.abs(x) < 0.001) {
	                    //should output 0 when input is 0
	                    return 0;
	                } else {
	                    return (3 + k) * x * 20 * deg / (Math.PI + k * Math.abs(x));
	                }
	            });
	        }
	    });
	    /**
		 * The oversampling of the effect. Can either be "none", "2x" or "4x".
		 * @memberOf Tone.Distortion#
		 * @type {string}
		 * @name oversample
		 */
	    Object.defineProperty(Tone.Distortion.prototype, 'oversample', {
	        get: function () {
	            return this._shaper.oversample;
	        },
	        set: function (oversampling) {
	            this._shaper.oversample = oversampling;
	        }
	    });
	    /**
		 *  Clean up. 
		 *  @returns {Tone.Distortion} this
		 */
	    Tone.Distortion.prototype.dispose = function () {
	        Tone.Effect.prototype.dispose.call(this);
	        this._shaper.dispose();
	        this._shaper = null;
	        return this;
	    };
	    return Tone.Distortion;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class  Tone.FeedbackDelay is a DelayNode in which part of output
		 *          signal is fed back into the delay. 
		 *
		 *  @constructor
		 *  @extends {Tone.FeedbackEffect}
		 *  @param {Time|Object} [delayTime] The delay applied to the incoming signal. 
		 *  @param {NormalRange=} feedback The amount of the effected signal which 
		 *                            is fed back through the delay.
		 *  @example
		 * var feedbackDelay = new Tone.FeedbackDelay("8n", 0.5).toMaster();
		 * var tom = new Tone.DrumSynth({
		 * 	"octaves" : 4,
		 * 	"pitchDecay" : 0.1
		 * }).connect(feedbackDelay);
		 * tom.triggerAttackRelease("A2","32n");
		 */
	    Tone.FeedbackDelay = function () {
	        var options = Tone.defaults(arguments, [
	            'delayTime',
	            'feedback'
	        ], Tone.FeedbackDelay);
	        Tone.FeedbackEffect.call(this, options);
	        /**
			 *  the delay node
			 *  @type {Tone.Delay}
			 *  @private
			 */
	        this._delayNode = new Tone.Delay(options.delayTime);
	        /**
			 *  The delayTime of the DelayNode. 
			 *  @type {Time}
			 *  @signal
			 */
	        this.delayTime = this._delayNode.delayTime;
	        // connect it up
	        this.connectEffect(this._delayNode);
	        this._readOnly(['delayTime']);
	    };
	    Tone.extend(Tone.FeedbackDelay, Tone.FeedbackEffect);
	    /**
		 *  The default values. 
		 *  @const
		 *  @static
		 *  @type {Object}
		 */
	    Tone.FeedbackDelay.defaults = { 'delayTime': 0.25 };
	    /**
		 *  clean up
		 *  @returns {Tone.FeedbackDelay} this
		 */
	    Tone.FeedbackDelay.prototype.dispose = function () {
	        Tone.FeedbackEffect.prototype.dispose.call(this);
	        this._delayNode.dispose();
	        this._delayNode = null;
	        this._writable(['delayTime']);
	        this.delayTime = null;
	        return this;
	    };
	    return Tone.FeedbackDelay;
	});
	Module(function (Tone) {
	    
	    /**
		 *  an array of comb filter delay values from Freeverb implementation
		 *  @static
		 *  @private
		 *  @type {Array}
		 */
	    var combFilterTunings = [
	        1557 / 44100,
	        1617 / 44100,
	        1491 / 44100,
	        1422 / 44100,
	        1277 / 44100,
	        1356 / 44100,
	        1188 / 44100,
	        1116 / 44100
	    ];
	    /**
		 *  an array of allpass filter frequency values from Freeverb implementation
		 *  @private
		 *  @static
		 *  @type {Array}
		 */
	    var allpassFilterFrequencies = [
	        225,
	        556,
	        441,
	        341
	    ];
	    /**
		 *  @class Tone.Freeverb is a reverb based on [Freeverb](https://ccrma.stanford.edu/~jos/pasp/Freeverb.html).
		 *         Read more on reverb on [Sound On Sound](https://web.archive.org/web/20160404083902/http://www.soundonsound.com:80/sos/feb01/articles/synthsecrets.asp).
		 *
		 *  @extends {Tone.Effect}
		 *  @constructor
		 *  @param {NormalRange|Object} [roomSize] Correlated to the decay time.
		 *  @param {Frequency} [dampening] The cutoff frequency of a lowpass filter as part
		 *                                 of the reverb.
		 *  @example
		 * var freeverb = new Tone.Freeverb().toMaster();
		 * freeverb.dampening.value = 1000;
		 * //routing synth through the reverb
		 * var synth = new Tone.AMSynth().connect(freeverb);
		 */
	    Tone.Freeverb = function () {
	        var options = Tone.defaults(arguments, [
	            'roomSize',
	            'dampening'
	        ], Tone.Freeverb);
	        Tone.StereoEffect.call(this, options);
	        /**
			 *  The roomSize value between. A larger roomSize
			 *  will result in a longer decay.
			 *  @type {NormalRange}
			 *  @signal
			 */
	        this.roomSize = new Tone.Signal(options.roomSize, Tone.Type.NormalRange);
	        /**
			 *  The amount of dampening of the reverberant signal.
			 *  @type {Frequency}
			 *  @signal
			 */
	        this.dampening = new Tone.Signal(options.dampening, Tone.Type.Frequency);
	        /**
			 *  the comb filters
			 *  @type {Array}
			 *  @private
			 */
	        this._combFilters = [];
	        /**
			 *  the allpass filters on the left
			 *  @type {Array}
			 *  @private
			 */
	        this._allpassFiltersL = [];
	        /**
			 *  the allpass filters on the right
			 *  @type {Array}
			 *  @private
			 */
	        this._allpassFiltersR = [];
	        //make the allpass filters on the right
	        for (var l = 0; l < allpassFilterFrequencies.length; l++) {
	            var allpassL = this.context.createBiquadFilter();
	            allpassL.type = 'allpass';
	            allpassL.frequency.value = allpassFilterFrequencies[l];
	            this._allpassFiltersL.push(allpassL);
	        }
	        //make the allpass filters on the left
	        for (var r = 0; r < allpassFilterFrequencies.length; r++) {
	            var allpassR = this.context.createBiquadFilter();
	            allpassR.type = 'allpass';
	            allpassR.frequency.value = allpassFilterFrequencies[r];
	            this._allpassFiltersR.push(allpassR);
	        }
	        //make the comb filters
	        for (var c = 0; c < combFilterTunings.length; c++) {
	            var lfpf = new Tone.LowpassCombFilter(combFilterTunings[c]);
	            if (c < combFilterTunings.length / 2) {
	                this.effectSendL.chain(lfpf, this._allpassFiltersL[0]);
	            } else {
	                this.effectSendR.chain(lfpf, this._allpassFiltersR[0]);
	            }
	            this.roomSize.connect(lfpf.resonance);
	            this.dampening.connect(lfpf.dampening);
	            this._combFilters.push(lfpf);
	        }
	        //chain the allpass filters togetehr
	        Tone.connectSeries.apply(Tone, this._allpassFiltersL);
	        Tone.connectSeries.apply(Tone, this._allpassFiltersR);
	        this._allpassFiltersL[this._allpassFiltersL.length - 1].connect(this.effectReturnL);
	        this._allpassFiltersR[this._allpassFiltersR.length - 1].connect(this.effectReturnR);
	        this._readOnly([
	            'roomSize',
	            'dampening'
	        ]);
	    };
	    Tone.extend(Tone.Freeverb, Tone.StereoEffect);
	    /**
		 *  @static
		 *  @type {Object}
		 */
	    Tone.Freeverb.defaults = {
	        'roomSize': 0.7,
	        'dampening': 3000
	    };
	    /**
		 *  Clean up.
		 *  @returns {Tone.Freeverb} this
		 */
	    Tone.Freeverb.prototype.dispose = function () {
	        Tone.StereoEffect.prototype.dispose.call(this);
	        for (var al = 0; al < this._allpassFiltersL.length; al++) {
	            this._allpassFiltersL[al].disconnect();
	            this._allpassFiltersL[al] = null;
	        }
	        this._allpassFiltersL = null;
	        for (var ar = 0; ar < this._allpassFiltersR.length; ar++) {
	            this._allpassFiltersR[ar].disconnect();
	            this._allpassFiltersR[ar] = null;
	        }
	        this._allpassFiltersR = null;
	        for (var cf = 0; cf < this._combFilters.length; cf++) {
	            this._combFilters[cf].dispose();
	            this._combFilters[cf] = null;
	        }
	        this._combFilters = null;
	        this._writable([
	            'roomSize',
	            'dampening'
	        ]);
	        this.roomSize.dispose();
	        this.roomSize = null;
	        this.dampening.dispose();
	        this.dampening = null;
	        return this;
	    };
	    return Tone.Freeverb;
	});
	Module(function (Tone) {
	    
	    /**
		 *  an array of the comb filter delay time values
		 *  @private
		 *  @static
		 *  @type {Array}
		 */
	    var combFilterDelayTimes = [
	        1687 / 25000,
	        1601 / 25000,
	        2053 / 25000,
	        2251 / 25000
	    ];
	    /**
		 *  the resonances of each of the comb filters
		 *  @private
		 *  @static
		 *  @type {Array}
		 */
	    var combFilterResonances = [
	        0.773,
	        0.802,
	        0.753,
	        0.733
	    ];
	    /**
		 *  the allpass filter frequencies
		 *  @private
		 *  @static
		 *  @type {Array}
		 */
	    var allpassFilterFreqs = [
	        347,
	        113,
	        37
	    ];
	    /**
		 *  @class Tone.JCReverb is a simple [Schroeder Reverberator](https://ccrma.stanford.edu/~jos/pasp/Schroeder_Reverberators.html)
		 *         tuned by John Chowning in 1970.
		 *         It is made up of three allpass filters and four Tone.FeedbackCombFilter. 
		 *         
		 *
		 *  @extends {Tone.Effect}
		 *  @constructor
		 *  @param {NormalRange|Object} [roomSize] Coorelates to the decay time.
		 *  @example
		 * var reverb = new Tone.JCReverb(0.4).connect(Tone.Master);
		 * var delay = new Tone.FeedbackDelay(0.5); 
		 * //connecting the synth to reverb through delay
		 * var synth = new Tone.DuoSynth().chain(delay, reverb);
		 * synth.triggerAttackRelease("A4","8n");
		 */
	    Tone.JCReverb = function () {
	        var options = Tone.defaults(arguments, ['roomSize'], Tone.JCReverb);
	        Tone.StereoEffect.call(this, options);
	        /**
			 *  room size control values between [0,1]
			 *  @type {NormalRange}
			 *  @signal
			 */
	        this.roomSize = new Tone.Signal(options.roomSize, Tone.Type.NormalRange);
	        /**
			 *  scale the room size
			 *  @type {Tone.Scale}
			 *  @private
			 */
	        this._scaleRoomSize = new Tone.Scale(-0.733, 0.197);
	        /**
			 *  a series of allpass filters
			 *  @type {Array}
			 *  @private
			 */
	        this._allpassFilters = [];
	        /**
			 *  parallel feedback comb filters
			 *  @type {Array}
			 *  @private
			 */
	        this._feedbackCombFilters = [];
	        //make the allpass filters
	        for (var af = 0; af < allpassFilterFreqs.length; af++) {
	            var allpass = this.context.createBiquadFilter();
	            allpass.type = 'allpass';
	            allpass.frequency.value = allpassFilterFreqs[af];
	            this._allpassFilters.push(allpass);
	        }
	        //and the comb filters
	        for (var cf = 0; cf < combFilterDelayTimes.length; cf++) {
	            var fbcf = new Tone.FeedbackCombFilter(combFilterDelayTimes[cf], 0.1);
	            this._scaleRoomSize.connect(fbcf.resonance);
	            fbcf.resonance.value = combFilterResonances[cf];
	            this._allpassFilters[this._allpassFilters.length - 1].connect(fbcf);
	            if (cf < combFilterDelayTimes.length / 2) {
	                fbcf.connect(this.effectReturnL);
	            } else {
	                fbcf.connect(this.effectReturnR);
	            }
	            this._feedbackCombFilters.push(fbcf);
	        }
	        //chain the allpass filters together
	        this.roomSize.connect(this._scaleRoomSize);
	        Tone.connectSeries.apply(Tone, this._allpassFilters);
	        this.effectSendL.connect(this._allpassFilters[0]);
	        this.effectSendR.connect(this._allpassFilters[0]);
	        this._readOnly(['roomSize']);
	    };
	    Tone.extend(Tone.JCReverb, Tone.StereoEffect);
	    /**
		 *  the default values
		 *  @static
		 *  @const
		 *  @type {Object}
		 */
	    Tone.JCReverb.defaults = { 'roomSize': 0.5 };
	    /**
		 *  Clean up. 
		 *  @returns {Tone.JCReverb} this
		 */
	    Tone.JCReverb.prototype.dispose = function () {
	        Tone.StereoEffect.prototype.dispose.call(this);
	        for (var apf = 0; apf < this._allpassFilters.length; apf++) {
	            this._allpassFilters[apf].disconnect();
	            this._allpassFilters[apf] = null;
	        }
	        this._allpassFilters = null;
	        for (var fbcf = 0; fbcf < this._feedbackCombFilters.length; fbcf++) {
	            this._feedbackCombFilters[fbcf].dispose();
	            this._feedbackCombFilters[fbcf] = null;
	        }
	        this._feedbackCombFilters = null;
	        this._writable(['roomSize']);
	        this.roomSize.dispose();
	        this.roomSize = null;
	        this._scaleRoomSize.dispose();
	        this._scaleRoomSize = null;
	        return this;
	    };
	    return Tone.JCReverb;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Mid/Side processing separates the the 'mid' signal 
		 *         (which comes out of both the left and the right channel) 
		 *         and the 'side' (which only comes out of the the side channels) 
		 *         and effects them separately before being recombined.
		 *         Applies a Mid/Side seperation and recombination.
		 *         Algorithm found in [kvraudio forums](http://www.kvraudio.com/forum/viewtopic.php?t=212587).
		 *         <br><br>
		 *         This is a base-class for Mid/Side Effects. 
		 *
		 *  @extends {Tone.Effect}
		 *  @constructor
		 */
	    Tone.MidSideEffect = function () {
	        Tone.Effect.apply(this, arguments);
	        /**
			 *  The mid/side split
			 *  @type  {Tone.MidSideSplit}
			 *  @private
			 */
	        this._midSideSplit = new Tone.MidSideSplit();
	        /**
			 *  The mid/side merge
			 *  @type  {Tone.MidSideMerge}
			 *  @private
			 */
	        this._midSideMerge = new Tone.MidSideMerge();
	        /**
			 *  The mid send. Connect to mid processing
			 *  @type {Tone.Expr}
			 *  @private
			 */
	        this.midSend = this._midSideSplit.mid;
	        /**
			 *  The side send. Connect to side processing
			 *  @type {Tone.Expr}
			 *  @private
			 */
	        this.sideSend = this._midSideSplit.side;
	        /**
			 *  The mid return connection
			 *  @type {GainNode}
			 *  @private
			 */
	        this.midReturn = this._midSideMerge.mid;
	        /**
			 *  The side return connection
			 *  @type {GainNode}
			 *  @private
			 */
	        this.sideReturn = this._midSideMerge.side;
	        //the connections
	        this.effectSend.connect(this._midSideSplit);
	        this._midSideMerge.connect(this.effectReturn);
	    };
	    Tone.extend(Tone.MidSideEffect, Tone.Effect);
	    /**
		 *  Clean up. 
		 *  @returns {Tone.MidSideEffect} this
		 */
	    Tone.MidSideEffect.prototype.dispose = function () {
	        Tone.Effect.prototype.dispose.call(this);
	        this._midSideSplit.dispose();
	        this._midSideSplit = null;
	        this._midSideMerge.dispose();
	        this._midSideMerge = null;
	        this.midSend = null;
	        this.sideSend = null;
	        this.midReturn = null;
	        this.sideReturn = null;
	        return this;
	    };
	    return Tone.MidSideEffect;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Tone.Phaser is a phaser effect. Phasers work by changing the phase
		 *         of different frequency components of an incoming signal. Read more on 
		 *         [Wikipedia](https://en.wikipedia.org/wiki/Phaser_(effect)). 
		 *         Inspiration for this phaser comes from [Tuna.js](https://github.com/Dinahmoe/tuna/).
		 *
		 *	@extends {Tone.StereoEffect}
		 *	@constructor
		 *	@param {Frequency|Object} [frequency] The speed of the phasing. 
		 *	@param {number} [octaves] The octaves of the effect. 
		 *	@param {Frequency} [baseFrequency] The base frequency of the filters. 
		 *	@example
		 * var phaser = new Tone.Phaser({
		 * 	"frequency" : 15, 
		 * 	"octaves" : 5, 
		 * 	"baseFrequency" : 1000
		 * }).toMaster();
		 * var synth = new Tone.FMSynth().connect(phaser);
		 * synth.triggerAttackRelease("E3", "2n");
		 */
	    Tone.Phaser = function () {
	        //set the defaults
	        var options = Tone.defaults(arguments, [
	            'frequency',
	            'octaves',
	            'baseFrequency'
	        ], Tone.Phaser);
	        Tone.StereoEffect.call(this, options);
	        /**
			 *  the lfo which controls the frequency on the left side
			 *  @type {Tone.LFO}
			 *  @private
			 */
	        this._lfoL = new Tone.LFO(options.frequency, 0, 1);
	        /**
			 *  the lfo which controls the frequency on the right side
			 *  @type {Tone.LFO}
			 *  @private
			 */
	        this._lfoR = new Tone.LFO(options.frequency, 0, 1);
	        this._lfoR.phase = 180;
	        /**
			 *  the base modulation frequency
			 *  @type {number}
			 *  @private
			 */
	        this._baseFrequency = options.baseFrequency;
	        /**
			 *  the octaves of the phasing
			 *  @type {number}
			 *  @private
			 */
	        this._octaves = options.octaves;
	        /**
			 *  The quality factor of the filters
			 *  @type {Positive}
			 *  @signal
			 */
	        this.Q = new Tone.Signal(options.Q, Tone.Type.Positive);
	        /**
			 *  the array of filters for the left side
			 *  @type {Array}
			 *  @private
			 */
	        this._filtersL = this._makeFilters(options.stages, this._lfoL, this.Q);
	        /**
			 *  the array of filters for the left side
			 *  @type {Array}
			 *  @private
			 */
	        this._filtersR = this._makeFilters(options.stages, this._lfoR, this.Q);
	        /**
			 * the frequency of the effect
			 * @type {Tone.Signal}
			 */
	        this.frequency = this._lfoL.frequency;
	        this.frequency.value = options.frequency;
	        //connect them up
	        this.effectSendL.connect(this._filtersL[0]);
	        this.effectSendR.connect(this._filtersR[0]);
	        this._filtersL[options.stages - 1].connect(this.effectReturnL);
	        this._filtersR[options.stages - 1].connect(this.effectReturnR);
	        //control the frequency with one LFO
	        this._lfoL.frequency.connect(this._lfoR.frequency);
	        //set the options
	        this.baseFrequency = options.baseFrequency;
	        this.octaves = options.octaves;
	        //start the lfo
	        this._lfoL.start();
	        this._lfoR.start();
	        this._readOnly([
	            'frequency',
	            'Q'
	        ]);
	    };
	    Tone.extend(Tone.Phaser, Tone.StereoEffect);
	    /**
		 *  defaults
		 *  @static
		 *  @type {object}
		 */
	    Tone.Phaser.defaults = {
	        'frequency': 0.5,
	        'octaves': 3,
	        'stages': 10,
	        'Q': 10,
	        'baseFrequency': 350
	    };
	    /**
		 *  @param {number} stages
		 *  @returns {Array} the number of filters all connected together
		 *  @private
		 */
	    Tone.Phaser.prototype._makeFilters = function (stages, connectToFreq, Q) {
	        var filters = new Array(stages);
	        //make all the filters
	        for (var i = 0; i < stages; i++) {
	            var filter = this.context.createBiquadFilter();
	            filter.type = 'allpass';
	            Q.connect(filter.Q);
	            connectToFreq.connect(filter.frequency);
	            filters[i] = filter;
	        }
	        Tone.connectSeries.apply(Tone, filters);
	        return filters;
	    };
	    /**
		 * The number of octaves the phase goes above
		 * the baseFrequency
		 * @memberOf Tone.Phaser#
		 * @type {Positive}
		 * @name octaves
		 */
	    Object.defineProperty(Tone.Phaser.prototype, 'octaves', {
	        get: function () {
	            return this._octaves;
	        },
	        set: function (octaves) {
	            this._octaves = octaves;
	            var max = this._baseFrequency * Math.pow(2, octaves);
	            this._lfoL.max = max;
	            this._lfoR.max = max;
	        }
	    });
	    /**
		 * The the base frequency of the filters. 
		 * @memberOf Tone.Phaser#
		 * @type {number}
		 * @name baseFrequency
		 */
	    Object.defineProperty(Tone.Phaser.prototype, 'baseFrequency', {
	        get: function () {
	            return this._baseFrequency;
	        },
	        set: function (freq) {
	            this._baseFrequency = freq;
	            this._lfoL.min = freq;
	            this._lfoR.min = freq;
	            this.octaves = this._octaves;
	        }
	    });
	    /**
		 *  clean up
		 *  @returns {Tone.Phaser} this
		 */
	    Tone.Phaser.prototype.dispose = function () {
	        Tone.StereoEffect.prototype.dispose.call(this);
	        this._writable([
	            'frequency',
	            'Q'
	        ]);
	        this.Q.dispose();
	        this.Q = null;
	        this._lfoL.dispose();
	        this._lfoL = null;
	        this._lfoR.dispose();
	        this._lfoR = null;
	        for (var i = 0; i < this._filtersL.length; i++) {
	            this._filtersL[i].disconnect();
	            this._filtersL[i] = null;
	        }
	        this._filtersL = null;
	        for (var j = 0; j < this._filtersR.length; j++) {
	            this._filtersR[j].disconnect();
	            this._filtersR[j] = null;
	        }
	        this._filtersR = null;
	        this.frequency = null;
	        return this;
	    };
	    return Tone.Phaser;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class  Tone.PingPongDelay is a feedback delay effect where the echo is heard
		 *          first in one channel and next in the opposite channel. In a stereo
		 *          system these are the right and left channels.
		 *          PingPongDelay in more simplified terms is two Tone.FeedbackDelays 
		 *          with independent delay values. Each delay is routed to one channel
		 *          (left or right), and the channel triggered second will always 
		 *          trigger at the same interval after the first.
		 *
		 * 	@constructor
		 * 	@extends {Tone.StereoXFeedbackEffect}
		 *  @param {Time|Object} [delayTime] The delayTime between consecutive echos.
		 *  @param {NormalRange=} feedback The amount of the effected signal which 
		 *                                 is fed back through the delay.
		 *  @example
		 * var pingPong = new Tone.PingPongDelay("4n", 0.2).toMaster();
		 * var drum = new Tone.DrumSynth().connect(pingPong);
		 * drum.triggerAttackRelease("C4", "32n");
		 */
	    Tone.PingPongDelay = function () {
	        var options = Tone.defaults(arguments, [
	            'delayTime',
	            'feedback'
	        ], Tone.PingPongDelay);
	        Tone.StereoXFeedbackEffect.call(this, options);
	        /**
			 *  the delay node on the left side
			 *  @type {Tone.Delay}
			 *  @private
			 */
	        this._leftDelay = new Tone.Delay(0, options.maxDelayTime);
	        /**
			 *  the delay node on the right side
			 *  @type {Tone.Delay}
			 *  @private
			 */
	        this._rightDelay = new Tone.Delay(0, options.maxDelayTime);
	        /**
			 *  the predelay on the right side
			 *  @type {Tone.Delay}
			 *  @private
			 */
	        this._rightPreDelay = new Tone.Delay(0, options.maxDelayTime);
	        /**
			 *  the delay time signal
			 *  @type {Time}
			 *  @signal
			 */
	        this.delayTime = new Tone.Signal(options.delayTime, Tone.Type.Time);
	        //connect it up
	        this.effectSendL.chain(this._leftDelay, this.effectReturnL);
	        this.effectSendR.chain(this._rightPreDelay, this._rightDelay, this.effectReturnR);
	        this.delayTime.fan(this._leftDelay.delayTime, this._rightDelay.delayTime, this._rightPreDelay.delayTime);
	        //rearranged the feedback to be after the rightPreDelay
	        this._feedbackLR.disconnect();
	        this._feedbackLR.connect(this._rightDelay);
	        this._readOnly(['delayTime']);
	    };
	    Tone.extend(Tone.PingPongDelay, Tone.StereoXFeedbackEffect);
	    /**
		 *  @static
		 *  @type {Object}
		 */
	    Tone.PingPongDelay.defaults = {
	        'delayTime': 0.25,
	        'maxDelayTime': 1
	    };
	    /**
		 *  Clean up. 
		 *  @returns {Tone.PingPongDelay} this
		 */
	    Tone.PingPongDelay.prototype.dispose = function () {
	        Tone.StereoXFeedbackEffect.prototype.dispose.call(this);
	        this._leftDelay.dispose();
	        this._leftDelay = null;
	        this._rightDelay.dispose();
	        this._rightDelay = null;
	        this._rightPreDelay.dispose();
	        this._rightPreDelay = null;
	        this._writable(['delayTime']);
	        this.delayTime.dispose();
	        this.delayTime = null;
	        return this;
	    };
	    return Tone.PingPongDelay;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Tone.PitchShift does near-realtime pitch shifting to the incoming signal. 
		 *         The effect is achieved by speeding up or slowing down the delayTime
		 *         of a DelayNode using a sawtooth wave. 
		 *         Algorithm found in [this pdf](http://dsp-book.narod.ru/soundproc.pdf).
		 *         Additional reference by [Miller Pucket](http://msp.ucsd.edu/techniques/v0.11/book-html/node115.html).
		 *         
		 *  @extends {Tone.FeedbackEffect}
		 *  @param {Interval=} pitch The interval to transpose the incoming signal by. 
		 */
	    Tone.PitchShift = function () {
	        var options = Tone.defaults(arguments, ['pitch'], Tone.PitchShift);
	        Tone.FeedbackEffect.call(this, options);
	        /**
			 *  The pitch signal
			 *  @type  {Tone.Signal}
			 *  @private
			 */
	        this._frequency = new Tone.Signal(0);
	        /**
			 *  Uses two DelayNodes to cover up the jump in
			 *  the sawtooth wave. 
			 *  @type  {DelayNode}
			 *  @private
			 */
	        this._delayA = new Tone.Delay(0, 1);
	        /**
			 *  The first LFO.
			 *  @type  {Tone.LFO}
			 *  @private
			 */
	        this._lfoA = new Tone.LFO({
	            'min': 0,
	            'max': 0.1,
	            'type': 'sawtooth'
	        }).connect(this._delayA.delayTime);
	        /**
			 *  The second DelayNode
			 *  @type  {DelayNode}
			 *  @private
			 */
	        this._delayB = new Tone.Delay(0, 1);
	        /**
			 *  The first LFO.
			 *  @type  {Tone.LFO}
			 *  @private
			 */
	        this._lfoB = new Tone.LFO({
	            'min': 0,
	            'max': 0.1,
	            'type': 'sawtooth',
	            'phase': 180
	        }).connect(this._delayB.delayTime);
	        /**
			 *  Crossfade quickly between the two delay lines
			 *  to cover up the jump in the sawtooth wave
			 *  @type  {Tone.CrossFade}
			 *  @private
			 */
	        this._crossFade = new Tone.CrossFade();
	        /**
			 *  LFO which alternates between the two
			 *  delay lines to cover up the disparity in the
			 *  sawtooth wave. 
			 *  @type  {Tone.LFO}
			 *  @private
			 */
	        this._crossFadeLFO = new Tone.LFO({
	            'min': 0,
	            'max': 1,
	            'type': 'triangle',
	            'phase': 90
	        }).connect(this._crossFade.fade);
	        /**
			 *  The delay node
			 *  @type {Tone.Delay}
			 *  @private
			 */
	        this._feedbackDelay = new Tone.Delay(options.delayTime);
	        /**
			 *  The amount of delay on the input signal
			 *  @type {Time}
			 *  @signal
			 */
	        this.delayTime = this._feedbackDelay.delayTime;
	        this._readOnly('delayTime');
	        /**
			 *  Hold the current pitch
			 *  @type {Number}
			 *  @private
			 */
	        this._pitch = options.pitch;
	        /**
			 *  Hold the current windowSize
			 *  @type {Number}
			 *  @private
			 */
	        this._windowSize = options.windowSize;
	        //connect the two delay lines up
	        this._delayA.connect(this._crossFade.a);
	        this._delayB.connect(this._crossFade.b);
	        //connect the frequency
	        this._frequency.fan(this._lfoA.frequency, this._lfoB.frequency, this._crossFadeLFO.frequency);
	        //route the input
	        this.effectSend.fan(this._delayA, this._delayB);
	        this._crossFade.chain(this._feedbackDelay, this.effectReturn);
	        //start the LFOs at the same time
	        var now = this.now();
	        this._lfoA.start(now);
	        this._lfoB.start(now);
	        this._crossFadeLFO.start(now);
	        //set the initial value
	        this.windowSize = this._windowSize;
	    };
	    Tone.extend(Tone.PitchShift, Tone.FeedbackEffect);
	    /**
		 *  default values
		 *  @static
		 *  @type {Object}
		 *  @const
		 */
	    Tone.PitchShift.defaults = {
	        'pitch': 0,
	        'windowSize': 0.1,
	        'delayTime': 0,
	        'feedback': 0
	    };
	    /**
		 * Repitch the incoming signal by some interval (measured
		 * in semi-tones). 
		 * @memberOf Tone.PitchShift#
		 * @type {Interval}
		 * @name pitch
		 * @example
		 * pitchShift.pitch = -12; //down one octave
		 * pitchShift.pitch = 7; //up a fifth
		 */
	    Object.defineProperty(Tone.PitchShift.prototype, 'pitch', {
	        get: function () {
	            return this._pitch;
	        },
	        set: function (interval) {
	            this._pitch = interval;
	            var factor = 0;
	            if (interval < 0) {
	                this._lfoA.min = 0;
	                this._lfoA.max = this._windowSize;
	                this._lfoB.min = 0;
	                this._lfoB.max = this._windowSize;
	                factor = Tone.intervalToFrequencyRatio(interval - 1) + 1;
	            } else {
	                this._lfoA.min = this._windowSize;
	                this._lfoA.max = 0;
	                this._lfoB.min = this._windowSize;
	                this._lfoB.max = 0;
	                factor = Tone.intervalToFrequencyRatio(interval) - 1;
	            }
	            this._frequency.value = factor * (1.2 / this._windowSize);
	        }
	    });
	    /**
		 * The window size corresponds roughly to the sample length in a looping sampler. 
		 * Smaller values are desirable for a less noticeable delay time of the pitch shifted
		 * signal, but larger values will result in smoother pitch shifting for larger intervals. 
		 * A nominal range of 0.03 to 0.1 is recommended. 
		 * @memberOf Tone.PitchShift#
		 * @type {Time}
		 * @name windowSize
		 * @example
		 * pitchShift.windowSize = 0.1;
		 */
	    Object.defineProperty(Tone.PitchShift.prototype, 'windowSize', {
	        get: function () {
	            return this._windowSize;
	        },
	        set: function (size) {
	            this._windowSize = this.toSeconds(size);
	            this.pitch = this._pitch;
	        }
	    });
	    /**
		 *  Clean up.
		 *  @return  {Tone.PitchShift}  this
		 */
	    Tone.PitchShift.prototype.dispose = function () {
	        Tone.FeedbackEffect.prototype.dispose.call(this);
	        this._frequency.dispose();
	        this._frequency = null;
	        this._delayA.disconnect();
	        this._delayA = null;
	        this._delayB.disconnect();
	        this._delayB = null;
	        this._lfoA.dispose();
	        this._lfoA = null;
	        this._lfoB.dispose();
	        this._lfoB = null;
	        this._crossFade.dispose();
	        this._crossFade = null;
	        this._crossFadeLFO.dispose();
	        this._crossFadeLFO = null;
	        this._writable('delayTime');
	        this._feedbackDelay.dispose();
	        this._feedbackDelay = null;
	        this.delayTime = null;
	        return this;
	    };
	    return Tone.PitchShift;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Base class for stereo feedback effects where the effectReturn
		 *         is fed back into the same channel. 
		 *
		 *	@constructor
		 *	@extends {Tone.StereoEffect}
		 */
	    Tone.StereoFeedbackEffect = function () {
	        var options = Tone.defaults(arguments, ['feedback'], Tone.FeedbackEffect);
	        Tone.StereoEffect.call(this, options);
	        /**
			 *  controls the amount of feedback
			 *  @type {NormalRange}
			 *  @signal
			 */
	        this.feedback = new Tone.Signal(options.feedback, Tone.Type.NormalRange);
	        /**
			 *  the left side feeback
			 *  @type {Tone.Gain}
			 *  @private
			 */
	        this._feedbackL = new Tone.Gain();
	        /**
			 *  the right side feeback
			 *  @type {Tone.Gain}
			 *  @private
			 */
	        this._feedbackR = new Tone.Gain();
	        //connect it up
	        this.effectReturnL.chain(this._feedbackL, this.effectSendL);
	        this.effectReturnR.chain(this._feedbackR, this.effectSendR);
	        this.feedback.fan(this._feedbackL.gain, this._feedbackR.gain);
	        this._readOnly(['feedback']);
	    };
	    Tone.extend(Tone.StereoFeedbackEffect, Tone.StereoEffect);
	    /**
		 *  clean up
		 *  @returns {Tone.StereoFeedbackEffect} this
		 */
	    Tone.StereoFeedbackEffect.prototype.dispose = function () {
	        Tone.StereoEffect.prototype.dispose.call(this);
	        this._writable(['feedback']);
	        this.feedback.dispose();
	        this.feedback = null;
	        this._feedbackL.dispose();
	        this._feedbackL = null;
	        this._feedbackR.dispose();
	        this._feedbackR = null;
	        return this;
	    };
	    return Tone.StereoFeedbackEffect;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Applies a width factor to the mid/side seperation. 
		 *         0 is all mid and 1 is all side.
		 *         Algorithm found in [kvraudio forums](http://www.kvraudio.com/forum/viewtopic.php?t=212587).
		 *         <br><br>
		 *         <code>
		 *         Mid *= 2*(1-width)<br>
		 *         Side *= 2*width
		 *         </code>
		 *
		 *  @extends {Tone.MidSideEffect}
		 *  @constructor
		 *  @param {NormalRange|Object} [width] The stereo width. A width of 0 is mono and 1 is stereo. 0.5 is no change.
		 */
	    Tone.StereoWidener = function () {
	        var options = Tone.defaults(arguments, ['width'], Tone.StereoWidener);
	        Tone.MidSideEffect.call(this, options);
	        /**
			 *  The width control. 0 = 100% mid. 1 = 100% side. 0.5 = no change. 
			 *  @type {NormalRange}
			 *  @signal
			 */
	        this.width = new Tone.Signal(options.width, Tone.Type.NormalRange);
	        /**
			 *  Mid multiplier
			 *  @type {Tone.Expr}
			 *  @private
			 */
	        this._midMult = new Tone.Expr('$0 * ($1 * (1 - $2))');
	        /**
			 *  Side multiplier
			 *  @type {Tone.Expr}
			 *  @private
			 */
	        this._sideMult = new Tone.Expr('$0 * ($1 * $2)');
	        /**
			 *  constant output of 2
			 *  @type {Tone}
			 *  @private
			 */
	        this._two = new Tone.Signal(2);
	        //the mid chain
	        this._two.connect(this._midMult, 0, 1);
	        this.width.connect(this._midMult, 0, 2);
	        //the side chain
	        this._two.connect(this._sideMult, 0, 1);
	        this.width.connect(this._sideMult, 0, 2);
	        //connect it to the effect send/return
	        this.midSend.chain(this._midMult, this.midReturn);
	        this.sideSend.chain(this._sideMult, this.sideReturn);
	        this._readOnly(['width']);
	    };
	    Tone.extend(Tone.StereoWidener, Tone.MidSideEffect);
	    /**
		 *  the default values
		 *  @static
		 *  @type {Object}
		 */
	    Tone.StereoWidener.defaults = { 'width': 0.5 };
	    /**
		 *  Clean up. 
		 *  @returns {Tone.StereoWidener} this
		 */
	    Tone.StereoWidener.prototype.dispose = function () {
	        Tone.MidSideEffect.prototype.dispose.call(this);
	        this._writable(['width']);
	        this.width.dispose();
	        this.width = null;
	        this._midMult.dispose();
	        this._midMult = null;
	        this._sideMult.dispose();
	        this._sideMult = null;
	        this._two.dispose();
	        this._two = null;
	        return this;
	    };
	    return Tone.StereoWidener;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Tone.Tremolo modulates the amplitude of an incoming signal using a Tone.LFO.
		 *         The type, frequency, and depth of the LFO is controllable.
		 *
		 *  @extends {Tone.StereoEffect}
		 *  @constructor
		 *  @param {Frequency} [frequency] The rate of the effect.
		 *  @param {NormalRange} [depth] The depth of the effect.
		 *  @example
		 * //create a tremolo and start it's LFO
		 * var tremolo = new Tone.Tremolo(9, 0.75).toMaster().start();
		 * //route an oscillator through the tremolo and start it
		 * var oscillator = new Tone.Oscillator().connect(tremolo).start();
		 */
	    Tone.Tremolo = function () {
	        var options = Tone.defaults(arguments, [
	            'frequency',
	            'depth'
	        ], Tone.Tremolo);
	        Tone.StereoEffect.call(this, options);
	        /**
			 *  The tremelo LFO in the left channel
			 *  @type  {Tone.LFO}
			 *  @private
			 */
	        this._lfoL = new Tone.LFO({
	            'phase': options.spread,
	            'min': 1,
	            'max': 0
	        });
	        /**
			 *  The tremelo LFO in the left channel
			 *  @type  {Tone.LFO}
			 *  @private
			 */
	        this._lfoR = new Tone.LFO({
	            'phase': options.spread,
	            'min': 1,
	            'max': 0
	        });
	        /**
			 *  Where the gain is multiplied
			 *  @type  {Tone.Gain}
			 *  @private
			 */
	        this._amplitudeL = new Tone.Gain();
	        /**
			 *  Where the gain is multiplied
			 *  @type  {Tone.Gain}
			 *  @private
			 */
	        this._amplitudeR = new Tone.Gain();
	        /**
			 *  The frequency of the tremolo.
			 *  @type  {Frequency}
			 *  @signal
			 */
	        this.frequency = new Tone.Signal(options.frequency, Tone.Type.Frequency);
	        /**
			 *  The depth of the effect. A depth of 0, has no effect
			 *  on the amplitude, and a depth of 1 makes the amplitude
			 *  modulate fully between 0 and 1.
			 *  @type  {NormalRange}
			 *  @signal
			 */
	        this.depth = new Tone.Signal(options.depth, Tone.Type.NormalRange);
	        this._readOnly([
	            'frequency',
	            'depth'
	        ]);
	        this.effectSendL.chain(this._amplitudeL, this.effectReturnL);
	        this.effectSendR.chain(this._amplitudeR, this.effectReturnR);
	        this._lfoL.connect(this._amplitudeL.gain);
	        this._lfoR.connect(this._amplitudeR.gain);
	        this.frequency.fan(this._lfoL.frequency, this._lfoR.frequency);
	        this.depth.fan(this._lfoR.amplitude, this._lfoL.amplitude);
	        this.type = options.type;
	        this.spread = options.spread;
	    };
	    Tone.extend(Tone.Tremolo, Tone.StereoEffect);
	    /**
		 *  @static
		 *  @const
		 *  @type {Object}
		 */
	    Tone.Tremolo.defaults = {
	        'frequency': 10,
	        'type': 'sine',
	        'depth': 0.5,
	        'spread': 180
	    };
	    /**
		 * Start the tremolo.
		 * @param {Time} [time=now] When the tremolo begins.
		 * @returns {Tone.Tremolo} this
		 */
	    Tone.Tremolo.prototype.start = function (time) {
	        this._lfoL.start(time);
	        this._lfoR.start(time);
	        return this;
	    };
	    /**
		 * Stop the tremolo.
		 * @param {Time} [time=now] When the tremolo stops.
		 * @returns {Tone.Tremolo} this
		 */
	    Tone.Tremolo.prototype.stop = function (time) {
	        this._lfoL.stop(time);
	        this._lfoR.stop(time);
	        return this;
	    };
	    /**
		 * Sync the effect to the transport.
		 * @param {Time} [delay=0] Delay time before starting the effect after the
		 *                              Transport has started.
		 * @returns {Tone.AutoFilter} this
		 */
	    Tone.Tremolo.prototype.sync = function (delay) {
	        this._lfoL.sync(delay);
	        this._lfoR.sync(delay);
	        return this;
	    };
	    /**
		 * Unsync the filter from the transport
		 * @returns {Tone.Tremolo} this
		 */
	    Tone.Tremolo.prototype.unsync = function () {
	        this._lfoL.unsync();
	        this._lfoR.unsync();
	        return this;
	    };
	    /**
		 * The Tremolo's oscillator type.
		 * @memberOf Tone.Tremolo#
		 * @type {string}
		 * @name type
		 */
	    Object.defineProperty(Tone.Tremolo.prototype, 'type', {
	        get: function () {
	            return this._lfoL.type;
	        },
	        set: function (type) {
	            this._lfoL.type = type;
	            this._lfoR.type = type;
	        }
	    });
	    /** 
		 * Amount of stereo spread. When set to 0, both LFO's will be panned centrally.
		 * When set to 180, LFO's will be panned hard left and right respectively.
		 * @memberOf Tone.Tremolo#
		 * @type {Degrees}
		 * @name spread
		 */
	    Object.defineProperty(Tone.Tremolo.prototype, 'spread', {
	        get: function () {
	            return this._lfoR.phase - this._lfoL.phase;    //180
	        },
	        set: function (spread) {
	            this._lfoL.phase = 90 - spread / 2;
	            this._lfoR.phase = spread / 2 + 90;
	        }
	    });
	    /**
		 *  clean up
		 *  @returns {Tone.Tremolo} this
		 */
	    Tone.Tremolo.prototype.dispose = function () {
	        Tone.StereoEffect.prototype.dispose.call(this);
	        this._writable([
	            'frequency',
	            'depth'
	        ]);
	        this._lfoL.dispose();
	        this._lfoL = null;
	        this._lfoR.dispose();
	        this._lfoR = null;
	        this._amplitudeL.dispose();
	        this._amplitudeL = null;
	        this._amplitudeR.dispose();
	        this._amplitudeR = null;
	        this.frequency = null;
	        this.depth = null;
	        return this;
	    };
	    return Tone.Tremolo;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class A Vibrato effect composed of a Tone.Delay and a Tone.LFO. The LFO
		 *         modulates the delayTime of the delay, causing the pitch to rise
		 *         and fall. 
		 *  @extends {Tone.Effect}
		 *  @param {Frequency} frequency The frequency of the vibrato.
		 *  @param {NormalRange} depth The amount the pitch is modulated.
		 */
	    Tone.Vibrato = function () {
	        var options = Tone.defaults(arguments, [
	            'frequency',
	            'depth'
	        ], Tone.Vibrato);
	        Tone.Effect.call(this, options);
	        /**
			 *  The delay node used for the vibrato effect
			 *  @type {Tone.Delay}
			 *  @private
			 */
	        this._delayNode = new Tone.Delay(0, options.maxDelay);
	        /**
			 *  The LFO used to control the vibrato
			 *  @type {Tone.LFO}
			 *  @private
			 */
	        this._lfo = new Tone.LFO({
	            'type': options.type,
	            'min': 0,
	            'max': options.maxDelay,
	            'frequency': options.frequency,
	            'phase': -90    //offse the phase so the resting position is in the center
	        }).start().connect(this._delayNode.delayTime);
	        /**
			 *  The frequency of the vibrato
			 *  @type {Frequency}
			 *  @signal
			 */
	        this.frequency = this._lfo.frequency;
	        /**
			 *  The depth of the vibrato. 
			 *  @type {NormalRange}
			 *  @signal
			 */
	        this.depth = this._lfo.amplitude;
	        this.depth.value = options.depth;
	        this._readOnly([
	            'frequency',
	            'depth'
	        ]);
	        this.effectSend.chain(this._delayNode, this.effectReturn);
	    };
	    Tone.extend(Tone.Vibrato, Tone.Effect);
	    /**
		 *  The defaults
		 *  @type  {Object}
		 *  @const
		 */
	    Tone.Vibrato.defaults = {
	        'maxDelay': 0.005,
	        'frequency': 5,
	        'depth': 0.1,
	        'type': 'sine'
	    };
	    /**
		 * Type of oscillator attached to the Vibrato.
		 * @memberOf Tone.Vibrato#
		 * @type {string}
		 * @name type
		 */
	    Object.defineProperty(Tone.Vibrato.prototype, 'type', {
	        get: function () {
	            return this._lfo.type;
	        },
	        set: function (type) {
	            this._lfo.type = type;
	        }
	    });
	    /**
		 *  Clean up.
		 *  @returns {Tone.Vibrato} this
		 */
	    Tone.Vibrato.prototype.dispose = function () {
	        Tone.Effect.prototype.dispose.call(this);
	        this._delayNode.dispose();
	        this._delayNode = null;
	        this._lfo.dispose();
	        this._lfo = null;
	        this._writable([
	            'frequency',
	            'depth'
	        ]);
	        this.frequency = null;
	        this.depth = null;
	    };
	    return Tone.Vibrato;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class  Tone.Event abstracts away Tone.Transport.schedule and provides a schedulable
		 *          callback for a single or repeatable events along the timeline. 
		 *
		 *  @extends {Tone}
		 *  @param {function} callback The callback to invoke at the time. 
		 *  @param {*} value The value or values which should be passed to
		 *                      the callback function on invocation.  
		 *  @example
		 * var chord = new Tone.Event(function(time, chord){
		 * 	//the chord as well as the exact time of the event
		 * 	//are passed in as arguments to the callback function
		 * }, ["D4", "E4", "F4"]);
		 * //start the chord at the beginning of the transport timeline
		 * chord.start();
		 * //loop it every measure for 8 measures
		 * chord.loop = 8;
		 * chord.loopEnd = "1m";
		 */
	    Tone.Event = function () {
	        var options = Tone.defaults(arguments, [
	            'callback',
	            'value'
	        ], Tone.Event);
	        Tone.call(this);
	        /**
			 *  Loop value
			 *  @type  {Boolean|Positive}
			 *  @private
			 */
	        this._loop = options.loop;
	        /**
			 *  The callback to invoke. 
			 *  @type  {Function}
			 */
	        this.callback = options.callback;
	        /**
			 *  The value which is passed to the
			 *  callback function.
			 *  @type  {*}
			 *  @private
			 */
	        this.value = options.value;
	        /**
			 *  When the note is scheduled to start.
			 *  @type  {Number}
			 *  @private
			 */
	        this._loopStart = this.toTicks(options.loopStart);
	        /**
			 *  When the note is scheduled to start.
			 *  @type  {Number}
			 *  @private
			 */
	        this._loopEnd = this.toTicks(options.loopEnd);
	        /**
			 *  Tracks the scheduled events
			 *  @type {Tone.TimelineState}
			 *  @private
			 */
	        this._state = new Tone.TimelineState(Tone.State.Stopped);
	        /**
			 *  The playback speed of the note. A speed of 1
			 *  is no change. 
			 *  @private
			 *  @type {Positive}
			 */
	        this._playbackRate = 1;
	        /**
			 *  A delay time from when the event is scheduled to start
			 *  @type {Ticks}
			 *  @private
			 */
	        this._startOffset = 0;
	        /**
			 *  private holder of probability value
			 *  @type {NormalRange}
			 *  @private
			 */
	        this._probability = options.probability;
	        /**
			 *  the amount of variation from the
			 *  given time. 
			 *  @type {Boolean|Time}
			 *  @private
			 */
	        this._humanize = options.humanize;
	        /**
			 *  If mute is true, the callback won't be
			 *  invoked.
			 *  @type {Boolean}
			 */
	        this.mute = options.mute;
	        //set the initial values
	        this.playbackRate = options.playbackRate;
	    };
	    Tone.extend(Tone.Event);
	    /**
		 *  The default values
		 *  @type  {Object}
		 *  @const
		 */
	    Tone.Event.defaults = {
	        'callback': Tone.noOp,
	        'loop': false,
	        'loopEnd': '1m',
	        'loopStart': 0,
	        'playbackRate': 1,
	        'value': null,
	        'probability': 1,
	        'mute': false,
	        'humanize': false
	    };
	    /**
		 *  Reschedule all of the events along the timeline
		 *  with the updated values.
		 *  @param {Time} after Only reschedules events after the given time.
		 *  @return  {Tone.Event}  this
		 *  @private
		 */
	    Tone.Event.prototype._rescheduleEvents = function (after) {
	        //if no argument is given, schedules all of the events
	        after = Tone.defaultArg(after, -1);
	        this._state.forEachFrom(after, function (event) {
	            var duration;
	            if (event.state === Tone.State.Started) {
	                if (!Tone.isUndef(event.id)) {
	                    Tone.Transport.clear(event.id);
	                }
	                var startTick = event.time + Math.round(this.startOffset / this._playbackRate);
	                if (this._loop) {
	                    duration = Infinity;
	                    if (Tone.isNumber(this._loop)) {
	                        duration = this._loop * this._getLoopDuration();
	                    }
	                    var nextEvent = this._state.getAfter(startTick);
	                    if (nextEvent !== null) {
	                        duration = Math.min(duration, nextEvent.time - startTick);
	                    }
	                    if (duration !== Infinity) {
	                        //schedule a stop since it's finite duration
	                        this._state.setStateAtTime(Tone.State.Stopped, startTick + duration + 1);
	                        duration = Tone.Time(duration, 'i');
	                    }
	                    var interval = Tone.Time(this._getLoopDuration(), 'i');
	                    event.id = Tone.Transport.scheduleRepeat(this._tick.bind(this), interval, Tone.TransportTime(startTick, 'i'), duration);
	                } else {
	                    event.id = Tone.Transport.schedule(this._tick.bind(this), startTick + 'i');
	                }
	            }
	        }.bind(this));
	        return this;
	    };
	    /**
		 *  Returns the playback state of the note, either "started" or "stopped".
		 *  @type {String}
		 *  @readOnly
		 *  @memberOf Tone.Event#
		 *  @name state
		 */
	    Object.defineProperty(Tone.Event.prototype, 'state', {
	        get: function () {
	            return this._state.getValueAtTime(Tone.Transport.ticks);
	        }
	    });
	    /**
		 *  The start from the scheduled start time
		 *  @type {Ticks}
		 *  @memberOf Tone.Event#
		 *  @name startOffset
		 *  @private
		 */
	    Object.defineProperty(Tone.Event.prototype, 'startOffset', {
	        get: function () {
	            return this._startOffset;
	        },
	        set: function (offset) {
	            this._startOffset = offset;
	        }
	    });
	    /**
		 *  The probability of the notes being triggered.
		 *  @memberOf Tone.Event#
		 *  @type {NormalRange}
		 *  @name probability
		 */
	    Object.defineProperty(Tone.Event.prototype, 'probability', {
	        get: function () {
	            return this._probability;
	        },
	        set: function (prob) {
	            this._probability = prob;
	        }
	    });
	    /**
		 *  If set to true, will apply small random variation
		 *  to the callback time. If the value is given as a time, it will randomize
		 *  by that amount.
		 *  @example
		 * event.humanize = true;
		 *  @type {Boolean|Time}
		 *  @name humanize
		 */
	    Object.defineProperty(Tone.Event.prototype, 'humanize', {
	        get: function () {
	            return this._humanize;
	        },
	        set: function (variation) {
	            this._humanize = variation;
	        }
	    });
	    /**
		 *  Start the note at the given time. 
		 *  @param  {TimelinePosition}  time  When the note should start.
		 *  @return  {Tone.Event}  this
		 */
	    Tone.Event.prototype.start = function (time) {
	        time = this.toTicks(time);
	        if (this._state.getValueAtTime(time) === Tone.State.Stopped) {
	            this._state.add({
	                'state': Tone.State.Started,
	                'time': time,
	                'id': undefined
	            });
	            this._rescheduleEvents(time);
	        }
	        return this;
	    };
	    /**
		 *  Stop the Event at the given time.
		 *  @param  {TimelinePosition}  time  When the note should stop.
		 *  @return  {Tone.Event}  this
		 */
	    Tone.Event.prototype.stop = function (time) {
	        this.cancel(time);
	        time = this.toTicks(time);
	        if (this._state.getValueAtTime(time) === Tone.State.Started) {
	            this._state.setStateAtTime(Tone.State.Stopped, time);
	            var previousEvent = this._state.getBefore(time);
	            var reschedulTime = time;
	            if (previousEvent !== null) {
	                reschedulTime = previousEvent.time;
	            }
	            this._rescheduleEvents(reschedulTime);
	        }
	        return this;
	    };
	    /**
		 *  Cancel all scheduled events greater than or equal to the given time
		 *  @param  {TimelinePosition}  [time=0]  The time after which events will be cancel.
		 *  @return  {Tone.Event}  this
		 */
	    Tone.Event.prototype.cancel = function (time) {
	        time = Tone.defaultArg(time, -Infinity);
	        time = this.toTicks(time);
	        this._state.forEachFrom(time, function (event) {
	            Tone.Transport.clear(event.id);
	        });
	        this._state.cancel(time);
	        return this;
	    };
	    /**
		 *  The callback function invoker. Also 
		 *  checks if the Event is done playing
		 *  @param  {Number}  time  The time of the event in seconds
		 *  @private
		 */
	    Tone.Event.prototype._tick = function (time) {
	        if (!this.mute && this._state.getValueAtTime(Tone.Transport.ticks) === Tone.State.Started) {
	            if (this.probability < 1 && Math.random() > this.probability) {
	                return;
	            }
	            if (this.humanize) {
	                var variation = 0.02;
	                if (!Tone.isBoolean(this.humanize)) {
	                    variation = this.toSeconds(this.humanize);
	                }
	                time += (Math.random() * 2 - 1) * variation;
	            }
	            this.callback(time, this.value);
	        }
	    };
	    /**
		 *  Get the duration of the loop.
		 *  @return  {Ticks}
		 *  @private
		 */
	    Tone.Event.prototype._getLoopDuration = function () {
	        return Math.round((this._loopEnd - this._loopStart) / this._playbackRate);
	    };
	    /**
		 *  If the note should loop or not
		 *  between Tone.Event.loopStart and 
		 *  Tone.Event.loopEnd. An integer
		 *  value corresponds to the number of
		 *  loops the Event does after it starts.
		 *  @memberOf Tone.Event#
		 *  @type {Boolean|Positive}
		 *  @name loop
		 */
	    Object.defineProperty(Tone.Event.prototype, 'loop', {
	        get: function () {
	            return this._loop;
	        },
	        set: function (loop) {
	            this._loop = loop;
	            this._rescheduleEvents();
	        }
	    });
	    /**
		 * 	The playback rate of the note. Defaults to 1.
		 *  @memberOf Tone.Event#
		 *  @type {Positive}
		 *  @name playbackRate
		 *  @example
		 * note.loop = true;
		 * //repeat the note twice as fast
		 * note.playbackRate = 2;
		 */
	    Object.defineProperty(Tone.Event.prototype, 'playbackRate', {
	        get: function () {
	            return this._playbackRate;
	        },
	        set: function (rate) {
	            this._playbackRate = rate;
	            this._rescheduleEvents();
	        }
	    });
	    /**
		 *  The loopEnd point is the time the event will loop
		 *  if Tone.Event.loop is true.
		 *  @memberOf Tone.Event#
		 *  @type {TransportTime}
		 *  @name loopEnd
		 */
	    Object.defineProperty(Tone.Event.prototype, 'loopEnd', {
	        get: function () {
	            return Tone.TransportTime(this._loopEnd, 'i').toNotation();
	        },
	        set: function (loopEnd) {
	            this._loopEnd = this.toTicks(loopEnd);
	            if (this._loop) {
	                this._rescheduleEvents();
	            }
	        }
	    });
	    /**
		 *  The time when the loop should start. 
		 *  @memberOf Tone.Event#
		 *  @type {TransportTime}
		 *  @name loopStart
		 */
	    Object.defineProperty(Tone.Event.prototype, 'loopStart', {
	        get: function () {
	            return Tone.TransportTime(this._loopStart, 'i').toNotation();
	        },
	        set: function (loopStart) {
	            this._loopStart = this.toTicks(loopStart);
	            if (this._loop) {
	                this._rescheduleEvents();
	            }
	        }
	    });
	    /**
		 *  The current progress of the loop interval.
		 *  Returns 0 if the event is not started yet or
		 *  it is not set to loop.
		 *  @memberOf Tone.Event#
		 *  @type {NormalRange}
		 *  @name progress
		 *  @readOnly
		 */
	    Object.defineProperty(Tone.Event.prototype, 'progress', {
	        get: function () {
	            if (this._loop) {
	                var ticks = Tone.Transport.ticks;
	                var lastEvent = this._state.get(ticks);
	                if (lastEvent !== null && lastEvent.state === Tone.State.Started) {
	                    var loopDuration = this._getLoopDuration();
	                    var progress = (ticks - lastEvent.time) % loopDuration;
	                    return progress / loopDuration;
	                } else {
	                    return 0;
	                }
	            } else {
	                return 0;
	            }
	        }
	    });
	    /**
		 *  Clean up
		 *  @return  {Tone.Event}  this
		 */
	    Tone.Event.prototype.dispose = function () {
	        this.cancel();
	        this._state.dispose();
	        this._state = null;
	        this.callback = null;
	        this.value = null;
	    };
	    return Tone.Event;
	});
	Module(function (Tone) {
	    /**
		 *  @class Tone.Loop creates a looped callback at the 
		 *         specified interval. The callback can be 
		 *         started, stopped and scheduled along
		 *         the Transport's timeline. 
		 *  @example
		 * var loop = new Tone.Loop(function(time){
		 * 	//triggered every eighth note. 
		 * 	console.log(time);
		 * }, "8n").start(0);
		 * Tone.Transport.start();
		 *  @extends {Tone}
		 *  @param {Function} callback The callback to invoke with the event.
		 *  @param {Time} interval The time between successive callback calls. 
		 */
	    Tone.Loop = function () {
	        var options = Tone.defaults(arguments, [
	            'callback',
	            'interval'
	        ], Tone.Loop);
	        Tone.call(this);
	        /**
			 *  The event which produces the callbacks
			 */
	        this._event = new Tone.Event({
	            'callback': this._tick.bind(this),
	            'loop': true,
	            'loopEnd': options.interval,
	            'playbackRate': options.playbackRate,
	            'probability': options.probability
	        });
	        /**
			 *  The callback to invoke with the next event in the pattern
			 *  @type {Function}
			 */
	        this.callback = options.callback;
	        //set the iterations
	        this.iterations = options.iterations;
	    };
	    Tone.extend(Tone.Loop);
	    /**
		 *  The defaults
		 *  @const
		 *  @type  {Object}
		 */
	    Tone.Loop.defaults = {
	        'interval': '4n',
	        'callback': Tone.noOp,
	        'playbackRate': 1,
	        'iterations': Infinity,
	        'probability': true,
	        'mute': false
	    };
	    /**
		 *  Start the loop at the specified time along the Transport's
		 *  timeline.
		 *  @param  {TimelinePosition=}  time  When to start the Loop.
		 *  @return  {Tone.Loop}  this
		 */
	    Tone.Loop.prototype.start = function (time) {
	        this._event.start(time);
	        return this;
	    };
	    /**
		 *  Stop the loop at the given time.
		 *  @param  {TimelinePosition=}  time  When to stop the Arpeggio
		 *  @return  {Tone.Loop}  this
		 */
	    Tone.Loop.prototype.stop = function (time) {
	        this._event.stop(time);
	        return this;
	    };
	    /**
		 *  Cancel all scheduled events greater than or equal to the given time
		 *  @param  {TimelinePosition}  [time=0]  The time after which events will be cancel.
		 *  @return  {Tone.Loop}  this
		 */
	    Tone.Loop.prototype.cancel = function (time) {
	        this._event.cancel(time);
	        return this;
	    };
	    /**
		 *  Internal function called when the notes should be called
		 *  @param  {Number}  time  The time the event occurs
		 *  @private
		 */
	    Tone.Loop.prototype._tick = function (time) {
	        this.callback(time);
	    };
	    /**
		 *  The state of the Loop, either started or stopped.
		 *  @memberOf Tone.Loop#
		 *  @type {String}
		 *  @name state
		 *  @readOnly
		 */
	    Object.defineProperty(Tone.Loop.prototype, 'state', {
	        get: function () {
	            return this._event.state;
	        }
	    });
	    /**
		 *  The progress of the loop as a value between 0-1. 0, when
		 *  the loop is stopped or done iterating. 
		 *  @memberOf Tone.Loop#
		 *  @type {NormalRange}
		 *  @name progress
		 *  @readOnly
		 */
	    Object.defineProperty(Tone.Loop.prototype, 'progress', {
	        get: function () {
	            return this._event.progress;
	        }
	    });
	    /**
		 *  The time between successive callbacks. 
		 *  @example
		 * loop.interval = "8n"; //loop every 8n
		 *  @memberOf Tone.Loop#
		 *  @type {Time}
		 *  @name interval
		 */
	    Object.defineProperty(Tone.Loop.prototype, 'interval', {
	        get: function () {
	            return this._event.loopEnd;
	        },
	        set: function (interval) {
	            this._event.loopEnd = interval;
	        }
	    });
	    /**
		 *  The playback rate of the loop. The normal playback rate is 1 (no change). 
		 *  A `playbackRate` of 2 would be twice as fast. 
		 *  @memberOf Tone.Loop#
		 *  @type {Time}
		 *  @name playbackRate
		 */
	    Object.defineProperty(Tone.Loop.prototype, 'playbackRate', {
	        get: function () {
	            return this._event.playbackRate;
	        },
	        set: function (rate) {
	            this._event.playbackRate = rate;
	        }
	    });
	    /**
		 *  Random variation +/-0.01s to the scheduled time. 
		 *  Or give it a time value which it will randomize by.
		 *  @type {Boolean|Time}
		 *  @memberOf Tone.Loop#
		 *  @name humanize
		 */
	    Object.defineProperty(Tone.Loop.prototype, 'humanize', {
	        get: function () {
	            return this._event.humanize;
	        },
	        set: function (variation) {
	            this._event.humanize = variation;
	        }
	    });
	    /**
		 *  The probably of the callback being invoked.
		 *  @memberOf Tone.Loop#
		 *  @type {NormalRange}
		 *  @name probability
		 */
	    Object.defineProperty(Tone.Loop.prototype, 'probability', {
	        get: function () {
	            return this._event.probability;
	        },
	        set: function (prob) {
	            this._event.probability = prob;
	        }
	    });
	    /**
		 *  Muting the Loop means that no callbacks are invoked.
		 *  @memberOf Tone.Loop#
		 *  @type {Boolean}
		 *  @name mute
		 */
	    Object.defineProperty(Tone.Loop.prototype, 'mute', {
	        get: function () {
	            return this._event.mute;
	        },
	        set: function (mute) {
	            this._event.mute = mute;
	        }
	    });
	    /**
		 *  The number of iterations of the loop. The default
		 *  value is Infinity (loop forever).
		 *  @memberOf Tone.Loop#
		 *  @type {Positive}
		 *  @name iterations
		 */
	    Object.defineProperty(Tone.Loop.prototype, 'iterations', {
	        get: function () {
	            if (this._event.loop === true) {
	                return Infinity;
	            } else {
	                return this._event.loop;
	            }
	        },
	        set: function (iters) {
	            if (iters === Infinity) {
	                this._event.loop = true;
	            } else {
	                this._event.loop = iters;
	            }
	        }
	    });
	    /**
		 *  Clean up
		 *  @return  {Tone.Loop}  this
		 */
	    Tone.Loop.prototype.dispose = function () {
	        this._event.dispose();
	        this._event = null;
	        this.callback = null;
	    };
	    return Tone.Loop;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Tone.Part is a collection Tone.Events which can be
		 *         started/stopped and looped as a single unit.
		 *
		 *  @extends {Tone.Event}
		 *  @param {Function} callback The callback to invoke on each event
		 *  @param {Array} events the array of events
		 *  @example
		 * var part = new Tone.Part(function(time, note){
		 * 	//the notes given as the second element in the array
		 * 	//will be passed in as the second argument
		 * 	synth.triggerAttackRelease(note, "8n", time);
		 * }, [[0, "C2"], ["0:2", "C3"], ["0:3:2", "G2"]]);
		 *  @example
		 * //use an array of objects as long as the object has a "time" attribute
		 * var part = new Tone.Part(function(time, value){
		 * 	//the value is an object which contains both the note and the velocity
		 * 	synth.triggerAttackRelease(value.note, "8n", time, value.velocity);
		 * }, [{"time" : 0, "note" : "C3", "velocity": 0.9}, 
		 * 	   {"time" : "0:2", "note" : "C4", "velocity": 0.5}
		 * ]).start(0);
		 */
	    Tone.Part = function () {
	        var options = Tone.defaults(arguments, [
	            'callback',
	            'events'
	        ], Tone.Part);
	        Tone.Event.call(this, options);
	        /**
			 *  An array of Objects. 
			 *  @type  {Array}
			 *  @private
			 */
	        this._events = [];
	        //add the events
	        for (var i = 0; i < options.events.length; i++) {
	            if (Array.isArray(options.events[i])) {
	                this.add(options.events[i][0], options.events[i][1]);
	            } else {
	                this.add(options.events[i]);
	            }
	        }
	    };
	    Tone.extend(Tone.Part, Tone.Event);
	    /**
		 *  The default values
		 *  @type  {Object}
		 *  @const
		 */
	    Tone.Part.defaults = {
	        'callback': Tone.noOp,
	        'loop': false,
	        'loopEnd': '1m',
	        'loopStart': 0,
	        'playbackRate': 1,
	        'probability': 1,
	        'humanize': false,
	        'mute': false,
	        'events': []
	    };
	    /**
		 *  Start the part at the given time. 
		 *  @param  {TransportTime}  time    When to start the part.
		 *  @param  {Time=}  offset  The offset from the start of the part
		 *                           to begin playing at.
		 *  @return  {Tone.Part}  this
		 */
	    Tone.Part.prototype.start = function (time, offset) {
	        var ticks = this.toTicks(time);
	        if (this._state.getValueAtTime(ticks) !== Tone.State.Started) {
	            if (this._loop) {
	                offset = Tone.defaultArg(offset, this._loopStart);
	            } else {
	                offset = Tone.defaultArg(offset, 0);
	            }
	            offset = this.toTicks(offset);
	            this._state.add({
	                'state': Tone.State.Started,
	                'time': ticks,
	                'offset': offset
	            });
	            this._forEach(function (event) {
	                this._startNote(event, ticks, offset);
	            });
	        }
	        return this;
	    };
	    /**
		 *  Start the event in the given event at the correct time given
		 *  the ticks and offset and looping.
		 *  @param  {Tone.Event}  event 
		 *  @param  {Ticks}  ticks
		 *  @param  {Ticks}  offset
		 *  @private
		 */
	    Tone.Part.prototype._startNote = function (event, ticks, offset) {
	        ticks -= offset;
	        if (this._loop) {
	            if (event.startOffset >= this._loopStart && event.startOffset < this._loopEnd) {
	                if (event.startOffset < offset) {
	                    //start it on the next loop
	                    ticks += this._getLoopDuration();
	                }
	                event.start(Tone.TransportTime(ticks, 'i'));
	            } else if (event.startOffset < this._loopStart && event.startOffset >= offset) {
	                event.loop = false;
	                event.start(Tone.TransportTime(ticks, 'i'));
	            }
	        } else {
	            if (event.startOffset >= offset) {
	                event.start(Tone.TransportTime(ticks, 'i'));
	            }
	        }
	    };
	    /**
		 *  The start from the scheduled start time
		 *  @type {Ticks}
		 *  @memberOf Tone.Part#
		 *  @name startOffset
		 *  @private
		 */
	    Object.defineProperty(Tone.Part.prototype, 'startOffset', {
	        get: function () {
	            return this._startOffset;
	        },
	        set: function (offset) {
	            this._startOffset = offset;
	            this._forEach(function (event) {
	                event.startOffset += this._startOffset;
	            });
	        }
	    });
	    /**
		 *  Stop the part at the given time.
		 *  @param  {TimelinePosition}  time  When to stop the part.
		 *  @return  {Tone.Part}  this
		 */
	    Tone.Part.prototype.stop = function (time) {
	        var ticks = this.toTicks(time);
	        this._state.cancel(ticks);
	        this._state.setStateAtTime(Tone.State.Stopped, ticks);
	        this._forEach(function (event) {
	            event.stop(time);
	        });
	        return this;
	    };
	    /**
		 *  Get/Set an Event's value at the given time. 
		 *  If a value is passed in and no event exists at
		 *  the given time, one will be created with that value. 
		 *  If two events are at the same time, the first one will
		 *  be returned.
		 *  @example
		 * part.at("1m"); //returns the part at the first measure
		 *
		 * part.at("2m", "C2"); //set the value at "2m" to C2. 
		 * //if an event didn't exist at that time, it will be created.
		 *  @param {TransportTime} time The time of the event to get or set.
		 *  @param {*=} value If a value is passed in, the value of the
		 *                    event at the given time will be set to it.
		 *  @return {Tone.Event} the event at the time
		 */
	    Tone.Part.prototype.at = function (time, value) {
	        time = Tone.TransportTime(time);
	        var tickTime = Tone.Time(1, 'i').toSeconds();
	        for (var i = 0; i < this._events.length; i++) {
	            var event = this._events[i];
	            if (Math.abs(time.toTicks() - event.startOffset) < tickTime) {
	                if (!Tone.isUndef(value)) {
	                    event.value = value;
	                }
	                return event;
	            }
	        }
	        //if there was no event at that time, create one
	        if (!Tone.isUndef(value)) {
	            this.add(time, value);
	            //return the new event
	            return this._events[this._events.length - 1];
	        } else {
	            return null;
	        }
	    };
	    /**
		 *  Add a an event to the part. 
		 *  @param {Time} time The time the note should start.
		 *                            If an object is passed in, it should
		 *                            have a 'time' attribute and the rest
		 *                            of the object will be used as the 'value'.
		 *  @param  {Tone.Event|*}  value 
		 *  @returns {Tone.Part} this
		 *  @example
		 * part.add("1m", "C#+11");
		 */
	    Tone.Part.prototype.add = function (time, value) {
	        //extract the parameters
	        if (time.hasOwnProperty('time')) {
	            value = time;
	            time = value.time;
	        }
	        time = this.toTicks(time);
	        var event;
	        if (value instanceof Tone.Event) {
	            event = value;
	            event.callback = this._tick.bind(this);
	        } else {
	            event = new Tone.Event({
	                'callback': this._tick.bind(this),
	                'value': value
	            });
	        }
	        //the start offset
	        event.startOffset = time;
	        //initialize the values
	        event.set({
	            'loopEnd': this.loopEnd,
	            'loopStart': this.loopStart,
	            'loop': this.loop,
	            'humanize': this.humanize,
	            'playbackRate': this.playbackRate,
	            'probability': this.probability
	        });
	        this._events.push(event);
	        //start the note if it should be played right now
	        this._restartEvent(event);
	        return this;
	    };
	    /**
		 *  Restart the given event
		 *  @param  {Tone.Event}  event 
		 *  @private
		 */
	    Tone.Part.prototype._restartEvent = function (event) {
	        this._state.forEach(function (stateEvent) {
	            if (stateEvent.state === Tone.State.Started) {
	                this._startNote(event, stateEvent.time, stateEvent.offset);
	            } else {
	                //stop the note
	                event.stop(Tone.TransportTime(stateEvent.time, 'i'));
	            }
	        }.bind(this));
	    };
	    /**
		 *  Remove an event from the part. Will recursively iterate
		 *  into nested parts to find the event.
		 *  @param {Time} time The time of the event
		 *  @param {*} value Optionally select only a specific event value
		 *  @return  {Tone.Part}  this
		 */
	    Tone.Part.prototype.remove = function (time, value) {
	        //extract the parameters
	        if (time.hasOwnProperty('time')) {
	            value = time;
	            time = value.time;
	        }
	        time = this.toTicks(time);
	        for (var i = this._events.length - 1; i >= 0; i--) {
	            var event = this._events[i];
	            if (event instanceof Tone.Part) {
	                event.remove(time, value);
	            } else {
	                if (event.startOffset === time) {
	                    if (Tone.isUndef(value) || !Tone.isUndef(value) && event.value === value) {
	                        this._events.splice(i, 1);
	                        event.dispose();
	                    }
	                }
	            }
	        }
	        return this;
	    };
	    /**
		 *  Remove all of the notes from the group. 
		 *  @return  {Tone.Part}  this
		 */
	    Tone.Part.prototype.removeAll = function () {
	        this._forEach(function (event) {
	            event.dispose();
	        });
	        this._events = [];
	        return this;
	    };
	    /**
		 *  Cancel scheduled state change events: i.e. "start" and "stop".
		 *  @param {TimelinePosition} after The time after which to cancel the scheduled events.
		 *  @return  {Tone.Part}  this
		 */
	    Tone.Part.prototype.cancel = function (after) {
	        this._forEach(function (event) {
	            event.cancel(after);
	        });
	        this._state.cancel(this.toTicks(after));
	        return this;
	    };
	    /**
		 *  Iterate over all of the events
		 *  @param {Function} callback
		 *  @param {Object} ctx The context
		 *  @private
		 */
	    Tone.Part.prototype._forEach = function (callback, ctx) {
	        if (this._events) {
	            ctx = Tone.defaultArg(ctx, this);
	            for (var i = this._events.length - 1; i >= 0; i--) {
	                var e = this._events[i];
	                if (e instanceof Tone.Part) {
	                    e._forEach(callback, ctx);
	                } else {
	                    callback.call(ctx, e);
	                }
	            }
	        }
	        return this;
	    };
	    /**
		 *  Set the attribute of all of the events
		 *  @param  {String}  attr  the attribute to set
		 *  @param  {*}  value      The value to set it to
		 *  @private
		 */
	    Tone.Part.prototype._setAll = function (attr, value) {
	        this._forEach(function (event) {
	            event[attr] = value;
	        });
	    };
	    /**
		 *  Internal tick method
		 *  @param  {Number}  time  The time of the event in seconds
		 *  @private
		 */
	    Tone.Part.prototype._tick = function (time, value) {
	        if (!this.mute) {
	            this.callback(time, value);
	        }
	    };
	    /**
		 *  Determine if the event should be currently looping
		 *  given the loop boundries of this Part.
		 *  @param  {Tone.Event}  event  The event to test
		 *  @private
		 */
	    Tone.Part.prototype._testLoopBoundries = function (event) {
	        if (event.startOffset < this._loopStart || event.startOffset >= this._loopEnd) {
	            event.cancel(0);
	        } else {
	            //reschedule it if it's stopped
	            if (event.state === Tone.State.Stopped) {
	                this._restartEvent(event);
	            }
	        }
	    };
	    /**
		 *  The probability of the notes being triggered.
		 *  @memberOf Tone.Part#
		 *  @type {NormalRange}
		 *  @name probability
		 */
	    Object.defineProperty(Tone.Part.prototype, 'probability', {
	        get: function () {
	            return this._probability;
	        },
	        set: function (prob) {
	            this._probability = prob;
	            this._setAll('probability', prob);
	        }
	    });
	    /**
		 *  If set to true, will apply small random variation
		 *  to the callback time. If the value is given as a time, it will randomize
		 *  by that amount.
		 *  @example
		 * event.humanize = true;
		 *  @type {Boolean|Time}
		 *  @name humanize
		 */
	    Object.defineProperty(Tone.Part.prototype, 'humanize', {
	        get: function () {
	            return this._humanize;
	        },
	        set: function (variation) {
	            this._humanize = variation;
	            this._setAll('humanize', variation);
	        }
	    });
	    /**
		 *  If the part should loop or not
		 *  between Tone.Part.loopStart and 
		 *  Tone.Part.loopEnd. An integer
		 *  value corresponds to the number of
		 *  loops the Part does after it starts.
		 *  @memberOf Tone.Part#
		 *  @type {Boolean|Positive}
		 *  @name loop
		 *  @example
		 * //loop the part 8 times
		 * part.loop = 8;
		 */
	    Object.defineProperty(Tone.Part.prototype, 'loop', {
	        get: function () {
	            return this._loop;
	        },
	        set: function (loop) {
	            this._loop = loop;
	            this._forEach(function (event) {
	                event._loopStart = this._loopStart;
	                event._loopEnd = this._loopEnd;
	                event.loop = loop;
	                this._testLoopBoundries(event);
	            });
	        }
	    });
	    /**
		 *  The loopEnd point determines when it will 
		 *  loop if Tone.Part.loop is true.
		 *  @memberOf Tone.Part#
		 *  @type {TransportTime}
		 *  @name loopEnd
		 */
	    Object.defineProperty(Tone.Part.prototype, 'loopEnd', {
	        get: function () {
	            return Tone.TransportTime(this._loopEnd, 'i').toNotation();
	        },
	        set: function (loopEnd) {
	            this._loopEnd = this.toTicks(loopEnd);
	            if (this._loop) {
	                this._forEach(function (event) {
	                    event.loopEnd = loopEnd;
	                    this._testLoopBoundries(event);
	                });
	            }
	        }
	    });
	    /**
		 *  The loopStart point determines when it will 
		 *  loop if Tone.Part.loop is true.
		 *  @memberOf Tone.Part#
		 *  @type {TransportTime}
		 *  @name loopStart
		 */
	    Object.defineProperty(Tone.Part.prototype, 'loopStart', {
	        get: function () {
	            return Tone.TransportTime(this._loopStart, 'i').toNotation();
	        },
	        set: function (loopStart) {
	            this._loopStart = this.toTicks(loopStart);
	            if (this._loop) {
	                this._forEach(function (event) {
	                    event.loopStart = this.loopStart;
	                    this._testLoopBoundries(event);
	                });
	            }
	        }
	    });
	    /**
		 * 	The playback rate of the part
		 *  @memberOf Tone.Part#
		 *  @type {Positive}
		 *  @name playbackRate
		 */
	    Object.defineProperty(Tone.Part.prototype, 'playbackRate', {
	        get: function () {
	            return this._playbackRate;
	        },
	        set: function (rate) {
	            this._playbackRate = rate;
	            this._setAll('playbackRate', rate);
	        }
	    });
	    /**
		 * 	The number of scheduled notes in the part. 
		 *  @memberOf Tone.Part#
		 *  @type {Positive}
		 *  @name length
		 *  @readOnly
		 */
	    Object.defineProperty(Tone.Part.prototype, 'length', {
	        get: function () {
	            return this._events.length;
	        }
	    });
	    /**
		 *  Clean up
		 *  @return  {Tone.Part}  this
		 */
	    Tone.Part.prototype.dispose = function () {
	        this.removeAll();
	        this._state.dispose();
	        this._state = null;
	        this.callback = null;
	        this._events = null;
	        return this;
	    };
	    return Tone.Part;
	});
	Module(function (Tone) {
	    /**
		 *  @class Tone.Pattern arpeggiates between the given notes
		 *         in a number of patterns. See Tone.CtrlPattern for
		 *         a full list of patterns.
		 *  @example
		 * var pattern = new Tone.Pattern(function(time, note){
		 *   //the order of the notes passed in depends on the pattern
		 * }, ["C2", "D4", "E5", "A6"], "upDown");
		 *  @extends {Tone.Loop}
		 *  @param {Function} callback The callback to invoke with the
		 *                             event.
		 *  @param {Array} values The values to arpeggiate over.
		 */
	    Tone.Pattern = function () {
	        var options = Tone.defaults(arguments, [
	            'callback',
	            'values',
	            'pattern'
	        ], Tone.Pattern);
	        Tone.Loop.call(this, options);
	        /**
			 *  The pattern manager
			 *  @type {Tone.CtrlPattern}
			 *  @private
			 */
	        this._pattern = new Tone.CtrlPattern({
	            'values': options.values,
	            'type': options.pattern,
	            'index': options.index
	        });
	    };
	    Tone.extend(Tone.Pattern, Tone.Loop);
	    /**
		 *  The defaults
		 *  @const
		 *  @type  {Object}
		 */
	    Tone.Pattern.defaults = {
	        'pattern': Tone.CtrlPattern.Type.Up,
	        'callback': Tone.noOp,
	        'values': []
	    };
	    /**
		 *  Internal function called when the notes should be called
		 *  @param  {Number}  time  The time the event occurs
		 *  @private
		 */
	    Tone.Pattern.prototype._tick = function (time) {
	        this.callback(time, this._pattern.value);
	        this._pattern.next();
	    };
	    /**
		 *  The current index in the values array.
		 *  @memberOf Tone.Pattern#
		 *  @type {Positive}
		 *  @name index
		 */
	    Object.defineProperty(Tone.Pattern.prototype, 'index', {
	        get: function () {
	            return this._pattern.index;
	        },
	        set: function (i) {
	            this._pattern.index = i;
	        }
	    });
	    /**
		 *  The array of events.
		 *  @memberOf Tone.Pattern#
		 *  @type {Array}
		 *  @name values
		 */
	    Object.defineProperty(Tone.Pattern.prototype, 'values', {
	        get: function () {
	            return this._pattern.values;
	        },
	        set: function (vals) {
	            this._pattern.values = vals;
	        }
	    });
	    /**
		 *  The current value of the pattern.
		 *  @memberOf Tone.Pattern#
		 *  @type {*}
		 *  @name value
		 *  @readOnly
		 */
	    Object.defineProperty(Tone.Pattern.prototype, 'value', {
	        get: function () {
	            return this._pattern.value;
	        }
	    });
	    /**
		 *  The pattern type. See Tone.CtrlPattern for the full list of patterns.
		 *  @memberOf Tone.Pattern#
		 *  @type {String}
		 *  @name pattern
		 */
	    Object.defineProperty(Tone.Pattern.prototype, 'pattern', {
	        get: function () {
	            return this._pattern.type;
	        },
	        set: function (pattern) {
	            this._pattern.type = pattern;
	        }
	    });
	    /**
		 *  Clean up
		 *  @return  {Tone.Pattern}  this
		 */
	    Tone.Pattern.prototype.dispose = function () {
	        Tone.Loop.prototype.dispose.call(this);
	        this._pattern.dispose();
	        this._pattern = null;
	    };
	    return Tone.Pattern;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class A sequence is an alternate notation of a part. Instead
		 *         of passing in an array of [time, event] pairs, pass
		 *         in an array of events which will be spaced at the
		 *         given subdivision. Sub-arrays will subdivide that beat
		 *         by the number of items are in the array. 
		 *         Sequence notation inspiration from [Tidal](http://yaxu.org/tidal/)
		 *  @param  {Function}  callback  The callback to invoke with every note
		 *  @param  {Array}    events  The sequence
		 *  @param  {Time} subdivision  The subdivision between which events are placed. 
		 *  @extends {Tone.Part}
		 *  @example
		 * var seq = new Tone.Sequence(function(time, note){
		 * 	console.log(note);
		 * //straight quater notes
		 * }, ["C4", "E4", "G4", "A4"], "4n");
		 *  @example
		 * var seq = new Tone.Sequence(function(time, note){
		 * 	console.log(note);
		 * //subdivisions are given as subarrays
		 * }, ["C4", ["E4", "D4", "E4"], "G4", ["A4", "G4"]]);
		 */
	    Tone.Sequence = function () {
	        var options = Tone.defaults(arguments, [
	            'callback',
	            'events',
	            'subdivision'
	        ], Tone.Sequence);
	        //remove the events
	        var events = options.events;
	        delete options.events;
	        Tone.Part.call(this, options);
	        /**
			 *  The subdivison of each note
			 *  @type  {Ticks}
			 *  @private
			 */
	        this._subdivision = this.toTicks(options.subdivision);
	        //if no time was passed in, the loop end is the end of the cycle
	        if (Tone.isUndef(options.loopEnd) && !Tone.isUndef(events)) {
	            this._loopEnd = events.length * this._subdivision;
	        }
	        //defaults to looping
	        this._loop = true;
	        //add all of the events
	        if (!Tone.isUndef(events)) {
	            for (var i = 0; i < events.length; i++) {
	                this.add(i, events[i]);
	            }
	        }
	    };
	    Tone.extend(Tone.Sequence, Tone.Part);
	    /**
		 *  The default values.
		 *  @type  {Object}
		 */
	    Tone.Sequence.defaults = { 'subdivision': '4n' };
	    /**
		 *  The subdivision of the sequence. This can only be 
		 *  set in the constructor. The subdivision is the 
		 *  interval between successive steps. 
		 *  @type {Time}
		 *  @memberOf Tone.Sequence#
		 *  @name subdivision
		 *  @readOnly
		 */
	    Object.defineProperty(Tone.Sequence.prototype, 'subdivision', {
	        get: function () {
	            return Tone.Time(this._subdivision, 'i').toNotation();
	        }
	    });
	    /**
		 *  Get/Set an index of the sequence. If the index contains a subarray, 
		 *  a Tone.Sequence representing that sub-array will be returned. 
		 *  @example
		 * var sequence = new Tone.Sequence(playNote, ["E4", "C4", "F#4", ["A4", "Bb3"]])
		 * sequence.at(0)// => returns "E4"
		 * //set a value
		 * sequence.at(0, "G3");
		 * //get a nested sequence
		 * sequence.at(3).at(1)// => returns "Bb3"
		 * @param {Positive} index The index to get or set
		 * @param {*} value Optionally pass in the value to set at the given index.
		 */
	    Tone.Sequence.prototype.at = function (index, value) {
	        //if the value is an array, 
	        if (Tone.isArray(value)) {
	            //remove the current event at that index
	            this.remove(index);
	        }
	        //call the parent's method
	        return Tone.Part.prototype.at.call(this, this._indexTime(index), value);
	    };
	    /**
		 *  Add an event at an index, if there's already something
		 *  at that index, overwrite it. If `value` is an array, 
		 *  it will be parsed as a subsequence.
		 *  @param {Number} index The index to add the event to
		 *  @param {*} value The value to add at that index
		 *  @returns {Tone.Sequence} this
		 */
	    Tone.Sequence.prototype.add = function (index, value) {
	        if (value === null) {
	            return this;
	        }
	        if (Tone.isArray(value)) {
	            //make a subsequence and add that to the sequence
	            var subSubdivision = Math.round(this._subdivision / value.length);
	            value = new Tone.Sequence(this._tick.bind(this), value, Tone.Time(subSubdivision, 'i'));
	        }
	        Tone.Part.prototype.add.call(this, this._indexTime(index), value);
	        return this;
	    };
	    /**
		 *  Remove a value from the sequence by index
		 *  @param {Number} index The index of the event to remove
		 *  @returns {Tone.Sequence} this
		 */
	    Tone.Sequence.prototype.remove = function (index, value) {
	        Tone.Part.prototype.remove.call(this, this._indexTime(index), value);
	        return this;
	    };
	    /**
		 *  Get the time of the index given the Sequence's subdivision
		 *  @param  {Number}  index 
		 *  @return  {Time}  The time of that index
		 *  @private
		 */
	    Tone.Sequence.prototype._indexTime = function (index) {
	        if (index instanceof Tone.TransportTime) {
	            return index;
	        } else {
	            return Tone.TransportTime(index * this._subdivision + this.startOffset, 'i');
	        }
	    };
	    /**
		 *  Clean up.
		 *  @return {Tone.Sequence} this
		 */
	    Tone.Sequence.prototype.dispose = function () {
	        Tone.Part.prototype.dispose.call(this);
	        return this;
	    };
	    return Tone.Sequence;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Tone.PulseOscillator is a pulse oscillator with control over pulse width,
		 *         also known as the duty cycle. At 50% duty cycle (width = 0.5) the wave is 
		 *         a square and only odd-numbered harmonics are present. At all other widths 
		 *         even-numbered harmonics are present. Read more 
		 *         [here](https://wigglewave.wordpress.com/2014/08/16/pulse-waveforms-and-harmonics/).
		 *
		 *  @constructor
		 *  @extends {Tone.Source}
		 *  @param {Frequency} [frequency] The frequency of the oscillator
		 *  @param {NormalRange} [width] The width of the pulse
		 *  @example
		 * var pulse = new Tone.PulseOscillator("E5", 0.4).toMaster().start();
		 */
	    Tone.PulseOscillator = function () {
	        var options = Tone.defaults(arguments, [
	            'frequency',
	            'width'
	        ], Tone.Oscillator);
	        Tone.Source.call(this, options);
	        /**
			 *  The width of the pulse. 
			 *  @type {NormalRange}
			 *  @signal
			 */
	        this.width = new Tone.Signal(options.width, Tone.Type.NormalRange);
	        /**
			 *  gate the width amount
			 *  @type {Tone.Gain}
			 *  @private
			 */
	        this._widthGate = new Tone.Gain();
	        /**
			 *  the sawtooth oscillator
			 *  @type {Tone.Oscillator}
			 *  @private
			 */
	        this._sawtooth = new Tone.Oscillator({
	            frequency: options.frequency,
	            detune: options.detune,
	            type: 'sawtooth',
	            phase: options.phase
	        });
	        /**
			 *  The frequency control.
			 *  @type {Frequency}
			 *  @signal
			 */
	        this.frequency = this._sawtooth.frequency;
	        /**
			 *  The detune in cents. 
			 *  @type {Cents}
			 *  @signal
			 */
	        this.detune = this._sawtooth.detune;
	        /**
			 *  Threshold the signal to turn it into a square
			 *  @type {Tone.WaveShaper}
			 *  @private
			 */
	        this._thresh = new Tone.WaveShaper(function (val) {
	            if (val < 0) {
	                return -1;
	            } else {
	                return 1;
	            }
	        });
	        //connections
	        this._sawtooth.chain(this._thresh, this.output);
	        this.width.chain(this._widthGate, this._thresh);
	        this._readOnly([
	            'width',
	            'frequency',
	            'detune'
	        ]);
	    };
	    Tone.extend(Tone.PulseOscillator, Tone.Source);
	    /**
		 *  The default parameters.
		 *  @static
		 *  @const
		 *  @type {Object}
		 */
	    Tone.PulseOscillator.defaults = {
	        'frequency': 440,
	        'detune': 0,
	        'phase': 0,
	        'width': 0.2
	    };
	    /**
		 *  start the oscillator
		 *  @param  {Time} time 
		 *  @private
		 */
	    Tone.PulseOscillator.prototype._start = function (time) {
	        time = this.toSeconds(time);
	        this._sawtooth.start(time);
	        this._widthGate.gain.setValueAtTime(1, time);
	    };
	    /**
		 *  stop the oscillator
		 *  @param  {Time} time 
		 *  @private
		 */
	    Tone.PulseOscillator.prototype._stop = function (time) {
	        time = this.toSeconds(time);
	        this._sawtooth.stop(time);
	        //the width is still connected to the output. 
	        //that needs to be stopped also
	        this._widthGate.gain.setValueAtTime(0, time);
	    };
	    /**
		 * The phase of the oscillator in degrees.
		 * @memberOf Tone.PulseOscillator#
		 * @type {Degrees}
		 * @name phase
		 */
	    Object.defineProperty(Tone.PulseOscillator.prototype, 'phase', {
	        get: function () {
	            return this._sawtooth.phase;
	        },
	        set: function (phase) {
	            this._sawtooth.phase = phase;
	        }
	    });
	    /**
		 * The type of the oscillator. Always returns "pulse".
		 * @readOnly
		 * @memberOf Tone.PulseOscillator#
		 * @type {string}
		 * @name type
		 */
	    Object.defineProperty(Tone.PulseOscillator.prototype, 'type', {
	        get: function () {
	            return 'pulse';
	        }
	    });
	    /**
		 * The partials of the waveform. Cannot set partials for this waveform type
		 * @memberOf Tone.PulseOscillator#
		 * @type {Array}
		 * @name partials
		 * @private
		 */
	    Object.defineProperty(Tone.PulseOscillator.prototype, 'partials', {
	        get: function () {
	            return [];
	        }
	    });
	    /**
		 *  Clean up method.
		 *  @return {Tone.PulseOscillator} this
		 */
	    Tone.PulseOscillator.prototype.dispose = function () {
	        Tone.Source.prototype.dispose.call(this);
	        this._sawtooth.dispose();
	        this._sawtooth = null;
	        this._writable([
	            'width',
	            'frequency',
	            'detune'
	        ]);
	        this.width.dispose();
	        this.width = null;
	        this._widthGate.dispose();
	        this._widthGate = null;
	        this._thresh.dispose();
	        this._thresh = null;
	        this.frequency = null;
	        this.detune = null;
	        return this;
	    };
	    return Tone.PulseOscillator;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Tone.PWMOscillator modulates the width of a Tone.PulseOscillator 
		 *         at the modulationFrequency. This has the effect of continuously
		 *         changing the timbre of the oscillator by altering the harmonics 
		 *         generated.
		 *
		 *  @extends {Tone.Source}
		 *  @constructor
		 *  @param {Frequency} frequency The starting frequency of the oscillator. 
		 *  @param {Frequency} modulationFrequency The modulation frequency of the width of the pulse. 
		 *  @example
		 *  var pwm = new Tone.PWMOscillator("Ab3", 0.3).toMaster().start();
		 */
	    Tone.PWMOscillator = function () {
	        var options = Tone.defaults(arguments, [
	            'frequency',
	            'modulationFrequency'
	        ], Tone.PWMOscillator);
	        Tone.Source.call(this, options);
	        /**
			 *  the pulse oscillator
			 *  @type {Tone.PulseOscillator}
			 *  @private
			 */
	        this._pulse = new Tone.PulseOscillator(options.modulationFrequency);
	        //change the pulse oscillator type
	        this._pulse._sawtooth.type = 'sine';
	        /**
			 *  the modulator
			 *  @type {Tone.Oscillator}
			 *  @private
			 */
	        this._modulator = new Tone.Oscillator({
	            'frequency': options.frequency,
	            'detune': options.detune,
	            'phase': options.phase
	        });
	        /**
			 *  Scale the oscillator so it doesn't go silent 
			 *  at the extreme values.
			 *  @type {Tone.Multiply}
			 *  @private
			 */
	        this._scale = new Tone.Multiply(2);
	        /**
			 *  The frequency control.
			 *  @type {Frequency}
			 *  @signal
			 */
	        this.frequency = this._modulator.frequency;
	        /**
			 *  The detune of the oscillator.
			 *  @type {Cents}
			 *  @signal
			 */
	        this.detune = this._modulator.detune;
	        /**
			 *  The modulation rate of the oscillator. 
			 *  @type {Frequency}
			 *  @signal
			 */
	        this.modulationFrequency = this._pulse.frequency;
	        //connections
	        this._modulator.chain(this._scale, this._pulse.width);
	        this._pulse.connect(this.output);
	        this._readOnly([
	            'modulationFrequency',
	            'frequency',
	            'detune'
	        ]);
	    };
	    Tone.extend(Tone.PWMOscillator, Tone.Source);
	    /**
		 *  default values
		 *  @static
		 *  @type {Object}
		 *  @const
		 */
	    Tone.PWMOscillator.defaults = {
	        'frequency': 440,
	        'detune': 0,
	        'phase': 0,
	        'modulationFrequency': 0.4
	    };
	    /**
		 *  start the oscillator
		 *  @param  {Time} [time=now]
		 *  @private
		 */
	    Tone.PWMOscillator.prototype._start = function (time) {
	        time = this.toSeconds(time);
	        this._modulator.start(time);
	        this._pulse.start(time);
	    };
	    /**
		 *  stop the oscillator
		 *  @param  {Time} time (optional) timing parameter
		 *  @private
		 */
	    Tone.PWMOscillator.prototype._stop = function (time) {
	        time = this.toSeconds(time);
	        this._modulator.stop(time);
	        this._pulse.stop(time);
	    };
	    /**
		 * The type of the oscillator. Always returns "pwm".
		 * @readOnly
		 * @memberOf Tone.PWMOscillator#
		 * @type {string}
		 * @name type
		 */
	    Object.defineProperty(Tone.PWMOscillator.prototype, 'type', {
	        get: function () {
	            return 'pwm';
	        }
	    });
	    /**
		 * The partials of the waveform. Cannot set partials for this waveform type
		 * @memberOf Tone.PWMOscillator#
		 * @type {Array}
		 * @name partials
		 * @private
		 */
	    Object.defineProperty(Tone.PWMOscillator.prototype, 'partials', {
	        get: function () {
	            return [];
	        }
	    });
	    /**
		 * The phase of the oscillator in degrees.
		 * @memberOf Tone.PWMOscillator#
		 * @type {number}
		 * @name phase
		 */
	    Object.defineProperty(Tone.PWMOscillator.prototype, 'phase', {
	        get: function () {
	            return this._modulator.phase;
	        },
	        set: function (phase) {
	            this._modulator.phase = phase;
	        }
	    });
	    /**
		 *  Clean up.
		 *  @return {Tone.PWMOscillator} this
		 */
	    Tone.PWMOscillator.prototype.dispose = function () {
	        Tone.Source.prototype.dispose.call(this);
	        this._pulse.dispose();
	        this._pulse = null;
	        this._scale.dispose();
	        this._scale = null;
	        this._modulator.dispose();
	        this._modulator = null;
	        this._writable([
	            'modulationFrequency',
	            'frequency',
	            'detune'
	        ]);
	        this.frequency = null;
	        this.detune = null;
	        this.modulationFrequency = null;
	        return this;
	    };
	    return Tone.PWMOscillator;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Tone.FMOscillator 
		 *
		 *  @extends {Tone.Source}
		 *  @constructor
		 *  @param {Frequency} frequency The starting frequency of the oscillator. 
		 *  @param {String} type The type of the carrier oscillator.
		 *  @param {String} modulationType The type of the modulator oscillator.
		 *  @example
		 * //a sine oscillator frequency-modulated by a square wave
		 * var fmOsc = new Tone.FMOscillator("Ab3", "sine", "square").toMaster().start();
		 */
	    Tone.FMOscillator = function () {
	        var options = Tone.defaults(arguments, [
	            'frequency',
	            'type',
	            'modulationType'
	        ], Tone.FMOscillator);
	        Tone.Source.call(this, options);
	        /**
			 *  The carrier oscillator
			 *  @type {Tone.Oscillator}
			 *  @private
			 */
	        this._carrier = new Tone.Oscillator(options.frequency, options.type);
	        /**
			 *  The oscillator's frequency
			 *  @type {Frequency}
			 *  @signal
			 */
	        this.frequency = new Tone.Signal(options.frequency, Tone.Type.Frequency);
	        /**
			 *  The detune control signal.
			 *  @type {Cents}
			 *  @signal
			 */
	        this.detune = this._carrier.detune;
	        this.detune.value = options.detune;
	        /**
			 *  The modulation index which is in essence the depth or amount of the modulation. In other terms it is the 
			 *  ratio of the frequency of the modulating signal (mf) to the amplitude of the 
			 *  modulating signal (ma) -- as in ma/mf. 
			 *	@type {Positive}
			 *	@signal
			 */
	        this.modulationIndex = new Tone.Multiply(options.modulationIndex);
	        this.modulationIndex.units = Tone.Type.Positive;
	        /**
			 *  The modulating oscillator
			 *  @type  {Tone.Oscillator}
			 *  @private
			 */
	        this._modulator = new Tone.Oscillator(options.frequency, options.modulationType);
	        /**
			 *  Harmonicity is the frequency ratio between the carrier and the modulator oscillators. 
			 *  A harmonicity of 1 gives both oscillators the same frequency. 
			 *  Harmonicity = 2 means a change of an octave. 
			 *  @type {Positive}
			 *  @signal
			 *  @example
			 * //pitch the modulator an octave below carrier
			 * synth.harmonicity.value = 0.5;
			 */
	        this.harmonicity = new Tone.Multiply(options.harmonicity);
	        this.harmonicity.units = Tone.Type.Positive;
	        /**
			 *  the node where the modulation happens
			 *  @type {Tone.Gain}
			 *  @private
			 */
	        this._modulationNode = new Tone.Gain(0);
	        //connections
	        this.frequency.connect(this._carrier.frequency);
	        this.frequency.chain(this.harmonicity, this._modulator.frequency);
	        this.frequency.chain(this.modulationIndex, this._modulationNode);
	        this._modulator.connect(this._modulationNode.gain);
	        this._modulationNode.connect(this._carrier.frequency);
	        this._carrier.connect(this.output);
	        this.detune.connect(this._modulator.detune);
	        this.phase = options.phase;
	        this._readOnly([
	            'modulationIndex',
	            'frequency',
	            'detune',
	            'harmonicity'
	        ]);
	    };
	    Tone.extend(Tone.FMOscillator, Tone.Source);
	    /**
		 *  default values
		 *  @static
		 *  @type {Object}
		 *  @const
		 */
	    Tone.FMOscillator.defaults = {
	        'frequency': 440,
	        'detune': 0,
	        'phase': 0,
	        'modulationIndex': 2,
	        'modulationType': 'square',
	        'harmonicity': 1
	    };
	    /**
		 *  start the oscillator
		 *  @param  {Time} [time=now]
		 *  @private
		 */
	    Tone.FMOscillator.prototype._start = function (time) {
	        time = this.toSeconds(time);
	        this._modulator.start(time);
	        this._carrier.start(time);
	    };
	    /**
		 *  stop the oscillator
		 *  @param  {Time} time (optional) timing parameter
		 *  @private
		 */
	    Tone.FMOscillator.prototype._stop = function (time) {
	        time = this.toSeconds(time);
	        this._modulator.stop(time);
	        this._carrier.stop(time);
	    };
	    /**
		 * The type of the carrier oscillator
		 * @memberOf Tone.FMOscillator#
		 * @type {string}
		 * @name type
		 */
	    Object.defineProperty(Tone.FMOscillator.prototype, 'type', {
	        get: function () {
	            return this._carrier.type;
	        },
	        set: function (type) {
	            this._carrier.type = type;
	        }
	    });
	    /**
		 * The type of the modulator oscillator
		 * @memberOf Tone.FMOscillator#
		 * @type {String}
		 * @name modulationType
		 */
	    Object.defineProperty(Tone.FMOscillator.prototype, 'modulationType', {
	        get: function () {
	            return this._modulator.type;
	        },
	        set: function (type) {
	            this._modulator.type = type;
	        }
	    });
	    /**
		 * The phase of the oscillator in degrees.
		 * @memberOf Tone.FMOscillator#
		 * @type {number}
		 * @name phase
		 */
	    Object.defineProperty(Tone.FMOscillator.prototype, 'phase', {
	        get: function () {
	            return this._carrier.phase;
	        },
	        set: function (phase) {
	            this._carrier.phase = phase;
	            this._modulator.phase = phase;
	        }
	    });
	    /**
		 * The partials of the carrier waveform. A partial represents 
		 * the amplitude at a harmonic. The first harmonic is the 
		 * fundamental frequency, the second is the octave and so on
		 * following the harmonic series. 
		 * Setting this value will automatically set the type to "custom". 
		 * The value is an empty array when the type is not "custom". 
		 * @memberOf Tone.FMOscillator#
		 * @type {Array}
		 * @name partials
		 * @example
		 * osc.partials = [1, 0.2, 0.01];
		 */
	    Object.defineProperty(Tone.FMOscillator.prototype, 'partials', {
	        get: function () {
	            return this._carrier.partials;
	        },
	        set: function (partials) {
	            this._carrier.partials = partials;
	        }
	    });
	    /**
		 *  Clean up.
		 *  @return {Tone.FMOscillator} this
		 */
	    Tone.FMOscillator.prototype.dispose = function () {
	        Tone.Source.prototype.dispose.call(this);
	        this._writable([
	            'modulationIndex',
	            'frequency',
	            'detune',
	            'harmonicity'
	        ]);
	        this.frequency.dispose();
	        this.frequency = null;
	        this.detune = null;
	        this.harmonicity.dispose();
	        this.harmonicity = null;
	        this._carrier.dispose();
	        this._carrier = null;
	        this._modulator.dispose();
	        this._modulator = null;
	        this._modulationNode.dispose();
	        this._modulationNode = null;
	        this.modulationIndex.dispose();
	        this.modulationIndex = null;
	        return this;
	    };
	    return Tone.FMOscillator;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Tone.AMOscillator 
		 *
		 *  @extends {Tone.Oscillator}
		 *  @constructor
		 *  @param {Frequency} frequency The starting frequency of the oscillator. 
		 *  @param {String} type The type of the carrier oscillator.
		 *  @param {String} modulationType The type of the modulator oscillator.
		 *  @example
		 * //a sine oscillator frequency-modulated by a square wave
		 * var fmOsc = new Tone.AMOscillator("Ab3", "sine", "square").toMaster().start();
		 */
	    Tone.AMOscillator = function () {
	        var options = Tone.defaults(arguments, [
	            'frequency',
	            'type',
	            'modulationType'
	        ], Tone.AMOscillator);
	        Tone.Source.call(this, options);
	        /**
			 *  The carrier oscillator
			 *  @type {Tone.Oscillator}
			 *  @private
			 */
	        this._carrier = new Tone.Oscillator(options.frequency, options.type);
	        /**
			 *  The oscillator's frequency
			 *  @type {Frequency}
			 *  @signal
			 */
	        this.frequency = this._carrier.frequency;
	        /**
			 *  The detune control signal.
			 *  @type {Cents}
			 *  @signal
			 */
	        this.detune = this._carrier.detune;
	        this.detune.value = options.detune;
	        /**
			 *  The modulating oscillator
			 *  @type  {Tone.Oscillator}
			 *  @private
			 */
	        this._modulator = new Tone.Oscillator(options.frequency, options.modulationType);
	        /**
			 *  convert the -1,1 output to 0,1
			 *  @type {Tone.AudioToGain}
			 *  @private
			 */
	        this._modulationScale = new Tone.AudioToGain();
	        /**
			 *  Harmonicity is the frequency ratio between the carrier and the modulator oscillators. 
			 *  A harmonicity of 1 gives both oscillators the same frequency. 
			 *  Harmonicity = 2 means a change of an octave. 
			 *  @type {Positive}
			 *  @signal
			 *  @example
			 * //pitch the modulator an octave below carrier
			 * synth.harmonicity.value = 0.5;
			 */
	        this.harmonicity = new Tone.Multiply(options.harmonicity);
	        this.harmonicity.units = Tone.Type.Positive;
	        /**
			 *  the node where the modulation happens
			 *  @type {Tone.Gain}
			 *  @private
			 */
	        this._modulationNode = new Tone.Gain(0);
	        //connections
	        this.frequency.chain(this.harmonicity, this._modulator.frequency);
	        this.detune.connect(this._modulator.detune);
	        this._modulator.chain(this._modulationScale, this._modulationNode.gain);
	        this._carrier.chain(this._modulationNode, this.output);
	        this.phase = options.phase;
	        this._readOnly([
	            'frequency',
	            'detune',
	            'harmonicity'
	        ]);
	    };
	    Tone.extend(Tone.AMOscillator, Tone.Oscillator);
	    /**
		 *  default values
		 *  @static
		 *  @type {Object}
		 *  @const
		 */
	    Tone.AMOscillator.defaults = {
	        'frequency': 440,
	        'detune': 0,
	        'phase': 0,
	        'modulationType': 'square',
	        'harmonicity': 1
	    };
	    /**
		 *  start the oscillator
		 *  @param  {Time} [time=now]
		 *  @private
		 */
	    Tone.AMOscillator.prototype._start = function (time) {
	        time = this.toSeconds(time);
	        this._modulator.start(time);
	        this._carrier.start(time);
	    };
	    /**
		 *  stop the oscillator
		 *  @param  {Time} time (optional) timing parameter
		 *  @private
		 */
	    Tone.AMOscillator.prototype._stop = function (time) {
	        time = this.toSeconds(time);
	        this._modulator.stop(time);
	        this._carrier.stop(time);
	    };
	    /**
		 * The type of the carrier oscillator
		 * @memberOf Tone.AMOscillator#
		 * @type {string}
		 * @name type
		 */
	    Object.defineProperty(Tone.AMOscillator.prototype, 'type', {
	        get: function () {
	            return this._carrier.type;
	        },
	        set: function (type) {
	            this._carrier.type = type;
	        }
	    });
	    /**
		 * The type of the modulator oscillator
		 * @memberOf Tone.AMOscillator#
		 * @type {string}
		 * @name modulationType
		 */
	    Object.defineProperty(Tone.AMOscillator.prototype, 'modulationType', {
	        get: function () {
	            return this._modulator.type;
	        },
	        set: function (type) {
	            this._modulator.type = type;
	        }
	    });
	    /**
		 * The phase of the oscillator in degrees.
		 * @memberOf Tone.AMOscillator#
		 * @type {number}
		 * @name phase
		 */
	    Object.defineProperty(Tone.AMOscillator.prototype, 'phase', {
	        get: function () {
	            return this._carrier.phase;
	        },
	        set: function (phase) {
	            this._carrier.phase = phase;
	            this._modulator.phase = phase;
	        }
	    });
	    /**
		 * The partials of the carrier waveform. A partial represents 
		 * the amplitude at a harmonic. The first harmonic is the 
		 * fundamental frequency, the second is the octave and so on
		 * following the harmonic series. 
		 * Setting this value will automatically set the type to "custom". 
		 * The value is an empty array when the type is not "custom". 
		 * @memberOf Tone.AMOscillator#
		 * @type {Array}
		 * @name partials
		 * @example
		 * osc.partials = [1, 0.2, 0.01];
		 */
	    Object.defineProperty(Tone.AMOscillator.prototype, 'partials', {
	        get: function () {
	            return this._carrier.partials;
	        },
	        set: function (partials) {
	            this._carrier.partials = partials;
	        }
	    });
	    /**
		 *  Clean up.
		 *  @return {Tone.AMOscillator} this
		 */
	    Tone.AMOscillator.prototype.dispose = function () {
	        Tone.Source.prototype.dispose.call(this);
	        this._writable([
	            'frequency',
	            'detune',
	            'harmonicity'
	        ]);
	        this.frequency = null;
	        this.detune = null;
	        this.harmonicity.dispose();
	        this.harmonicity = null;
	        this._carrier.dispose();
	        this._carrier = null;
	        this._modulator.dispose();
	        this._modulator = null;
	        this._modulationNode.dispose();
	        this._modulationNode = null;
	        this._modulationScale.dispose();
	        this._modulationScale = null;
	        return this;
	    };
	    return Tone.AMOscillator;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Tone.FatOscillator 
		 *
		 *  @extends {Tone.Source}
		 *  @constructor
		 *  @param {Frequency} frequency The starting frequency of the oscillator. 
		 *  @param {String} type The type of the carrier oscillator.
		 *  @param {String} modulationType The type of the modulator oscillator.
		 *  @example
		 * //a sine oscillator frequency-modulated by a square wave
		 * var fmOsc = new Tone.FatOscillator("Ab3", "sine", "square").toMaster().start();
		 */
	    Tone.FatOscillator = function () {
	        var options = Tone.defaults(arguments, [
	            'frequency',
	            'type',
	            'spread'
	        ], Tone.FatOscillator);
	        Tone.Source.call(this, options);
	        /**
			 *  The oscillator's frequency
			 *  @type {Frequency}
			 *  @signal
			 */
	        this.frequency = new Tone.Signal(options.frequency, Tone.Type.Frequency);
	        /**
			 *  The detune control signal.
			 *  @type {Cents}
			 *  @signal
			 */
	        this.detune = new Tone.Signal(options.detune, Tone.Type.Cents);
	        /**
			 *  The array of oscillators
			 *  @type {Array}
			 *  @private
			 */
	        this._oscillators = [];
	        /**
			 *  The total spread of the oscillators
			 *  @type  {Cents}
			 *  @private
			 */
	        this._spread = options.spread;
	        /**
			 *  The type of the oscillator
			 *  @type {String}
			 *  @private
			 */
	        this._type = options.type;
	        /**
			 *  The phase of the oscillators
			 *  @type {Degrees}
			 *  @private
			 */
	        this._phase = options.phase;
	        /**
			 *  The partials array
			 *  @type {Array}
			 *  @private
			 */
	        this._partials = Tone.defaultArg(options.partials, []);
	        //set the count initially
	        this.count = options.count;
	        this._readOnly([
	            'frequency',
	            'detune'
	        ]);
	    };
	    Tone.extend(Tone.FatOscillator, Tone.Source);
	    /**
		 *  default values
		 *  @static
		 *  @type {Object}
		 *  @const
		 */
	    Tone.FatOscillator.defaults = {
	        'frequency': 440,
	        'detune': 0,
	        'phase': 0,
	        'spread': 20,
	        'count': 3,
	        'type': 'sawtooth'
	    };
	    /**
		 *  start the oscillator
		 *  @param  {Time} [time=now]
		 *  @private
		 */
	    Tone.FatOscillator.prototype._start = function (time) {
	        time = this.toSeconds(time);
	        this._forEach(function (osc) {
	            osc.start(time);
	        });
	    };
	    /**
		 *  stop the oscillator
		 *  @param  {Time} time (optional) timing parameter
		 *  @private
		 */
	    Tone.FatOscillator.prototype._stop = function (time) {
	        time = this.toSeconds(time);
	        this._forEach(function (osc) {
	            osc.stop(time);
	        });
	    };
	    /**
		 *  Iterate over all of the oscillators
		 *  @param  {Function}  iterator  The iterator function
		 *  @private
		 */
	    Tone.FatOscillator.prototype._forEach = function (iterator) {
	        for (var i = 0; i < this._oscillators.length; i++) {
	            iterator.call(this, this._oscillators[i], i);
	        }
	    };
	    /**
		 * The type of the carrier oscillator
		 * @memberOf Tone.FatOscillator#
		 * @type {string}
		 * @name type
		 */
	    Object.defineProperty(Tone.FatOscillator.prototype, 'type', {
	        get: function () {
	            return this._type;
	        },
	        set: function (type) {
	            this._type = type;
	            this._forEach(function (osc) {
	                osc.type = type;
	            });
	        }
	    });
	    /**
		 * The detune spread between the oscillators. If "count" is
		 * set to 3 oscillators and the "spread" is set to 40,
		 * the three oscillators would be detuned like this: [-20, 0, 20]
		 * for a total detune spread of 40 cents.
		 * @memberOf Tone.FatOscillator#
		 * @type {Cents}
		 * @name spread
		 */
	    Object.defineProperty(Tone.FatOscillator.prototype, 'spread', {
	        get: function () {
	            return this._spread;
	        },
	        set: function (spread) {
	            this._spread = spread;
	            if (this._oscillators.length > 1) {
	                var start = -spread / 2;
	                var step = spread / (this._oscillators.length - 1);
	                this._forEach(function (osc, i) {
	                    osc.detune.value = start + step * i;
	                });
	            }
	        }
	    });
	    /**
		 * The number of detuned oscillators
		 * @memberOf Tone.FatOscillator#
		 * @type {Number}
		 * @name count
		 */
	    Object.defineProperty(Tone.FatOscillator.prototype, 'count', {
	        get: function () {
	            return this._oscillators.length;
	        },
	        set: function (count) {
	            count = Math.max(count, 1);
	            if (this._oscillators.length !== count) {
	                // var partials = this.partials;
	                // var type = this.type;
	                //dispose the previous oscillators
	                this._forEach(function (osc) {
	                    osc.dispose();
	                });
	                this._oscillators = [];
	                for (var i = 0; i < count; i++) {
	                    var osc = new Tone.Oscillator();
	                    if (this.type === Tone.Oscillator.Type.Custom) {
	                        osc.partials = this._partials;
	                    } else {
	                        osc.type = this._type;
	                    }
	                    osc.phase = this._phase;
	                    osc.volume.value = -6 - count;
	                    this.frequency.connect(osc.frequency);
	                    this.detune.connect(osc.detune);
	                    osc.connect(this.output);
	                    this._oscillators[i] = osc;
	                }
	                //set the spread
	                this.spread = this._spread;
	                if (this.state === Tone.State.Started) {
	                    this._forEach(function (osc) {
	                        osc.start();
	                    });
	                }
	            }
	        }
	    });
	    /**
		 * The phase of the oscillator in degrees.
		 * @memberOf Tone.FatOscillator#
		 * @type {Number}
		 * @name phase
		 */
	    Object.defineProperty(Tone.FatOscillator.prototype, 'phase', {
	        get: function () {
	            return this._phase;
	        },
	        set: function (phase) {
	            this._phase = phase;
	            this._forEach(function (osc) {
	                osc.phase = phase;
	            });
	        }
	    });
	    /**
		 * The partials of the carrier waveform. A partial represents 
		 * the amplitude at a harmonic. The first harmonic is the 
		 * fundamental frequency, the second is the octave and so on
		 * following the harmonic series. 
		 * Setting this value will automatically set the type to "custom". 
		 * The value is an empty array when the type is not "custom". 
		 * @memberOf Tone.FatOscillator#
		 * @type {Array}
		 * @name partials
		 * @example
		 * osc.partials = [1, 0.2, 0.01];
		 */
	    Object.defineProperty(Tone.FatOscillator.prototype, 'partials', {
	        get: function () {
	            return this._partials;
	        },
	        set: function (partials) {
	            this._partials = partials;
	            this._type = Tone.Oscillator.Type.Custom;
	            this._forEach(function (osc) {
	                osc.partials = partials;
	            });
	        }
	    });
	    /**
		 *  Clean up.
		 *  @return {Tone.FatOscillator} this
		 */
	    Tone.FatOscillator.prototype.dispose = function () {
	        Tone.Source.prototype.dispose.call(this);
	        this._writable([
	            'frequency',
	            'detune'
	        ]);
	        this.frequency.dispose();
	        this.frequency = null;
	        this.detune.dispose();
	        this.detune = null;
	        this._forEach(function (osc) {
	            osc.dispose();
	        });
	        this._oscillators = null;
	        this._partials = null;
	        return this;
	    };
	    return Tone.FatOscillator;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Tone.OmniOscillator aggregates Tone.Oscillator, Tone.PulseOscillator,
		 *         Tone.PWMOscillator, Tone.FMOscillator, Tone.AMOscillator, and Tone.FatOscillator
		 *         into one class. The oscillator class can be changed by setting the `type`. 
		 *         `omniOsc.type = "pwm"` will set it to the Tone.PWMOscillator. Prefixing
		 *         any of the basic types ("sine", "square4", etc.) with "fm", "am", or "fat"
		 *         will use the FMOscillator, AMOscillator or FatOscillator respectively. 
		 *         For example: `omniOsc.type = "fatsawtooth"` will create set the oscillator
		 *         to a FatOscillator of type "sawtooth". 
		 *
		 *  @extends {Tone.Source}
		 *  @constructor
		 *  @param {Frequency} frequency The initial frequency of the oscillator.
		 *  @param {String} type The type of the oscillator.
		 *  @example
		 *  var omniOsc = new Tone.OmniOscillator("C#4", "pwm");
		 */
	    Tone.OmniOscillator = function () {
	        var options = Tone.defaults(arguments, [
	            'frequency',
	            'type'
	        ], Tone.OmniOscillator);
	        Tone.Source.call(this, options);
	        /**
			 *  The frequency control.
			 *  @type {Frequency}
			 *  @signal
			 */
	        this.frequency = new Tone.Signal(options.frequency, Tone.Type.Frequency);
	        /**
			 *  The detune control
			 *  @type {Cents}
			 *  @signal
			 */
	        this.detune = new Tone.Signal(options.detune, Tone.Type.Cents);
	        /**
			 *  the type of the oscillator source
			 *  @type {String}
			 *  @private
			 */
	        this._sourceType = undefined;
	        /**
			 *  the oscillator
			 *  @type {Tone.Oscillator}
			 *  @private
			 */
	        this._oscillator = null;
	        //set the oscillator
	        this.type = options.type;
	        this._readOnly([
	            'frequency',
	            'detune'
	        ]);
	        //set the options
	        this.set(options);
	    };
	    Tone.extend(Tone.OmniOscillator, Tone.Source);
	    /**
		 *  default values
		 *  @static
		 *  @type {Object}
		 *  @const
		 */
	    Tone.OmniOscillator.defaults = {
	        'frequency': 440,
	        'detune': 0,
	        'type': 'sine',
	        'phase': 0
	    };
	    /**
		 *  @enum {String}
		 *  @private
		 */
	    var OmniOscType = {
	        Pulse: 'PulseOscillator',
	        PWM: 'PWMOscillator',
	        Osc: 'Oscillator',
	        FM: 'FMOscillator',
	        AM: 'AMOscillator',
	        Fat: 'FatOscillator'
	    };
	    /**
		 *  start the oscillator
		 *  @param {Time} [time=now] the time to start the oscillator
		 *  @private
		 */
	    Tone.OmniOscillator.prototype._start = function (time) {
	        this._oscillator.start(time);
	    };
	    /**
		 *  start the oscillator
		 *  @param {Time} [time=now] the time to start the oscillator
		 *  @private
		 */
	    Tone.OmniOscillator.prototype._stop = function (time) {
	        this._oscillator.stop(time);
	    };
	    /**
		 * The type of the oscillator. Can be any of the basic types: sine, square, triangle, sawtooth. Or
		 * prefix the basic types with "fm", "am", or "fat" to use the FMOscillator, AMOscillator or FatOscillator
		 * types. The oscillator could also be set to "pwm" or "pulse". All of the parameters of the
		 * oscillator's class are accessible when the oscillator is set to that type, but throws an error 
		 * when it's not.
		 * 
		 * @memberOf Tone.OmniOscillator#
		 * @type {String}
		 * @name type
		 * @example
		 * omniOsc.type = "pwm";
		 * //modulationFrequency is parameter which is available
		 * //only when the type is "pwm". 
		 * omniOsc.modulationFrequency.value = 0.5;
		 * @example
		 * //an square wave frequency modulated by a sawtooth
		 * omniOsc.type = "fmsquare";
		 * omniOsc.modulationType = "sawtooth";
		 */
	    Object.defineProperty(Tone.OmniOscillator.prototype, 'type', {
	        get: function () {
	            var prefix = '';
	            if (this._sourceType === OmniOscType.FM) {
	                prefix = 'fm';
	            } else if (this._sourceType === OmniOscType.AM) {
	                prefix = 'am';
	            } else if (this._sourceType === OmniOscType.Fat) {
	                prefix = 'fat';
	            }
	            return prefix + this._oscillator.type;
	        },
	        set: function (type) {
	            if (type.substr(0, 2) === 'fm') {
	                this._createNewOscillator(OmniOscType.FM);
	                this._oscillator.type = type.substr(2);
	            } else if (type.substr(0, 2) === 'am') {
	                this._createNewOscillator(OmniOscType.AM);
	                this._oscillator.type = type.substr(2);
	            } else if (type.substr(0, 3) === 'fat') {
	                this._createNewOscillator(OmniOscType.Fat);
	                this._oscillator.type = type.substr(3);
	            } else if (type === 'pwm') {
	                this._createNewOscillator(OmniOscType.PWM);
	            } else if (type === 'pulse') {
	                this._createNewOscillator(OmniOscType.Pulse);
	            } else {
	                this._createNewOscillator(OmniOscType.Osc);
	                this._oscillator.type = type;
	            }
	        }
	    });
	    /**
		 * The partials of the waveform. A partial represents 
		 * the amplitude at a harmonic. The first harmonic is the 
		 * fundamental frequency, the second is the octave and so on
		 * following the harmonic series. 
		 * Setting this value will automatically set the type to "custom". 
		 * The value is an empty array when the type is not "custom". 
		 * This is not available on "pwm" and "pulse" oscillator types.
		 * @memberOf Tone.OmniOscillator#
		 * @type {Array}
		 * @name partials
		 * @example
		 * osc.partials = [1, 0.2, 0.01];
		 */
	    Object.defineProperty(Tone.OmniOscillator.prototype, 'partials', {
	        get: function () {
	            return this._oscillator.partials;
	        },
	        set: function (partials) {
	            this._oscillator.partials = partials;
	        }
	    });
	    /**
		 *  Set a member/attribute of the oscillator. 
		 *  @param {Object|String} params
		 *  @param {number=} value
		 *  @param {Time=} rampTime
		 *  @returns {Tone.OmniOscillator} this
		 */
	    Tone.OmniOscillator.prototype.set = function (params, value) {
	        //make sure the type is set first
	        if (params === 'type') {
	            this.type = value;
	        } else if (Tone.isObject(params) && params.hasOwnProperty('type')) {
	            this.type = params.type;
	        }
	        //then set the rest
	        Tone.prototype.set.apply(this, arguments);
	        return this;
	    };
	    /**
		 *  connect the oscillator to the frequency and detune signals
		 *  @private
		 */
	    Tone.OmniOscillator.prototype._createNewOscillator = function (oscType) {
	        if (oscType !== this._sourceType) {
	            this._sourceType = oscType;
	            var OscillatorConstructor = Tone[oscType];
	            //short delay to avoid clicks on the change
	            var now = this.now();
	            if (this._oscillator !== null) {
	                var oldOsc = this._oscillator;
	                oldOsc.stop(now);
	                //dispose the old one
	                this.context.setTimeout(function () {
	                    oldOsc.dispose();
	                    oldOsc = null;
	                }, this.blockTime);
	            }
	            this._oscillator = new OscillatorConstructor();
	            this.frequency.connect(this._oscillator.frequency);
	            this.detune.connect(this._oscillator.detune);
	            this._oscillator.connect(this.output);
	            if (this.state === Tone.State.Started) {
	                this._oscillator.start(now);
	            }
	        }
	    };
	    /**
		 * The phase of the oscillator in degrees. 
		 * @memberOf Tone.OmniOscillator#
		 * @type {Degrees}
		 * @name phase
		 */
	    Object.defineProperty(Tone.OmniOscillator.prototype, 'phase', {
	        get: function () {
	            return this._oscillator.phase;
	        },
	        set: function (phase) {
	            this._oscillator.phase = phase;
	        }
	    });
	    /**
		 * The width of the oscillator (only if the oscillator is set to "pulse")
		 * @memberOf Tone.OmniOscillator#
		 * @type {NormalRange}
		 * @signal
		 * @name width
		 * @example
		 * var omniOsc = new Tone.OmniOscillator(440, "pulse");
		 * //can access the width attribute only if type === "pulse"
		 * omniOsc.width.value = 0.2; 
		 */
	    Object.defineProperty(Tone.OmniOscillator.prototype, 'width', {
	        get: function () {
	            if (this._sourceType === OmniOscType.Pulse) {
	                return this._oscillator.width;
	            }
	        }
	    });
	    /**
		 * The number of detuned oscillators
		 * @memberOf Tone.OmniOscillator#
		 * @type {Number}
		 * @name count
		 */
	    Object.defineProperty(Tone.OmniOscillator.prototype, 'count', {
	        get: function () {
	            if (this._sourceType === OmniOscType.Fat) {
	                return this._oscillator.count;
	            }
	        },
	        set: function (count) {
	            if (this._sourceType === OmniOscType.Fat) {
	                this._oscillator.count = count;
	            }
	        }
	    });
	    /**
		 * The detune spread between the oscillators. If "count" is
		 * set to 3 oscillators and the "spread" is set to 40,
		 * the three oscillators would be detuned like this: [-20, 0, 20]
		 * for a total detune spread of 40 cents. See Tone.FatOscillator
		 * for more info.
		 * @memberOf Tone.OmniOscillator#
		 * @type {Cents}
		 * @name spread
		 */
	    Object.defineProperty(Tone.OmniOscillator.prototype, 'spread', {
	        get: function () {
	            if (this._sourceType === OmniOscType.Fat) {
	                return this._oscillator.spread;
	            }
	        },
	        set: function (spread) {
	            if (this._sourceType === OmniOscType.Fat) {
	                this._oscillator.spread = spread;
	            }
	        }
	    });
	    /**
		 * The type of the modulator oscillator. Only if the oscillator
		 * is set to "am" or "fm" types. see. Tone.AMOscillator or Tone.FMOscillator
		 * for more info. 
		 * @memberOf Tone.OmniOscillator#
		 * @type {String}
		 * @name modulationType
		 */
	    Object.defineProperty(Tone.OmniOscillator.prototype, 'modulationType', {
	        get: function () {
	            if (this._sourceType === OmniOscType.FM || this._sourceType === OmniOscType.AM) {
	                return this._oscillator.modulationType;
	            }
	        },
	        set: function (mType) {
	            if (this._sourceType === OmniOscType.FM || this._sourceType === OmniOscType.AM) {
	                this._oscillator.modulationType = mType;
	            }
	        }
	    });
	    /**
		 * The modulation index which is in essence the depth or amount of the modulation. In other terms it is the 
		 * ratio of the frequency of the modulating signal (mf) to the amplitude of the 
		 * modulating signal (ma) -- as in ma/mf. 
		 * See Tone.FMOscillator for more info. 
		 * @type {Positive}
		 * @signal
		 * @name modulationIndex
		 */
	    Object.defineProperty(Tone.OmniOscillator.prototype, 'modulationIndex', {
	        get: function () {
	            if (this._sourceType === OmniOscType.FM) {
	                return this._oscillator.modulationIndex;
	            }
	        }
	    });
	    /**
		 *  Harmonicity is the frequency ratio between the carrier and the modulator oscillators. 
		 *  A harmonicity of 1 gives both oscillators the same frequency. 
		 *  Harmonicity = 2 means a change of an octave. See Tone.AMOscillator or Tone.FMOscillator
		 *  for more info. 
		 *  @memberOf Tone.OmniOscillator#
		 *  @signal
		 *  @type {Positive}
		 *  @name harmonicity
		 */
	    Object.defineProperty(Tone.OmniOscillator.prototype, 'harmonicity', {
	        get: function () {
	            if (this._sourceType === OmniOscType.FM || this._sourceType === OmniOscType.AM) {
	                return this._oscillator.harmonicity;
	            }
	        }
	    });
	    /**
		 * The modulationFrequency Signal of the oscillator 
		 * (only if the oscillator type is set to pwm). See 
		 * Tone.PWMOscillator for more info. 
		 * @memberOf Tone.OmniOscillator#
		 * @type {Frequency}
		 * @signal
		 * @name modulationFrequency
		 * @example
		 * var omniOsc = new Tone.OmniOscillator(440, "pwm");
		 * //can access the modulationFrequency attribute only if type === "pwm"
		 * omniOsc.modulationFrequency.value = 0.2; 
		 */
	    Object.defineProperty(Tone.OmniOscillator.prototype, 'modulationFrequency', {
	        get: function () {
	            if (this._sourceType === OmniOscType.PWM) {
	                return this._oscillator.modulationFrequency;
	            }
	        }
	    });
	    /**
		 *  Clean up.
		 *  @return {Tone.OmniOscillator} this
		 */
	    Tone.OmniOscillator.prototype.dispose = function () {
	        Tone.Source.prototype.dispose.call(this);
	        this._writable([
	            'frequency',
	            'detune'
	        ]);
	        this.detune.dispose();
	        this.detune = null;
	        this.frequency.dispose();
	        this.frequency = null;
	        this._oscillator.dispose();
	        this._oscillator = null;
	        this._sourceType = null;
	        return this;
	    };
	    return Tone.OmniOscillator;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class  Base-class for all instruments
		 *
		 *  @constructor
		 *  @extends {Tone.AudioNode}
		 */
	    Tone.Instrument = function (options) {
	        //get the defaults
	        options = Tone.defaultArg(options, Tone.Instrument.defaults);
	        Tone.AudioNode.call(this);
	        /**
			 *  The output and volume triming node
			 *  @type  {Tone.Volume}
			 *  @private
			 */
	        this._volume = this.output = new Tone.Volume(options.volume);
	        /**
			 * The volume of the output in decibels.
			 * @type {Decibels}
			 * @signal
			 * @example
			 * source.volume.value = -6;
			 */
	        this.volume = this._volume.volume;
	        this._readOnly('volume');
	    };
	    Tone.extend(Tone.Instrument, Tone.AudioNode);
	    /**
		 *  the default attributes
		 *  @type {object}
		 */
	    Tone.Instrument.defaults = {
	        /** the volume of the output in decibels */
	        'volume': 0
	    };
	    /**
		 *  @abstract
		 *  @param {string|number} note the note to trigger
		 *  @param {Time} [time=now] the time to trigger the ntoe
		 *  @param {number} [velocity=1] the velocity to trigger the note
		 */
	    Tone.Instrument.prototype.triggerAttack = Tone.noOp;
	    /**
		 *  @abstract
		 *  @param {Time} [time=now] when to trigger the release
		 */
	    Tone.Instrument.prototype.triggerRelease = Tone.noOp;
	    /**
		 *  Trigger the attack and then the release after the duration.
		 *  @param  {Frequency} note     The note to trigger.
		 *  @param  {Time} duration How long the note should be held for before
		 *                          triggering the release. This value must be greater than 0.
		 *  @param {Time} [time=now]  When the note should be triggered.
		 *  @param  {NormalRange} [velocity=1] The velocity the note should be triggered at.
		 *  @returns {Tone.Instrument} this
		 *  @example
		 * //trigger "C4" for the duration of an 8th note
		 * synth.triggerAttackRelease("C4", "8n");
		 */
	    Tone.Instrument.prototype.triggerAttackRelease = function (note, duration, time, velocity) {
	        time = this.toSeconds(time);
	        duration = this.toSeconds(duration);
	        this.triggerAttack(note, time, velocity);
	        this.triggerRelease(time + duration);
	        return this;
	    };
	    /**
		 *  clean up
		 *  @returns {Tone.Instrument} this
		 */
	    Tone.Instrument.prototype.dispose = function () {
	        Tone.AudioNode.prototype.dispose.call(this);
	        this._volume.dispose();
	        this._volume = null;
	        this._writable(['volume']);
	        this.volume = null;
	        return this;
	    };
	    return Tone.Instrument;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class  This is an abstract base class for other monophonic instruments to 
		 *          extend. IMPORTANT: It does not make any sound on its own and
		 *          shouldn't be directly instantiated.
		 *
		 *  @constructor
		 *  @abstract
		 *  @extends {Tone.Instrument}
		 */
	    Tone.Monophonic = function (options) {
	        //get the defaults
	        options = Tone.defaultArg(options, Tone.Monophonic.defaults);
	        Tone.Instrument.call(this, options);
	        /**
			 *  The glide time between notes. 
			 *  @type {Time}
			 */
	        this.portamento = options.portamento;
	    };
	    Tone.extend(Tone.Monophonic, Tone.Instrument);
	    /**
		 *  @static
		 *  @const
		 *  @type {Object}
		 */
	    Tone.Monophonic.defaults = { 'portamento': 0 };
	    /**
		 *  Trigger the attack of the note optionally with a given velocity. 
		 *  
		 *  
		 *  @param  {Frequency} note     The note to trigger.
		 *  @param  {Time} [time=now]     When the note should start.
		 *  @param  {number} [velocity=1] velocity The velocity scaler 
		 *                                determines how "loud" the note 
		 *                                will be triggered.
		 *  @returns {Tone.Monophonic} this
		 *  @example
		 * synth.triggerAttack("C4");
		 *  @example
		 * //trigger the note a half second from now at half velocity
		 * synth.triggerAttack("C4", "+0.5", 0.5);
		 */
	    Tone.Monophonic.prototype.triggerAttack = function (note, time, velocity) {
	        time = this.toSeconds(time);
	        this._triggerEnvelopeAttack(time, velocity);
	        this.setNote(note, time);
	        return this;
	    };
	    /**
		 *  Trigger the release portion of the envelope
		 *  @param  {Time} [time=now] If no time is given, the release happens immediatly
		 *  @returns {Tone.Monophonic} this
		 *  @example
		 * synth.triggerRelease();
		 */
	    Tone.Monophonic.prototype.triggerRelease = function (time) {
	        time = this.toSeconds(time);
	        this._triggerEnvelopeRelease(time);
	        return this;
	    };
	    /**
		 *  override this method with the actual method
		 *  @abstract
		 *  @private
		 */
	    Tone.Monophonic.prototype._triggerEnvelopeAttack = function () {
	    };
	    /**
		 *  override this method with the actual method
		 *  @abstract
		 *  @private
		 */
	    Tone.Monophonic.prototype._triggerEnvelopeRelease = function () {
	    };
	    /**
		 *  Set the note at the given time. If no time is given, the note
		 *  will set immediately. 
		 *  @param {Frequency} note The note to change to.
		 *  @param  {Time} [time=now] The time when the note should be set. 
		 *  @returns {Tone.Monophonic} this
		 * @example
		 * //change to F#6 in one quarter note from now.
		 * synth.setNote("F#6", "+4n");
		 * @example
		 * //change to Bb4 right now
		 * synth.setNote("Bb4");
		 */
	    Tone.Monophonic.prototype.setNote = function (note, time) {
	        time = this.toSeconds(time);
	        if (this.portamento > 0) {
	            var currentNote = this.frequency.value;
	            this.frequency.setValueAtTime(currentNote, time);
	            var portTime = this.toSeconds(this.portamento);
	            this.frequency.exponentialRampToValueAtTime(note, time + portTime);
	        } else {
	            this.frequency.setValueAtTime(note, time);
	        }
	        return this;
	    };
	    return Tone.Monophonic;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class  Tone.Synth is composed simply of a Tone.OmniOscillator
		 *          routed through a Tone.AmplitudeEnvelope. 
		 *          <img src="https://docs.google.com/drawings/d/1-1_0YW2Z1J2EPI36P8fNCMcZG7N1w1GZluPs4og4evo/pub?w=1163&h=231">
		 *
		 *  @constructor
		 *  @extends {Tone.Monophonic}
		 *  @param {Object} [options] the options available for the synth 
		 *                          see defaults below
		 *  @example
		 * var synth = new Tone.Synth().toMaster();
		 * synth.triggerAttackRelease("C4", "8n");
		 */
	    Tone.Synth = function (options) {
	        //get the defaults
	        options = Tone.defaultArg(options, Tone.Synth.defaults);
	        Tone.Monophonic.call(this, options);
	        /**
			 *  The oscillator.
			 *  @type {Tone.OmniOscillator}
			 */
	        this.oscillator = new Tone.OmniOscillator(options.oscillator);
	        /**
			 *  The frequency control.
			 *  @type {Frequency}
			 *  @signal
			 */
	        this.frequency = this.oscillator.frequency;
	        /**
			 *  The detune control.
			 *  @type {Cents}
			 *  @signal
			 */
	        this.detune = this.oscillator.detune;
	        /**
			 *  The amplitude envelope.
			 *  @type {Tone.AmplitudeEnvelope}
			 */
	        this.envelope = new Tone.AmplitudeEnvelope(options.envelope);
	        //connect the oscillators to the output
	        this.oscillator.chain(this.envelope, this.output);
	        //start the oscillators
	        this.oscillator.start();
	        this._readOnly([
	            'oscillator',
	            'frequency',
	            'detune',
	            'envelope'
	        ]);
	    };
	    Tone.extend(Tone.Synth, Tone.Monophonic);
	    /**
		 *  @const
		 *  @static
		 *  @type {Object}
		 */
	    Tone.Synth.defaults = {
	        'oscillator': { 'type': 'triangle' },
	        'envelope': {
	            'attack': 0.005,
	            'decay': 0.1,
	            'sustain': 0.3,
	            'release': 1
	        }
	    };
	    /**
		 *  start the attack portion of the envelope
		 *  @param {Time} [time=now] the time the attack should start
		 *  @param {number} [velocity=1] the velocity of the note (0-1)
		 *  @returns {Tone.Synth} this
		 *  @private
		 */
	    Tone.Synth.prototype._triggerEnvelopeAttack = function (time, velocity) {
	        //the envelopes
	        this.envelope.triggerAttack(time, velocity);
	        return this;
	    };
	    /**
		 *  start the release portion of the envelope
		 *  @param {Time} [time=now] the time the release should start
		 *  @returns {Tone.Synth} this
		 *  @private
		 */
	    Tone.Synth.prototype._triggerEnvelopeRelease = function (time) {
	        this.envelope.triggerRelease(time);
	        return this;
	    };
	    /**
		 *  clean up
		 *  @returns {Tone.Synth} this
		 */
	    Tone.Synth.prototype.dispose = function () {
	        Tone.Monophonic.prototype.dispose.call(this);
	        this._writable([
	            'oscillator',
	            'frequency',
	            'detune',
	            'envelope'
	        ]);
	        this.oscillator.dispose();
	        this.oscillator = null;
	        this.envelope.dispose();
	        this.envelope = null;
	        this.frequency = null;
	        this.detune = null;
	        return this;
	    };
	    return Tone.Synth;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class  AMSynth uses the output of one Tone.Synth to modulate the
		 *          amplitude of another Tone.Synth. The harmonicity (the ratio between
		 *          the two signals) affects the timbre of the output signal greatly.
		 *          Read more about Amplitude Modulation Synthesis on
		 *          [SoundOnSound](https://web.archive.org/web/20160404103653/http://www.soundonsound.com:80/sos/mar00/articles/synthsecrets.htm).
		 *          <img src="https://docs.google.com/drawings/d/1TQu8Ed4iFr1YTLKpB3U1_hur-UwBrh5gdBXc8BxfGKw/pub?w=1009&h=457">
		 *
		 *  @constructor
		 *  @extends {Tone.Monophonic}
		 *  @param {Object} [options] the options available for the synth
		 *                            see defaults below
		 *  @example
		 * var synth = new Tone.AMSynth().toMaster();
		 * synth.triggerAttackRelease("C4", "4n");
		 */
	    Tone.AMSynth = function (options) {
	        options = Tone.defaultArg(options, Tone.AMSynth.defaults);
	        Tone.Monophonic.call(this, options);
	        /**
			 *  The carrier voice.
			 *  @type {Tone.Synth}
			 *  @private
			 */
	        this._carrier = new Tone.Synth();
	        this._carrier.volume.value = -10;
	        /**
			 *  The carrier's oscillator
			 *  @type {Tone.Oscillator}
			 */
	        this.oscillator = this._carrier.oscillator;
	        /**
			 *  The carrier's envelope
			 *  @type {Tone.AmplitudeEnvelope}
			 */
	        this.envelope = this._carrier.envelope.set(options.envelope);
	        /**
			 *  The modulator voice.
			 *  @type {Tone.Synth}
			 *  @private
			 */
	        this._modulator = new Tone.Synth();
	        this._modulator.volume.value = -10;
	        /**
			 *  The modulator's oscillator which is applied
			 *  to the amplitude of the oscillator
			 *  @type {Tone.Oscillator}
			 */
	        this.modulation = this._modulator.oscillator.set(options.modulation);
	        /**
			 *  The modulator's envelope
			 *  @type {Tone.AmplitudeEnvelope}
			 */
	        this.modulationEnvelope = this._modulator.envelope.set(options.modulationEnvelope);
	        /**
			 *  The frequency.
			 *  @type {Frequency}
			 *  @signal
			 */
	        this.frequency = new Tone.Signal(440, Tone.Type.Frequency);
	        /**
			 *  The detune in cents
			 *  @type {Cents}
			 *  @signal
			 */
	        this.detune = new Tone.Signal(options.detune, Tone.Type.Cents);
	        /**
			 *  Harmonicity is the ratio between the two voices. A harmonicity of
			 *  1 is no change. Harmonicity = 2 means a change of an octave.
			 *  @type {Positive}
			 *  @signal
			 *  @example
			 * //pitch voice1 an octave below voice0
			 * synth.harmonicity.value = 0.5;
			 */
	        this.harmonicity = new Tone.Multiply(options.harmonicity);
	        this.harmonicity.units = Tone.Type.Positive;
	        /**
			 *  convert the -1,1 output to 0,1
			 *  @type {Tone.AudioToGain}
			 *  @private
			 */
	        this._modulationScale = new Tone.AudioToGain();
	        /**
			 *  the node where the modulation happens
			 *  @type {Tone.Gain}
			 *  @private
			 */
	        this._modulationNode = new Tone.Gain();
	        //control the two voices frequency
	        this.frequency.connect(this._carrier.frequency);
	        this.frequency.chain(this.harmonicity, this._modulator.frequency);
	        this.detune.fan(this._carrier.detune, this._modulator.detune);
	        this._modulator.chain(this._modulationScale, this._modulationNode.gain);
	        this._carrier.chain(this._modulationNode, this.output);
	        this._readOnly([
	            'frequency',
	            'harmonicity',
	            'oscillator',
	            'envelope',
	            'modulation',
	            'modulationEnvelope',
	            'detune'
	        ]);
	    };
	    Tone.extend(Tone.AMSynth, Tone.Monophonic);
	    /**
		 *  @static
		 *  @type {Object}
		 */
	    Tone.AMSynth.defaults = {
	        'harmonicity': 3,
	        'detune': 0,
	        'oscillator': { 'type': 'sine' },
	        'envelope': {
	            'attack': 0.01,
	            'decay': 0.01,
	            'sustain': 1,
	            'release': 0.5
	        },
	        'modulation': { 'type': 'square' },
	        'modulationEnvelope': {
	            'attack': 0.5,
	            'decay': 0,
	            'sustain': 1,
	            'release': 0.5
	        }
	    };
	    /**
		 *  trigger the attack portion of the note
		 *
		 *  @param  {Time} [time=now] the time the note will occur
		 *  @param {NormalRange} [velocity=1] the velocity of the note
		 *  @private
		 *  @returns {Tone.AMSynth} this
		 */
	    Tone.AMSynth.prototype._triggerEnvelopeAttack = function (time, velocity) {
	        //the port glide
	        time = this.toSeconds(time);
	        //the envelopes
	        this.envelope.triggerAttack(time, velocity);
	        this.modulationEnvelope.triggerAttack(time, velocity);
	        return this;
	    };
	    /**
		 *  trigger the release portion of the note
		 *
		 *  @param  {Time} [time=now] the time the note will release
		 *  @private
		 *  @returns {Tone.AMSynth} this
		 */
	    Tone.AMSynth.prototype._triggerEnvelopeRelease = function (time) {
	        this.envelope.triggerRelease(time);
	        this.modulationEnvelope.triggerRelease(time);
	        return this;
	    };
	    /**
		 *  clean up
		 *  @returns {Tone.AMSynth} this
		 */
	    Tone.AMSynth.prototype.dispose = function () {
	        Tone.Monophonic.prototype.dispose.call(this);
	        this._writable([
	            'frequency',
	            'harmonicity',
	            'oscillator',
	            'envelope',
	            'modulation',
	            'modulationEnvelope',
	            'detune'
	        ]);
	        this._carrier.dispose();
	        this._carrier = null;
	        this._modulator.dispose();
	        this._modulator = null;
	        this.frequency.dispose();
	        this.frequency = null;
	        this.detune.dispose();
	        this.detune = null;
	        this.harmonicity.dispose();
	        this.harmonicity = null;
	        this._modulationScale.dispose();
	        this._modulationScale = null;
	        this._modulationNode.dispose();
	        this._modulationNode = null;
	        this.oscillator = null;
	        this.envelope = null;
	        this.modulationEnvelope = null;
	        this.modulation = null;
	        return this;
	    };
	    return Tone.AMSynth;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class  Tone.MonoSynth is composed of one oscillator, one filter, and two envelopes.
		 *          The amplitude of the Tone.Oscillator and the cutoff frequency of the 
		 *          Tone.Filter are controlled by Tone.Envelopes. 
		 *          <img src="https://docs.google.com/drawings/d/1gaY1DF9_Hzkodqf8JI1Cg2VZfwSElpFQfI94IQwad38/pub?w=924&h=240">
		 *          
		 *  @constructor
		 *  @extends {Tone.Monophonic}
		 *  @param {Object} [options] the options available for the synth 
		 *                          see defaults below
		 *  @example
		 * var synth = new Tone.MonoSynth({
		 * 	"oscillator" : {
		 * 		"type" : "square"
		 *  },
		 *  "envelope" : {
		 *  	"attack" : 0.1
		 *  }
		 * }).toMaster();
		 * synth.triggerAttackRelease("C4", "8n");
		 */
	    Tone.MonoSynth = function (options) {
	        //get the defaults
	        options = Tone.defaultArg(options, Tone.MonoSynth.defaults);
	        Tone.Monophonic.call(this, options);
	        /**
			 *  The oscillator.
			 *  @type {Tone.OmniOscillator}
			 */
	        this.oscillator = new Tone.OmniOscillator(options.oscillator);
	        /**
			 *  The frequency control.
			 *  @type {Frequency}
			 *  @signal
			 */
	        this.frequency = this.oscillator.frequency;
	        /**
			 *  The detune control.
			 *  @type {Cents}
			 *  @signal
			 */
	        this.detune = this.oscillator.detune;
	        /**
			 *  The filter.
			 *  @type {Tone.Filter}
			 */
	        this.filter = new Tone.Filter(options.filter);
	        /**
			 *  The filter envelope.
			 *  @type {Tone.FrequencyEnvelope}
			 */
	        this.filterEnvelope = new Tone.FrequencyEnvelope(options.filterEnvelope);
	        /**
			 *  The amplitude envelope.
			 *  @type {Tone.AmplitudeEnvelope}
			 */
	        this.envelope = new Tone.AmplitudeEnvelope(options.envelope);
	        //connect the oscillators to the output
	        this.oscillator.chain(this.filter, this.envelope, this.output);
	        //start the oscillators
	        this.oscillator.start();
	        //connect the filter envelope
	        this.filterEnvelope.connect(this.filter.frequency);
	        this._readOnly([
	            'oscillator',
	            'frequency',
	            'detune',
	            'filter',
	            'filterEnvelope',
	            'envelope'
	        ]);
	    };
	    Tone.extend(Tone.MonoSynth, Tone.Monophonic);
	    /**
		 *  @const
		 *  @static
		 *  @type {Object}
		 */
	    Tone.MonoSynth.defaults = {
	        'frequency': 'C4',
	        'detune': 0,
	        'oscillator': { 'type': 'square' },
	        'filter': {
	            'Q': 6,
	            'type': 'lowpass',
	            'rolloff': -24
	        },
	        'envelope': {
	            'attack': 0.005,
	            'decay': 0.1,
	            'sustain': 0.9,
	            'release': 1
	        },
	        'filterEnvelope': {
	            'attack': 0.06,
	            'decay': 0.2,
	            'sustain': 0.5,
	            'release': 2,
	            'baseFrequency': 200,
	            'octaves': 7,
	            'exponent': 2
	        }
	    };
	    /**
		 *  start the attack portion of the envelope
		 *  @param {Time} [time=now] the time the attack should start
		 *  @param {NormalRange} [velocity=1] the velocity of the note (0-1)
		 *  @returns {Tone.MonoSynth} this
		 *  @private
		 */
	    Tone.MonoSynth.prototype._triggerEnvelopeAttack = function (time, velocity) {
	        //the envelopes
	        this.envelope.triggerAttack(time, velocity);
	        this.filterEnvelope.triggerAttack(time);
	        return this;
	    };
	    /**
		 *  start the release portion of the envelope
		 *  @param {Time} [time=now] the time the release should start
		 *  @returns {Tone.MonoSynth} this
		 *  @private
		 */
	    Tone.MonoSynth.prototype._triggerEnvelopeRelease = function (time) {
	        this.envelope.triggerRelease(time);
	        this.filterEnvelope.triggerRelease(time);
	        return this;
	    };
	    /**
		 *  clean up
		 *  @returns {Tone.MonoSynth} this
		 */
	    Tone.MonoSynth.prototype.dispose = function () {
	        Tone.Monophonic.prototype.dispose.call(this);
	        this._writable([
	            'oscillator',
	            'frequency',
	            'detune',
	            'filter',
	            'filterEnvelope',
	            'envelope'
	        ]);
	        this.oscillator.dispose();
	        this.oscillator = null;
	        this.envelope.dispose();
	        this.envelope = null;
	        this.filterEnvelope.dispose();
	        this.filterEnvelope = null;
	        this.filter.dispose();
	        this.filter = null;
	        this.frequency = null;
	        this.detune = null;
	        return this;
	    };
	    return Tone.MonoSynth;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class  Tone.DuoSynth is a monophonic synth composed of two 
		 *          MonoSynths run in parallel with control over the 
		 *          frequency ratio between the two voices and vibrato effect.
		 *          <img src="https://docs.google.com/drawings/d/1bL4GXvfRMMlqS7XyBm9CjL9KJPSUKbcdBNpqOlkFLxk/pub?w=1012&h=448">
		 *
		 *  @constructor
		 *  @extends {Tone.Monophonic}
		 *  @param {Object} [options] the options available for the synth 
		 *                          see defaults below
		 *  @example
		 * var duoSynth = new Tone.DuoSynth().toMaster();
		 * duoSynth.triggerAttackRelease("C4", "2n");
		 */
	    Tone.DuoSynth = function (options) {
	        options = Tone.defaultArg(options, Tone.DuoSynth.defaults);
	        Tone.Monophonic.call(this, options);
	        /**
			 *  the first voice
			 *  @type {Tone.MonoSynth}
			 */
	        this.voice0 = new Tone.MonoSynth(options.voice0);
	        this.voice0.volume.value = -10;
	        /**
			 *  the second voice
			 *  @type {Tone.MonoSynth}
			 */
	        this.voice1 = new Tone.MonoSynth(options.voice1);
	        this.voice1.volume.value = -10;
	        /**
			 *  The vibrato LFO. 
			 *  @type {Tone.LFO}
			 *  @private
			 */
	        this._vibrato = new Tone.LFO(options.vibratoRate, -50, 50);
	        this._vibrato.start();
	        /**
			 * the vibrato frequency
			 * @type {Frequency}
			 * @signal
			 */
	        this.vibratoRate = this._vibrato.frequency;
	        /**
			 *  the vibrato gain
			 *  @type {Tone.Gain}
			 *  @private
			 */
	        this._vibratoGain = new Tone.Gain(options.vibratoAmount, Tone.Type.Positive);
	        /**
			 * The amount of vibrato
			 * @type {Positive}
			 * @signal
			 */
	        this.vibratoAmount = this._vibratoGain.gain;
	        /**
			 *  the frequency control
			 *  @type {Frequency}
			 *  @signal
			 */
	        this.frequency = new Tone.Signal(440, Tone.Type.Frequency);
	        /**
			 *  Harmonicity is the ratio between the two voices. A harmonicity of
			 *  1 is no change. Harmonicity = 2 means a change of an octave. 
			 *  @type {Positive}
			 *  @signal
			 *  @example
			 * //pitch voice1 an octave below voice0
			 * duoSynth.harmonicity.value = 0.5;
			 */
	        this.harmonicity = new Tone.Multiply(options.harmonicity);
	        this.harmonicity.units = Tone.Type.Positive;
	        //control the two voices frequency
	        this.frequency.connect(this.voice0.frequency);
	        this.frequency.chain(this.harmonicity, this.voice1.frequency);
	        this._vibrato.connect(this._vibratoGain);
	        this._vibratoGain.fan(this.voice0.detune, this.voice1.detune);
	        this.voice0.connect(this.output);
	        this.voice1.connect(this.output);
	        this._readOnly([
	            'voice0',
	            'voice1',
	            'frequency',
	            'vibratoAmount',
	            'vibratoRate'
	        ]);
	    };
	    Tone.extend(Tone.DuoSynth, Tone.Monophonic);
	    /**
		 *  @static
		 *  @type {Object}
		 */
	    Tone.DuoSynth.defaults = {
	        'vibratoAmount': 0.5,
	        'vibratoRate': 5,
	        'harmonicity': 1.5,
	        'voice0': {
	            'volume': -10,
	            'portamento': 0,
	            'oscillator': { 'type': 'sine' },
	            'filterEnvelope': {
	                'attack': 0.01,
	                'decay': 0,
	                'sustain': 1,
	                'release': 0.5
	            },
	            'envelope': {
	                'attack': 0.01,
	                'decay': 0,
	                'sustain': 1,
	                'release': 0.5
	            }
	        },
	        'voice1': {
	            'volume': -10,
	            'portamento': 0,
	            'oscillator': { 'type': 'sine' },
	            'filterEnvelope': {
	                'attack': 0.01,
	                'decay': 0,
	                'sustain': 1,
	                'release': 0.5
	            },
	            'envelope': {
	                'attack': 0.01,
	                'decay': 0,
	                'sustain': 1,
	                'release': 0.5
	            }
	        }
	    };
	    /**
		 *  start the attack portion of the envelopes
		 *  
		 *  @param {Time} [time=now] the time the attack should start
		 *  @param {NormalRange} [velocity=1] the velocity of the note (0-1)
		 *  @returns {Tone.DuoSynth} this
		 *  @private
		 */
	    Tone.DuoSynth.prototype._triggerEnvelopeAttack = function (time, velocity) {
	        time = this.toSeconds(time);
	        this.voice0.envelope.triggerAttack(time, velocity);
	        this.voice1.envelope.triggerAttack(time, velocity);
	        this.voice0.filterEnvelope.triggerAttack(time);
	        this.voice1.filterEnvelope.triggerAttack(time);
	        return this;
	    };
	    /**
		 *  start the release portion of the envelopes
		 *  
		 *  @param {Time} [time=now] the time the release should start
		 *  @returns {Tone.DuoSynth} this
		 *  @private
		 */
	    Tone.DuoSynth.prototype._triggerEnvelopeRelease = function (time) {
	        this.voice0.triggerRelease(time);
	        this.voice1.triggerRelease(time);
	        return this;
	    };
	    /**
		 *  clean up
		 *  @returns {Tone.DuoSynth} this
		 */
	    Tone.DuoSynth.prototype.dispose = function () {
	        Tone.Monophonic.prototype.dispose.call(this);
	        this._writable([
	            'voice0',
	            'voice1',
	            'frequency',
	            'vibratoAmount',
	            'vibratoRate'
	        ]);
	        this.voice0.dispose();
	        this.voice0 = null;
	        this.voice1.dispose();
	        this.voice1 = null;
	        this.frequency.dispose();
	        this.frequency = null;
	        this._vibratoGain.dispose();
	        this._vibratoGain = null;
	        this._vibrato = null;
	        this.harmonicity.dispose();
	        this.harmonicity = null;
	        this.vibratoAmount.dispose();
	        this.vibratoAmount = null;
	        this.vibratoRate = null;
	        return this;
	    };
	    return Tone.DuoSynth;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class  FMSynth is composed of two Tone.Synths where one Tone.Synth modulates
		 *          the frequency of a second Tone.Synth. A lot of spectral content 
		 *          can be explored using the modulationIndex parameter. Read more about
		 *          frequency modulation synthesis on Sound On Sound: [Part 1](https://web.archive.org/web/20160403123704/http://www.soundonsound.com/sos/apr00/articles/synthsecrets.htm), [Part 2](https://web.archive.org/web/20160403115835/http://www.soundonsound.com/sos/may00/articles/synth.htm).
		 *          <img src="https://docs.google.com/drawings/d/1h0PUDZXPgi4Ikx6bVT6oncrYPLluFKy7lj53puxj-DM/pub?w=902&h=462">
		 *
		 *  @constructor
		 *  @extends {Tone.Monophonic}
		 *  @param {Object} [options] the options available for the synth
		 *                          see defaults below
		 *  @example
		 * var fmSynth = new Tone.FMSynth().toMaster();
		 * fmSynth.triggerAttackRelease("C5", "4n");
		 */
	    Tone.FMSynth = function (options) {
	        options = Tone.defaultArg(options, Tone.FMSynth.defaults);
	        Tone.Monophonic.call(this, options);
	        /**
			 *  The carrier voice.
			 *  @type {Tone.Synth}
			 *  @private
			 */
	        this._carrier = new Tone.Synth(options.carrier);
	        this._carrier.volume.value = -10;
	        /**
			 *  The carrier's oscillator
			 *  @type {Tone.Oscillator}
			 */
	        this.oscillator = this._carrier.oscillator;
	        /**
			 *  The carrier's envelope
			 *  @type {Tone.Oscillator}
			 */
	        this.envelope = this._carrier.envelope.set(options.envelope);
	        /**
			 *  The modulator voice.
			 *  @type {Tone.Synth}
			 *  @private
			 */
	        this._modulator = new Tone.Synth(options.modulator);
	        this._modulator.volume.value = -10;
	        /**
			 *  The modulator's oscillator which is applied
			 *  to the amplitude of the oscillator
			 *  @type {Tone.Oscillator}
			 */
	        this.modulation = this._modulator.oscillator.set(options.modulation);
	        /**
			 *  The modulator's envelope
			 *  @type {Tone.Oscillator}
			 */
	        this.modulationEnvelope = this._modulator.envelope.set(options.modulationEnvelope);
	        /**
			 *  The frequency control.
			 *  @type {Frequency}
			 *  @signal
			 */
	        this.frequency = new Tone.Signal(440, Tone.Type.Frequency);
	        /**
			 *  The detune in cents
			 *  @type {Cents}
			 *  @signal
			 */
	        this.detune = new Tone.Signal(options.detune, Tone.Type.Cents);
	        /**
			 *  Harmonicity is the ratio between the two voices. A harmonicity of
			 *  1 is no change. Harmonicity = 2 means a change of an octave.
			 *  @type {Positive}
			 *  @signal
			 *  @example
			 * //pitch voice1 an octave below voice0
			 * synth.harmonicity.value = 0.5;
			 */
	        this.harmonicity = new Tone.Multiply(options.harmonicity);
	        this.harmonicity.units = Tone.Type.Positive;
	        /**
			 *  The modulation index which essentially the depth or amount of the modulation. It is the
			 *  ratio of the frequency of the modulating signal (mf) to the amplitude of the
			 *  modulating signal (ma) -- as in ma/mf.
			 *	@type {Positive}
			 *	@signal
			 */
	        this.modulationIndex = new Tone.Multiply(options.modulationIndex);
	        this.modulationIndex.units = Tone.Type.Positive;
	        /**
			 *  the node where the modulation happens
			 *  @type {GainNode}
			 *  @private
			 */
	        this._modulationNode = new Tone.Gain(0);
	        //control the two voices frequency
	        this.frequency.connect(this._carrier.frequency);
	        this.frequency.chain(this.harmonicity, this._modulator.frequency);
	        this.frequency.chain(this.modulationIndex, this._modulationNode);
	        this.detune.fan(this._carrier.detune, this._modulator.detune);
	        this._modulator.connect(this._modulationNode.gain);
	        this._modulationNode.connect(this._carrier.frequency);
	        this._carrier.connect(this.output);
	        this._readOnly([
	            'frequency',
	            'harmonicity',
	            'modulationIndex',
	            'oscillator',
	            'envelope',
	            'modulation',
	            'modulationEnvelope',
	            'detune'
	        ]);
	    };
	    Tone.extend(Tone.FMSynth, Tone.Monophonic);
	    /**
		 *  @static
		 *  @type {Object}
		 */
	    Tone.FMSynth.defaults = {
	        'harmonicity': 3,
	        'modulationIndex': 10,
	        'detune': 0,
	        'oscillator': { 'type': 'sine' },
	        'envelope': {
	            'attack': 0.01,
	            'decay': 0.01,
	            'sustain': 1,
	            'release': 0.5
	        },
	        'modulation': { 'type': 'square' },
	        'modulationEnvelope': {
	            'attack': 0.5,
	            'decay': 0,
	            'sustain': 1,
	            'release': 0.5
	        }
	    };
	    /**
		 * 	trigger the attack portion of the note
		 *
		 *  @param  {Time} [time=now] the time the note will occur
		 *  @param {number} [velocity=1] the velocity of the note
		 *  @returns {Tone.FMSynth} this
		 *  @private
		 */
	    Tone.FMSynth.prototype._triggerEnvelopeAttack = function (time, velocity) {
	        time = this.toSeconds(time);
	        //the envelopes
	        this.envelope.triggerAttack(time, velocity);
	        this.modulationEnvelope.triggerAttack(time);
	        return this;
	    };
	    /**
		 *  trigger the release portion of the note
		 *
		 *  @param  {Time} [time=now] the time the note will release
		 *  @returns {Tone.FMSynth} this
		 *  @private
		 */
	    Tone.FMSynth.prototype._triggerEnvelopeRelease = function (time) {
	        time = this.toSeconds(time);
	        this.envelope.triggerRelease(time);
	        this.modulationEnvelope.triggerRelease(time);
	        return this;
	    };
	    /**
		 *  clean up
		 *  @returns {Tone.FMSynth} this
		 */
	    Tone.FMSynth.prototype.dispose = function () {
	        Tone.Monophonic.prototype.dispose.call(this);
	        this._writable([
	            'frequency',
	            'harmonicity',
	            'modulationIndex',
	            'oscillator',
	            'envelope',
	            'modulation',
	            'modulationEnvelope',
	            'detune'
	        ]);
	        this._carrier.dispose();
	        this._carrier = null;
	        this._modulator.dispose();
	        this._modulator = null;
	        this.frequency.dispose();
	        this.frequency = null;
	        this.detune.dispose();
	        this.detune = null;
	        this.modulationIndex.dispose();
	        this.modulationIndex = null;
	        this.harmonicity.dispose();
	        this.harmonicity = null;
	        this._modulationNode.dispose();
	        this._modulationNode = null;
	        this.oscillator = null;
	        this.envelope = null;
	        this.modulationEnvelope = null;
	        this.modulation = null;
	        return this;
	    };
	    return Tone.FMSynth;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class  Tone.MembraneSynth makes kick and tom sounds using a single oscillator
		 *          with an amplitude envelope and frequency ramp. A Tone.OmniOscillator
		 *          is routed through a Tone.AmplitudeEnvelope to the output. The drum
		 *          quality of the sound comes from the frequency envelope applied
		 *          during during Tone.MembraneSynth.triggerAttack(note). The frequency
		 *          envelope starts at <code>note * .octaves</code> and ramps to 
		 *          <code>note</code> over the duration of <code>.pitchDecay</code>. 
		 *
		 *  @constructor
		 *  @extends {Tone.Instrument}
		 *  @param {Object} [options] the options available for the synth 
		 *                          see defaults below
		 *  @example
		 * var synth = new Tone.MembraneSynth().toMaster();
		 * synth.triggerAttackRelease("C2", "8n");
		 */
	    Tone.MembraneSynth = function (options) {
	        options = Tone.defaultArg(options, Tone.MembraneSynth.defaults);
	        Tone.Instrument.call(this, options);
	        /**
			 *  The oscillator.
			 *  @type {Tone.OmniOscillator}
			 */
	        this.oscillator = new Tone.OmniOscillator(options.oscillator).start();
	        /**
			 *  The amplitude envelope.
			 *  @type {Tone.AmplitudeEnvelope}
			 */
	        this.envelope = new Tone.AmplitudeEnvelope(options.envelope);
	        /**
			 *  The number of octaves the pitch envelope ramps.
			 *  @type {Positive}
			 */
	        this.octaves = options.octaves;
	        /**
			 *  The amount of time the frequency envelope takes. 
			 *  @type {Time}
			 */
	        this.pitchDecay = options.pitchDecay;
	        this.oscillator.chain(this.envelope, this.output);
	        this._readOnly([
	            'oscillator',
	            'envelope'
	        ]);
	    };
	    Tone.extend(Tone.MembraneSynth, Tone.Instrument);
	    /**
		 *  @static
		 *  @type {Object}
		 */
	    Tone.MembraneSynth.defaults = {
	        'pitchDecay': 0.05,
	        'octaves': 10,
	        'oscillator': { 'type': 'sine' },
	        'envelope': {
	            'attack': 0.001,
	            'decay': 0.4,
	            'sustain': 0.01,
	            'release': 1.4,
	            'attackCurve': 'exponential'
	        }
	    };
	    /**
		 *  Trigger the note at the given time with the given velocity. 
		 *  
		 *  @param  {Frequency} note     the note
		 *  @param  {Time} [time=now]     the time, if not given is now
		 *  @param  {number} [velocity=1] velocity defaults to 1
		 *  @returns {Tone.MembraneSynth} this
		 *  @example
		 *  kick.triggerAttack(60);
		 */
	    Tone.MembraneSynth.prototype.triggerAttack = function (note, time, velocity) {
	        time = this.toSeconds(time);
	        note = this.toFrequency(note);
	        var maxNote = note * this.octaves;
	        this.oscillator.frequency.setValueAtTime(maxNote, time);
	        this.oscillator.frequency.exponentialRampToValueAtTime(note, time + this.toSeconds(this.pitchDecay));
	        this.envelope.triggerAttack(time, velocity);
	        return this;
	    };
	    /**
		 *  Trigger the release portion of the note.
		 *  
		 *  @param  {Time} [time=now] the time the note will release
		 *  @returns {Tone.MembraneSynth} this
		 */
	    Tone.MembraneSynth.prototype.triggerRelease = function (time) {
	        this.envelope.triggerRelease(time);
	        return this;
	    };
	    /**
		 *  Clean up.
		 *  @returns {Tone.MembraneSynth} this
		 */
	    Tone.MembraneSynth.prototype.dispose = function () {
	        Tone.Instrument.prototype.dispose.call(this);
	        this._writable([
	            'oscillator',
	            'envelope'
	        ]);
	        this.oscillator.dispose();
	        this.oscillator = null;
	        this.envelope.dispose();
	        this.envelope = null;
	        return this;
	    };
	    return Tone.MembraneSynth;
	});
	Module(function (Tone) {
	    /**
		 *  Inharmonic ratio of frequencies based on the Roland TR-808
		 *  Taken from https://ccrma.stanford.edu/papers/tr-808-cymbal-physically-informed-circuit-bendable-digital-model
		 *  @private
		 *  @static
		 *  @type {Array}
		 */
	    var inharmRatios = [
	        1,
	        1.483,
	        1.932,
	        2.546,
	        2.63,
	        3.897
	    ];
	    /**
		 *  @class  A highly inharmonic and spectrally complex source with a highpass filter
		 *          and amplitude envelope which is good for making metalophone sounds. Based
		 *          on CymbalSynth by [@polyrhythmatic](https://github.com/polyrhythmatic).
		 *          Inspiration from [Sound on Sound](https://web.archive.org/web/20160610143924/https://www.soundonsound.com/sos/jul02/articles/synthsecrets0702.asp).
		 *
		 *  @constructor
		 *  @extends {Tone.Instrument}
		 *  @param {Object} [options] The options availble for the synth
		 *                             see defaults below
		 */
	    Tone.MetalSynth = function (options) {
	        options = Tone.defaultArg(options, Tone.MetalSynth.defaults);
	        Tone.Instrument.call(this, options);
	        /**
			 *  The frequency of the cymbal
			 *  @type  {Frequency}
			 *  @signal
			 */
	        this.frequency = new Tone.Signal(options.frequency, Tone.Type.Frequency);
	        /**
			 *  The array of FMOscillators
			 *  @type  {Array}
			 *  @private
			 */
	        this._oscillators = [];
	        /**
			 *  The frequency multipliers
			 *  @type {Array}
			 *  @private
			 */
	        this._freqMultipliers = [];
	        /**
			 *  The amplitude for the body
			 *  @type {Tone.Gain}
			 *  @private
			 */
	        this._amplitue = new Tone.Gain(0).connect(this.output);
	        /**
			 *  highpass the output
			 *  @type {Tone.Filter}
			 *  @private
			 */
	        this._highpass = new Tone.Filter({
	            'type': 'highpass',
	            'Q': -3.0102999566398125
	        }).connect(this._amplitue);
	        /**
			 *  The number of octaves the highpass
			 *  filter frequency ramps
			 *  @type {Number}
			 *  @private
			 */
	        this._octaves = options.octaves;
	        /**
			 *  Scale the body envelope
			 *  for the bandpass
			 *  @type {Tone.Scale}
			 *  @private
			 */
	        this._filterFreqScaler = new Tone.Scale(options.resonance, 7000);
	        /**
			 *  The envelope which is connected both to the
			 *  amplitude and highpass filter's cutoff frequency
			 *  @type  {Tone.Envelope}
			 */
	        this.envelope = new Tone.Envelope({
	            'attack': options.envelope.attack,
	            'attackCurve': 'linear',
	            'decay': options.envelope.decay,
	            'sustain': 0,
	            'release': options.envelope.release
	        }).chain(this._filterFreqScaler, this._highpass.frequency);
	        this.envelope.connect(this._amplitue.gain);
	        for (var i = 0; i < inharmRatios.length; i++) {
	            var osc = new Tone.FMOscillator({
	                'type': 'square',
	                'modulationType': 'square',
	                'harmonicity': options.harmonicity,
	                'modulationIndex': options.modulationIndex
	            });
	            osc.connect(this._highpass).start(0);
	            this._oscillators[i] = osc;
	            var mult = new Tone.Multiply(inharmRatios[i]);
	            this._freqMultipliers[i] = mult;
	            this.frequency.chain(mult, osc.frequency);
	        }
	        //set the octaves
	        this.octaves = options.octaves;
	    };
	    Tone.extend(Tone.MetalSynth, Tone.Instrument);
	    /**
		 *  default values
		 *  @static
		 *  @const
		 *  @type {Object}
		 */
	    Tone.MetalSynth.defaults = {
	        'frequency': 200,
	        'envelope': {
	            'attack': 0.001,
	            'decay': 1.4,
	            'release': 0.2
	        },
	        'harmonicity': 5.1,
	        'modulationIndex': 32,
	        'resonance': 4000,
	        'octaves': 1.5
	    };
	    /**
		 *  Trigger the attack.
		 *  @param  {Time}  time      When the attack should be triggered.
		 *  @param  {NormalRange}  [velocity=1]  The velocity that the envelope should be triggered at.
		 *  @return  {Tone.MetalSynth}  this
		 */
	    Tone.MetalSynth.prototype.triggerAttack = function (time, vel) {
	        time = this.toSeconds(time);
	        vel = Tone.defaultArg(vel, 1);
	        this.envelope.triggerAttack(time, vel);
	        return this;
	    };
	    /**
		 *  Trigger the release of the envelope.
		 *  @param  {Time}  time      When the release should be triggered.
		 *  @return  {Tone.MetalSynth}  this
		 */
	    Tone.MetalSynth.prototype.triggerRelease = function (time) {
	        time = this.toSeconds(time);
	        this.envelope.triggerRelease(time);
	        return this;
	    };
	    /**
		 *  Trigger the attack and release of the envelope after the given
		 *  duration.
		 *  @param  {Time}  duration  The duration before triggering the release
		 *  @param  {Time}  time      When the attack should be triggered.
		 *  @param  {NormalRange}  [velocity=1]  The velocity that the envelope should be triggered at.
		 *  @return  {Tone.MetalSynth}  this
		 */
	    Tone.MetalSynth.prototype.triggerAttackRelease = function (duration, time, velocity) {
	        time = this.toSeconds(time);
	        duration = this.toSeconds(duration);
	        this.triggerAttack(time, velocity);
	        this.triggerRelease(time + duration);
	        return this;
	    };
	    /**
		 *  The modulationIndex of the oscillators which make up the source.
		 *  see Tone.FMOscillator.modulationIndex
		 *  @memberOf Tone.MetalSynth#
		 *  @type {Positive}
		 *  @name  modulationIndex
		 */
	    Object.defineProperty(Tone.MetalSynth.prototype, 'modulationIndex', {
	        get: function () {
	            return this._oscillators[0].modulationIndex.value;
	        },
	        set: function (val) {
	            for (var i = 0; i < this._oscillators.length; i++) {
	                this._oscillators[i].modulationIndex.value = val;
	            }
	        }
	    });
	    /**
		 *  The harmonicity of the oscillators which make up the source.
		 *  see Tone.FMOscillator.harmonicity
		 *  @memberOf Tone.MetalSynth#
		 *  @type {Positive}
		 *  @name  harmonicity
		 */
	    Object.defineProperty(Tone.MetalSynth.prototype, 'harmonicity', {
	        get: function () {
	            return this._oscillators[0].harmonicity.value;
	        },
	        set: function (val) {
	            for (var i = 0; i < this._oscillators.length; i++) {
	                this._oscillators[i].harmonicity.value = val;
	            }
	        }
	    });
	    /**
		 *  The frequency of the highpass filter attached to the envelope
		 *  @memberOf Tone.MetalSynth#
		 *  @type {Frequency}
		 *  @name  resonance
		 */
	    Object.defineProperty(Tone.MetalSynth.prototype, 'resonance', {
	        get: function () {
	            return this._filterFreqScaler.min;
	        },
	        set: function (val) {
	            this._filterFreqScaler.min = val;
	            this.octaves = this._octaves;
	        }
	    });
	    /**
		 *  The number of octaves above the "resonance" frequency
		 *  that the filter ramps during the attack/decay envelope
		 *  @memberOf Tone.MetalSynth#
		 *  @type {Number}
		 *  @name  octaves
		 */
	    Object.defineProperty(Tone.MetalSynth.prototype, 'octaves', {
	        get: function () {
	            return this._octaves;
	        },
	        set: function (octs) {
	            this._octaves = octs;
	            this._filterFreqScaler.max = this._filterFreqScaler.min * Math.pow(2, octs);
	        }
	    });
	    /**
		 *  Clean up
		 *  @returns {Tone.MetalSynth} this
		 */
	    Tone.MetalSynth.prototype.dispose = function () {
	        Tone.Instrument.prototype.dispose.call(this);
	        for (var i = 0; i < this._oscillators.length; i++) {
	            this._oscillators[i].dispose();
	            this._freqMultipliers[i].dispose();
	        }
	        this._oscillators = null;
	        this._freqMultipliers = null;
	        this.frequency.dispose();
	        this.frequency = null;
	        this._filterFreqScaler.dispose();
	        this._filterFreqScaler = null;
	        this._amplitue.dispose();
	        this._amplitue = null;
	        this.envelope.dispose();
	        this.envelope = null;
	        this._highpass.dispose();
	        this._highpass = null;
	    };
	    return Tone.MetalSynth;
	});
	Module(function (Tone) {
	    /**
		 *  BufferSource polyfill
		 */
	    if (window.AudioBufferSourceNode && !AudioBufferSourceNode.prototype.start) {
	        AudioBufferSourceNode.prototype.start = AudioBufferSourceNode.prototype.noteGrainOn;
	        AudioBufferSourceNode.prototype.stop = AudioBufferSourceNode.prototype.noteOff;
	    }
	    /**
		 *  @class Wrapper around the native BufferSourceNode.
		 *  @extends {Tone.AudioNode}
		 *  @param  {AudioBuffer|Tone.Buffer}  buffer   The buffer to play
		 *  @param  {Function}  onload  The callback to invoke when the
		 *                               buffer is done playing.
		 */
	    Tone.BufferSource = function () {
	        var options = Tone.defaults(arguments, [
	            'buffer',
	            'onload'
	        ], Tone.BufferSource);
	        Tone.AudioNode.call(this);
	        /**
			 *  The callback to invoke after the
			 *  buffer source is done playing.
			 *  @type  {Function}
			 */
	        this.onended = options.onended;
	        /**
			 *  The time that the buffer was started.
			 *  @type  {Number}
			 *  @private
			 */
	        this._startTime = -1;
	        /**
			 *  The time that the buffer is scheduled to stop.
			 *  @type  {Number}
			 *  @private
			 */
	        this._stopTime = -1;
	        /**
			 *  The gain node which envelopes the BufferSource
			 *  @type  {Tone.Gain}
			 *  @private
			 */
	        this._gainNode = this.output = new Tone.Gain();
	        /**
			 *  The buffer source
			 *  @type  {AudioBufferSourceNode}
			 *  @private
			 */
	        this._source = this.context.createBufferSource();
	        this._source.connect(this._gainNode);
	        /**
			 * The private buffer instance
			 * @type {Tone.Buffer}
			 * @private
			 */
	        this._buffer = new Tone.Buffer(options.buffer, options.onload);
	        /**
			 *  The playbackRate of the buffer
			 *  @type {Positive}
			 *  @signal
			 */
	        this.playbackRate = new Tone.Param(this._source.playbackRate, Tone.Type.Positive);
	        /**
			 *  The fadeIn time of the amplitude envelope.
			 *  @type {Time}
			 */
	        this.fadeIn = options.fadeIn;
	        /**
			 *  The fadeOut time of the amplitude envelope.
			 *  @type {Time}
			 */
	        this.fadeOut = options.fadeOut;
	        /**
			 *  The value that the buffer ramps to
			 *  @type {Gain}
			 *  @private
			 */
	        this._gain = 1;
	        /**
			 * The onended timeout
			 * @type {Number}
			 * @private
			 */
	        this._onendedTimeout = -1;
	        this.loop = options.loop;
	        this.loopStart = options.loopStart;
	        this.loopEnd = options.loopEnd;
	        this.playbackRate.value = options.playbackRate;
	    };
	    Tone.extend(Tone.BufferSource, Tone.AudioNode);
	    /**
		 *  The defaults
		 *  @const
		 *  @type  {Object}
		 */
	    Tone.BufferSource.defaults = {
	        'onended': Tone.noOp,
	        'onload': Tone.noOp,
	        'loop': false,
	        'loopStart': 0,
	        'loopEnd': 0,
	        'fadeIn': 0,
	        'fadeOut': 0,
	        'playbackRate': 1
	    };
	    /**
		 *  Returns the playback state of the source, either "started" or "stopped".
		 *  @type {Tone.State}
		 *  @readOnly
		 *  @memberOf Tone.BufferSource#
		 *  @name state
		 */
	    Object.defineProperty(Tone.BufferSource.prototype, 'state', {
	        get: function () {
	            var now = this.now();
	            if (this._startTime !== -1 && now >= this._startTime && now < this._stopTime) {
	                return Tone.State.Started;
	            } else {
	                return Tone.State.Stopped;
	            }
	        }
	    });
	    /**
		 *  Start the buffer
		 *  @param  {Time} [startTime=now] When the player should start.
		 *  @param  {Time} [offset=0] The offset from the beginning of the sample
		 *                                 to start at.
		 *  @param  {Time=} duration How long the sample should play. If no duration
		 *                                is given, it will default to the full length
		 *                                of the sample (minus any offset)
		 *  @param  {Gain}  [gain=1]  The gain to play the buffer back at.
		 *  @param  {Time=}  fadeInTime  The optional fadeIn ramp time.
		 *  @return  {Tone.BufferSource}  this
		 */
	    Tone.BufferSource.prototype.start = function (time, offset, duration, gain, fadeInTime) {
	        if (this._startTime !== -1) {
	            throw new Error('Tone.BufferSource can only be started once.');
	        }
	        if (this.buffer.loaded) {
	            time = this.toSeconds(time);
	            //if it's a loop the default offset is the loopstart point
	            if (this.loop) {
	                offset = Tone.defaultArg(offset, this.loopStart);
	            } else {
	                //otherwise the default offset is 0
	                offset = Tone.defaultArg(offset, 0);
	            }
	            offset = this.toSeconds(offset);
	            //the values in seconds
	            time = this.toSeconds(time);
	            gain = Tone.defaultArg(gain, 1);
	            this._gain = gain;
	            //the fadeIn time
	            if (Tone.isUndef(fadeInTime)) {
	                fadeInTime = this.toSeconds(this.fadeIn);
	            } else {
	                fadeInTime = this.toSeconds(fadeInTime);
	            }
	            if (fadeInTime > 0) {
	                this._gainNode.gain.setValueAtTime(0, time);
	                this._gainNode.gain.linearRampToValueAtTime(this._gain, time + fadeInTime);
	            } else {
	                this._gainNode.gain.setValueAtTime(gain, time);
	            }
	            this._startTime = time + fadeInTime;
	            var computedDur = Tone.defaultArg(duration, this.buffer.duration - offset);
	            computedDur = this.toSeconds(computedDur);
	            computedDur = Math.max(computedDur, 0);
	            if (!this.loop || this.loop && !Tone.isUndef(duration)) {
	                //clip the duration when not looping
	                if (!this.loop) {
	                    computedDur = Math.min(computedDur, this.buffer.duration - offset);
	                }
	                this.stop(time + computedDur + fadeInTime, this.fadeOut);
	            }
	            //start the buffer source
	            if (this.loop) {
	                //modify the offset if it's greater than the loop time
	                var loopEnd = this.loopEnd || this.buffer.duration;
	                var loopStart = this.loopStart;
	                var loopDuration = loopEnd - loopStart;
	                //move the offset back
	                if (offset > loopEnd) {
	                    offset = (offset - loopStart) % loopDuration + loopStart;
	                }
	            }
	            this._source.buffer = this.buffer.get();
	            this._source.loopEnd = this.loopEnd || this.buffer.duration;
	            this._source.start(time, offset);
	        } else {
	            throw new Error('Tone.BufferSource: buffer is either not set or not loaded.');
	        }
	        return this;
	    };
	    /**
		 *  Stop the buffer. Optionally add a ramp time to fade the
		 *  buffer out.
		 *  @param  {Time=}  time         The time the buffer should stop.
		 *  @param  {Time=}  fadeOutTime  How long the gain should fade out for
		 *  @return  {Tone.BufferSource}  this
		 */
	    Tone.BufferSource.prototype.stop = function (time, fadeOutTime) {
	        if (this.buffer.loaded) {
	            time = this.toSeconds(time);
	            //the fadeOut time
	            if (Tone.isUndef(fadeOutTime)) {
	                fadeOutTime = this.toSeconds(this.fadeOut);
	            } else {
	                fadeOutTime = this.toSeconds(fadeOutTime);
	            }
	            //only stop if the last stop was scheduled later
	            if (this._stopTime === -1 || this._stopTime > time) {
	                this._stopTime = time;
	                //cancel the end curve
	                this._gainNode.gain.cancelScheduledValues(this._startTime + this.sampleTime);
	                time = Math.max(this._startTime, time);
	                //set a new one
	                if (fadeOutTime > 0) {
	                    var startFade = Math.max(this._startTime, time - fadeOutTime);
	                    this._gainNode.gain.setValueAtTime(this._gain, startFade);
	                    this._gainNode.gain.linearRampToValueAtTime(0, time);
	                } else {
	                    this._gainNode.gain.setValueAtTime(0, time);
	                }
	                Tone.context.clearTimeout(this._onendedTimeout);
	                this._onendedTimeout = Tone.context.setTimeout(this._onended.bind(this), this._stopTime - this.now());
	            }
	        } else {
	            throw new Error('Tone.BufferSource: buffer is either not set or not loaded.');
	        }
	        return this;
	    };
	    /**
		 *  Internal callback when the buffer is ended.
		 *  Invokes `onended` and disposes the node.
		 *  @private
		 */
	    Tone.BufferSource.prototype._onended = function () {
	        this.onended(this);
	    };
	    /**
		 * If loop is true, the loop will start at this position.
		 * @memberOf Tone.BufferSource#
		 * @type {Time}
		 * @name loopStart
		 */
	    Object.defineProperty(Tone.BufferSource.prototype, 'loopStart', {
	        get: function () {
	            return this._source.loopStart;
	        },
	        set: function (loopStart) {
	            this._source.loopStart = this.toSeconds(loopStart);
	        }
	    });
	    /**
		 * If loop is true, the loop will end at this position.
		 * @memberOf Tone.BufferSource#
		 * @type {Time}
		 * @name loopEnd
		 */
	    Object.defineProperty(Tone.BufferSource.prototype, 'loopEnd', {
	        get: function () {
	            return this._source.loopEnd;
	        },
	        set: function (loopEnd) {
	            this._source.loopEnd = this.toSeconds(loopEnd);
	        }
	    });
	    /**
		 * The audio buffer belonging to the player.
		 * @memberOf Tone.BufferSource#
		 * @type {Tone.Buffer}
		 * @name buffer
		 */
	    Object.defineProperty(Tone.BufferSource.prototype, 'buffer', {
	        get: function () {
	            return this._buffer;
	        },
	        set: function (buffer) {
	            this._buffer.set(buffer);
	        }
	    });
	    /**
		 * If the buffer should loop once it's over.
		 * @memberOf Tone.BufferSource#
		 * @type {Boolean}
		 * @name loop
		 */
	    Object.defineProperty(Tone.BufferSource.prototype, 'loop', {
	        get: function () {
	            return this._source.loop;
	        },
	        set: function (loop) {
	            this._source.loop = loop;
	        }
	    });
	    /**
		 *  Clean up.
		 *  @return  {Tone.BufferSource}  this
		 */
	    Tone.BufferSource.prototype.dispose = function () {
	        Tone.AudioNode.prototype.dispose.call(this);
	        this.onended = null;
	        this._source.disconnect();
	        this._source = null;
	        this._gainNode.dispose();
	        this._gainNode = null;
	        this._buffer.dispose();
	        this._buffer = null;
	        this._startTime = -1;
	        this.playbackRate = null;
	        Tone.context.clearTimeout(this._onendedTimeout);
	        return this;
	    };
	    return Tone.BufferSource;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class  Tone.Noise is a noise generator. It uses looped noise buffers to save on performance.
		 *          Tone.Noise supports the noise types: "pink", "white", and "brown". Read more about
		 *          colors of noise on [Wikipedia](https://en.wikipedia.org/wiki/Colors_of_noise).
		 *
		 *  @constructor
		 *  @extends {Tone.Source}
		 *  @param {string} type the noise type (white|pink|brown)
		 *  @example
		 * //initialize the noise and start
		 * var noise = new Tone.Noise("pink").start();
		 * 
		 * //make an autofilter to shape the noise
		 * var autoFilter = new Tone.AutoFilter({
		 * 	"frequency" : "8m", 
		 * 	"min" : 800, 
		 * 	"max" : 15000
		 * }).connect(Tone.Master);
		 * 
		 * //connect the noise
		 * noise.connect(autoFilter);
		 * //start the autofilter LFO
		 * autoFilter.start()
		 */
	    Tone.Noise = function () {
	        var options = Tone.defaults(arguments, ['type'], Tone.Noise);
	        Tone.Source.call(this, options);
	        /**
			 *  @private
			 *  @type {AudioBufferSourceNode}
			 */
	        this._source = null;
	        /**
			 *  the buffer
			 *  @private
			 *  @type {AudioBuffer}
			 */
	        this._type = options.type;
	        /**
			 *  The playback rate of the noise. Affects
			 *  the "frequency" of the noise.
			 *  @type {Positive}
			 *  @signal
			 */
	        this._playbackRate = options.playbackRate;
	    };
	    Tone.extend(Tone.Noise, Tone.Source);
	    /**
		 *  the default parameters
		 *
		 *  @static
		 *  @const
		 *  @type {Object}
		 */
	    Tone.Noise.defaults = {
	        'type': 'white',
	        'playbackRate': 1
	    };
	    /**
		 * The type of the noise. Can be "white", "brown", or "pink". 
		 * @memberOf Tone.Noise#
		 * @type {string}
		 * @name type
		 * @example
		 * noise.type = "white";
		 */
	    Object.defineProperty(Tone.Noise.prototype, 'type', {
	        get: function () {
	            return this._type;
	        },
	        set: function (type) {
	            if (this._type !== type) {
	                if (type in _noiseBuffers) {
	                    this._type = type;
	                    //if it's playing, stop and restart it
	                    if (this.state === Tone.State.Started) {
	                        var now = this.now();
	                        this._stop(now);
	                        this._start(now);
	                    }
	                } else {
	                    throw new TypeError('Tone.Noise: invalid type: ' + type);
	                }
	            }
	        }
	    });
	    /**
		 *  The playback rate of the noise. Affects
		 *  the "frequency" of the noise.
		 *  @type {Positive}
		 *  @signal
		 */
	    Object.defineProperty(Tone.Noise.prototype, 'playbackRate', {
	        get: function () {
	            return this._playbackRate;
	        },
	        set: function (rate) {
	            this._playbackRate = rate;
	            if (this._source) {
	                this._source.playbackRate.value = rate;
	            }
	        }
	    });
	    /**
		 *  internal start method
		 *
		 *  @param {Time} time
		 *  @private
		 */
	    Tone.Noise.prototype._start = function (time) {
	        var buffer = _noiseBuffers[this._type];
	        this._source = new Tone.BufferSource(buffer).connect(this.output);
	        this._source.loop = true;
	        this._source.playbackRate.value = this._playbackRate;
	        this._source.start(this.toSeconds(time), Math.random() * (buffer.duration - 0.001));
	    };
	    /**
		 *  internal stop method
		 *
		 *  @param {Time} time
		 *  @private
		 */
	    Tone.Noise.prototype._stop = function (time) {
	        if (this._source) {
	            this._source.stop(this.toSeconds(time));
	            this._source = null;
	        }
	    };
	    /**
		 *  Clean up.
		 *  @returns {Tone.Noise} this
		 */
	    Tone.Noise.prototype.dispose = function () {
	        Tone.Source.prototype.dispose.call(this);
	        if (this._source !== null) {
	            this._source.disconnect();
	            this._source = null;
	        }
	        this._buffer = null;
	        return this;
	    };
	    ///////////////////////////////////////////////////////////////////////////
	    // THE BUFFERS
	    ///////////////////////////////////////////////////////////////////////////
	    //Noise buffer stats
	    var bufferLength = 44100 * 5;
	    var channels = 2;
	    /**
		 *	The noise arrays. Generated on initialization.
		 *  borrowed heavily from https://github.com/zacharydenton/noise.js 
		 *  (c) 2013 Zach Denton (MIT)
		 *  @static
		 *  @private
		 *  @type {Array}
		 */
	    var _noiseArrays = {
	        'pink': function () {
	            var buffer = [];
	            for (var channelNum = 0; channelNum < channels; channelNum++) {
	                var channel = new Float32Array(bufferLength);
	                buffer[channelNum] = channel;
	                var b0, b1, b2, b3, b4, b5, b6;
	                b0 = b1 = b2 = b3 = b4 = b5 = b6 = 0;
	                for (var i = 0; i < bufferLength; i++) {
	                    var white = Math.random() * 2 - 1;
	                    b0 = 0.99886 * b0 + white * 0.0555179;
	                    b1 = 0.99332 * b1 + white * 0.0750759;
	                    b2 = 0.969 * b2 + white * 0.153852;
	                    b3 = 0.8665 * b3 + white * 0.3104856;
	                    b4 = 0.55 * b4 + white * 0.5329522;
	                    b5 = -0.7616 * b5 - white * 0.016898;
	                    channel[i] = b0 + b1 + b2 + b3 + b4 + b5 + b6 + white * 0.5362;
	                    channel[i] *= 0.11;
	                    // (roughly) compensate for gain
	                    b6 = white * 0.115926;
	                }
	            }
	            return buffer;
	        }(),
	        'brown': function () {
	            var buffer = [];
	            for (var channelNum = 0; channelNum < channels; channelNum++) {
	                var channel = new Float32Array(bufferLength);
	                buffer[channelNum] = channel;
	                var lastOut = 0;
	                for (var i = 0; i < bufferLength; i++) {
	                    var white = Math.random() * 2 - 1;
	                    channel[i] = (lastOut + 0.02 * white) / 1.02;
	                    lastOut = channel[i];
	                    channel[i] *= 3.5;    // (roughly) compensate for gain
	                }
	            }
	            return buffer;
	        }(),
	        'white': function () {
	            var buffer = [];
	            for (var channelNum = 0; channelNum < channels; channelNum++) {
	                var channel = new Float32Array(bufferLength);
	                buffer[channelNum] = channel;
	                for (var i = 0; i < bufferLength; i++) {
	                    channel[i] = Math.random() * 2 - 1;
	                }
	            }
	            return buffer;
	        }()
	    };
	    /**
		 *	static noise buffers
		 *  @static
		 *  @private
		 *  @type {Tone.Buffer}
		 */
	    var _noiseBuffers = {};
	    //create the Tone.Buffers
	    function createBuffers() {
	        for (var type in _noiseArrays) {
	            _noiseBuffers[type] = new Tone.Buffer().fromArray(_noiseArrays[type]);
	        }
	    }
	    //create the noise buffers
	    Tone.getContext(createBuffers);
	    Tone.Context.on('init', createBuffers);
	    return Tone.Noise;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class  Tone.NoiseSynth is composed of a noise generator (Tone.Noise), one filter (Tone.Filter), 
		 *          and two envelopes (Tone.Envelop). One envelope controls the amplitude
		 *          of the noise and the other is controls the cutoff frequency of the filter. 
		 *          <img src="https://docs.google.com/drawings/d/1rqzuX9rBlhT50MRvD2TKml9bnZhcZmzXF1rf_o7vdnE/pub?w=918&h=242">
		 *
		 *  @constructor
		 *  @extends {Tone.Instrument}
		 *  @param {Object} [options] the options available for the synth 
		 *                          see defaults below
		 * @example
		 * var noiseSynth = new Tone.NoiseSynth().toMaster();
		 * noiseSynth.triggerAttackRelease("8n");
		 */
	    Tone.NoiseSynth = function (options) {
	        //get the defaults
	        options = Tone.defaultArg(options, Tone.NoiseSynth.defaults);
	        Tone.Instrument.call(this, options);
	        /**
			 *  The noise source.
			 *  @type {Tone.Noise}
			 *  @example
			 * noiseSynth.set("noise.type", "brown");
			 */
	        this.noise = new Tone.Noise();
	        /**
			 *  The amplitude envelope. 
			 *  @type {Tone.AmplitudeEnvelope}
			 */
	        this.envelope = new Tone.AmplitudeEnvelope(options.envelope);
	        //connect the noise to the output
	        this.noise.chain(this.envelope, this.output);
	        //start the noise
	        this.noise.start();
	        this._readOnly([
	            'noise',
	            'envelope'
	        ]);
	    };
	    Tone.extend(Tone.NoiseSynth, Tone.Instrument);
	    /**
		 *  @const
		 *  @static
		 *  @type {Object}
		 */
	    Tone.NoiseSynth.defaults = {
	        'noise': { 'type': 'white' },
	        'envelope': {
	            'attack': 0.005,
	            'decay': 0.1,
	            'sustain': 0
	        }
	    };
	    /**
		 *  Start the attack portion of the envelopes. Unlike other 
		 *  instruments, Tone.NoiseSynth doesn't have a note. 
		 *  @param {Time} [time=now] the time the attack should start
		 *  @param {number} [velocity=1] the velocity of the note (0-1)
		 *  @returns {Tone.NoiseSynth} this
		 *  @example
		 * noiseSynth.triggerAttack();
		 */
	    Tone.NoiseSynth.prototype.triggerAttack = function (time, velocity) {
	        //the envelopes
	        this.envelope.triggerAttack(time, velocity);
	        return this;
	    };
	    /**
		 *  Start the release portion of the envelopes.
		 *  @param {Time} [time=now] the time the release should start
		 *  @returns {Tone.NoiseSynth} this
		 */
	    Tone.NoiseSynth.prototype.triggerRelease = function (time) {
	        this.envelope.triggerRelease(time);
	        return this;
	    };
	    /**
		 *  Trigger the attack and then the release. 
		 *  @param  {Time} duration the duration of the note
		 *  @param  {Time} [time=now]     the time of the attack
		 *  @param  {number} [velocity=1] the velocity
		 *  @returns {Tone.NoiseSynth} this
		 */
	    Tone.NoiseSynth.prototype.triggerAttackRelease = function (duration, time, velocity) {
	        time = this.toSeconds(time);
	        duration = this.toSeconds(duration);
	        this.triggerAttack(time, velocity);
	        this.triggerRelease(time + duration);
	        return this;
	    };
	    /**
		 *  Clean up. 
		 *  @returns {Tone.NoiseSynth} this
		 */
	    Tone.NoiseSynth.prototype.dispose = function () {
	        Tone.Instrument.prototype.dispose.call(this);
	        this._writable([
	            'noise',
	            'envelope'
	        ]);
	        this.noise.dispose();
	        this.noise = null;
	        this.envelope.dispose();
	        this.envelope = null;
	        return this;
	    };
	    return Tone.NoiseSynth;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Karplus-String string synthesis. Often out of tune. 
		 *         Will change when the AudioWorkerNode is available across
		 *         browsers. 
		 *  
		 *  @constructor
		 *  @extends {Tone.Instrument}
		 *  @param {Object} [options] see the defaults
		 *  @example
		 * var plucky = new Tone.PluckSynth().toMaster();
		 * plucky.triggerAttack("C4");
		 */
	    Tone.PluckSynth = function (options) {
	        options = Tone.defaultArg(options, Tone.PluckSynth.defaults);
	        Tone.Instrument.call(this, options);
	        /**
			 *  @type {Tone.Noise}
			 *  @private
			 */
	        this._noise = new Tone.Noise('pink');
	        /**
			 *  The amount of noise at the attack. 
			 *  Nominal range of [0.1, 20]
			 *  @type {number}
			 */
	        this.attackNoise = options.attackNoise;
	        /**
			 *  the LFCF
			 *  @type {Tone.LowpassCombFilter}
			 *  @private
			 */
	        this._lfcf = new Tone.LowpassCombFilter({
	            'resonance': options.resonance,
	            'dampening': options.dampening
	        });
	        /**
			 *  The resonance control. 
			 *  @type {NormalRange}
			 *  @signal
			 */
	        this.resonance = this._lfcf.resonance;
	        /**
			 *  The dampening control. i.e. the lowpass filter frequency of the comb filter
			 *  @type {Frequency}
			 *  @signal
			 */
	        this.dampening = this._lfcf.dampening;
	        //connections
	        this._noise.connect(this._lfcf);
	        this._lfcf.connect(this.output);
	        this._readOnly([
	            'resonance',
	            'dampening'
	        ]);
	    };
	    Tone.extend(Tone.PluckSynth, Tone.Instrument);
	    /**
		 *  @static
		 *  @const
		 *  @type {Object}
		 */
	    Tone.PluckSynth.defaults = {
	        'attackNoise': 1,
	        'dampening': 4000,
	        'resonance': 0.9
	    };
	    /**
		 *  Trigger the note. 
		 *  @param {Frequency} note The note to trigger.
		 *  @param {Time} [time=now] When the note should be triggered.
		 *  @returns {Tone.PluckSynth} this
		 */
	    Tone.PluckSynth.prototype.triggerAttack = function (note, time) {
	        note = this.toFrequency(note);
	        time = this.toSeconds(time);
	        var delayAmount = 1 / note;
	        this._lfcf.delayTime.setValueAtTime(delayAmount, time);
	        this._noise.start(time);
	        this._noise.stop(time + delayAmount * this.attackNoise);
	        return this;
	    };
	    /**
		 *  Clean up. 
		 *  @returns {Tone.PluckSynth} this
		 */
	    Tone.PluckSynth.prototype.dispose = function () {
	        Tone.Instrument.prototype.dispose.call(this);
	        this._noise.dispose();
	        this._lfcf.dispose();
	        this._noise = null;
	        this._lfcf = null;
	        this._writable([
	            'resonance',
	            'dampening'
	        ]);
	        this.dampening = null;
	        this.resonance = null;
	        return this;
	    };
	    return Tone.PluckSynth;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class  Tone.PolySynth handles voice creation and allocation for any
		 *          instruments passed in as the second paramter. PolySynth is 
		 *          not a synthesizer by itself, it merely manages voices of 
		 *          one of the other types of synths, allowing any of the 
		 *          monophonic synthesizers to be polyphonic. 
		 *
		 *  @constructor
		 *  @extends {Tone.Instrument}
		 *  @param {number|Object} [polyphony=4] The number of voices to create
		 *  @param {function} [voice=Tone.Synth] The constructor of the voices
		 *                                            uses Tone.Synth by default. 
		 *  @example
		 * //a polysynth composed of 6 Voices of Synth
		 * var synth = new Tone.PolySynth(6, Tone.Synth).toMaster();
		 * //set the attributes using the set interface
		 * synth.set("detune", -1200);
		 * //play a chord
		 * synth.triggerAttackRelease(["C4", "E4", "A4"], "4n");
		 */
	    Tone.PolySynth = function () {
	        var options = Tone.defaults(arguments, [
	            'polyphony',
	            'voice'
	        ], Tone.PolySynth);
	        Tone.Instrument.call(this, options);
	        options = Tone.defaultArg(options, Tone.Instrument.defaults);
	        //max polyphony
	        options.polyphony = Math.min(Tone.PolySynth.MAX_POLYPHONY, options.polyphony);
	        /**
			 *  the array of voices
			 *  @type {Array}
			 */
	        this.voices = new Array(options.polyphony);
	        /**
			 *  The queue of voices with data about last trigger
			 *  and the triggered note
			 *  @private
			 *  @type {Array}
			 */
	        this._triggers = new Array(options.polyphony);
	        /**
			 *  The detune in cents
			 *  @type {Cents}
			 *  @signal
			 */
	        this.detune = new Tone.Signal(options.detune, Tone.Type.Cents);
	        this._readOnly('detune');
	        //create the voices
	        for (var i = 0; i < options.polyphony; i++) {
	            var v = new options.voice(arguments[2], arguments[3]);
	            this.voices[i] = v;
	            v.connect(this.output);
	            if (v.hasOwnProperty('detune')) {
	                this.detune.connect(v.detune);
	            }
	            this._triggers[i] = {
	                release: -1,
	                note: null,
	                voice: v
	            };
	        }
	    };
	    Tone.extend(Tone.PolySynth, Tone.Instrument);
	    /**
		 *  the defaults
		 *  @const
		 *  @static
		 *  @type {Object}
		 */
	    Tone.PolySynth.defaults = {
	        'polyphony': 4,
	        'volume': 0,
	        'detune': 0,
	        'voice': Tone.Synth
	    };
	    /**
		 *  Trigger the attack portion of the note
		 *  @param  {Frequency|Array} notes The notes to play. Accepts a single
		 *                                  Frequency or an array of frequencies.
		 *  @param  {Time} [time=now]  The start time of the note.
		 *  @param {number} [velocity=1] The velocity of the note.
		 *  @returns {Tone.PolySynth} this
		 *  @example
		 * //trigger a chord immediately with a velocity of 0.2
		 * poly.triggerAttack(["Ab3", "C4", "F5"], undefined, 0.2);
		 */
	    Tone.PolySynth.prototype.triggerAttack = function (notes, time, velocity) {
	        if (!Array.isArray(notes)) {
	            notes = [notes];
	        }
	        time = this.toSeconds(time);
	        for (var i = 0; i < notes.length; i++) {
	            var val = notes[i];
	            //trigger the oldest voice
	            var oldest = this._triggers[0];
	            var oldestIndex = 0;
	            for (var j = 1; j < this._triggers.length; j++) {
	                if (this._triggers[j].release < oldest.release) {
	                    oldest = this._triggers[j];
	                    oldestIndex = j;
	                }
	            }
	            oldest.release = Infinity;
	            oldest.note = JSON.stringify(val);
	            oldest.voice.triggerAttack(val, time, velocity);
	        }
	        return this;
	    };
	    /**
		 *  Trigger the attack and release after the specified duration
		 *  
		 *  @param  {Frequency|Array} notes The notes to play. Accepts a single
		 *                                  Frequency or an array of frequencies.
		 *  @param  {Time} duration the duration of the note
		 *  @param  {Time} [time=now]     if no time is given, defaults to now
		 *  @param  {number} [velocity=1] the velocity of the attack (0-1)
		 *  @returns {Tone.PolySynth} this
		 *  @example
		 * //trigger a chord for a duration of a half note 
		 * poly.triggerAttackRelease(["Eb3", "G4", "C5"], "2n");
		 *  @example
		 * //can pass in an array of durations as well
		 * poly.triggerAttackRelease(["Eb3", "G4", "C5"], ["2n", "4n", "4n"]);
		 */
	    Tone.PolySynth.prototype.triggerAttackRelease = function (notes, duration, time, velocity) {
	        time = this.toSeconds(time);
	        this.triggerAttack(notes, time, velocity);
	        if (Tone.isArray(duration) && Tone.isArray(notes)) {
	            for (var i = 0; i < notes.length; i++) {
	                var d = duration[Math.min(i, duration.length - 1)];
	                this.triggerRelease(notes[i], time + this.toSeconds(d));
	            }
	        } else {
	            this.triggerRelease(notes, time + this.toSeconds(duration));
	        }
	        return this;
	    };
	    /**
		 *  Trigger the release of the note. Unlike monophonic instruments, 
		 *  a note (or array of notes) needs to be passed in as the first argument.
		 *  @param  {Frequency|Array} notes The notes to play. Accepts a single
		 *                                  Frequency or an array of frequencies.
		 *  @param  {Time} [time=now]  When the release will be triggered. 
		 *  @returns {Tone.PolySynth} this
		 *  @example
		 * poly.triggerRelease(["Ab3", "C4", "F5"], "+2n");
		 */
	    Tone.PolySynth.prototype.triggerRelease = function (notes, time) {
	        if (!Array.isArray(notes)) {
	            notes = [notes];
	        }
	        time = this.toSeconds(time);
	        for (var i = 0; i < notes.length; i++) {
	            //get the voice
	            var stringified = JSON.stringify(notes[i]);
	            for (var v = 0; v < this._triggers.length; v++) {
	                var desc = this._triggers[v];
	                if (desc.note === stringified && desc.release > time) {
	                    desc.voice.triggerRelease(time);
	                    desc.release = time;
	                }
	            }
	        }
	        return this;
	    };
	    /**
		 *  Set a member/attribute of the voices. 
		 *  @param {Object|string} params
		 *  @param {number=} value
		 *  @param {Time=} rampTime
		 *  @returns {Tone.PolySynth} this
		 *  @example
		 * poly.set({
		 * 	"filter" : {
		 * 		"type" : "highpass"
		 * 	},
		 * 	"envelope" : {
		 * 		"attack" : 0.25
		 * 	}
		 * });
		 */
	    Tone.PolySynth.prototype.set = function (params, value, rampTime) {
	        for (var i = 0; i < this.voices.length; i++) {
	            this.voices[i].set(params, value, rampTime);
	        }
	        return this;
	    };
	    /**
		 *  Get the synth's attributes. Given no arguments get
		 *  will return all available object properties and their corresponding
		 *  values. Pass in a single attribute to retrieve or an array
		 *  of attributes. The attribute strings can also include a "."
		 *  to access deeper properties.
		 *  @param {Array=} params the parameters to get, otherwise will return 
		 *  					   all available.
		 */
	    Tone.PolySynth.prototype.get = function (params) {
	        return this.voices[0].get(params);
	    };
	    /**
		 *  Trigger the release portion of all the currently active voices.
		 *  @param {Time} [time=now] When the notes should be released.
		 *  @return {Tone.PolySynth} this
		 */
	    Tone.PolySynth.prototype.releaseAll = function (time) {
	        time = this.toSeconds(time);
	        for (var i = 0; i < this._triggers.length; i++) {
	            var desc = this._triggers[i];
	            if (desc.release > time) {
	                desc.release = time;
	                desc.voice.triggerRelease(time);
	            }
	        }
	        return this;
	    };
	    /**
		 *  Clean up.
		 *  @returns {Tone.PolySynth} this
		 */
	    Tone.PolySynth.prototype.dispose = function () {
	        Tone.Instrument.prototype.dispose.call(this);
	        for (var i = 0; i < this.voices.length; i++) {
	            this.voices[i].dispose();
	            this.voices[i] = null;
	        }
	        this._writable('detune');
	        this.detune.dispose();
	        this.detune = null;
	        this.voices = null;
	        this._triggers = null;
	        return this;
	    };
	    /**
		 *  The maximum number of notes that can be allocated 
		 *  to a polysynth. 
		 *  @type  {Number}
		 *  @static
		 */
	    Tone.PolySynth.MAX_POLYPHONY = 20;
	    return Tone.PolySynth;
	});
	Module(function (Tone) {
	    /**
		 * @class Automatically interpolates between a set of pitched samples. Pass in an object which maps the note's pitch or midi value to the url, then you can trigger the attack and release of that note like other instruments. By automatically repitching the samples, it is possible to play pitches which were not explicitly included which can save loading time.
		 *        For sample or buffer playback where repitching is not necessary, use [Tone.Player](https://tonejs.github.io/docs/Player).
		 * @param {Object} samples An object of samples mapping either Midi
		 *                         Note Numbers or Scientific Pitch Notation
		 *                         to the url of that sample.
		 * @example
		 * var sampler = new Tone.Sampler({
		 * 	"C3" : "path/to/C3.mp3",
		 * 	"D#3" : "path/to/Dsharp3.mp3",
		 * 	"F#3" : "path/to/Fsharp3.mp3",
		 * 	"A3" : "path/to/A3.mp3",
		 * }, function(){
		 * 	//sampler will repitch the closest sample
		 * 	sampler.triggerAttack("D3")
		 * })
		 * @extends {Tone.Instrument}
		 */
	    Tone.Sampler = function (urls) {
	        // shift arguments over one. Those are the remainder of the options
	        var args = Array.prototype.slice.call(arguments);
	        args.shift();
	        var options = Tone.defaults(args, [
	            'onload',
	            'baseUrl'
	        ], Tone.Sampler);
	        Tone.Instrument.call(this, options);
	        var urlMap = {};
	        for (var note in urls) {
	            if (Tone.isNote(note)) {
	                //convert the note name to MIDI
	                var mid = Tone.Frequency(note).toMidi();
	                urlMap[mid] = urls[note];
	            } else if (!isNaN(parseFloat(note))) {
	                //otherwise if it's numbers assume it's midi
	                urlMap[note] = urls[note];
	            } else {
	                throw new Error('Tone.Sampler: url keys must be the note\'s pitch');
	            }
	        }
	        /**
			 * The stored and loaded buffers
			 * @type {Tone.Buffers}
			 * @private
			 */
	        this._buffers = new Tone.Buffers(urlMap, options.onload, options.baseUrl);
	        /**
			 * The object of all currently playing BufferSources
			 * @type {Object}
			 * @private
			 */
	        this._activeSources = {};
	        /**
			 * The envelope applied to the beginning of the sample.
			 * @type {Time}
			 */
	        this.attack = options.attack;
	        /**
			 * The envelope applied to the end of the envelope.
			 * @type {Time}
			 */
	        this.release = options.release;
	    };
	    Tone.extend(Tone.Sampler, Tone.Instrument);
	    /**
		 * The defaults
		 * @const
		 * @type {Object}
		 */
	    Tone.Sampler.defaults = {
	        attack: 0,
	        release: 0.1,
	        onload: Tone.noOp,
	        baseUrl: ''
	    };
	    /**
		 * Returns the difference in steps between the given midi note at the closets sample.
		 * @param  {Midi} midi
		 * @return {Interval}
		 * @private
		 */
	    Tone.Sampler.prototype._findClosest = function (midi) {
	        var MAX_INTERVAL = 24;
	        var interval = 0;
	        while (interval < MAX_INTERVAL) {
	            // check above and below
	            if (this._buffers.has(midi + interval)) {
	                return -interval;
	            } else if (this._buffers.has(midi - interval)) {
	                return interval;
	            }
	            interval++;
	        }
	        return null;
	    };
	    /**
		 * @param  {Frequency} note     The note to play
		 * @param  {Time=} time     When to play the note
		 * @param  {NormalRange=} velocity The velocity to play the sample back.
		 * @return {Tone.Sampler}          this
		 */
	    Tone.Sampler.prototype.triggerAttack = function (note, time, velocity) {
	        var midi = Tone.Frequency(note).toMidi();
	        // find the closest note pitch
	        var difference = this._findClosest(midi);
	        if (difference !== null) {
	            var closestNote = midi - difference;
	            var buffer = this._buffers.get(closestNote);
	            // play that note
	            var source = new Tone.BufferSource({
	                'buffer': buffer,
	                'playbackRate': Tone.intervalToFrequencyRatio(difference),
	                'fadeIn': this.attack,
	                'fadeOut': this.release
	            }).connect(this.output);
	            source.start(time, 0, buffer.duration, velocity);
	            // add it to the active sources
	            if (!Tone.isArray(this._activeSources[midi])) {
	                this._activeSources[midi] = [];
	            }
	            this._activeSources[midi].push({
	                note: midi,
	                source: source
	            });
	        }
	        return this;
	    };
	    /**
		 * @param  {Frequency} note     The note to release.
		 * @param  {Time=} time     	When to release the note.
		 * @return {Tone.Sampler}	this
		 */
	    Tone.Sampler.prototype.triggerRelease = function (note, time) {
	        var midi = Tone.Frequency(note).toMidi();
	        // find the note
	        if (this._activeSources[midi] && this._activeSources[midi].length) {
	            var source = this._activeSources[midi].shift().source;
	            time = this.toSeconds(time);
	            source.stop(time + this.release, this.release);
	        }
	    };
	    /**
		 * Invoke the attack phase, then after the duration, invoke the release.
		 * @param  {Frequency} note     The note to play
		 * @param  {Time} duration The time the note should be held
		 * @param  {Time=} time     When to start the attack
		 * @param  {NormalRange} [velocity=1] The velocity of the attack
		 * @return {Tone.Sampler}          this
		 */
	    Tone.Sampler.prototype.triggerAttackRelease = function (note, duration, time, velocity) {
	        time = this.toSeconds(time);
	        duration = this.toSeconds(duration);
	        this.triggerAttack(note, time, velocity);
	        this.triggerRelease(note, time + duration);
	        return this;
	    };
	    /**
		 *  Add a note to the sampler.
		 *  @param  {Note|Midi}   note      The buffer's pitch.
		 *  @param  {String|Tone.Buffer|Audiobuffer}  url  Either the url of the bufer,
		 *                                                 or a buffer which will be added
		 *                                                 with the given name.
		 *  @param  {Function=}  callback  The callback to invoke
		 *                                 when the url is loaded.
		 */
	    Tone.Sampler.prototype.add = function (note, url, callback) {
	        if (Tone.isNote(note)) {
	            //convert the note name to MIDI
	            var mid = Tone.Frequency(note).toMidi();
	            this._buffers.add(mid, url, callback);
	        } else if (!isNaN(parseFloat(note))) {
	            //otherwise if it's numbers assume it's midi
	            this._buffers.add(note, url, callback);
	        } else {
	            throw new Error('Tone.Sampler: note must be the note\'s pitch. Instead got ' + note);
	        }
	    };
	    /**
		 * If the buffers are loaded or not
		 * @memberOf Tone.Sampler#
		 * @type {Boolean}
		 * @name loaded
		 * @readOnly
		 */
	    Object.defineProperty(Tone.Sampler.prototype, 'loaded', {
	        get: function () {
	            return this._buffers.loaded;
	        }
	    });
	    /**
		 * Clean up
		 * @return {Tone.Sampler} this
		 */
	    Tone.Sampler.prototype.dispose = function () {
	        Tone.Instrument.prototype.dispose.call(this);
	        this._buffers.dispose();
	        this._buffers = null;
	        for (var midi in this._activeSources) {
	            this._activeSources[midi].forEach(function (event) {
	                event.source.dispose();
	            });
	        }
	        this._activeSources = null;
	        return this;
	    };
	    return Tone.Sampler;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Maps a NormalRange [0, 1] to an AudioRange [-1, 1]. 
		 *         See also Tone.AudioToGain. 
		 *
		 *  @extends {Tone.SignalBase}
		 *  @constructor
		 *  @example
		 * var g2a = new Tone.GainToAudio();
		 */
	    Tone.GainToAudio = function () {
	        Tone.SignalBase.call(this);
	        /**
			 *  @type {WaveShaperNode}
			 *  @private
			 */
	        this._norm = this.input = this.output = new Tone.WaveShaper(function (x) {
	            return Math.abs(x) * 2 - 1;
	        });
	    };
	    Tone.extend(Tone.GainToAudio, Tone.SignalBase);
	    /**
		 *  clean up
		 *  @returns {Tone.GainToAudio} this
		 */
	    Tone.GainToAudio.prototype.dispose = function () {
	        Tone.SignalBase.prototype.dispose.call(this);
	        this._norm.dispose();
	        this._norm = null;
	        return this;
	    };
	    return Tone.GainToAudio;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Normalize takes an input min and max and maps it linearly to NormalRange [0,1]
		 *
		 *  @extends {Tone.SignalBase}
		 *  @constructor
		 *  @param {number} inputMin the min input value
		 *  @param {number} inputMax the max input value
		 *  @example
		 * var norm = new Tone.Normalize(2, 4);
		 * var sig = new Tone.Signal(3).connect(norm);
		 * //output of norm is 0.5. 
		 */
	    Tone.Normalize = function (inputMin, inputMax) {
	        Tone.SignalBase.call(this);
	        /**
			 *  the min input value
			 *  @type {number}
			 *  @private
			 */
	        this._inputMin = Tone.defaultArg(inputMin, 0);
	        /**
			 *  the max input value
			 *  @type {number}
			 *  @private
			 */
	        this._inputMax = Tone.defaultArg(inputMax, 1);
	        /**
			 *  subtract the min from the input
			 *  @type {Tone.Add}
			 *  @private
			 */
	        this._sub = this.input = new Tone.Add(0);
	        /**
			 *  divide by the difference between the input and output
			 *  @type {Tone.Multiply}
			 *  @private
			 */
	        this._div = this.output = new Tone.Multiply(1);
	        this._sub.connect(this._div);
	        this._setRange();
	    };
	    Tone.extend(Tone.Normalize, Tone.SignalBase);
	    /**
		 * The minimum value the input signal will reach.
		 * @memberOf Tone.Normalize#
		 * @type {number}
		 * @name min
		 */
	    Object.defineProperty(Tone.Normalize.prototype, 'min', {
	        get: function () {
	            return this._inputMin;
	        },
	        set: function (min) {
	            this._inputMin = min;
	            this._setRange();
	        }
	    });
	    /**
		 * The maximum value the input signal will reach.
		 * @memberOf Tone.Normalize#
		 * @type {number}
		 * @name max
		 */
	    Object.defineProperty(Tone.Normalize.prototype, 'max', {
	        get: function () {
	            return this._inputMax;
	        },
	        set: function (max) {
	            this._inputMax = max;
	            this._setRange();
	        }
	    });
	    /**
		 *  set the values
		 *  @private
		 */
	    Tone.Normalize.prototype._setRange = function () {
	        this._sub.value = -this._inputMin;
	        this._div.value = 1 / (this._inputMax - this._inputMin);
	    };
	    /**
		 *  clean up
		 *  @returns {Tone.Normalize} this
		 */
	    Tone.Normalize.prototype.dispose = function () {
	        Tone.SignalBase.prototype.dispose.call(this);
	        this._sub.dispose();
	        this._sub = null;
	        this._div.dispose();
	        this._div = null;
	        return this;
	    };
	    return Tone.Normalize;
	});
	Module(function (Tone) {
	    /**
		 * @class Tone.TransportTimelineSignal extends Tone.TimelineSignal, but adds the ability to synchronize the signal to the signal to the Tone.Transport
		 * @extends {Tone.TimelineSignal}
		 */
	    Tone.TransportTimelineSignal = function () {
	        Tone.TimelineSignal.apply(this, arguments);
	        /**
			 * The real signal output
			 * @type {Tone.Signal}
			 * @private
			 */
	        this.output = this._outputSig = new Tone.Signal(this._initial);
	        /**
			 * Keep track of the last value. (small optimization)
			 * @private
			 * @type {Number}
			 */
	        this._lastVal = this.value;
	        /**
			 * The event id of the tick update loop
			 * @private
			 * @type {Number}
			 */
	        this._synced = Tone.Transport.scheduleRepeat(this._onTick.bind(this), '1i');
	        /**
			 * A bound version of the anchor value methods
			 * @type {Function}
			 * @private
			 */
	        this._bindAnchorValue = this._anchorValue.bind(this);
	        Tone.Transport.on('start stop pause', this._bindAnchorValue);
	        this._events.memory = Infinity;
	    };
	    Tone.extend(Tone.TransportTimelineSignal, Tone.TimelineSignal);
	    /**
		 * Callback which is invoked every tick.
		 * @private
		 * @param  {Number} time
		 * @return {Tone.TransportTimelineSignal}      this
		 */
	    Tone.TransportTimelineSignal.prototype._onTick = function (time) {
	        var val = this.getValueAtTime(Tone.Transport.seconds);
	        if (this._lastVal !== val) {
	            this._lastVal = val;
	            //approximate ramp curves with linear ramps
	            this._outputSig.linearRampToValueAtTime(val, time);
	        }
	    };
	    /**
		 * Anchor the value at the start and stop of the Transport
		 * @param  {Number} time The time of the event
		 * @return {Tone.TransportTimelineSignal}      this
		 * @private
		 */
	    Tone.TransportTimelineSignal.prototype._anchorValue = function (time) {
	        var val = this.getValueAtTime(Tone.Transport.ticks);
	        this._lastVal = val;
	        this._outputSig.cancelScheduledValues(time);
	        this._outputSig.setValueAtTime(val, time);
	        return this;
	    };
	    /**
		 *  Get the scheduled value at the given time. This will
		 *  return the unconverted (raw) value.
		 *  @param  {TransportTime}  time  The time in seconds.
		 *  @return  {Number}  The scheduled value at the given time.
		 */
	    Tone.TransportTimelineSignal.prototype.getValueAtTime = function (time) {
	        time = this.toTicks(time);
	        return Tone.TimelineSignal.prototype.getValueAtTime.call(this, time);
	    };
	    /**
		 * Set the output of the signal at the given time
		 * @param  {Number} value The value to change to at the given time
		 * @param  {TransportTime} time  The time to change the signal
		 * @return {Tone.TransportTimelineSignal}       this
		 */
	    Tone.TransportTimelineSignal.prototype.setValueAtTime = function (value, time) {
	        time = this.toTicks(time);
	        Tone.TimelineSignal.prototype.setValueAtTime.call(this, value, time);
	        return this;
	    };
	    /**
		 * Linear ramp to the given value from the previous scheduled point to the given value
		 * @param  {Number} value The value to change to at the given time
		 * @param  {TransportTime} time  The time to change the signal
		 * @return {Tone.TransportTimelineSignal}       this
		 */
	    Tone.TransportTimelineSignal.prototype.linearRampToValueAtTime = function (value, time) {
	        time = this.toTicks(time);
	        Tone.TimelineSignal.prototype.linearRampToValueAtTime.call(this, value, time);
	        return this;
	    };
	    /**
		 * Exponential ramp to the given value from the previous scheduled point to the given value
		 * @param  {Number} value The value to change to at the given time
		 * @param  {TransportTime} time  The time to change the signal
		 * @return {Tone.TransportTimelineSignal}       this
		 */
	    Tone.TransportTimelineSignal.prototype.exponentialRampToValueAtTime = function (value, time) {
	        time = this.toTicks(time);
	        Tone.TimelineSignal.prototype.exponentialRampToValueAtTime.call(this, value, time);
	        return this;
	    };
	    /**
		 *  Start exponentially approaching the target value at the given time with
		 *  a rate having the given time constant.
		 *  @param {number} value
		 *  @param {TransportTime} startTime
		 *  @param {number} timeConstant
		 * @return {Tone.TransportTimelineSignal}       this
		 */
	    Tone.TransportTimelineSignal.prototype.setTargetAtTime = function (value, startTime, timeConstant) {
	        startTime = this.toTicks(startTime);
	        Tone.TimelineSignal.prototype.setTargetAtTime.call(this, value, startTime, timeConstant);
	        return this;
	    };
	    /**
		 *  Cancels all scheduled parameter changes with times greater than or
		 *  equal to startTime.
		 *  @param  {TransportTime} startTime
		 *  @returns {Tone.Param} this
		 */
	    Tone.TransportTimelineSignal.prototype.cancelScheduledValues = function (startTime) {
	        startTime = this.toTicks(startTime);
	        Tone.TimelineSignal.prototype.cancelScheduledValues.call(this, startTime);
	        return this;
	    };
	    /**
		 *  Set an array of arbitrary values starting at the given time for the given duration.
		 *  @param {Float32Array} values
		 *  @param {Time} startTime
		 *  @param {Time} duration
		 *  @param {NormalRange} [scaling=1] If the values in the curve should be scaled by some value
		 *  @returns {Tone.TimelineSignal} this
		 */
	    Tone.TransportTimelineSignal.prototype.setValueCurveAtTime = function (values, startTime, duration, scaling) {
	        startTime = this.toTicks(startTime);
	        duration = this.toTicks(duration);
	        Tone.TimelineSignal.prototype.setValueCurveAtTime.call(this, values, startTime, duration, scaling);
	        return this;
	    };
	    /**
		 * Dispose and disconnect
		 * @return {Tone.TransportTimelineSignal} this
		 */
	    Tone.TransportTimelineSignal.prototype.dispose = function () {
	        Tone.Transport.clear(this._synced);
	        Tone.Transport.off('start stop pause', this._syncedCallback);
	        this._events.cancel(0);
	        Tone.TimelineSignal.prototype.dispose.call(this);
	        this._outputSig.dispose();
	        this._outputSig = null;
	    };
	    return Tone.TransportTimelineSignal;
	});
	Module(function (Tone) {
	    /**
		 *  @class Tone.MultiPlayer is well suited for one-shots, multi-sampled instruments
		 *         or any time you need to play a bunch of audio buffers. 
		 *
		 *  @deprecated Use [Tone.Players](Players) instead.
		 *  @param  {Object|Array|Tone.Buffers}  buffers  The buffers which are available
		 *                                                to the MultiPlayer
		 *  @param {Function} onload The callback to invoke when all of the buffers are loaded.
		 *  @extends {Tone}
		 *  @example
		 * var multiPlayer = new MultiPlayer({
		 * 	"kick" : "path/to/kick.mp3",
		 * 	"snare" : "path/to/snare.mp3",
		 * }, function(){
		 * 	multiPlayer.start("kick");
		 * });
		 *  @example
		 * //can also store the values in an array
		 * var multiPlayer = new MultiPlayer(["path/to/kick.mp3", "path/to/snare.mp3"], 
		 * function(){
		 * 	//if an array is passed in, the samples are referenced to by index
		 * 	multiPlayer.start(1);
		 * });
		 */
	    Tone.MultiPlayer = function (urls) {
	        console.warn('Tone.MultiPlayer is deprecated. Use Tone.Players instead.');
	        //remove the urls from the options
	        if (arguments.length === 1 && !Tone.isUndef(arguments[0]) && !arguments[0].hasOwnProperty('urls')) {
	            urls = { 'urls': urls };
	        }
	        var options = Tone.defaults(arguments, [
	            'urls',
	            'onload'
	        ], Tone.MultiPlayer);
	        Tone.Source.call(this, options);
	        if (options.urls instanceof Tone.Buffers) {
	            /**
				 *  All the buffers belonging to the player.
				 *  @type  {Tone.Buffers}
				 */
	            this.buffers = options.urls;
	        } else {
	            this.buffers = new Tone.Buffers(options.urls, options.onload);
	        }
	        /**
			 *  Keeps track of the currently playing sources.
			 *  @type  {Object}
			 *  @private
			 */
	        this._activeSources = {};
	        /**
			 *  The fade in envelope which is applied
			 *  to the beginning of the BufferSource
			 *  @type  {Time}
			 */
	        this.fadeIn = options.fadeIn;
	        /**
			 *  The fade out envelope which is applied
			 *  to the end of the BufferSource
			 *  @type  {Time}
			 */
	        this.fadeOut = options.fadeOut;
	    };
	    Tone.extend(Tone.MultiPlayer, Tone.Source);
	    /**
		 *  The defaults
		 *  @type  {Object}
		 */
	    Tone.MultiPlayer.defaults = {
	        'onload': Tone.noOp,
	        'fadeIn': 0,
	        'fadeOut': 0
	    };
	    /**
		 * Make the source from the buffername
		 * @param  {String} bufferName
		 * @return {Tone.BufferSource}
		 * @private
		 */
	    Tone.MultiPlayer.prototype._makeSource = function (bufferName) {
	        var buffer;
	        if (Tone.isString(bufferName) || Tone.isNumber(bufferName)) {
	            buffer = this.buffers.get(bufferName).get();
	        } else if (bufferName instanceof Tone.Buffer) {
	            buffer = bufferName.get();
	        } else if (bufferName instanceof AudioBuffer) {
	            buffer = bufferName;
	        }
	        var source = new Tone.BufferSource(buffer).connect(this.output);
	        if (!this._activeSources.hasOwnProperty(bufferName)) {
	            this._activeSources[bufferName] = [];
	        }
	        this._activeSources[bufferName].push(source);
	        return source;
	    };
	    /**
		 *  Start a buffer by name. The `start` method allows a number of options
		 *  to be passed in such as offset, interval, and gain. This is good for multi-sampled 
		 *  instruments and sound sprites where samples are repitched played back at different velocities.
		 *  @param  {String}  bufferName    The name of the buffer to start.
		 *  @param  {Time}  time      When to start the buffer.
		 *  @param  {Time}  [offset=0]    The offset into the buffer to play from.
		 *  @param  {Time=}  duration   How long to play the buffer for.
		 *  @param  {Interval}  [pitch=0]  The interval to repitch the buffer.
		 *  @param  {Gain}  [gain=1]      The gain to play the sample at.
		 *  @return  {Tone.MultiPlayer}  this
		 */
	    Tone.MultiPlayer.prototype.start = function (bufferName, time, offset, duration, pitch, gain) {
	        time = this.toSeconds(time);
	        var source = this._makeSource(bufferName);
	        source.start(time, offset, duration, Tone.defaultArg(gain, 1), this.fadeIn);
	        if (duration) {
	            source.stop(time + this.toSeconds(duration), this.fadeOut);
	        }
	        pitch = Tone.defaultArg(pitch, 0);
	        source.playbackRate.value = Tone.intervalToFrequencyRatio(pitch);
	        return this;
	    };
	    /**
		 *  Start a looping buffer by name. Similar to `start`, but the buffer
		 *  is looped instead of played straight through. Can still be stopped with `stop`. 
		 *  @param  {String}  bufferName    The name of the buffer to start.
		 *  @param  {Time}  time      When to start the buffer.
		 *  @param  {Time}  [offset=0]    The offset into the buffer to play from.
		 *  @param  {Time=}  loopStart   The start of the loop.
		 *  @param  {Time=}  loopEnd	The end of the loop.
		 *  @param  {Interval}  [pitch=0]  The interval to repitch the buffer.
		 *  @param  {Gain}  [gain=1]      The gain to play the sample at.
		 *  @return  {Tone.MultiPlayer}  this
		 */
	    Tone.MultiPlayer.prototype.startLoop = function (bufferName, time, offset, loopStart, loopEnd, pitch, gain) {
	        time = this.toSeconds(time);
	        var source = this._makeSource(bufferName);
	        source.loop = true;
	        source.loopStart = this.toSeconds(Tone.defaultArg(loopStart, 0));
	        source.loopEnd = this.toSeconds(Tone.defaultArg(loopEnd, 0));
	        source.start(time, offset, undefined, Tone.defaultArg(gain, 1), this.fadeIn);
	        pitch = Tone.defaultArg(pitch, 0);
	        source.playbackRate.value = Tone.intervalToFrequencyRatio(pitch);
	        return this;
	    };
	    /**
		 *  Stop the first played instance of the buffer name.
		 *  @param  {String}  bufferName  The buffer to stop.
		 *  @param  {Time=}  time    When to stop the buffer
		 *  @return  {Tone.MultiPlayer}  this
		 */
	    Tone.MultiPlayer.prototype.stop = function (bufferName, time) {
	        if (this._activeSources[bufferName] && this._activeSources[bufferName].length) {
	            time = this.toSeconds(time);
	            this._activeSources[bufferName].shift().stop(time, this.fadeOut);
	        } else {
	            throw new Error('Tone.MultiPlayer: cannot stop a buffer that hasn\'t been started or is already stopped');
	        }
	        return this;
	    };
	    /**
		 *  Stop all currently playing buffers at the given time.
		 *  @param  {Time=}  time  When to stop the buffers.
		 *  @return  {Tone.MultiPlayer}  this
		 */
	    Tone.MultiPlayer.prototype.stopAll = function (time) {
	        time = this.toSeconds(time);
	        for (var bufferName in this._activeSources) {
	            var sources = this._activeSources[bufferName];
	            for (var i = 0; i < sources.length; i++) {
	                sources[i].stop(time);
	            }
	        }
	        return this;
	    };
	    /**
		 *  Add another buffer to the available buffers.
		 *  @param {String} name The name to that the buffer is refered
		 *                       to in start/stop methods. 
		 *  @param {String|Tone.Buffer} url The url of the buffer to load
		 *                                  or the buffer.
		 *  @param {Function} callback The function to invoke after the buffer is loaded.
		 */
	    Tone.MultiPlayer.prototype.add = function (name, url, callback) {
	        this.buffers.add(name, url, callback);
	        return this;
	    };
	    /**
		 *  Returns the playback state of the source. "started"
		 *  if there are any buffers playing. "stopped" otherwise.
		 *  @type {Tone.State}
		 *  @readOnly
		 *  @memberOf Tone.MultiPlayer#
		 *  @name state
		 */
	    Object.defineProperty(Tone.MultiPlayer.prototype, 'state', {
	        get: function () {
	            return this._activeSources.length > 0 ? Tone.State.Started : Tone.State.Stopped;
	        }
	    });
	    /**
		 * Mute the output. 
		 * @memberOf Tone.MultiPlayer#
		 * @type {boolean}
		 * @name mute
		 * @example
		 * //mute the output
		 * source.mute = true;
		 */
	    Object.defineProperty(Tone.MultiPlayer.prototype, 'mute', {
	        get: function () {
	            return this._volume.mute;
	        },
	        set: function (mute) {
	            this._volume.mute = mute;
	        }
	    });
	    /**
		 *  Clean up.
		 *  @return  {Tone.MultiPlayer}  this
		 */
	    Tone.MultiPlayer.prototype.dispose = function () {
	        Tone.Source.prototype.dispose.call(this);
	        for (var bufferName in this._activeSources) {
	            this._activeSources[bufferName].forEach(function (source) {
	                source.dispose();
	            });
	        }
	        this.buffers.dispose();
	        this.buffers = null;
	        this._activeSources = null;
	        return this;
	    };
	    return Tone.MultiPlayer;
	});
	Module(function (Tone) {
	    /**
		 * @class Tone.GrainPlayer implements [granular synthesis](https://en.wikipedia.org/wiki/Granular_synthesis).
		 *        Granular Synthesis enables you to adjust pitch and playback rate independently. The grainSize is the
		 *        amount of time each small chunk of audio is played for and the overlap is the
		 *        amount of crossfading transition time between successive grains.
		 * @extends {Tone.Source}
		 * @param {String|Tone.Buffer} url	The url to load, or the Tone.Buffer to play.
		 * @param {Function=} callback The callback to invoke after the url is loaded.
		 */
	    Tone.GrainPlayer = function () {
	        var options = Tone.defaults(arguments, [
	            'url',
	            'onload'
	        ], Tone.GrainPlayer);
	        Tone.Source.call(this, options);
	        /**
			 *  The audio buffer belonging to the player.
			 *  @type  {Tone.Buffer}
			 */
	        this.buffer = new Tone.Buffer(options.url, options.onload);
	        /**
			 *  Create a repeating tick to schedule
			 *  the grains.
			 *  @type  {Tone.Clock}
			 *  @private
			 */
	        this._clock = new Tone.Clock(this._tick.bind(this), options.grainSize);
	        /**
			 *  @type  {Number}
			 *  @private
			 */
	        this._loopStart = 0;
	        /**
			 *  @type  {Number}
			 *  @private
			 */
	        this._loopEnd = 0;
	        /**
			 * All of the currently playing BufferSources
			 * @type {Array}
			 * @private
			 */
	        this._activeSources = [];
	        /**
			 *  @type  {Number}
			 *  @private
			 */
	        this._playbackRate = options.playbackRate;
	        /**
			 *  @type  {Number}
			 *  @private
			 */
	        this._grainSize = options.grainSize;
	        /**
			 *  @private
			 *  @type {Number}
			 */
	        this._overlap = options.overlap;
	        /**
			 *  Adjust the pitch independently of the playbackRate.
			 *  @type  {Cents}
			 */
	        this.detune = options.detune;
	        //setup
	        this.overlap = options.overlap;
	        this.loop = options.loop;
	        this.playbackRate = options.playbackRate;
	        this.grainSize = options.grainSize;
	        this.loopStart = options.loopStart;
	        this.loopEnd = options.loopEnd;
	        this.reverse = options.reverse;
	        this._clock.on('stop', this._onstop.bind(this));
	    };
	    Tone.extend(Tone.GrainPlayer, Tone.Source);
	    /**
		 *  the default parameters
		 *  @static
		 *  @const
		 *  @type {Object}
		 */
	    Tone.GrainPlayer.defaults = {
	        'onload': Tone.noOp,
	        'overlap': 0.1,
	        'grainSize': 0.2,
	        'playbackRate': 1,
	        'detune': 0,
	        'loop': false,
	        'loopStart': 0,
	        'loopEnd': 0,
	        'reverse': false
	    };
	    /**
		 *  Play the buffer at the given startTime. Optionally add an offset
		 *  and/or duration which will play the buffer from a position
		 *  within the buffer for the given duration.
		 *
		 *  @param  {Time} [startTime=now] When the player should start.
		 *  @param  {Time} [offset=0] The offset from the beginning of the sample
		 *                                 to start at.
		 *  @param  {Time=} duration How long the sample should play. If no duration
		 *                                is given, it will default to the full length
		 *                                of the sample (minus any offset)
		 *  @returns {Tone.GrainPlayer} this
		 *  @memberOf Tone.GrainPlayer#
		 *  @method start
		 *  @name start
		 */
	    /**
		 *  Internal start method
		 *  @param {Time} time
		 *  @param {Time} offset
		 *  @private
		 */
	    Tone.GrainPlayer.prototype._start = function (time, offset, duration) {
	        offset = Tone.defaultArg(offset, 0);
	        offset = this.toSeconds(offset);
	        time = this.toSeconds(time);
	        this._offset = offset;
	        this._clock.start(time);
	        if (duration) {
	            this.stop(time + this.toSeconds(duration));
	        }
	    };
	    /**
		 *  Internal start method
		 *  @param {Time} time
		 *  @private
		 */
	    Tone.GrainPlayer.prototype._stop = function (time) {
	        this._clock.stop(time);
	    };
	    /**
		 * Invoked when the clock is stopped
		 * @param  {Number} time
		 * @private
		 */
	    Tone.GrainPlayer.prototype._onstop = function (time) {
	        //stop the players
	        this._activeSources.forEach(function (source) {
	            source.stop(time, 0);
	        });
	    };
	    /**
		 *  Invoked on each clock tick. scheduled a new
		 *  grain at this time.
		 *  @param  {Time}  time
		 *  @private
		 */
	    Tone.GrainPlayer.prototype._tick = function (time) {
	        var fadeIn = this._offset < this._overlap ? 0 : this._overlap;
	        var source = new Tone.BufferSource({
	            'buffer': this.buffer,
	            'fadeIn': fadeIn,
	            'fadeOut': this._overlap,
	            'loop': this.loop,
	            'loopStart': this._loopStart,
	            'loopEnd': this._loopEnd,
	            'playbackRate': Tone.intervalToFrequencyRatio(this.detune / 100)
	        }).connect(this.output);
	        source.start(time, this._offset);
	        this._offset += this.grainSize;
	        source.stop(time + this.grainSize);
	        //add it to the active sources
	        this._activeSources.push(source);
	        //remove it when it's done
	        source.onended = function () {
	            var index = this._activeSources.indexOf(source);
	            if (index !== -1) {
	                this._activeSources.splice(index, 1);
	            }
	        }.bind(this);
	    };
	    /**
		 *  Jump to a specific time and play it.
		 *  @param  {Time}  offset  The offset to jump to.
		 *  @param {Time=} time When to make the jump.
		 *  @return  {Tone.GrainPlayer}  this
		 */
	    Tone.GrainPlayer.prototype.seek = function (offset, time) {
	        this._offset = this.toSeconds(offset);
	        this._tick(this.toSeconds(time));
	        return this;
	    };
	    /**
		 * The playback rate of the sample
		 * @memberOf Tone.GrainPlayer#
		 * @type {Positive}
		 * @name playbackRate
		 */
	    Object.defineProperty(Tone.GrainPlayer.prototype, 'playbackRate', {
	        get: function () {
	            return this._playbackRate;
	        },
	        set: function (rate) {
	            this._playbackRate = rate;
	            this.grainSize = this._grainSize;
	        }
	    });
	    /**
		 * The loop start time.
		 * @memberOf Tone.GrainPlayer#
		 * @type {Time}
		 * @name loopStart
		 */
	    Object.defineProperty(Tone.GrainPlayer.prototype, 'loopStart', {
	        get: function () {
	            return this._loopStart;
	        },
	        set: function (time) {
	            this._loopStart = this.toSeconds(time);
	        }
	    });
	    /**
		 * The loop end time.
		 * @memberOf Tone.GrainPlayer#
		 * @type {Time}
		 * @name loopEnd
		 */
	    Object.defineProperty(Tone.GrainPlayer.prototype, 'loopEnd', {
	        get: function () {
	            return this._loopEnd;
	        },
	        set: function (time) {
	            this._loopEnd = this.toSeconds(time);
	        }
	    });
	    /**
		 * The direction the buffer should play in
		 * @memberOf Tone.GrainPlayer#
		 * @type {boolean}
		 * @name reverse
		 */
	    Object.defineProperty(Tone.GrainPlayer.prototype, 'reverse', {
	        get: function () {
	            return this.buffer.reverse;
	        },
	        set: function (rev) {
	            this.buffer.reverse = rev;
	        }
	    });
	    /**
		 * The size of each chunk of audio that the
		 * buffer is chopped into and played back at.
		 * @memberOf Tone.GrainPlayer#
		 * @type {Time}
		 * @name grainSize
		 */
	    Object.defineProperty(Tone.GrainPlayer.prototype, 'grainSize', {
	        get: function () {
	            return this._grainSize;
	        },
	        set: function (size) {
	            this._grainSize = this.toSeconds(size);
	            this._clock.frequency.value = this._playbackRate / this._grainSize;
	        }
	    });
	    /**
		 * This is the duration of the cross-fade between
		 * sucessive grains.
		 * @memberOf Tone.GrainPlayer#
		 * @type {Time}
		 * @name overlap
		 */
	    Object.defineProperty(Tone.GrainPlayer.prototype, 'overlap', {
	        get: function () {
	            return this._overlap;
	        },
	        set: function (time) {
	            this._overlap = this.toSeconds(time);
	        }
	    });
	    /**
		 * Clean up
		 * @return {Tone.GrainPlayer} this
		 */
	    Tone.GrainPlayer.prototype.dispose = function () {
	        Tone.Source.prototype.dispose.call(this);
	        this.buffer.dispose();
	        this.buffer = null;
	        this._clock.dispose();
	        this._clock = null;
	        this._activeSources.forEach(function (source) {
	            source.dispose();
	        });
	        this._activeSources = null;
	        return this;
	    };
	    return Tone.GrainPlayer;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class  Tone.Player is an audio file player with start, loop, and stop functions.
		 *  
		 *  @constructor
		 *  @extends {Tone.Source} 
		 *  @param {string|AudioBuffer} url Either the AudioBuffer or the url from
		 *                                  which to load the AudioBuffer
		 *  @param {function=} onload The function to invoke when the buffer is loaded. 
		 *                            Recommended to use Tone.Buffer.on('load') instead.
		 *  @example
		 * var player = new Tone.Player("./path/to/sample.mp3").toMaster();
		 * //play as soon as the buffer is loaded
		 * player.autostart = true;
		 */
	    Tone.Player = function (url) {
	        var options;
	        if (url instanceof Tone.Buffer) {
	            url = url.get();
	            options = Tone.Player.defaults;
	        } else {
	            options = Tone.defaults(arguments, [
	                'url',
	                'onload'
	            ], Tone.Player);
	        }
	        Tone.Source.call(this, options);
	        /**
			 *  @private
			 *  @type {AudioBufferSourceNode}
			 */
	        this._source = null;
	        /**
			 *  If the file should play as soon
			 *  as the buffer is loaded. 
			 *  @type {boolean}
			 *  @example
			 * //will play as soon as it's loaded
			 * var player = new Tone.Player({
			 * 	"url" : "./path/to/sample.mp3",
			 * 	"autostart" : true,
			 * }).toMaster();
			 */
	        this.autostart = options.autostart;
	        /**
			 *  the buffer
			 *  @private
			 *  @type {Tone.Buffer}
			 */
	        this._buffer = new Tone.Buffer({
	            'url': options.url,
	            'onload': this._onload.bind(this, options.onload),
	            'reverse': options.reverse
	        });
	        if (url instanceof AudioBuffer) {
	            this._buffer.set(url);
	        }
	        /**
			 *  if the buffer should loop once it's over
			 *  @type {boolean}
			 *  @private
			 */
	        this._loop = options.loop;
	        /**
			 *  if 'loop' is true, the loop will start at this position
			 *  @type {Time}
			 *  @private
			 */
	        this._loopStart = options.loopStart;
	        /**
			 *  if 'loop' is true, the loop will end at this position
			 *  @type {Time}
			 *  @private
			 */
	        this._loopEnd = options.loopEnd;
	        /**
			 *  the playback rate
			 *  @private
			 *  @type {number}
			 */
	        this._playbackRate = options.playbackRate;
	        /**
			 *  Enabling retrigger will allow a player to be restarted
			 *  before the the previous 'start' is done playing. Otherwise, 
			 *  successive calls to Tone.Player.start will only start
			 *  the sample if it had played all the way through. 
			 *  @type {boolean}
			 */
	        this.retrigger = options.retrigger;
	        /**
			 *  The fadeIn time of the amplitude envelope.
			 *  @type {Time}
			 */
	        this.fadeIn = options.fadeIn;
	        /**
			 *  The fadeOut time of the amplitude envelope.
			 *  @type {Time}
			 */
	        this.fadeOut = options.fadeOut;
	    };
	    Tone.extend(Tone.Player, Tone.Source);
	    /**
		 *  the default parameters
		 *  @static
		 *  @const
		 *  @type {Object}
		 */
	    Tone.Player.defaults = {
	        'onload': Tone.noOp,
	        'playbackRate': 1,
	        'loop': false,
	        'autostart': false,
	        'loopStart': 0,
	        'loopEnd': 0,
	        'retrigger': false,
	        'reverse': false,
	        'fadeIn': 0,
	        'fadeOut': 0
	    };
	    /**
		 *  Load the audio file as an audio buffer.
		 *  Decodes the audio asynchronously and invokes
		 *  the callback once the audio buffer loads. 
		 *  Note: this does not need to be called if a url
		 *  was passed in to the constructor. Only use this
		 *  if you want to manually load a new url. 
		 * @param {string} url The url of the buffer to load.
		 *                     Filetype support depends on the
		 *                     browser.
		 *  @param  {function=} callback The function to invoke once
		 *                               the sample is loaded.
		 *  @returns {Promise}
		 */
	    Tone.Player.prototype.load = function (url, callback) {
	        return this._buffer.load(url, this._onload.bind(this, callback));
	    };
	    /**
		 * Internal callback when the buffer is loaded.
		 * @private
		 */
	    Tone.Player.prototype._onload = function (callback) {
	        callback = Tone.defaultArg(callback, Tone.noOp);
	        callback(this);
	        if (this.autostart) {
	            this.start();
	        }
	    };
	    /**
		 *  Play the buffer at the given startTime. Optionally add an offset
		 *  and/or duration which will play the buffer from a position
		 *  within the buffer for the given duration. 
		 *  
		 *  @param  {Time} [startTime=now] When the player should start.
		 *  @param  {Time} [offset=0] The offset from the beginning of the sample
		 *                                 to start at. 
		 *  @param  {Time=} duration How long the sample should play. If no duration
		 *                                is given, it will default to the full length 
		 *                                of the sample (minus any offset)
		 *  @returns {Tone.Player} this
		 *  @memberOf Tone.Player#
		 *  @method start
		 *  @name start
		 */
	    /**
		 *  Internal start method
		 *  @private
		 */
	    Tone.Player.prototype._start = function (startTime, offset, duration) {
	        //if it's a loop the default offset is the loopstart point
	        if (this._loop) {
	            offset = Tone.defaultArg(offset, this._loopStart);
	        } else {
	            //otherwise the default offset is 0
	            offset = Tone.defaultArg(offset, 0);
	        }
	        //compute the values in seconds
	        offset = this.toSeconds(offset);
	        duration = Tone.defaultArg(duration, Math.max(this._buffer.duration - offset, 0));
	        duration = this.toSeconds(duration);
	        startTime = this.toSeconds(startTime);
	        // //make the source
	        this._source = new Tone.BufferSource({
	            'buffer': this._buffer,
	            'loop': this._loop,
	            'loopStart': this._loopStart,
	            'loopEnd': this._loopEnd,
	            'playbackRate': this._playbackRate,
	            'fadeIn': this.fadeIn,
	            'fadeOut': this.fadeOut
	        }).connect(this.output);
	        //set the looping properties
	        if (!this._loop && !this._synced) {
	            //if it's not looping, set the state change at the end of the sample
	            this._state.setStateAtTime(Tone.State.Stopped, startTime + duration);
	        }
	        //start it
	        if (this._loop) {
	            this._source.start(startTime, offset);
	        } else {
	            this._source.start(startTime, offset, duration);
	        }
	        return this;
	    };
	    /**
		 *  Stop playback.
		 *  @private
		 *  @param  {Time} [time=now]
		 *  @returns {Tone.Player} this
		 */
	    Tone.Player.prototype._stop = function (time) {
	        if (this._source) {
	            this._source.stop(this.toSeconds(time));
	        }
	        return this;
	    };
	    /**
		 *  Seek to a specific time in the player's buffer. If the 
		 *  source is no longer playing at that time, it will stop.
		 *  If you seek to a time that 
		 *  @param {Time} offset The time to seek to.
		 *  @param {Time=} time The time for the seek event to occur.
		 *  @return {Tone.Player} this
		 *  @example
		 * source.start(0.2);
		 * source.stop(0.4);
		 */
	    Tone.Player.prototype.seek = function (offset, time) {
	        time = this.toSeconds(time);
	        if (this._state.getValueAtTime(time) === Tone.State.Started) {
	            offset = this.toSeconds(offset);
	            // if it's currently playing, stop it
	            this._stop(time);
	            //restart it at the given time
	            this._start(time, offset);
	        }
	        return this;
	    };
	    /**
		 *  Set the loop start and end. Will only loop if loop is 
		 *  set to true. 
		 *  @param {Time} loopStart The loop end time
		 *  @param {Time} loopEnd The loop end time
		 *  @returns {Tone.Player} this
		 *  @example
		 * //loop 0.1 seconds of the file. 
		 * player.setLoopPoints(0.2, 0.3);
		 * player.loop = true;
		 */
	    Tone.Player.prototype.setLoopPoints = function (loopStart, loopEnd) {
	        this.loopStart = loopStart;
	        this.loopEnd = loopEnd;
	        return this;
	    };
	    /**
		 * If loop is true, the loop will start at this position. 
		 * @memberOf Tone.Player#
		 * @type {Time}
		 * @name loopStart
		 */
	    Object.defineProperty(Tone.Player.prototype, 'loopStart', {
	        get: function () {
	            return this._loopStart;
	        },
	        set: function (loopStart) {
	            this._loopStart = loopStart;
	            if (this._source) {
	                this._source.loopStart = this.toSeconds(loopStart);
	            }
	        }
	    });
	    /**
		 * If loop is true, the loop will end at this position.
		 * @memberOf Tone.Player#
		 * @type {Time}
		 * @name loopEnd
		 */
	    Object.defineProperty(Tone.Player.prototype, 'loopEnd', {
	        get: function () {
	            return this._loopEnd;
	        },
	        set: function (loopEnd) {
	            this._loopEnd = loopEnd;
	            if (this._source) {
	                this._source.loopEnd = this.toSeconds(loopEnd);
	            }
	        }
	    });
	    /**
		 * The audio buffer belonging to the player. 
		 * @memberOf Tone.Player#
		 * @type {Tone.Buffer}
		 * @name buffer
		 */
	    Object.defineProperty(Tone.Player.prototype, 'buffer', {
	        get: function () {
	            return this._buffer;
	        },
	        set: function (buffer) {
	            this._buffer.set(buffer);
	        }
	    });
	    /**
		 * If the buffer should loop once it's over. 
		 * @memberOf Tone.Player#
		 * @type {boolean}
		 * @name loop
		 */
	    Object.defineProperty(Tone.Player.prototype, 'loop', {
	        get: function () {
	            return this._loop;
	        },
	        set: function (loop) {
	            this._loop = loop;
	            if (this._source) {
	                this._source.loop = loop;
	            }
	        }
	    });
	    /**
		 * The playback speed. 1 is normal speed. This is not a signal because
		 * Safari and iOS currently don't support playbackRate as a signal.
		 * @memberOf Tone.Player#
		 * @type {number}
		 * @name playbackRate
		 */
	    Object.defineProperty(Tone.Player.prototype, 'playbackRate', {
	        get: function () {
	            return this._playbackRate;
	        },
	        set: function (rate) {
	            this._playbackRate = rate;
	            if (this._source) {
	                this._source.playbackRate.value = rate;
	            }
	        }
	    });
	    /**
		 * The direction the buffer should play in
		 * @memberOf Tone.Player#
		 * @type {boolean}
		 * @name reverse
		 */
	    Object.defineProperty(Tone.Player.prototype, 'reverse', {
	        get: function () {
	            return this._buffer.reverse;
	        },
	        set: function (rev) {
	            this._buffer.reverse = rev;
	        }
	    });
	    /**
		 * If all the buffer is loaded
		 * @memberOf Tone.Player#
		 * @type {Boolean}
		 * @name loaded
		 * @readOnly
		 */
	    Object.defineProperty(Tone.Player.prototype, 'loaded', {
	        get: function () {
	            return this._buffer.loaded;
	        }
	    });
	    /**
		 *  Dispose and disconnect.
		 *  @return {Tone.Player} this
		 */
	    Tone.Player.prototype.dispose = function () {
	        Tone.Source.prototype.dispose.call(this);
	        if (this._source !== null) {
	            this._source.disconnect();
	            this._source = null;
	        }
	        this._buffer.dispose();
	        this._buffer = null;
	        return this;
	    };
	    return Tone.Player;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class  Tone.Players combines multiple [Tone.Player](Player) objects.
		 *
		 *  @constructor
		 *  @extends {Tone.AudioNode}
		 *  @param {Object} urls An object mapping a name to a url.
		 *  @param {function=} onload The function to invoke when the buffer is loaded.
		 */
	    Tone.Players = function (urls) {
	        var args = Array.prototype.slice.call(arguments);
	        args.shift();
	        var options = Tone.defaults(args, ['onload'], Tone.Players);
	        Tone.call(this);
	        /**
			 *  The output volume node
			 *  @type  {Tone.Volume}
			 *  @private
			 */
	        this._volume = this.output = new Tone.Volume(options.volume);
	        /**
			 * The volume of the output in decibels.
			 * @type {Decibels}
			 * @signal
			 * @example
			 * source.volume.value = -6;
			 */
	        this.volume = this._volume.volume;
	        this._readOnly('volume');
	        //make the output explicitly stereo
	        this._volume.output.output.channelCount = 2;
	        this._volume.output.output.channelCountMode = 'explicit';
	        //mute initially
	        this.mute = options.mute;
	        /**
			 * The container of all of the players
			 * @type {Object}
			 * @private
			 */
	        this._players = {};
	        /**
			 * The loading count
			 * @type {Number}
			 * @private
			 */
	        this._loadingCount = 0;
	        /**
			 * private holder of the fadeIn time
			 * @type {Time}
			 * @private
			 */
	        this._fadeIn = options.fadeIn;
	        /**
			 * private holder of the fadeOut time
			 * @type {Time}
			 * @private
			 */
	        this._fadeOut = options.fadeOut;
	        //add all of the players
	        for (var name in urls) {
	            this._loadingCount++;
	            this.add(name, urls[name], this._bufferLoaded.bind(this, options.onload));
	        }
	    };
	    Tone.extend(Tone.Players, Tone.AudioNode);
	    /**
		 * The default values
		 * @type {Object}
		 */
	    Tone.Players.defaults = {
	        'volume': 0,
	        'mute': false,
	        'onload': Tone.noOp,
	        'fadeIn': 0,
	        'fadeOut': 0
	    };
	    /**
		 *  A buffer was loaded. decrement the counter.
		 *  @param  {Function}  callback
		 *  @private
		 */
	    Tone.Players.prototype._bufferLoaded = function (callback) {
	        this._loadingCount--;
	        if (this._loadingCount === 0 && callback) {
	            callback(this);
	        }
	    };
	    /**
		 * Mute the output.
		 * @memberOf Tone.Source#
		 * @type {boolean}
		 * @name mute
		 * @example
		 * //mute the output
		 * source.mute = true;
		 */
	    Object.defineProperty(Tone.Players.prototype, 'mute', {
	        get: function () {
	            return this._volume.mute;
	        },
	        set: function (mute) {
	            this._volume.mute = mute;
	        }
	    });
	    /**
		 * The fadeIn time of the amplitude envelope.
		 * @memberOf Tone.Source#
		 * @type {Time}
		 * @name fadeIn
		 */
	    Object.defineProperty(Tone.Players.prototype, 'fadeIn', {
	        get: function () {
	            return this._fadeIn;
	        },
	        set: function (fadeIn) {
	            this._fadeIn = fadeIn;
	            this._forEach(function (player) {
	                player.fadeIn = fadeIn;
	            });
	        }
	    });
	    /**
		 * The fadeOut time of the amplitude envelope.
		 * @memberOf Tone.Source#
		 * @type {Time}
		 * @name fadeOut
		 */
	    Object.defineProperty(Tone.Players.prototype, 'fadeOut', {
	        get: function () {
	            return this._fadeOut;
	        },
	        set: function (fadeOut) {
	            this._fadeOut = fadeOut;
	            this._forEach(function (player) {
	                player.fadeOut = fadeOut;
	            });
	        }
	    });
	    /**
		 * The state of the players object. Returns "started" if any of the players are playing.
		 * @memberOf Tone.Players#
		 * @type {String}
		 * @name state
		 * @readOnly
		 */
	    Object.defineProperty(Tone.Players.prototype, 'state', {
	        get: function () {
	            var playing = false;
	            this._forEach(function (player) {
	                playing = playing || player.state === Tone.State.Started;
	            });
	            return playing ? Tone.State.Started : Tone.State.Stopped;
	        }
	    });
	    /**
		 *  True if the buffers object has a buffer by that name.
		 *  @param  {String|Number}  name  The key or index of the
		 *                                 buffer.
		 *  @return  {Boolean}
		 */
	    Tone.Players.prototype.has = function (name) {
	        return this._players.hasOwnProperty(name);
	    };
	    /**
		 *  Get a player by name.
		 *  @param  {String}  name  The players name as defined in
		 *                          the constructor object or `add` method.
		 *  @return  {Tone.Player}
		 */
	    Tone.Players.prototype.get = function (name) {
	        if (this.has(name)) {
	            return this._players[name];
	        } else {
	            throw new Error('Tone.Players: no player named ' + name);
	        }
	    };
	    /**
		 * Iterate over all of the players
		 * @param  {Function} callback
		 * @return {Tone.Players}            this
		 * @private
		 */
	    Tone.Players.prototype._forEach = function (callback) {
	        for (var playerName in this._players) {
	            callback(this._players[playerName], playerName);
	        }
	        return this;
	    };
	    /**
		 * If all the buffers are loaded or not
		 * @memberOf Tone.Players#
		 * @type {Boolean}
		 * @name loaded
		 * @readOnly
		 */
	    Object.defineProperty(Tone.Players.prototype, 'loaded', {
	        get: function () {
	            var isLoaded = true;
	            this._forEach(function (player) {
	                isLoaded = isLoaded && player.loaded;
	            });
	            return isLoaded;
	        }
	    });
	    /**
		 *  Add a player by name and url to the Players
		 *  @param  {String}    name      A unique name to give the player
		 *  @param  {String|Tone.Buffer|Audiobuffer}  url  Either the url of the bufer,
		 *                                                 or a buffer which will be added
		 *                                                 with the given name.
		 *  @param  {Function=}  callback  The callback to invoke
		 *                                 when the url is loaded.
		 */
	    Tone.Players.prototype.add = function (name, url, callback) {
	        this._players[name] = new Tone.Player(url, callback).connect(this.output);
	        this._players[name].fadeIn = this._fadeIn;
	        this._players[name].fadeOut = this._fadeOut;
	        return this;
	    };
	    /**
		 * Stop all of the players at the given time
		 * @param {Time} time The time to stop all of the players.
		 * @return {Tone.Players} this
		 */
	    Tone.Players.prototype.stopAll = function (time) {
	        this._forEach(function (player) {
	            player.stop(time);
	        });
	    };
	    /**
		 *  Dispose and disconnect.
		 *  @return {Tone.Players} this
		 */
	    Tone.Players.prototype.dispose = function () {
	        Tone.AudioNode.prototype.dispose.call(this);
	        this._volume.dispose();
	        this._volume = null;
	        this._writable('volume');
	        this.volume = null;
	        this.output = null;
	        this._forEach(function (player) {
	            player.dispose();
	        });
	        this._players = null;
	        return this;
	    };
	    return Tone.Players;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class  Tone.UserMedia uses MediaDevices.getUserMedia to open up
		 *          and external microphone or audio input. Check
		 *          [MediaDevices API Support](https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia)
		 *          to see which browsers are supported. Access to an external input
		 *          is limited to secure (HTTPS) connections.
		 *
		 *  @constructor
		 *  @extends {Tone.AudioNode}
		 *  @param {Decibels=} volume The level of the input
		 *  @example
		 * //list the inputs and open the third one
		 * var motu = new Tone.UserMedia();
		 *
		 * //opening the input asks the user to activate their mic
		 * motu.open().then(function(){
		 * 	//opening is activates the microphone
		 * 	//starting lets audio through
		 * 	motu.start(10);
		 * });
		 */
	    Tone.UserMedia = function () {
	        var options = Tone.defaults(arguments, ['volume'], Tone.UserMedia);
	        Tone.AudioNode.call(this);
	        /**
			 *  The MediaStreamNode
			 *  @type {MediaStreamAudioSourceNode}
			 *  @private
			 */
	        this._mediaStream = null;
	        /**
			 *  The media stream created by getUserMedia.
			 *  @type {LocalMediaStream}
			 *  @private
			 */
	        this._stream = null;
	        /**
			 *  The open device
			 *  @type  {MediaDeviceInfo}
			 *  @private
			 */
	        this._device = null;
	        /**
			 *  The output volume node
			 *  @type  {Tone.Volume}
			 *  @private
			 */
	        this._volume = this.output = new Tone.Volume(options.volume);
	        /**
			 * The volume of the output in decibels.
			 * @type {Decibels}
			 * @signal
			 * @example
			 * input.volume.value = -6;
			 */
	        this.volume = this._volume.volume;
	        this._readOnly('volume');
	        this.mute = options.mute;
	    };
	    Tone.extend(Tone.UserMedia, Tone.AudioNode);
	    /**
		 * the default parameters
		 * @type {Object}
		 */
	    Tone.UserMedia.defaults = {
	        'volume': 0,
	        'mute': false
	    };
	    /**
		 *  Open the media stream. If a string is passed in, it is assumed
		 *  to be the label or id of the stream, if a number is passed in,
		 *  it is the input number of the stream.
		 *  @param  {String|Number} [labelOrId="default"] The label or id of the audio input media device.
		 *                                                With no argument, the default stream is opened.
		 *  @return {Promise} The promise is resolved when the stream is open.
		 */
	    Tone.UserMedia.prototype.open = function (labelOrId) {
	        labelOrId = Tone.defaultArg(labelOrId, 'default');
	        return Tone.UserMedia.enumerateDevices().then(function (devices) {
	            var device;
	            if (Tone.isNumber(labelOrId)) {
	                device = devices[labelOrId];
	            } else {
	                device = devices.find(function (device) {
	                    return device.label === labelOrId || device.deviceId === labelOrId;
	                });
	                //didn't find a matching device
	                if (!device) {
	                    throw new Error('Tone.UserMedia: no matching device: ' + labelOrId);
	                }
	            }
	            this._device = device;
	            //do getUserMedia
	            var constraints = {
	                audio: {
	                    'deviceId': device.deviceId,
	                    'echoCancellation': false,
	                    'sampleRate': this.context.sampleRate
	                }
	            };
	            return navigator.mediaDevices.getUserMedia(constraints).then(function (stream) {
	                //start a new source only if the previous one is closed
	                if (!this._stream) {
	                    this._stream = stream;
	                    //Wrap a MediaStreamSourceNode around the live input stream.
	                    this._mediaStream = this.context.createMediaStreamSource(stream);
	                    //Connect the MediaStreamSourceNode to a gate gain node
	                    this._mediaStream.connect(this.output);
	                }
	                return this;
	            }.bind(this));
	        }.bind(this));
	    };
	    /**
		 *  Close the media stream
		 *  @return {Tone.UserMedia} this
		 */
	    Tone.UserMedia.prototype.close = function () {
	        if (this._stream) {
	            this._stream.getAudioTracks().forEach(function (track) {
	                track.stop();
	            });
	            this._stream = null;
	            //remove the old media stream
	            this._mediaStream.disconnect();
	            this._mediaStream = null;
	        }
	        this._device = null;
	        return this;
	    };
	    /**
		 *  Returns a promise which resolves with the list of audio input devices available.
		 *  @return {Promise} The promise that is resolved with the devices
		 *  @static
		 *  @example
		 * Tone.UserMedia.enumerateDevices().then(function(devices){
		 * 	console.log(devices)
		 * })
		 */
	    Tone.UserMedia.enumerateDevices = function () {
	        return navigator.mediaDevices.enumerateDevices().then(function (devices) {
	            return devices.filter(function (device) {
	                return device.kind === 'audioinput';
	            });
	        });
	    };
	    /**
		 *  Returns the playback state of the source, "started" when the microphone is open
		 *  and "stopped" when the mic is closed.
		 *  @type {Tone.State}
		 *  @readOnly
		 *  @memberOf Tone.UserMedia#
		 *  @name state
		 */
	    Object.defineProperty(Tone.UserMedia.prototype, 'state', {
	        get: function () {
	            return this._stream && this._stream.active ? Tone.State.Started : Tone.State.Stopped;
	        }
	    });
	    /**
		 * 	Returns an identifier for the represented device that is
		 * 	persisted across sessions. It is un-guessable by other applications and
		 * 	unique to the origin of the calling application. It is reset when the
		 * 	user clears cookies (for Private Browsing, a different identifier is
		 * 	used that is not persisted across sessions). Returns undefined when the
		 * 	device is not open.
		 *  @type {String}
		 *  @readOnly
		 *  @memberOf Tone.UserMedia#
		 *  @name deviceId
		 */
	    Object.defineProperty(Tone.UserMedia.prototype, 'deviceId', {
	        get: function () {
	            if (this._device) {
	                return this._device.deviceId;
	            }
	        }
	    });
	    /**
		 * 	Returns a group identifier. Two devices have the
		 * 	same group identifier if they belong to the same physical device.
		 * 	Returns undefined when the device is not open.
		 *  @type {String}
		 *  @readOnly
		 *  @memberOf Tone.UserMedia#
		 *  @name groupId
		 */
	    Object.defineProperty(Tone.UserMedia.prototype, 'groupId', {
	        get: function () {
	            if (this._device) {
	                return this._device.groupId;
	            }
	        }
	    });
	    /**
		 * 	Returns a label describing this device (for example "Built-in Microphone").
		 * 	Returns undefined when the device is not open or label is not available
		 * 	because of permissions.
		 *  @type {String}
		 *  @readOnly
		 *  @memberOf Tone.UserMedia#
		 *  @name groupId
		 */
	    Object.defineProperty(Tone.UserMedia.prototype, 'label', {
	        get: function () {
	            if (this._device) {
	                return this._device.label;
	            }
	        }
	    });
	    /**
		 * Mute the output.
		 * @memberOf Tone.UserMedia#
		 * @type {boolean}
		 * @name mute
		 * @example
		 * //mute the output
		 * userMedia.mute = true;
		 */
	    Object.defineProperty(Tone.UserMedia.prototype, 'mute', {
	        get: function () {
	            return this._volume.mute;
	        },
	        set: function (mute) {
	            this._volume.mute = mute;
	        }
	    });
	    /**
		 * Clean up.
		 * @return {Tone.UserMedia} this
		 */
	    Tone.UserMedia.prototype.dispose = function () {
	        Tone.AudioNode.prototype.dispose.call(this);
	        this.close();
	        this._writable('volume');
	        this._volume.dispose();
	        this._volume = null;
	        this.volume = null;
	        return this;
	    };
	    /**
		 *  If getUserMedia is supported by the browser.
		 *  @type  {Boolean}
		 *  @memberOf Tone.UserMedia#
		 *  @name supported
		 *  @static
		 *  @readOnly
		 */
	    Object.defineProperty(Tone.UserMedia, 'supported', {
	        get: function () {
	            return !Tone.isUndef(navigator.mediaDevices) && Tone.isFunction(navigator.mediaDevices.getUserMedia);
	        }
	    });
	    return Tone.UserMedia;
	});
	
	return Tone;
}));
},{}],100:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var offsets = [0, 0.5, 1, 1.5, 2, 3, 3.5, 4, 4.5, 5, 5.5, 6];
var minNote = 21;
var maxNote = 108;
var KeyboardElement = (function () {
    function KeyboardElement(container) {
        this.container = container;
        this.keys = {};
        this.resize();
        this.notes = {};
    }
    KeyboardElement.prototype.resize = function () {
        this.keys = {};
        this.container.innerHTML = '';
        var keyWidth = 1 / 52;
        for (var i = minNote; i <= maxNote; i++) {
            var key = document.createElement('div');
            key.classList.add('key');
            var isSharp = ([1, 3, 6, 8, 10].indexOf(i % 12) !== -1);
            key.classList.add(isSharp ? 'black' : 'white');
            this.container.appendChild(key);
            var noteOctave = Math.floor(i / 12) - Math.floor(minNote / 12);
            var offset = offsets[i % 12] + noteOctave * 7 - 5;
            key.style.width = keyWidth * 100 + "%";
            key.style.left = offset * keyWidth * 100 + "%";
            key.id = i.toString();
            var fill = document.createElement('div');
            fill.classList.add('fill');
            key.appendChild(fill);
            this.keys[i] = key;
        }
    };
    KeyboardElement.prototype.keyDown = function (noteNum) {
        if (noteNum in this.keys) {
            var key = this.keys[noteNum];
            var note = new Note(key.querySelector('.fill'));
            if (!this.notes[noteNum]) {
                this.notes[noteNum] = [];
            }
            this.notes[noteNum].push(note);
        }
    };
    KeyboardElement.prototype.keyUp = function (noteNum) {
        if (noteNum in this.keys) {
            if (!(this.notes[noteNum] && this.notes[noteNum].length)) {
                console.warn('note off before note on');
            }
            else {
                this.notes[noteNum].shift().noteOff();
            }
        }
    };
    return KeyboardElement;
}());
exports.KeyboardElement = KeyboardElement;
var Note = (function () {
    function Note(element) {
        this.element = element;
        this.element.classList.add('active');
    }
    Note.prototype.noteOff = function () {
        this.element.classList.remove('active');
    };
    return Note;
}());

},{}],101:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var _this = this;
Object.defineProperty(exports, "__esModule", { value: true });
var deeplearn_1 = require("deeplearn");
var demo_util = require("../util");
var keyboard_element_1 = require("./keyboard_element");
var Piano = require('tone-piano').Piano;
var lstmKernel1;
var lstmBias1;
var lstmKernel2;
var lstmBias2;
var lstmKernel3;
var lstmBias3;
var c;
var h;
var fullyConnectedBiases;
var fullyConnectedWeights;
var forgetBias = deeplearn_1.Scalar.new(1.0);
var activeNotes = new Map();
var STEPS_PER_GENERATE_CALL = 10;
var GENERATION_BUFFER_SECONDS = .5;
var MAX_GENERATION_LAG_SECONDS = 1;
var MAX_NOTE_DURATION_SECONDS = 3;
var NOTES_PER_OCTAVE = 12;
var DENSITY_BIN_RANGES = [1.0, 2.0, 4.0, 8.0, 16.0, 32.0, 64.0];
var PITCH_HISTOGRAM_SIZE = NOTES_PER_OCTAVE;
var pitchHistogramEncoding;
var noteDensityEncoding;
var conditioningOff = true;
var currentPianoTimeSec = 0;
var pianoStartTimestampMs = 0;
var currentVelocity = 100;
var MIN_MIDI_PITCH = 0;
var MAX_MIDI_PITCH = 127;
var VELOCITY_BINS = 32;
var MAX_SHIFT_STEPS = 100;
var STEPS_PER_SECOND = 100;
var MIDI_EVENT_ON = 0x90;
var MIDI_EVENT_OFF = 0x80;
var MIDI_NO_OUTPUT_DEVICES_FOUND_MESSAGE = 'No midi output devices found.';
var currentLoopId = 0;
var EVENT_RANGES = [
    ['note_on', MIN_MIDI_PITCH, MAX_MIDI_PITCH],
    ['note_off', MIN_MIDI_PITCH, MAX_MIDI_PITCH],
    ['time_shift', 1, MAX_SHIFT_STEPS],
    ['velocity_change', 1, VELOCITY_BINS],
];
function calculateEventSize() {
    var eventOffset = 0;
    for (var _i = 0, EVENT_RANGES_1 = EVENT_RANGES; _i < EVENT_RANGES_1.length; _i++) {
        var eventRange = EVENT_RANGES_1[_i];
        var minValue = eventRange[1];
        var maxValue = eventRange[2];
        eventOffset += maxValue - minValue + 1;
    }
    return eventOffset;
}
var EVENT_SIZE = calculateEventSize();
var PRIMER_IDX = 355;
var lastSample = deeplearn_1.Scalar.new(PRIMER_IDX);
var container = document.querySelector('#keyboard');
var keyboardInterface = new keyboard_element_1.KeyboardElement(container);
var piano = new Piano({ velocities: 4 }).toMaster();
var SALAMANDER_URL = 'https://storage.googleapis.com/learnjs-data/' +
    'Piano/Salamander/';
var CHECKPOINT_URL = '.';
var isDeviceSupported = demo_util.isWebGLSupported() && !demo_util.isSafari();
if (!isDeviceSupported) {
    document.querySelector('#status').innerHTML =
        'We do not yet support your device. Please try on a desktop ' +
            'computer with Chrome/Firefox, or an Android phone with WebGL support.';
}
else {
    start();
}
var math = new deeplearn_1.NDArrayMathGPU();
function start() {
    piano.load(SALAMANDER_URL)
        .then(function () {
        var reader = new deeplearn_1.CheckpointLoader(CHECKPOINT_URL);
        return reader.getAllVariables();
    })
        .then(function (vars) {
        document.querySelector('#status').classList.add('hidden');
        document.querySelector('#controls').classList.remove('hidden');
        document.querySelector('#keyboard').classList.remove('hidden');
        lstmKernel1 =
            vars['rnn/multi_rnn_cell/cell_0/basic_lstm_cell/kernel'];
        lstmBias1 =
            vars['rnn/multi_rnn_cell/cell_0/basic_lstm_cell/bias'];
        lstmKernel2 =
            vars['rnn/multi_rnn_cell/cell_1/basic_lstm_cell/kernel'];
        lstmBias2 =
            vars['rnn/multi_rnn_cell/cell_1/basic_lstm_cell/bias'];
        lstmKernel3 =
            vars['rnn/multi_rnn_cell/cell_2/basic_lstm_cell/kernel'];
        lstmBias3 =
            vars['rnn/multi_rnn_cell/cell_2/basic_lstm_cell/bias'];
        fullyConnectedBiases = vars['fully_connected/biases'];
        fullyConnectedWeights = vars['fully_connected/weights'];
        resetRnn();
    });
}
function resetRnn() {
    c = [
        deeplearn_1.Array2D.zeros([1, lstmBias1.shape[0] / 4]),
        deeplearn_1.Array2D.zeros([1, lstmBias2.shape[0] / 4]),
        deeplearn_1.Array2D.zeros([1, lstmBias3.shape[0] / 4]),
    ];
    h = [
        deeplearn_1.Array2D.zeros([1, lstmBias1.shape[0] / 4]),
        deeplearn_1.Array2D.zeros([1, lstmBias2.shape[0] / 4]),
        deeplearn_1.Array2D.zeros([1, lstmBias3.shape[0] / 4]),
    ];
    if (lastSample != null) {
        lastSample.dispose();
    }
    lastSample = deeplearn_1.Scalar.new(PRIMER_IDX);
    currentPianoTimeSec = piano.now();
    pianoStartTimestampMs = performance.now() - currentPianoTimeSec * 1000;
    currentLoopId++;
    generateStep(currentLoopId);
}
window.addEventListener('resize', resize);
function resize() {
    keyboardInterface.resize();
}
resize();
var densityControl = document.getElementById('note-density');
var densityDisplay = document.getElementById('note-density-display');
var conditioningOffElem = document.getElementById('conditioning-off');
conditioningOffElem.onchange = updateConditioningParams;
var conditioningOnElem = document.getElementById('conditioning-on');
conditioningOnElem.onchange = updateConditioningParams;
var conditioningControlsElem = document.getElementById('conditioning-controls');
var gainSliderElement = document.getElementById('gain');
var gainDisplayElement = document.getElementById('gain-display');
var globalGain = +gainSliderElement.value;
gainDisplayElement.innerText = globalGain.toString();
gainSliderElement.addEventListener('input', function () {
    globalGain = +gainSliderElement.value;
    gainDisplayElement.innerText = globalGain.toString();
});
var pitchHistogramElements = [
    document.getElementById('pitch-c'),
    document.getElementById('pitch-cs'),
    document.getElementById('pitch-d'),
    document.getElementById('pitch-ds'),
    document.getElementById('pitch-e'),
    document.getElementById('pitch-f'),
    document.getElementById('pitch-fs'),
    document.getElementById('pitch-g'),
    document.getElementById('pitch-gs'),
    document.getElementById('pitch-a'),
    document.getElementById('pitch-as'),
    document.getElementById('pitch-b'),
];
var preset1 = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
var preset2 = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
try {
    parseHash();
}
catch (e) {
    console.warn(e);
}
function parseHash() {
    if (!window.location.hash) {
        return;
    }
    var params = window.location.hash.substr(1).split('|');
    densityControl.value = params[0];
    var pitches = params[1].split(',');
    for (var i = 0; i < pitchHistogramElements.length; i++) {
        pitchHistogramElements[i].value = pitches[i];
    }
    var preset1Values = params[2].split(',');
    for (var i = 0; i < preset1.length; i++) {
        preset1[i] = parseInt(preset1Values[i], 10);
    }
    var preset2Values = params[3].split(',');
    for (var i = 0; i < preset2.length; i++) {
        preset2[i] = parseInt(preset2Values[i], 10);
    }
    if (!!parseInt(params[4], 10)) {
        conditioningOffElem.checked = true;
    }
    else {
        conditioningOnElem.checked = true;
    }
}
function updateConditioningParams() {
    var pitchHistogram = pitchHistogramElements.map(function (e) {
        return parseInt(e.value, 10) || 0;
    });
    if (noteDensityEncoding !== undefined) {
        noteDensityEncoding.dispose();
        noteDensityEncoding = undefined;
    }
    if (conditioningOffElem.checked) {
        conditioningOff = true;
        conditioningControlsElem.classList.add('inactive');
    }
    else {
        conditioningOff = false;
        conditioningControlsElem.classList.remove('inactive');
    }
    window.location.assign('#' + densityControl.value + '|' + pitchHistogram.join(',') + '|' +
        preset1.join(',') + '|' + preset2.join(',') + '|' +
        (conditioningOff ? '1' : '0'));
    var noteDensityIdx = parseInt(densityControl.value, 10) || 0;
    var noteDensity = DENSITY_BIN_RANGES[noteDensityIdx];
    densityDisplay.innerHTML = noteDensity.toString();
    noteDensityEncoding = deeplearn_1.Array1D.zeros([DENSITY_BIN_RANGES.length + 1]);
    noteDensityEncoding.set(1.0, noteDensityIdx + 1);
    if (pitchHistogramEncoding !== undefined) {
        pitchHistogramEncoding.dispose();
        pitchHistogramEncoding = undefined;
    }
    pitchHistogramEncoding = deeplearn_1.Array1D.zeros([PITCH_HISTOGRAM_SIZE]);
    var pitchHistogramTotal = pitchHistogram.reduce(function (prev, val) {
        return prev + val;
    });
    for (var i = 0; i < PITCH_HISTOGRAM_SIZE; i++) {
        pitchHistogramEncoding.set(pitchHistogram[i] / pitchHistogramTotal, i);
    }
}
document.getElementById('note-density').oninput = updateConditioningParams;
pitchHistogramElements.map(function (e) {
    e.oninput = updateConditioningParams;
});
updateConditioningParams();
function updatePitchHistogram(newHist) {
    for (var i = 0; i < newHist.length; i++) {
        pitchHistogramElements[i].value = newHist[i].toString();
    }
    updateConditioningParams();
}
document.getElementById('c-major').onclick = function () {
    updatePitchHistogram([2, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1]);
};
document.getElementById('f-major').onclick = function () {
    updatePitchHistogram([1, 0, 1, 0, 1, 2, 0, 1, 0, 1, 1, 0]);
};
document.getElementById('d-minor').onclick = function () {
    updatePitchHistogram([1, 0, 2, 0, 1, 1, 0, 1, 0, 1, 1, 0]);
};
document.getElementById('whole-tone').onclick = function () {
    updatePitchHistogram([1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0]);
};
document.getElementById('pentatonic').onclick = function () {
    updatePitchHistogram([0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0]);
};
document.getElementById('reset-rnn').onclick = function () {
    resetRnn();
};
document.getElementById('preset-1').onclick = function () {
    updatePitchHistogram(preset1);
};
document.getElementById('preset-2').onclick = function () {
    updatePitchHistogram(preset2);
};
document.getElementById('save-1').onclick = function () {
    preset1 = pitchHistogramElements.map(function (e) {
        return parseInt(e.value, 10) || 0;
    });
    updateConditioningParams();
};
document.getElementById('save-2').onclick = function () {
    preset2 = pitchHistogramElements.map(function (e) {
        return parseInt(e.value, 10) || 0;
    });
    updateConditioningParams();
};
function generateStep(loopId) {
    return __awaiter(this, void 0, void 0, function () {
        var _this = this;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if (loopId < currentLoopId) {
                        return [2];
                    }
                    return [4, math.scope(function (keep, track) { return __awaiter(_this, void 0, void 0, function () {
                            var lstm1, lstm2, lstm3, outputs, i, eventInput, input, output, outputH, weightedResult, logits, softmax, sampledOutput, i, _a, delta;
                            return __generator(this, function (_b) {
                                switch (_b.label) {
                                    case 0:
                                        lstm1 = math.basicLSTMCell.bind(math, forgetBias, lstmKernel1, lstmBias1);
                                        lstm2 = math.basicLSTMCell.bind(math, forgetBias, lstmKernel2, lstmBias2);
                                        lstm3 = math.basicLSTMCell.bind(math, forgetBias, lstmKernel3, lstmBias3);
                                        c.map(function (val) {
                                            track(val);
                                        });
                                        h.map(function (val) {
                                            track(val);
                                        });
                                        outputs = [];
                                        for (i = 0; i < STEPS_PER_GENERATE_CALL; i++) {
                                            eventInput = math.oneHot(lastSample.as1D(), EVENT_SIZE).as1D();
                                            if (i === 0) {
                                                lastSample.dispose();
                                            }
                                            input = eventInput;
                                            output = math.multiRNNCell([lstm1, lstm2, lstm3], input.as2D(1, -1), c, h);
                                            c = output[0];
                                            h = output[1];
                                            outputH = h[2];
                                            weightedResult = math.matMul(outputH, fullyConnectedWeights);
                                            logits = math.add(weightedResult, fullyConnectedBiases);
                                            softmax = math.softmax(logits.as1D());
                                            sampledOutput = math.multinomial(softmax, 1).asScalar();
                                            outputs.push(sampledOutput);
                                            keep(sampledOutput);
                                            lastSample = sampledOutput;
                                        }
                                        c.map(function (val) {
                                            keep(val);
                                        });
                                        h.map(function (val) {
                                            keep(val);
                                        });
                                        return [4, outputs[outputs.length - 1].data()];
                                    case 1:
                                        _b.sent();
                                        i = 0;
                                        _b.label = 2;
                                    case 2:
                                        if (!(i < outputs.length)) return [3, 5];
                                        _a = playOutput;
                                        return [4, outputs[i].val()];
                                    case 3:
                                        _a.apply(void 0, [_b.sent()]);
                                        _b.label = 4;
                                    case 4:
                                        i++;
                                        return [3, 2];
                                    case 5:
                                        lastSample.getTexture();
                                        if (piano.now() - currentPianoTimeSec > MAX_GENERATION_LAG_SECONDS) {
                                            console.warn("Generation is " + (piano.now() - currentPianoTimeSec) + " seconds behind, " +
                                                ("which is over " + MAX_NOTE_DURATION_SECONDS + ". Resetting time!"));
                                            currentPianoTimeSec = piano.now();
                                        }
                                        delta = Math.max(0, currentPianoTimeSec - piano.now() - GENERATION_BUFFER_SECONDS);
                                        setTimeout(function () { return generateStep(loopId); }, delta * 1000);
                                        return [2];
                                }
                            });
                        }); })];
                case 1:
                    _a.sent();
                    return [2];
            }
        });
    });
}
var midi;
var outputDevice = null;
(function () { return __awaiter(_this, void 0, void 0, function () {
    var midiOutDropdownContainer, navigator_1, midiOutDropdown_1, count_1, midiDevices_1, e_1;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                midiOutDropdownContainer = document.getElementById('midi-out-container');
                _a.label = 1;
            case 1:
                _a.trys.push([1, 3, , 4]);
                navigator_1 = window.navigator;
                return [4, navigator_1.requestMIDIAccess()];
            case 2:
                midi = _a.sent();
                midiOutDropdown_1 = document.getElementById('midi-out');
                count_1 = 0;
                midiDevices_1 = [];
                midi.outputs.forEach(function (output) {
                    console.log("\n          Output midi device [type: '" + output.type + "']\n          id: " + output.id + "\n          manufacturer: " + output.manufacturer + "\n          name:" + output.name + "\n          version: " + output.version);
                    midiDevices_1.push(output);
                    var option = document.createElement('option');
                    option.innerText = output.name;
                    midiOutDropdown_1.appendChild(option);
                    count_1++;
                });
                midiOutDropdown_1.addEventListener('change', function () {
                    outputDevice = midiDevices_1[midiOutDropdown_1.selectedIndex];
                });
                if (count_1 > 0) {
                    outputDevice = midiDevices_1[0];
                }
                else {
                    midiOutDropdownContainer.innerText = MIDI_NO_OUTPUT_DEVICES_FOUND_MESSAGE;
                }
                return [3, 4];
            case 3:
                e_1 = _a.sent();
                midiOutDropdownContainer.innerText = MIDI_NO_OUTPUT_DEVICES_FOUND_MESSAGE;
                midi = null;
                return [3, 4];
            case 4: return [2];
        }
    });
}); })();
function playOutput(index) {
    var offset = 0;
    var _loop_1 = function (eventRange) {
        var eventType = eventRange[0];
        var minValue = eventRange[1];
        var maxValue = eventRange[2];
        if (offset <= index && index <= offset + maxValue - minValue) {
            if (eventType === 'note_on') {
                var noteNum_1 = index - offset;
                setTimeout(function () {
                    keyboardInterface.keyDown(noteNum_1);
                    setTimeout(function () {
                        keyboardInterface.keyUp(noteNum_1);
                    }, 100);
                }, (currentPianoTimeSec - piano.now()) * 1000);
                activeNotes.set(noteNum_1, currentPianoTimeSec);
                if (outputDevice != null) {
                    outputDevice.send([MIDI_EVENT_ON, noteNum_1, currentVelocity * globalGain], Math.floor(1000 * currentPianoTimeSec) - pianoStartTimestampMs);
                }
                return { value: piano.keyDown(noteNum_1, currentPianoTimeSec, currentVelocity * globalGain / 100) };
            }
            else if (eventType === 'note_off') {
                var noteNum = index - offset;
                var activeNoteEndTimeSec = activeNotes.get(noteNum);
                if (activeNoteEndTimeSec == null) {
                    return { value: void 0 };
                }
                var timeSec = Math.max(currentPianoTimeSec, activeNoteEndTimeSec + .5);
                if (outputDevice != null) {
                    outputDevice.send([MIDI_EVENT_OFF, noteNum, currentVelocity * globalGain], Math.floor(timeSec * 1000) - pianoStartTimestampMs);
                }
                piano.keyUp(noteNum, timeSec);
                activeNotes.delete(noteNum);
                return { value: void 0 };
            }
            else if (eventType === 'time_shift') {
                currentPianoTimeSec += (index - offset + 1) / STEPS_PER_SECOND;
                activeNotes.forEach(function (timeSec, noteNum) {
                    if (currentPianoTimeSec - timeSec > MAX_NOTE_DURATION_SECONDS) {
                        console.info("Note " + noteNum + " has been active for " + (currentPianoTimeSec - timeSec) + ", " +
                            ("seconds which is over " + MAX_NOTE_DURATION_SECONDS + ", will ") +
                            "release.");
                        if (outputDevice != null) {
                            outputDevice.send([MIDI_EVENT_OFF, noteNum, currentVelocity * globalGain]);
                        }
                        piano.keyUp(noteNum, currentPianoTimeSec);
                        activeNotes.delete(noteNum);
                    }
                });
                return { value: currentPianoTimeSec };
            }
            else if (eventType === 'velocity_change') {
                currentVelocity = (index - offset + 1) * Math.ceil(127 / VELOCITY_BINS);
                currentVelocity = currentVelocity / 127;
                return { value: currentVelocity };
            }
            else {
                throw new Error('Could not decode eventType: ' + eventType);
            }
        }
        offset += maxValue - minValue + 1;
    };
    for (var _i = 0, EVENT_RANGES_2 = EVENT_RANGES; _i < EVENT_RANGES_2.length; _i++) {
        var eventRange = EVENT_RANGES_2[_i];
        var state_1 = _loop_1(eventRange);
        if (typeof state_1 === "object")
            return state_1.value;
    }
    throw new Error("Could not decode index: " + index);
}

},{"../util":102,"./keyboard_element":100,"deeplearn":43,"tone-piano":98}],102:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var deeplearn_1 = require("deeplearn");
function isWebGLSupported() {
    try {
        var math = new deeplearn_1.NDArrayMathGPU();
        math.dispose();
        return true;
    }
    catch (e) {
        return false;
    }
}
exports.isWebGLSupported = isWebGLSupported;
function isSafari() {
    var ua = navigator.userAgent.toLowerCase();
    if (ua.indexOf('safari') !== -1) {
        if (ua.indexOf('chrome') > -1) {
            return false;
        }
        else {
            return true;
        }
    }
    return false;
}
exports.isSafari = isSafari;
function isMobile() {
    var a = navigator.userAgent || navigator.vendor || window.opera;
    return /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i
        .test(a) ||
        /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i
            .test(a.substr(0, 4));
}
exports.isMobile = isMobile;

},{"deeplearn":43}]},{},[101])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImRlbW9zL25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJkZW1vcy9ub2RlX21vZHVsZXMvYnJvd3Nlci1yZXNvbHZlL2VtcHR5LmpzIiwiZGVtb3Mvbm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L3NyYy9kYXRhL2NoZWNrcG9pbnRfbG9hZGVyLmpzIiwiZGVtb3Mvbm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L3NyYy9kYXRhL2RhdGFzZXQuanMiLCJkZW1vcy9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL2RhdGEvaW5wdXRfcHJvdmlkZXIuanMiLCJkZW1vcy9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL2RhdGEveGhyLWRhdGFzZXQuanMiLCJkZW1vcy9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL2RldmljZV91dGlsLmpzIiwiZGVtb3Mvbm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L3NyYy9lbnZpcm9ubWVudC5qcyIsImRlbW9zL25vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9zcmMvZ3JhcGgvZ3JhcGguanMiLCJkZW1vcy9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL2dyYXBoL2dyYXBoX3V0aWwuanMiLCJkZW1vcy9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL2dyYXBoL29wZXJhdGlvbl9lbWl0dGVyLmpzIiwiZGVtb3Mvbm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L3NyYy9ncmFwaC9vcHMvYWRkLmpzIiwiZGVtb3Mvbm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L3NyYy9ncmFwaC9vcHMvYXJnbWF4LmpzIiwiZGVtb3Mvbm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L3NyYy9ncmFwaC9vcHMvYXJnbWF4ZXF1YWxzLmpzIiwiZGVtb3Mvbm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L3NyYy9ncmFwaC9vcHMvY29uY2F0M2QuanMiLCJkZW1vcy9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL2dyYXBoL29wcy9jb252b2x1dGlvbi5qcyIsImRlbW9zL25vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9zcmMvZ3JhcGgvb3BzL2RpdmlkZS5qcyIsImRlbW9zL25vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9zcmMvZ3JhcGgvb3BzL2VsZW1lbnRfd2lzZV9hY3RpdmF0aW9uLmpzIiwiZGVtb3Mvbm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L3NyYy9ncmFwaC9vcHMvZWxlbWVudF93aXNlX2Nvc3QuanMiLCJkZW1vcy9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL2dyYXBoL29wcy9leHAuanMiLCJkZW1vcy9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL2dyYXBoL29wcy9saW5lYXJfY29tYmluYXRpb24uanMiLCJkZW1vcy9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL2dyYXBoL29wcy9sb2cuanMiLCJkZW1vcy9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL2dyYXBoL29wcy9tYXRtdWwuanMiLCJkZW1vcy9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL2dyYXBoL29wcy9tYXhfcG9vbC5qcyIsImRlbW9zL25vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9zcmMvZ3JhcGgvb3BzL211bHRpcGx5LmpzIiwiZGVtb3Mvbm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L3NyYy9ncmFwaC9vcHMvb3AuanMiLCJkZW1vcy9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL2dyYXBoL29wcy9yZWR1Y2Vfc3VtLmpzIiwiZGVtb3Mvbm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L3NyYy9ncmFwaC9vcHMvcmVzaGFwZS5qcyIsImRlbW9zL25vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9zcmMvZ3JhcGgvb3BzL3NvZnRtYXguanMiLCJkZW1vcy9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL2dyYXBoL29wcy9zdWJ0cmFjdC5qcyIsImRlbW9zL25vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9zcmMvZ3JhcGgvb3B0aW1pemVycy9hZGFkZWx0YV9vcHRpbWl6ZXIuanMiLCJkZW1vcy9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL2dyYXBoL29wdGltaXplcnMvYWRhZ3JhZF9vcHRpbWl6ZXIuanMiLCJkZW1vcy9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL2dyYXBoL29wdGltaXplcnMvYWRhbV9vcHRpbWl6ZXIuanMiLCJkZW1vcy9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL2dyYXBoL29wdGltaXplcnMvYWRhbWF4X29wdGltaXplci5qcyIsImRlbW9zL25vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9zcmMvZ3JhcGgvb3B0aW1pemVycy9tb21lbnR1bV9vcHRpbWl6ZXIuanMiLCJkZW1vcy9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL2dyYXBoL29wdGltaXplcnMvb3B0aW1pemVyLmpzIiwiZGVtb3Mvbm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L3NyYy9ncmFwaC9vcHRpbWl6ZXJzL3Jtc3Byb3Bfb3B0aW1pemVyLmpzIiwiZGVtb3Mvbm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L3NyYy9ncmFwaC9vcHRpbWl6ZXJzL3NnZF9vcHRpbWl6ZXIuanMiLCJkZW1vcy9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL2dyYXBoL3ByaW9yaXR5X3F1ZXVlLmpzIiwiZGVtb3Mvbm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L3NyYy9ncmFwaC9zZXNzaW9uLmpzIiwiZGVtb3Mvbm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L3NyYy9ncmFwaC9zZXNzaW9uX3V0aWwuanMiLCJkZW1vcy9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL2dyYXBoL3RlbnNvcl9hcnJheV9tYXAuanMiLCJkZW1vcy9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL2dyYXBoX3J1bm5lci5qcyIsImRlbW9zL25vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9zcmMvaW5kZXguanMiLCJkZW1vcy9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL2luaXRpYWxpemVycy5qcyIsImRlbW9zL25vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9zcmMvbWF0aC9hY3RpdmF0aW9uX2Z1bmN0aW9ucy5qcyIsImRlbW9zL25vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9zcmMvbWF0aC9heGlzX3V0aWwuanMiLCJkZW1vcy9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL21hdGgvYnJvYWRjYXN0X3V0aWwuanMiLCJkZW1vcy9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL21hdGgvY29uY2F0X3V0aWwuanMiLCJkZW1vcy9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL21hdGgvY29udl91dGlsLmpzIiwiZGVtb3Mvbm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L3NyYy9tYXRoL2NvcHkyZF91dGlsLmpzIiwiZGVtb3Mvbm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L3NyYy9tYXRoL2Nvc3RfZnVuY3Rpb25zLmpzIiwiZGVtb3Mvbm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L3NyYy9tYXRoL21hdGguanMiLCJkZW1vcy9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL21hdGgvbWF0aF9jcHUuanMiLCJkZW1vcy9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL21hdGgvbWF0aF9ncHUuanMiLCJkZW1vcy9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL21hdGgvbmRhcnJheS5qcyIsImRlbW9zL25vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9zcmMvbWF0aC9yZWR1Y2VfdXRpbC5qcyIsImRlbW9zL25vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9zcmMvbWF0aC9zbGljZV91dGlsLmpzIiwiZGVtb3Mvbm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L3NyYy9tYXRoL3dlYmdsL2FkZHNjYWxlZG1hdF9ncHUuanMiLCJkZW1vcy9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL21hdGgvd2ViZ2wvYXJnbWlubWF4X2dwdS5qcyIsImRlbW9zL25vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9zcmMvbWF0aC93ZWJnbC9iYXRjaG5vcm1fZ3B1LmpzIiwiZGVtb3Mvbm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L3NyYy9tYXRoL3dlYmdsL2JpbmFyeW9wX2dwdS5qcyIsImRlbW9zL25vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9zcmMvbWF0aC93ZWJnbC9jbGlwX2dwdS5qcyIsImRlbW9zL25vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9zcmMvbWF0aC93ZWJnbC9jb25jYXRfZ3B1LmpzIiwiZGVtb3Mvbm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L3NyYy9tYXRoL3dlYmdsL2NvbnZfYmFja3Byb3BfZ3B1LmpzIiwiZGVtb3Mvbm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L3NyYy9tYXRoL3dlYmdsL2NvbnZfZ3B1LmpzIiwiZGVtb3Mvbm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L3NyYy9tYXRoL3dlYmdsL2NvbnZfZ3B1X2RlcHRod2lzZS5qcyIsImRlbW9zL25vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9zcmMvbWF0aC93ZWJnbC9jb3B5X2dwdS5qcyIsImRlbW9zL25vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9zcmMvbWF0aC93ZWJnbC9ncGdwdV9jb250ZXh0LmpzIiwiZGVtb3Mvbm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L3NyYy9tYXRoL3dlYmdsL2dwZ3B1X21hdGguanMiLCJkZW1vcy9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL21hdGgvd2ViZ2wvZ3BncHVfdXRpbC5qcyIsImRlbW9zL25vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9zcmMvbWF0aC93ZWJnbC9tYXhfcG9vbF9iYWNrcHJvcF9ncHUuanMiLCJkZW1vcy9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL21hdGgvd2ViZ2wvbXVsbWF0X2dwdS5qcyIsImRlbW9zL25vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9zcmMvbWF0aC93ZWJnbC9tdWx0aW5vbWlhbF9ncHUuanMiLCJkZW1vcy9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL21hdGgvd2ViZ2wvb25laG90X2dwdS5qcyIsImRlbW9zL25vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9zcmMvbWF0aC93ZWJnbC9wb29sX2dwdS5qcyIsImRlbW9zL25vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9zcmMvbWF0aC93ZWJnbC9yZWR1Y2VfZ3B1LmpzIiwiZGVtb3Mvbm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L3NyYy9tYXRoL3dlYmdsL3JlbmRlcl9uZGFycmF5X2dwdV91dGlsLmpzIiwiZGVtb3Mvbm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L3NyYy9tYXRoL3dlYmdsL3Jlc2l6ZV9iaWxpbmVhcl9ncHUuanMiLCJkZW1vcy9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL21hdGgvd2ViZ2wvc2hhZGVyX2NvbXBpbGVyLmpzIiwiZGVtb3Mvbm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L3NyYy9tYXRoL3dlYmdsL3NsaWNlX2dwdS5qcyIsImRlbW9zL25vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9zcmMvbWF0aC93ZWJnbC90ZXhfdXRpbC5qcyIsImRlbW9zL25vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9zcmMvbWF0aC93ZWJnbC90ZXh0dXJlX21hbmFnZXIuanMiLCJkZW1vcy9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL21hdGgvd2ViZ2wvdGlsZV9ncHUuanMiLCJkZW1vcy9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL21hdGgvd2ViZ2wvdHJhbnNwb3NlX2dwdS5qcyIsImRlbW9zL25vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9zcmMvbWF0aC93ZWJnbC91bmFyeW9wX2dwdS5qcyIsImRlbW9zL25vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9zcmMvbWF0aC93ZWJnbC93ZWJnbF91dGlsLmpzIiwiZGVtb3Mvbm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L3NyYy90ZXN0X3V0aWwuanMiLCJkZW1vcy9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL3V0aWwuanMiLCJkZW1vcy9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL3ZlcnNpb24uanMiLCJkZW1vcy9ub2RlX21vZHVsZXMvc2VlZHJhbmRvbS9pbmRleC5qcyIsImRlbW9zL25vZGVfbW9kdWxlcy9zZWVkcmFuZG9tL2xpYi9hbGVhLmpzIiwiZGVtb3Mvbm9kZV9tb2R1bGVzL3NlZWRyYW5kb20vbGliL3R5Y2hlaS5qcyIsImRlbW9zL25vZGVfbW9kdWxlcy9zZWVkcmFuZG9tL2xpYi94b3IxMjguanMiLCJkZW1vcy9ub2RlX21vZHVsZXMvc2VlZHJhbmRvbS9saWIveG9yNDA5Ni5qcyIsImRlbW9zL25vZGVfbW9kdWxlcy9zZWVkcmFuZG9tL2xpYi94b3JzaGlmdDcuanMiLCJkZW1vcy9ub2RlX21vZHVsZXMvc2VlZHJhbmRvbS9saWIveG9yd293LmpzIiwiZGVtb3Mvbm9kZV9tb2R1bGVzL3NlZWRyYW5kb20vc2VlZHJhbmRvbS5qcyIsImRlbW9zL25vZGVfbW9kdWxlcy90b25lLXBpYW5vL2J1aWxkL1BpYW5vLmpzIiwiZGVtb3Mvbm9kZV9tb2R1bGVzL3RvbmUvYnVpbGQvVG9uZS5qcyIsImRlbW9zL3BlcmZvcm1hbmNlX3Jubi9rZXlib2FyZF9lbGVtZW50LnRzIiwiZGVtb3MvcGVyZm9ybWFuY2Vfcm5uL3BlcmZvcm1hbmNlX3Jubi50cyIsImRlbW9zL3V0aWwudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbktBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9sQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25GQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2w1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0akNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaGNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM3lCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeFJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9VQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZQQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDcnp0QkEsSUFBTSxPQUFPLEdBQUcsQ0FBQyxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUMsRUFBRSxHQUFHLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxHQUFHLEVBQUUsQ0FBQyxFQUFFLEdBQUcsRUFBRSxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUMsQ0FBQyxDQUFDO0FBRS9ELElBQU0sT0FBTyxHQUFHLEVBQUUsQ0FBQztBQUNuQixJQUFNLE9BQU8sR0FBRyxHQUFHLENBQUM7QUFFcEI7SUFLRSx5QkFBWSxTQUFrQjtRQUM1QixJQUFJLENBQUMsU0FBUyxHQUFHLFNBQVMsQ0FBQztRQUMzQixJQUFJLENBQUMsSUFBSSxHQUFHLEVBQUUsQ0FBQztRQUVmLElBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQztRQUNkLElBQUksQ0FBQyxLQUFLLEdBQUcsRUFBRSxDQUFDO0lBQ2xCLENBQUM7SUFFRCxnQ0FBTSxHQUFOO1FBRUUsSUFBSSxDQUFDLElBQUksR0FBRyxFQUFFLENBQUM7UUFDZixJQUFJLENBQUMsU0FBUyxDQUFDLFNBQVMsR0FBRyxFQUFFLENBQUM7UUFHOUIsSUFBTSxRQUFRLEdBQUcsQ0FBQyxHQUFHLEVBQUUsQ0FBQztRQUV4QixHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxPQUFPLEVBQUUsQ0FBQyxJQUFJLE9BQU8sRUFBRSxDQUFDLEVBQUUsRUFBRSxDQUFDO1lBQ3hDLElBQU0sR0FBRyxHQUFHLFFBQVEsQ0FBQyxhQUFhLENBQUMsS0FBSyxDQUFDLENBQUM7WUFDMUMsR0FBRyxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUM7WUFDekIsSUFBTSxPQUFPLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDMUQsR0FBRyxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDO1lBQy9DLElBQUksQ0FBQyxTQUFTLENBQUMsV0FBVyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1lBR2hDLElBQU0sVUFBVSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxHQUFHLEVBQUUsQ0FBQyxDQUFDO1lBQ2pFLElBQU0sTUFBTSxHQUFHLE9BQU8sQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLEdBQUcsVUFBVSxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUM7WUFDcEQsR0FBRyxDQUFDLEtBQUssQ0FBQyxLQUFLLEdBQU0sUUFBUSxHQUFHLEdBQUcsTUFBRyxDQUFDO1lBQ3ZDLEdBQUcsQ0FBQyxLQUFLLENBQUMsSUFBSSxHQUFNLE1BQU0sR0FBRyxRQUFRLEdBQUcsR0FBRyxNQUFHLENBQUM7WUFDL0MsR0FBRyxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUMsUUFBUSxFQUFFLENBQUM7WUFFdEIsSUFBTSxJQUFJLEdBQUcsUUFBUSxDQUFDLGFBQWEsQ0FBQyxLQUFLLENBQUMsQ0FBQztZQUMzQyxJQUFJLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsQ0FBQztZQUMzQixHQUFHLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxDQUFDO1lBQ3RCLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDO1FBQ3JCLENBQUM7SUFDSCxDQUFDO0lBRUQsaUNBQU8sR0FBUCxVQUFRLE9BQWU7UUFDckIsRUFBRSxDQUFDLENBQUMsT0FBTyxJQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO1lBQ3pCLElBQU0sR0FBRyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7WUFFL0IsSUFBTSxJQUFJLEdBQUcsSUFBSSxJQUFJLENBQUMsR0FBRyxDQUFDLGFBQWEsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDO1lBQ2xELEVBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUM7Z0JBQ3pCLElBQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLEdBQUcsRUFBWSxDQUFDO1lBQ3JDLENBQUM7WUFDRCxJQUFJLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUNqQyxDQUFDO0lBQ0gsQ0FBQztJQUVELCtCQUFLLEdBQUwsVUFBTSxPQUFlO1FBQ25CLEVBQUUsQ0FBQyxDQUFDLE9BQU8sSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztZQUN6QixFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsSUFBSSxJQUFJLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQztnQkFDekQsT0FBTyxDQUFDLElBQUksQ0FBQyx5QkFBeUIsQ0FBQyxDQUFDO1lBQzFDLENBQUM7WUFBQyxJQUFJLENBQUMsQ0FBQztnQkFDTixJQUFJLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDLEtBQUssRUFBRSxDQUFDLE9BQU8sRUFBRSxDQUFDO1lBQ3hDLENBQUM7UUFDSCxDQUFDO0lBQ0gsQ0FBQztJQUNILHNCQUFDO0FBQUQsQ0EvREEsQUErREMsSUFBQTtBQS9EWSwwQ0FBZTtBQWlFNUI7SUFHRSxjQUFZLE9BQWdCO1FBQzFCLElBQUksQ0FBQyxPQUFPLEdBQUcsT0FBTyxDQUFDO1FBQ3ZCLElBQUksQ0FBQyxPQUFPLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUN2QyxDQUFDO0lBRUQsc0JBQU8sR0FBUDtRQUNFLElBQUksQ0FBQyxPQUFPLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUMxQyxDQUFDO0lBQ0gsV0FBQztBQUFELENBWEEsQUFXQyxJQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNoRkQsaUJBaWpCQTs7QUFqakJBLHVDQUE4RjtBQUM5RixtQ0FBcUM7QUFFckMsdURBQW1EO0FBR25ELElBQU0sS0FBSyxHQUFHLE9BQU8sQ0FBQyxZQUFZLENBQUMsQ0FBQyxLQUFLLENBQUM7QUFFMUMsSUFBSSxXQUFvQixDQUFDO0FBQ3pCLElBQUksU0FBa0IsQ0FBQztBQUN2QixJQUFJLFdBQW9CLENBQUM7QUFDekIsSUFBSSxTQUFrQixDQUFDO0FBQ3ZCLElBQUksV0FBb0IsQ0FBQztBQUN6QixJQUFJLFNBQWtCLENBQUM7QUFDdkIsSUFBSSxDQUFZLENBQUM7QUFDakIsSUFBSSxDQUFZLENBQUM7QUFDakIsSUFBSSxvQkFBNkIsQ0FBQztBQUNsQyxJQUFJLHFCQUE4QixDQUFDO0FBQ25DLElBQU0sVUFBVSxHQUFHLGtCQUFNLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0FBQ25DLElBQU0sV0FBVyxHQUFHLElBQUksR0FBRyxFQUFrQixDQUFDO0FBTTlDLElBQU0sdUJBQXVCLEdBQUcsRUFBRSxDQUFDO0FBR25DLElBQU0seUJBQXlCLEdBQUcsRUFBRSxDQUFDO0FBRXJDLElBQU0sMEJBQTBCLEdBQUcsQ0FBQyxDQUFDO0FBRXJDLElBQU0seUJBQXlCLEdBQUcsQ0FBQyxDQUFDO0FBRXBDLElBQU0sZ0JBQWdCLEdBQUcsRUFBRSxDQUFDO0FBQzVCLElBQU0sa0JBQWtCLEdBQUcsQ0FBQyxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLENBQUMsQ0FBQztBQUNsRSxJQUFNLG9CQUFvQixHQUFHLGdCQUFnQixDQUFDO0FBRTlDLElBQUksc0JBQStCLENBQUM7QUFDcEMsSUFBSSxtQkFBNEIsQ0FBQztBQUNqQyxJQUFJLGVBQWUsR0FBRyxJQUFJLENBQUM7QUFFM0IsSUFBSSxtQkFBbUIsR0FBRyxDQUFDLENBQUM7QUFFNUIsSUFBSSxxQkFBcUIsR0FBRyxDQUFDLENBQUM7QUFFOUIsSUFBSSxlQUFlLEdBQUcsR0FBRyxDQUFDO0FBRTFCLElBQU0sY0FBYyxHQUFHLENBQUMsQ0FBQztBQUN6QixJQUFNLGNBQWMsR0FBRyxHQUFHLENBQUM7QUFDM0IsSUFBTSxhQUFhLEdBQUcsRUFBRSxDQUFDO0FBQ3pCLElBQU0sZUFBZSxHQUFHLEdBQUcsQ0FBQztBQUM1QixJQUFNLGdCQUFnQixHQUFHLEdBQUcsQ0FBQztBQUU3QixJQUFNLGFBQWEsR0FBRyxJQUFJLENBQUM7QUFDM0IsSUFBTSxjQUFjLEdBQUcsSUFBSSxDQUFDO0FBQzVCLElBQU0sb0NBQW9DLEdBQUcsK0JBQStCLENBQUM7QUFHN0UsSUFBSSxhQUFhLEdBQUcsQ0FBQyxDQUFDO0FBRXRCLElBQU0sWUFBWSxHQUFHO0lBQ25CLENBQUMsU0FBUyxFQUFFLGNBQWMsRUFBRSxjQUFjLENBQUM7SUFDM0MsQ0FBQyxVQUFVLEVBQUUsY0FBYyxFQUFFLGNBQWMsQ0FBQztJQUM1QyxDQUFDLFlBQVksRUFBRSxDQUFDLEVBQUUsZUFBZSxDQUFDO0lBQ2xDLENBQUMsaUJBQWlCLEVBQUUsQ0FBQyxFQUFFLGFBQWEsQ0FBQztDQUN0QyxDQUFDO0FBRUY7SUFDRSxJQUFJLFdBQVcsR0FBRyxDQUFDLENBQUM7SUFDcEIsR0FBRyxDQUFDLENBQXFCLFVBQVksRUFBWiw2QkFBWSxFQUFaLDBCQUFZLEVBQVosSUFBWTtRQUFoQyxJQUFNLFVBQVUscUJBQUE7UUFDbkIsSUFBTSxRQUFRLEdBQUcsVUFBVSxDQUFDLENBQUMsQ0FBVyxDQUFDO1FBQ3pDLElBQU0sUUFBUSxHQUFHLFVBQVUsQ0FBQyxDQUFDLENBQVcsQ0FBQztRQUN6QyxXQUFXLElBQUksUUFBUSxHQUFHLFFBQVEsR0FBRyxDQUFDLENBQUM7S0FDeEM7SUFDRCxNQUFNLENBQUMsV0FBVyxDQUFDO0FBQ3JCLENBQUM7QUFFRCxJQUFNLFVBQVUsR0FBRyxrQkFBa0IsRUFBRSxDQUFDO0FBQ3hDLElBQU0sVUFBVSxHQUFHLEdBQUcsQ0FBQztBQUN2QixJQUFJLFVBQVUsR0FBRyxrQkFBTSxDQUFDLEdBQUcsQ0FBQyxVQUFVLENBQUMsQ0FBQztBQUV4QyxJQUFNLFNBQVMsR0FBRyxRQUFRLENBQUMsYUFBYSxDQUFDLFdBQVcsQ0FBQyxDQUFDO0FBQ3RELElBQU0saUJBQWlCLEdBQUcsSUFBSSxrQ0FBZSxDQUFDLFNBQVMsQ0FBQyxDQUFDO0FBRXpELElBQU0sS0FBSyxHQUFHLElBQUksS0FBSyxDQUFDLEVBQUMsVUFBVSxFQUFFLENBQUMsRUFBQyxDQUFDLENBQUMsUUFBUSxFQUFFLENBQUM7QUFFcEQsSUFBTSxjQUFjLEdBQUcsOENBQThDO0lBQ2pFLG1CQUFtQixDQUFDO0FBQ3hCLElBQU0sY0FBYyxHQUFHLEdBQUcsQ0FBQztBQUUzQixJQUFNLGlCQUFpQixHQUFHLFNBQVMsQ0FBQyxnQkFBZ0IsRUFBRSxJQUFJLENBQUMsU0FBUyxDQUFDLFFBQVEsRUFBRSxDQUFDO0FBRWhGLEVBQUUsQ0FBQyxDQUFDLENBQUMsaUJBQWlCLENBQUMsQ0FBQyxDQUFDO0lBQ3ZCLFFBQVEsQ0FBQyxhQUFhLENBQUMsU0FBUyxDQUFDLENBQUMsU0FBUztRQUN2Qyw2REFBNkQ7WUFDN0QsdUVBQXVFLENBQUM7QUFDOUUsQ0FBQztBQUFDLElBQUksQ0FBQyxDQUFDO0lBQ04sS0FBSyxFQUFFLENBQUM7QUFDVixDQUFDO0FBRUQsSUFBTSxJQUFJLEdBQUcsSUFBSSwwQkFBYyxFQUFFLENBQUM7QUFFbEM7SUFDRSxLQUFLLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQztTQUNyQixJQUFJLENBQUM7UUFDSixJQUFNLE1BQU0sR0FBRyxJQUFJLDRCQUFnQixDQUFDLGNBQWMsQ0FBQyxDQUFDO1FBQ3BELE1BQU0sQ0FBQyxNQUFNLENBQUMsZUFBZSxFQUFFLENBQUM7SUFDbEMsQ0FBQyxDQUFDO1NBQ0QsSUFBSSxDQUFDLFVBQUMsSUFBa0M7UUFDdkMsUUFBUSxDQUFDLGFBQWEsQ0FBQyxTQUFTLENBQUMsQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxDQUFDO1FBQzFELFFBQVEsQ0FBQyxhQUFhLENBQUMsV0FBVyxDQUFDLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUMvRCxRQUFRLENBQUMsYUFBYSxDQUFDLFdBQVcsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLENBQUM7UUFFL0QsV0FBVztZQUNQLElBQUksQ0FBQyxrREFBa0QsQ0FBWSxDQUFDO1FBQ3hFLFNBQVM7WUFDTCxJQUFJLENBQUMsZ0RBQWdELENBQVksQ0FBQztRQUV0RSxXQUFXO1lBQ1AsSUFBSSxDQUFDLGtEQUFrRCxDQUFZLENBQUM7UUFDeEUsU0FBUztZQUNMLElBQUksQ0FBQyxnREFBZ0QsQ0FBWSxDQUFDO1FBRXRFLFdBQVc7WUFDUCxJQUFJLENBQUMsa0RBQWtELENBQVksQ0FBQztRQUN4RSxTQUFTO1lBQ0wsSUFBSSxDQUFDLGdEQUFnRCxDQUFZLENBQUM7UUFFdEUsb0JBQW9CLEdBQUcsSUFBSSxDQUFDLHdCQUF3QixDQUFZLENBQUM7UUFDakUscUJBQXFCLEdBQUcsSUFBSSxDQUFDLHlCQUF5QixDQUFZLENBQUM7UUFDbkUsUUFBUSxFQUFFLENBQUM7SUFDYixDQUFDLENBQUMsQ0FBQztBQUNULENBQUM7QUFFRDtJQUNFLENBQUMsR0FBRztRQUNGLG1CQUFPLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxFQUFFLFNBQVMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7UUFDMUMsbUJBQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEVBQUUsU0FBUyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztRQUMxQyxtQkFBTyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsRUFBRSxTQUFTLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO0tBQzNDLENBQUM7SUFDRixDQUFDLEdBQUc7UUFDRixtQkFBTyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsRUFBRSxTQUFTLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1FBQzFDLG1CQUFPLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxFQUFFLFNBQVMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7UUFDMUMsbUJBQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEVBQUUsU0FBUyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztLQUMzQyxDQUFDO0lBQ0YsRUFBRSxDQUFDLENBQUMsVUFBVSxJQUFJLElBQUksQ0FBQyxDQUFDLENBQUM7UUFDdkIsVUFBVSxDQUFDLE9BQU8sRUFBRSxDQUFDO0lBQ3ZCLENBQUM7SUFDRCxVQUFVLEdBQUcsa0JBQU0sQ0FBQyxHQUFHLENBQUMsVUFBVSxDQUFDLENBQUM7SUFDcEMsbUJBQW1CLEdBQUcsS0FBSyxDQUFDLEdBQUcsRUFBRSxDQUFDO0lBQ2xDLHFCQUFxQixHQUFHLFdBQVcsQ0FBQyxHQUFHLEVBQUUsR0FBRyxtQkFBbUIsR0FBRyxJQUFJLENBQUM7SUFDdkUsYUFBYSxFQUFFLENBQUM7SUFDaEIsWUFBWSxDQUFDLGFBQWEsQ0FBQyxDQUFDO0FBQzlCLENBQUM7QUFFRCxNQUFNLENBQUMsZ0JBQWdCLENBQUMsUUFBUSxFQUFFLE1BQU0sQ0FBQyxDQUFDO0FBRTFDO0lBQ0UsaUJBQWlCLENBQUMsTUFBTSxFQUFFLENBQUM7QUFDN0IsQ0FBQztBQUVELE1BQU0sRUFBRSxDQUFDO0FBRVQsSUFBTSxjQUFjLEdBQ2hCLFFBQVEsQ0FBQyxjQUFjLENBQUMsY0FBYyxDQUFxQixDQUFDO0FBQ2hFLElBQU0sY0FBYyxHQUFHLFFBQVEsQ0FBQyxjQUFjLENBQUMsc0JBQXNCLENBQUMsQ0FBQztBQUN2RSxJQUFNLG1CQUFtQixHQUNyQixRQUFRLENBQUMsY0FBYyxDQUFDLGtCQUFrQixDQUFxQixDQUFDO0FBQ3BFLG1CQUFtQixDQUFDLFFBQVEsR0FBRyx3QkFBd0IsQ0FBQztBQUN4RCxJQUFNLGtCQUFrQixHQUNwQixRQUFRLENBQUMsY0FBYyxDQUFDLGlCQUFpQixDQUFxQixDQUFDO0FBQ25FLGtCQUFrQixDQUFDLFFBQVEsR0FBRyx3QkFBd0IsQ0FBQztBQUN2RCxJQUFNLHdCQUF3QixHQUMxQixRQUFRLENBQUMsY0FBYyxDQUFDLHVCQUF1QixDQUFtQixDQUFDO0FBRXZFLElBQU0saUJBQWlCLEdBQUcsUUFBUSxDQUFDLGNBQWMsQ0FBQyxNQUFNLENBQXFCLENBQUM7QUFDOUUsSUFBTSxrQkFBa0IsR0FDcEIsUUFBUSxDQUFDLGNBQWMsQ0FBQyxjQUFjLENBQW9CLENBQUM7QUFDL0QsSUFBSSxVQUFVLEdBQUcsQ0FBQyxpQkFBaUIsQ0FBQyxLQUFLLENBQUM7QUFDMUMsa0JBQWtCLENBQUMsU0FBUyxHQUFHLFVBQVUsQ0FBQyxRQUFRLEVBQUUsQ0FBQztBQUNyRCxpQkFBaUIsQ0FBQyxnQkFBZ0IsQ0FBQyxPQUFPLEVBQUU7SUFDMUMsVUFBVSxHQUFHLENBQUMsaUJBQWlCLENBQUMsS0FBSyxDQUFDO0lBQ3RDLGtCQUFrQixDQUFDLFNBQVMsR0FBRyxVQUFVLENBQUMsUUFBUSxFQUFFLENBQUM7QUFDdkQsQ0FBQyxDQUFDLENBQUM7QUFFSCxJQUFNLHNCQUFzQixHQUFHO0lBQzdCLFFBQVEsQ0FBQyxjQUFjLENBQUMsU0FBUyxDQUFDO0lBQ2xDLFFBQVEsQ0FBQyxjQUFjLENBQUMsVUFBVSxDQUFDO0lBQ25DLFFBQVEsQ0FBQyxjQUFjLENBQUMsU0FBUyxDQUFDO0lBQ2xDLFFBQVEsQ0FBQyxjQUFjLENBQUMsVUFBVSxDQUFDO0lBQ25DLFFBQVEsQ0FBQyxjQUFjLENBQUMsU0FBUyxDQUFDO0lBQ2xDLFFBQVEsQ0FBQyxjQUFjLENBQUMsU0FBUyxDQUFDO0lBQ2xDLFFBQVEsQ0FBQyxjQUFjLENBQUMsVUFBVSxDQUFDO0lBQ25DLFFBQVEsQ0FBQyxjQUFjLENBQUMsU0FBUyxDQUFDO0lBQ2xDLFFBQVEsQ0FBQyxjQUFjLENBQUMsVUFBVSxDQUFDO0lBQ25DLFFBQVEsQ0FBQyxjQUFjLENBQUMsU0FBUyxDQUFDO0lBQ2xDLFFBQVEsQ0FBQyxjQUFjLENBQUMsVUFBVSxDQUFDO0lBQ25DLFFBQVEsQ0FBQyxjQUFjLENBQUMsU0FBUyxDQUFDO0NBQ2IsQ0FBQztBQUV4QixJQUFJLE9BQU8sR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7QUFDbkQsSUFBSSxPQUFPLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO0FBRW5ELElBQUksQ0FBQztJQUNILFNBQVMsRUFBRSxDQUFDO0FBQ2QsQ0FBQztBQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFFWCxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ2xCLENBQUM7QUFFRDtJQUNFLEVBQUUsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO1FBQzFCLE1BQU0sQ0FBQztJQUNULENBQUM7SUFDRCxJQUFNLE1BQU0sR0FBRyxNQUFNLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQ3pELGNBQWMsQ0FBQyxLQUFLLEdBQUcsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ2pDLElBQU0sT0FBTyxHQUFHLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDckMsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxzQkFBc0IsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQztRQUN2RCxzQkFBc0IsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLEdBQUcsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQy9DLENBQUM7SUFDRCxJQUFNLGFBQWEsR0FBRyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQzNDLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsT0FBTyxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRSxDQUFDO1FBQ3hDLE9BQU8sQ0FBQyxDQUFDLENBQUMsR0FBRyxRQUFRLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDO0lBQzlDLENBQUM7SUFDRCxJQUFNLGFBQWEsR0FBRyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQzNDLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsT0FBTyxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRSxDQUFDO1FBQ3hDLE9BQU8sQ0FBQyxDQUFDLENBQUMsR0FBRyxRQUFRLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDO0lBQzlDLENBQUM7SUFDRCxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDOUIsbUJBQW1CLENBQUMsT0FBTyxHQUFHLElBQUksQ0FBQztJQUNyQyxDQUFDO0lBQUMsSUFBSSxDQUFDLENBQUM7UUFDTixrQkFBa0IsQ0FBQyxPQUFPLEdBQUcsSUFBSSxDQUFDO0lBQ3BDLENBQUM7QUFDSCxDQUFDO0FBRUQ7SUFDRSxJQUFNLGNBQWMsR0FBRyxzQkFBc0IsQ0FBQyxHQUFHLENBQUMsVUFBQyxDQUFDO1FBQ2xELE1BQU0sQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLEtBQUssRUFBRSxFQUFFLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDcEMsQ0FBQyxDQUFDLENBQUM7SUFFSCxFQUFFLENBQUMsQ0FBQyxtQkFBbUIsS0FBSyxTQUFTLENBQUMsQ0FBQyxDQUFDO1FBQ3RDLG1CQUFtQixDQUFDLE9BQU8sRUFBRSxDQUFDO1FBQzlCLG1CQUFtQixHQUFHLFNBQVMsQ0FBQztJQUNsQyxDQUFDO0lBRUQsRUFBRSxDQUFDLENBQUMsbUJBQW1CLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQztRQUNoQyxlQUFlLEdBQUcsSUFBSSxDQUFDO1FBQ3ZCLHdCQUF3QixDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsVUFBVSxDQUFDLENBQUM7SUFDckQsQ0FBQztJQUFDLElBQUksQ0FBQyxDQUFDO1FBQ04sZUFBZSxHQUFHLEtBQUssQ0FBQztRQUN4Qix3QkFBd0IsQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxDQUFDO0lBQ3hELENBQUM7SUFFRCxNQUFNLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FDbEIsR0FBRyxHQUFHLGNBQWMsQ0FBQyxLQUFLLEdBQUcsR0FBRyxHQUFHLGNBQWMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsR0FBRztRQUNqRSxPQUFPLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLEdBQUcsR0FBRyxPQUFPLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLEdBQUc7UUFDakQsQ0FBQyxlQUFlLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztJQUVuQyxJQUFNLGNBQWMsR0FBRyxRQUFRLENBQUMsY0FBYyxDQUFDLEtBQUssRUFBRSxFQUFFLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDL0QsSUFBTSxXQUFXLEdBQUcsa0JBQWtCLENBQUMsY0FBYyxDQUFDLENBQUM7SUFDdkQsY0FBYyxDQUFDLFNBQVMsR0FBRyxXQUFXLENBQUMsUUFBUSxFQUFFLENBQUM7SUFDbEQsbUJBQW1CLEdBQUcsbUJBQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQyxrQkFBa0IsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUNyRSxtQkFBbUIsQ0FBQyxHQUFHLENBQUMsR0FBRyxFQUFFLGNBQWMsR0FBRyxDQUFDLENBQUMsQ0FBQztJQUVqRCxFQUFFLENBQUMsQ0FBQyxzQkFBc0IsS0FBSyxTQUFTLENBQUMsQ0FBQyxDQUFDO1FBQ3pDLHNCQUFzQixDQUFDLE9BQU8sRUFBRSxDQUFDO1FBQ2pDLHNCQUFzQixHQUFHLFNBQVMsQ0FBQztJQUNyQyxDQUFDO0lBQ0Qsc0JBQXNCLEdBQUcsbUJBQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQyxvQkFBb0IsQ0FBQyxDQUFDLENBQUM7SUFDL0QsSUFBTSxtQkFBbUIsR0FBRyxjQUFjLENBQUMsTUFBTSxDQUFDLFVBQUMsSUFBSSxFQUFFLEdBQUc7UUFDMUQsTUFBTSxDQUFDLElBQUksR0FBRyxHQUFHLENBQUM7SUFDcEIsQ0FBQyxDQUFDLENBQUM7SUFDSCxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLG9CQUFvQixFQUFFLENBQUMsRUFBRSxFQUFFLENBQUM7UUFDOUMsc0JBQXNCLENBQUMsR0FBRyxDQUFDLGNBQWMsQ0FBQyxDQUFDLENBQUMsR0FBRyxtQkFBbUIsRUFBRSxDQUFDLENBQUMsQ0FBQztJQUN6RSxDQUFDO0FBQ0gsQ0FBQztBQUVELFFBQVEsQ0FBQyxjQUFjLENBQUMsY0FBYyxDQUFDLENBQUMsT0FBTyxHQUFHLHdCQUF3QixDQUFDO0FBQzNFLHNCQUFzQixDQUFDLEdBQUcsQ0FBQyxVQUFDLENBQUM7SUFDM0IsQ0FBQyxDQUFDLE9BQU8sR0FBRyx3QkFBd0IsQ0FBQztBQUN2QyxDQUFDLENBQUMsQ0FBQztBQUNILHdCQUF3QixFQUFFLENBQUM7QUFFM0IsOEJBQThCLE9BQWlCO0lBQzdDLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsT0FBTyxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRSxDQUFDO1FBQ3hDLHNCQUFzQixDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssR0FBRyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxFQUFFLENBQUM7SUFDMUQsQ0FBQztJQUNELHdCQUF3QixFQUFFLENBQUM7QUFDN0IsQ0FBQztBQUVELFFBQVEsQ0FBQyxjQUFjLENBQUMsU0FBUyxDQUFDLENBQUMsT0FBTyxHQUFHO0lBQzNDLG9CQUFvQixDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQzdELENBQUMsQ0FBQztBQUVGLFFBQVEsQ0FBQyxjQUFjLENBQUMsU0FBUyxDQUFDLENBQUMsT0FBTyxHQUFHO0lBQzNDLG9CQUFvQixDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQzdELENBQUMsQ0FBQztBQUVGLFFBQVEsQ0FBQyxjQUFjLENBQUMsU0FBUyxDQUFDLENBQUMsT0FBTyxHQUFHO0lBQzNDLG9CQUFvQixDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQzdELENBQUMsQ0FBQztBQUVGLFFBQVEsQ0FBQyxjQUFjLENBQUMsWUFBWSxDQUFDLENBQUMsT0FBTyxHQUFHO0lBQzlDLG9CQUFvQixDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQzdELENBQUMsQ0FBQztBQUVGLFFBQVEsQ0FBQyxjQUFjLENBQUMsWUFBWSxDQUFDLENBQUMsT0FBTyxHQUFHO0lBQzlDLG9CQUFvQixDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQzdELENBQUMsQ0FBQztBQUVGLFFBQVEsQ0FBQyxjQUFjLENBQUMsV0FBVyxDQUFDLENBQUMsT0FBTyxHQUFHO0lBQzdDLFFBQVEsRUFBRSxDQUFDO0FBQ2IsQ0FBQyxDQUFDO0FBRUYsUUFBUSxDQUFDLGNBQWMsQ0FBQyxVQUFVLENBQUMsQ0FBQyxPQUFPLEdBQUc7SUFDNUMsb0JBQW9CLENBQUMsT0FBTyxDQUFDLENBQUM7QUFDaEMsQ0FBQyxDQUFDO0FBRUYsUUFBUSxDQUFDLGNBQWMsQ0FBQyxVQUFVLENBQUMsQ0FBQyxPQUFPLEdBQUc7SUFDNUMsb0JBQW9CLENBQUMsT0FBTyxDQUFDLENBQUM7QUFDaEMsQ0FBQyxDQUFDO0FBRUYsUUFBUSxDQUFDLGNBQWMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxPQUFPLEdBQUc7SUFDMUMsT0FBTyxHQUFHLHNCQUFzQixDQUFDLEdBQUcsQ0FBQyxVQUFDLENBQUM7UUFDckMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsS0FBSyxFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUNwQyxDQUFDLENBQUMsQ0FBQztJQUNILHdCQUF3QixFQUFFLENBQUM7QUFDN0IsQ0FBQyxDQUFDO0FBRUYsUUFBUSxDQUFDLGNBQWMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxPQUFPLEdBQUc7SUFDMUMsT0FBTyxHQUFHLHNCQUFzQixDQUFDLEdBQUcsQ0FBQyxVQUFDLENBQUM7UUFDckMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsS0FBSyxFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUNwQyxDQUFDLENBQUMsQ0FBQztJQUNILHdCQUF3QixFQUFFLENBQUM7QUFDN0IsQ0FBQyxDQUFDO0FBc0JGLHNCQUE0QixNQUFjOzs7Ozs7b0JBQ3hDLEVBQUUsQ0FBQyxDQUFDLE1BQU0sR0FBRyxhQUFhLENBQUMsQ0FBQyxDQUFDO3dCQUUzQixNQUFNLEtBQUM7b0JBQ1QsQ0FBQztvQkFDRCxXQUFNLElBQUksQ0FBQyxLQUFLLENBQUMsVUFBTyxJQUFJLEVBQUUsS0FBSzs7Ozs7d0NBQzNCLEtBQUssR0FDUCxJQUFJLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsVUFBVSxFQUFFLFdBQVcsRUFBRSxTQUFTLENBQUMsQ0FBQzt3Q0FDaEUsS0FBSyxHQUNQLElBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxVQUFVLEVBQUUsV0FBVyxFQUFFLFNBQVMsQ0FBQyxDQUFDO3dDQUNoRSxLQUFLLEdBQ1AsSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLFVBQVUsRUFBRSxXQUFXLEVBQUUsU0FBUyxDQUFDLENBQUM7d0NBRXRFLENBQUMsQ0FBQyxHQUFHLENBQUMsVUFBQSxHQUFHOzRDQUNQLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQzt3Q0FDYixDQUFDLENBQUMsQ0FBQzt3Q0FDSCxDQUFDLENBQUMsR0FBRyxDQUFDLFVBQUEsR0FBRzs0Q0FDUCxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUM7d0NBQ2IsQ0FBQyxDQUFDLENBQUM7d0NBQ0csT0FBTyxHQUFhLEVBQUUsQ0FBQzt3Q0FFN0IsR0FBRyxDQUFDLENBQUssQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsdUJBQXVCLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQzs0Q0FFM0MsVUFBVSxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsVUFBVSxDQUFDLElBQUksRUFBRSxFQUFFLFVBQVUsQ0FBQyxDQUFDLElBQUksRUFBRSxDQUFDOzRDQUdyRSxFQUFFLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztnREFDWixVQUFVLENBQUMsT0FBTyxFQUFFLENBQUM7NENBQ3ZCLENBQUM7NENBRUssS0FBSyxHQUFHLFVBQVUsQ0FBQzs0Q0FDbkIsTUFBTSxHQUNSLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQyxLQUFLLEVBQUUsS0FBSyxFQUFFLEtBQUssQ0FBQyxFQUFFLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDOzRDQUN0RSxDQUFDLEdBQUcsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDOzRDQUNkLENBQUMsR0FBRyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUM7NENBRVIsT0FBTyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQzs0Q0FDZixjQUFjLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxPQUFPLEVBQUUscUJBQXFCLENBQUMsQ0FBQzs0Q0FDN0QsTUFBTSxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsY0FBYyxFQUFFLG9CQUFvQixDQUFDLENBQUM7NENBRXhELE9BQU8sR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxJQUFJLEVBQUUsQ0FBQyxDQUFDOzRDQUN0QyxhQUFhLEdBQUcsSUFBSSxDQUFDLFdBQVcsQ0FBQyxPQUFPLEVBQUUsQ0FBQyxDQUFDLENBQUMsUUFBUSxFQUFFLENBQUM7NENBQzlELE9BQU8sQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLENBQUM7NENBQzVCLElBQUksQ0FBQyxhQUFhLENBQUMsQ0FBQzs0Q0FDcEIsVUFBVSxHQUFHLGFBQWEsQ0FBQzt3Q0FDN0IsQ0FBQzt3Q0FFRCxDQUFDLENBQUMsR0FBRyxDQUFDLFVBQUEsR0FBRzs0Q0FDUCxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7d0NBQ1osQ0FBQyxDQUFDLENBQUM7d0NBQ0gsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxVQUFBLEdBQUc7NENBQ1AsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO3dDQUNaLENBQUMsQ0FBQyxDQUFDO3dDQUVILFdBQU0sT0FBTyxDQUFDLE9BQU8sQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLENBQUMsSUFBSSxFQUFFLEVBQUE7O3dDQUF4QyxTQUF3QyxDQUFDO3dDQUVoQyxDQUFDLEdBQUcsQ0FBQzs7OzZDQUFFLENBQUEsQ0FBQyxHQUFHLE9BQU8sQ0FBQyxNQUFNLENBQUE7d0NBQ2hDLEtBQUEsVUFBVSxDQUFBO3dDQUFDLFdBQU0sT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxFQUFBOzt3Q0FBakMsa0JBQVcsU0FBc0IsRUFBQyxDQUFDOzs7d0NBREQsQ0FBQyxFQUFFLENBQUE7Ozt3Q0FNdkMsVUFBVSxDQUFDLFVBQVUsRUFBRSxDQUFDO3dDQUV4QixFQUFFLENBQUMsQ0FBQyxLQUFLLENBQUMsR0FBRyxFQUFFLEdBQUcsbUJBQW1CLEdBQUcsMEJBQTBCLENBQUMsQ0FBQyxDQUFDOzRDQUNuRSxPQUFPLENBQUMsSUFBSSxDQUNSLG9CQUNJLEtBQUssQ0FBQyxHQUFHLEVBQUUsR0FBRyxtQkFBbUIsdUJBQW1CO2lEQUN4RCxtQkFBaUIseUJBQXlCLHNCQUFtQixDQUFBLENBQUMsQ0FBQzs0Q0FDbkUsbUJBQW1CLEdBQUcsS0FBSyxDQUFDLEdBQUcsRUFBRSxDQUFDO3dDQUNwQyxDQUFDO3dDQUNLLEtBQUssR0FBRyxJQUFJLENBQUMsR0FBRyxDQUNsQixDQUFDLEVBQUUsbUJBQW1CLEdBQUcsS0FBSyxDQUFDLEdBQUcsRUFBRSxHQUFHLHlCQUF5QixDQUFDLENBQUM7d0NBQ3RFLFVBQVUsQ0FBQyxjQUFNLE9BQUEsWUFBWSxDQUFDLE1BQU0sQ0FBQyxFQUFwQixDQUFvQixFQUFFLEtBQUssR0FBRyxJQUFJLENBQUMsQ0FBQzs7Ozs2QkFDdEQsQ0FBQyxFQUFBOztvQkFyRUYsU0FxRUUsQ0FBQzs7Ozs7Q0FDSjtBQUVELElBQUksSUFBSSxDQUFDO0FBRVQsSUFBSSxZQUFZLEdBQVEsSUFBSSxDQUFDO0FBQzdCLENBQUM7Ozs7O2dCQUNPLHdCQUF3QixHQUMxQixRQUFRLENBQUMsY0FBYyxDQUFDLG9CQUFvQixDQUFDLENBQUM7Ozs7Z0JBRzFDLGNBQWlCLE1BQU0sQ0FBQyxTQUFTLENBQUM7Z0JBQ2pDLFdBQU0sV0FBUyxDQUFDLGlCQUFpQixFQUFFLEVBQUE7O2dCQUExQyxJQUFJLEdBQUcsU0FBbUMsQ0FBQztnQkFFckMsb0JBQ0YsUUFBUSxDQUFDLGNBQWMsQ0FBQyxVQUFVLENBQXNCLENBQUM7Z0JBRXpELFVBQVEsQ0FBQyxDQUFDO2dCQUVSLGdCQUFxQixFQUFFLENBQUM7Z0JBRTlCLElBQUksQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLFVBQUMsTUFBVztvQkFDL0IsT0FBTyxDQUFDLEdBQUcsQ0FBQyw0Q0FDcUIsTUFBTSxDQUFDLElBQUksMEJBQ2xDLE1BQU0sQ0FBQyxFQUFFLGtDQUNDLE1BQU0sQ0FBQyxZQUFZLHlCQUM1QixNQUFNLENBQUMsSUFBSSw2QkFDUCxNQUFNLENBQUMsT0FBUyxDQUFDLENBQUM7b0JBQ2pDLGFBQVcsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7b0JBRXpCLElBQU0sTUFBTSxHQUFHLFFBQVEsQ0FBQyxhQUFhLENBQUMsUUFBUSxDQUFDLENBQUM7b0JBQ2hELE1BQU0sQ0FBQyxTQUFTLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQztvQkFDL0IsaUJBQWUsQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUFDLENBQUM7b0JBQ3BDLE9BQUssRUFBRSxDQUFDO2dCQUNWLENBQUMsQ0FBQyxDQUFDO2dCQUVILGlCQUFlLENBQUMsZ0JBQWdCLENBQUMsUUFBUSxFQUFFO29CQUN6QyxZQUFZLEdBQUcsYUFBVyxDQUFDLGlCQUFlLENBQUMsYUFBYSxDQUFDLENBQUM7Z0JBQzVELENBQUMsQ0FBQyxDQUFDO2dCQUVILEVBQUUsQ0FBQyxDQUFDLE9BQUssR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDO29CQUNkLFlBQVksR0FBRyxhQUFXLENBQUMsQ0FBQyxDQUFDLENBQUM7Z0JBQ2hDLENBQUM7Z0JBQUMsSUFBSSxDQUFDLENBQUM7b0JBQ04sd0JBQXdCLENBQUMsU0FBUyxHQUFHLG9DQUFvQyxDQUFDO2dCQUM1RSxDQUFDOzs7O2dCQUVELHdCQUF3QixDQUFDLFNBQVMsR0FBRyxvQ0FBb0MsQ0FBQztnQkFFMUUsSUFBSSxHQUFHLElBQUksQ0FBQzs7Ozs7S0FFZixDQUFDLEVBQUUsQ0FBQztBQUtMLG9CQUFvQixLQUFhO0lBQy9CLElBQUksTUFBTSxHQUFHLENBQUMsQ0FBQzs0QkFDSixVQUFVO1FBQ25CLElBQU0sU0FBUyxHQUFHLFVBQVUsQ0FBQyxDQUFDLENBQVcsQ0FBQztRQUMxQyxJQUFNLFFBQVEsR0FBRyxVQUFVLENBQUMsQ0FBQyxDQUFXLENBQUM7UUFDekMsSUFBTSxRQUFRLEdBQUcsVUFBVSxDQUFDLENBQUMsQ0FBVyxDQUFDO1FBQ3pDLEVBQUUsQ0FBQyxDQUFDLE1BQU0sSUFBSSxLQUFLLElBQUksS0FBSyxJQUFJLE1BQU0sR0FBRyxRQUFRLEdBQUcsUUFBUSxDQUFDLENBQUMsQ0FBQztZQUM3RCxFQUFFLENBQUMsQ0FBQyxTQUFTLEtBQUssU0FBUyxDQUFDLENBQUMsQ0FBQztnQkFDNUIsSUFBTSxTQUFPLEdBQUcsS0FBSyxHQUFHLE1BQU0sQ0FBQztnQkFDL0IsVUFBVSxDQUFDO29CQUNULGlCQUFpQixDQUFDLE9BQU8sQ0FBQyxTQUFPLENBQUMsQ0FBQztvQkFDbkMsVUFBVSxDQUFDO3dCQUNULGlCQUFpQixDQUFDLEtBQUssQ0FBQyxTQUFPLENBQUMsQ0FBQztvQkFDbkMsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxDQUFDO2dCQUNWLENBQUMsRUFBRSxDQUFDLG1CQUFtQixHQUFHLEtBQUssQ0FBQyxHQUFHLEVBQUUsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDO2dCQUMvQyxXQUFXLENBQUMsR0FBRyxDQUFDLFNBQU8sRUFBRSxtQkFBbUIsQ0FBQyxDQUFDO2dCQUU5QyxFQUFFLENBQUMsQ0FBQyxZQUFZLElBQUksSUFBSSxDQUFDLENBQUMsQ0FBQztvQkFDekIsWUFBWSxDQUFDLElBQUksQ0FDYixDQUFDLGFBQWEsRUFBRSxTQUFPLEVBQUUsZUFBZSxHQUFHLFVBQVUsQ0FBQyxFQUN0RCxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksR0FBRyxtQkFBbUIsQ0FBQyxHQUFHLHFCQUFxQixDQUFDLENBQUM7Z0JBQ3RFLENBQUM7Z0NBRU0sS0FBSyxDQUFDLE9BQU8sQ0FDaEIsU0FBTyxFQUFFLG1CQUFtQixFQUFFLGVBQWUsR0FBRyxVQUFVLEdBQUcsR0FBRyxDQUFDO1lBQ3ZFLENBQUM7WUFBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsU0FBUyxLQUFLLFVBQVUsQ0FBQyxDQUFDLENBQUM7Z0JBQ3BDLElBQU0sT0FBTyxHQUFHLEtBQUssR0FBRyxNQUFNLENBQUM7Z0JBRS9CLElBQU0sb0JBQW9CLEdBQUcsV0FBVyxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsQ0FBQztnQkFHdEQsRUFBRSxDQUFDLENBQUMsb0JBQW9CLElBQUksSUFBSSxDQUFDLENBQUMsQ0FBQzs7Z0JBRW5DLENBQUM7Z0JBQ0QsSUFBTSxPQUFPLEdBQ1QsSUFBSSxDQUFDLEdBQUcsQ0FBQyxtQkFBbUIsRUFBRSxvQkFBb0IsR0FBRyxFQUFFLENBQUMsQ0FBQztnQkFFN0QsRUFBRSxDQUFDLENBQUMsWUFBWSxJQUFJLElBQUksQ0FBQyxDQUFDLENBQUM7b0JBQ3pCLFlBQVksQ0FBQyxJQUFJLENBQ2IsQ0FBQyxjQUFjLEVBQUUsT0FBTyxFQUFFLGVBQWUsR0FBRyxVQUFVLENBQUMsRUFDdkQsSUFBSSxDQUFDLEtBQUssQ0FBQyxPQUFPLEdBQUcsSUFBSSxDQUFDLEdBQUcscUJBQXFCLENBQUMsQ0FBQztnQkFDMUQsQ0FBQztnQkFDRCxLQUFLLENBQUMsS0FBSyxDQUFDLE9BQU8sRUFBRSxPQUFPLENBQUMsQ0FBQztnQkFDOUIsV0FBVyxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsQ0FBQzs7WUFFOUIsQ0FBQztZQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQyxTQUFTLEtBQUssWUFBWSxDQUFDLENBQUMsQ0FBQztnQkFDdEMsbUJBQW1CLElBQUksQ0FBQyxLQUFLLEdBQUcsTUFBTSxHQUFHLENBQUMsQ0FBQyxHQUFHLGdCQUFnQixDQUFDO2dCQUMvRCxXQUFXLENBQUMsT0FBTyxDQUFDLFVBQUMsT0FBTyxFQUFFLE9BQU87b0JBQ25DLEVBQUUsQ0FBQyxDQUFDLG1CQUFtQixHQUFHLE9BQU8sR0FBRyx5QkFBeUIsQ0FBQyxDQUFDLENBQUM7d0JBQzlELE9BQU8sQ0FBQyxJQUFJLENBQ1IsVUFBUSxPQUFPLDhCQUNYLG1CQUFtQixHQUFHLE9BQU8sUUFBSTs2QkFDckMsMkJBQXlCLHlCQUF5QixZQUFTLENBQUE7NEJBQzNELFVBQVUsQ0FBQyxDQUFDO3dCQUNoQixFQUFFLENBQUMsQ0FBQyxZQUFZLElBQUksSUFBSSxDQUFDLENBQUMsQ0FBQzs0QkFDekIsWUFBWSxDQUFDLElBQUksQ0FDYixDQUFDLGNBQWMsRUFBRSxPQUFPLEVBQUUsZUFBZSxHQUFHLFVBQVUsQ0FBQyxDQUFDLENBQUM7d0JBQy9ELENBQUM7d0JBQ0QsS0FBSyxDQUFDLEtBQUssQ0FBQyxPQUFPLEVBQUUsbUJBQW1CLENBQUMsQ0FBQzt3QkFDMUMsV0FBVyxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsQ0FBQztvQkFDOUIsQ0FBQztnQkFDSCxDQUFDLENBQUMsQ0FBQztnQ0FDSSxtQkFBbUI7WUFDNUIsQ0FBQztZQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQyxTQUFTLEtBQUssaUJBQWlCLENBQUMsQ0FBQyxDQUFDO2dCQUMzQyxlQUFlLEdBQUcsQ0FBQyxLQUFLLEdBQUcsTUFBTSxHQUFHLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxHQUFHLGFBQWEsQ0FBQyxDQUFDO2dCQUN4RSxlQUFlLEdBQUcsZUFBZSxHQUFHLEdBQUcsQ0FBQztnQ0FDakMsZUFBZTtZQUN4QixDQUFDO1lBQUMsSUFBSSxDQUFDLENBQUM7Z0JBQ04sTUFBTSxJQUFJLEtBQUssQ0FBQyw4QkFBOEIsR0FBRyxTQUFTLENBQUMsQ0FBQztZQUM5RCxDQUFDO1FBQ0gsQ0FBQztRQUNELE1BQU0sSUFBSSxRQUFRLEdBQUcsUUFBUSxHQUFHLENBQUMsQ0FBQztJQUNwQyxDQUFDO0lBdEVELEdBQUcsQ0FBQyxDQUFxQixVQUFZLEVBQVosNkJBQVksRUFBWiwwQkFBWSxFQUFaLElBQVk7UUFBaEMsSUFBTSxVQUFVLHFCQUFBOzhCQUFWLFVBQVU7OztLQXNFcEI7SUFDRCxNQUFNLElBQUksS0FBSyxDQUFDLDZCQUEyQixLQUFPLENBQUMsQ0FBQztBQUN0RCxDQUFDOzs7OztBQy9pQkQsdUNBQXlDO0FBRXpDO0lBQ0UsSUFBSSxDQUFDO1FBQ0gsSUFBTSxJQUFJLEdBQUcsSUFBSSwwQkFBYyxFQUFFLENBQUM7UUFDbEMsSUFBSSxDQUFDLE9BQU8sRUFBRSxDQUFDO1FBQ2YsTUFBTSxDQUFDLElBQUksQ0FBQztJQUNkLENBQUM7SUFBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ1gsTUFBTSxDQUFDLEtBQUssQ0FBQztJQUNmLENBQUM7QUFDSCxDQUFDO0FBUkQsNENBUUM7QUFFRDtJQUNFLElBQU0sRUFBRSxHQUFHLFNBQVMsQ0FBQyxTQUFTLENBQUMsV0FBVyxFQUFFLENBQUM7SUFDN0MsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDaEMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDOUIsTUFBTSxDQUFDLEtBQUssQ0FBQztRQUNmLENBQUM7UUFBQyxJQUFJLENBQUMsQ0FBQztZQUNOLE1BQU0sQ0FBQyxJQUFJLENBQUM7UUFDZCxDQUFDO0lBQ0gsQ0FBQztJQUNELE1BQU0sQ0FBQyxLQUFLLENBQUM7QUFDZixDQUFDO0FBVkQsNEJBVUM7QUFFRDtJQUVFLElBQU0sQ0FBQyxHQUFHLFNBQVMsQ0FBQyxTQUFTLElBQUksU0FBUyxDQUFDLE1BQU0sSUFBSyxNQUFjLENBQUMsS0FBSyxDQUFDO0lBRTNFLE1BQU0sQ0FBQywwVEFBMFQ7U0FDclQsSUFBSSxDQUFDLENBQUMsQ0FBQztRQUVmLHlrREFBeWtEO2FBQ3BrRCxJQUFJLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNoQyxDQUFDO0FBVEQsNEJBU0MiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwiIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgbmRhcnJheV8xID0gcmVxdWlyZShcIi4uL21hdGgvbmRhcnJheVwiKTtcbnZhciBNQU5JRkVTVF9GSUxFID0gJ21hbmlmZXN0Lmpzb24nO1xudmFyIENoZWNrcG9pbnRMb2FkZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENoZWNrcG9pbnRMb2FkZXIodXJsUGF0aCkge1xuICAgICAgICB0aGlzLnVybFBhdGggPSB1cmxQYXRoO1xuICAgICAgICBpZiAodGhpcy51cmxQYXRoLmNoYXJBdCh0aGlzLnVybFBhdGgubGVuZ3RoIC0gMSkgIT09ICcvJykge1xuICAgICAgICAgICAgdGhpcy51cmxQYXRoICs9ICcvJztcbiAgICAgICAgfVxuICAgIH1cbiAgICBDaGVja3BvaW50TG9hZGVyLnByb3RvdHlwZS5sb2FkTWFuaWZlc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgICAgICB4aHIub3BlbignR0VUJywgX3RoaXMudXJsUGF0aCArIE1BTklGRVNUX0ZJTEUpO1xuICAgICAgICAgICAgeGhyLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5jaGVja3BvaW50TWFuaWZlc3QgPSBKU09OLnBhcnNlKHhoci5yZXNwb25zZVRleHQpO1xuICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB4aHIub25lcnJvciA9IGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihNQU5JRkVTVF9GSUxFICsgXCIgbm90IGZvdW5kIGF0IFwiICsgX3RoaXMudXJsUGF0aCArIFwiLiBcIiArIGVycm9yKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB4aHIuc2VuZCgpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIENoZWNrcG9pbnRMb2FkZXIucHJvdG90eXBlLmdldENoZWNrcG9pbnRNYW5pZmVzdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMuY2hlY2twb2ludE1hbmlmZXN0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgX3RoaXMubG9hZE1hbmlmZXN0KCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoX3RoaXMuY2hlY2twb2ludE1hbmlmZXN0KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICByZXNvbHZlKF90aGlzLmNoZWNrcG9pbnRNYW5pZmVzdCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQ2hlY2twb2ludExvYWRlci5wcm90b3R5cGUuZ2V0QWxsVmFyaWFibGVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy52YXJpYWJsZXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKF90aGlzLnZhcmlhYmxlcyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgX3RoaXMuZ2V0Q2hlY2twb2ludE1hbmlmZXN0KCkudGhlbihmdW5jdGlvbiAoY2hlY2twb2ludERlZmluaXRpb24pIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFyaWFibGVOYW1lcyA9IE9iamVjdC5rZXlzKF90aGlzLmNoZWNrcG9pbnRNYW5pZmVzdCk7XG4gICAgICAgICAgICAgICAgdmFyIHZhcmlhYmxlUHJvbWlzZXMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhcmlhYmxlTmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyaWFibGVQcm9taXNlcy5wdXNoKF90aGlzLmdldFZhcmlhYmxlKHZhcmlhYmxlTmFtZXNbaV0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgUHJvbWlzZS5hbGwodmFyaWFibGVQcm9taXNlcykudGhlbihmdW5jdGlvbiAodmFyaWFibGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnZhcmlhYmxlcyA9IHt9O1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhcmlhYmxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMudmFyaWFibGVzW3ZhcmlhYmxlTmFtZXNbaV1dID0gdmFyaWFibGVzW2ldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoX3RoaXMudmFyaWFibGVzKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIENoZWNrcG9pbnRMb2FkZXIucHJvdG90eXBlLmdldFZhcmlhYmxlID0gZnVuY3Rpb24gKHZhck5hbWUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCEodmFyTmFtZSBpbiB0aGlzLmNoZWNrcG9pbnRNYW5pZmVzdCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGxvYWQgbm9uLWV4aXN0YW50IHZhcmlhYmxlICcgKyB2YXJOYW1lKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdmFyaWFibGVSZXF1ZXN0UHJvbWlzZU1ldGhvZCA9IGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICAgICAgIHhoci5yZXNwb25zZVR5cGUgPSAnYXJyYXlidWZmZXInO1xuICAgICAgICAgICAgdmFyIGZuYW1lID0gX3RoaXMuY2hlY2twb2ludE1hbmlmZXN0W3Zhck5hbWVdLmZpbGVuYW1lO1xuICAgICAgICAgICAgeGhyLm9wZW4oJ0dFVCcsIF90aGlzLnVybFBhdGggKyBmbmFtZSk7XG4gICAgICAgICAgICB4aHIub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZXMgPSBuZXcgRmxvYXQzMkFycmF5KHhoci5yZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgdmFyIG5kYXJyYXkgPSBuZGFycmF5XzEuTkRBcnJheS5tYWtlKF90aGlzLmNoZWNrcG9pbnRNYW5pZmVzdFt2YXJOYW1lXS5zaGFwZSwgeyB2YWx1ZXM6IHZhbHVlcyB9KTtcbiAgICAgICAgICAgICAgICByZXNvbHZlKG5kYXJyYXkpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHhoci5vbmVycm9yID0gZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IGZldGNoIHZhcmlhYmxlIFwiICsgdmFyTmFtZSArIFwiOiBcIiArIGVycm9yKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB4aHIuc2VuZCgpO1xuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5jaGVja3BvaW50TWFuaWZlc3QgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5sb2FkTWFuaWZlc3QoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3IFByb21pc2UodmFyaWFibGVSZXF1ZXN0UHJvbWlzZU1ldGhvZCkudGhlbihyZXNvbHZlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSh2YXJpYWJsZVJlcXVlc3RQcm9taXNlTWV0aG9kKTtcbiAgICB9O1xuICAgIHJldHVybiBDaGVja3BvaW50TG9hZGVyO1xufSgpKTtcbmV4cG9ydHMuQ2hlY2twb2ludExvYWRlciA9IENoZWNrcG9pbnRMb2FkZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaGVja3BvaW50X2xvYWRlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBuZGFycmF5XzEgPSByZXF1aXJlKFwiLi4vbWF0aC9uZGFycmF5XCIpO1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbnZhciBTVEFUU19TQU1QTEVfUEVSQ0VOVEFHRSA9IDAuMTtcbnZhciBJbk1lbW9yeURhdGFzZXQgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEluTWVtb3J5RGF0YXNldChkYXRhU2hhcGVzKSB7XG4gICAgICAgIHRoaXMuZGF0YVNoYXBlcyA9IGRhdGFTaGFwZXM7XG4gICAgICAgIHRoaXMubm9ybWFsaXphdGlvbkluZm8gPSB7fTtcbiAgICB9XG4gICAgSW5NZW1vcnlEYXRhc2V0LnByb3RvdHlwZS5nZXREYXRhU2hhcGUgPSBmdW5jdGlvbiAoZGF0YUluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFTaGFwZXNbZGF0YUluZGV4XTtcbiAgICB9O1xuICAgIEluTWVtb3J5RGF0YXNldC5wcm90b3R5cGUuZ2V0RGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YXNldDtcbiAgICB9O1xuICAgIEluTWVtb3J5RGF0YXNldC5wcm90b3R5cGUuZ2V0U3RhdHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLmRhdGFzZXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEYXRhIGlzIG51bGwuJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YXNldC5tYXAoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIF90aGlzLmdldFN0YXRzRm9yRGF0YShkKTsgfSk7XG4gICAgfTtcbiAgICBJbk1lbW9yeURhdGFzZXQucHJvdG90eXBlLmdldFN0YXRzRm9yRGF0YSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHZhciBpbnB1dE1pbiA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICAgICAgdmFyIGlucHV0TWF4ID0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZO1xuICAgICAgICB2YXIgZXhhbXBsZUluZGljZXMgPSBkYXRhLm1hcChmdW5jdGlvbiAoZXhhbXBsZSwgaSkgeyByZXR1cm4gaTsgfSk7XG4gICAgICAgIHV0aWwuc2h1ZmZsZShleGFtcGxlSW5kaWNlcyk7XG4gICAgICAgIGV4YW1wbGVJbmRpY2VzID1cbiAgICAgICAgICAgIGV4YW1wbGVJbmRpY2VzLnNsaWNlKGV4YW1wbGVJbmRpY2VzLmxlbmd0aCAqIFNUQVRTX1NBTVBMRV9QRVJDRU5UQUdFKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleGFtcGxlSW5kaWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGlucHV0VmFsdWVzID0gZGF0YVtleGFtcGxlSW5kaWNlc1tpXV0uZ2V0VmFsdWVzKCk7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGlucHV0VmFsdWVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgaW5wdXRNaW4gPSBNYXRoLm1pbihpbnB1dE1pbiwgaW5wdXRWYWx1ZXNbal0pO1xuICAgICAgICAgICAgICAgIGlucHV0TWF4ID0gTWF0aC5tYXgoaW5wdXRNYXgsIGlucHV0VmFsdWVzW2pdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaW5wdXRNaW46IGlucHV0TWluLFxuICAgICAgICAgICAgaW5wdXRNYXg6IGlucHV0TWF4LFxuICAgICAgICAgICAgZXhhbXBsZUNvdW50OiBkYXRhLmxlbmd0aCxcbiAgICAgICAgICAgIHNoYXBlOiBkYXRhWzBdLnNoYXBlLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgSW5NZW1vcnlEYXRhc2V0LnByb3RvdHlwZS5ub3JtYWxpemVFeGFtcGxlc1RvUmFuZ2UgPSBmdW5jdGlvbiAoZXhhbXBsZXMsIGN1ckxvd2VyQm91bmRzLCBjdXJVcHBlckJvdW5kcywgbmV3TG93ZXJCb3VuZHMsIG5ld1VwcGVyQm91bmRzKSB7XG4gICAgICAgIHZhciBjdXJCb3VuZHNJc1BlckRpbWVuc2lvbiA9IChjdXJVcHBlckJvdW5kcyBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSAmJlxuICAgICAgICAgICAgY3VyTG93ZXJCb3VuZHMgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkpO1xuICAgICAgICB2YXIgbmV3Qm91bmRzSXNQZXJEaW1lbnNpb24gPSAobmV3TG93ZXJCb3VuZHMgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkgJiZcbiAgICAgICAgICAgIG5ld1VwcGVyQm91bmRzIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5KTtcbiAgICAgICAgdmFyIGlucHV0U2l6ZSA9IHV0aWwuc2l6ZUZyb21TaGFwZShleGFtcGxlc1swXS5zaGFwZSk7XG4gICAgICAgIHZhciBuZXdFeGFtcGxlcyA9IFtdO1xuICAgICAgICBleGFtcGxlcy5mb3JFYWNoKGZ1bmN0aW9uIChleGFtcGxlKSB7XG4gICAgICAgICAgICB2YXIgaW5wdXRWYWx1ZXMgPSBleGFtcGxlLmdldFZhbHVlcygpO1xuICAgICAgICAgICAgdmFyIG5vcm1hbGl6ZWRWYWx1ZXMgPSBuZXcgRmxvYXQzMkFycmF5KGlucHV0U2l6ZSk7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGlucHV0U2l6ZTsgaisrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGN1ckxvd2VyQm91bmQgPSBjdXJCb3VuZHNJc1BlckRpbWVuc2lvbiA/XG4gICAgICAgICAgICAgICAgICAgIGN1ckxvd2VyQm91bmRzW2pdIDpcbiAgICAgICAgICAgICAgICAgICAgY3VyTG93ZXJCb3VuZHM7XG4gICAgICAgICAgICAgICAgdmFyIGN1clVwcGVyQm91bmQgPSBjdXJCb3VuZHNJc1BlckRpbWVuc2lvbiA/XG4gICAgICAgICAgICAgICAgICAgIGN1clVwcGVyQm91bmRzW2pdIDpcbiAgICAgICAgICAgICAgICAgICAgY3VyVXBwZXJCb3VuZHM7XG4gICAgICAgICAgICAgICAgdmFyIGN1clJhbmdlID0gY3VyVXBwZXJCb3VuZCAtIGN1ckxvd2VyQm91bmQ7XG4gICAgICAgICAgICAgICAgdmFyIG5ld0xvd2VyQm91bmQgPSBuZXdCb3VuZHNJc1BlckRpbWVuc2lvbiA/XG4gICAgICAgICAgICAgICAgICAgIG5ld0xvd2VyQm91bmRzW2pdIDpcbiAgICAgICAgICAgICAgICAgICAgbmV3TG93ZXJCb3VuZHM7XG4gICAgICAgICAgICAgICAgdmFyIG5ld1VwcGVyQm91bmQgPSBuZXdCb3VuZHNJc1BlckRpbWVuc2lvbiA/XG4gICAgICAgICAgICAgICAgICAgIG5ld1VwcGVyQm91bmRzW2pdIDpcbiAgICAgICAgICAgICAgICAgICAgbmV3VXBwZXJCb3VuZHM7XG4gICAgICAgICAgICAgICAgdmFyIG5ld1JhbmdlID0gbmV3VXBwZXJCb3VuZCAtIG5ld0xvd2VyQm91bmQ7XG4gICAgICAgICAgICAgICAgaWYgKGN1clJhbmdlID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWRWYWx1ZXNbal0gPSBuZXdMb3dlckJvdW5kO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbm9ybWFsaXplZFZhbHVlc1tqXSA9IG5ld0xvd2VyQm91bmQgK1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3UmFuZ2UgKiAoaW5wdXRWYWx1ZXNbal0gLSBjdXJMb3dlckJvdW5kKSAvIGN1clJhbmdlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5ld0V4YW1wbGVzLnB1c2gobmRhcnJheV8xLk5EQXJyYXkubWFrZShleGFtcGxlLnNoYXBlLCB7IHZhbHVlczogbm9ybWFsaXplZFZhbHVlcyB9KSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbmV3RXhhbXBsZXM7XG4gICAgfTtcbiAgICBJbk1lbW9yeURhdGFzZXQucHJvdG90eXBlLmNvbXB1dGVCb3VuZHMgPSBmdW5jdGlvbiAoZGF0YUluZGV4KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLmRhdGFzZXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEYXRhIGlzIG51bGwuJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNpemUgPSB1dGlsLnNpemVGcm9tU2hhcGUodGhpcy5kYXRhc2V0W2RhdGFJbmRleF1bMF0uc2hhcGUpO1xuICAgICAgICB0aGlzLm5vcm1hbGl6YXRpb25JbmZvW2RhdGFJbmRleF0gPSB7XG4gICAgICAgICAgICBpc05vcm1hbGl6ZWQ6IGZhbHNlLFxuICAgICAgICAgICAgbWluVmFsdWVzOiBuZXcgRmxvYXQzMkFycmF5KHNpemUpLFxuICAgICAgICAgICAgbWF4VmFsdWVzOiBuZXcgRmxvYXQzMkFycmF5KHNpemUpXG4gICAgICAgIH07XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLm5vcm1hbGl6YXRpb25JbmZvW2RhdGFJbmRleF0ubWluVmFsdWVzW2ldID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgICAgICAgICAgdGhpcy5ub3JtYWxpemF0aW9uSW5mb1tkYXRhSW5kZXhdLm1heFZhbHVlc1tpXSA9IE51bWJlci5ORUdBVElWRV9JTkZJTklUWTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRhdGFzZXRbZGF0YUluZGV4XS5mb3JFYWNoKGZ1bmN0aW9uIChleGFtcGxlKSB7XG4gICAgICAgICAgICB2YXIgaW5wdXRWYWx1ZXMgPSBleGFtcGxlLmdldFZhbHVlcygpO1xuICAgICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBzaXplOyBrKyspIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5ub3JtYWxpemF0aW9uSW5mb1tkYXRhSW5kZXhdLm1pblZhbHVlc1trXSA9IE1hdGgubWluKF90aGlzLm5vcm1hbGl6YXRpb25JbmZvW2RhdGFJbmRleF0ubWluVmFsdWVzW2tdLCBpbnB1dFZhbHVlc1trXSk7XG4gICAgICAgICAgICAgICAgX3RoaXMubm9ybWFsaXphdGlvbkluZm9bZGF0YUluZGV4XS5tYXhWYWx1ZXNba10gPSBNYXRoLm1heChfdGhpcy5ub3JtYWxpemF0aW9uSW5mb1tkYXRhSW5kZXhdLm1heFZhbHVlc1trXSwgaW5wdXRWYWx1ZXNba10pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEluTWVtb3J5RGF0YXNldC5wcm90b3R5cGUubm9ybWFsaXplV2l0aGluQm91bmRzID0gZnVuY3Rpb24gKGRhdGFJbmRleCwgbG93ZXJCb3VuZCwgdXBwZXJCb3VuZCkge1xuICAgICAgICBpZiAodGhpcy5kYXRhc2V0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRGF0YSBpcyBudWxsLicpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhSW5kZXggPj0gdGhpcy5kYXRhc2V0Lmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkYXRhSW5kZXggb3V0IG9mIGJvdW5kcy4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5ub3JtYWxpemF0aW9uSW5mb1tkYXRhSW5kZXhdID09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuY29tcHV0ZUJvdW5kcyhkYXRhSW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjdXJMb3dlckJvdW5kcztcbiAgICAgICAgdmFyIGN1clVwcGVyQm91bmRzO1xuICAgICAgICBpZiAodGhpcy5ub3JtYWxpemF0aW9uSW5mb1tkYXRhSW5kZXhdLmlzTm9ybWFsaXplZCkge1xuICAgICAgICAgICAgY3VyTG93ZXJCb3VuZHMgPSB0aGlzLm5vcm1hbGl6YXRpb25JbmZvW2RhdGFJbmRleF0ubG93ZXJCb3VuZDtcbiAgICAgICAgICAgIGN1clVwcGVyQm91bmRzID0gdGhpcy5ub3JtYWxpemF0aW9uSW5mb1tkYXRhSW5kZXhdLnVwcGVyQm91bmQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjdXJMb3dlckJvdW5kcyA9IHRoaXMubm9ybWFsaXphdGlvbkluZm9bZGF0YUluZGV4XS5taW5WYWx1ZXM7XG4gICAgICAgICAgICBjdXJVcHBlckJvdW5kcyA9IHRoaXMubm9ybWFsaXphdGlvbkluZm9bZGF0YUluZGV4XS5tYXhWYWx1ZXM7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kYXRhc2V0W2RhdGFJbmRleF0gPSB0aGlzLm5vcm1hbGl6ZUV4YW1wbGVzVG9SYW5nZSh0aGlzLmRhdGFzZXRbZGF0YUluZGV4XSwgY3VyTG93ZXJCb3VuZHMsIGN1clVwcGVyQm91bmRzLCBsb3dlckJvdW5kLCB1cHBlckJvdW5kKTtcbiAgICAgICAgdGhpcy5ub3JtYWxpemF0aW9uSW5mb1tkYXRhSW5kZXhdLmlzTm9ybWFsaXplZCA9IHRydWU7XG4gICAgICAgIHRoaXMubm9ybWFsaXphdGlvbkluZm9bZGF0YUluZGV4XS5sb3dlckJvdW5kID0gbG93ZXJCb3VuZDtcbiAgICAgICAgdGhpcy5ub3JtYWxpemF0aW9uSW5mb1tkYXRhSW5kZXhdLnVwcGVyQm91bmQgPSB1cHBlckJvdW5kO1xuICAgIH07XG4gICAgSW5NZW1vcnlEYXRhc2V0LnByb3RvdHlwZS5pc05vcm1hbGl6ZWQgPSBmdW5jdGlvbiAoZGF0YUluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5vcm1hbGl6YXRpb25JbmZvICE9IG51bGwgJiZcbiAgICAgICAgICAgIHRoaXMubm9ybWFsaXphdGlvbkluZm9bZGF0YUluZGV4XS5pc05vcm1hbGl6ZWQ7XG4gICAgfTtcbiAgICBJbk1lbW9yeURhdGFzZXQucHJvdG90eXBlLnJlbW92ZU5vcm1hbGl6YXRpb24gPSBmdW5jdGlvbiAoZGF0YUluZGV4KSB7XG4gICAgICAgIGlmICh0aGlzLmRhdGFzZXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUcmFpbmluZyBvciB0ZXN0IGRhdGEgaXMgbnVsbC4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuaXNOb3JtYWxpemVkKGRhdGFJbmRleCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRhdGFzZXRbZGF0YUluZGV4XSA9IHRoaXMubm9ybWFsaXplRXhhbXBsZXNUb1JhbmdlKHRoaXMuZGF0YXNldFtkYXRhSW5kZXhdLCB0aGlzLm5vcm1hbGl6YXRpb25JbmZvW2RhdGFJbmRleF0ubG93ZXJCb3VuZCwgdGhpcy5ub3JtYWxpemF0aW9uSW5mb1tkYXRhSW5kZXhdLnVwcGVyQm91bmQsIHRoaXMubm9ybWFsaXphdGlvbkluZm9bZGF0YUluZGV4XS5taW5WYWx1ZXMsIHRoaXMubm9ybWFsaXphdGlvbkluZm9bZGF0YUluZGV4XS5tYXhWYWx1ZXMpO1xuICAgICAgICB0aGlzLm5vcm1hbGl6YXRpb25JbmZvW2RhdGFJbmRleF0uaXNOb3JtYWxpemVkID0gZmFsc2U7XG4gICAgfTtcbiAgICBJbk1lbW9yeURhdGFzZXQucHJvdG90eXBlLnVubm9ybWFsaXplRXhhbXBsZXMgPSBmdW5jdGlvbiAoZXhhbXBsZXMsIGRhdGFJbmRleCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNOb3JtYWxpemVkKGRhdGFJbmRleCkpIHtcbiAgICAgICAgICAgIHJldHVybiBleGFtcGxlcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5ub3JtYWxpemVFeGFtcGxlc1RvUmFuZ2UoZXhhbXBsZXMsIHRoaXMubm9ybWFsaXphdGlvbkluZm9bZGF0YUluZGV4XS5sb3dlckJvdW5kLCB0aGlzLm5vcm1hbGl6YXRpb25JbmZvW2RhdGFJbmRleF0udXBwZXJCb3VuZCwgdGhpcy5ub3JtYWxpemF0aW9uSW5mb1tkYXRhSW5kZXhdLm1pblZhbHVlcywgdGhpcy5ub3JtYWxpemF0aW9uSW5mb1tkYXRhSW5kZXhdLm1heFZhbHVlcyk7XG4gICAgfTtcbiAgICBJbk1lbW9yeURhdGFzZXQucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmRhdGFzZXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5kYXRhc2V0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRoaXMuZGF0YXNldFtpXS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIHRoaXMuZGF0YXNldFtpXVtqXS5kaXNwb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kYXRhc2V0ID0gW107XG4gICAgfTtcbiAgICByZXR1cm4gSW5NZW1vcnlEYXRhc2V0O1xufSgpKTtcbmV4cG9ydHMuSW5NZW1vcnlEYXRhc2V0ID0gSW5NZW1vcnlEYXRhc2V0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YXNldC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIG5kYXJyYXlfMSA9IHJlcXVpcmUoXCIuLi9tYXRoL25kYXJyYXlcIik7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xudmFyIEluTWVtb3J5U2h1ZmZsZWRJbnB1dFByb3ZpZGVyQnVpbGRlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSW5NZW1vcnlTaHVmZmxlZElucHV0UHJvdmlkZXJCdWlsZGVyKGlucHV0cykge1xuICAgICAgICB0aGlzLmlucHV0cyA9IGlucHV0cztcbiAgICAgICAgdGhpcy5pZHggPSAwO1xuICAgICAgICB0aGlzLmlucHV0Q291bnRlciA9IDA7XG4gICAgICAgIHRoaXMuZXBvY2ggPSAwO1xuICAgICAgICB0aGlzLnNodWZmbGVkSW5kaWNlcyA9IHV0aWwuY3JlYXRlU2h1ZmZsZWRJbmRpY2VzKGlucHV0c1swXS5sZW5ndGgpO1xuICAgICAgICB0aGlzLm51bUlucHV0cyA9IGlucHV0cy5sZW5ndGg7XG4gICAgICAgIHZhciBudW1FeGFtcGxlcyA9IHRoaXMuaW5wdXRzWzBdLmxlbmd0aDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm51bUlucHV0czsgaSsrKSB7XG4gICAgICAgICAgICB1dGlsLmFzc2VydCh0aGlzLmlucHV0c1tpXS5sZW5ndGggPT09IG51bUV4YW1wbGVzLCAnTnVtYmVyIG9mIGV4YW1wbGVzIG11c3QgbWF0Y2ggYWNyb3NzIGRpZmZlcmVudCBpbnB1dHMuJyk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm51bUlucHV0czsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgaW5wdXRTaGFwZSA9IHRoaXMuaW5wdXRzW2ldWzBdLnNoYXBlO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLmlucHV0c1tpXS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIHV0aWwuYXNzZXJ0U2hhcGVzTWF0Y2goaW5wdXRTaGFwZSwgdGhpcy5pbnB1dHNbaV1bal0uc2hhcGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIEluTWVtb3J5U2h1ZmZsZWRJbnB1dFByb3ZpZGVyQnVpbGRlci5wcm90b3R5cGUuZ2V0Q3VycmVudEV4YW1wbGVJbmRleCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJldHVybklkeCA9IHRoaXMuaWR4O1xuICAgICAgICB0aGlzLmlucHV0Q291bnRlcisrO1xuICAgICAgICBpZiAodGhpcy5pbnB1dENvdW50ZXIgPj0gdGhpcy5udW1JbnB1dHMpIHtcbiAgICAgICAgICAgIHRoaXMuaWR4Kys7XG4gICAgICAgICAgICB0aGlzLmlucHV0Q291bnRlciA9IDA7XG4gICAgICAgICAgICBpZiAodGhpcy5pZHggPj0gdGhpcy5pbnB1dHNbMF0ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pZHggPSAwO1xuICAgICAgICAgICAgICAgIHRoaXMuZXBvY2grKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0dXJuSWR4O1xuICAgIH07XG4gICAgSW5NZW1vcnlTaHVmZmxlZElucHV0UHJvdmlkZXJCdWlsZGVyLnByb3RvdHlwZS5nZXROZXh0SW5wdXQgPSBmdW5jdGlvbiAoaW5wdXRJZCkge1xuICAgICAgICB2YXIgY3VycmVudEV4YW1wbGVJbmRleCA9IHRoaXMuZ2V0Q3VycmVudEV4YW1wbGVJbmRleCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5pbnB1dHNbaW5wdXRJZF1bdGhpcy5zaHVmZmxlZEluZGljZXNbY3VycmVudEV4YW1wbGVJbmRleF1dO1xuICAgIH07XG4gICAgSW5NZW1vcnlTaHVmZmxlZElucHV0UHJvdmlkZXJCdWlsZGVyLnByb3RvdHlwZS5nZXRFcG9jaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXBvY2g7XG4gICAgfTtcbiAgICBJbk1lbW9yeVNodWZmbGVkSW5wdXRQcm92aWRlckJ1aWxkZXIucHJvdG90eXBlLmdldElucHV0UHJvdmlkZXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaW5wdXRQcm92aWRlcnMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm51bUlucHV0czsgaSsrKSB7XG4gICAgICAgICAgICBpbnB1dFByb3ZpZGVycy5wdXNoKHRoaXMuZ2V0SW5wdXRQcm92aWRlcihpKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlucHV0UHJvdmlkZXJzO1xuICAgIH07XG4gICAgcmV0dXJuIEluTWVtb3J5U2h1ZmZsZWRJbnB1dFByb3ZpZGVyQnVpbGRlcjtcbn0oKSk7XG5leHBvcnRzLkluTWVtb3J5U2h1ZmZsZWRJbnB1dFByb3ZpZGVyQnVpbGRlciA9IEluTWVtb3J5U2h1ZmZsZWRJbnB1dFByb3ZpZGVyQnVpbGRlcjtcbnZhciBJbkNQVU1lbW9yeVNodWZmbGVkSW5wdXRQcm92aWRlckJ1aWxkZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhJbkNQVU1lbW9yeVNodWZmbGVkSW5wdXRQcm92aWRlckJ1aWxkZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSW5DUFVNZW1vcnlTaHVmZmxlZElucHV0UHJvdmlkZXJCdWlsZGVyKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIEluQ1BVTWVtb3J5U2h1ZmZsZWRJbnB1dFByb3ZpZGVyQnVpbGRlci5wcm90b3R5cGUuZ2V0SW5wdXRQcm92aWRlciA9IGZ1bmN0aW9uIChpbnB1dElkKSB7XG4gICAgICAgIHZhciBzaHVmZmxlZElucHV0UHJvdmlkZXIgPSB0aGlzO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZ2V0TmV4dENvcHk6IGZ1bmN0aW9uIChtYXRoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5kYXJyYXlfMS5OREFycmF5Lmxpa2Uoc2h1ZmZsZWRJbnB1dFByb3ZpZGVyLmdldE5leHRJbnB1dChpbnB1dElkKSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGlzcG9zZUNvcHk6IGZ1bmN0aW9uIChtYXRoLCBjb3B5KSB7XG4gICAgICAgICAgICAgICAgY29weS5kaXNwb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfTtcbiAgICByZXR1cm4gSW5DUFVNZW1vcnlTaHVmZmxlZElucHV0UHJvdmlkZXJCdWlsZGVyO1xufShJbk1lbW9yeVNodWZmbGVkSW5wdXRQcm92aWRlckJ1aWxkZXIpKTtcbmV4cG9ydHMuSW5DUFVNZW1vcnlTaHVmZmxlZElucHV0UHJvdmlkZXJCdWlsZGVyID0gSW5DUFVNZW1vcnlTaHVmZmxlZElucHV0UHJvdmlkZXJCdWlsZGVyO1xudmFyIEluR1BVTWVtb3J5U2h1ZmZsZWRJbnB1dFByb3ZpZGVyQnVpbGRlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEluR1BVTWVtb3J5U2h1ZmZsZWRJbnB1dFByb3ZpZGVyQnVpbGRlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBJbkdQVU1lbW9yeVNodWZmbGVkSW5wdXRQcm92aWRlckJ1aWxkZXIoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgSW5HUFVNZW1vcnlTaHVmZmxlZElucHV0UHJvdmlkZXJCdWlsZGVyLnByb3RvdHlwZS5nZXRJbnB1dFByb3ZpZGVyID0gZnVuY3Rpb24gKGlucHV0SWQpIHtcbiAgICAgICAgdmFyIHNodWZmbGVkSW5wdXRQcm92aWRlciA9IHRoaXM7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBnZXROZXh0Q29weTogZnVuY3Rpb24gKG1hdGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWF0aC5jbG9uZShzaHVmZmxlZElucHV0UHJvdmlkZXIuZ2V0TmV4dElucHV0KGlucHV0SWQpKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkaXNwb3NlQ29weTogZnVuY3Rpb24gKG1hdGgsIGNvcHkpIHtcbiAgICAgICAgICAgICAgICBjb3B5LmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9O1xuICAgIHJldHVybiBJbkdQVU1lbW9yeVNodWZmbGVkSW5wdXRQcm92aWRlckJ1aWxkZXI7XG59KEluTWVtb3J5U2h1ZmZsZWRJbnB1dFByb3ZpZGVyQnVpbGRlcikpO1xuZXhwb3J0cy5JbkdQVU1lbW9yeVNodWZmbGVkSW5wdXRQcm92aWRlckJ1aWxkZXIgPSBJbkdQVU1lbW9yeVNodWZmbGVkSW5wdXRQcm92aWRlckJ1aWxkZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbnB1dF9wcm92aWRlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIG5kYXJyYXlfMSA9IHJlcXVpcmUoXCIuLi9tYXRoL25kYXJyYXlcIik7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xudmFyIGRhdGFzZXRfMSA9IHJlcXVpcmUoXCIuL2RhdGFzZXRcIik7XG52YXIgUEFSU0lOR19JTUFHRV9DQU5WQVNfSEVJR0hUX1BYID0gMTAwMDtcbmZ1bmN0aW9uIGdldFhockRhdGFzZXRDb25maWcoanNvbkNvbmZpZ1BhdGgpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgIHhoci5vcGVuKCdHRVQnLCBqc29uQ29uZmlnUGF0aCk7XG4gICAgICAgIHhoci5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXNvbHZlKEpTT04ucGFyc2UoeGhyLnJlc3BvbnNlVGV4dCkpO1xuICAgICAgICB9O1xuICAgICAgICB4aHIub25lcnJvciA9IGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgfTtcbiAgICAgICAgeGhyLnNlbmQoKTtcbiAgICB9KTtcbn1cbmV4cG9ydHMuZ2V0WGhyRGF0YXNldENvbmZpZyA9IGdldFhockRhdGFzZXRDb25maWc7XG52YXIgWGhyRGF0YXNldCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFhockRhdGFzZXQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gWGhyRGF0YXNldCh4aHJEYXRhc2V0Q29uZmlnKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHhockRhdGFzZXRDb25maWcuZGF0YS5tYXAoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHguc2hhcGU7IH0pKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy54aHJEYXRhc2V0Q29uZmlnID0geGhyRGF0YXNldENvbmZpZztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBYaHJEYXRhc2V0LnByb3RvdHlwZS5nZXROREFycmF5ID0gZnVuY3Rpb24gKGluZm8pIHtcbiAgICAgICAgdmFyIGRhdGFQcm9taXNlID0gaW5mby5kYXRhVHlwZSA9PT0gJ3BuZycgP1xuICAgICAgICAgICAgcGFyc2VUeXBlZEFycmF5RnJvbVBuZyhpbmZvLCBpbmZvLnNoYXBlKSA6XG4gICAgICAgICAgICBwYXJzZVR5cGVkQXJyYXlGcm9tQmluYXJ5KGluZm8pO1xuICAgICAgICByZXR1cm4gZGF0YVByb21pc2UudGhlbihmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgdmFyIGlucHV0U2l6ZSA9IHV0aWwuc2l6ZUZyb21TaGFwZShpbmZvLnNoYXBlKTtcbiAgICAgICAgICAgIHZhciBuZGFycmF5cyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aCAvIGlucHV0U2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlcyA9IGRhdGEuc3ViYXJyYXkoaSAqIGlucHV0U2l6ZSwgKGkgKyAxKSAqIGlucHV0U2l6ZSk7XG4gICAgICAgICAgICAgICAgdmFyIG5kYXJyYXkgPSBuZGFycmF5XzEuTkRBcnJheS5tYWtlKGluZm8uc2hhcGUsIHsgdmFsdWVzOiBuZXcgRmxvYXQzMkFycmF5KHZhbHVlcykgfSk7XG4gICAgICAgICAgICAgICAgbmRhcnJheXMucHVzaChuZGFycmF5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZGFycmF5cztcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBYaHJEYXRhc2V0LnByb3RvdHlwZS5mZXRjaERhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICB2YXIgcHJvbWlzZXMgPSBfdGhpcy54aHJEYXRhc2V0Q29uZmlnLmRhdGEubWFwKGZ1bmN0aW9uICh4KSB7IHJldHVybiBfdGhpcy5nZXROREFycmF5KHgpOyB9KTtcbiAgICAgICAgICAgIFByb21pc2UuYWxsKHByb21pc2VzKS50aGVuKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuZGF0YXNldCA9IGRhdGE7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIFhockRhdGFzZXQ7XG59KGRhdGFzZXRfMS5Jbk1lbW9yeURhdGFzZXQpKTtcbmV4cG9ydHMuWGhyRGF0YXNldCA9IFhockRhdGFzZXQ7XG5mdW5jdGlvbiBwYXJzZVR5cGVkQXJyYXlGcm9tQmluYXJ5KGluZm8pIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgIHhoci5vcGVuKCdHRVQnLCBpbmZvLnBhdGgpO1xuICAgICAgICB4aHIucmVzcG9uc2VUeXBlID0gJ2FycmF5YnVmZmVyJztcbiAgICAgICAgeGhyLm9ubG9hZCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgdmFyIGRhdGEgPSAoaW5mby5kYXRhVHlwZSA9PT0gJ2Zsb2F0MzInKSA/XG4gICAgICAgICAgICAgICAgbmV3IEZsb2F0MzJBcnJheSh4aHIucmVzcG9uc2UpIDpcbiAgICAgICAgICAgICAgICBuZXcgVWludDhBcnJheSh4aHIucmVzcG9uc2UpO1xuICAgICAgICAgICAgcmVzb2x2ZShkYXRhKTtcbiAgICAgICAgfTtcbiAgICAgICAgeGhyLm9uZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7IHJldHVybiByZWplY3QoZXJyKTsgfTtcbiAgICAgICAgeGhyLnNlbmQoKTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIHBhcnNlR3JheXNjYWxlSW1hZ2VEYXRhKGRhdGEsIHJlc3VsdCwgcmVzdWx0T2Zmc2V0KSB7XG4gICAgdmFyIGlkeCA9IHJlc3VsdE9mZnNldDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpICs9IDQpIHtcbiAgICAgICAgcmVzdWx0W2lkeCsrXSA9IGRhdGFbaV07XG4gICAgfVxufVxuZnVuY3Rpb24gcGFyc2VSR0JJbWFnZURhdGEoZGF0YSwgcmVzdWx0LCByZXN1bHRPZmZzZXQpIHtcbiAgICB2YXIgaWR4ID0gcmVzdWx0T2Zmc2V0O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkgKz0gNCkge1xuICAgICAgICByZXN1bHRbaWR4XSA9IGRhdGFbaV07XG4gICAgICAgIHJlc3VsdFtpZHggKyAxXSA9IGRhdGFbaSArIDFdO1xuICAgICAgICByZXN1bHRbaWR4ICsgMl0gPSBkYXRhW2kgKyAyXTtcbiAgICAgICAgaWR4ICs9IDM7XG4gICAgfVxufVxuZnVuY3Rpb24gcGFyc2VJbWFnZShpbWcsIHNoYXBlKSB7XG4gICAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgIHZhciBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICB2YXIgTiA9IGltZy5oZWlnaHQ7XG4gICAgdmFyIGlucHV0U2l6ZSA9IHV0aWwuc2l6ZUZyb21TaGFwZShzaGFwZSk7XG4gICAgdmFyIHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KE4gKiBpbnB1dFNpemUpO1xuICAgIGlmIChpbWcud2lkdGggIT09IHNoYXBlWzBdICogc2hhcGVbMV0pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW1hZ2Ugd2lkdGggKFwiICsgaW1nLndpZHRoICsgXCIpIG11c3QgYmUgbXVsdGlwbGUgb2YgXCIgK1xuICAgICAgICAgICAgKFwicm93cypjb2x1bW5zIChcIiArIHNoYXBlWzBdICsgXCIqXCIgKyBzaGFwZVsxXSArIFwiKSBvZiB0aGUgbmRhcnJheVwiKSk7XG4gICAgfVxuICAgIGNhbnZhcy53aWR0aCA9IGltZy53aWR0aDtcbiAgICBjYW52YXMuaGVpZ2h0ID0gUEFSU0lOR19JTUFHRV9DQU5WQVNfSEVJR0hUX1BYO1xuICAgIHZhciBzeCA9IDA7XG4gICAgdmFyIHNXaWR0aCA9IGNhbnZhcy53aWR0aDtcbiAgICB2YXIgc0hlaWdodCA9IGNhbnZhcy5oZWlnaHQ7XG4gICAgdmFyIGR4ID0gMDtcbiAgICB2YXIgZHkgPSAwO1xuICAgIHZhciBkV2lkdGggPSBzV2lkdGg7XG4gICAgdmFyIGRIZWlnaHQgPSBzSGVpZ2h0O1xuICAgIHZhciBkZXB0aCA9IHNoYXBlWzJdO1xuICAgIHZhciBvZmZzZXQgPSAwO1xuICAgIHZhciBudW1QYXNzZXMgPSBNYXRoLmNlaWwoTiAvIGNhbnZhcy5oZWlnaHQpO1xuICAgIGZvciAodmFyIHBhc3MgPSAwOyBwYXNzIDwgbnVtUGFzc2VzOyArK3Bhc3MpIHtcbiAgICAgICAgdmFyIHN5ID0gcGFzcyAqIGNhbnZhcy5oZWlnaHQ7XG4gICAgICAgIGlmICgocGFzcyA9PT0gbnVtUGFzc2VzIC0gMSkgJiYgKE4gJSBjYW52YXMuaGVpZ2h0ID4gMCkpIHtcbiAgICAgICAgICAgIGNhbnZhcy5oZWlnaHQgPSBOICUgY2FudmFzLmhlaWdodDtcbiAgICAgICAgICAgIHNIZWlnaHQgPSBjYW52YXMuaGVpZ2h0O1xuICAgICAgICAgICAgZEhlaWdodCA9IHNIZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LmRyYXdJbWFnZShpbWcsIHN4LCBzeSwgc1dpZHRoLCBzSGVpZ2h0LCBkeCwgZHksIGRXaWR0aCwgZEhlaWdodCk7XG4gICAgICAgIHZhciBkYXRhID0gY3R4LmdldEltYWdlRGF0YSgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpLmRhdGE7XG4gICAgICAgIChkZXB0aCA9PT0gMSkgPyBwYXJzZUdyYXlzY2FsZUltYWdlRGF0YShkYXRhLCByZXN1bHQsIG9mZnNldCkgOlxuICAgICAgICAgICAgcGFyc2VSR0JJbWFnZURhdGEoZGF0YSwgcmVzdWx0LCBvZmZzZXQpO1xuICAgICAgICBvZmZzZXQgKz0gY2FudmFzLmhlaWdodCAqIGlucHV0U2l6ZTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHBhcnNlVHlwZWRBcnJheUZyb21QbmcoaW5mbywgc2hhcGUpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICB2YXIgaW1nID0gbmV3IEltYWdlKCk7XG4gICAgICAgIGltZy5zZXRBdHRyaWJ1dGUoJ2Nyb3NzT3JpZ2luJywgJycpO1xuICAgICAgICBpbWcub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHBhcnNlSW1hZ2UoaW1nLCBzaGFwZSk7XG4gICAgICAgICAgICBpbWcuc3JjID0gJyc7XG4gICAgICAgICAgICBpbWcgPSBudWxsO1xuICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9O1xuICAgICAgICBpbWcuc3JjID0gaW5mby5wYXRoO1xuICAgIH0pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9eGhyLWRhdGFzZXQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5mdW5jdGlvbiBpc01vYmlsZSgpIHtcbiAgICB2YXIgYSA9IG5hdmlnYXRvci51c2VyQWdlbnQgfHwgbmF2aWdhdG9yLnZlbmRvciB8fCB3aW5kb3cub3BlcmE7XG4gICAgcmV0dXJuIC8oYW5kcm9pZHxiYlxcZCt8bWVlZ28pLittb2JpbGV8YXZhbnRnb3xiYWRhXFwvfGJsYWNrYmVycnl8YmxhemVyfGNvbXBhbHxlbGFpbmV8ZmVubmVjfGhpcHRvcHxpZW1vYmlsZXxpcChob25lfG9kKXxpcmlzfGtpbmRsZXxsZ2UgfG1hZW1vfG1pZHB8bW1wfG1vYmlsZS4rZmlyZWZveHxuZXRmcm9udHxvcGVyYSBtKG9ifGluKWl8cGFsbSggb3MpP3xwaG9uZXxwKGl4aXxyZSlcXC98cGx1Y2tlcnxwb2NrZXR8cHNwfHNlcmllcyg0fDYpMHxzeW1iaWFufHRyZW98dXBcXC4oYnJvd3NlcnxsaW5rKXx2b2RhZm9uZXx3YXB8d2luZG93cyBjZXx4ZGF8eGlpbm8vaVxuICAgICAgICAudGVzdChhKSB8fFxuICAgICAgICAvMTIwN3w2MzEwfDY1OTB8M2dzb3w0dGhwfDUwWzEtNl1pfDc3MHN8ODAyc3xhIHdhfGFiYWN8YWMoZXJ8b298c1xcLSl8YWkoa298cm4pfGFsKGF2fGNhfGNvKXxhbW9pfGFuKGV4fG55fHl3KXxhcHR1fGFyKGNofGdvKXxhcyh0ZXx1cyl8YXR0d3xhdShkaXxcXC1tfHIgfHMgKXxhdmFufGJlKGNrfGxsfG5xKXxiaShsYnxyZCl8YmwoYWN8YXopfGJyKGV8dil3fGJ1bWJ8YndcXC0obnx1KXxjNTVcXC98Y2FwaXxjY3dhfGNkbVxcLXxjZWxsfGNodG18Y2xkY3xjbWRcXC18Y28obXB8bmQpfGNyYXd8ZGEoaXR8bGx8bmcpfGRidGV8ZGNcXC1zfGRldml8ZGljYXxkbW9ifGRvKGN8cClvfGRzKDEyfFxcLWQpfGVsKDQ5fGFpKXxlbShsMnx1bCl8ZXIoaWN8azApfGVzbDh8ZXooWzQtN10wfG9zfHdhfHplKXxmZXRjfGZseShcXC18Xyl8ZzEgdXxnNTYwfGdlbmV8Z2ZcXC01fGdcXC1tb3xnbyhcXC53fG9kKXxncihhZHx1bil8aGFpZXxoY2l0fGhkXFwtKG18cHx0KXxoZWlcXC18aGkocHR8dGEpfGhwKCBpfGlwKXxoc1xcLWN8aHQoYyhcXC18IHxffGF8Z3xwfHN8dCl8dHApfGh1KGF3fHRjKXxpXFwtKDIwfGdvfG1hKXxpMjMwfGlhYyggfFxcLXxcXC8pfGlicm98aWRlYXxpZzAxfGlrb218aW0xa3xpbm5vfGlwYXF8aXJpc3xqYSh0fHYpYXxqYnJvfGplbXV8amlnc3xrZGRpfGtlaml8a2d0KCB8XFwvKXxrbG9ufGtwdCB8a3djXFwtfGt5byhjfGspfGxlKG5vfHhpKXxsZyggZ3xcXC8oa3xsfHUpfDUwfDU0fFxcLVthLXddKXxsaWJ3fGx5bnh8bTFcXC13fG0zZ2F8bTUwXFwvfG1hKHRlfHVpfHhvKXxtYygwMXwyMXxjYSl8bVxcLWNyfG1lKHJjfHJpKXxtaShvOHxvYXx0cyl8bW1lZnxtbygwMXwwMnxiaXxkZXxkb3x0KFxcLXwgfG98dil8enopfG10KDUwfHAxfHYgKXxtd2JwfG15d2F8bjEwWzAtMl18bjIwWzItM118bjMwKDB8Mil8bjUwKDB8Mnw1KXxuNygwKDB8MSl8MTApfG5lKChjfG0pXFwtfG9ufHRmfHdmfHdnfHd0KXxub2soNnxpKXxuenBofG8yaW18b3AodGl8d3YpfG9yYW58b3dnMXxwODAwfHBhbihhfGR8dCl8cGR4Z3xwZygxM3xcXC0oWzEtOF18YykpfHBoaWx8cGlyZXxwbChheXx1Yyl8cG5cXC0yfHBvKGNrfHJ0fHNlKXxwcm94fHBzaW98cHRcXC1nfHFhXFwtYXxxYygwN3wxMnwyMXwzMnw2MHxcXC1bMi03XXxpXFwtKXxxdGVrfHIzODB8cjYwMHxyYWtzfHJpbTl8cm8odmV8em8pfHM1NVxcL3xzYShnZXxtYXxtbXxtc3xueXx2YSl8c2MoMDF8aFxcLXxvb3xwXFwtKXxzZGtcXC98c2UoYyhcXC18MHwxKXw0N3xtY3xuZHxyaSl8c2doXFwtfHNoYXJ8c2llKFxcLXxtKXxza1xcLTB8c2woNDV8aWQpfHNtKGFsfGFyfGIzfGl0fHQ1KXxzbyhmdHxueSl8c3AoMDF8aFxcLXx2XFwtfHYgKXxzeSgwMXxtYil8dDIoMTh8NTApfHQ2KDAwfDEwfDE4KXx0YShndHxsayl8dGNsXFwtfHRkZ1xcLXx0ZWwoaXxtKXx0aW1cXC18dFxcLW1vfHRvKHBsfHNoKXx0cyg3MHxtXFwtfG0zfG01KXx0eFxcLTl8dXAoXFwuYnxnMXxzaSl8dXRzdHx2NDAwfHY3NTB8dmVyaXx2aShyZ3x0ZSl8dmsoNDB8NVswLTNdfFxcLXYpfHZtNDB8dm9kYXx2dWxjfHZ4KDUyfDUzfDYwfDYxfDcwfDgwfDgxfDgzfDg1fDk4KXx3M2MoXFwtfCApfHdlYmN8d2hpdHx3aShnIHxuY3xudyl8d21sYnx3b251fHg3MDB8eWFzXFwtfHlvdXJ8emV0b3x6dGVcXC0vaVxuICAgICAgICAgICAgLnRlc3QoYS5zdWJzdHIoMCwgNCkpO1xufVxuZXhwb3J0cy5pc01vYmlsZSA9IGlzTW9iaWxlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGV2aWNlX3V0aWwuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZGV2aWNlX3V0aWwgPSByZXF1aXJlKFwiLi9kZXZpY2VfdXRpbFwiKTtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcbnZhciBUeXBlO1xuKGZ1bmN0aW9uIChUeXBlKSB7XG4gICAgVHlwZVtUeXBlW1wiTlVNQkVSXCJdID0gMF0gPSBcIk5VTUJFUlwiO1xuICAgIFR5cGVbVHlwZVtcIkJPT0xFQU5cIl0gPSAxXSA9IFwiQk9PTEVBTlwiO1xufSkoVHlwZSA9IGV4cG9ydHMuVHlwZSB8fCAoZXhwb3J0cy5UeXBlID0ge30pKTtcbmV4cG9ydHMuVVJMX1BST1BFUlRJRVMgPSBbXG4gICAgeyBuYW1lOiAnV0VCR0xfRElTSk9JTlRfUVVFUllfVElNRVJfRVhURU5TSU9OX0VOQUJMRUQnLCB0eXBlOiBUeXBlLkJPT0xFQU4gfSxcbiAgICB7IG5hbWU6ICdXRUJHTF9ESVNKT0lOVF9RVUVSWV9USU1FUl9FWFRFTlNJT05fUkVMSUFCTEUnLCB0eXBlOiBUeXBlLkJPT0xFQU4gfSxcbiAgICB7IG5hbWU6ICdXRUJHTF9WRVJTSU9OJywgdHlwZTogVHlwZS5OVU1CRVIgfSxcbiAgICB7IG5hbWU6ICdXRUJHTF9GTE9BVF9URVhUVVJFX0VOQUJMRUQnLCB0eXBlOiBUeXBlLkJPT0xFQU4gfSwge1xuICAgICAgICBuYW1lOiAnV0VCR0xfR0VUX0JVRkZFUl9TVUJfREFUQV9BU1lOQ19FWFRFTlNJT05fRU5BQkxFRCcsXG4gICAgICAgIHR5cGU6IFR5cGUuQk9PTEVBTlxuICAgIH1cbl07XG5mdW5jdGlvbiBnZXRXZWJHTFJlbmRlcmluZ0NvbnRleHQod2ViR0xWZXJzaW9uKSB7XG4gICAgaWYgKHdlYkdMVmVyc2lvbiA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBnZXQgV2ViR0wgcmVuZGVyaW5nIGNvbnRleHQsIFdlYkdMIGlzIGRpc2FibGVkLicpO1xuICAgIH1cbiAgICB2YXIgdGVtcENhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgIGlmICh3ZWJHTFZlcnNpb24gPT09IDEpIHtcbiAgICAgICAgcmV0dXJuICh0ZW1wQ2FudmFzLmdldENvbnRleHQoJ3dlYmdsJykgfHxcbiAgICAgICAgICAgIHRlbXBDYW52YXMuZ2V0Q29udGV4dCgnZXhwZXJpbWVudGFsLXdlYmdsJykpO1xuICAgIH1cbiAgICByZXR1cm4gdGVtcENhbnZhcy5nZXRDb250ZXh0KCd3ZWJnbDInKTtcbn1cbmZ1bmN0aW9uIGxvc2VDb250ZXh0KGdsKSB7XG4gICAgaWYgKGdsICE9IG51bGwpIHtcbiAgICAgICAgdmFyIGxvc2VDb250ZXh0RXh0ZW5zaW9uID0gZ2wuZ2V0RXh0ZW5zaW9uKCdXRUJHTF9sb3NlX2NvbnRleHQnKTtcbiAgICAgICAgaWYgKGxvc2VDb250ZXh0RXh0ZW5zaW9uID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXh0ZW5zaW9uIFdFQkdMX2xvc2VfY29udGV4dCBub3Qgc3VwcG9ydGVkIG9uIHRoaXMgYnJvd3Nlci4nKTtcbiAgICAgICAgfVxuICAgICAgICBsb3NlQ29udGV4dEV4dGVuc2lvbi5sb3NlQ29udGV4dCgpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGlzV2ViR0xWZXJzaW9uRW5hYmxlZCh3ZWJHTFZlcnNpb24pIHtcbiAgICB2YXIgZ2wgPSBnZXRXZWJHTFJlbmRlcmluZ0NvbnRleHQod2ViR0xWZXJzaW9uKTtcbiAgICBpZiAoZ2wgIT0gbnVsbCkge1xuICAgICAgICBsb3NlQ29udGV4dChnbCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBpc1dlYkdMRGlzam9pbnRRdWVyeVRpbWVyRW5hYmxlZCh3ZWJHTFZlcnNpb24pIHtcbiAgICB2YXIgZ2wgPSBnZXRXZWJHTFJlbmRlcmluZ0NvbnRleHQod2ViR0xWZXJzaW9uKTtcbiAgICB2YXIgZXh0ZW5zaW9uTmFtZSA9IHdlYkdMVmVyc2lvbiA9PT0gMSA/ICdFWFRfZGlzam9pbnRfdGltZXJfcXVlcnknIDpcbiAgICAgICAgJ0VYVF9kaXNqb2ludF90aW1lcl9xdWVyeV93ZWJnbDInO1xuICAgIHZhciBleHQgPSBnbC5nZXRFeHRlbnNpb24oZXh0ZW5zaW9uTmFtZSk7XG4gICAgdmFyIGlzRXh0RW5hYmxlZCA9IGV4dCAhPSBudWxsO1xuICAgIGlmIChnbCAhPSBudWxsKSB7XG4gICAgICAgIGxvc2VDb250ZXh0KGdsKTtcbiAgICB9XG4gICAgcmV0dXJuIGlzRXh0RW5hYmxlZDtcbn1cbmZ1bmN0aW9uIGlzRmxvYXRUZXh0dXJlUmVhZFBpeGVsc0VuYWJsZWQod2ViR0xWZXJzaW9uKSB7XG4gICAgaWYgKHdlYkdMVmVyc2lvbiA9PT0gMCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZhciBnbCA9IGdldFdlYkdMUmVuZGVyaW5nQ29udGV4dCh3ZWJHTFZlcnNpb24pO1xuICAgIGlmICh3ZWJHTFZlcnNpb24gPT09IDEpIHtcbiAgICAgICAgaWYgKGdsLmdldEV4dGVuc2lvbignT0VTX3RleHR1cmVfZmxvYXQnKSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmIChnbC5nZXRFeHRlbnNpb24oJ0VYVF9jb2xvcl9idWZmZXJfZmxvYXQnKSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIGZyYW1lQnVmZmVyID0gZ2wuY3JlYXRlRnJhbWVidWZmZXIoKTtcbiAgICB2YXIgdGV4dHVyZSA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcbiAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZXh0dXJlKTtcbiAgICB2YXIgaW50ZXJuYWxGb3JtYXQgPSB3ZWJHTFZlcnNpb24gPT09IDIgPyBnbC5SR0JBMzJGIDogZ2wuUkdCQTtcbiAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGludGVybmFsRm9ybWF0LCAxLCAxLCAwLCBnbC5SR0JBLCBnbC5GTE9BVCwgbnVsbCk7XG4gICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBmcmFtZUJ1ZmZlcik7XG4gICAgZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoZ2wuRlJBTUVCVUZGRVIsIGdsLkNPTE9SX0FUVEFDSE1FTlQwLCBnbC5URVhUVVJFXzJELCB0ZXh0dXJlLCAwKTtcbiAgICB2YXIgZnJhbWVCdWZmZXJDb21wbGV0ZSA9IChnbC5jaGVja0ZyYW1lYnVmZmVyU3RhdHVzKGdsLkZSQU1FQlVGRkVSKSA9PT0gZ2wuRlJBTUVCVUZGRVJfQ09NUExFVEUpO1xuICAgIGdsLnJlYWRQaXhlbHMoMCwgMCwgMSwgMSwgZ2wuUkdCQSwgZ2wuRkxPQVQsIG5ldyBGbG9hdDMyQXJyYXkoNCkpO1xuICAgIHZhciByZWFkUGl4ZWxzTm9FcnJvciA9IGdsLmdldEVycm9yKCkgPT09IGdsLk5PX0VSUk9SO1xuICAgIGxvc2VDb250ZXh0KGdsKTtcbiAgICByZXR1cm4gZnJhbWVCdWZmZXJDb21wbGV0ZSAmJiByZWFkUGl4ZWxzTm9FcnJvcjtcbn1cbmZ1bmN0aW9uIGlzV2ViR0xHZXRCdWZmZXJTdWJEYXRhQXN5bmNFeHRlbnNpb25FbmFibGVkKHdlYkdMVmVyc2lvbikge1xuICAgIGlmICh3ZWJHTFZlcnNpb24gIT09IDIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2YXIgZ2wgPSBnZXRXZWJHTFJlbmRlcmluZ0NvbnRleHQod2ViR0xWZXJzaW9uKTtcbiAgICB2YXIgZXh0ID0gZ2wuZ2V0RXh0ZW5zaW9uKCdXRUJHTF9nZXRfYnVmZmVyX3N1Yl9kYXRhX2FzeW5jJyk7XG4gICAgdmFyIGlzRW5hYmxlZCA9IGV4dCAhPSBudWxsO1xuICAgIGxvc2VDb250ZXh0KGdsKTtcbiAgICByZXR1cm4gaXNFbmFibGVkO1xufVxudmFyIEVudmlyb25tZW50ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBFbnZpcm9ubWVudChmZWF0dXJlcykge1xuICAgICAgICB0aGlzLmZlYXR1cmVzID0ge307XG4gICAgICAgIGlmIChmZWF0dXJlcyAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmZlYXR1cmVzID0gZmVhdHVyZXM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgRW52aXJvbm1lbnQucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChmZWF0dXJlKSB7XG4gICAgICAgIGlmIChmZWF0dXJlIGluIHRoaXMuZmVhdHVyZXMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZlYXR1cmVzW2ZlYXR1cmVdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZmVhdHVyZXNbZmVhdHVyZV0gPSB0aGlzLmV2YWx1YXRlRmVhdHVyZShmZWF0dXJlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmVhdHVyZXNbZmVhdHVyZV07XG4gICAgfTtcbiAgICBFbnZpcm9ubWVudC5wcm90b3R5cGUuZXZhbHVhdGVGZWF0dXJlID0gZnVuY3Rpb24gKGZlYXR1cmUpIHtcbiAgICAgICAgaWYgKGZlYXR1cmUgPT09ICdXRUJHTF9ESVNKT0lOVF9RVUVSWV9USU1FUl9FWFRFTlNJT05fRU5BQkxFRCcpIHtcbiAgICAgICAgICAgIHZhciB3ZWJHTFZlcnNpb24gPSB0aGlzLmdldCgnV0VCR0xfVkVSU0lPTicpO1xuICAgICAgICAgICAgaWYgKHdlYkdMVmVyc2lvbiA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpc1dlYkdMRGlzam9pbnRRdWVyeVRpbWVyRW5hYmxlZCh3ZWJHTFZlcnNpb24pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGZlYXR1cmUgPT09ICdXRUJHTF9ESVNKT0lOVF9RVUVSWV9USU1FUl9FWFRFTlNJT05fUkVMSUFCTEUnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXQoJ1dFQkdMX0RJU0pPSU5UX1FVRVJZX1RJTUVSX0VYVEVOU0lPTl9FTkFCTEVEJykgJiZcbiAgICAgICAgICAgICAgICAhZGV2aWNlX3V0aWwuaXNNb2JpbGUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChmZWF0dXJlID09PSAnV0VCR0xfVkVSU0lPTicpIHtcbiAgICAgICAgICAgIGlmIChpc1dlYkdMVmVyc2lvbkVuYWJsZWQoMikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzV2ViR0xWZXJzaW9uRW5hYmxlZCgxKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZmVhdHVyZSA9PT0gJ1dFQkdMX0ZMT0FUX1RFWFRVUkVfRU5BQkxFRCcpIHtcbiAgICAgICAgICAgIHJldHVybiBpc0Zsb2F0VGV4dHVyZVJlYWRQaXhlbHNFbmFibGVkKHRoaXMuZ2V0KCdXRUJHTF9WRVJTSU9OJykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGZlYXR1cmUgPT09ICdXRUJHTF9HRVRfQlVGRkVSX1NVQl9EQVRBX0FTWU5DX0VYVEVOU0lPTl9FTkFCTEVEJykge1xuICAgICAgICAgICAgcmV0dXJuIGlzV2ViR0xHZXRCdWZmZXJTdWJEYXRhQXN5bmNFeHRlbnNpb25FbmFibGVkKHRoaXMuZ2V0KCdXRUJHTF9WRVJTSU9OJykpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gZmVhdHVyZSBcIiArIGZlYXR1cmUgKyBcIi5cIik7XG4gICAgfTtcbiAgICByZXR1cm4gRW52aXJvbm1lbnQ7XG59KCkpO1xuZXhwb3J0cy5FbnZpcm9ubWVudCA9IEVudmlyb25tZW50O1xudmFyIERFRVBMRUFSTkpTX0ZMQUdTX1BSRUZJWCA9ICdkbGpzZmxhZ3MnO1xuZnVuY3Rpb24gZ2V0RmVhdHVyZXNGcm9tVVJMKCkge1xuICAgIHZhciBmZWF0dXJlcyA9IHt9O1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gZmVhdHVyZXM7XG4gICAgfVxuICAgIHZhciB1cmxQYXJhbXMgPSB1dGlsLmdldFF1ZXJ5UGFyYW1zKHdpbmRvdy5sb2NhdGlvbi5zZWFyY2gpO1xuICAgIGlmIChERUVQTEVBUk5KU19GTEFHU19QUkVGSVggaW4gdXJsUGFyYW1zKSB7XG4gICAgICAgIHZhciB1cmxGbGFnc18xID0ge307XG4gICAgICAgIHZhciBrZXlWYWx1ZXMgPSB1cmxQYXJhbXNbREVFUExFQVJOSlNfRkxBR1NfUFJFRklYXS5zcGxpdCgnLCcpO1xuICAgICAgICBrZXlWYWx1ZXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5VmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBfYSA9IGtleVZhbHVlLnNwbGl0KCc6JyksIGtleSA9IF9hWzBdLCB2YWx1ZSA9IF9hWzFdO1xuICAgICAgICAgICAgdXJsRmxhZ3NfMVtrZXldID0gdmFsdWU7XG4gICAgICAgIH0pO1xuICAgICAgICBleHBvcnRzLlVSTF9QUk9QRVJUSUVTLmZvckVhY2goZnVuY3Rpb24gKHVybFByb3BlcnR5KSB7XG4gICAgICAgICAgICBpZiAodXJsUHJvcGVydHkubmFtZSBpbiB1cmxGbGFnc18xKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJTZXR0aW5nIGZlYXR1cmUgb3ZlcnJpZGUgZnJvbSBVUkwgXCIgKyB1cmxQcm9wZXJ0eS5uYW1lICsgXCI6IFwiICtcbiAgICAgICAgICAgICAgICAgICAgKFwiXCIgKyB1cmxGbGFnc18xW3VybFByb3BlcnR5Lm5hbWVdKSk7XG4gICAgICAgICAgICAgICAgaWYgKHVybFByb3BlcnR5LnR5cGUgPT09IFR5cGUuTlVNQkVSKSB7XG4gICAgICAgICAgICAgICAgICAgIGZlYXR1cmVzW3VybFByb3BlcnR5Lm5hbWVdID0gK3VybEZsYWdzXzFbdXJsUHJvcGVydHkubmFtZV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHVybFByb3BlcnR5LnR5cGUgPT09IFR5cGUuQk9PTEVBTikge1xuICAgICAgICAgICAgICAgICAgICBmZWF0dXJlc1t1cmxQcm9wZXJ0eS5uYW1lXSA9IHVybEZsYWdzXzFbdXJsUHJvcGVydHkubmFtZV0gPT09ICd0cnVlJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlVua25vd24gVVJMIHBhcmFtOiBcIiArIHVybFByb3BlcnR5Lm5hbWUgKyBcIi5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGZlYXR1cmVzO1xufVxuZXhwb3J0cy5FTlYgPSBuZXcgRW52aXJvbm1lbnQoZ2V0RmVhdHVyZXNGcm9tVVJMKCkpO1xuZnVuY3Rpb24gc2V0RW52aXJvbm1lbnQoZW52aXJvbm1lbnQpIHtcbiAgICBleHBvcnRzLkVOViA9IGVudmlyb25tZW50O1xufVxuZXhwb3J0cy5zZXRFbnZpcm9ubWVudCA9IHNldEVudmlyb25tZW50O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZW52aXJvbm1lbnQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBpbml0aWFsaXplcnNfMSA9IHJlcXVpcmUoXCIuLi9pbml0aWFsaXplcnNcIik7XG52YXIgY29uY2F0X3V0aWwgPSByZXF1aXJlKFwiLi4vbWF0aC9jb25jYXRfdXRpbFwiKTtcbnZhciBjb252X3V0aWwgPSByZXF1aXJlKFwiLi4vbWF0aC9jb252X3V0aWxcIik7XG52YXIgbmRhcnJheV8xID0gcmVxdWlyZShcIi4uL21hdGgvbmRhcnJheVwiKTtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG52YXIgR3JhcGhMYXllcnMgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEdyYXBoTGF5ZXJzKGcpIHtcbiAgICAgICAgdGhpcy5nID0gZztcbiAgICB9XG4gICAgR3JhcGhMYXllcnMucHJvdG90eXBlLmRlbnNlID0gZnVuY3Rpb24gKG5hbWUsIHgsIHVuaXRzLCBhY3RpdmF0aW9uLCB1c2VCaWFzLCBrZXJuZWxJbml0aWFsaXplciwgYmlhc0luaXRpYWxpemVyKSB7XG4gICAgICAgIGlmIChhY3RpdmF0aW9uID09PSB2b2lkIDApIHsgYWN0aXZhdGlvbiA9IG51bGw7IH1cbiAgICAgICAgaWYgKHVzZUJpYXMgPT09IHZvaWQgMCkgeyB1c2VCaWFzID0gdHJ1ZTsgfVxuICAgICAgICBpZiAoa2VybmVsSW5pdGlhbGl6ZXIgPT09IHZvaWQgMCkgeyBrZXJuZWxJbml0aWFsaXplciA9IG5ldyBpbml0aWFsaXplcnNfMS5WYXJpYW5jZVNjYWxpbmdJbml0aWFsaXplcigpOyB9XG4gICAgICAgIGlmIChiaWFzSW5pdGlhbGl6ZXIgPT09IHZvaWQgMCkgeyBiaWFzSW5pdGlhbGl6ZXIgPSBuZXcgaW5pdGlhbGl6ZXJzXzEuWmVyb3NJbml0aWFsaXplcigpOyB9XG4gICAgICAgIHZhciB3ZWlnaHRzID0gdGhpcy5nLnZhcmlhYmxlKG5hbWUgKyAnLXdlaWdodHMnLCBrZXJuZWxJbml0aWFsaXplci5pbml0aWFsaXplKFt4LnNoYXBlWzBdLCB1bml0c10sIHguc2hhcGVbMF0sIHVuaXRzKSk7XG4gICAgICAgIHZhciBvdXQgPSB0aGlzLmcubWF0bXVsKHgsIHdlaWdodHMpO1xuICAgICAgICBpZiAodXNlQmlhcykge1xuICAgICAgICAgICAgdmFyIGJpYXMgPSB0aGlzLmcudmFyaWFibGUobmFtZSArICctYmlhcycsIGJpYXNJbml0aWFsaXplci5pbml0aWFsaXplKFt1bml0c10sIHguc2hhcGVbMF0sIHVuaXRzKSk7XG4gICAgICAgICAgICBvdXQgPSB0aGlzLmcuYWRkKG91dCwgYmlhcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFjdGl2YXRpb24gIT0gbnVsbCkge1xuICAgICAgICAgICAgb3V0ID0gYWN0aXZhdGlvbihvdXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfTtcbiAgICByZXR1cm4gR3JhcGhMYXllcnM7XG59KCkpO1xuZXhwb3J0cy5HcmFwaExheWVycyA9IEdyYXBoTGF5ZXJzO1xudmFyIEdyYXBoID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBHcmFwaCgpIHtcbiAgICAgICAgdGhpcy5ub2RlcyA9IFtdO1xuICAgICAgICB0aGlzLmxheWVycyA9IG5ldyBHcmFwaExheWVycyh0aGlzKTtcbiAgICB9XG4gICAgR3JhcGgucHJvdG90eXBlLnZhcmlhYmxlID0gZnVuY3Rpb24gKG5hbWUsIGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkTm9kZUFuZFJldHVybk91dHB1dChuZXcgVmFyaWFibGVOb2RlKHRoaXMsIG5hbWUsIGRhdGEpKTtcbiAgICB9O1xuICAgIEdyYXBoLnByb3RvdHlwZS5wbGFjZWhvbGRlciA9IGZ1bmN0aW9uIChuYW1lLCBzaGFwZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5hZGROb2RlQW5kUmV0dXJuT3V0cHV0KG5ldyBQbGFjZWhvbGRlck5vZGUodGhpcywgbmFtZSwgc2hhcGUpKTtcbiAgICB9O1xuICAgIEdyYXBoLnByb3RvdHlwZS5jb25zdGFudCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgZmluYWxWYWx1ZTtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGZpbmFsVmFsdWUgPSBuZGFycmF5XzEuU2NhbGFyLm5ldyh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBuZGFycmF5XzEuTkRBcnJheSkge1xuICAgICAgICAgICAgZmluYWxWYWx1ZSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgIHZhciBmbGF0VmFsdWVzID0gdXRpbC5mbGF0dGVuKHZhbHVlKTtcbiAgICAgICAgICAgIHZhciB2YWxzID0gbmV3IEZsb2F0MzJBcnJheShmbGF0VmFsdWVzKTtcbiAgICAgICAgICAgIGZpbmFsVmFsdWUgPSBuZGFycmF5XzEuTkRBcnJheS5tYWtlKHV0aWwuaW5mZXJTaGFwZSh2YWx1ZSksIHsgdmFsdWVzOiB2YWxzIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmltcGxlbWVudGVkIGNvbnN0YW50IHR5cGUuJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkTm9kZUFuZFJldHVybk91dHB1dChuZXcgQ29uc3RhbnROb2RlKHRoaXMsIGZpbmFsVmFsdWUpKTtcbiAgICB9O1xuICAgIEdyYXBoLnByb3RvdHlwZS5yZXNoYXBlID0gZnVuY3Rpb24gKHgsIHNoYXBlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZE5vZGVBbmRSZXR1cm5PdXRwdXQobmV3IFJlc2hhcGVOb2RlKHRoaXMsICdSZXNoYXBlJywgeCwgc2hhcGUpKTtcbiAgICB9O1xuICAgIEdyYXBoLnByb3RvdHlwZS5mdXNlZExpbmVhckNvbWJpbmF0aW9uID0gZnVuY3Rpb24gKHgxLCB4MiwgYzEsIGMyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZE5vZGVBbmRSZXR1cm5PdXRwdXQobmV3IEZ1c2VkTGluZWFyQ29tYmluYXRpb25Ob2RlKHRoaXMsIHgxLCB4MiwgYzEsIGMyKSk7XG4gICAgfTtcbiAgICBHcmFwaC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKHgxLCB4Mikge1xuICAgICAgICByZXR1cm4gdGhpcy5hZGROb2RlQW5kUmV0dXJuT3V0cHV0KG5ldyBBZGROb2RlKHRoaXMsIHgxLCB4MikpO1xuICAgIH07XG4gICAgR3JhcGgucHJvdG90eXBlLnN1YnRyYWN0ID0gZnVuY3Rpb24gKHgxLCB4Mikge1xuICAgICAgICByZXR1cm4gdGhpcy5hZGROb2RlQW5kUmV0dXJuT3V0cHV0KG5ldyBTdWJ0cmFjdE5vZGUodGhpcywgeDEsIHgyKSk7XG4gICAgfTtcbiAgICBHcmFwaC5wcm90b3R5cGUubXVsdGlwbHkgPSBmdW5jdGlvbiAoeDEsIHgyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZE5vZGVBbmRSZXR1cm5PdXRwdXQobmV3IE11bHRpcGx5Tm9kZSh0aGlzLCB4MSwgeDIpKTtcbiAgICB9O1xuICAgIEdyYXBoLnByb3RvdHlwZS5kaXZpZGUgPSBmdW5jdGlvbiAoeDEsIHgyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZE5vZGVBbmRSZXR1cm5PdXRwdXQobmV3IERpdmlkZU5vZGUodGhpcywgeDEsIHgyKSk7XG4gICAgfTtcbiAgICBHcmFwaC5wcm90b3R5cGUucmVkdWNlU3VtID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkTm9kZUFuZFJldHVybk91dHB1dChuZXcgUmVkdWNlU3VtTm9kZSh0aGlzLCB4KSk7XG4gICAgfTtcbiAgICBHcmFwaC5wcm90b3R5cGUuY29uY2F0M2QgPSBmdW5jdGlvbiAoeDEsIHgyLCBheGlzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZE5vZGVBbmRSZXR1cm5PdXRwdXQobmV3IENvbmNhdDNETm9kZSh0aGlzLCB4MSwgeDIsIGF4aXMpKTtcbiAgICB9O1xuICAgIEdyYXBoLnByb3RvdHlwZS5tYXRtdWwgPSBmdW5jdGlvbiAoeDEsIHgyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZE5vZGVBbmRSZXR1cm5PdXRwdXQobmV3IE1hdE11bE5vZGUodGhpcywgeDEsIHgyKSk7XG4gICAgfTtcbiAgICBHcmFwaC5wcm90b3R5cGUuY29udjJkID0gZnVuY3Rpb24gKHgsIHcsIGIsIGZpZWxkU2l6ZSwgb3V0cHV0RGVwdGgsIHN0cmlkZSwgemVyb1BhZCkge1xuICAgICAgICBpZiAoc3RyaWRlID09PSB2b2lkIDApIHsgc3RyaWRlID0gMTsgfVxuICAgICAgICByZXR1cm4gdGhpcy5hZGROb2RlQW5kUmV0dXJuT3V0cHV0KG5ldyBDb252b2x1dGlvbjJETm9kZSh0aGlzLCB4LCB3LCBiLCBmaWVsZFNpemUsIG91dHB1dERlcHRoLCBzdHJpZGUsIHplcm9QYWQpKTtcbiAgICB9O1xuICAgIEdyYXBoLnByb3RvdHlwZS5tYXhQb29sID0gZnVuY3Rpb24gKHgsIGZpZWxkU2l6ZSwgc3RyaWRlLCB6ZXJvUGFkKSB7XG4gICAgICAgIGlmIChzdHJpZGUgPT09IHZvaWQgMCkgeyBzdHJpZGUgPSAxOyB9XG4gICAgICAgIHJldHVybiB0aGlzLmFkZE5vZGVBbmRSZXR1cm5PdXRwdXQobmV3IE1heFBvb2xOb2RlKHRoaXMsIHgsIGZpZWxkU2l6ZSwgc3RyaWRlLCB6ZXJvUGFkKSk7XG4gICAgfTtcbiAgICBHcmFwaC5wcm90b3R5cGUuZXhwID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkTm9kZUFuZFJldHVybk91dHB1dChuZXcgRXhwTm9kZSh0aGlzLCB4KSk7XG4gICAgfTtcbiAgICBHcmFwaC5wcm90b3R5cGUubG9nID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkTm9kZUFuZFJldHVybk91dHB1dChuZXcgTG9nTm9kZSh0aGlzLCB4KSk7XG4gICAgfTtcbiAgICBHcmFwaC5wcm90b3R5cGUucmVsdSA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZE5vZGVBbmRSZXR1cm5PdXRwdXQobmV3IFJlTFVOb2RlKHRoaXMsIHgpKTtcbiAgICB9O1xuICAgIEdyYXBoLnByb3RvdHlwZS5sZWFreVJlbHUgPSBmdW5jdGlvbiAoeCwgYWxwaGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkTm9kZUFuZFJldHVybk91dHB1dChuZXcgTGVha3lSZUxVTm9kZSh0aGlzLCB4LCBhbHBoYSkpO1xuICAgIH07XG4gICAgR3JhcGgucHJvdG90eXBlLnRhbmggPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hZGROb2RlQW5kUmV0dXJuT3V0cHV0KG5ldyBUYW5ITm9kZSh0aGlzLCB4KSk7XG4gICAgfTtcbiAgICBHcmFwaC5wcm90b3R5cGUuc2lnbW9pZCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZE5vZGVBbmRSZXR1cm5PdXRwdXQobmV3IFNpZ21vaWROb2RlKHRoaXMsIHgpKTtcbiAgICB9O1xuICAgIEdyYXBoLnByb3RvdHlwZS5zcXVhcmUgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hZGROb2RlQW5kUmV0dXJuT3V0cHV0KG5ldyBTcXVhcmVOb2RlKHRoaXMsIHgpKTtcbiAgICB9O1xuICAgIEdyYXBoLnByb3RvdHlwZS5zb2Z0bWF4ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkTm9kZUFuZFJldHVybk91dHB1dChuZXcgU29mdG1heE5vZGUodGhpcywgeCkpO1xuICAgIH07XG4gICAgR3JhcGgucHJvdG90eXBlLnNvZnRtYXhDcm9zc0VudHJvcHlDb3N0ID0gZnVuY3Rpb24gKHgsIHRhcmdldCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hZGROb2RlQW5kUmV0dXJuT3V0cHV0KG5ldyBTb2Z0bWF4Q3Jvc3NFbnRyb3B5Q29zdE5vZGUodGhpcywgeCwgdGFyZ2V0KSk7XG4gICAgfTtcbiAgICBHcmFwaC5wcm90b3R5cGUubWVhblNxdWFyZWRDb3N0ID0gZnVuY3Rpb24gKGxhYmVsLCBwcmVkaWN0aW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZE5vZGVBbmRSZXR1cm5PdXRwdXQobmV3IE1lYW5TcXVhcmVkQ29zdE5vZGUodGhpcywgbGFiZWwsIHByZWRpY3Rpb24pKTtcbiAgICB9O1xuICAgIEdyYXBoLnByb3RvdHlwZS5hcmdtYXggPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hZGROb2RlQW5kUmV0dXJuT3V0cHV0KG5ldyBBcmdNYXhOb2RlKHRoaXMsIHgpKTtcbiAgICB9O1xuICAgIEdyYXBoLnByb3RvdHlwZS5hcmdtYXhFcXVhbHMgPSBmdW5jdGlvbiAoeDEsIHgyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZE5vZGVBbmRSZXR1cm5PdXRwdXQobmV3IEFyZ01heEVxdWFsc05vZGUodGhpcywgeDEsIHgyKSk7XG4gICAgfTtcbiAgICBHcmFwaC5wcm90b3R5cGUuYWRkTm9kZUFuZFJldHVybk91dHB1dCA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHRoaXMubm9kZXMucHVzaChub2RlKTtcbiAgICAgICAgbm9kZS52YWxpZGF0ZSgpO1xuICAgICAgICByZXR1cm4gbm9kZS5vdXRwdXQ7XG4gICAgfTtcbiAgICBHcmFwaC5wcm90b3R5cGUuZ2V0Tm9kZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5vZGVzO1xuICAgIH07XG4gICAgcmV0dXJuIEdyYXBoO1xufSgpKTtcbmV4cG9ydHMuR3JhcGggPSBHcmFwaDtcbnZhciBUZW5zb3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRlbnNvcihzaGFwZSkge1xuICAgICAgICB0aGlzLnNoYXBlID0gc2hhcGU7XG4gICAgICAgIHRoaXMuaWQgPSBUZW5zb3IubmV4dElEKys7XG4gICAgfVxuICAgIFRlbnNvci5uZXh0SUQgPSAwO1xuICAgIHJldHVybiBUZW5zb3I7XG59KCkpO1xuZXhwb3J0cy5UZW5zb3IgPSBUZW5zb3I7XG52YXIgTm9kZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTm9kZShncmFwaCwgbmFtZSwgaW5wdXRzLCBvdXRwdXQpIHtcbiAgICAgICAgdGhpcy5ncmFwaCA9IGdyYXBoO1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLmlucHV0cyA9IGlucHV0cztcbiAgICAgICAgdGhpcy5vdXRwdXQgPSBvdXRwdXQ7XG4gICAgICAgIHRoaXMuaWQgPSBOb2RlLm5leHRJRCsrO1xuICAgICAgICBvdXRwdXQubm9kZSA9IHRoaXM7XG4gICAgfVxuICAgIE5vZGUubmV4dElEID0gMDtcbiAgICByZXR1cm4gTm9kZTtcbn0oKSk7XG5leHBvcnRzLk5vZGUgPSBOb2RlO1xudmFyIFZhcmlhYmxlTm9kZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFZhcmlhYmxlTm9kZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBWYXJpYWJsZU5vZGUoZ3JhcGgsIG5hbWUsIGRhdGEpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZ3JhcGgsIG5hbWUsIHt9LCBuZXcgVGVuc29yKGRhdGEuc2hhcGUpKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5kYXRhID0gZGF0YTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBWYXJpYWJsZU5vZGUucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB1dGlsLmFzc2VydCh0aGlzLmRhdGEgIT0gbnVsbCwgJ0Vycm9yIGFkZGluZyB2YXJpYWJsZSBvcDogRGF0YSBmb3IgdmFyaWFibGUgXFwnJyArIHRoaXMubmFtZSArXG4gICAgICAgICAgICAnXFwnIGlzIG51bGwgb3IgdW5kZWZpbmVkJyk7XG4gICAgfTtcbiAgICByZXR1cm4gVmFyaWFibGVOb2RlO1xufShOb2RlKSk7XG5leHBvcnRzLlZhcmlhYmxlTm9kZSA9IFZhcmlhYmxlTm9kZTtcbnZhciBQbGFjZWhvbGRlck5vZGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhQbGFjZWhvbGRlck5vZGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUGxhY2Vob2xkZXJOb2RlKGdyYXBoLCBuYW1lLCBzaGFwZSkge1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgZ3JhcGgsIG5hbWUsIHt9LCBuZXcgVGVuc29yKHNoYXBlKSkgfHwgdGhpcztcbiAgICB9XG4gICAgUGxhY2Vob2xkZXJOb2RlLnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICByZXR1cm4gUGxhY2Vob2xkZXJOb2RlO1xufShOb2RlKSk7XG5leHBvcnRzLlBsYWNlaG9sZGVyTm9kZSA9IFBsYWNlaG9sZGVyTm9kZTtcbnZhciBDb25zdGFudE5vZGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDb25zdGFudE5vZGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ29uc3RhbnROb2RlKGdyYXBoLCBkYXRhKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGdyYXBoLCAnQ29uc3RhbnQnLCB7fSwgbmV3IFRlbnNvcihkYXRhLnNoYXBlKSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuZGF0YSA9IGRhdGE7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgQ29uc3RhbnROb2RlLnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdXRpbC5hc3NlcnQodGhpcy5kYXRhICE9IG51bGwsICdFcnJvciBhZGRpbmcgY29uc3RhbnQ6IGRhdGEgZm9yIHBsYWNlaG9sZGVyIFxcJycgKyB0aGlzLm5hbWUgK1xuICAgICAgICAgICAgJ1xcJyBpcyBudWxsIG9yIHVuZGVmaW5lZCcpO1xuICAgIH07XG4gICAgcmV0dXJuIENvbnN0YW50Tm9kZTtcbn0oTm9kZSkpO1xuZXhwb3J0cy5Db25zdGFudE5vZGUgPSBDb25zdGFudE5vZGU7XG52YXIgUmVzaGFwZU5vZGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhSZXNoYXBlTm9kZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBSZXNoYXBlTm9kZShncmFwaCwgbmFtZSwgeCwgc2hhcGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZ3JhcGgsIG5hbWUsIHsgeDogeCB9LCBuZXcgVGVuc29yKHNoYXBlKSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIF90aGlzLnggPSB4O1xuICAgICAgICBfdGhpcy5zaGFwZSA9IHNoYXBlO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFJlc2hhcGVOb2RlLnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHhTaXplID0gdXRpbC5zaXplRnJvbVNoYXBlKHRoaXMueC5zaGFwZSk7XG4gICAgICAgIHZhciBzaGFwZVNpemUgPSB1dGlsLnNpemVGcm9tU2hhcGUodGhpcy5zaGFwZSk7XG4gICAgICAgIHV0aWwuYXNzZXJ0KHhTaXplID09PSBzaGFwZVNpemUsIFwiRXJyb3IgbWFraW5nIHJlc2hhcGUgb3BlcmF0aW9uOiBpbnB1dCB0byByZXNoYXBlICdcIiArIHRoaXMubmFtZSArIFwiJ1wiICtcbiAgICAgICAgICAgIChcIiBvZiBzaGFwZSAoXCIgKyB0aGlzLnguc2hhcGUgKyBcIikgZG9lcyBub3QgbWF0Y2ggc2l6ZSBvZiBcIikgK1xuICAgICAgICAgICAgKFwicmVxdWVzdGVkIHNoYXBlIFwiICsgdGhpcy5zaGFwZSArIFwiLlwiKSk7XG4gICAgfTtcbiAgICBSZXNoYXBlTm9kZS5YID0gJ3gnO1xuICAgIHJldHVybiBSZXNoYXBlTm9kZTtcbn0oTm9kZSkpO1xuZXhwb3J0cy5SZXNoYXBlTm9kZSA9IFJlc2hhcGVOb2RlO1xudmFyIEZ1c2VkTGluZWFyQ29tYmluYXRpb25Ob2RlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRnVzZWRMaW5lYXJDb21iaW5hdGlvbk5vZGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRnVzZWRMaW5lYXJDb21iaW5hdGlvbk5vZGUoZ3JhcGgsIHQxLCB0MiwgYzEsIGMyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGdyYXBoLCAnTGluZWFyIENvbWJpbmF0aW9uJywgeyB0MTogdDEsIHQyOiB0MiwgYzE6IGMxLCBjMjogYzIgfSwgbmV3IFRlbnNvcih0MS5zaGFwZSkpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnQxID0gdDE7XG4gICAgICAgIF90aGlzLnQyID0gdDI7XG4gICAgICAgIF90aGlzLmMxID0gYzE7XG4gICAgICAgIF90aGlzLmMyID0gYzI7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgRnVzZWRMaW5lYXJDb21iaW5hdGlvbk5vZGUucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB1dGlsLmFzc2VydFNoYXBlc01hdGNoKHRoaXMudDEuc2hhcGUsIHRoaXMudDIuc2hhcGUpO1xuICAgICAgICBpZiAoIXV0aWwuaXNTY2FsYXJTaGFwZSh0aGlzLmMxLnNoYXBlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFcnJvciBhZGRpbmcgZnVzZWRMaW5lYXJDb21iaW5hdGlvbjogYzEgaXMgbm90IGEgc2NhbGFyLCBnb3QgJyArXG4gICAgICAgICAgICAgICAgKFwic2hhcGU6IFwiICsgdGhpcy5jMS5zaGFwZSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdXRpbC5pc1NjYWxhclNoYXBlKHRoaXMuYzIuc2hhcGUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Vycm9yIGFkZGluZyBmdXNlZExpbmVhckNvbWJpbmF0aW9uOiBjMiBpcyBub3QgYSBzY2FsYXIsIGdvdCAnICtcbiAgICAgICAgICAgICAgICAoXCJzaGFwZTogXCIgKyB0aGlzLmMyLnNoYXBlKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEZ1c2VkTGluZWFyQ29tYmluYXRpb25Ob2RlLlQxID0gJ3QxJztcbiAgICBGdXNlZExpbmVhckNvbWJpbmF0aW9uTm9kZS5UMiA9ICd0Mic7XG4gICAgRnVzZWRMaW5lYXJDb21iaW5hdGlvbk5vZGUuQzEgPSAnYzEnO1xuICAgIEZ1c2VkTGluZWFyQ29tYmluYXRpb25Ob2RlLkMyID0gJ2MyJztcbiAgICByZXR1cm4gRnVzZWRMaW5lYXJDb21iaW5hdGlvbk5vZGU7XG59KE5vZGUpKTtcbmV4cG9ydHMuRnVzZWRMaW5lYXJDb21iaW5hdGlvbk5vZGUgPSBGdXNlZExpbmVhckNvbWJpbmF0aW9uTm9kZTtcbnZhciBBZGROb2RlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQWRkTm9kZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBZGROb2RlKGdyYXBoLCB0MSwgdDIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZ3JhcGgsICdBZGQnLCB7IHQxOiB0MSwgdDI6IHQyIH0sIG5ldyBUZW5zb3IodXRpbC5zaXplRnJvbVNoYXBlKHQxLnNoYXBlKSA9PT0gMSA/IHQyLnNoYXBlIDogdDEuc2hhcGUpKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50MSA9IHQxO1xuICAgICAgICBfdGhpcy50MiA9IHQyO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEFkZE5vZGUucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB1dGlsLmFzc2VydCh1dGlsLnNpemVGcm9tU2hhcGUodGhpcy50MS5zaGFwZSkgPT09IDEgfHxcbiAgICAgICAgICAgIHV0aWwuc2l6ZUZyb21TaGFwZSh0aGlzLnQyLnNoYXBlKSA9PT0gMSB8fFxuICAgICAgICAgICAgdXRpbC5hcnJheXNFcXVhbCh0aGlzLnQxLnNoYXBlLCB0aGlzLnQyLnNoYXBlKSwgJ0Vycm9yIGFkZGluZyBhZGQgb3BlcmF0aW9uIG9wOiBvbmUgb2YgaW5wdXRzIG11c3QgYmUgc2NhbGFyIG9yIHRoZSAnICtcbiAgICAgICAgICAgIChcInNoYXBlcyBcIiArIHRoaXMudDEuc2hhcGUgKyBcIiBhbmQgXCIgKyB0aGlzLnQyLnNoYXBlICsgXCIgbXVzdCBtYXRjaC5cIikpO1xuICAgIH07XG4gICAgQWRkTm9kZS5UMSA9ICd0MSc7XG4gICAgQWRkTm9kZS5UMiA9ICd0Mic7XG4gICAgcmV0dXJuIEFkZE5vZGU7XG59KE5vZGUpKTtcbmV4cG9ydHMuQWRkTm9kZSA9IEFkZE5vZGU7XG52YXIgU3VidHJhY3ROb2RlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU3VidHJhY3ROb2RlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFN1YnRyYWN0Tm9kZShncmFwaCwgdDEsIHQyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGdyYXBoLCAnU3VidHJhY3QnLCB7IHQxOiB0MSwgdDI6IHQyIH0sIG5ldyBUZW5zb3IodXRpbC5zaXplRnJvbVNoYXBlKHQxLnNoYXBlKSA9PT0gMSA/IHQyLnNoYXBlIDogdDEuc2hhcGUpKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50MSA9IHQxO1xuICAgICAgICBfdGhpcy50MiA9IHQyO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFN1YnRyYWN0Tm9kZS5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0KHV0aWwuc2l6ZUZyb21TaGFwZSh0aGlzLnQxLnNoYXBlKSA9PT0gMSB8fFxuICAgICAgICAgICAgdXRpbC5zaXplRnJvbVNoYXBlKHRoaXMudDIuc2hhcGUpID09PSAxIHx8XG4gICAgICAgICAgICB1dGlsLmFycmF5c0VxdWFsKHRoaXMudDEuc2hhcGUsIHRoaXMudDIuc2hhcGUpLCAnRXJyb3IgYWRkaW5nIHN1YnRyYWN0IG9wOiBvbmUgb2YgaW5wdXRzIG11c3QgYmUgc2NhbGFyIG9yIHRoZSAnICtcbiAgICAgICAgICAgIChcInNoYXBlcyBcIiArIHRoaXMudDEuc2hhcGUgKyBcIiBhbmQgXCIgKyB0aGlzLnQyLnNoYXBlICsgXCIgbXVzdCBtYXRjaC5cIikpO1xuICAgIH07XG4gICAgU3VidHJhY3ROb2RlLlQxID0gJ3QxJztcbiAgICBTdWJ0cmFjdE5vZGUuVDIgPSAndDInO1xuICAgIHJldHVybiBTdWJ0cmFjdE5vZGU7XG59KE5vZGUpKTtcbmV4cG9ydHMuU3VidHJhY3ROb2RlID0gU3VidHJhY3ROb2RlO1xudmFyIE11bHRpcGx5Tm9kZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE11bHRpcGx5Tm9kZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNdWx0aXBseU5vZGUoZ3JhcGgsIHQxLCB0Mikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBncmFwaCwgJ011bHRpcGx5JywgeyB0MTogdDEsIHQyOiB0MiB9LCBuZXcgVGVuc29yKHV0aWwuc2l6ZUZyb21TaGFwZSh0MS5zaGFwZSkgPT09IDEgPyB0Mi5zaGFwZSA6IHQxLnNoYXBlKSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudDEgPSB0MTtcbiAgICAgICAgX3RoaXMudDIgPSB0MjtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBNdWx0aXBseU5vZGUucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB1dGlsLmFzc2VydCh1dGlsLnNpemVGcm9tU2hhcGUodGhpcy50MS5zaGFwZSkgPT09IDEgfHxcbiAgICAgICAgICAgIHV0aWwuc2l6ZUZyb21TaGFwZSh0aGlzLnQyLnNoYXBlKSA9PT0gMSB8fFxuICAgICAgICAgICAgdXRpbC5hcnJheXNFcXVhbCh0aGlzLnQxLnNoYXBlLCB0aGlzLnQyLnNoYXBlKSwgJ0Vycm9yIGFkZGluZyBtdWx0aXBseSBvcDogb25lIG9mIGlucHV0cyBtdXN0IGJlIHNjYWxhciBvciB0aGUgJyArXG4gICAgICAgICAgICAoXCJzaGFwZXMgXCIgKyB0aGlzLnQxLnNoYXBlICsgXCIgYW5kIFwiICsgdGhpcy50Mi5zaGFwZSArIFwiIG11c3QgbWF0Y2guXCIpKTtcbiAgICB9O1xuICAgIE11bHRpcGx5Tm9kZS5UMSA9ICd0MSc7XG4gICAgTXVsdGlwbHlOb2RlLlQyID0gJ3QyJztcbiAgICByZXR1cm4gTXVsdGlwbHlOb2RlO1xufShOb2RlKSk7XG5leHBvcnRzLk11bHRpcGx5Tm9kZSA9IE11bHRpcGx5Tm9kZTtcbnZhciBEaXZpZGVOb2RlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRGl2aWRlTm9kZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBEaXZpZGVOb2RlKGdyYXBoLCB0MSwgdDIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZ3JhcGgsICdEaXZpZGUnLCB7IHQxOiB0MSwgdDI6IHQyIH0sIG5ldyBUZW5zb3IodXRpbC5zaXplRnJvbVNoYXBlKHQxLnNoYXBlKSA9PT0gMSA/IHQyLnNoYXBlIDogdDEuc2hhcGUpKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50MSA9IHQxO1xuICAgICAgICBfdGhpcy50MiA9IHQyO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIERpdmlkZU5vZGUucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB1dGlsLmFzc2VydCh1dGlsLnNpemVGcm9tU2hhcGUodGhpcy50MS5zaGFwZSkgPT09IDEgfHxcbiAgICAgICAgICAgIHV0aWwuc2l6ZUZyb21TaGFwZSh0aGlzLnQyLnNoYXBlKSA9PT0gMSB8fFxuICAgICAgICAgICAgdXRpbC5hcnJheXNFcXVhbCh0aGlzLnQxLnNoYXBlLCB0aGlzLnQyLnNoYXBlKSwgJ0Vycm9yIGFkZGluZyBkaXZpZGUgb3A6IG9uZSBvZiBpbnB1dHMgbXVzdCBiZSBzY2FsYXIgb3IgdGhlICcgK1xuICAgICAgICAgICAgKFwic2hhcGVzIFwiICsgdGhpcy50MS5zaGFwZSArIFwiIGFuZCBcIiArIHRoaXMudDIuc2hhcGUgKyBcIiBtdXN0IG1hdGNoLlwiKSk7XG4gICAgfTtcbiAgICBEaXZpZGVOb2RlLlQxID0gJ3QxJztcbiAgICBEaXZpZGVOb2RlLlQyID0gJ3QyJztcbiAgICByZXR1cm4gRGl2aWRlTm9kZTtcbn0oTm9kZSkpO1xuZXhwb3J0cy5EaXZpZGVOb2RlID0gRGl2aWRlTm9kZTtcbnZhciBSZWR1Y2VTdW1Ob2RlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUmVkdWNlU3VtTm9kZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBSZWR1Y2VTdW1Ob2RlKGdyYXBoLCB4KSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBncmFwaCwgJ1JlZHVjZVN1bScsIHsgeDogeCB9LCBuZXcgVGVuc29yKFtdKSkgfHwgdGhpcztcbiAgICB9XG4gICAgUmVkdWNlU3VtTm9kZS5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgUmVkdWNlU3VtTm9kZS5YID0gJ3gnO1xuICAgIHJldHVybiBSZWR1Y2VTdW1Ob2RlO1xufShOb2RlKSk7XG5leHBvcnRzLlJlZHVjZVN1bU5vZGUgPSBSZWR1Y2VTdW1Ob2RlO1xudmFyIENvbmNhdDNETm9kZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENvbmNhdDNETm9kZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDb25jYXQzRE5vZGUoZ3JhcGgsIHgxLCB4MiwgYXhpcykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBncmFwaCwgJ0NvbmNhdDNEJywgeyB4MTogeDEsIHgyOiB4MiB9LCBuZXcgVGVuc29yKGNvbmNhdF91dGlsLmNvbXB1dGVPdXRTaGFwZSh4MS5zaGFwZSwgeDIuc2hhcGUsIGF4aXMpKSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMueDEgPSB4MTtcbiAgICAgICAgX3RoaXMueDIgPSB4MjtcbiAgICAgICAgX3RoaXMuYXhpcyA9IGF4aXM7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgQ29uY2F0M0ROb2RlLnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uY2F0X3V0aWwuYXNzZXJ0UGFyYW1zKHRoaXMueDEuc2hhcGUsIHRoaXMueDIuc2hhcGUsIHRoaXMuYXhpcyk7XG4gICAgfTtcbiAgICBDb25jYXQzRE5vZGUuWDEgPSAneDEnO1xuICAgIENvbmNhdDNETm9kZS5YMiA9ICd4Mic7XG4gICAgQ29uY2F0M0ROb2RlLkFYSVMgPSAnYXhpcyc7XG4gICAgcmV0dXJuIENvbmNhdDNETm9kZTtcbn0oTm9kZSkpO1xuZXhwb3J0cy5Db25jYXQzRE5vZGUgPSBDb25jYXQzRE5vZGU7XG5mdW5jdGlvbiBnZXRNYXRNdWxPdXRwdXRTaGFwZSh4MVNoYXBlLCB4MlNoYXBlKSB7XG4gICAgaWYgKHgxU2hhcGUubGVuZ3RoID09PSAxICYmIHgyU2hhcGUubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybiBbMV07XG4gICAgfVxuICAgIGVsc2UgaWYgKHgxU2hhcGUubGVuZ3RoID09PSAxICYmIHgyU2hhcGUubGVuZ3RoID09PSAyKSB7XG4gICAgICAgIHJldHVybiBbeDJTaGFwZVsxXV07XG4gICAgfVxuICAgIGVsc2UgaWYgKHgxU2hhcGUubGVuZ3RoID09PSAyICYmIHgyU2hhcGUubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybiBbeDFTaGFwZVswXV07XG4gICAgfVxuICAgIHJldHVybiBbeDFTaGFwZVswXSwgeDJTaGFwZVsxXV07XG59XG52YXIgTWF0TXVsTm9kZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1hdE11bE5vZGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWF0TXVsTm9kZShncmFwaCwgeDEsIHgyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGdyYXBoLCAnTWF0TXVsJywgeyB4MTogeDEsIHgyOiB4MiB9LCBuZXcgVGVuc29yKGdldE1hdE11bE91dHB1dFNoYXBlKHgxLnNoYXBlLCB4Mi5zaGFwZSkpKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy54MSA9IHgxO1xuICAgICAgICBfdGhpcy54MiA9IHgyO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE1hdE11bE5vZGUucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy54MS5zaGFwZS5sZW5ndGggPT09IDIgJiYgdGhpcy54Mi5zaGFwZS5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgIHV0aWwuYXNzZXJ0KHRoaXMueDEuc2hhcGVbMV0gPT09IHRoaXMueDIuc2hhcGVbMF0sICdFcnJvciBhZGRpbmcgbWF0bXVsIG9wOiBpbm5lciBzaGFwZXMgb2YgbWF0cmljZXMgd2l0aCBzaGFwZXMgJyArXG4gICAgICAgICAgICAgICAgKHRoaXMueDEuc2hhcGUgKyBcIiBhbmQgXCIgKyB0aGlzLngyLnNoYXBlICsgXCIgbXVzdCBtYXRjaC5cIikpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMueDEuc2hhcGUubGVuZ3RoID09PSAyICYmIHRoaXMueDIuc2hhcGUubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICB1dGlsLmFzc2VydCh0aGlzLngxLnNoYXBlWzFdID09PSB0aGlzLngyLnNoYXBlWzBdLCAnRXJyb3IgYWRkaW5nIG1hdG11bCBvcDogc2Vjb25kIGRpbWVuc2lvbiBvZiBtYXRyaXggd2l0aCBzaGFwZSAnICtcbiAgICAgICAgICAgICAgICB0aGlzLngxLnNoYXBlLnRvU3RyaW5nKCkgK1xuICAgICAgICAgICAgICAgIChcIiBtdXN0IG1hdGNoIHNpemUgb2YgdmVjdG9yIHdpdGggc2hhcGUgXCIgKyB0aGlzLngyLnNoYXBlICsgXCIuXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLngxLnNoYXBlLmxlbmd0aCA9PT0gMSAmJiB0aGlzLngyLnNoYXBlLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgdXRpbC5hc3NlcnQodGhpcy54MS5zaGFwZVswXSA9PT0gdGhpcy54Mi5zaGFwZVswXSwgXCJFcnJvciBhZGRpbmcgbWF0bXVsIG9wOiBzaXplIG9mIHZlY3RvciB3aXRoIHNoYXBlIFwiICsgdGhpcy54MS5zaGFwZSArXG4gICAgICAgICAgICAgICAgXCIgbXVzdCBtYXRjaCBmaXJzdCBkaW1lbnNpb24gb2YgbWF0cml4IHdpdGggXCIgK1xuICAgICAgICAgICAgICAgIChcInNoYXBlIFwiICsgdGhpcy54Mi5zaGFwZSArIFwiLlwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Vycm9yIGFkZGluZyBtYXRtdWwgb3A6IGlucHV0cyBtdXN0IGJlIHZlY3RvcnMgb3IgbWF0cmljZXMuJyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1hdE11bE5vZGUuWDEgPSAneDEnO1xuICAgIE1hdE11bE5vZGUuWDIgPSAneDInO1xuICAgIHJldHVybiBNYXRNdWxOb2RlO1xufShOb2RlKSk7XG5leHBvcnRzLk1hdE11bE5vZGUgPSBNYXRNdWxOb2RlO1xudmFyIENvbnZvbHV0aW9uMkROb2RlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ29udm9sdXRpb24yRE5vZGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ29udm9sdXRpb24yRE5vZGUoZ3JhcGgsIHgsIHcsIGIsIGZpZWxkU2l6ZSwgb3V0cHV0RGVwdGgsIHN0cmlkZSwgemVyb1BhZCkge1xuICAgICAgICBpZiAoc3RyaWRlID09PSB2b2lkIDApIHsgc3RyaWRlID0gMTsgfVxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBncmFwaCwgJ0NvbnZvbHV0aW9uIDJEJywgeyB4OiB4LCB3OiB3LCBiOiBiIH0sIG5ldyBUZW5zb3IoY29udl91dGlsLmNvbXB1dGVPdXRwdXRTaGFwZTNEKHguc2hhcGUsIGZpZWxkU2l6ZSwgb3V0cHV0RGVwdGgsIHN0cmlkZSwgemVyb1BhZCkpKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy54ID0geDtcbiAgICAgICAgX3RoaXMudyA9IHc7XG4gICAgICAgIF90aGlzLmIgPSBiO1xuICAgICAgICBfdGhpcy5maWVsZFNpemUgPSBmaWVsZFNpemU7XG4gICAgICAgIF90aGlzLm91dHB1dERlcHRoID0gb3V0cHV0RGVwdGg7XG4gICAgICAgIF90aGlzLnN0cmlkZSA9IHN0cmlkZTtcbiAgICAgICAgX3RoaXMuemVyb1BhZCA9IHplcm9QYWQ7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgQ29udm9sdXRpb24yRE5vZGUucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB1dGlsLmFzc2VydCh0aGlzLnguc2hhcGUubGVuZ3RoID09PSAzLCAnRXJyb3IgYWRkaW5nIGNvbnYyZCBvcDogaW5wdXQgbXVzdCBiZSBvZiByYW5rIDMsIGJ1dCBnb3Qgc2hhcGU6ICcgK1xuICAgICAgICAgICAgKHRoaXMueC5zaGFwZSArIFwiLlwiKSk7XG4gICAgICAgIHV0aWwuYXNzZXJ0KHRoaXMudy5zaGFwZS5sZW5ndGggPT09IDQsICdFcnJvciBhZGRpbmcgY29udjJkIG9wOiB3ZWlnaHRzIG11c3QgYmUgb2YgcmFuayA0LCBidXQgZ290IHNoYXBlOiAnICtcbiAgICAgICAgICAgICh0aGlzLncuc2hhcGUgKyBcIi5cIikpO1xuICAgICAgICB1dGlsLmFzc2VydCh0aGlzLmIuc2hhcGUubGVuZ3RoID09PSAxLCAnRXJyb3IgYWRkaW5nIGNvbnYyZCBvcDogYmlhc2VzIG11c3QgYmUgb2YgcmFuayAxLCBidXQgZ290IHNoYXBlOiAnICtcbiAgICAgICAgICAgICh0aGlzLmIuc2hhcGUgKyBcIi5cIikpO1xuICAgICAgICB1dGlsLmFzc2VydCh0aGlzLnguc2hhcGVbMl0gPT09IHRoaXMudy5zaGFwZVsyXSwgXCJFcnJvciBhZGRpbmcgY29udjJkIG9wOiBkZXB0aCBvZiBpbnB1dCAoXCIgKyB0aGlzLnguc2hhcGVbMl0gKyBcIikgXCIgK1xuICAgICAgICAgICAgKFwibXVzdCBtYXRjaCBpbnB1dCBkZXB0aCBmb3Igd2VpZ2h0cyAoXCIgKyB0aGlzLncuc2hhcGVbMl0gKyBcIikuXCIpKTtcbiAgICB9O1xuICAgIENvbnZvbHV0aW9uMkROb2RlLlggPSAneCc7XG4gICAgQ29udm9sdXRpb24yRE5vZGUuVyA9ICd3JztcbiAgICBDb252b2x1dGlvbjJETm9kZS5CID0gJ2InO1xuICAgIHJldHVybiBDb252b2x1dGlvbjJETm9kZTtcbn0oTm9kZSkpO1xuZXhwb3J0cy5Db252b2x1dGlvbjJETm9kZSA9IENvbnZvbHV0aW9uMkROb2RlO1xudmFyIE1heFBvb2xOb2RlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWF4UG9vbE5vZGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWF4UG9vbE5vZGUoZ3JhcGgsIHgsIGZpZWxkU2l6ZSwgc3RyaWRlLCB6ZXJvUGFkKSB7XG4gICAgICAgIGlmIChzdHJpZGUgPT09IHZvaWQgMCkgeyBzdHJpZGUgPSAxOyB9XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGdyYXBoLCAnTWF4IHBvb2wnLCB7IHg6IHggfSwgbmV3IFRlbnNvcihjb252X3V0aWwuY29tcHV0ZU91dHB1dFNoYXBlM0QoeC5zaGFwZSwgZmllbGRTaXplLCB4LnNoYXBlWzJdLCBzdHJpZGUsIHplcm9QYWQpKSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMueCA9IHg7XG4gICAgICAgIF90aGlzLmZpZWxkU2l6ZSA9IGZpZWxkU2l6ZTtcbiAgICAgICAgX3RoaXMuc3RyaWRlID0gc3RyaWRlO1xuICAgICAgICBfdGhpcy56ZXJvUGFkID0gemVyb1BhZDtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBNYXhQb29sTm9kZS5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0KHRoaXMueC5zaGFwZS5sZW5ndGggPT09IDMsICdFcnJvciBhZGRpbmcgbWF4UG9vbCBvcDogaW5wdXQgbXVzdCBiZSBvZiByYW5rIDMsIGJ1dCBnb3Qgc2hhcGU6ICcgK1xuICAgICAgICAgICAgKHRoaXMueC5zaGFwZSArIFwiLlwiKSk7XG4gICAgfTtcbiAgICBNYXhQb29sTm9kZS5YID0gJ3gnO1xuICAgIHJldHVybiBNYXhQb29sTm9kZTtcbn0oTm9kZSkpO1xuZXhwb3J0cy5NYXhQb29sTm9kZSA9IE1heFBvb2xOb2RlO1xudmFyIFJlTFVOb2RlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUmVMVU5vZGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUmVMVU5vZGUoZ3JhcGgsIHgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIGdyYXBoLCAnUmVMVScsIHsgeDogeCB9LCBuZXcgVGVuc29yKHguc2hhcGUpKSB8fCB0aGlzO1xuICAgIH1cbiAgICBSZUxVTm9kZS5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgUmVMVU5vZGUuWCA9ICd4JztcbiAgICByZXR1cm4gUmVMVU5vZGU7XG59KE5vZGUpKTtcbmV4cG9ydHMuUmVMVU5vZGUgPSBSZUxVTm9kZTtcbnZhciBMZWFreVJlTFVOb2RlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTGVha3lSZUxVTm9kZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBMZWFreVJlTFVOb2RlKGdyYXBoLCB4LCBhbHBoYSkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBncmFwaCwgJ0xlYWt5UmVMVScsIHsgeDogeCB9LCBuZXcgVGVuc29yKHguc2hhcGUpKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5hbHBoYSA9IGFscGhhO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIExlYWt5UmVMVU5vZGUucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgIExlYWt5UmVMVU5vZGUuWCA9ICd4JztcbiAgICByZXR1cm4gTGVha3lSZUxVTm9kZTtcbn0oTm9kZSkpO1xuZXhwb3J0cy5MZWFreVJlTFVOb2RlID0gTGVha3lSZUxVTm9kZTtcbnZhciBFeHBOb2RlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRXhwTm9kZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBFeHBOb2RlKGdyYXBoLCB4KSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBncmFwaCwgJ0V4cCcsIHsgeDogeCB9LCBuZXcgVGVuc29yKHguc2hhcGUpKSB8fCB0aGlzO1xuICAgIH1cbiAgICBFeHBOb2RlLnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICBFeHBOb2RlLlggPSAneCc7XG4gICAgcmV0dXJuIEV4cE5vZGU7XG59KE5vZGUpKTtcbmV4cG9ydHMuRXhwTm9kZSA9IEV4cE5vZGU7XG52YXIgTG9nTm9kZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKExvZ05vZGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTG9nTm9kZShncmFwaCwgeCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgZ3JhcGgsICdMb2cnLCB7IHg6IHggfSwgbmV3IFRlbnNvcih4LnNoYXBlKSkgfHwgdGhpcztcbiAgICB9XG4gICAgTG9nTm9kZS5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgTG9nTm9kZS5YID0gJ3gnO1xuICAgIHJldHVybiBMb2dOb2RlO1xufShOb2RlKSk7XG5leHBvcnRzLkxvZ05vZGUgPSBMb2dOb2RlO1xudmFyIFRhbkhOb2RlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVGFuSE5vZGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVGFuSE5vZGUoZ3JhcGgsIHgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIGdyYXBoLCAnVGFuSCcsIHsgeDogeCB9LCBuZXcgVGVuc29yKHguc2hhcGUpKSB8fCB0aGlzO1xuICAgIH1cbiAgICBUYW5ITm9kZS5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgVGFuSE5vZGUuWCA9ICd4JztcbiAgICByZXR1cm4gVGFuSE5vZGU7XG59KE5vZGUpKTtcbmV4cG9ydHMuVGFuSE5vZGUgPSBUYW5ITm9kZTtcbnZhciBTaWdtb2lkTm9kZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFNpZ21vaWROb2RlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFNpZ21vaWROb2RlKGdyYXBoLCB4KSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBncmFwaCwgJ1NpZ21vaWQnLCB7IHg6IHggfSwgbmV3IFRlbnNvcih4LnNoYXBlKSkgfHwgdGhpcztcbiAgICB9XG4gICAgU2lnbW9pZE5vZGUucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgIFNpZ21vaWROb2RlLlggPSAneCc7XG4gICAgcmV0dXJuIFNpZ21vaWROb2RlO1xufShOb2RlKSk7XG5leHBvcnRzLlNpZ21vaWROb2RlID0gU2lnbW9pZE5vZGU7XG52YXIgU3F1YXJlTm9kZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFNxdWFyZU5vZGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU3F1YXJlTm9kZShncmFwaCwgeCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgZ3JhcGgsICdTcXVhcmUnLCB7IHg6IHggfSwgbmV3IFRlbnNvcih4LnNoYXBlKSkgfHwgdGhpcztcbiAgICB9XG4gICAgU3F1YXJlTm9kZS5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgU3F1YXJlTm9kZS5YID0gJ3gnO1xuICAgIHJldHVybiBTcXVhcmVOb2RlO1xufShOb2RlKSk7XG5leHBvcnRzLlNxdWFyZU5vZGUgPSBTcXVhcmVOb2RlO1xudmFyIFNvZnRtYXhDcm9zc0VudHJvcHlDb3N0Tm9kZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFNvZnRtYXhDcm9zc0VudHJvcHlDb3N0Tm9kZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTb2Z0bWF4Q3Jvc3NFbnRyb3B5Q29zdE5vZGUoZ3JhcGgsIHgsIHRhcmdldCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBncmFwaCwgJ1NvZnRtYXhDcm9zc0VudHJvcHlDb3N0JywgeyB4OiB4LCB0YXJnZXQ6IHRhcmdldCB9LCBuZXcgVGVuc29yKFtdKSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMueCA9IHg7XG4gICAgICAgIF90aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBTb2Z0bWF4Q3Jvc3NFbnRyb3B5Q29zdE5vZGUucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB1dGlsLmFzc2VydCh1dGlsLmFycmF5c0VxdWFsKHRoaXMueC5zaGFwZSwgdGhpcy50YXJnZXQuc2hhcGUpLCBcIkVycm9yIGFkZGluZyBzb2Z0bWF4Q3Jvc3NFbnRyb3B5Q29zdCBvcDogeCBzaGFwZSAoXCIgKyB0aGlzLnguc2hhcGUgKyBcIikgXCIgK1xuICAgICAgICAgICAgKFwibXVzdCBtYXRjaCB0YXJnZXQgc2hhcGUgKFwiICsgdGhpcy50YXJnZXQuc2hhcGUgKyBcIikuXCIpKTtcbiAgICB9O1xuICAgIFNvZnRtYXhDcm9zc0VudHJvcHlDb3N0Tm9kZS5YID0gJ3gnO1xuICAgIFNvZnRtYXhDcm9zc0VudHJvcHlDb3N0Tm9kZS5UQVJHRVQgPSAndGFyZ2V0JztcbiAgICByZXR1cm4gU29mdG1heENyb3NzRW50cm9weUNvc3ROb2RlO1xufShOb2RlKSk7XG5leHBvcnRzLlNvZnRtYXhDcm9zc0VudHJvcHlDb3N0Tm9kZSA9IFNvZnRtYXhDcm9zc0VudHJvcHlDb3N0Tm9kZTtcbnZhciBTb2Z0bWF4Tm9kZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFNvZnRtYXhOb2RlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFNvZnRtYXhOb2RlKGdyYXBoLCB4KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGdyYXBoLCAnU29mdG1heCcsIHsgeDogeCB9LCBuZXcgVGVuc29yKHguc2hhcGUpKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy54ID0geDtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBTb2Z0bWF4Tm9kZS5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0KHRoaXMueC5zaGFwZS5sZW5ndGggPT09IDEsICdUaGUgaW5wdXQgdG8gYSBzb2Z0bWF4IG11c3QgYmUgYSAxLUQgdGVuc29yJyk7XG4gICAgICAgIHV0aWwuYXNzZXJ0KHRoaXMueC5zaGFwZVswXSA+PSAyLCAnVGhlIGlucHV0IHRvIGEgc29mdG1heCBtdXN0IGhhdmUgYXQgbGVhc3QgMiB2YWx1ZXMnKTtcbiAgICB9O1xuICAgIFNvZnRtYXhOb2RlLlggPSAneCc7XG4gICAgcmV0dXJuIFNvZnRtYXhOb2RlO1xufShOb2RlKSk7XG5leHBvcnRzLlNvZnRtYXhOb2RlID0gU29mdG1heE5vZGU7XG52YXIgTWVhblNxdWFyZWRDb3N0Tm9kZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1lYW5TcXVhcmVkQ29zdE5vZGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWVhblNxdWFyZWRDb3N0Tm9kZShncmFwaCwgbGFiZWwsIHByZWRpY3Rpb24pIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZ3JhcGgsICdNZWFuIFNxdWFyZWQgQ29zdCcsIHsgbGFiZWw6IGxhYmVsLCBwcmVkaWN0aW9uOiBwcmVkaWN0aW9uIH0sIG5ldyBUZW5zb3IoW10pKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5sYWJlbCA9IGxhYmVsO1xuICAgICAgICBfdGhpcy5wcmVkaWN0aW9uID0gcHJlZGljdGlvbjtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBNZWFuU3F1YXJlZENvc3ROb2RlLnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdXRpbC5hc3NlcnQodXRpbC5hcnJheXNFcXVhbCh0aGlzLmxhYmVsLnNoYXBlLCB0aGlzLnByZWRpY3Rpb24uc2hhcGUpLCBcIkVycm9yIGFkZGluZyBtZWFuU3F1YXJlZENvc3Qgb3A6IGxhYmVsIHNoYXBlIChcIiArIHRoaXMubGFiZWwuc2hhcGUgKyBcIikgXCIgK1xuICAgICAgICAgICAgKFwibXVzdCBtYXRjaCBwcmVkaWN0aW9uIHNoYXBlIChcIiArIHRoaXMucHJlZGljdGlvbi5zaGFwZSArIFwiKS5cIikpO1xuICAgIH07XG4gICAgTWVhblNxdWFyZWRDb3N0Tm9kZS5MQUJFTCA9ICdsYWJlbCc7XG4gICAgTWVhblNxdWFyZWRDb3N0Tm9kZS5QUkVESUNUSU9OID0gJ3ByZWRpY3Rpb24nO1xuICAgIHJldHVybiBNZWFuU3F1YXJlZENvc3ROb2RlO1xufShOb2RlKSk7XG5leHBvcnRzLk1lYW5TcXVhcmVkQ29zdE5vZGUgPSBNZWFuU3F1YXJlZENvc3ROb2RlO1xudmFyIEFyZ01heE5vZGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhBcmdNYXhOb2RlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEFyZ01heE5vZGUoZ3JhcGgsIHgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZ3JhcGgsICdBcmdNYXgnLCB7IHg6IHggfSwgbmV3IFRlbnNvcihbMV0pKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy54ID0geDtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBBcmdNYXhOb2RlLnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdXRpbC5hc3NlcnQodXRpbC5zaXplRnJvbVNoYXBlKHRoaXMueC5zaGFwZSkgPiAwLCAnRXJyb3IgYWRkaW5nIGFyZ21heCBvcDogaW5wdXQgdGVuc29yIG11c3QgaGF2ZSBhdCBsZWFzdCBvbmUgZW50cnkuJyk7XG4gICAgfTtcbiAgICBBcmdNYXhOb2RlLlggPSAneCc7XG4gICAgcmV0dXJuIEFyZ01heE5vZGU7XG59KE5vZGUpKTtcbmV4cG9ydHMuQXJnTWF4Tm9kZSA9IEFyZ01heE5vZGU7XG52YXIgQXJnTWF4RXF1YWxzTm9kZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFyZ01heEVxdWFsc05vZGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQXJnTWF4RXF1YWxzTm9kZShncmFwaCwgeDEsIHgyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGdyYXBoLCAnQXJnTWF4RXF1YWxzJywgeyB4MTogeDEsIHgyOiB4MiB9LCBuZXcgVGVuc29yKFsxXSkpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLngxID0geDE7XG4gICAgICAgIF90aGlzLngyID0geDI7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgQXJnTWF4RXF1YWxzTm9kZS5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0KHV0aWwuYXJyYXlzRXF1YWwodGhpcy54MS5zaGFwZSwgdGhpcy54Mi5zaGFwZSksIFwiRXJyb3IgYWRkaW5nIEFyZ01heEVxdWFscyBvcDogeDEgc2hhcGUgKFwiICsgdGhpcy54MS5zaGFwZSArIFwiKSBcIiArXG4gICAgICAgICAgICAoXCJtdXN0IG1hdGNoIHgyIHNoYXBlIChcIiArIHRoaXMueDIuc2hhcGUgKyBcIikuXCIpKTtcbiAgICB9O1xuICAgIEFyZ01heEVxdWFsc05vZGUuWDEgPSAneDEnO1xuICAgIEFyZ01heEVxdWFsc05vZGUuWDIgPSAneDInO1xuICAgIHJldHVybiBBcmdNYXhFcXVhbHNOb2RlO1xufShOb2RlKSk7XG5leHBvcnRzLkFyZ01heEVxdWFsc05vZGUgPSBBcmdNYXhFcXVhbHNOb2RlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z3JhcGguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZ3JhcGhfMSA9IHJlcXVpcmUoXCIuL2dyYXBoXCIpO1xudmFyIHByaW9yaXR5X3F1ZXVlID0gcmVxdWlyZShcIi4vcHJpb3JpdHlfcXVldWVcIik7XG52YXIgcHJpb3JpdHlfcXVldWVfMSA9IHJlcXVpcmUoXCIuL3ByaW9yaXR5X3F1ZXVlXCIpO1xuZnVuY3Rpb24gZ2V0VW5vcmRlcmVkRXZhbHVhdGlvblNldChub2RlcywgdGVybWluYXRpbmdOb2Rlcykge1xuICAgIHZhciB0ZXJtaW5hdGluZ05vZGVNYXAgPSB7fTtcbiAgICB2YXIgc2VlbiA9IHt9O1xuICAgIHZhciBzZXQgPSBbXTtcbiAgICB2YXIgdmlzaXQgPSBub2Rlcy5zbGljZSgpO1xuICAgIHRlcm1pbmF0aW5nTm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gdGVybWluYXRpbmdOb2RlTWFwW25vZGUuaWRdID0gbm9kZTsgfSk7XG4gICAgdmFyIF9sb29wXzEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjdXIgPSB2aXNpdC5wb3AoKTtcbiAgICAgICAgaWYgKHNlZW5bY3VyLmlkXSA9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodGVybWluYXRpbmdOb2RlTWFwW2N1ci5pZF0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKGN1ci5pbnB1dHMpXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGlucHV0TmFtZSkgeyByZXR1cm4gY3VyLmlucHV0c1tpbnB1dE5hbWVdOyB9KVxuICAgICAgICAgICAgICAgICAgICAuZm9yRWFjaChmdW5jdGlvbiAoaW5wdXQpIHsgcmV0dXJuIHZpc2l0LnB1c2goaW5wdXQubm9kZSk7IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0LnB1c2goY3VyKTtcbiAgICAgICAgICAgIHNlZW5bY3VyLmlkXSA9IGN1cjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgd2hpbGUgKHZpc2l0Lmxlbmd0aCAhPT0gMCkge1xuICAgICAgICBfbG9vcF8xKCk7XG4gICAgfVxuICAgIHJldHVybiBzZXQ7XG59XG5leHBvcnRzLmdldFVub3JkZXJlZEV2YWx1YXRpb25TZXQgPSBnZXRVbm9yZGVyZWRFdmFsdWF0aW9uU2V0O1xuZnVuY3Rpb24gZ2V0T3JkZXJlZEV2YWx1YXRpb25TZXQodW5vcmRlcmVkRXZhbHVhdGlvblNldCkge1xuICAgIHZhciBzZXQgPSBbXTtcbiAgICB2YXIgbm9kZUluZGljZXMgPSB7fTtcbiAgICB2YXIgcGVuZGluZ0RlcGVuZGVuY2llcyA9IHt9O1xuICAgIHZhciBub2RlUXVldWUgPSBuZXcgcHJpb3JpdHlfcXVldWVfMS5Qcmlvcml0eVF1ZXVlKGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBwcmlvcml0eV9xdWV1ZS5kZWZhdWx0Q29tcGFyZShwZW5kaW5nRGVwZW5kZW5jaWVzW2EuaWRdLCBwZW5kaW5nRGVwZW5kZW5jaWVzW2IuaWRdKTsgfSwgZnVuY3Rpb24gKG5vZGUsIG5ld0luZGV4KSB7IHJldHVybiBub2RlSW5kaWNlc1tub2RlLmlkXSA9IG5ld0luZGV4OyB9KTtcbiAgICB1bm9yZGVyZWRFdmFsdWF0aW9uU2V0LmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIHBlbmRpbmdEZXBlbmRlbmNpZXNbbm9kZS5pZF0gPSAwOyB9KTtcbiAgICB1bm9yZGVyZWRFdmFsdWF0aW9uU2V0LmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIE9iamVjdC5rZXlzKG5vZGUuaW5wdXRzKVxuICAgICAgICAubWFwKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIG5vZGUuaW5wdXRzW2tleV07IH0pXG4gICAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICBpZiAodW5vcmRlcmVkRXZhbHVhdGlvblNldC5pbmRleE9mKGlucHV0Lm5vZGUpICE9PSAtMSkge1xuICAgICAgICAgICAgcGVuZGluZ0RlcGVuZGVuY2llc1tpbnB1dC5ub2RlLmlkXSsrO1xuICAgICAgICB9XG4gICAgfSk7IH0pO1xuICAgIHVub3JkZXJlZEV2YWx1YXRpb25TZXQuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gbm9kZVF1ZXVlLmVucXVldWUobm9kZSk7IH0pO1xuICAgIHdoaWxlICghbm9kZVF1ZXVlLmVtcHR5KCkpIHtcbiAgICAgICAgc2V0LnVuc2hpZnQobm9kZVF1ZXVlLmRlcXVldWUoKSk7XG4gICAgICAgIE9iamVjdC5rZXlzKHNldFswXS5pbnB1dHMpLm1hcChmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBzZXRbMF0uaW5wdXRzW2tleV07IH0pLmZvckVhY2goZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICAgICAgICBpZiAodW5vcmRlcmVkRXZhbHVhdGlvblNldC5pbmRleE9mKGlucHV0Lm5vZGUpID09PSAtMSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBlbmRpbmdEZXBlbmRlbmNpZXNbaW5wdXQubm9kZS5pZF0tLTtcbiAgICAgICAgICAgIG5vZGVRdWV1ZS51cGRhdGUoaW5wdXQubm9kZSwgbm9kZUluZGljZXNbaW5wdXQubm9kZS5pZF0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHNldDtcbn1cbmV4cG9ydHMuZ2V0T3JkZXJlZEV2YWx1YXRpb25TZXQgPSBnZXRPcmRlcmVkRXZhbHVhdGlvblNldDtcbmZ1bmN0aW9uIGlzSW5wdXROb2RlKG5vZGUpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMobm9kZS5pbnB1dHMpLmxlbmd0aCA9PT0gMDtcbn1cbmV4cG9ydHMuaXNJbnB1dE5vZGUgPSBpc0lucHV0Tm9kZTtcbmZ1bmN0aW9uIHNob3VsZEJhY2tQcm9wKHQpIHtcbiAgICByZXR1cm4gISh0Lm5vZGUgaW5zdGFuY2VvZiBncmFwaF8xLkNvbnN0YW50Tm9kZSk7XG59XG5leHBvcnRzLnNob3VsZEJhY2tQcm9wID0gc2hvdWxkQmFja1Byb3A7XG5mdW5jdGlvbiBpc1Bhc3N0aHJvdWdoTm9kZShub2RlLCBtYXApIHtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG5vZGUuaW5wdXRzKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGlucHV0ID0gbm9kZS5pbnB1dHNba2V5c1tpXV07XG4gICAgICAgIGlmIChtYXAuZ2V0KGlucHV0LCB0cnVlKSA9PT0gbWFwLmdldChub2RlLm91dHB1dCwgdHJ1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmV4cG9ydHMuaXNQYXNzdGhyb3VnaE5vZGUgPSBpc1Bhc3N0aHJvdWdoTm9kZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdyYXBoX3V0aWwuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZ3JhcGhfMSA9IHJlcXVpcmUoXCIuL2dyYXBoXCIpO1xudmFyIGdyYXBoX3V0aWwgPSByZXF1aXJlKFwiLi9ncmFwaF91dGlsXCIpO1xudmFyIGFkZF8xID0gcmVxdWlyZShcIi4vb3BzL2FkZFwiKTtcbnZhciBhcmdtYXhfMSA9IHJlcXVpcmUoXCIuL29wcy9hcmdtYXhcIik7XG52YXIgYXJnbWF4ZXF1YWxzXzEgPSByZXF1aXJlKFwiLi9vcHMvYXJnbWF4ZXF1YWxzXCIpO1xudmFyIGNvbmNhdDNkXzEgPSByZXF1aXJlKFwiLi9vcHMvY29uY2F0M2RcIik7XG52YXIgY29udm9sdXRpb25fMSA9IHJlcXVpcmUoXCIuL29wcy9jb252b2x1dGlvblwiKTtcbnZhciBkaXZpZGVfMSA9IHJlcXVpcmUoXCIuL29wcy9kaXZpZGVcIik7XG52YXIgZWxlbWVudF93aXNlX2FjdGl2YXRpb25fMSA9IHJlcXVpcmUoXCIuL29wcy9lbGVtZW50X3dpc2VfYWN0aXZhdGlvblwiKTtcbnZhciBlbGVtZW50X3dpc2VfY29zdF8xID0gcmVxdWlyZShcIi4vb3BzL2VsZW1lbnRfd2lzZV9jb3N0XCIpO1xudmFyIGV4cF8xID0gcmVxdWlyZShcIi4vb3BzL2V4cFwiKTtcbnZhciBsaW5lYXJfY29tYmluYXRpb25fMSA9IHJlcXVpcmUoXCIuL29wcy9saW5lYXJfY29tYmluYXRpb25cIik7XG52YXIgbG9nXzEgPSByZXF1aXJlKFwiLi9vcHMvbG9nXCIpO1xudmFyIG1hdG11bF8xID0gcmVxdWlyZShcIi4vb3BzL21hdG11bFwiKTtcbnZhciBtYXhfcG9vbF8xID0gcmVxdWlyZShcIi4vb3BzL21heF9wb29sXCIpO1xudmFyIG11bHRpcGx5XzEgPSByZXF1aXJlKFwiLi9vcHMvbXVsdGlwbHlcIik7XG52YXIgcmVkdWNlX3N1bV8xID0gcmVxdWlyZShcIi4vb3BzL3JlZHVjZV9zdW1cIik7XG52YXIgcmVzaGFwZV8xID0gcmVxdWlyZShcIi4vb3BzL3Jlc2hhcGVcIik7XG52YXIgc29mdG1heF8xID0gcmVxdWlyZShcIi4vb3BzL3NvZnRtYXhcIik7XG52YXIgc3VidHJhY3RfMSA9IHJlcXVpcmUoXCIuL29wcy9zdWJ0cmFjdFwiKTtcbmZ1bmN0aW9uIGVtaXRGcm9tR3JhcGhOb2Rlcyhub2Rlcykge1xuICAgIHZhciBvcHMgPSBbXTtcbiAgICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShvcHMsIGVtaXRPcEZyb21Ob2RlKG5vZGUpKTsgfSk7XG4gICAgcmV0dXJuIG9wcztcbn1cbmV4cG9ydHMuZW1pdEZyb21HcmFwaE5vZGVzID0gZW1pdEZyb21HcmFwaE5vZGVzO1xuZnVuY3Rpb24gZW1pdE9wRnJvbU5vZGUobm9kZSkge1xuICAgIGlmIChub2RlIGluc3RhbmNlb2YgZ3JhcGhfMS5SZXNoYXBlTm9kZSkge1xuICAgICAgICByZXR1cm4gW25ldyByZXNoYXBlXzEuUmVzaGFwZShub2RlLmlucHV0c1tncmFwaF8xLlJlc2hhcGVOb2RlLlhdLCBub2RlLm91dHB1dCldO1xuICAgIH1cbiAgICBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgZ3JhcGhfMS5NYXRNdWxOb2RlKSB7XG4gICAgICAgIHZhciB4MSA9IG5vZGUuaW5wdXRzW2dyYXBoXzEuTWF0TXVsTm9kZS5YMV07XG4gICAgICAgIHZhciB4MiA9IG5vZGUuaW5wdXRzW2dyYXBoXzEuTWF0TXVsTm9kZS5YMl07XG4gICAgICAgIHJldHVybiBbbmV3IG1hdG11bF8xLk1hdE11bCh4MSwgeDIsIG5vZGUub3V0cHV0KV07XG4gICAgfVxuICAgIGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBncmFwaF8xLkNvbnZvbHV0aW9uMkROb2RlKSB7XG4gICAgICAgIHZhciB3ID0gbm9kZS5pbnB1dHNbZ3JhcGhfMS5Db252b2x1dGlvbjJETm9kZS5XXTtcbiAgICAgICAgdmFyIHggPSBub2RlLmlucHV0c1tncmFwaF8xLkNvbnZvbHV0aW9uMkROb2RlLlhdO1xuICAgICAgICB2YXIgYiA9IG5vZGUuaW5wdXRzW2dyYXBoXzEuQ29udm9sdXRpb24yRE5vZGUuQl07XG4gICAgICAgIHJldHVybiBbbmV3IGNvbnZvbHV0aW9uXzEuQ29udm9sdXRpb24yRCh3LCB4LCBiLCBub2RlLm91dHB1dCwgbm9kZS5maWVsZFNpemUsIG5vZGUub3V0cHV0RGVwdGgsIG5vZGUuc3RyaWRlLCBub2RlLnplcm9QYWQpXTtcbiAgICB9XG4gICAgZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIGdyYXBoXzEuTWF4UG9vbE5vZGUpIHtcbiAgICAgICAgdmFyIHggPSBub2RlLmlucHV0c1tncmFwaF8xLk1heFBvb2xOb2RlLlhdO1xuICAgICAgICByZXR1cm4gW25ldyBtYXhfcG9vbF8xLk1heFBvb2woeCwgbm9kZS5vdXRwdXQsIG5vZGUuZmllbGRTaXplLCBub2RlLnN0cmlkZSwgbm9kZS56ZXJvUGFkKV07XG4gICAgfVxuICAgIGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBncmFwaF8xLkV4cE5vZGUpIHtcbiAgICAgICAgcmV0dXJuIFtuZXcgZXhwXzEuRXhwKG5vZGUuaW5wdXRzW2dyYXBoXzEuRXhwTm9kZS5YXSwgbm9kZS5vdXRwdXQpXTtcbiAgICB9XG4gICAgZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIGdyYXBoXzEuTG9nTm9kZSkge1xuICAgICAgICByZXR1cm4gW25ldyBsb2dfMS5Mb2cobm9kZS5pbnB1dHNbZ3JhcGhfMS5Mb2dOb2RlLlhdLCBub2RlLm91dHB1dCldO1xuICAgIH1cbiAgICBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgZ3JhcGhfMS5SZUxVTm9kZSkge1xuICAgICAgICByZXR1cm4gW25ldyBlbGVtZW50X3dpc2VfYWN0aXZhdGlvbl8xLlJlTFUobm9kZS5pbnB1dHNbZ3JhcGhfMS5SZUxVTm9kZS5YXSwgbm9kZS5vdXRwdXQpXTtcbiAgICB9XG4gICAgZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIGdyYXBoXzEuTGVha3lSZUxVTm9kZSkge1xuICAgICAgICByZXR1cm4gW25ldyBlbGVtZW50X3dpc2VfYWN0aXZhdGlvbl8xLkxlYWt5UmVMVShub2RlLmlucHV0c1tncmFwaF8xLkxlYWt5UmVMVU5vZGUuWF0sIG5vZGUub3V0cHV0LCBub2RlLmFscGhhKV07XG4gICAgfVxuICAgIGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBncmFwaF8xLlRhbkhOb2RlKSB7XG4gICAgICAgIHJldHVybiBbbmV3IGVsZW1lbnRfd2lzZV9hY3RpdmF0aW9uXzEuVGFuSChub2RlLmlucHV0c1tncmFwaF8xLlRhbkhOb2RlLlhdLCBub2RlLm91dHB1dCldO1xuICAgIH1cbiAgICBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgZ3JhcGhfMS5TaWdtb2lkTm9kZSkge1xuICAgICAgICByZXR1cm4gW25ldyBlbGVtZW50X3dpc2VfYWN0aXZhdGlvbl8xLlNpZ21vaWQobm9kZS5pbnB1dHNbZ3JhcGhfMS5TaWdtb2lkTm9kZS5YXSwgbm9kZS5vdXRwdXQpXTtcbiAgICB9XG4gICAgZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIGdyYXBoXzEuU29mdG1heENyb3NzRW50cm9weUNvc3ROb2RlKSB7XG4gICAgICAgIHZhciB4ID0gbm9kZS5pbnB1dHNbZ3JhcGhfMS5Tb2Z0bWF4Q3Jvc3NFbnRyb3B5Q29zdE5vZGUuWF07XG4gICAgICAgIHZhciB0YXJnZXQgPSBub2RlLmlucHV0c1tncmFwaF8xLlNvZnRtYXhDcm9zc0VudHJvcHlDb3N0Tm9kZS5UQVJHRVRdO1xuICAgICAgICByZXR1cm4gW25ldyBzb2Z0bWF4XzEuU29mdG1heENyb3NzRW50cm9weUNvc3QoeCwgdGFyZ2V0LCBub2RlLm91dHB1dCldO1xuICAgIH1cbiAgICBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgZ3JhcGhfMS5Tb2Z0bWF4Tm9kZSkge1xuICAgICAgICByZXR1cm4gW25ldyBzb2Z0bWF4XzEuU29mdG1heChub2RlLmlucHV0c1tncmFwaF8xLlNvZnRtYXhOb2RlLlhdLCBub2RlLm91dHB1dCldO1xuICAgIH1cbiAgICBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgZ3JhcGhfMS5NZWFuU3F1YXJlZENvc3ROb2RlKSB7XG4gICAgICAgIHZhciBsYWJlbCA9IG5vZGUuaW5wdXRzW2dyYXBoXzEuTWVhblNxdWFyZWRDb3N0Tm9kZS5MQUJFTF07XG4gICAgICAgIHZhciBwcmVkaWN0aW9uID0gbm9kZS5pbnB1dHNbZ3JhcGhfMS5NZWFuU3F1YXJlZENvc3ROb2RlLlBSRURJQ1RJT05dO1xuICAgICAgICByZXR1cm4gW25ldyBlbGVtZW50X3dpc2VfY29zdF8xLk1lYW5TcXVhcmVkQ29zdChsYWJlbCwgcHJlZGljdGlvbiwgbm9kZS5vdXRwdXQpXTtcbiAgICB9XG4gICAgZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIGdyYXBoXzEuQXJnTWF4RXF1YWxzTm9kZSkge1xuICAgICAgICByZXR1cm4gW25ldyBhcmdtYXhlcXVhbHNfMS5BcmdNYXhFcXVhbHMobm9kZS5pbnB1dHNbZ3JhcGhfMS5BcmdNYXhFcXVhbHNOb2RlLlgxXSwgbm9kZS5pbnB1dHNbZ3JhcGhfMS5BcmdNYXhFcXVhbHNOb2RlLlgyXSwgbm9kZS5vdXRwdXQpXTtcbiAgICB9XG4gICAgZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIGdyYXBoXzEuQXJnTWF4Tm9kZSkge1xuICAgICAgICByZXR1cm4gW25ldyBhcmdtYXhfMS5BcmdNYXgobm9kZS54LCBub2RlLm91dHB1dCldO1xuICAgIH1cbiAgICBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgZ3JhcGhfMS5GdXNlZExpbmVhckNvbWJpbmF0aW9uTm9kZSkge1xuICAgICAgICByZXR1cm4gW25ldyBsaW5lYXJfY29tYmluYXRpb25fMS5MaW5lYXJDb21iaW5hdGlvbihub2RlLmlucHV0c1tncmFwaF8xLkZ1c2VkTGluZWFyQ29tYmluYXRpb25Ob2RlLlQxXSwgbm9kZS5pbnB1dHNbZ3JhcGhfMS5GdXNlZExpbmVhckNvbWJpbmF0aW9uTm9kZS5UMl0sIG5vZGUuaW5wdXRzW2dyYXBoXzEuRnVzZWRMaW5lYXJDb21iaW5hdGlvbk5vZGUuQzFdLCBub2RlLmlucHV0c1tncmFwaF8xLkZ1c2VkTGluZWFyQ29tYmluYXRpb25Ob2RlLkMyXSwgbm9kZS5vdXRwdXQpXTtcbiAgICB9XG4gICAgZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIGdyYXBoXzEuQ29uY2F0M0ROb2RlKSB7XG4gICAgICAgIHJldHVybiBbbmV3IGNvbmNhdDNkXzEuQ29uY2F0M0Qobm9kZS5pbnB1dHNbZ3JhcGhfMS5Db25jYXQzRE5vZGUuWDFdLCBub2RlLmlucHV0c1tncmFwaF8xLkNvbmNhdDNETm9kZS5YMl0sIG5vZGUuYXhpcywgbm9kZS5vdXRwdXQpXTtcbiAgICB9XG4gICAgZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIGdyYXBoXzEuU3F1YXJlTm9kZSkge1xuICAgICAgICByZXR1cm4gW25ldyBlbGVtZW50X3dpc2VfYWN0aXZhdGlvbl8xLlNxdWFyZShub2RlLmlucHV0c1tncmFwaF8xLlNxdWFyZU5vZGUuWF0sIG5vZGUub3V0cHV0KV07XG4gICAgfVxuICAgIGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBncmFwaF8xLkFkZE5vZGUpIHtcbiAgICAgICAgcmV0dXJuIFtuZXcgYWRkXzEuQWRkKG5vZGUuaW5wdXRzW2dyYXBoXzEuQWRkTm9kZS5UMV0sIG5vZGUuaW5wdXRzW2dyYXBoXzEuQWRkTm9kZS5UMl0sIG5vZGUub3V0cHV0KV07XG4gICAgfVxuICAgIGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBncmFwaF8xLlN1YnRyYWN0Tm9kZSkge1xuICAgICAgICByZXR1cm4gW25ldyBzdWJ0cmFjdF8xLlN1YnRyYWN0KG5vZGUuaW5wdXRzW2dyYXBoXzEuU3VidHJhY3ROb2RlLlQxXSwgbm9kZS5pbnB1dHNbZ3JhcGhfMS5TdWJ0cmFjdE5vZGUuVDJdLCBub2RlLm91dHB1dCldO1xuICAgIH1cbiAgICBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgZ3JhcGhfMS5NdWx0aXBseU5vZGUpIHtcbiAgICAgICAgcmV0dXJuIFtuZXcgbXVsdGlwbHlfMS5NdWx0aXBseShub2RlLmlucHV0c1tncmFwaF8xLk11bHRpcGx5Tm9kZS5UMV0sIG5vZGUuaW5wdXRzW2dyYXBoXzEuTXVsdGlwbHlOb2RlLlQyXSwgbm9kZS5vdXRwdXQpXTtcbiAgICB9XG4gICAgZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIGdyYXBoXzEuRGl2aWRlTm9kZSkge1xuICAgICAgICByZXR1cm4gW25ldyBkaXZpZGVfMS5EaXZpZGUobm9kZS5pbnB1dHNbZ3JhcGhfMS5EaXZpZGVOb2RlLlQxXSwgbm9kZS5pbnB1dHNbZ3JhcGhfMS5EaXZpZGVOb2RlLlQyXSwgbm9kZS5vdXRwdXQpXTtcbiAgICB9XG4gICAgZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIGdyYXBoXzEuUmVkdWNlU3VtTm9kZSkge1xuICAgICAgICByZXR1cm4gW25ldyByZWR1Y2Vfc3VtXzEuUmVkdWNlU3VtKG5vZGUuaW5wdXRzW2dyYXBoXzEuUmVkdWNlU3VtTm9kZS5YXSwgbm9kZS5vdXRwdXQpXTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZ3JhcGhfdXRpbC5pc0lucHV0Tm9kZShub2RlKSkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBFcnJvcihcIlVuc3VwcG9ydGVkIG5vZGUgdHlwZTogXCIgKyBub2RlLmNvbnN0cnVjdG9yLm5hbWUpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9wZXJhdGlvbl9lbWl0dGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgbmRhcnJheV8xID0gcmVxdWlyZShcIi4uLy4uL21hdGgvbmRhcnJheVwiKTtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4uLy4uL3V0aWxcIik7XG52YXIgZ3JhcGhfdXRpbCA9IHJlcXVpcmUoXCIuLi9ncmFwaF91dGlsXCIpO1xudmFyIG9wXzEgPSByZXF1aXJlKFwiLi9vcFwiKTtcbnZhciBBZGQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhBZGQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQWRkKHgxVGVuc29yLCB4MlRlbnNvciwgeVRlbnNvcikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy54MVRlbnNvciA9IHgxVGVuc29yO1xuICAgICAgICBfdGhpcy54MlRlbnNvciA9IHgyVGVuc29yO1xuICAgICAgICBfdGhpcy55VGVuc29yID0geVRlbnNvcjtcbiAgICAgICAgdXRpbC5hc3NlcnQodXRpbC5zaXplRnJvbVNoYXBlKHgxVGVuc29yLnNoYXBlKSA9PT0gMSB8fFxuICAgICAgICAgICAgdXRpbC5zaXplRnJvbVNoYXBlKHgyVGVuc29yLnNoYXBlKSA9PT0gMSB8fFxuICAgICAgICAgICAgdXRpbC5hcnJheXNFcXVhbCh4MVRlbnNvci5zaGFwZSwgeDJUZW5zb3Iuc2hhcGUpLCAnT25lIG9mIHQxIG9yIHQyIG11c3QgYmUgYSBzY2FsYXIsIG9yIHQxIGFuZCB0MiBtdXN0IGhhdmUgJyArXG4gICAgICAgICAgICAndGhlIHNhbWUgc2hhcGUnKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBBZGQucHJvdG90eXBlLmZlZWRGb3J3YXJkID0gZnVuY3Rpb24gKG1hdGgsIGluZmVyZW5jZUFycmF5cykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgeDEgPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMueDFUZW5zb3IpO1xuICAgICAgICB2YXIgeDIgPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMueDJUZW5zb3IpO1xuICAgICAgICBtYXRoLnNjb3BlKGZ1bmN0aW9uIChrZWVwKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICAgICAgaWYgKHV0aWwuaXNTY2FsYXJTaGFwZSh4MS5zaGFwZSkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBtYXRoLnNjYWxhclBsdXNBcnJheSh4MSwgeDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodXRpbC5pc1NjYWxhclNoYXBlKHgyLnNoYXBlKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IG1hdGguc2NhbGFyUGx1c0FycmF5KHgyLCB4MSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBtYXRoLmFkZCh4MSwgeDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5mZXJlbmNlQXJyYXlzLnNldChfdGhpcy55VGVuc29yLCBrZWVwKHJlc3VsdCkpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEFkZC5wcm90b3R5cGUuYmFja1Byb3AgPSBmdW5jdGlvbiAobWF0aCwgaW5mZXJlbmNlQXJyYXlzLCBncmFkaWVudEFycmF5cykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgZHkgPSBncmFkaWVudEFycmF5cy5nZXQodGhpcy55VGVuc29yKTtcbiAgICAgICAgbWF0aC5zY29wZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoZ3JhcGhfdXRpbC5zaG91bGRCYWNrUHJvcChfdGhpcy54MVRlbnNvcikpIHtcbiAgICAgICAgICAgICAgICBpZiAodXRpbC5pc1NjYWxhclNoYXBlKF90aGlzLngxVGVuc29yLnNoYXBlKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3VtID0gbWF0aC5zdW0oZHkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuZHlTaXplU2NhbGFyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmR5U2l6ZVNjYWxhciA9IG5kYXJyYXlfMS5TY2FsYXIubmV3KGR5LnNpemUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGdyYWRpZW50QXJyYXlzLmFkZChfdGhpcy54MVRlbnNvciwgbWF0aC5kaXZpZGUoc3VtLCBfdGhpcy5keVNpemVTY2FsYXIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGdyYWRpZW50QXJyYXlzLmFkZChfdGhpcy54MVRlbnNvciwgbWF0aC5jbG9uZShkeSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChncmFwaF91dGlsLnNob3VsZEJhY2tQcm9wKF90aGlzLngyVGVuc29yKSkge1xuICAgICAgICAgICAgICAgIGlmICh1dGlsLmlzU2NhbGFyU2hhcGUoX3RoaXMueDJUZW5zb3Iuc2hhcGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdW0gPSBtYXRoLnN1bShkeSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5keVNpemVTY2FsYXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuZHlTaXplU2NhbGFyID0gbmRhcnJheV8xLlNjYWxhci5uZXcoZHkuc2l6ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZ3JhZGllbnRBcnJheXMuYWRkKF90aGlzLngyVGVuc29yLCBtYXRoLmRpdmlkZShzdW0sIF90aGlzLmR5U2l6ZVNjYWxhcikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZ3JhZGllbnRBcnJheXMuYWRkKF90aGlzLngyVGVuc29yLCBtYXRoLmNsb25lKGR5KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEFkZC5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuZHlTaXplU2NhbGFyICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuZHlTaXplU2NhbGFyLmRpc3Bvc2UoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEFkZDtcbn0ob3BfMS5PcGVyYXRpb24pKTtcbmV4cG9ydHMuQWRkID0gQWRkO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWRkLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgb3BfMSA9IHJlcXVpcmUoXCIuL29wXCIpO1xudmFyIEFyZ01heCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFyZ01heCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBcmdNYXgoeFRlbnNvciwgeVRlbnNvcikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy54VGVuc29yID0geFRlbnNvcjtcbiAgICAgICAgX3RoaXMueVRlbnNvciA9IHlUZW5zb3I7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgQXJnTWF4LnByb3RvdHlwZS5mZWVkRm9yd2FyZCA9IGZ1bmN0aW9uIChtYXRoLCBpbmZlcmVuY2VBcnJheXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHggPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMueFRlbnNvcik7XG4gICAgICAgIG1hdGguc2NvcGUoZnVuY3Rpb24gKGtlZXApIHtcbiAgICAgICAgICAgIGluZmVyZW5jZUFycmF5cy5zZXQoX3RoaXMueVRlbnNvciwga2VlcChtYXRoLmFyZ01heCh4KSkpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEFyZ01heC5wcm90b3R5cGUuYmFja1Byb3AgPSBmdW5jdGlvbiAobWF0aCwgaW5mZXJlbmNlQXJyYXlzLCBncmFkaWVudEFycmF5cykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FyZ01heCBiYWNrcHJvcCB1bmltcGxlbWVudGVkJyk7XG4gICAgfTtcbiAgICByZXR1cm4gQXJnTWF4O1xufShvcF8xLk9wZXJhdGlvbikpO1xuZXhwb3J0cy5BcmdNYXggPSBBcmdNYXg7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hcmdtYXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBvcF8xID0gcmVxdWlyZShcIi4vb3BcIik7XG52YXIgQXJnTWF4RXF1YWxzID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQXJnTWF4RXF1YWxzLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEFyZ01heEVxdWFscyh4MVRlbnNvciwgeDJUZW5zb3IsIHlUZW5zb3IpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMueDFUZW5zb3IgPSB4MVRlbnNvcjtcbiAgICAgICAgX3RoaXMueDJUZW5zb3IgPSB4MlRlbnNvcjtcbiAgICAgICAgX3RoaXMueVRlbnNvciA9IHlUZW5zb3I7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgQXJnTWF4RXF1YWxzLnByb3RvdHlwZS5mZWVkRm9yd2FyZCA9IGZ1bmN0aW9uIChtYXRoLCBpbmZlcmVuY2VBcnJheXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHgxID0gaW5mZXJlbmNlQXJyYXlzLmdldCh0aGlzLngxVGVuc29yKTtcbiAgICAgICAgdmFyIHgyID0gaW5mZXJlbmNlQXJyYXlzLmdldCh0aGlzLngyVGVuc29yKTtcbiAgICAgICAgbWF0aC5zY29wZShmdW5jdGlvbiAoa2VlcCkge1xuICAgICAgICAgICAgaW5mZXJlbmNlQXJyYXlzLnNldChfdGhpcy55VGVuc29yLCBrZWVwKG1hdGguYXJnTWF4RXF1YWxzKHgxLCB4MikpKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBBcmdNYXhFcXVhbHMucHJvdG90eXBlLmJhY2tQcm9wID0gZnVuY3Rpb24gKG1hdGgsIGluZmVyZW5jZUFycmF5cywgZ3JhZGllbnRBcnJheXMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBcmdNYXhFcXVhbHMgYmFja3Byb3AgdW5pbXBsZW1lbnRlZCcpO1xuICAgIH07XG4gICAgcmV0dXJuIEFyZ01heEVxdWFscztcbn0ob3BfMS5PcGVyYXRpb24pKTtcbmV4cG9ydHMuQXJnTWF4RXF1YWxzID0gQXJnTWF4RXF1YWxzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXJnbWF4ZXF1YWxzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgY29uY2F0X3V0aWwgPSByZXF1aXJlKFwiLi4vLi4vbWF0aC9jb25jYXRfdXRpbFwiKTtcbnZhciBvcF8xID0gcmVxdWlyZShcIi4vb3BcIik7XG52YXIgQ29uY2F0M0QgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDb25jYXQzRCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDb25jYXQzRCh4MVRlbnNvciwgeDJUZW5zb3IsIGF4aXMsIHlUZW5zb3IpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMueDFUZW5zb3IgPSB4MVRlbnNvcjtcbiAgICAgICAgX3RoaXMueDJUZW5zb3IgPSB4MlRlbnNvcjtcbiAgICAgICAgX3RoaXMuYXhpcyA9IGF4aXM7XG4gICAgICAgIF90aGlzLnlUZW5zb3IgPSB5VGVuc29yO1xuICAgICAgICBjb25jYXRfdXRpbC5hc3NlcnRQYXJhbXMoeDFUZW5zb3Iuc2hhcGUsIHgyVGVuc29yLnNoYXBlLCBheGlzKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBDb25jYXQzRC5wcm90b3R5cGUuZmVlZEZvcndhcmQgPSBmdW5jdGlvbiAobWF0aCwgaW5mZXJlbmNlQXJyYXlzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciB4MSA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy54MVRlbnNvcik7XG4gICAgICAgIHZhciB4MiA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy54MlRlbnNvcik7XG4gICAgICAgIG1hdGguc2NvcGUoZnVuY3Rpb24gKGtlZXApIHtcbiAgICAgICAgICAgIHZhciBjb25jYXRSZXN1bHQgPSBtYXRoLmNvbmNhdDNEKHgxLCB4MiwgX3RoaXMuYXhpcyk7XG4gICAgICAgICAgICBpbmZlcmVuY2VBcnJheXMuc2V0KF90aGlzLnlUZW5zb3IsIGtlZXAoY29uY2F0UmVzdWx0KSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQ29uY2F0M0QucHJvdG90eXBlLmJhY2tQcm9wID0gZnVuY3Rpb24gKG1hdGgsIGluZmVyZW5jZUFycmF5cywgZ3JhZGllbnRBcnJheXMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb25jYXQzRCBiYWNrcHJvcCBub3QgaW1wbGVtZW50ZWQuJyk7XG4gICAgfTtcbiAgICByZXR1cm4gQ29uY2F0M0Q7XG59KG9wXzEuT3BlcmF0aW9uKSk7XG5leHBvcnRzLkNvbmNhdDNEID0gQ29uY2F0M0Q7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25jYXQzZC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGNvbnZfdXRpbCA9IHJlcXVpcmUoXCIuLi8uLi9tYXRoL2NvbnZfdXRpbFwiKTtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4uLy4uL3V0aWxcIik7XG52YXIgb3BfMSA9IHJlcXVpcmUoXCIuL29wXCIpO1xudmFyIENvbnZvbHV0aW9uMkQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDb252b2x1dGlvbjJELCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENvbnZvbHV0aW9uMkQod1RlbnNvciwgeFRlbnNvciwgYlRlbnNvciwgeVRlbnNvciwgZmllbGRTaXplLCBvdXRwdXREZXB0aCwgc3RyaWRlLCB6ZXJvUGFkKSB7XG4gICAgICAgIGlmIChzdHJpZGUgPT09IHZvaWQgMCkgeyBzdHJpZGUgPSAxOyB9XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLndUZW5zb3IgPSB3VGVuc29yO1xuICAgICAgICBfdGhpcy54VGVuc29yID0geFRlbnNvcjtcbiAgICAgICAgX3RoaXMuYlRlbnNvciA9IGJUZW5zb3I7XG4gICAgICAgIF90aGlzLnlUZW5zb3IgPSB5VGVuc29yO1xuICAgICAgICBfdGhpcy5maWVsZFNpemUgPSBmaWVsZFNpemU7XG4gICAgICAgIF90aGlzLm91dHB1dERlcHRoID0gb3V0cHV0RGVwdGg7XG4gICAgICAgIF90aGlzLnN0cmlkZSA9IHN0cmlkZTtcbiAgICAgICAgX3RoaXMuYXNzZXJ0V2VpZ2h0c1NoYXBlKHdUZW5zb3Iuc2hhcGUpO1xuICAgICAgICBfdGhpcy56ZXJvUGFkID0gemVyb1BhZCAhPSBudWxsID9cbiAgICAgICAgICAgIHplcm9QYWQgOlxuICAgICAgICAgICAgY29udl91dGlsLmNvbXB1dGVEZWZhdWx0UGFkKF90aGlzLnhUZW5zb3Iuc2hhcGUsIF90aGlzLmZpZWxkU2l6ZSwgX3RoaXMuc3RyaWRlKTtcbiAgICAgICAgdXRpbC5hc3NlcnQodXRpbC5pc0ludChfdGhpcy56ZXJvUGFkKSwgXCJUaGUgemVybyBwYWRkaW5nIChcIiArIF90aGlzLnplcm9QYWQgKyBcIikgbXVzdCBiZSBhbiBpbnRlZ2VyLiBDaGFuZ2UgdGhlIFwiICtcbiAgICAgICAgICAgIFwic3RyaWRlIGFuZC9vciB6ZXJvIHBhZCBwYXJhbWV0ZXJzXCIpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIENvbnZvbHV0aW9uMkQucHJvdG90eXBlLmZlZWRGb3J3YXJkID0gZnVuY3Rpb24gKG1hdGgsIGluZmVyZW5jZUFycmF5cykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgd2VpZ2h0cyA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy53VGVuc29yKTtcbiAgICAgICAgdmFyIGJpYXNlcyA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy5iVGVuc29yKTtcbiAgICAgICAgdmFyIHggPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMueFRlbnNvcik7XG4gICAgICAgIG1hdGguc2NvcGUoZnVuY3Rpb24gKGtlZXApIHtcbiAgICAgICAgICAgIGluZmVyZW5jZUFycmF5cy5zZXQoX3RoaXMueVRlbnNvciwga2VlcChtYXRoLmNvbnYyZCh4LCB3ZWlnaHRzLCBiaWFzZXMsIF90aGlzLnN0cmlkZSwgX3RoaXMuemVyb1BhZCkpKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBDb252b2x1dGlvbjJELnByb3RvdHlwZS5iYWNrUHJvcCA9IGZ1bmN0aW9uIChtYXRoLCBpbmZlcmVuY2VBcnJheXMsIGdyYWRpZW50QXJyYXlzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciB3ZWlnaHRzID0gaW5mZXJlbmNlQXJyYXlzLmdldCh0aGlzLndUZW5zb3IpO1xuICAgICAgICB2YXIgeCA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy54VGVuc29yKTtcbiAgICAgICAgdmFyIGR5ID0gZ3JhZGllbnRBcnJheXMuZ2V0KHRoaXMueVRlbnNvcik7XG4gICAgICAgIG1hdGguc2NvcGUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF9hID0gbWF0aC5jb252MmRCYWNrUHJvcCh4LCBkeSwgd2VpZ2h0cywgX3RoaXMuc3RyaWRlLCBfdGhpcy56ZXJvUGFkKSwgZHcgPSBfYS5kdywgZGIgPSBfYS5kYiwgZHggPSBfYS5keDtcbiAgICAgICAgICAgIGdyYWRpZW50QXJyYXlzLmFkZChfdGhpcy53VGVuc29yLCBkdyk7XG4gICAgICAgICAgICBncmFkaWVudEFycmF5cy5hZGQoX3RoaXMuYlRlbnNvciwgZGIpO1xuICAgICAgICAgICAgZ3JhZGllbnRBcnJheXMuYWRkKF90aGlzLnhUZW5zb3IsIGR4KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBDb252b2x1dGlvbjJELnByb3RvdHlwZS5hc3NlcnRXZWlnaHRzU2hhcGUgPSBmdW5jdGlvbiAod2VpZ2h0c1NoYXBlKSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0KHdlaWdodHNTaGFwZVswXSA9PT0gdGhpcy5maWVsZFNpemUgJiZcbiAgICAgICAgICAgIHdlaWdodHNTaGFwZVsxXSA9PT0gdGhpcy5maWVsZFNpemUgJiZcbiAgICAgICAgICAgIHdlaWdodHNTaGFwZVsyXSA9PT0gdGhpcy54VGVuc29yLnNoYXBlWzJdICYmXG4gICAgICAgICAgICB3ZWlnaHRzU2hhcGVbM10gPT09IHRoaXMub3V0cHV0RGVwdGgsIFwid2VpZ2h0cyBtdXN0IGJlIG9mIHNoYXBlIFtcIiArIHRoaXMuZmllbGRTaXplICsgXCIsXCIgKyB0aGlzLmZpZWxkU2l6ZSArIFwiLFwiICtcbiAgICAgICAgICAgICh0aGlzLnhUZW5zb3Iuc2hhcGVbMl0gKyBcIixcIiArIHRoaXMub3V0cHV0RGVwdGggKyBcIl0gYnV0IHRoZXkgYXJlIG9mXCIpICtcbiAgICAgICAgICAgIChcInNoYXBlIFtcIiArIHdlaWdodHNTaGFwZSArIFwiXVwiKSk7XG4gICAgfTtcbiAgICByZXR1cm4gQ29udm9sdXRpb24yRDtcbn0ob3BfMS5PcGVyYXRpb24pKTtcbmV4cG9ydHMuQ29udm9sdXRpb24yRCA9IENvbnZvbHV0aW9uMkQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb252b2x1dGlvbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vLi4vdXRpbFwiKTtcbnZhciBncmFwaF91dGlsID0gcmVxdWlyZShcIi4uL2dyYXBoX3V0aWxcIik7XG52YXIgb3BfMSA9IHJlcXVpcmUoXCIuL29wXCIpO1xudmFyIERpdmlkZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKERpdmlkZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBEaXZpZGUoeDFUZW5zb3IsIHgyVGVuc29yLCB5VGVuc29yKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLngxVGVuc29yID0geDFUZW5zb3I7XG4gICAgICAgIF90aGlzLngyVGVuc29yID0geDJUZW5zb3I7XG4gICAgICAgIF90aGlzLnlUZW5zb3IgPSB5VGVuc29yO1xuICAgICAgICB1dGlsLmFzc2VydCh1dGlsLnNpemVGcm9tU2hhcGUoeDFUZW5zb3Iuc2hhcGUpID09PSAxIHx8XG4gICAgICAgICAgICB1dGlsLnNpemVGcm9tU2hhcGUoeDJUZW5zb3Iuc2hhcGUpID09PSAxIHx8XG4gICAgICAgICAgICB1dGlsLmFycmF5c0VxdWFsKHgxVGVuc29yLnNoYXBlLCB4MlRlbnNvci5zaGFwZSksICdPbmUgb2YgdDEgb3IgdDIgbXVzdCBiZSBhIHNjYWxhciwgb3IgdDEgYW5kIHQyIG11c3QgaGF2ZSAnICtcbiAgICAgICAgICAgICd0aGUgc2FtZSBzaGFwZScpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIERpdmlkZS5wcm90b3R5cGUuZmVlZEZvcndhcmQgPSBmdW5jdGlvbiAobWF0aCwgaW5mZXJlbmNlQXJyYXlzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciB0MSA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy54MVRlbnNvcik7XG4gICAgICAgIHZhciB0MiA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy54MlRlbnNvcik7XG4gICAgICAgIG1hdGguc2NvcGUoZnVuY3Rpb24gKGtlZXApIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgICAgICBpZiAodXRpbC5pc1NjYWxhclNoYXBlKHQxLnNoYXBlKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IG1hdGguc2NhbGFyRGl2aWRlZEJ5QXJyYXkodDEsIHQyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHV0aWwuaXNTY2FsYXJTaGFwZSh0Mi5zaGFwZSkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBtYXRoLmFycmF5RGl2aWRlZEJ5U2NhbGFyKHQxLCB0Mik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBtYXRoLmRpdmlkZSh0MSwgdDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5mZXJlbmNlQXJyYXlzLnNldChfdGhpcy55VGVuc29yLCBrZWVwKHJlc3VsdCkpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIERpdmlkZS5wcm90b3R5cGUuYmFja1Byb3AgPSBmdW5jdGlvbiAobWF0aCwgaW5mZXJlbmNlQXJyYXlzLCBncmFkaWVudEFycmF5cykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgeDEgPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMueDFUZW5zb3IpO1xuICAgICAgICB2YXIgeDIgPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMueDJUZW5zb3IpO1xuICAgICAgICB2YXIgZHkgPSBncmFkaWVudEFycmF5cy5nZXQodGhpcy55VGVuc29yKTtcbiAgICAgICAgdmFyIHgxSXNTY2FsYXIgPSB1dGlsLmlzU2NhbGFyU2hhcGUoeDEuc2hhcGUpO1xuICAgICAgICB2YXIgeDJJc1NjYWxhciA9IHV0aWwuaXNTY2FsYXJTaGFwZSh4Mi5zaGFwZSk7XG4gICAgICAgIG1hdGguc2NvcGUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGdyYXBoX3V0aWwuc2hvdWxkQmFja1Byb3AoX3RoaXMueDFUZW5zb3IpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHgxSXNTY2FsYXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRpdiA9IG1hdGguZGl2aWRlKGR5LCB4Mik7XG4gICAgICAgICAgICAgICAgICAgIGdyYWRpZW50QXJyYXlzLmFkZChfdGhpcy54MVRlbnNvciwgbWF0aC5zdW0oZGl2KSk7XG4gICAgICAgICAgICAgICAgICAgIGRpdi5kaXNwb3NlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHgySXNTY2FsYXIpIHtcbiAgICAgICAgICAgICAgICAgICAgZ3JhZGllbnRBcnJheXMuYWRkKF90aGlzLngxVGVuc29yLCBtYXRoLmFycmF5RGl2aWRlZEJ5U2NhbGFyKGR5LCB4MikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZ3JhZGllbnRBcnJheXMuYWRkKF90aGlzLngxVGVuc29yLCBtYXRoLmRpdmlkZShkeSwgeDIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ3JhcGhfdXRpbC5zaG91bGRCYWNrUHJvcChfdGhpcy54MlRlbnNvcikpIHtcbiAgICAgICAgICAgICAgICB2YXIgeDJTcXVhcmVkID0gbWF0aC5lbGVtZW50V2lzZU11bCh4MiwgeDIpO1xuICAgICAgICAgICAgICAgIHZhciB4MU92ZXJYMlNxdWFyZWQgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgaWYgKHgySXNTY2FsYXIpIHtcbiAgICAgICAgICAgICAgICAgICAgeDFPdmVyWDJTcXVhcmVkID0gbWF0aC5hcnJheURpdmlkZWRCeVNjYWxhcih4MSwgeDJTcXVhcmVkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoeDFJc1NjYWxhcikge1xuICAgICAgICAgICAgICAgICAgICB4MU92ZXJYMlNxdWFyZWQgPSBtYXRoLnNjYWxhckRpdmlkZWRCeUFycmF5KHgxLCB4MlNxdWFyZWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgeDFPdmVyWDJTcXVhcmVkID0gbWF0aC5kaXZpZGUoeDEsIHgyU3F1YXJlZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBkeDIgPSBtYXRoLm5lZyh4MU92ZXJYMlNxdWFyZWQpO1xuICAgICAgICAgICAgICAgIHZhciBkeVRpbWVzRGVyaXZhdGl2ZSA9IG1hdGguZWxlbWVudFdpc2VNdWwoZHksIGR4Mik7XG4gICAgICAgICAgICAgICAgaWYgKHgySXNTY2FsYXIpIHtcbiAgICAgICAgICAgICAgICAgICAgZ3JhZGllbnRBcnJheXMuYWRkKF90aGlzLngyVGVuc29yLCBtYXRoLnN1bShkeVRpbWVzRGVyaXZhdGl2ZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZ3JhZGllbnRBcnJheXMuYWRkKF90aGlzLngyVGVuc29yLCBkeVRpbWVzRGVyaXZhdGl2ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBEaXZpZGU7XG59KG9wXzEuT3BlcmF0aW9uKSk7XG5leHBvcnRzLkRpdmlkZSA9IERpdmlkZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRpdmlkZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGFjdGl2YXRpb25fZnVuY3Rpb25zXzEgPSByZXF1aXJlKFwiLi4vLi4vbWF0aC9hY3RpdmF0aW9uX2Z1bmN0aW9uc1wiKTtcbnZhciBvcF8xID0gcmVxdWlyZShcIi4vb3BcIik7XG52YXIgRWxlbWVudFdpc2VBY3RpdmF0aW9uID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRWxlbWVudFdpc2VBY3RpdmF0aW9uLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEVsZW1lbnRXaXNlQWN0aXZhdGlvbih4VGVuc29yLCB5VGVuc29yLCBmdW5jKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnhUZW5zb3IgPSB4VGVuc29yO1xuICAgICAgICBfdGhpcy55VGVuc29yID0geVRlbnNvcjtcbiAgICAgICAgX3RoaXMuZnVuYyA9IGZ1bmM7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgRWxlbWVudFdpc2VBY3RpdmF0aW9uLnByb3RvdHlwZS5mZWVkRm9yd2FyZCA9IGZ1bmN0aW9uIChtYXRoLCBpbmZlcmVuY2VBcnJheXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHggPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMueFRlbnNvcik7XG4gICAgICAgIG1hdGguc2NvcGUoZnVuY3Rpb24gKGtlZXApIHtcbiAgICAgICAgICAgIGluZmVyZW5jZUFycmF5cy5zZXQoX3RoaXMueVRlbnNvciwga2VlcChfdGhpcy5mdW5jLm91dHB1dChtYXRoLCB4KSkpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEVsZW1lbnRXaXNlQWN0aXZhdGlvbi5wcm90b3R5cGUuYmFja1Byb3AgPSBmdW5jdGlvbiAobWF0aCwgaW5mZXJlbmNlQXJyYXlzLCBncmFkaWVudEFycmF5cykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgeCA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy54VGVuc29yKTtcbiAgICAgICAgdmFyIHkgPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMueVRlbnNvcik7XG4gICAgICAgIHZhciBkeSA9IGdyYWRpZW50QXJyYXlzLmdldCh0aGlzLnlUZW5zb3IpO1xuICAgICAgICBtYXRoLnNjb3BlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBkeWR4ID0gX3RoaXMuZnVuYy5kZXIobWF0aCwgeCwgeSk7XG4gICAgICAgICAgICBncmFkaWVudEFycmF5cy5hZGQoX3RoaXMueFRlbnNvciwgbWF0aC5lbGVtZW50V2lzZU11bChkeSwgZHlkeCkpO1xuICAgICAgICAgICAgZHlkeC5kaXNwb3NlKCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgRWxlbWVudFdpc2VBY3RpdmF0aW9uLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmZ1bmMuZGlzcG9zZSgpO1xuICAgIH07XG4gICAgcmV0dXJuIEVsZW1lbnRXaXNlQWN0aXZhdGlvbjtcbn0ob3BfMS5PcGVyYXRpb24pKTtcbmV4cG9ydHMuRWxlbWVudFdpc2VBY3RpdmF0aW9uID0gRWxlbWVudFdpc2VBY3RpdmF0aW9uO1xudmFyIFJlTFUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhSZUxVLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFJlTFUoeFRlbnNvciwgeVRlbnNvcikge1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgeFRlbnNvciwgeVRlbnNvciwgbmV3IGFjdGl2YXRpb25fZnVuY3Rpb25zXzEuUmVMVUZ1bmMoKSkgfHwgdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFJlTFU7XG59KEVsZW1lbnRXaXNlQWN0aXZhdGlvbikpO1xuZXhwb3J0cy5SZUxVID0gUmVMVTtcbnZhciBMZWFreVJlTFUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhMZWFreVJlTFUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTGVha3lSZUxVKHhUZW5zb3IsIHlUZW5zb3IsIGFscGhhKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCB4VGVuc29yLCB5VGVuc29yLCBuZXcgYWN0aXZhdGlvbl9mdW5jdGlvbnNfMS5MZWFreVJlbHVGdW5jKGFscGhhKSkgfHwgdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIExlYWt5UmVMVTtcbn0oRWxlbWVudFdpc2VBY3RpdmF0aW9uKSk7XG5leHBvcnRzLkxlYWt5UmVMVSA9IExlYWt5UmVMVTtcbnZhciBUYW5IID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVGFuSCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUYW5IKHhUZW5zb3IsIHlUZW5zb3IpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIHhUZW5zb3IsIHlUZW5zb3IsIG5ldyBhY3RpdmF0aW9uX2Z1bmN0aW9uc18xLlRhbkhGdW5jKCkpIHx8IHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBUYW5IO1xufShFbGVtZW50V2lzZUFjdGl2YXRpb24pKTtcbmV4cG9ydHMuVGFuSCA9IFRhbkg7XG52YXIgU2lnbW9pZCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFNpZ21vaWQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU2lnbW9pZCh4VGVuc29yLCB5VGVuc29yKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCB4VGVuc29yLCB5VGVuc29yLCBuZXcgYWN0aXZhdGlvbl9mdW5jdGlvbnNfMS5TaWdtb2lkRnVuYygpKSB8fCB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gU2lnbW9pZDtcbn0oRWxlbWVudFdpc2VBY3RpdmF0aW9uKSk7XG5leHBvcnRzLlNpZ21vaWQgPSBTaWdtb2lkO1xudmFyIFNxdWFyZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFNxdWFyZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTcXVhcmUoeFRlbnNvciwgeVRlbnNvcikge1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgeFRlbnNvciwgeVRlbnNvciwgbmV3IGFjdGl2YXRpb25fZnVuY3Rpb25zXzEuU3F1YXJlRnVuYygpKSB8fCB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gU3F1YXJlO1xufShFbGVtZW50V2lzZUFjdGl2YXRpb24pKTtcbmV4cG9ydHMuU3F1YXJlID0gU3F1YXJlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZWxlbWVudF93aXNlX2FjdGl2YXRpb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBjb3N0X2Z1bmN0aW9uc18xID0gcmVxdWlyZShcIi4uLy4uL21hdGgvY29zdF9mdW5jdGlvbnNcIik7XG52YXIgbmRhcnJheV8xID0gcmVxdWlyZShcIi4uLy4uL21hdGgvbmRhcnJheVwiKTtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4uLy4uL3V0aWxcIik7XG52YXIgZ3JhcGhfdXRpbCA9IHJlcXVpcmUoXCIuLi9ncmFwaF91dGlsXCIpO1xudmFyIG9wXzEgPSByZXF1aXJlKFwiLi9vcFwiKTtcbnZhciBFbGVtZW50V2lzZUNvc3QgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhFbGVtZW50V2lzZUNvc3QsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRWxlbWVudFdpc2VDb3N0KHgxVGVuc29yLCB4MlRlbnNvciwgeVRlbnNvciwgZnVuYykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy54MVRlbnNvciA9IHgxVGVuc29yO1xuICAgICAgICBfdGhpcy54MlRlbnNvciA9IHgyVGVuc29yO1xuICAgICAgICBfdGhpcy55VGVuc29yID0geVRlbnNvcjtcbiAgICAgICAgX3RoaXMuZnVuYyA9IGZ1bmM7XG4gICAgICAgIF90aGlzLm9uZU92ZXJOU2NhbGFyID0gbmRhcnJheV8xLlNjYWxhci5uZXcoMSAvIHV0aWwuc2l6ZUZyb21TaGFwZSh4MVRlbnNvci5zaGFwZSkpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEVsZW1lbnRXaXNlQ29zdC5wcm90b3R5cGUuZmVlZEZvcndhcmQgPSBmdW5jdGlvbiAobWF0aCwgaW5mZXJlbmNlQXJyYXlzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciB4MSA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy54MVRlbnNvcik7XG4gICAgICAgIHZhciB4MiA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy54MlRlbnNvcik7XG4gICAgICAgIG1hdGguc2NvcGUoZnVuY3Rpb24gKGtlZXApIHtcbiAgICAgICAgICAgIHZhciBlbGVtZW50V2lzZUNvc3QgPSBfdGhpcy5mdW5jLmNvc3QobWF0aCwgeDEsIHgyKTtcbiAgICAgICAgICAgIHZhciBzdW0gPSBtYXRoLnN1bShlbGVtZW50V2lzZUNvc3QpO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG1hdGguc2NhbGFyVGltZXNBcnJheShfdGhpcy5vbmVPdmVyTlNjYWxhciwgc3VtKTtcbiAgICAgICAgICAgIGluZmVyZW5jZUFycmF5cy5zZXQoX3RoaXMueVRlbnNvciwga2VlcChyZXN1bHQpKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBFbGVtZW50V2lzZUNvc3QucHJvdG90eXBlLmJhY2tQcm9wID0gZnVuY3Rpb24gKG1hdGgsIGluZmVyZW5jZUFycmF5cywgZ3JhZGllbnRBcnJheXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHgxID0gaW5mZXJlbmNlQXJyYXlzLmdldCh0aGlzLngxVGVuc29yKTtcbiAgICAgICAgdmFyIHgyID0gaW5mZXJlbmNlQXJyYXlzLmdldCh0aGlzLngyVGVuc29yKTtcbiAgICAgICAgbWF0aC5zY29wZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoZ3JhcGhfdXRpbC5zaG91bGRCYWNrUHJvcChfdGhpcy54MVRlbnNvcikpIHtcbiAgICAgICAgICAgICAgICBncmFkaWVudEFycmF5cy5hZGQoX3RoaXMueDFUZW5zb3IsIF90aGlzLmZ1bmMuZGVyKG1hdGgsIHgxLCB4MikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdyYXBoX3V0aWwuc2hvdWxkQmFja1Byb3AoX3RoaXMueDJUZW5zb3IpKSB7XG4gICAgICAgICAgICAgICAgZ3JhZGllbnRBcnJheXMuYWRkKF90aGlzLngyVGVuc29yLCBfdGhpcy5mdW5jLmRlcihtYXRoLCB4MiwgeDEpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBFbGVtZW50V2lzZUNvc3QucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZnVuYy5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMub25lT3Zlck5TY2FsYXIuZGlzcG9zZSgpO1xuICAgIH07XG4gICAgcmV0dXJuIEVsZW1lbnRXaXNlQ29zdDtcbn0ob3BfMS5PcGVyYXRpb24pKTtcbmV4cG9ydHMuRWxlbWVudFdpc2VDb3N0ID0gRWxlbWVudFdpc2VDb3N0O1xudmFyIE1lYW5TcXVhcmVkQ29zdCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1lYW5TcXVhcmVkQ29zdCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNZWFuU3F1YXJlZENvc3QoeDFUZW5zb3IsIHgyVGVuc29yLCB5VGVuc29yKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCB4MVRlbnNvciwgeDJUZW5zb3IsIHlUZW5zb3IsIG5ldyBjb3N0X2Z1bmN0aW9uc18xLlNxdWFyZUNvc3RGdW5jKCkpIHx8IHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBNZWFuU3F1YXJlZENvc3Q7XG59KEVsZW1lbnRXaXNlQ29zdCkpO1xuZXhwb3J0cy5NZWFuU3F1YXJlZENvc3QgPSBNZWFuU3F1YXJlZENvc3Q7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lbGVtZW50X3dpc2VfY29zdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGdyYXBoX3V0aWwgPSByZXF1aXJlKFwiLi4vZ3JhcGhfdXRpbFwiKTtcbnZhciBvcF8xID0gcmVxdWlyZShcIi4vb3BcIik7XG52YXIgRXhwID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRXhwLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEV4cCh4VGVuc29yLCB5VGVuc29yKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnhUZW5zb3IgPSB4VGVuc29yO1xuICAgICAgICBfdGhpcy55VGVuc29yID0geVRlbnNvcjtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBFeHAucHJvdG90eXBlLmZlZWRGb3J3YXJkID0gZnVuY3Rpb24gKG1hdGgsIGluZmVyZW5jZUFycmF5cykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgeCA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy54VGVuc29yKTtcbiAgICAgICAgbWF0aC5zY29wZShmdW5jdGlvbiAoa2VlcCkge1xuICAgICAgICAgICAgaW5mZXJlbmNlQXJyYXlzLnNldChfdGhpcy55VGVuc29yLCBrZWVwKG1hdGguZXhwKHgpKSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgRXhwLnByb3RvdHlwZS5iYWNrUHJvcCA9IGZ1bmN0aW9uIChtYXRoLCBpbmZlcmVuY2VBcnJheXMsIGdyYWRpZW50QXJyYXlzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciB5ID0gaW5mZXJlbmNlQXJyYXlzLmdldCh0aGlzLnlUZW5zb3IpO1xuICAgICAgICB2YXIgZHkgPSBncmFkaWVudEFycmF5cy5nZXQodGhpcy55VGVuc29yKTtcbiAgICAgICAgbWF0aC5zY29wZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoZ3JhcGhfdXRpbC5zaG91bGRCYWNrUHJvcChfdGhpcy54VGVuc29yKSkge1xuICAgICAgICAgICAgICAgIGdyYWRpZW50QXJyYXlzLmFkZChfdGhpcy54VGVuc29yLCBtYXRoLmVsZW1lbnRXaXNlTXVsKHksIGR5KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIEV4cDtcbn0ob3BfMS5PcGVyYXRpb24pKTtcbmV4cG9ydHMuRXhwID0gRXhwO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXhwLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZ3JhcGhfdXRpbCA9IHJlcXVpcmUoXCIuLi9ncmFwaF91dGlsXCIpO1xudmFyIG9wXzEgPSByZXF1aXJlKFwiLi9vcFwiKTtcbnZhciBMaW5lYXJDb21iaW5hdGlvbiA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKExpbmVhckNvbWJpbmF0aW9uLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIExpbmVhckNvbWJpbmF0aW9uKHgxVGVuc29yLCB4MlRlbnNvciwgYzFUZW5zb3IsIGMyVGVuc29yLCBvdXRUZW5zb3IpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMueDFUZW5zb3IgPSB4MVRlbnNvcjtcbiAgICAgICAgX3RoaXMueDJUZW5zb3IgPSB4MlRlbnNvcjtcbiAgICAgICAgX3RoaXMuYzFUZW5zb3IgPSBjMVRlbnNvcjtcbiAgICAgICAgX3RoaXMuYzJUZW5zb3IgPSBjMlRlbnNvcjtcbiAgICAgICAgX3RoaXMub3V0VGVuc29yID0gb3V0VGVuc29yO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIExpbmVhckNvbWJpbmF0aW9uLnByb3RvdHlwZS5mZWVkRm9yd2FyZCA9IGZ1bmN0aW9uIChtYXRoLCBpbmZlcmVuY2VBcnJheXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHgxID0gaW5mZXJlbmNlQXJyYXlzLmdldCh0aGlzLngxVGVuc29yKTtcbiAgICAgICAgdmFyIHgyID0gaW5mZXJlbmNlQXJyYXlzLmdldCh0aGlzLngyVGVuc29yKTtcbiAgICAgICAgdmFyIGMxID0gaW5mZXJlbmNlQXJyYXlzLmdldCh0aGlzLmMxVGVuc29yKS5hc1NjYWxhcigpO1xuICAgICAgICB2YXIgYzIgPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMuYzJUZW5zb3IpLmFzU2NhbGFyKCk7XG4gICAgICAgIG1hdGguc2NvcGUoZnVuY3Rpb24gKGtlZXApIHtcbiAgICAgICAgICAgIGluZmVyZW5jZUFycmF5cy5zZXQoX3RoaXMub3V0VGVuc29yLCBrZWVwKG1hdGguc2NhbGVkQXJyYXlBZGQoYzEsIHgxLCBjMiwgeDIpKSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgTGluZWFyQ29tYmluYXRpb24ucHJvdG90eXBlLmJhY2tQcm9wID0gZnVuY3Rpb24gKG1hdGgsIGluZmVyZW5jZUFycmF5cywgZ3JhZGllbnRBcnJheXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHgxID0gaW5mZXJlbmNlQXJyYXlzLmdldCh0aGlzLngxVGVuc29yKTtcbiAgICAgICAgdmFyIHgyID0gaW5mZXJlbmNlQXJyYXlzLmdldCh0aGlzLngyVGVuc29yKTtcbiAgICAgICAgdmFyIGMxID0gaW5mZXJlbmNlQXJyYXlzLmdldCh0aGlzLmMxVGVuc29yKTtcbiAgICAgICAgdmFyIGMyID0gaW5mZXJlbmNlQXJyYXlzLmdldCh0aGlzLmMyVGVuc29yKTtcbiAgICAgICAgdmFyIGR5ID0gZ3JhZGllbnRBcnJheXMuZ2V0KHRoaXMub3V0VGVuc29yKTtcbiAgICAgICAgbWF0aC5zY29wZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoZ3JhcGhfdXRpbC5zaG91bGRCYWNrUHJvcChfdGhpcy54MVRlbnNvcikpIHtcbiAgICAgICAgICAgICAgICBncmFkaWVudEFycmF5cy5hZGQoX3RoaXMueDFUZW5zb3IsIG1hdGguc2NhbGFyVGltZXNBcnJheShjMSwgZHkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChncmFwaF91dGlsLnNob3VsZEJhY2tQcm9wKF90aGlzLngyVGVuc29yKSkge1xuICAgICAgICAgICAgICAgIGdyYWRpZW50QXJyYXlzLmFkZChfdGhpcy54MlRlbnNvciwgbWF0aC5zY2FsYXJUaW1lc0FycmF5KGMyLCBkeSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdyYXBoX3V0aWwuc2hvdWxkQmFja1Byb3AoX3RoaXMuYzFUZW5zb3IpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRvdFByb2R1Y3QxID0gbWF0aC5lbGVtZW50V2lzZU11bCh4MSwgZHkpO1xuICAgICAgICAgICAgICAgIGdyYWRpZW50QXJyYXlzLmFkZChfdGhpcy5jMVRlbnNvciwgbWF0aC5zdW0oZG90UHJvZHVjdDEpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChncmFwaF91dGlsLnNob3VsZEJhY2tQcm9wKF90aGlzLmMyVGVuc29yKSkge1xuICAgICAgICAgICAgICAgIHZhciBkb3RQcm9kdWN0MiA9IG1hdGguZWxlbWVudFdpc2VNdWwoeDIsIGR5KTtcbiAgICAgICAgICAgICAgICBncmFkaWVudEFycmF5cy5hZGQoX3RoaXMuYzJUZW5zb3IsIG1hdGguc3VtKGRvdFByb2R1Y3QyKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIExpbmVhckNvbWJpbmF0aW9uO1xufShvcF8xLk9wZXJhdGlvbikpO1xuZXhwb3J0cy5MaW5lYXJDb21iaW5hdGlvbiA9IExpbmVhckNvbWJpbmF0aW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGluZWFyX2NvbWJpbmF0aW9uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZ3JhcGhfdXRpbCA9IHJlcXVpcmUoXCIuLi9ncmFwaF91dGlsXCIpO1xudmFyIG9wXzEgPSByZXF1aXJlKFwiLi9vcFwiKTtcbnZhciBMb2cgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhMb2csIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTG9nKHhUZW5zb3IsIHlUZW5zb3IpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMueFRlbnNvciA9IHhUZW5zb3I7XG4gICAgICAgIF90aGlzLnlUZW5zb3IgPSB5VGVuc29yO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIExvZy5wcm90b3R5cGUuZmVlZEZvcndhcmQgPSBmdW5jdGlvbiAobWF0aCwgaW5mZXJlbmNlQXJyYXlzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciB4ID0gaW5mZXJlbmNlQXJyYXlzLmdldCh0aGlzLnhUZW5zb3IpO1xuICAgICAgICBtYXRoLnNjb3BlKGZ1bmN0aW9uIChrZWVwKSB7XG4gICAgICAgICAgICBpbmZlcmVuY2VBcnJheXMuc2V0KF90aGlzLnlUZW5zb3IsIGtlZXAobWF0aC5sb2coeCkpKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBMb2cucHJvdG90eXBlLmJhY2tQcm9wID0gZnVuY3Rpb24gKG1hdGgsIGluZmVyZW5jZUFycmF5cywgZ3JhZGllbnRBcnJheXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHggPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMueFRlbnNvcik7XG4gICAgICAgIHZhciBkeSA9IGdyYWRpZW50QXJyYXlzLmdldCh0aGlzLnlUZW5zb3IpO1xuICAgICAgICBtYXRoLnNjb3BlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChncmFwaF91dGlsLnNob3VsZEJhY2tQcm9wKF90aGlzLnhUZW5zb3IpKSB7XG4gICAgICAgICAgICAgICAgZ3JhZGllbnRBcnJheXMuYWRkKF90aGlzLnhUZW5zb3IsIG1hdGguZGl2aWRlKGR5LCB4KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIExvZztcbn0ob3BfMS5PcGVyYXRpb24pKTtcbmV4cG9ydHMuTG9nID0gTG9nO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9nLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgbWF0aF8xID0gcmVxdWlyZShcIi4uLy4uL21hdGgvbWF0aFwiKTtcbnZhciBncmFwaF91dGlsID0gcmVxdWlyZShcIi4uL2dyYXBoX3V0aWxcIik7XG52YXIgb3BfMSA9IHJlcXVpcmUoXCIuL29wXCIpO1xudmFyIE1hdE11bCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1hdE11bCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNYXRNdWwoeDFUZW5zb3IsIHgyVGVuc29yLCB5VGVuc29yKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLngxVGVuc29yID0geDFUZW5zb3I7XG4gICAgICAgIF90aGlzLngyVGVuc29yID0geDJUZW5zb3I7XG4gICAgICAgIF90aGlzLnlUZW5zb3IgPSB5VGVuc29yO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE1hdE11bC5wcm90b3R5cGUuZmVlZEZvcndhcmQgPSBmdW5jdGlvbiAobWF0aCwgaW5mZXJlbmNlQXJyYXlzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciB4MSA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy54MVRlbnNvcik7XG4gICAgICAgIHZhciB4MiA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy54MlRlbnNvcik7XG4gICAgICAgIG1hdGguc2NvcGUoZnVuY3Rpb24gKGtlZXApIHtcbiAgICAgICAgICAgIGlmICh4MS5zaGFwZS5sZW5ndGggPT09IDIgJiYgeDIuc2hhcGUubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICAgICAgaW5mZXJlbmNlQXJyYXlzLnNldChfdGhpcy55VGVuc29yLCBrZWVwKG1hdGgubWF0TXVsKHgxLCB4MikpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHgxLnNoYXBlLmxlbmd0aCA9PT0gMiAmJiB4Mi5zaGFwZS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICBpbmZlcmVuY2VBcnJheXMuc2V0KF90aGlzLnlUZW5zb3IsIGtlZXAobWF0aC5tYXRyaXhUaW1lc1ZlY3Rvcih4MSwgeDIpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh4MS5zaGFwZS5sZW5ndGggPT09IDEgJiYgeDIuc2hhcGUubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICAgICAgaW5mZXJlbmNlQXJyYXlzLnNldChfdGhpcy55VGVuc29yLCBrZWVwKG1hdGgudmVjdG9yVGltZXNNYXRyaXgoeDEsIHgyKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIE1hdE11bC5wcm90b3R5cGUuYmFja1Byb3AgPSBmdW5jdGlvbiAobWF0aCwgaW5mZXJlbmNlQXJyYXlzLCBncmFkaWVudEFycmF5cykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgeDEgPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMueDFUZW5zb3IpO1xuICAgICAgICB2YXIgeDIgPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMueDJUZW5zb3IpO1xuICAgICAgICB2YXIgZHkgPSBncmFkaWVudEFycmF5cy5nZXQodGhpcy55VGVuc29yKTtcbiAgICAgICAgaWYgKHgxLnNoYXBlLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgeDEgPSB4MS5yZXNoYXBlKFsxLCB4MS5zaXplXSk7XG4gICAgICAgICAgICBkeSA9IGR5LnJlc2hhcGUoWzEsIGR5LnNpemVdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoeDIuc2hhcGUubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICB4MiA9IHgyLnJlc2hhcGUoW3gyLnNpemUsIDFdKTtcbiAgICAgICAgICAgIGR5ID0gZHkucmVzaGFwZShbZHkuc2l6ZSwgMV0pO1xuICAgICAgICB9XG4gICAgICAgIG1hdGguc2NvcGUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGdyYXBoX3V0aWwuc2hvdWxkQmFja1Byb3AoX3RoaXMueDFUZW5zb3IpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGR4MSA9IG1hdGgubWF0TXVsKGR5LCB4MiwgbWF0aF8xLk1hdHJpeE9yaWVudGF0aW9uLlJFR1VMQVIsIG1hdGhfMS5NYXRyaXhPcmllbnRhdGlvbi5UUkFOU1BPU0VEKTtcbiAgICAgICAgICAgICAgICBncmFkaWVudEFycmF5cy5hZGQoX3RoaXMueDFUZW5zb3IsIF90aGlzLngxVGVuc29yLnNoYXBlLmxlbmd0aCA9PT0gMSA/IGR4MS5hczFEKCkgOiBkeDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdyYXBoX3V0aWwuc2hvdWxkQmFja1Byb3AoX3RoaXMueDJUZW5zb3IpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGR4MiA9IG1hdGgubWF0TXVsKHgxLCBkeSwgbWF0aF8xLk1hdHJpeE9yaWVudGF0aW9uLlRSQU5TUE9TRUQsIG1hdGhfMS5NYXRyaXhPcmllbnRhdGlvbi5SRUdVTEFSKTtcbiAgICAgICAgICAgICAgICBncmFkaWVudEFycmF5cy5hZGQoX3RoaXMueDJUZW5zb3IsIF90aGlzLngyVGVuc29yLnNoYXBlLmxlbmd0aCA9PT0gMSA/IGR4Mi5hczFEKCkgOiBkeDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBNYXRNdWw7XG59KG9wXzEuT3BlcmF0aW9uKSk7XG5leHBvcnRzLk1hdE11bCA9IE1hdE11bDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1hdG11bC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGNvbnZfdXRpbCA9IHJlcXVpcmUoXCIuLi8uLi9tYXRoL2NvbnZfdXRpbFwiKTtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4uLy4uL3V0aWxcIik7XG52YXIgb3BfMSA9IHJlcXVpcmUoXCIuL29wXCIpO1xudmFyIE1heFBvb2wgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNYXhQb29sLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1heFBvb2woeFRlbnNvciwgeVRlbnNvciwgZmllbGRTaXplLCBzdHJpZGUsIHBhZCkge1xuICAgICAgICBpZiAoc3RyaWRlID09PSB2b2lkIDApIHsgc3RyaWRlID0gMTsgfVxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy54VGVuc29yID0geFRlbnNvcjtcbiAgICAgICAgX3RoaXMueVRlbnNvciA9IHlUZW5zb3I7XG4gICAgICAgIF90aGlzLmZpZWxkU2l6ZSA9IGZpZWxkU2l6ZTtcbiAgICAgICAgX3RoaXMuc3RyaWRlID0gc3RyaWRlO1xuICAgICAgICBpZiAocGFkICE9IG51bGwpIHtcbiAgICAgICAgICAgIF90aGlzLnBhZCA9IHBhZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIF90aGlzLnBhZCA9IGNvbnZfdXRpbC5jb21wdXRlRGVmYXVsdFBhZCh4VGVuc29yLnNoYXBlLCBfdGhpcy5maWVsZFNpemUsIF90aGlzLnN0cmlkZSk7XG4gICAgICAgIH1cbiAgICAgICAgdXRpbC5hc3NlcnQodXRpbC5pc0ludChfdGhpcy5wYWQpLCBcIlRoZSB6ZXJvIHBhZGRpbmcgKFwiICsgX3RoaXMucGFkICsgXCIpIG11c3QgYmUgYW4gaW50ZWdlci4gQ2hhbmdlIHRoZSBcIiArXG4gICAgICAgICAgICBcInN0cmlkZSBhbmQvb3IgemVybyBwYWQgcGFyYW1ldGVyc1wiKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBNYXhQb29sLnByb3RvdHlwZS5mZWVkRm9yd2FyZCA9IGZ1bmN0aW9uIChtYXRoLCBpbmZlcmVuY2VBcnJheXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHggPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMueFRlbnNvcik7XG4gICAgICAgIG1hdGguc2NvcGUoZnVuY3Rpb24gKGtlZXApIHtcbiAgICAgICAgICAgIGluZmVyZW5jZUFycmF5cy5zZXQoX3RoaXMueVRlbnNvciwga2VlcChtYXRoLm1heFBvb2woeCwgX3RoaXMuZmllbGRTaXplLCBfdGhpcy5zdHJpZGUsIF90aGlzLnBhZCkpKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBNYXhQb29sLnByb3RvdHlwZS5iYWNrUHJvcCA9IGZ1bmN0aW9uIChtYXRoLCBpbmZlcmVuY2VBcnJheXMsIGdyYWRpZW50QXJyYXlzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciB4ID0gaW5mZXJlbmNlQXJyYXlzLmdldCh0aGlzLnhUZW5zb3IpO1xuICAgICAgICB2YXIgZHkgPSBncmFkaWVudEFycmF5cy5nZXQodGhpcy55VGVuc29yKTtcbiAgICAgICAgbWF0aC5zY29wZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBncmFkaWVudEFycmF5cy5hZGQoX3RoaXMueFRlbnNvciwgbWF0aC5tYXhQb29sQmFja3Byb3AoZHksIHgsIF90aGlzLmZpZWxkU2l6ZSwgX3RoaXMuc3RyaWRlLCBfdGhpcy5wYWQpKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gTWF4UG9vbDtcbn0ob3BfMS5PcGVyYXRpb24pKTtcbmV4cG9ydHMuTWF4UG9vbCA9IE1heFBvb2w7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYXhfcG9vbC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vLi4vdXRpbFwiKTtcbnZhciBncmFwaF91dGlsID0gcmVxdWlyZShcIi4uL2dyYXBoX3V0aWxcIik7XG52YXIgb3BfMSA9IHJlcXVpcmUoXCIuL29wXCIpO1xudmFyIE11bHRpcGx5ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTXVsdGlwbHksIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTXVsdGlwbHkoeDFUZW5zb3IsIHgyVGVuc29yLCB5VGVuc29yKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLngxVGVuc29yID0geDFUZW5zb3I7XG4gICAgICAgIF90aGlzLngyVGVuc29yID0geDJUZW5zb3I7XG4gICAgICAgIF90aGlzLnlUZW5zb3IgPSB5VGVuc29yO1xuICAgICAgICB1dGlsLmFzc2VydCh1dGlsLnNpemVGcm9tU2hhcGUoeDFUZW5zb3Iuc2hhcGUpID09PSAxIHx8XG4gICAgICAgICAgICB1dGlsLnNpemVGcm9tU2hhcGUoeDJUZW5zb3Iuc2hhcGUpID09PSAxIHx8XG4gICAgICAgICAgICB1dGlsLmFycmF5c0VxdWFsKHgxVGVuc29yLnNoYXBlLCB4MlRlbnNvci5zaGFwZSksICdPbmUgb2YgdDEgb3IgdDIgbXVzdCBiZSBhIHNjYWxhciwgb3IgdDEgYW5kIHQyIG11c3QgaGF2ZSAnICtcbiAgICAgICAgICAgICd0aGUgc2FtZSBzaGFwZScpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE11bHRpcGx5LnByb3RvdHlwZS5mZWVkRm9yd2FyZCA9IGZ1bmN0aW9uIChtYXRoLCBpbmZlcmVuY2VBcnJheXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHQxID0gaW5mZXJlbmNlQXJyYXlzLmdldCh0aGlzLngxVGVuc29yKTtcbiAgICAgICAgdmFyIHQyID0gaW5mZXJlbmNlQXJyYXlzLmdldCh0aGlzLngyVGVuc29yKTtcbiAgICAgICAgbWF0aC5zY29wZShmdW5jdGlvbiAoa2VlcCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgICAgIGlmICh1dGlsLmlzU2NhbGFyU2hhcGUodDEuc2hhcGUpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gbWF0aC5zY2FsYXJUaW1lc0FycmF5KHQxLCB0Mik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh1dGlsLmlzU2NhbGFyU2hhcGUodDIuc2hhcGUpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gbWF0aC5zY2FsYXJUaW1lc0FycmF5KHQyLCB0MSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBtYXRoLmVsZW1lbnRXaXNlTXVsKHQxLCB0Mik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbmZlcmVuY2VBcnJheXMuc2V0KF90aGlzLnlUZW5zb3IsIGtlZXAocmVzdWx0KSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgTXVsdGlwbHkucHJvdG90eXBlLmJhY2tQcm9wID0gZnVuY3Rpb24gKG1hdGgsIGluZmVyZW5jZUFycmF5cywgZ3JhZGllbnRBcnJheXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHgxID0gaW5mZXJlbmNlQXJyYXlzLmdldCh0aGlzLngxVGVuc29yKTtcbiAgICAgICAgdmFyIHgyID0gaW5mZXJlbmNlQXJyYXlzLmdldCh0aGlzLngyVGVuc29yKTtcbiAgICAgICAgdmFyIGR5ID0gZ3JhZGllbnRBcnJheXMuZ2V0KHRoaXMueVRlbnNvcik7XG4gICAgICAgIG1hdGguc2NvcGUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGdyYXBoX3V0aWwuc2hvdWxkQmFja1Byb3AoX3RoaXMueDFUZW5zb3IpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHV0aWwuaXNTY2FsYXJTaGFwZShfdGhpcy54MVRlbnNvci5zaGFwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG11bCA9IG1hdGguZWxlbWVudFdpc2VNdWwoZHksIHgyKTtcbiAgICAgICAgICAgICAgICAgICAgZ3JhZGllbnRBcnJheXMuYWRkKF90aGlzLngxVGVuc29yLCBtYXRoLnN1bShtdWwpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodXRpbC5pc1NjYWxhclNoYXBlKHgyLnNoYXBlKSkge1xuICAgICAgICAgICAgICAgICAgICBncmFkaWVudEFycmF5cy5hZGQoX3RoaXMueDFUZW5zb3IsIG1hdGguc2NhbGFyVGltZXNBcnJheSh4MiwgZHkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGdyYWRpZW50QXJyYXlzLmFkZChfdGhpcy54MVRlbnNvciwgbWF0aC5lbGVtZW50V2lzZU11bCh4MiwgZHkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ3JhcGhfdXRpbC5zaG91bGRCYWNrUHJvcChfdGhpcy54MlRlbnNvcikpIHtcbiAgICAgICAgICAgICAgICBpZiAodXRpbC5pc1NjYWxhclNoYXBlKF90aGlzLngyVGVuc29yLnNoYXBlKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbXVsID0gbWF0aC5lbGVtZW50V2lzZU11bChkeSwgeDEpO1xuICAgICAgICAgICAgICAgICAgICBncmFkaWVudEFycmF5cy5hZGQoX3RoaXMueDJUZW5zb3IsIG1hdGguc3VtKG11bCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh1dGlsLmlzU2NhbGFyU2hhcGUoeDEuc2hhcGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGdyYWRpZW50QXJyYXlzLmFkZChfdGhpcy54MlRlbnNvciwgbWF0aC5zY2FsYXJUaW1lc0FycmF5KHgxLCBkeSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZ3JhZGllbnRBcnJheXMuYWRkKF90aGlzLngyVGVuc29yLCBtYXRoLmVsZW1lbnRXaXNlTXVsKHgxLCBkeSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gTXVsdGlwbHk7XG59KG9wXzEuT3BlcmF0aW9uKSk7XG5leHBvcnRzLk11bHRpcGx5ID0gTXVsdGlwbHk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tdWx0aXBseS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBPcGVyYXRpb24gPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE9wZXJhdGlvbigpIHtcbiAgICB9XG4gICAgT3BlcmF0aW9uLnByb3RvdHlwZS5kaXNwb3NlVHJhbnNpZW50QXJyYXlzID0gZnVuY3Rpb24gKGluZmVyZW5jZUFycmF5cywgZ3JhZGllbnRBcnJheXMpIHsgfTtcbiAgICBPcGVyYXRpb24ucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgcmV0dXJuIE9wZXJhdGlvbjtcbn0oKSk7XG5leHBvcnRzLk9wZXJhdGlvbiA9IE9wZXJhdGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9wLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgbmRhcnJheV8xID0gcmVxdWlyZShcIi4uLy4uL21hdGgvbmRhcnJheVwiKTtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4uLy4uL3V0aWxcIik7XG52YXIgZ3JhcGhfdXRpbCA9IHJlcXVpcmUoXCIuLi9ncmFwaF91dGlsXCIpO1xudmFyIG9wXzEgPSByZXF1aXJlKFwiLi9vcFwiKTtcbnZhciBSZWR1Y2VTdW0gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhSZWR1Y2VTdW0sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUmVkdWNlU3VtKHgsIG91dFRlbnNvcikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy54ID0geDtcbiAgICAgICAgX3RoaXMub3V0VGVuc29yID0gb3V0VGVuc29yO1xuICAgICAgICB1dGlsLmFzc2VydFNoYXBlc01hdGNoKG91dFRlbnNvci5zaGFwZSwgW10pO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFJlZHVjZVN1bS5wcm90b3R5cGUuZmVlZEZvcndhcmQgPSBmdW5jdGlvbiAobWF0aCwgaW5mZXJlbmNlQXJyYXlzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciB4ID0gaW5mZXJlbmNlQXJyYXlzLmdldCh0aGlzLngpO1xuICAgICAgICBtYXRoLnNjb3BlKGZ1bmN0aW9uIChrZWVwKSB7XG4gICAgICAgICAgICBpbmZlcmVuY2VBcnJheXMuc2V0KF90aGlzLm91dFRlbnNvciwga2VlcChtYXRoLnN1bSh4KSkpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFJlZHVjZVN1bS5wcm90b3R5cGUuYmFja1Byb3AgPSBmdW5jdGlvbiAobWF0aCwgaW5mZXJlbmNlQXJyYXlzLCBncmFkaWVudEFycmF5cykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoIWdyYXBoX3V0aWwuc2hvdWxkQmFja1Byb3AodGhpcy54KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG1hdGguc2NvcGUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGR5ID0gZ3JhZGllbnRBcnJheXMuZ2V0KF90aGlzLm91dFRlbnNvcik7XG4gICAgICAgICAgICBpZiAoX3RoaXMub25lcyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdmFyIHhBcnJheSA9IGluZmVyZW5jZUFycmF5cy5nZXQoX3RoaXMueCk7XG4gICAgICAgICAgICAgICAgX3RoaXMub25lcyA9IG5kYXJyYXlfMS5OREFycmF5Lnplcm9zTGlrZSh4QXJyYXkpO1xuICAgICAgICAgICAgICAgIF90aGlzLm9uZXMuZmlsbCgxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdyYWRpZW50QXJyYXlzLmFkZChfdGhpcy54LCBtYXRoLnNjYWxhclRpbWVzQXJyYXkoZHksIF90aGlzLm9uZXMpKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gUmVkdWNlU3VtO1xufShvcF8xLk9wZXJhdGlvbikpO1xuZXhwb3J0cy5SZWR1Y2VTdW0gPSBSZWR1Y2VTdW07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWR1Y2Vfc3VtLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi8uLi91dGlsXCIpO1xudmFyIG9wXzEgPSByZXF1aXJlKFwiLi9vcFwiKTtcbnZhciBSZXNoYXBlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUmVzaGFwZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBSZXNoYXBlKHhUZW5zb3IsIHlUZW5zb3IpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMueFRlbnNvciA9IHhUZW5zb3I7XG4gICAgICAgIF90aGlzLnlUZW5zb3IgPSB5VGVuc29yO1xuICAgICAgICB2YXIgeFNpemUgPSB1dGlsLnNpemVGcm9tU2hhcGUoeFRlbnNvci5zaGFwZSk7XG4gICAgICAgIHZhciB5U2l6ZSA9IHV0aWwuc2l6ZUZyb21TaGFwZSh5VGVuc29yLnNoYXBlKTtcbiAgICAgICAgdXRpbC5hc3NlcnQoeFNpemUgPT09IHlTaXplLCBcIlRoZSBpbnB1dCBzaXplIChcIiArIHhTaXplICsgXCIpIGFuZCBvdXRwdXQgc2l6ZSAoXCIgKyB5U2l6ZSArIFwiKSBtdXN0IG1hdGNoXCIpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFJlc2hhcGUucHJvdG90eXBlLmZlZWRGb3J3YXJkID0gZnVuY3Rpb24gKG1hdGgsIGluZmVyZW5jZUFycmF5cykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgeCA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy54VGVuc29yKTtcbiAgICAgICAgdmFyIGNsb25lID0gbWF0aC5jbG9uZSh4KTtcbiAgICAgICAgbWF0aC5zY29wZShmdW5jdGlvbiAoa2VlcCkge1xuICAgICAgICAgICAgaW5mZXJlbmNlQXJyYXlzLnNldChfdGhpcy55VGVuc29yLCBrZWVwKGNsb25lLnJlc2hhcGUoX3RoaXMueVRlbnNvci5zaGFwZSkpKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBSZXNoYXBlLnByb3RvdHlwZS5iYWNrUHJvcCA9IGZ1bmN0aW9uIChtYXRoLCBpbmZlcmVuY2VBcnJheXMsIGdyYWRpZW50QXJyYXlzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBkeSA9IGdyYWRpZW50QXJyYXlzLmdldCh0aGlzLnlUZW5zb3IpO1xuICAgICAgICB2YXIgY2xvbmUgPSBtYXRoLmNsb25lKGR5KTtcbiAgICAgICAgbWF0aC5zY29wZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBncmFkaWVudEFycmF5cy5hZGQoX3RoaXMueFRlbnNvciwgY2xvbmUucmVzaGFwZShfdGhpcy54VGVuc29yLnNoYXBlKSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIFJlc2hhcGU7XG59KG9wXzEuT3BlcmF0aW9uKSk7XG5leHBvcnRzLlJlc2hhcGUgPSBSZXNoYXBlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVzaGFwZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIG5kYXJyYXlfMSA9IHJlcXVpcmUoXCIuLi8uLi9tYXRoL25kYXJyYXlcIik7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi8uLi91dGlsXCIpO1xudmFyIGdyYXBoXzEgPSByZXF1aXJlKFwiLi4vZ3JhcGhcIik7XG52YXIgb3BfMSA9IHJlcXVpcmUoXCIuL29wXCIpO1xudmFyIFNvZnRtYXggPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTb2Z0bWF4LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFNvZnRtYXgobG9naXRzVGVuc29yLCBvdXRwdXQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMubG9naXRzVGVuc29yID0gbG9naXRzVGVuc29yO1xuICAgICAgICBfdGhpcy5vdXRwdXQgPSBvdXRwdXQ7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgU29mdG1heC5wcm90b3R5cGUuZmVlZEZvcndhcmQgPSBmdW5jdGlvbiAobWF0aCwgaW5mZXJlbmNlQXJyYXlzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBsb2dpdHMgPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMubG9naXRzVGVuc29yKTtcbiAgICAgICAgcmV0dXJuIG1hdGguc2NvcGUoZnVuY3Rpb24gKGtlZXApIHtcbiAgICAgICAgICAgIGluZmVyZW5jZUFycmF5cy5zZXQoX3RoaXMub3V0cHV0LCBrZWVwKG1hdGguc29mdG1heChsb2dpdHMpKSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgU29mdG1heC5wcm90b3R5cGUuYmFja1Byb3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRocm93IEVycm9yKCdTb2Z0bWF4IGJhY2twcm9wIGlzIG5vdCB5ZXQgaW1wbGVtZW50ZWQnKTtcbiAgICB9O1xuICAgIHJldHVybiBTb2Z0bWF4O1xufShvcF8xLk9wZXJhdGlvbikpO1xuZXhwb3J0cy5Tb2Z0bWF4ID0gU29mdG1heDtcbnZhciBTb2Z0bWF4Q3Jvc3NFbnRyb3B5Q29zdCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFNvZnRtYXhDcm9zc0VudHJvcHlDb3N0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFNvZnRtYXhDcm9zc0VudHJvcHlDb3N0KGxvZ2l0c1RlbnNvciwgbGFiZWxUZW5zb3IsIHlUZW5zb3IpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMubG9naXRzVGVuc29yID0gbG9naXRzVGVuc29yO1xuICAgICAgICBfdGhpcy5sYWJlbFRlbnNvciA9IGxhYmVsVGVuc29yO1xuICAgICAgICBfdGhpcy55VGVuc29yID0geVRlbnNvcjtcbiAgICAgICAgX3RoaXMuZXBzaWxvbiA9IG5kYXJyYXlfMS5TY2FsYXIubmV3KDFlLTUpO1xuICAgICAgICBfdGhpcy5zb2Z0bWF4VGVuc29yID0gbmV3IGdyYXBoXzEuVGVuc29yKGxvZ2l0c1RlbnNvci5zaGFwZSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgU29mdG1heENyb3NzRW50cm9weUNvc3QucHJvdG90eXBlLmZlZWRGb3J3YXJkID0gZnVuY3Rpb24gKG1hdGgsIGluZmVyZW5jZUFycmF5cykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgbG9naXRzID0gaW5mZXJlbmNlQXJyYXlzLmdldCh0aGlzLmxvZ2l0c1RlbnNvcik7XG4gICAgICAgIHZhciBsYWJlbCA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy5sYWJlbFRlbnNvcik7XG4gICAgICAgIG1hdGguc2NvcGUoZnVuY3Rpb24gKGtlZXApIHtcbiAgICAgICAgICAgIHZhciBzb2Z0bWF4UmVzdWx0ID0gbWF0aC5zb2Z0bWF4KGxvZ2l0cyk7XG4gICAgICAgICAgICBpbmZlcmVuY2VBcnJheXMuc2V0KF90aGlzLnNvZnRtYXhUZW5zb3IsIGtlZXAoc29mdG1heFJlc3VsdCkpO1xuICAgICAgICAgICAgaW5mZXJlbmNlQXJyYXlzLnNldChfdGhpcy55VGVuc29yLCBrZWVwKGNyb3NzRW50cm9weUNvc3QobWF0aCwgc29mdG1heFJlc3VsdCwgbGFiZWwsIF90aGlzLmVwc2lsb24pKSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgU29mdG1heENyb3NzRW50cm9weUNvc3QucHJvdG90eXBlLmJhY2tQcm9wID0gZnVuY3Rpb24gKG1hdGgsIGluZmVyZW5jZUFycmF5cywgZ3JhZGllbnRBcnJheXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHNvZnRtYXggPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMuc29mdG1heFRlbnNvcik7XG4gICAgICAgIHZhciBsYWJlbCA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy5sYWJlbFRlbnNvcik7XG4gICAgICAgIG1hdGguc2NvcGUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZ3JhZGllbnRBcnJheXMuYWRkKF90aGlzLmxvZ2l0c1RlbnNvciwgbWF0aC5zdWJ0cmFjdChzb2Z0bWF4LCBsYWJlbCkpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFNvZnRtYXhDcm9zc0VudHJvcHlDb3N0LnByb3RvdHlwZS5kaXNwb3NlVHJhbnNpZW50QXJyYXlzID0gZnVuY3Rpb24gKGluZmVyZW5jZUFycmF5cywgZ3JhZGllbnRBcnJheXMpIHtcbiAgICAgICAgaW5mZXJlbmNlQXJyYXlzLmRpc3Bvc2VBcnJheSh0aGlzLnNvZnRtYXhUZW5zb3IpO1xuICAgIH07XG4gICAgU29mdG1heENyb3NzRW50cm9weUNvc3QucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZXBzaWxvbi5kaXNwb3NlKCk7XG4gICAgfTtcbiAgICByZXR1cm4gU29mdG1heENyb3NzRW50cm9weUNvc3Q7XG59KG9wXzEuT3BlcmF0aW9uKSk7XG5leHBvcnRzLlNvZnRtYXhDcm9zc0VudHJvcHlDb3N0ID0gU29mdG1heENyb3NzRW50cm9weUNvc3Q7XG5mdW5jdGlvbiBjcm9zc0VudHJvcHlDb3N0KG1hdGgsIHksIHRhcmdldCwgZXBzaWxvbikge1xuICAgIHV0aWwuYXNzZXJ0KHkuc2l6ZSA9PT0gdGFyZ2V0LnNpemUsICdUaGUgb3V0cHV0IGFuZCB0YXJnZXQgbXVzdCBiZSB0aGUgc2FtZSBzaXplJyk7XG4gICAgcmV0dXJuIG1hdGguc2NvcGUoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgeVBsdXNFcHMgPSBtYXRoLnNjYWxhclBsdXNBcnJheShlcHNpbG9uLCB5KTtcbiAgICAgICAgdmFyIGxvZ091dHB1dCA9IG1hdGgubG9nKHlQbHVzRXBzKTtcbiAgICAgICAgdmFyIHRhckxvZ091dHB1dCA9IG1hdGguZWxlbWVudFdpc2VNdWwodGFyZ2V0LCBsb2dPdXRwdXQpO1xuICAgICAgICB2YXIgY29zdFZlY3RvciA9IG1hdGgubmVnKHRhckxvZ091dHB1dCk7XG4gICAgICAgIHJldHVybiBtYXRoLnN1bShjb3N0VmVjdG9yKTtcbiAgICB9KTtcbn1cbmV4cG9ydHMuY3Jvc3NFbnRyb3B5Q29zdCA9IGNyb3NzRW50cm9weUNvc3Q7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zb2Z0bWF4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgbmRhcnJheV8xID0gcmVxdWlyZShcIi4uLy4uL21hdGgvbmRhcnJheVwiKTtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4uLy4uL3V0aWxcIik7XG52YXIgZ3JhcGhfdXRpbCA9IHJlcXVpcmUoXCIuLi9ncmFwaF91dGlsXCIpO1xudmFyIG9wXzEgPSByZXF1aXJlKFwiLi9vcFwiKTtcbnZhciBTdWJ0cmFjdCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFN1YnRyYWN0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFN1YnRyYWN0KHQxLCB0Miwgb3V0VGVuc29yKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnQxID0gdDE7XG4gICAgICAgIF90aGlzLnQyID0gdDI7XG4gICAgICAgIF90aGlzLm91dFRlbnNvciA9IG91dFRlbnNvcjtcbiAgICAgICAgdXRpbC5hc3NlcnQodXRpbC5zaXplRnJvbVNoYXBlKHQxLnNoYXBlKSA9PT0gMSB8fFxuICAgICAgICAgICAgdXRpbC5zaXplRnJvbVNoYXBlKHQyLnNoYXBlKSA9PT0gMSB8fFxuICAgICAgICAgICAgdXRpbC5hcnJheXNFcXVhbCh0MS5zaGFwZSwgdDIuc2hhcGUpLCAnT25lIG9mIHQxIG9yIHQyIG11c3QgYmUgYSBzY2FsYXIsIG9yIHQxIGFuZCB0MiBtdXN0IGhhdmUgJyArXG4gICAgICAgICAgICAndGhlIHNhbWUgc2hhcGUnKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBTdWJ0cmFjdC5wcm90b3R5cGUuZmVlZEZvcndhcmQgPSBmdW5jdGlvbiAobWF0aCwgaW5mZXJlbmNlQXJyYXlzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciB0MSA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy50MSk7XG4gICAgICAgIHZhciB0MiA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy50Mik7XG4gICAgICAgIG1hdGguc2NvcGUoZnVuY3Rpb24gKGtlZXApIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgICAgICBpZiAodXRpbC5pc1NjYWxhclNoYXBlKHQxLnNoYXBlKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IG1hdGguc2NhbGFyTWludXNBcnJheSh0MSwgdDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodXRpbC5pc1NjYWxhclNoYXBlKHQyLnNoYXBlKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IG1hdGguYXJyYXlNaW51c1NjYWxhcih0MSwgdDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gbWF0aC5zdWJ0cmFjdCh0MSwgdDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5mZXJlbmNlQXJyYXlzLnNldChfdGhpcy5vdXRUZW5zb3IsIGtlZXAocmVzdWx0KSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgU3VidHJhY3QucHJvdG90eXBlLmJhY2tQcm9wID0gZnVuY3Rpb24gKG1hdGgsIGluZmVyZW5jZUFycmF5cywgZ3JhZGllbnRBcnJheXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGR5ID0gZ3JhZGllbnRBcnJheXMuZ2V0KHRoaXMub3V0VGVuc29yKTtcbiAgICAgICAgbWF0aC5zY29wZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoZ3JhcGhfdXRpbC5zaG91bGRCYWNrUHJvcChfdGhpcy50MSkpIHtcbiAgICAgICAgICAgICAgICBpZiAodXRpbC5pc1NjYWxhclNoYXBlKF90aGlzLnQxLnNoYXBlKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3VtID0gbWF0aC5zdW0oZHkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuZHlTaXplU2NhbGFyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmR5U2l6ZVNjYWxhciA9IG5kYXJyYXlfMS5TY2FsYXIubmV3KGR5LnNpemUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGdyYWRpZW50QXJyYXlzLmFkZChfdGhpcy50MSwgbWF0aC5kaXZpZGUoc3VtLCBfdGhpcy5keVNpemVTY2FsYXIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGdyYWRpZW50QXJyYXlzLmFkZChfdGhpcy50MSwgbWF0aC5jbG9uZShkeSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChncmFwaF91dGlsLnNob3VsZEJhY2tQcm9wKF90aGlzLnQyKSkge1xuICAgICAgICAgICAgICAgIGlmICh1dGlsLmlzU2NhbGFyU2hhcGUoX3RoaXMudDIuc2hhcGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdW0gPSBtYXRoLnN1bShkeSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZWdTdW0gPSBtYXRoLm5lZyhzdW0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuZHlTaXplU2NhbGFyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmR5U2l6ZVNjYWxhciA9IG5kYXJyYXlfMS5TY2FsYXIubmV3KGR5LnNpemUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGdyYWRpZW50QXJyYXlzLmFkZChfdGhpcy50MiwgbWF0aC5kaXZpZGUobmVnU3VtLCBfdGhpcy5keVNpemVTY2FsYXIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGdyYWRpZW50QXJyYXlzLmFkZChfdGhpcy50MiwgbWF0aC5uZWcoZHkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgU3VidHJhY3QucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmR5U2l6ZVNjYWxhciAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmR5U2l6ZVNjYWxhci5kaXNwb3NlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBTdWJ0cmFjdDtcbn0ob3BfMS5PcGVyYXRpb24pKTtcbmV4cG9ydHMuU3VidHJhY3QgPSBTdWJ0cmFjdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN1YnRyYWN0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgbmRhcnJheV8xID0gcmVxdWlyZShcIi4uLy4uL21hdGgvbmRhcnJheVwiKTtcbnZhciB0ZW5zb3JfYXJyYXlfbWFwXzEgPSByZXF1aXJlKFwiLi4vdGVuc29yX2FycmF5X21hcFwiKTtcbnZhciBvcHRpbWl6ZXJfMSA9IHJlcXVpcmUoXCIuL29wdGltaXplclwiKTtcbnZhciBBZGFkZWx0YU9wdGltaXplciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFkYWRlbHRhT3B0aW1pemVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEFkYWRlbHRhT3B0aW1pemVyKGxlYXJuaW5nUmF0ZSwgZ2FtbWEsIHNwZWNpZmllZFZhcmlhYmxlTGlzdCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBsZWFybmluZ1JhdGUsIHNwZWNpZmllZFZhcmlhYmxlTGlzdCkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMubGVhcm5pbmdSYXRlID0gbGVhcm5pbmdSYXRlO1xuICAgICAgICBfdGhpcy5nYW1tYSA9IGdhbW1hO1xuICAgICAgICBfdGhpcy5hY2N1bXVsYXRlZFNxdWFyZWRHcmFkaWVudHMgPSBuZXcgdGVuc29yX2FycmF5X21hcF8xLlRlbnNvckFycmF5TWFwKCk7XG4gICAgICAgIF90aGlzLmFjY3VtdWxhdGVkVXBkYXRlcyA9IG5ldyB0ZW5zb3JfYXJyYXlfbWFwXzEuVGVuc29yQXJyYXlNYXAoKTtcbiAgICAgICAgX3RoaXMuZXBzID0gbmRhcnJheV8xLlNjYWxhci5uZXcoMWUtNik7XG4gICAgICAgIF90aGlzLmcgPSBuZGFycmF5XzEuU2NhbGFyLm5ldyhfdGhpcy5nYW1tYSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgQWRhZGVsdGFPcHRpbWl6ZXIucHJvdG90eXBlLmJlZm9yZUJhdGNoID0gZnVuY3Rpb24gKG1hdGgsIGJhdGNoU2l6ZSwgcnVudGltZSwgYWN0aXZhdGlvbkFycmF5TWFwLCBncmFkaWVudEFycmF5TWFwKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuYmVmb3JlQmF0Y2guY2FsbCh0aGlzLCBtYXRoLCBiYXRjaFNpemUsIHJ1bnRpbWUsIGFjdGl2YXRpb25BcnJheU1hcCwgZ3JhZGllbnRBcnJheU1hcCk7XG4gICAgICAgIGlmICh0aGlzLmFjY3VtdWxhdGVkU3F1YXJlZEdyYWRpZW50cy5zaXplKCkgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMudmFyaWFibGVOb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuYWNjdW11bGF0ZWRTcXVhcmVkR3JhZGllbnRzLnNldChub2RlLm91dHB1dCwgbmRhcnJheV8xLk5EQXJyYXkuemVyb3Mobm9kZS5vdXRwdXQuc2hhcGUpKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5hY2N1bXVsYXRlZFVwZGF0ZXMuc2V0KG5vZGUub3V0cHV0LCBuZGFycmF5XzEuTkRBcnJheS56ZXJvcyhub2RlLm91dHB1dC5zaGFwZSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEFkYWRlbHRhT3B0aW1pemVyLnByb3RvdHlwZS5hZnRlckJhdGNoID0gZnVuY3Rpb24gKG1hdGgsIGJhdGNoU2l6ZSwgcnVudGltZSwgYWN0aXZhdGlvbkFycmF5TWFwLCBncmFkaWVudEFycmF5TWFwKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIG1hdGguc2NvcGUoZnVuY3Rpb24gKGtlZXApIHtcbiAgICAgICAgICAgIF90aGlzLnZhcmlhYmxlTm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgIHZhciBvbGRWYXJpYWJsZSA9IGFjdGl2YXRpb25BcnJheU1hcC5nZXQobm9kZS5vdXRwdXQpO1xuICAgICAgICAgICAgICAgIHZhciBncmFkaWVudCA9IF90aGlzLnZhcmlhYmxlR3JhZGllbnRzLmdldChub2RlLm91dHB1dCk7XG4gICAgICAgICAgICAgICAgdmFyIG9sZENhY2hlID0gX3RoaXMuYWNjdW11bGF0ZWRTcXVhcmVkR3JhZGllbnRzLmdldChub2RlLm91dHB1dCk7XG4gICAgICAgICAgICAgICAgdmFyIG9sZFVwZGF0ZXMgPSBfdGhpcy5hY2N1bXVsYXRlZFVwZGF0ZXMuZ2V0KG5vZGUub3V0cHV0KTtcbiAgICAgICAgICAgICAgICB2YXIgZ3JhZGllbnRTcXVhcmUgPSBtYXRoLm11bHRpcGx5KGdyYWRpZW50LCBncmFkaWVudCk7XG4gICAgICAgICAgICAgICAgdmFyIGNhY2hlID0gbWF0aC5zY2FsZWRBcnJheUFkZChfdGhpcy5nLCBvbGRDYWNoZSwgbWF0aC5zdWJ0cmFjdChfdGhpcy5vbmUsIF90aGlzLmcpLCBncmFkaWVudFNxdWFyZSk7XG4gICAgICAgICAgICAgICAgdmFyIHVwZGF0ZXMgPSBtYXRoLm11bHRpcGx5KG1hdGguZGl2aWRlKG1hdGguc3FydChtYXRoLmFkZChvbGRVcGRhdGVzLCBfdGhpcy5lcHMpKSwgbWF0aC5zcXJ0KG1hdGguYWRkKG9sZENhY2hlLCBfdGhpcy5lcHMpKSksIGdyYWRpZW50KTtcbiAgICAgICAgICAgICAgICB2YXIgdmFyaWFibGUgPSBtYXRoLnNjYWxlZEFycmF5QWRkKF90aGlzLmMsIHVwZGF0ZXMsIF90aGlzLm9uZSwgb2xkVmFyaWFibGUpO1xuICAgICAgICAgICAgICAgIHZhciB1cGRhdGVTcXVhcmUgPSBtYXRoLm11bHRpcGx5KHVwZGF0ZXMsIHVwZGF0ZXMpO1xuICAgICAgICAgICAgICAgIHZhciBuZXdVcGRhdGVzID0gbWF0aC5zY2FsZWRBcnJheUFkZChfdGhpcy5nLCBvbGRVcGRhdGVzLCBtYXRoLnN1YnRyYWN0KF90aGlzLm9uZSwgX3RoaXMuZyksIHVwZGF0ZVNxdWFyZSk7XG4gICAgICAgICAgICAgICAgX3RoaXMuYWNjdW11bGF0ZWRTcXVhcmVkR3JhZGllbnRzLnNldChub2RlLm91dHB1dCwga2VlcChjYWNoZSkpO1xuICAgICAgICAgICAgICAgIF90aGlzLmFjY3VtdWxhdGVkVXBkYXRlcy5zZXQobm9kZS5vdXRwdXQsIGtlZXAobmV3VXBkYXRlcykpO1xuICAgICAgICAgICAgICAgIGFjdGl2YXRpb25BcnJheU1hcC5zZXQobm9kZS5vdXRwdXQsIGtlZXAodmFyaWFibGUpKTtcbiAgICAgICAgICAgICAgICBub2RlLmRhdGEgPSB2YXJpYWJsZTtcbiAgICAgICAgICAgICAgICBvbGRWYXJpYWJsZS5kaXNwb3NlKCk7XG4gICAgICAgICAgICAgICAgb2xkQ2FjaGUuZGlzcG9zZSgpO1xuICAgICAgICAgICAgICAgIG9sZFVwZGF0ZXMuZGlzcG9zZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnZhcmlhYmxlR3JhZGllbnRzLmRpc3Bvc2UoKTtcbiAgICAgICAgdGhpcy52YXJpYWJsZUdyYWRpZW50cyA9IG5ldyB0ZW5zb3JfYXJyYXlfbWFwXzEuVGVuc29yQXJyYXlNYXAoKTtcbiAgICB9O1xuICAgIEFkYWRlbHRhT3B0aW1pemVyLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5lcHMuZGlzcG9zZSgpO1xuICAgICAgICB0aGlzLmcuZGlzcG9zZSgpO1xuICAgICAgICB0aGlzLmFjY3VtdWxhdGVkU3F1YXJlZEdyYWRpZW50cy5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMuYWNjdW11bGF0ZWRVcGRhdGVzLmRpc3Bvc2UoKTtcbiAgICB9O1xuICAgIHJldHVybiBBZGFkZWx0YU9wdGltaXplcjtcbn0ob3B0aW1pemVyXzEuT3B0aW1pemVyKSk7XG5leHBvcnRzLkFkYWRlbHRhT3B0aW1pemVyID0gQWRhZGVsdGFPcHRpbWl6ZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hZGFkZWx0YV9vcHRpbWl6ZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBuZGFycmF5XzEgPSByZXF1aXJlKFwiLi4vLi4vbWF0aC9uZGFycmF5XCIpO1xudmFyIHRlbnNvcl9hcnJheV9tYXBfMSA9IHJlcXVpcmUoXCIuLi90ZW5zb3JfYXJyYXlfbWFwXCIpO1xudmFyIG9wdGltaXplcl8xID0gcmVxdWlyZShcIi4vb3B0aW1pemVyXCIpO1xudmFyIEFkYWdyYWRPcHRpbWl6ZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhBZGFncmFkT3B0aW1pemVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEFkYWdyYWRPcHRpbWl6ZXIobGVhcm5pbmdSYXRlLCBzcGVjaWZpZWRWYXJpYWJsZUxpc3QpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbGVhcm5pbmdSYXRlLCBzcGVjaWZpZWRWYXJpYWJsZUxpc3QpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmxlYXJuaW5nUmF0ZSA9IGxlYXJuaW5nUmF0ZTtcbiAgICAgICAgX3RoaXMuYWNjdW11bGF0ZWRTcXVhcmVkR3JhZGllbnRzID0gbmV3IHRlbnNvcl9hcnJheV9tYXBfMS5UZW5zb3JBcnJheU1hcCgpO1xuICAgICAgICBfdGhpcy5lcHMgPSBuZGFycmF5XzEuU2NhbGFyLm5ldygxZS02KTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBBZGFncmFkT3B0aW1pemVyLnByb3RvdHlwZS5iZWZvcmVCYXRjaCA9IGZ1bmN0aW9uIChtYXRoLCBiYXRjaFNpemUsIHJ1bnRpbWUsIGFjdGl2YXRpb25BcnJheU1hcCwgZ3JhZGllbnRBcnJheU1hcCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLmJlZm9yZUJhdGNoLmNhbGwodGhpcywgbWF0aCwgYmF0Y2hTaXplLCBydW50aW1lLCBhY3RpdmF0aW9uQXJyYXlNYXAsIGdyYWRpZW50QXJyYXlNYXApO1xuICAgICAgICBpZiAodGhpcy5hY2N1bXVsYXRlZFNxdWFyZWRHcmFkaWVudHMuc2l6ZSgpID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLnZhcmlhYmxlTm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgIF90aGlzLmFjY3VtdWxhdGVkU3F1YXJlZEdyYWRpZW50cy5zZXQobm9kZS5vdXRwdXQsIG5kYXJyYXlfMS5OREFycmF5Lnplcm9zKG5vZGUub3V0cHV0LnNoYXBlKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQWRhZ3JhZE9wdGltaXplci5wcm90b3R5cGUuYWZ0ZXJCYXRjaCA9IGZ1bmN0aW9uIChtYXRoLCBiYXRjaFNpemUsIHJ1bnRpbWUsIGFjdGl2YXRpb25BcnJheU1hcCwgZ3JhZGllbnRBcnJheU1hcCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBtYXRoLnNjb3BlKGZ1bmN0aW9uIChrZWVwKSB7XG4gICAgICAgICAgICBfdGhpcy52YXJpYWJsZU5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgb2xkVmFyaWFibGUgPSBhY3RpdmF0aW9uQXJyYXlNYXAuZ2V0KG5vZGUub3V0cHV0KTtcbiAgICAgICAgICAgICAgICB2YXIgZ3JhZGllbnQgPSBfdGhpcy52YXJpYWJsZUdyYWRpZW50cy5nZXQobm9kZS5vdXRwdXQpO1xuICAgICAgICAgICAgICAgIHZhciBvbGRDYWNoZSA9IF90aGlzLmFjY3VtdWxhdGVkU3F1YXJlZEdyYWRpZW50cy5nZXQobm9kZS5vdXRwdXQpO1xuICAgICAgICAgICAgICAgIHZhciBncmFkaWVudFNxdWFyZSA9IG1hdGgubXVsdGlwbHkoZ3JhZGllbnQsIGdyYWRpZW50KTtcbiAgICAgICAgICAgICAgICB2YXIgY2FjaGUgPSBtYXRoLmFkZChvbGRDYWNoZSwgZ3JhZGllbnRTcXVhcmUpO1xuICAgICAgICAgICAgICAgIHZhciB2YXJpYWJsZSA9IG1hdGguc2NhbGVkQXJyYXlBZGQoX3RoaXMuYywgbWF0aC5kaXZpZGUoZ3JhZGllbnQsIG1hdGguYWRkKG1hdGguc3FydChjYWNoZSksIF90aGlzLmVwcykpLCBfdGhpcy5vbmUsIG9sZFZhcmlhYmxlKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5hY2N1bXVsYXRlZFNxdWFyZWRHcmFkaWVudHMuc2V0KG5vZGUub3V0cHV0LCBrZWVwKGNhY2hlKSk7XG4gICAgICAgICAgICAgICAgYWN0aXZhdGlvbkFycmF5TWFwLnNldChub2RlLm91dHB1dCwga2VlcCh2YXJpYWJsZSkpO1xuICAgICAgICAgICAgICAgIG5vZGUuZGF0YSA9IHZhcmlhYmxlO1xuICAgICAgICAgICAgICAgIG9sZFZhcmlhYmxlLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgICAgICBvbGRDYWNoZS5kaXNwb3NlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudmFyaWFibGVHcmFkaWVudHMuZGlzcG9zZSgpO1xuICAgICAgICB0aGlzLnZhcmlhYmxlR3JhZGllbnRzID0gbmV3IHRlbnNvcl9hcnJheV9tYXBfMS5UZW5zb3JBcnJheU1hcCgpO1xuICAgIH07XG4gICAgQWRhZ3JhZE9wdGltaXplci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuZXBzLmRpc3Bvc2UoKTtcbiAgICAgICAgdGhpcy5hY2N1bXVsYXRlZFNxdWFyZWRHcmFkaWVudHMuZGlzcG9zZSgpO1xuICAgIH07XG4gICAgcmV0dXJuIEFkYWdyYWRPcHRpbWl6ZXI7XG59KG9wdGltaXplcl8xLk9wdGltaXplcikpO1xuZXhwb3J0cy5BZGFncmFkT3B0aW1pemVyID0gQWRhZ3JhZE9wdGltaXplcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFkYWdyYWRfb3B0aW1pemVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgbmRhcnJheV8xID0gcmVxdWlyZShcIi4uLy4uL21hdGgvbmRhcnJheVwiKTtcbnZhciB0ZW5zb3JfYXJyYXlfbWFwXzEgPSByZXF1aXJlKFwiLi4vdGVuc29yX2FycmF5X21hcFwiKTtcbnZhciBvcHRpbWl6ZXJfMSA9IHJlcXVpcmUoXCIuL29wdGltaXplclwiKTtcbnZhciBBZGFtT3B0aW1pemVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQWRhbU9wdGltaXplciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBZGFtT3B0aW1pemVyKGxlYXJuaW5nUmF0ZSwgYmV0YTEsIGJldGEyLCBzcGVjaWZpZWRWYXJpYWJsZUxpc3QpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbGVhcm5pbmdSYXRlLCBzcGVjaWZpZWRWYXJpYWJsZUxpc3QpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmxlYXJuaW5nUmF0ZSA9IGxlYXJuaW5nUmF0ZTtcbiAgICAgICAgX3RoaXMuYmV0YTEgPSBiZXRhMTtcbiAgICAgICAgX3RoaXMuYmV0YTIgPSBiZXRhMjtcbiAgICAgICAgX3RoaXMuZmlyc3RNb21lbnQgPSBuZXcgdGVuc29yX2FycmF5X21hcF8xLlRlbnNvckFycmF5TWFwKCk7XG4gICAgICAgIF90aGlzLnNlY29uZE1vbWVudCA9IG5ldyB0ZW5zb3JfYXJyYXlfbWFwXzEuVGVuc29yQXJyYXlNYXAoKTtcbiAgICAgICAgX3RoaXMuZXBzID0gbmRhcnJheV8xLlNjYWxhci5uZXcoMWUtOCk7XG4gICAgICAgIF90aGlzLmIxID0gbmRhcnJheV8xLlNjYWxhci5uZXcoX3RoaXMuYmV0YTEpO1xuICAgICAgICBfdGhpcy5iMiA9IG5kYXJyYXlfMS5TY2FsYXIubmV3KF90aGlzLmJldGEyKTtcbiAgICAgICAgX3RoaXMuYWNjQjEgPSBuZGFycmF5XzEuU2NhbGFyLm5ldyhfdGhpcy5iZXRhMSk7XG4gICAgICAgIF90aGlzLmFjY0IyID0gbmRhcnJheV8xLlNjYWxhci5uZXcoX3RoaXMuYmV0YTIpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEFkYW1PcHRpbWl6ZXIucHJvdG90eXBlLmJlZm9yZUJhdGNoID0gZnVuY3Rpb24gKG1hdGgsIGJhdGNoU2l6ZSwgcnVudGltZSwgYWN0aXZhdGlvbkFycmF5TWFwLCBncmFkaWVudEFycmF5TWFwKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuYmVmb3JlQmF0Y2guY2FsbCh0aGlzLCBtYXRoLCBiYXRjaFNpemUsIHJ1bnRpbWUsIGFjdGl2YXRpb25BcnJheU1hcCwgZ3JhZGllbnRBcnJheU1hcCk7XG4gICAgICAgIGlmICh0aGlzLmZpcnN0TW9tZW50LnNpemUoKSA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy52YXJpYWJsZU5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5maXJzdE1vbWVudC5zZXQobm9kZS5vdXRwdXQsIG5kYXJyYXlfMS5OREFycmF5Lnplcm9zKG5vZGUub3V0cHV0LnNoYXBlKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zZWNvbmRNb21lbnQuc2l6ZSgpID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLnZhcmlhYmxlTm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgIF90aGlzLnNlY29uZE1vbWVudC5zZXQobm9kZS5vdXRwdXQsIG5kYXJyYXlfMS5OREFycmF5Lnplcm9zKG5vZGUub3V0cHV0LnNoYXBlKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQWRhbU9wdGltaXplci5wcm90b3R5cGUuYWZ0ZXJCYXRjaCA9IGZ1bmN0aW9uIChtYXRoLCBiYXRjaFNpemUsIHJ1bnRpbWUsIGFjdGl2YXRpb25BcnJheU1hcCwgZ3JhZGllbnRBcnJheU1hcCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBtYXRoLnNjb3BlKGZ1bmN0aW9uIChrZWVwKSB7XG4gICAgICAgICAgICBfdGhpcy52YXJpYWJsZU5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgb2xkVmFyaWFibGUgPSBhY3RpdmF0aW9uQXJyYXlNYXAuZ2V0KG5vZGUub3V0cHV0KTtcbiAgICAgICAgICAgICAgICB2YXIgZ3JhZGllbnQgPSBfdGhpcy52YXJpYWJsZUdyYWRpZW50cy5nZXQobm9kZS5vdXRwdXQpO1xuICAgICAgICAgICAgICAgIHZhciBvbGRGaXJzdE1vbWVudCA9IF90aGlzLmZpcnN0TW9tZW50LmdldChub2RlLm91dHB1dCk7XG4gICAgICAgICAgICAgICAgdmFyIG9sZFNlY29uZE1vbWVudCA9IF90aGlzLnNlY29uZE1vbWVudC5nZXQobm9kZS5vdXRwdXQpO1xuICAgICAgICAgICAgICAgIHZhciBuZXdGaXJzdE1vbWVudCA9IG1hdGguc2NhbGVkQXJyYXlBZGQoX3RoaXMuYjEsIG9sZEZpcnN0TW9tZW50LCBtYXRoLnN1YnRyYWN0KF90aGlzLm9uZSwgX3RoaXMuYjEpLCBncmFkaWVudCk7XG4gICAgICAgICAgICAgICAgdmFyIGdyYWRpZW50U3F1YXJlID0gbWF0aC5tdWx0aXBseShncmFkaWVudCwgZ3JhZGllbnQpO1xuICAgICAgICAgICAgICAgIHZhciBuZXdTZWNvbmRNb21lbnQgPSBtYXRoLnNjYWxlZEFycmF5QWRkKF90aGlzLmIyLCBvbGRTZWNvbmRNb21lbnQsIG1hdGguc3VidHJhY3QoX3RoaXMub25lLCBfdGhpcy5iMiksIGdyYWRpZW50U3F1YXJlKTtcbiAgICAgICAgICAgICAgICB2YXIgYmlhc0NvcnJlY3RlZEZpcnN0TW9tZW50ID0gbWF0aC5kaXZpZGUobmV3Rmlyc3RNb21lbnQsIG1hdGguc3VidHJhY3QoX3RoaXMub25lLCBfdGhpcy5hY2NCMSkpO1xuICAgICAgICAgICAgICAgIHZhciBiaWFzQ29ycmVjdGVkU2Vjb25kTW9tZW50ID0gbWF0aC5kaXZpZGUobmV3U2Vjb25kTW9tZW50LCBtYXRoLnN1YnRyYWN0KF90aGlzLm9uZSwgX3RoaXMuYWNjQjIpKTtcbiAgICAgICAgICAgICAgICB2YXIgdmFyaWFibGUgPSBtYXRoLnNjYWxlZEFycmF5QWRkKF90aGlzLmMsIG1hdGguZGl2aWRlKGJpYXNDb3JyZWN0ZWRGaXJzdE1vbWVudCwgbWF0aC5hZGQobWF0aC5zcXJ0KGJpYXNDb3JyZWN0ZWRTZWNvbmRNb21lbnQpLCBfdGhpcy5lcHMpKSwgX3RoaXMub25lLCBvbGRWYXJpYWJsZSk7XG4gICAgICAgICAgICAgICAgYWN0aXZhdGlvbkFycmF5TWFwLnNldChub2RlLm91dHB1dCwga2VlcCh2YXJpYWJsZSkpO1xuICAgICAgICAgICAgICAgIG5vZGUuZGF0YSA9IHZhcmlhYmxlO1xuICAgICAgICAgICAgICAgIF90aGlzLmZpcnN0TW9tZW50LnNldChub2RlLm91dHB1dCwga2VlcChuZXdGaXJzdE1vbWVudCkpO1xuICAgICAgICAgICAgICAgIF90aGlzLnNlY29uZE1vbWVudC5zZXQobm9kZS5vdXRwdXQsIGtlZXAobmV3U2Vjb25kTW9tZW50KSk7XG4gICAgICAgICAgICAgICAgb2xkVmFyaWFibGUuZGlzcG9zZSgpO1xuICAgICAgICAgICAgICAgIGdyYWRpZW50LmRpc3Bvc2UoKTtcbiAgICAgICAgICAgICAgICBvbGRGaXJzdE1vbWVudC5kaXNwb3NlKCk7XG4gICAgICAgICAgICAgICAgb2xkU2Vjb25kTW9tZW50LmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIG9sZEFjY0IxID0gX3RoaXMuYWNjQjE7XG4gICAgICAgICAgICB2YXIgb2xkQWNjQjIgPSBfdGhpcy5hY2NCMjtcbiAgICAgICAgICAgIF90aGlzLmFjY0IxID0ga2VlcChtYXRoLm11bHRpcGx5KF90aGlzLmFjY0IxLCBfdGhpcy5iMSkpO1xuICAgICAgICAgICAgX3RoaXMuYWNjQjIgPSBrZWVwKG1hdGgubXVsdGlwbHkoX3RoaXMuYWNjQjIsIF90aGlzLmIyKSk7XG4gICAgICAgICAgICBvbGRBY2NCMS5kaXNwb3NlKCk7XG4gICAgICAgICAgICBvbGRBY2NCMi5kaXNwb3NlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnZhcmlhYmxlR3JhZGllbnRzLmRpc3Bvc2UoKTtcbiAgICAgICAgdGhpcy52YXJpYWJsZUdyYWRpZW50cyA9IG5ldyB0ZW5zb3JfYXJyYXlfbWFwXzEuVGVuc29yQXJyYXlNYXAoKTtcbiAgICB9O1xuICAgIEFkYW1PcHRpbWl6ZXIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLmZpcnN0TW9tZW50LmRpc3Bvc2UoKTtcbiAgICAgICAgdGhpcy5zZWNvbmRNb21lbnQuZGlzcG9zZSgpO1xuICAgICAgICB0aGlzLmVwcy5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMuYjEuZGlzcG9zZSgpO1xuICAgICAgICB0aGlzLmIyLmRpc3Bvc2UoKTtcbiAgICAgICAgdGhpcy5hY2NCMS5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMuYWNjQjIuZGlzcG9zZSgpO1xuICAgIH07XG4gICAgcmV0dXJuIEFkYW1PcHRpbWl6ZXI7XG59KG9wdGltaXplcl8xLk9wdGltaXplcikpO1xuZXhwb3J0cy5BZGFtT3B0aW1pemVyID0gQWRhbU9wdGltaXplcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFkYW1fb3B0aW1pemVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgbmRhcnJheV8xID0gcmVxdWlyZShcIi4uLy4uL21hdGgvbmRhcnJheVwiKTtcbnZhciB0ZW5zb3JfYXJyYXlfbWFwXzEgPSByZXF1aXJlKFwiLi4vdGVuc29yX2FycmF5X21hcFwiKTtcbnZhciBvcHRpbWl6ZXJfMSA9IHJlcXVpcmUoXCIuL29wdGltaXplclwiKTtcbnZhciBBZGFtYXhPcHRpbWl6ZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhBZGFtYXhPcHRpbWl6ZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQWRhbWF4T3B0aW1pemVyKGxlYXJuaW5nUmF0ZSwgYmV0YTEsIGJldGEyLCBzcGVjaWZpZWRWYXJpYWJsZUxpc3QpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbGVhcm5pbmdSYXRlLCBzcGVjaWZpZWRWYXJpYWJsZUxpc3QpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmxlYXJuaW5nUmF0ZSA9IGxlYXJuaW5nUmF0ZTtcbiAgICAgICAgX3RoaXMuYmV0YTEgPSBiZXRhMTtcbiAgICAgICAgX3RoaXMuYmV0YTIgPSBiZXRhMjtcbiAgICAgICAgX3RoaXMuZmlyc3RNb21lbnQgPSBuZXcgdGVuc29yX2FycmF5X21hcF8xLlRlbnNvckFycmF5TWFwKCk7XG4gICAgICAgIF90aGlzLndlaWdodGVkSW5mTm9ybSA9IG5ldyB0ZW5zb3JfYXJyYXlfbWFwXzEuVGVuc29yQXJyYXlNYXAoKTtcbiAgICAgICAgX3RoaXMuZXBzID0gbmRhcnJheV8xLlNjYWxhci5uZXcoMWUtOCk7XG4gICAgICAgIF90aGlzLmIxID0gbmRhcnJheV8xLlNjYWxhci5uZXcoX3RoaXMuYmV0YTEpO1xuICAgICAgICBfdGhpcy5iMiA9IG5kYXJyYXlfMS5TY2FsYXIubmV3KF90aGlzLmJldGEyKTtcbiAgICAgICAgX3RoaXMuYWNjQjEgPSBuZGFycmF5XzEuU2NhbGFyLm5ldyhfdGhpcy5iZXRhMSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgQWRhbWF4T3B0aW1pemVyLnByb3RvdHlwZS5iZWZvcmVCYXRjaCA9IGZ1bmN0aW9uIChtYXRoLCBiYXRjaFNpemUsIHJ1bnRpbWUsIGFjdGl2YXRpb25BcnJheU1hcCwgZ3JhZGllbnRBcnJheU1hcCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLmJlZm9yZUJhdGNoLmNhbGwodGhpcywgbWF0aCwgYmF0Y2hTaXplLCBydW50aW1lLCBhY3RpdmF0aW9uQXJyYXlNYXAsIGdyYWRpZW50QXJyYXlNYXApO1xuICAgICAgICBpZiAodGhpcy5maXJzdE1vbWVudC5zaXplKCkgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMudmFyaWFibGVOb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuZmlyc3RNb21lbnQuc2V0KG5vZGUub3V0cHV0LCBuZGFycmF5XzEuTkRBcnJheS56ZXJvcyhub2RlLm91dHB1dC5zaGFwZSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMud2VpZ2h0ZWRJbmZOb3JtLnNpemUoKSA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy52YXJpYWJsZU5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy53ZWlnaHRlZEluZk5vcm0uc2V0KG5vZGUub3V0cHV0LCBuZGFycmF5XzEuTkRBcnJheS56ZXJvcyhub2RlLm91dHB1dC5zaGFwZSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEFkYW1heE9wdGltaXplci5wcm90b3R5cGUuYWZ0ZXJCYXRjaCA9IGZ1bmN0aW9uIChtYXRoLCBiYXRjaFNpemUsIHJ1bnRpbWUsIGFjdGl2YXRpb25BcnJheU1hcCwgZ3JhZGllbnRBcnJheU1hcCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBtYXRoLnNjb3BlKGZ1bmN0aW9uIChrZWVwKSB7XG4gICAgICAgICAgICBfdGhpcy52YXJpYWJsZU5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgb2xkVmFyaWFibGUgPSBhY3RpdmF0aW9uQXJyYXlNYXAuZ2V0KG5vZGUub3V0cHV0KTtcbiAgICAgICAgICAgICAgICB2YXIgZ3JhZGllbnQgPSBfdGhpcy52YXJpYWJsZUdyYWRpZW50cy5nZXQobm9kZS5vdXRwdXQpO1xuICAgICAgICAgICAgICAgIHZhciBvbGRGaXJzdE1vbWVudCA9IF90aGlzLmZpcnN0TW9tZW50LmdldChub2RlLm91dHB1dCk7XG4gICAgICAgICAgICAgICAgdmFyIG9sZFdlaWdodGVkSW5mTm9ybSA9IF90aGlzLndlaWdodGVkSW5mTm9ybS5nZXQobm9kZS5vdXRwdXQpO1xuICAgICAgICAgICAgICAgIHZhciBuZXdGaXJzdE1vbWVudCA9IG1hdGguc2NhbGVkQXJyYXlBZGQoX3RoaXMuYjEsIG9sZEZpcnN0TW9tZW50LCBtYXRoLnN1YnRyYWN0KF90aGlzLm9uZSwgX3RoaXMuYjEpLCBncmFkaWVudCk7XG4gICAgICAgICAgICAgICAgdmFyIHV0MCA9IG1hdGgubXVsdGlwbHkoX3RoaXMuYjIsIG9sZFdlaWdodGVkSW5mTm9ybSk7XG4gICAgICAgICAgICAgICAgdmFyIHV0MSA9IG1hdGguYWJzKGdyYWRpZW50KTtcbiAgICAgICAgICAgICAgICB2YXIgbmV3V2VpZ2h0ZWRJbmZOb3JtID0gbWF0aC5hZGQobWF0aC5yZWx1KG1hdGguc3VidHJhY3QodXQwLCB1dDEpKSwgdXQxKTtcbiAgICAgICAgICAgICAgICB2YXIgdmFyaWFibGUgPSBtYXRoLnNjYWxlZEFycmF5QWRkKF90aGlzLm9uZSwgb2xkVmFyaWFibGUsIG1hdGguZGl2aWRlKF90aGlzLmMsIG1hdGguc3VidHJhY3QoX3RoaXMub25lLCBfdGhpcy5hY2NCMSkpLCBtYXRoLmRpdmlkZShuZXdGaXJzdE1vbWVudCwgbWF0aC5hZGQoX3RoaXMuZXBzLCBuZXdXZWlnaHRlZEluZk5vcm0pKSk7XG4gICAgICAgICAgICAgICAgYWN0aXZhdGlvbkFycmF5TWFwLnNldChub2RlLm91dHB1dCwga2VlcCh2YXJpYWJsZSkpO1xuICAgICAgICAgICAgICAgIG5vZGUuZGF0YSA9IHZhcmlhYmxlO1xuICAgICAgICAgICAgICAgIF90aGlzLmZpcnN0TW9tZW50LnNldChub2RlLm91dHB1dCwga2VlcChuZXdGaXJzdE1vbWVudCkpO1xuICAgICAgICAgICAgICAgIF90aGlzLndlaWdodGVkSW5mTm9ybS5zZXQobm9kZS5vdXRwdXQsIGtlZXAobmV3V2VpZ2h0ZWRJbmZOb3JtKSk7XG4gICAgICAgICAgICAgICAgb2xkVmFyaWFibGUuZGlzcG9zZSgpO1xuICAgICAgICAgICAgICAgIGdyYWRpZW50LmRpc3Bvc2UoKTtcbiAgICAgICAgICAgICAgICBvbGRGaXJzdE1vbWVudC5kaXNwb3NlKCk7XG4gICAgICAgICAgICAgICAgb2xkV2VpZ2h0ZWRJbmZOb3JtLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIG9sZEFjY0IxID0gX3RoaXMuYWNjQjE7XG4gICAgICAgICAgICBfdGhpcy5hY2NCMSA9IGtlZXAobWF0aC5tdWx0aXBseShfdGhpcy5hY2NCMSwgX3RoaXMuYjEpKTtcbiAgICAgICAgICAgIG9sZEFjY0IxLmRpc3Bvc2UoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudmFyaWFibGVHcmFkaWVudHMuZGlzcG9zZSgpO1xuICAgICAgICB0aGlzLnZhcmlhYmxlR3JhZGllbnRzID0gbmV3IHRlbnNvcl9hcnJheV9tYXBfMS5UZW5zb3JBcnJheU1hcCgpO1xuICAgIH07XG4gICAgQWRhbWF4T3B0aW1pemVyLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5maXJzdE1vbWVudC5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMud2VpZ2h0ZWRJbmZOb3JtLmRpc3Bvc2UoKTtcbiAgICAgICAgdGhpcy5lcHMuZGlzcG9zZSgpO1xuICAgICAgICB0aGlzLmFjY0IxLmRpc3Bvc2UoKTtcbiAgICAgICAgdGhpcy5iMS5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMuYjIuZGlzcG9zZSgpO1xuICAgIH07XG4gICAgcmV0dXJuIEFkYW1heE9wdGltaXplcjtcbn0ob3B0aW1pemVyXzEuT3B0aW1pemVyKSk7XG5leHBvcnRzLkFkYW1heE9wdGltaXplciA9IEFkYW1heE9wdGltaXplcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFkYW1heF9vcHRpbWl6ZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBuZGFycmF5XzEgPSByZXF1aXJlKFwiLi4vLi4vbWF0aC9uZGFycmF5XCIpO1xudmFyIHRlbnNvcl9hcnJheV9tYXBfMSA9IHJlcXVpcmUoXCIuLi90ZW5zb3JfYXJyYXlfbWFwXCIpO1xudmFyIHNnZF9vcHRpbWl6ZXJfMSA9IHJlcXVpcmUoXCIuL3NnZF9vcHRpbWl6ZXJcIik7XG52YXIgTW9tZW50dW1PcHRpbWl6ZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNb21lbnR1bU9wdGltaXplciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNb21lbnR1bU9wdGltaXplcihsZWFybmluZ1JhdGUsIG1vbWVudHVtLCBzcGVjaWZpZWRWYXJpYWJsZUxpc3QpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbGVhcm5pbmdSYXRlLCBzcGVjaWZpZWRWYXJpYWJsZUxpc3QpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmxlYXJuaW5nUmF0ZSA9IGxlYXJuaW5nUmF0ZTtcbiAgICAgICAgX3RoaXMubW9tZW50dW0gPSBtb21lbnR1bTtcbiAgICAgICAgX3RoaXMudmFyaWFibGVWZWxvY2l0aWVzID0gbmV3IHRlbnNvcl9hcnJheV9tYXBfMS5UZW5zb3JBcnJheU1hcCgpO1xuICAgICAgICBfdGhpcy5tID0gbmRhcnJheV8xLlNjYWxhci5uZXcoX3RoaXMubW9tZW50dW0pO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE1vbWVudHVtT3B0aW1pemVyLnByb3RvdHlwZS5iZWZvcmVCYXRjaCA9IGZ1bmN0aW9uIChtYXRoLCBiYXRjaFNpemUsIHJ1bnRpbWUsIGFjdGl2YXRpb25BcnJheU1hcCwgZ3JhZGllbnRBcnJheU1hcCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLmJlZm9yZUJhdGNoLmNhbGwodGhpcywgbWF0aCwgYmF0Y2hTaXplLCBydW50aW1lLCBhY3RpdmF0aW9uQXJyYXlNYXAsIGdyYWRpZW50QXJyYXlNYXApO1xuICAgICAgICBpZiAodGhpcy52YXJpYWJsZVZlbG9jaXRpZXMuc2l6ZSgpID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLnZhcmlhYmxlTm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgIF90aGlzLnZhcmlhYmxlVmVsb2NpdGllcy5zZXQobm9kZS5vdXRwdXQsIG5kYXJyYXlfMS5OREFycmF5Lnplcm9zKG5vZGUub3V0cHV0LnNoYXBlKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTW9tZW50dW1PcHRpbWl6ZXIucHJvdG90eXBlLmFmdGVyQmF0Y2ggPSBmdW5jdGlvbiAobWF0aCwgYmF0Y2hTaXplLCBydW50aW1lLCBhY3RpdmF0aW9uQXJyYXlNYXAsIGdyYWRpZW50QXJyYXlNYXApIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgbWF0aC5zY29wZShmdW5jdGlvbiAoa2VlcCkge1xuICAgICAgICAgICAgX3RoaXMudmFyaWFibGVOb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9sZFZhcmlhYmxlID0gYWN0aXZhdGlvbkFycmF5TWFwLmdldChub2RlLm91dHB1dCk7XG4gICAgICAgICAgICAgICAgdmFyIGdyYWRpZW50ID0gX3RoaXMudmFyaWFibGVHcmFkaWVudHMuZ2V0KG5vZGUub3V0cHV0KTtcbiAgICAgICAgICAgICAgICB2YXIgb2xkVmVsb2NpdHkgPSBfdGhpcy52YXJpYWJsZVZlbG9jaXRpZXMuZ2V0KG5vZGUub3V0cHV0KTtcbiAgICAgICAgICAgICAgICB2YXIgdmVsb2NpdHkgPSBtYXRoLnNjYWxlZEFycmF5QWRkKF90aGlzLm0sIG9sZFZlbG9jaXR5LCBfdGhpcy5vbmUsIGdyYWRpZW50KTtcbiAgICAgICAgICAgICAgICB2YXIgdmFyaWFibGUgPSBtYXRoLnNjYWxlZEFycmF5QWRkKF90aGlzLmMsIHZlbG9jaXR5LCBfdGhpcy5vbmUsIG9sZFZhcmlhYmxlKTtcbiAgICAgICAgICAgICAgICBfdGhpcy52YXJpYWJsZVZlbG9jaXRpZXMuc2V0KG5vZGUub3V0cHV0LCBrZWVwKHZlbG9jaXR5KSk7XG4gICAgICAgICAgICAgICAgYWN0aXZhdGlvbkFycmF5TWFwLnNldChub2RlLm91dHB1dCwga2VlcCh2YXJpYWJsZSkpO1xuICAgICAgICAgICAgICAgIG5vZGUuZGF0YSA9IHZhcmlhYmxlO1xuICAgICAgICAgICAgICAgIG9sZFZhcmlhYmxlLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgICAgICBvbGRWZWxvY2l0eS5kaXNwb3NlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudmFyaWFibGVHcmFkaWVudHMuZGlzcG9zZSgpO1xuICAgICAgICB0aGlzLnZhcmlhYmxlR3JhZGllbnRzID0gbmV3IHRlbnNvcl9hcnJheV9tYXBfMS5UZW5zb3JBcnJheU1hcCgpO1xuICAgIH07XG4gICAgTW9tZW50dW1PcHRpbWl6ZXIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLm0uZGlzcG9zZSgpO1xuICAgICAgICB0aGlzLnZhcmlhYmxlVmVsb2NpdGllcy5kaXNwb3NlKCk7XG4gICAgfTtcbiAgICBNb21lbnR1bU9wdGltaXplci5wcm90b3R5cGUuc2V0TW9tZW50dW0gPSBmdW5jdGlvbiAobW9tZW50dW0pIHtcbiAgICAgICAgdGhpcy5tb21lbnR1bSA9IG1vbWVudHVtO1xuICAgIH07XG4gICAgcmV0dXJuIE1vbWVudHVtT3B0aW1pemVyO1xufShzZ2Rfb3B0aW1pemVyXzEuU0dET3B0aW1pemVyKSk7XG5leHBvcnRzLk1vbWVudHVtT3B0aW1pemVyID0gTW9tZW50dW1PcHRpbWl6ZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb21lbnR1bV9vcHRpbWl6ZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgbmRhcnJheV8xID0gcmVxdWlyZShcIi4uLy4uL21hdGgvbmRhcnJheVwiKTtcbnZhciBzZXNzaW9uX3V0aWwgPSByZXF1aXJlKFwiLi4vc2Vzc2lvbl91dGlsXCIpO1xudmFyIHRlbnNvcl9hcnJheV9tYXBfMSA9IHJlcXVpcmUoXCIuLi90ZW5zb3JfYXJyYXlfbWFwXCIpO1xudmFyIE9wdGltaXplciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gT3B0aW1pemVyKGxlYXJuaW5nUmF0ZSwgc3BlY2lmaWVkVmFyaWFibGVMaXN0KSB7XG4gICAgICAgIHRoaXMubGVhcm5pbmdSYXRlID0gbGVhcm5pbmdSYXRlO1xuICAgICAgICB0aGlzLnZhcmlhYmxlR3JhZGllbnRzID0gbmV3IHRlbnNvcl9hcnJheV9tYXBfMS5UZW5zb3JBcnJheU1hcCgpO1xuICAgICAgICB0aGlzLm9uZSA9IG5kYXJyYXlfMS5TY2FsYXIubmV3KDEpO1xuICAgICAgICBpZiAoc3BlY2lmaWVkVmFyaWFibGVMaXN0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuc3BlY2lmaWVkVmFyaWFibGVOb2RlcyA9IHNwZWNpZmllZFZhcmlhYmxlTGlzdDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBPcHRpbWl6ZXIucHJvdG90eXBlLmJlZm9yZUJhdGNoID0gZnVuY3Rpb24gKG1hdGgsIGJhdGNoU2l6ZSwgcnVudGltZSwgYWN0aXZhdGlvbkFycmF5TWFwLCBncmFkaWVudEFycmF5TWFwKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMudmFyaWFibGVOb2RlcyA9IHRoaXMuc3BlY2lmaWVkVmFyaWFibGVOb2RlcyA9PSBudWxsID9cbiAgICAgICAgICAgIHNlc3Npb25fdXRpbC5nZXRWYXJpYWJsZU5vZGVzRnJvbUV2YWx1YXRpb25TZXQocnVudGltZS5ub2RlcykgOlxuICAgICAgICAgICAgdGhpcy5zcGVjaWZpZWRWYXJpYWJsZU5vZGVzO1xuICAgICAgICBpZiAoYmF0Y2hTaXplICE9PSB0aGlzLnByZXZCYXRjaFNpemUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYy5kaXNwb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnByZXZCYXRjaFNpemUgPSBiYXRjaFNpemU7XG4gICAgICAgICAgICB0aGlzLmMgPSBuZGFycmF5XzEuU2NhbGFyLm5ldygtdGhpcy5sZWFybmluZ1JhdGUgLyBiYXRjaFNpemUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudmFyaWFibGVOb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBfdGhpcy52YXJpYWJsZUdyYWRpZW50cy5zZXQobm9kZS5vdXRwdXQsIG5kYXJyYXlfMS5OREFycmF5Lnplcm9zKG5vZGUub3V0cHV0LnNoYXBlKSk7IH0pO1xuICAgIH07XG4gICAgT3B0aW1pemVyLnByb3RvdHlwZS5hZnRlckV4YW1wbGUgPSBmdW5jdGlvbiAobWF0aCwgcnVudGltZSwgYWN0aXZhdGlvbkFycmF5TWFwLCBncmFkaWVudEFycmF5TWFwKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIG1hdGguc2NvcGUoZnVuY3Rpb24gKGtlZXApIHtcbiAgICAgICAgICAgIF90aGlzLnZhcmlhYmxlTm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgIHZhciBncmFkaWVudCA9IGdyYWRpZW50QXJyYXlNYXAuZ2V0KG5vZGUub3V0cHV0KTtcbiAgICAgICAgICAgICAgICB2YXIgYWNjdW11bGF0ZWRHcmFkaWVudCA9IF90aGlzLnZhcmlhYmxlR3JhZGllbnRzLmdldChub2RlLm91dHB1dCk7XG4gICAgICAgICAgICAgICAgX3RoaXMudmFyaWFibGVHcmFkaWVudHMuc2V0KG5vZGUub3V0cHV0LCBrZWVwKG1hdGguYWRkKGdyYWRpZW50LCBhY2N1bXVsYXRlZEdyYWRpZW50KSkpO1xuICAgICAgICAgICAgICAgIGFjY3VtdWxhdGVkR3JhZGllbnQuZGlzcG9zZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgT3B0aW1pemVyLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5jICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuYy5kaXNwb3NlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vbmUuZGlzcG9zZSgpO1xuICAgIH07XG4gICAgcmV0dXJuIE9wdGltaXplcjtcbn0oKSk7XG5leHBvcnRzLk9wdGltaXplciA9IE9wdGltaXplcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9wdGltaXplci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIG5kYXJyYXlfMSA9IHJlcXVpcmUoXCIuLi8uLi9tYXRoL25kYXJyYXlcIik7XG52YXIgdGVuc29yX2FycmF5X21hcF8xID0gcmVxdWlyZShcIi4uL3RlbnNvcl9hcnJheV9tYXBcIik7XG52YXIgb3B0aW1pemVyXzEgPSByZXF1aXJlKFwiLi9vcHRpbWl6ZXJcIik7XG52YXIgUk1TUHJvcE9wdGltaXplciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFJNU1Byb3BPcHRpbWl6ZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUk1TUHJvcE9wdGltaXplcihsZWFybmluZ1JhdGUsIGdhbW1hLCBzcGVjaWZpZWRWYXJpYWJsZUxpc3QpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbGVhcm5pbmdSYXRlLCBzcGVjaWZpZWRWYXJpYWJsZUxpc3QpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmxlYXJuaW5nUmF0ZSA9IGxlYXJuaW5nUmF0ZTtcbiAgICAgICAgX3RoaXMuZ2FtbWEgPSBnYW1tYTtcbiAgICAgICAgX3RoaXMuYWNjdW11bGF0ZWRTcXVhcmVkR3JhZGllbnRzID0gbmV3IHRlbnNvcl9hcnJheV9tYXBfMS5UZW5zb3JBcnJheU1hcCgpO1xuICAgICAgICBfdGhpcy5lcHMgPSBuZGFycmF5XzEuU2NhbGFyLm5ldygxZS02KTtcbiAgICAgICAgX3RoaXMuZyA9IG5kYXJyYXlfMS5TY2FsYXIubmV3KF90aGlzLmdhbW1hKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBSTVNQcm9wT3B0aW1pemVyLnByb3RvdHlwZS5iZWZvcmVCYXRjaCA9IGZ1bmN0aW9uIChtYXRoLCBiYXRjaFNpemUsIHJ1bnRpbWUsIGFjdGl2YXRpb25BcnJheU1hcCwgZ3JhZGllbnRBcnJheU1hcCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLmJlZm9yZUJhdGNoLmNhbGwodGhpcywgbWF0aCwgYmF0Y2hTaXplLCBydW50aW1lLCBhY3RpdmF0aW9uQXJyYXlNYXAsIGdyYWRpZW50QXJyYXlNYXApO1xuICAgICAgICBpZiAodGhpcy5hY2N1bXVsYXRlZFNxdWFyZWRHcmFkaWVudHMuc2l6ZSgpID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLnZhcmlhYmxlTm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgIF90aGlzLmFjY3VtdWxhdGVkU3F1YXJlZEdyYWRpZW50cy5zZXQobm9kZS5vdXRwdXQsIG5kYXJyYXlfMS5OREFycmF5Lnplcm9zKG5vZGUub3V0cHV0LnNoYXBlKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUk1TUHJvcE9wdGltaXplci5wcm90b3R5cGUuYWZ0ZXJCYXRjaCA9IGZ1bmN0aW9uIChtYXRoLCBiYXRjaFNpemUsIHJ1bnRpbWUsIGFjdGl2YXRpb25BcnJheU1hcCwgZ3JhZGllbnRBcnJheU1hcCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBtYXRoLnNjb3BlKGZ1bmN0aW9uIChrZWVwKSB7XG4gICAgICAgICAgICBfdGhpcy52YXJpYWJsZU5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgb2xkVmFyaWFibGUgPSBhY3RpdmF0aW9uQXJyYXlNYXAuZ2V0KG5vZGUub3V0cHV0KTtcbiAgICAgICAgICAgICAgICB2YXIgZ3JhZGllbnQgPSBfdGhpcy52YXJpYWJsZUdyYWRpZW50cy5nZXQobm9kZS5vdXRwdXQpO1xuICAgICAgICAgICAgICAgIHZhciBvbGRDYWNoZSA9IF90aGlzLmFjY3VtdWxhdGVkU3F1YXJlZEdyYWRpZW50cy5nZXQobm9kZS5vdXRwdXQpO1xuICAgICAgICAgICAgICAgIHZhciBncmFkaWVudFNxdWFyZSA9IG1hdGgubXVsdGlwbHkoZ3JhZGllbnQsIGdyYWRpZW50KTtcbiAgICAgICAgICAgICAgICB2YXIgY2FjaGUgPSBtYXRoLnNjYWxlZEFycmF5QWRkKF90aGlzLmcsIG9sZENhY2hlLCBtYXRoLnN1YnRyYWN0KF90aGlzLm9uZSwgX3RoaXMuZyksIGdyYWRpZW50U3F1YXJlKTtcbiAgICAgICAgICAgICAgICB2YXIgdmFyaWFibGUgPSBtYXRoLnNjYWxlZEFycmF5QWRkKF90aGlzLmMsIG1hdGguZGl2aWRlKGdyYWRpZW50LCBtYXRoLmFkZChtYXRoLnNxcnQoY2FjaGUpLCBfdGhpcy5lcHMpKSwgX3RoaXMub25lLCBvbGRWYXJpYWJsZSk7XG4gICAgICAgICAgICAgICAgX3RoaXMuYWNjdW11bGF0ZWRTcXVhcmVkR3JhZGllbnRzLnNldChub2RlLm91dHB1dCwga2VlcChjYWNoZSkpO1xuICAgICAgICAgICAgICAgIGFjdGl2YXRpb25BcnJheU1hcC5zZXQobm9kZS5vdXRwdXQsIGtlZXAodmFyaWFibGUpKTtcbiAgICAgICAgICAgICAgICBub2RlLmRhdGEgPSB2YXJpYWJsZTtcbiAgICAgICAgICAgICAgICBvbGRWYXJpYWJsZS5kaXNwb3NlKCk7XG4gICAgICAgICAgICAgICAgb2xkQ2FjaGUuZGlzcG9zZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnZhcmlhYmxlR3JhZGllbnRzLmRpc3Bvc2UoKTtcbiAgICAgICAgdGhpcy52YXJpYWJsZUdyYWRpZW50cyA9IG5ldyB0ZW5zb3JfYXJyYXlfbWFwXzEuVGVuc29yQXJyYXlNYXAoKTtcbiAgICB9O1xuICAgIFJNU1Byb3BPcHRpbWl6ZXIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLmVwcy5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMuZy5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMuYWNjdW11bGF0ZWRTcXVhcmVkR3JhZGllbnRzLmRpc3Bvc2UoKTtcbiAgICB9O1xuICAgIHJldHVybiBSTVNQcm9wT3B0aW1pemVyO1xufShvcHRpbWl6ZXJfMS5PcHRpbWl6ZXIpKTtcbmV4cG9ydHMuUk1TUHJvcE9wdGltaXplciA9IFJNU1Byb3BPcHRpbWl6ZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ybXNwcm9wX29wdGltaXplci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRlbnNvcl9hcnJheV9tYXBfMSA9IHJlcXVpcmUoXCIuLi90ZW5zb3JfYXJyYXlfbWFwXCIpO1xudmFyIG9wdGltaXplcl8xID0gcmVxdWlyZShcIi4vb3B0aW1pemVyXCIpO1xudmFyIFNHRE9wdGltaXplciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFNHRE9wdGltaXplciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTR0RPcHRpbWl6ZXIobGVhcm5pbmdSYXRlLCBzcGVjaWZpZWRWYXJpYWJsZUxpc3QpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbGVhcm5pbmdSYXRlLCBzcGVjaWZpZWRWYXJpYWJsZUxpc3QpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmxlYXJuaW5nUmF0ZSA9IGxlYXJuaW5nUmF0ZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBTR0RPcHRpbWl6ZXIucHJvdG90eXBlLmFmdGVyQmF0Y2ggPSBmdW5jdGlvbiAobWF0aCwgYmF0Y2hTaXplLCBydW50aW1lLCBhY3RpdmF0aW9uQXJyYXlNYXAsIGdyYWRpZW50QXJyYXlNYXApIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgbWF0aC5zY29wZShmdW5jdGlvbiAoa2VlcCkge1xuICAgICAgICAgICAgX3RoaXMudmFyaWFibGVOb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9sZFZhcmlhYmxlID0gYWN0aXZhdGlvbkFycmF5TWFwLmdldChub2RlLm91dHB1dCk7XG4gICAgICAgICAgICAgICAgdmFyIGdyYWRpZW50ID0gX3RoaXMudmFyaWFibGVHcmFkaWVudHMuZ2V0KG5vZGUub3V0cHV0KTtcbiAgICAgICAgICAgICAgICB2YXIgdmFyaWFibGUgPSBtYXRoLnNjYWxlZEFycmF5QWRkKF90aGlzLmMsIGdyYWRpZW50LCBfdGhpcy5vbmUsIG9sZFZhcmlhYmxlKTtcbiAgICAgICAgICAgICAgICBhY3RpdmF0aW9uQXJyYXlNYXAuc2V0KG5vZGUub3V0cHV0LCBrZWVwKHZhcmlhYmxlKSk7XG4gICAgICAgICAgICAgICAgbm9kZS5kYXRhID0gdmFyaWFibGU7XG4gICAgICAgICAgICAgICAgb2xkVmFyaWFibGUuZGlzcG9zZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnZhcmlhYmxlR3JhZGllbnRzLmRpc3Bvc2UoKTtcbiAgICAgICAgdGhpcy52YXJpYWJsZUdyYWRpZW50cyA9IG5ldyB0ZW5zb3JfYXJyYXlfbWFwXzEuVGVuc29yQXJyYXlNYXAoKTtcbiAgICB9O1xuICAgIFNHRE9wdGltaXplci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG4gICAgfTtcbiAgICBTR0RPcHRpbWl6ZXIucHJvdG90eXBlLnNldExlYXJuaW5nUmF0ZSA9IGZ1bmN0aW9uIChsZWFybmluZ1JhdGUpIHtcbiAgICAgICAgdGhpcy5sZWFybmluZ1JhdGUgPSBsZWFybmluZ1JhdGU7XG4gICAgfTtcbiAgICByZXR1cm4gU0dET3B0aW1pemVyO1xufShvcHRpbWl6ZXJfMS5PcHRpbWl6ZXIpKTtcbmV4cG9ydHMuU0dET3B0aW1pemVyID0gU0dET3B0aW1pemVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2dkX29wdGltaXplci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmZ1bmN0aW9uIGRlZmF1bHRDb21wYXJlKGEsIGIpIHtcbiAgICBpZiAoYSA9PT0gYikge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgZWxzZSBpZiAoYSA8IGIpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0Q29tcGFyZSA9IGRlZmF1bHRDb21wYXJlO1xudmFyIFByaW9yaXR5UXVldWUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFByaW9yaXR5UXVldWUoY29tcGFyYXRvciwgaW5kZXhPYnNlcnZlcikge1xuICAgICAgICB0aGlzLmNvbXBhcmF0b3IgPSBjb21wYXJhdG9yO1xuICAgICAgICB0aGlzLmluZGV4T2JzZXJ2ZXIgPSBpbmRleE9ic2VydmVyO1xuICAgICAgICB0aGlzLmhlYXAgPSBbXTtcbiAgICB9XG4gICAgUHJpb3JpdHlRdWV1ZS5wcm90b3R5cGUuZW5xdWV1ZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHRoaXMuaGVhcC5wdXNoKHQpO1xuICAgICAgICB0aGlzLm9uSW5kZXhDaGFuZ2VkKHQsIHRoaXMuaGVhcC5sZW5ndGggLSAxKTtcbiAgICAgICAgdGhpcy5zaWZ0VXAodGhpcy5oZWFwLmxlbmd0aCAtIDEpO1xuICAgIH07XG4gICAgUHJpb3JpdHlRdWV1ZS5wcm90b3R5cGUuZGVxdWV1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuZW1wdHkoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkZXF1ZXVlIGNhbGxlZCBvbiBlbXB0eSBwcmlvcml0eSBxdWV1ZS4nKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdCA9IHRoaXMuaGVhcFswXTtcbiAgICAgICAgdGhpcy5zd2FwKDAsIHRoaXMuaGVhcC5sZW5ndGggLSAxKTtcbiAgICAgICAgdGhpcy5oZWFwLnBvcCgpO1xuICAgICAgICB0aGlzLnNpZnREb3duKDApO1xuICAgICAgICByZXR1cm4gdDtcbiAgICB9O1xuICAgIFByaW9yaXR5UXVldWUucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChuZXdULCBpbmRleCkge1xuICAgICAgICB2YXIgbGFzdCA9IChpbmRleCA9PT0gdGhpcy5oZWFwLmxlbmd0aCAtIDEpO1xuICAgICAgICBpZiAoIWxhc3QpIHtcbiAgICAgICAgICAgIHRoaXMuc3dhcChpbmRleCwgdGhpcy5oZWFwLmxlbmd0aCAtIDEpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaGVhcC5wb3AoKTtcbiAgICAgICAgaWYgKCFsYXN0KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zaWZ0VXBJbmRleChpbmRleCkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zaWZ0VXAoaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5zaWZ0RG93bkluZGV4KGluZGV4KSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNpZnREb3duKGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVucXVldWUobmV3VCk7XG4gICAgfTtcbiAgICBQcmlvcml0eVF1ZXVlLnByb3RvdHlwZS5lbXB0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGVhcC5sZW5ndGggPT09IDA7XG4gICAgfTtcbiAgICBQcmlvcml0eVF1ZXVlLnByb3RvdHlwZS5vbkluZGV4Q2hhbmdlZCA9IGZ1bmN0aW9uICh0LCBuZXdJbmRleCkge1xuICAgICAgICBpZiAodGhpcy5pbmRleE9ic2VydmVyKSB7XG4gICAgICAgICAgICB0aGlzLmluZGV4T2JzZXJ2ZXIodCwgbmV3SW5kZXgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBQcmlvcml0eVF1ZXVlLnByb3RvdHlwZS5nZXRQYXJlbnRJbmRleCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICBpZiAoaW5kZXggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gTWF0aC5mbG9vcigoaW5kZXggLSAxKSAvIDIpO1xuICAgIH07XG4gICAgUHJpb3JpdHlRdWV1ZS5wcm90b3R5cGUuZ2V0TGVmdENoaWxkSW5kZXggPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IGluZGV4ICogMiArIDE7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgPCB0aGlzLmhlYXAubGVuZ3RoID8gY2FuZGlkYXRlIDogLTE7XG4gICAgfTtcbiAgICBQcmlvcml0eVF1ZXVlLnByb3RvdHlwZS5nZXRSaWdodENoaWxkSW5kZXggPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IGluZGV4ICogMiArIDI7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgPCB0aGlzLmhlYXAubGVuZ3RoID8gY2FuZGlkYXRlIDogLTE7XG4gICAgfTtcbiAgICBQcmlvcml0eVF1ZXVlLnByb3RvdHlwZS5zaWZ0VXBJbmRleCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICB2YXIgcGFyZW50SW5kZXggPSB0aGlzLmdldFBhcmVudEluZGV4KGluZGV4KTtcbiAgICAgICAgaWYgKHBhcmVudEluZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNvbXBhcmUocGFyZW50SW5kZXgsIGluZGV4KSA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJlbnRJbmRleDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfTtcbiAgICBQcmlvcml0eVF1ZXVlLnByb3RvdHlwZS5zaWZ0VXAgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgdmFyIHNpZnRJbmRleCA9IHRoaXMuc2lmdFVwSW5kZXgoaW5kZXgpO1xuICAgICAgICB3aGlsZSAoc2lmdEluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgdGhpcy5zd2FwKGluZGV4LCBzaWZ0SW5kZXgpO1xuICAgICAgICAgICAgaW5kZXggPSBzaWZ0SW5kZXg7XG4gICAgICAgICAgICBzaWZ0SW5kZXggPSB0aGlzLnNpZnRVcEluZGV4KGluZGV4KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUHJpb3JpdHlRdWV1ZS5wcm90b3R5cGUuc2lmdERvd25JbmRleCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICBpZiAoaW5kZXggPj0gdGhpcy5oZWFwLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsYXJnZXN0Q2hpbGRJbmRleCA9IGluZGV4O1xuICAgICAgICB2YXIgbGVmdENoaWxkSW5kZXggPSB0aGlzLmdldExlZnRDaGlsZEluZGV4KGluZGV4KTtcbiAgICAgICAgaWYgKChsZWZ0Q2hpbGRJbmRleCAhPT0gLTEpICYmXG4gICAgICAgICAgICAodGhpcy5jb21wYXJlKGxlZnRDaGlsZEluZGV4LCBsYXJnZXN0Q2hpbGRJbmRleCkgPCAwKSkge1xuICAgICAgICAgICAgbGFyZ2VzdENoaWxkSW5kZXggPSBsZWZ0Q2hpbGRJbmRleDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmlnaHRDaGlsZEluZGV4ID0gdGhpcy5nZXRSaWdodENoaWxkSW5kZXgoaW5kZXgpO1xuICAgICAgICBpZiAoKHJpZ2h0Q2hpbGRJbmRleCAhPT0gLTEpICYmXG4gICAgICAgICAgICAodGhpcy5jb21wYXJlKHJpZ2h0Q2hpbGRJbmRleCwgbGFyZ2VzdENoaWxkSW5kZXgpIDwgMCkpIHtcbiAgICAgICAgICAgIGxhcmdlc3RDaGlsZEluZGV4ID0gcmlnaHRDaGlsZEluZGV4O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAobGFyZ2VzdENoaWxkSW5kZXggPT09IGluZGV4KSA/IC0xIDogbGFyZ2VzdENoaWxkSW5kZXg7XG4gICAgfTtcbiAgICBQcmlvcml0eVF1ZXVlLnByb3RvdHlwZS5zaWZ0RG93biA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICB2YXIgc2lmdEluZGV4ID0gdGhpcy5zaWZ0RG93bkluZGV4KGluZGV4KTtcbiAgICAgICAgd2hpbGUgKHNpZnRJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuc3dhcChpbmRleCwgc2lmdEluZGV4KTtcbiAgICAgICAgICAgIGluZGV4ID0gc2lmdEluZGV4O1xuICAgICAgICAgICAgc2lmdEluZGV4ID0gdGhpcy5zaWZ0RG93bkluZGV4KGluZGV4KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUHJpb3JpdHlRdWV1ZS5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIChhSW5kZXgsIGJJbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb21wYXJhdG9yKHRoaXMuaGVhcFthSW5kZXhdLCB0aGlzLmhlYXBbYkluZGV4XSk7XG4gICAgfTtcbiAgICBQcmlvcml0eVF1ZXVlLnByb3RvdHlwZS5zd2FwID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgdmFyIHRlbXAgPSB0aGlzLmhlYXBbYV07XG4gICAgICAgIHRoaXMuaGVhcFthXSA9IHRoaXMuaGVhcFtiXTtcbiAgICAgICAgdGhpcy5oZWFwW2JdID0gdGVtcDtcbiAgICAgICAgdGhpcy5vbkluZGV4Q2hhbmdlZCh0aGlzLmhlYXBbYV0sIGEpO1xuICAgICAgICB0aGlzLm9uSW5kZXhDaGFuZ2VkKHRoaXMuaGVhcFtiXSwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gUHJpb3JpdHlRdWV1ZTtcbn0oKSk7XG5leHBvcnRzLlByaW9yaXR5UXVldWUgPSBQcmlvcml0eVF1ZXVlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJpb3JpdHlfcXVldWUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgbmRhcnJheV8xID0gcmVxdWlyZShcIi4uL21hdGgvbmRhcnJheVwiKTtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG52YXIgb3BlcmF0aW9uX2VtaXR0ZXIgPSByZXF1aXJlKFwiLi9vcGVyYXRpb25fZW1pdHRlclwiKTtcbnZhciBzZXNzaW9uX3V0aWwgPSByZXF1aXJlKFwiLi9zZXNzaW9uX3V0aWxcIik7XG52YXIgdGVuc29yX2FycmF5X21hcF8xID0gcmVxdWlyZShcIi4vdGVuc29yX2FycmF5X21hcFwiKTtcbnZhciBGZWVkRGljdGlvbmFyeSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRmVlZERpY3Rpb25hcnkoZmVlZEVudHJpZXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5kaWN0ID0ge307XG4gICAgICAgIGlmIChmZWVkRW50cmllcykge1xuICAgICAgICAgICAgZmVlZEVudHJpZXMuZm9yRWFjaChmdW5jdGlvbiAoZW50cnkpIHsgcmV0dXJuIF90aGlzLmRpY3RbZW50cnkudGVuc29yLmlkXSA9IGVudHJ5OyB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gRmVlZERpY3Rpb25hcnk7XG59KCkpO1xuZXhwb3J0cy5GZWVkRGljdGlvbmFyeSA9IEZlZWREaWN0aW9uYXJ5O1xudmFyIENvc3RSZWR1Y3Rpb247XG4oZnVuY3Rpb24gKENvc3RSZWR1Y3Rpb24pIHtcbiAgICBDb3N0UmVkdWN0aW9uW0Nvc3RSZWR1Y3Rpb25bXCJOT05FXCJdID0gMF0gPSBcIk5PTkVcIjtcbiAgICBDb3N0UmVkdWN0aW9uW0Nvc3RSZWR1Y3Rpb25bXCJTVU1cIl0gPSAxXSA9IFwiU1VNXCI7XG4gICAgQ29zdFJlZHVjdGlvbltDb3N0UmVkdWN0aW9uW1wiTUVBTlwiXSA9IDJdID0gXCJNRUFOXCI7XG59KShDb3N0UmVkdWN0aW9uID0gZXhwb3J0cy5Db3N0UmVkdWN0aW9uIHx8IChleHBvcnRzLkNvc3RSZWR1Y3Rpb24gPSB7fSkpO1xudmFyIFNlc3Npb24gPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNlc3Npb24oZ3JhcGgsIG1hdGgpIHtcbiAgICAgICAgdGhpcy5tYXRoID0gbWF0aDtcbiAgICAgICAgdGhpcy5hY3RpdmF0aW9uQXJyYXlNYXAgPSBuZXcgdGVuc29yX2FycmF5X21hcF8xLlRlbnNvckFycmF5TWFwKCk7XG4gICAgICAgIHRoaXMucnVudGltZUNhY2hlID0ge307XG4gICAgICAgIHRoaXMub25lU2NhbGFyID0gbmRhcnJheV8xLlNjYWxhci5uZXcoMSk7XG4gICAgICAgIHRoaXMuZ3JhZGllbnRBcnJheU1hcCA9IG5ldyB0ZW5zb3JfYXJyYXlfbWFwXzEuU3VtbWVkVGVuc29yQXJyYXlNYXAodGhpcy5tYXRoKTtcbiAgICB9XG4gICAgU2Vzc2lvbi5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5hY3RpdmF0aW9uQXJyYXlNYXAuZGlzcG9zZSgpO1xuICAgICAgICBPYmplY3Qua2V5cyh0aGlzLnJ1bnRpbWVDYWNoZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICB2YXIgcnVudGltZSA9IF90aGlzLnJ1bnRpbWVDYWNoZVtrZXldO1xuICAgICAgICAgICAgaWYgKHJ1bnRpbWUub3BlcmF0aW9ucykge1xuICAgICAgICAgICAgICAgIHJ1bnRpbWUub3BlcmF0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChvcCkgeyByZXR1cm4gb3AuZGlzcG9zZSgpOyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucnVudGltZUNhY2hlID0ge307XG4gICAgICAgIGlmICh0aGlzLmJhdGNoU2l6ZVNjYWxhciAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmJhdGNoU2l6ZVNjYWxhci5kaXNwb3NlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vbmVTY2FsYXIuZGlzcG9zZSgpO1xuICAgIH07XG4gICAgU2Vzc2lvbi5wcm90b3R5cGUuZXZhbEFsbCA9IGZ1bmN0aW9uICh0ZW5zb3JzLCBmZWVkRW50cmllcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gdGhpcy5tYXRoLnNjb3BlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBmZWVkID0gbmV3IEZlZWREaWN0aW9uYXJ5KGZlZWRFbnRyaWVzKTtcbiAgICAgICAgICAgIHZhciBydW50aW1lID0gX3RoaXMuZ2V0T3JDcmVhdGVSdW50aW1lKHRlbnNvcnMsIGZlZWQpO1xuICAgICAgICAgICAgdmFyIGFjdGl2YXRpb25zID0gX3RoaXMuYWN0aXZhdGlvbkFycmF5TWFwO1xuICAgICAgICAgICAgc2Vzc2lvbl91dGlsLmRpc3Bvc2VBbmRJbml0aWFsaXplT3BlcmF0aW9uT3V0cHV0cyhydW50aW1lLm5vZGVzLCBhY3RpdmF0aW9ucyk7XG4gICAgICAgICAgICBzZXNzaW9uX3V0aWwuZGlzcG9zZVRyYW5zaWVudE9wZXJhdGlvbkFycmF5cyhydW50aW1lLm9wZXJhdGlvbnMsIF90aGlzLmFjdGl2YXRpb25BcnJheU1hcCwgX3RoaXMuZ3JhZGllbnRBcnJheU1hcCk7XG4gICAgICAgICAgICBzZXNzaW9uX3V0aWwuYWRkUGVyc2lzdGVudEFycmF5c1RvVGVuc29yQXJyYXlNYXAocnVudGltZS5ub2RlcywgYWN0aXZhdGlvbnMpO1xuICAgICAgICAgICAgc2Vzc2lvbl91dGlsLmxvYWRJbnB1dHNGcm9tRmVlZERpY3Rpb25hcnlUb1RlbnNvckFycmF5TWFwKGZlZWQsIGFjdGl2YXRpb25zLCBfdGhpcy5tYXRoKTtcbiAgICAgICAgICAgIHJ1bnRpbWUub3BlcmF0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChvcCkgeyByZXR1cm4gb3AuZmVlZEZvcndhcmQoX3RoaXMubWF0aCwgYWN0aXZhdGlvbnMpOyB9KTtcbiAgICAgICAgICAgIHZhciByZXN1bHRzID0gdGVuc29ycy5tYXAoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIGFjdGl2YXRpb25zLmdldCh4KTsgfSk7XG4gICAgICAgICAgICB0ZW5zb3JzLmZvckVhY2goZnVuY3Rpb24gKHgpIHsgcmV0dXJuIGFjdGl2YXRpb25zLmRlbGV0ZSh4KTsgfSk7XG4gICAgICAgICAgICBzZXNzaW9uX3V0aWwucmVsZWFzZUZlZWREaWN0aW9uYXJ5SW5wdXRzRnJvbVRlbnNvckFycmF5TWFwKGZlZWQsIGFjdGl2YXRpb25zLCBfdGhpcy5tYXRoKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFNlc3Npb24ucHJvdG90eXBlLmV2YWwgPSBmdW5jdGlvbiAodGVuc29yLCBmZWVkRW50cmllcykge1xuICAgICAgICByZXR1cm4gdGhpcy5ldmFsQWxsKFt0ZW5zb3JdLCBmZWVkRW50cmllcylbMF07XG4gICAgfTtcbiAgICBTZXNzaW9uLnByb3RvdHlwZS50cmFpbiA9IGZ1bmN0aW9uIChjb3N0VGVuc29yLCBmZWVkRW50cmllcywgYmF0Y2hTaXplLCBvcHRpbWl6ZXIsIGNvc3RSZWR1Y3Rpb24pIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKGNvc3RSZWR1Y3Rpb24gPT09IHZvaWQgMCkgeyBjb3N0UmVkdWN0aW9uID0gQ29zdFJlZHVjdGlvbi5OT05FOyB9XG4gICAgICAgIHV0aWwuYXNzZXJ0KHV0aWwuaXNTY2FsYXJTaGFwZShjb3N0VGVuc29yLnNoYXBlKSwgJ0Nvc3QgdGVuc29yIGZvciB0cmFpbmluZyBtdXN0IGJlIGEgc2NhbGFyIHZhbHVlLicpO1xuICAgICAgICBpZiAodGhpcy5wcmV2QmF0Y2hTaXplICE9PSBiYXRjaFNpemUpIHtcbiAgICAgICAgICAgIHRoaXMucHJldkJhdGNoU2l6ZSA9IGJhdGNoU2l6ZTtcbiAgICAgICAgICAgIHRoaXMuYmF0Y2hTaXplU2NhbGFyID0gbmRhcnJheV8xLlNjYWxhci5uZXcoYmF0Y2hTaXplKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZmVlZCA9IG5ldyBGZWVkRGljdGlvbmFyeShmZWVkRW50cmllcyk7XG4gICAgICAgIHNlc3Npb25fdXRpbC50aHJvd0lmRmVlZERpY3Rpb25hcnlDb250YWluc05EQXJyYXlzKGZlZWQpO1xuICAgICAgICB2YXIgcnVudGltZSA9IHRoaXMuZ2V0T3JDcmVhdGVSdW50aW1lKFtjb3N0VGVuc29yXSwgZmVlZCk7XG4gICAgICAgIHZhciBpbmZlcmVuY2VPcGVyYXRpb25zID0gcnVudGltZS5vcGVyYXRpb25zO1xuICAgICAgICB2YXIgYmFja1Byb3BPcGVyYXRpb25zID0gcnVudGltZS5vcGVyYXRpb25zLnNsaWNlKCkucmV2ZXJzZSgpO1xuICAgICAgICB2YXIgYWN0aXZhdGlvbnMgPSB0aGlzLmFjdGl2YXRpb25BcnJheU1hcDtcbiAgICAgICAgdmFyIGdyYWRpZW50cyA9IHRoaXMuZ3JhZGllbnRBcnJheU1hcDtcbiAgICAgICAgZ3JhZGllbnRzLm51bGxpZnkoY29zdFRlbnNvcik7XG4gICAgICAgIGdyYWRpZW50cy5hZGQoY29zdFRlbnNvciwgdGhpcy5vbmVTY2FsYXIpO1xuICAgICAgICBzZXNzaW9uX3V0aWwuYWRkUGVyc2lzdGVudEFycmF5c1RvVGVuc29yQXJyYXlNYXAocnVudGltZS5ub2RlcywgYWN0aXZhdGlvbnMpO1xuICAgICAgICBvcHRpbWl6ZXIuYmVmb3JlQmF0Y2godGhpcy5tYXRoLCBiYXRjaFNpemUsIHJ1bnRpbWUsIGFjdGl2YXRpb25zLCBncmFkaWVudHMpO1xuICAgICAgICByZXR1cm4gdGhpcy5tYXRoLnNjb3BlKGZ1bmN0aW9uIChrZWVwLCB0cmFjaykge1xuICAgICAgICAgICAgdmFyIGNvc3QgPSB0cmFjayhuZGFycmF5XzEuU2NhbGFyLm5ldygwKSk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJhdGNoU2l6ZTsgKytpKSB7XG4gICAgICAgICAgICAgICAgc2Vzc2lvbl91dGlsLmRpc3Bvc2VBbmRJbml0aWFsaXplT3BlcmF0aW9uT3V0cHV0cyhydW50aW1lLm5vZGVzLCBhY3RpdmF0aW9ucyk7XG4gICAgICAgICAgICAgICAgc2Vzc2lvbl91dGlsLmRpc3Bvc2VBbmRJbml0aWFsaXplT3BlcmF0aW9uSW5wdXRHcmFkaWVudHMocnVudGltZS5ub2RlcywgZ3JhZGllbnRzKTtcbiAgICAgICAgICAgICAgICBzZXNzaW9uX3V0aWwuZGlzcG9zZVRyYW5zaWVudE9wZXJhdGlvbkFycmF5cyhydW50aW1lLm9wZXJhdGlvbnMsIGFjdGl2YXRpb25zLCBncmFkaWVudHMpO1xuICAgICAgICAgICAgICAgIHNlc3Npb25fdXRpbC5sb2FkSW5wdXRzRnJvbUZlZWREaWN0aW9uYXJ5VG9UZW5zb3JBcnJheU1hcChmZWVkLCBhY3RpdmF0aW9ucywgX3RoaXMubWF0aCk7XG4gICAgICAgICAgICAgICAgaW5mZXJlbmNlT3BlcmF0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChvcCkgeyByZXR1cm4gb3AuZmVlZEZvcndhcmQoX3RoaXMubWF0aCwgYWN0aXZhdGlvbnMpOyB9KTtcbiAgICAgICAgICAgICAgICBiYWNrUHJvcE9wZXJhdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAob3ApIHsgcmV0dXJuIG9wLmJhY2tQcm9wKF90aGlzLm1hdGgsIGFjdGl2YXRpb25zLCBncmFkaWVudHMpOyB9KTtcbiAgICAgICAgICAgICAgICBvcHRpbWl6ZXIuYWZ0ZXJFeGFtcGxlKF90aGlzLm1hdGgsIHJ1bnRpbWUsIGFjdGl2YXRpb25zLCBncmFkaWVudHMpO1xuICAgICAgICAgICAgICAgIHNlc3Npb25fdXRpbC5yZWxlYXNlRmVlZERpY3Rpb25hcnlJbnB1dHNGcm9tVGVuc29yQXJyYXlNYXAoZmVlZCwgYWN0aXZhdGlvbnMsIF90aGlzLm1hdGgpO1xuICAgICAgICAgICAgICAgIGNvc3QgPSBfdGhpcy51cGRhdGVDb3N0Rm9yRXhhbXBsZShjb3N0LCBhY3RpdmF0aW9ucy5nZXQoY29zdFRlbnNvciksIGNvc3RSZWR1Y3Rpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3B0aW1pemVyLmFmdGVyQmF0Y2goX3RoaXMubWF0aCwgYmF0Y2hTaXplLCBydW50aW1lLCBhY3RpdmF0aW9ucywgZ3JhZGllbnRzKTtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy51cGRhdGVDb3N0Rm9yQmF0Y2goY29zdCwgY29zdFJlZHVjdGlvbik7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgU2Vzc2lvbi5wcm90b3R5cGUudXBkYXRlQ29zdEZvckV4YW1wbGUgPSBmdW5jdGlvbiAodG90YWxDb3N0LCBjdXJyQ29zdCwgY29zdFJlZHVjdGlvbikge1xuICAgICAgICBpZiAoY29zdFJlZHVjdGlvbiA9PT0gQ29zdFJlZHVjdGlvbi5NRUFOIHx8XG4gICAgICAgICAgICBjb3N0UmVkdWN0aW9uID09PSBDb3N0UmVkdWN0aW9uLlNVTSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWF0aC5hZGQodG90YWxDb3N0LCBjdXJyQ29zdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRvdGFsQ29zdDtcbiAgICB9O1xuICAgIFNlc3Npb24ucHJvdG90eXBlLnVwZGF0ZUNvc3RGb3JCYXRjaCA9IGZ1bmN0aW9uICh0b3RhbENvc3QsIGNvc3RSZWR1Y3Rpb24pIHtcbiAgICAgICAgaWYgKGNvc3RSZWR1Y3Rpb24gPT09IENvc3RSZWR1Y3Rpb24uTUVBTikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWF0aC5kaXZpZGUodG90YWxDb3N0LCB0aGlzLmJhdGNoU2l6ZVNjYWxhcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRvdGFsQ29zdDtcbiAgICB9O1xuICAgIFNlc3Npb24ucHJvdG90eXBlLmdldE9yQ3JlYXRlUnVudGltZSA9IGZ1bmN0aW9uICh0ZW5zb3JzLCBmZWVkKSB7XG4gICAgICAgIHZhciBrZXkgPSB0aGlzLm1ha2VSdW50aW1lQ2FjaGVLZXkodGVuc29ycywgZmVlZCk7XG4gICAgICAgIHZhciBydW50aW1lID0gdGhpcy5ydW50aW1lQ2FjaGVba2V5XTtcbiAgICAgICAgaWYgKHJ1bnRpbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdmFyIG5vZGVzID0gc2Vzc2lvbl91dGlsLmdldE9yZGVyZWRFdmFsdWF0aW9uU2V0RnJvbUV2YWxUZW5zb3IodGVuc29ycywgZmVlZCk7XG4gICAgICAgICAgICBzZXNzaW9uX3V0aWwucmVtb3ZlRmVlZERpY3Rpb25hcnlOb2Rlc0Zyb21FdmFsdWF0aW9uU2V0KGZlZWQsIG5vZGVzKTtcbiAgICAgICAgICAgIHNlc3Npb25fdXRpbC50aHJvd0Vycm9ySWZFdmFsdWF0aW9uU2V0Q29udGFpbnNQbGFjZWhvbGRlck5vZGVzKG5vZGVzKTtcbiAgICAgICAgICAgIHZhciBvcGVyYXRpb25zID0gb3BlcmF0aW9uX2VtaXR0ZXIuZW1pdEZyb21HcmFwaE5vZGVzKG5vZGVzKTtcbiAgICAgICAgICAgIHJ1bnRpbWUgPSB7IG5vZGVzOiBub2Rlcywgb3BlcmF0aW9uczogb3BlcmF0aW9ucyB9O1xuICAgICAgICAgICAgdGhpcy5ydW50aW1lQ2FjaGVba2V5XSA9IHJ1bnRpbWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJ1bnRpbWU7XG4gICAgfTtcbiAgICBTZXNzaW9uLnByb3RvdHlwZS5tYWtlUnVudGltZUNhY2hlS2V5ID0gZnVuY3Rpb24gKHRlbnNvcnMsIGZlZWQpIHtcbiAgICAgICAgcmV0dXJuIHRlbnNvcnMubWFwKGZ1bmN0aW9uICh4KSB7IHJldHVybiB4LmlkOyB9KS5zb3J0KCkuam9pbignXycpICsgJ19fJyArXG4gICAgICAgICAgICBPYmplY3Qua2V5cyhmZWVkLmRpY3QpLnNvcnQoKS5qb2luKCdfJyk7XG4gICAgfTtcbiAgICByZXR1cm4gU2Vzc2lvbjtcbn0oKSk7XG5leHBvcnRzLlNlc3Npb24gPSBTZXNzaW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2Vzc2lvbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBuZGFycmF5XzEgPSByZXF1aXJlKFwiLi4vbWF0aC9uZGFycmF5XCIpO1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbnZhciBncmFwaF8xID0gcmVxdWlyZShcIi4vZ3JhcGhcIik7XG52YXIgZ3JhcGhfdXRpbCA9IHJlcXVpcmUoXCIuL2dyYXBoX3V0aWxcIik7XG5mdW5jdGlvbiBnZXRUZXJtaW5hdGluZ05vZGVzRnJvbUZlZWREaWN0aW9uYXJ5KGZlZWREaWN0aW9uYXJ5KSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKGZlZWREaWN0aW9uYXJ5LmRpY3QpXG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKHRlbnNvcklEKSB7IHJldHVybiBmZWVkRGljdGlvbmFyeS5kaWN0Wyt0ZW5zb3JJRF0udGVuc29yLm5vZGU7IH0pO1xufVxuZXhwb3J0cy5nZXRUZXJtaW5hdGluZ05vZGVzRnJvbUZlZWREaWN0aW9uYXJ5ID0gZ2V0VGVybWluYXRpbmdOb2Rlc0Zyb21GZWVkRGljdGlvbmFyeTtcbmZ1bmN0aW9uIGdldE9yZGVyZWRFdmFsdWF0aW9uU2V0RnJvbUV2YWxUZW5zb3IoZXZhbFRlbnNvcnMsIGZlZWREaWN0aW9uYXJ5KSB7XG4gICAgdmFyIHRlcm1pbmF0aW5nTm9kZXMgPSBnZXRUZXJtaW5hdGluZ05vZGVzRnJvbUZlZWREaWN0aW9uYXJ5KGZlZWREaWN0aW9uYXJ5KTtcbiAgICB2YXIgZXZhbE5vZGVzID0gZXZhbFRlbnNvcnMubWFwKGZ1bmN0aW9uICh4KSB7IHJldHVybiB4Lm5vZGU7IH0pO1xuICAgIHZhciB1bm9yZGVyZWRFdmFsdWF0aW9uU2V0ID0gZ3JhcGhfdXRpbC5nZXRVbm9yZGVyZWRFdmFsdWF0aW9uU2V0KGV2YWxOb2RlcywgdGVybWluYXRpbmdOb2Rlcyk7XG4gICAgdmFyIG9yZGVyZWRFdmFsdWF0aW9uU2V0ID0gZ3JhcGhfdXRpbC5nZXRPcmRlcmVkRXZhbHVhdGlvblNldCh1bm9yZGVyZWRFdmFsdWF0aW9uU2V0KTtcbiAgICByZXR1cm4gb3JkZXJlZEV2YWx1YXRpb25TZXQ7XG59XG5leHBvcnRzLmdldE9yZGVyZWRFdmFsdWF0aW9uU2V0RnJvbUV2YWxUZW5zb3IgPSBnZXRPcmRlcmVkRXZhbHVhdGlvblNldEZyb21FdmFsVGVuc29yO1xuZnVuY3Rpb24gYWRkUGVyc2lzdGVudEFycmF5c1RvVGVuc29yQXJyYXlNYXAoZXZhbHVhdGlvblNldCwgdGVuc29yQXJyYXlNYXApIHtcbiAgICBldmFsdWF0aW9uU2V0LmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBncmFwaF8xLlZhcmlhYmxlTm9kZSB8fCBub2RlIGluc3RhbmNlb2YgZ3JhcGhfMS5Db25zdGFudE5vZGUpIHtcbiAgICAgICAgICAgIHRlbnNvckFycmF5TWFwLnNldChub2RlLm91dHB1dCwgbm9kZS5kYXRhKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZXhwb3J0cy5hZGRQZXJzaXN0ZW50QXJyYXlzVG9UZW5zb3JBcnJheU1hcCA9IGFkZFBlcnNpc3RlbnRBcnJheXNUb1RlbnNvckFycmF5TWFwO1xuZnVuY3Rpb24gZ2V0VmFyaWFibGVOb2Rlc0Zyb21FdmFsdWF0aW9uU2V0KGV2YWx1YXRpb25TZXQpIHtcbiAgICB2YXIgbm9kZXMgPSBbXTtcbiAgICBldmFsdWF0aW9uU2V0LmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBncmFwaF8xLlZhcmlhYmxlTm9kZSkge1xuICAgICAgICAgICAgbm9kZXMucHVzaChub2RlKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBub2Rlcztcbn1cbmV4cG9ydHMuZ2V0VmFyaWFibGVOb2Rlc0Zyb21FdmFsdWF0aW9uU2V0ID0gZ2V0VmFyaWFibGVOb2Rlc0Zyb21FdmFsdWF0aW9uU2V0O1xuZnVuY3Rpb24gdGhyb3dJZkZlZWREaWN0aW9uYXJ5Q29udGFpbnNOREFycmF5cyhmZWVkRGljdGlvbmFyeSkge1xuICAgIE9iamVjdC5rZXlzKGZlZWREaWN0aW9uYXJ5LmRpY3QpLmZvckVhY2goZnVuY3Rpb24gKHRlbnNvcklEKSB7XG4gICAgICAgIGlmIChmZWVkRGljdGlvbmFyeS5kaWN0Wyt0ZW5zb3JJRF0uZGF0YSBpbnN0YW5jZW9mIG5kYXJyYXlfMS5OREFycmF5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RyYWluaW5nIHJlcXVpcmVzIEZlZWREaWN0aW9uYXJ5IGVudHJpZXMgdG8gYmUgSW5wdXRQcm92aWRlcnMnICtcbiAgICAgICAgICAgICAgICAnYW5kIG5vdCBOREFycmF5cy4nKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZXhwb3J0cy50aHJvd0lmRmVlZERpY3Rpb25hcnlDb250YWluc05EQXJyYXlzID0gdGhyb3dJZkZlZWREaWN0aW9uYXJ5Q29udGFpbnNOREFycmF5cztcbmZ1bmN0aW9uIGxvYWRJbnB1dHNGcm9tRmVlZERpY3Rpb25hcnlUb1RlbnNvckFycmF5TWFwKGJhdGNoRmVlZCwgYWN0aXZhdGlvbnMsIG1hdGgpIHtcbiAgICBPYmplY3Qua2V5cyhiYXRjaEZlZWQuZGljdCkuZm9yRWFjaChmdW5jdGlvbiAodGVuc29ySUQpIHtcbiAgICAgICAgdmFyIGZlZWRFbnRyeSA9IGJhdGNoRmVlZC5kaWN0Wyt0ZW5zb3JJRF07XG4gICAgICAgIHZhciBkYXRhO1xuICAgICAgICBpZiAoZmVlZEVudHJ5LmRhdGEgaW5zdGFuY2VvZiBuZGFycmF5XzEuTkRBcnJheSkge1xuICAgICAgICAgICAgZGF0YSA9IGZlZWRFbnRyeS5kYXRhO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIHByb3ZpZGVyID0gZmVlZEVudHJ5LmRhdGE7XG4gICAgICAgICAgICBkYXRhID0gcHJvdmlkZXIuZ2V0TmV4dENvcHkobWF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgdXRpbC5hc3NlcnQodXRpbC5hcnJheXNFcXVhbChmZWVkRW50cnkudGVuc29yLnNoYXBlLCBkYXRhLnNoYXBlKSwgXCJFcnJvciBsb2FkaW5nIEZlZWRFbnRyeTogZmVlZGluZyBOREFycmF5IG9mIHNoYXBlIFwiICsgZGF0YS5zaGFwZSArIFwiIFwiICtcbiAgICAgICAgICAgIChcImRvZXMgbm90IG1hdGNoIFRlbnNvciAoaWQ6IFwiICsgZmVlZEVudHJ5LnRlbnNvci5pZCArIFwiKSBzaGFwZTogXCIpICtcbiAgICAgICAgICAgIChmZWVkRW50cnkudGVuc29yLnNoYXBlICsgXCIuXCIpKTtcbiAgICAgICAgYWN0aXZhdGlvbnMuc2V0KGZlZWRFbnRyeS50ZW5zb3IsIGRhdGEpO1xuICAgIH0pO1xufVxuZXhwb3J0cy5sb2FkSW5wdXRzRnJvbUZlZWREaWN0aW9uYXJ5VG9UZW5zb3JBcnJheU1hcCA9IGxvYWRJbnB1dHNGcm9tRmVlZERpY3Rpb25hcnlUb1RlbnNvckFycmF5TWFwO1xuZnVuY3Rpb24gcmVsZWFzZUZlZWREaWN0aW9uYXJ5SW5wdXRzRnJvbVRlbnNvckFycmF5TWFwKGJhdGNoRmVlZCwgYWN0aXZhdGlvbnMsIG1hdGgpIHtcbiAgICBPYmplY3Qua2V5cyhiYXRjaEZlZWQuZGljdCkuZm9yRWFjaChmdW5jdGlvbiAodGVuc29ySUQpIHtcbiAgICAgICAgdmFyIGZlZWRFbnRyeSA9IGJhdGNoRmVlZC5kaWN0Wyt0ZW5zb3JJRF07XG4gICAgICAgIGlmICghKGZlZWRFbnRyeS5kYXRhIGluc3RhbmNlb2YgbmRhcnJheV8xLk5EQXJyYXkpKSB7XG4gICAgICAgICAgICB2YXIgcHJvdmlkZXIgPSBmZWVkRW50cnkuZGF0YTtcbiAgICAgICAgICAgIHZhciBmZWVkRW50cnlBcnJheSA9IGFjdGl2YXRpb25zLmdldChmZWVkRW50cnkudGVuc29yKTtcbiAgICAgICAgICAgIHByb3ZpZGVyLmRpc3Bvc2VDb3B5KG1hdGgsIGZlZWRFbnRyeUFycmF5KTtcbiAgICAgICAgfVxuICAgICAgICBhY3RpdmF0aW9ucy5kZWxldGUoZmVlZEVudHJ5LnRlbnNvcik7XG4gICAgfSk7XG59XG5leHBvcnRzLnJlbGVhc2VGZWVkRGljdGlvbmFyeUlucHV0c0Zyb21UZW5zb3JBcnJheU1hcCA9IHJlbGVhc2VGZWVkRGljdGlvbmFyeUlucHV0c0Zyb21UZW5zb3JBcnJheU1hcDtcbmZ1bmN0aW9uIHJlbW92ZUZlZWREaWN0aW9uYXJ5Tm9kZXNGcm9tRXZhbHVhdGlvblNldChmZWVkRGljdGlvbmFyeSwgZXZhbHVhdGlvblNldCkge1xuICAgIHZhciBpID0gMDtcbiAgICB3aGlsZSAoaSA8IGV2YWx1YXRpb25TZXQubGVuZ3RoKSB7XG4gICAgICAgIHZhciBub2RlID0gZXZhbHVhdGlvblNldFtpXTtcbiAgICAgICAgaWYgKGZlZWREaWN0aW9uYXJ5LmRpY3Rbbm9kZS5vdXRwdXQuaWRdICE9IG51bGwpIHtcbiAgICAgICAgICAgIGV2YWx1YXRpb25TZXQuc3BsaWNlKGksIDEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgKytpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5yZW1vdmVGZWVkRGljdGlvbmFyeU5vZGVzRnJvbUV2YWx1YXRpb25TZXQgPSByZW1vdmVGZWVkRGljdGlvbmFyeU5vZGVzRnJvbUV2YWx1YXRpb25TZXQ7XG5mdW5jdGlvbiBkaXNwb3NlQW5kSW5pdGlhbGl6ZU9wZXJhdGlvbk91dHB1dHMoZXZhbHVhdGlvblNldCwgdGVuc29yQXJyYXlNYXApIHtcbiAgICBldmFsdWF0aW9uU2V0LmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgaWYgKCFncmFwaF91dGlsLmlzSW5wdXROb2RlKG5vZGUpKSB7XG4gICAgICAgICAgICBpZiAoIWdyYXBoX3V0aWwuaXNQYXNzdGhyb3VnaE5vZGUobm9kZSwgdGVuc29yQXJyYXlNYXApKSB7XG4gICAgICAgICAgICAgICAgdGVuc29yQXJyYXlNYXAuZGlzcG9zZUFycmF5KG5vZGUub3V0cHV0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRlbnNvckFycmF5TWFwLnNldChub2RlLm91dHB1dCwgbnVsbCk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmV4cG9ydHMuZGlzcG9zZUFuZEluaXRpYWxpemVPcGVyYXRpb25PdXRwdXRzID0gZGlzcG9zZUFuZEluaXRpYWxpemVPcGVyYXRpb25PdXRwdXRzO1xuZnVuY3Rpb24gZGlzcG9zZUFuZEluaXRpYWxpemVPcGVyYXRpb25JbnB1dEdyYWRpZW50cyhldmFsdWF0aW9uU2V0LCBncmFkaWVudHMpIHtcbiAgICBldmFsdWF0aW9uU2V0LmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgT2JqZWN0LmtleXMobm9kZS5pbnB1dHMpLmZvckVhY2goZnVuY3Rpb24gKGlucHV0TmFtZSkge1xuICAgICAgICAgICAgdmFyIGlucHV0ID0gbm9kZS5pbnB1dHNbaW5wdXROYW1lXTtcbiAgICAgICAgICAgIGlmIChncmFkaWVudHMuZ2V0KGlucHV0LCB0cnVlKSAhPT0gZ3JhZGllbnRzLmdldChub2RlLm91dHB1dCwgdHJ1ZSkpIHtcbiAgICAgICAgICAgICAgICBncmFkaWVudHMuZGlzcG9zZUFycmF5KGlucHV0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdyYWRpZW50cy5udWxsaWZ5KGlucHV0KTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5leHBvcnRzLmRpc3Bvc2VBbmRJbml0aWFsaXplT3BlcmF0aW9uSW5wdXRHcmFkaWVudHMgPSBkaXNwb3NlQW5kSW5pdGlhbGl6ZU9wZXJhdGlvbklucHV0R3JhZGllbnRzO1xuZnVuY3Rpb24gZGlzcG9zZVRyYW5zaWVudE9wZXJhdGlvbkFycmF5cyhvcGVyYXRpb25zLCBhY3RpdmF0aW9ucywgZ3JhZGllbnRzKSB7XG4gICAgb3BlcmF0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChvcCkgeyByZXR1cm4gb3AuZGlzcG9zZVRyYW5zaWVudEFycmF5cyhhY3RpdmF0aW9ucywgZ3JhZGllbnRzKTsgfSk7XG59XG5leHBvcnRzLmRpc3Bvc2VUcmFuc2llbnRPcGVyYXRpb25BcnJheXMgPSBkaXNwb3NlVHJhbnNpZW50T3BlcmF0aW9uQXJyYXlzO1xuZnVuY3Rpb24gdGhyb3dFcnJvcklmRXZhbHVhdGlvblNldENvbnRhaW5zUGxhY2Vob2xkZXJOb2RlcyhldmFsdWF0aW9uU2V0KSB7XG4gICAgZXZhbHVhdGlvblNldC5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgZ3JhcGhfMS5QbGFjZWhvbGRlck5vZGUpIHtcbiAgICAgICAgICAgIHZhciBzaGFwZSA9ICdbJyArIG5vZGUub3V0cHV0LnNoYXBlLmpvaW4oJywgJykgKyAnXSc7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BsYWNlaG9sZGVyIG5vZGUgXCInICsgbm9kZS5uYW1lICsgJ1wiICcgKyBzaGFwZSArXG4gICAgICAgICAgICAgICAgJyBub3QgcHJlc2VudCBpbiBmZWVkIGRpY3Rpb25hcnkuJyk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmV4cG9ydHMudGhyb3dFcnJvcklmRXZhbHVhdGlvblNldENvbnRhaW5zUGxhY2Vob2xkZXJOb2RlcyA9IHRocm93RXJyb3JJZkV2YWx1YXRpb25TZXRDb250YWluc1BsYWNlaG9sZGVyTm9kZXM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZXNzaW9uX3V0aWwuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBUZW5zb3JBcnJheU1hcEJhc2UgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRlbnNvckFycmF5TWFwQmFzZSgpIHtcbiAgICAgICAgdGhpcy5kaWN0ID0ge307XG4gICAgfVxuICAgIFRlbnNvckFycmF5TWFwQmFzZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKHRlbnNvciwgc2tpcENoZWNrcykge1xuICAgICAgICBpZiAoc2tpcENoZWNrcyA9PT0gdm9pZCAwKSB7IHNraXBDaGVja3MgPSBmYWxzZTsgfVxuICAgICAgICBpZiAoIXNraXBDaGVja3MgJiYgdGhpcy5kaWN0W3RlbnNvci5pZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidGVuc29yIFwiICsgdGVuc29yLmlkICsgXCIgbm90IGluIGFycmF5IG1hcC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5kYSA9IHRoaXMuZGljdFt0ZW5zb3IuaWRdO1xuICAgICAgICBpZiAoIXNraXBDaGVja3MgJiYgbmRhID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0ZW5zb3IgXCIgKyB0ZW5zb3IuaWQgKyBcIiBoYXMgbnVsbCBhcnJheS5cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5kYTtcbiAgICB9O1xuICAgIFRlbnNvckFycmF5TWFwQmFzZS5wcm90b3R5cGUuZGVsZXRlID0gZnVuY3Rpb24gKHRlbnNvcikge1xuICAgICAgICBkZWxldGUgdGhpcy5kaWN0W3RlbnNvci5pZF07XG4gICAgfTtcbiAgICBUZW5zb3JBcnJheU1hcEJhc2UucHJvdG90eXBlLm51bGxpZnkgPSBmdW5jdGlvbiAodGVuc29yKSB7XG4gICAgICAgIHRoaXMuZGljdFt0ZW5zb3IuaWRdID0gbnVsbDtcbiAgICB9O1xuICAgIFRlbnNvckFycmF5TWFwQmFzZS5wcm90b3R5cGUuZGlzcG9zZUFycmF5ID0gZnVuY3Rpb24gKHRlbnNvcikge1xuICAgICAgICBpZiAodGhpcy5kaWN0W3RlbnNvci5pZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBuZGEgPSB0aGlzLmRpY3RbdGVuc29yLmlkXTtcbiAgICAgICAgaWYgKG5kYSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG5kYS5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMuZGljdFt0ZW5zb3IuaWRdID0gbnVsbDtcbiAgICB9O1xuICAgIFRlbnNvckFycmF5TWFwQmFzZS5wcm90b3R5cGUuc2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuZGljdCkubGVuZ3RoO1xuICAgIH07XG4gICAgVGVuc29yQXJyYXlNYXBCYXNlLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBPYmplY3Qua2V5cyh0aGlzLmRpY3QpLmZvckVhY2goZnVuY3Rpb24gKHRlbnNvcklEKSB7XG4gICAgICAgICAgICB2YXIgbmRhID0gX3RoaXMuZGljdFsrdGVuc29ySURdO1xuICAgICAgICAgICAgaWYgKG5kYSkge1xuICAgICAgICAgICAgICAgIG5kYS5kaXNwb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmRpY3QgPSB7fTtcbiAgICB9O1xuICAgIFRlbnNvckFycmF5TWFwQmFzZS5wcm90b3R5cGUuaGFzTnVsbEFycmF5ID0gZnVuY3Rpb24gKHRlbnNvcikge1xuICAgICAgICBpZiAodGhpcy5kaWN0W3RlbnNvci5pZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidGVuc29yIFwiICsgdGVuc29yLmlkICsgXCIgbm90IGluIGFycmF5IG1hcC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZGljdFt0ZW5zb3IuaWRdID09PSBudWxsO1xuICAgIH07XG4gICAgcmV0dXJuIFRlbnNvckFycmF5TWFwQmFzZTtcbn0oKSk7XG5leHBvcnRzLlRlbnNvckFycmF5TWFwQmFzZSA9IFRlbnNvckFycmF5TWFwQmFzZTtcbnZhciBUZW5zb3JBcnJheU1hcCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFRlbnNvckFycmF5TWFwLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRlbnNvckFycmF5TWFwKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIFRlbnNvckFycmF5TWFwLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAodGVuc29yLCBhcnJheSkge1xuICAgICAgICB0aGlzLmRpY3RbdGVuc29yLmlkXSA9IGFycmF5O1xuICAgIH07XG4gICAgcmV0dXJuIFRlbnNvckFycmF5TWFwO1xufShUZW5zb3JBcnJheU1hcEJhc2UpKTtcbmV4cG9ydHMuVGVuc29yQXJyYXlNYXAgPSBUZW5zb3JBcnJheU1hcDtcbnZhciBTdW1tZWRUZW5zb3JBcnJheU1hcCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFN1bW1lZFRlbnNvckFycmF5TWFwLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFN1bW1lZFRlbnNvckFycmF5TWFwKG1hdGgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMubWF0aCA9IG1hdGg7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgU3VtbWVkVGVuc29yQXJyYXlNYXAucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uICh0ZW5zb3IsIGFycmF5KSB7XG4gICAgICAgIGlmICh0aGlzLmRpY3RbdGVuc29yLmlkXSA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmRpY3RbdGVuc29yLmlkXSA9IHRoaXMubWF0aC5rZWVwKGFycmF5KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBvbGRWYWx1ZSA9IHRoaXMuZ2V0KHRlbnNvcik7XG4gICAgICAgICAgICB2YXIgbmV3VmFsdWUgPSB0aGlzLm1hdGgua2VlcCh0aGlzLm1hdGguYWRkU3RyaWN0KG9sZFZhbHVlLCBhcnJheSkpO1xuICAgICAgICAgICAgdGhpcy5kaWN0W3RlbnNvci5pZF0gPSBuZXdWYWx1ZTtcbiAgICAgICAgICAgIG9sZFZhbHVlLmRpc3Bvc2UoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFN1bW1lZFRlbnNvckFycmF5TWFwO1xufShUZW5zb3JBcnJheU1hcEJhc2UpKTtcbmV4cG9ydHMuU3VtbWVkVGVuc29yQXJyYXlNYXAgPSBTdW1tZWRUZW5zb3JBcnJheU1hcDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRlbnNvcl9hcnJheV9tYXAuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgc2Vzc2lvbl8xID0gcmVxdWlyZShcIi4vZ3JhcGgvc2Vzc2lvblwiKTtcbnZhciBuZGFycmF5XzEgPSByZXF1aXJlKFwiLi9tYXRoL25kYXJyYXlcIik7XG52YXIgREVGQVVMVF9FVkFMX0lOVEVSVkFMX01TID0gMTUwMDtcbnZhciBERUZBVUxUX0NPU1RfSU5URVJWQUxfTVMgPSA1MDA7XG52YXIgREVGQVVMVF9JTkZFUkVOQ0VfRVhBTVBMRV9JTlRFUlZBTF9NUyA9IDMwMDA7XG52YXIgTWV0cmljUmVkdWN0aW9uO1xuKGZ1bmN0aW9uIChNZXRyaWNSZWR1Y3Rpb24pIHtcbiAgICBNZXRyaWNSZWR1Y3Rpb25bTWV0cmljUmVkdWN0aW9uW1wiU1VNXCJdID0gMF0gPSBcIlNVTVwiO1xuICAgIE1ldHJpY1JlZHVjdGlvbltNZXRyaWNSZWR1Y3Rpb25bXCJNRUFOXCJdID0gMV0gPSBcIk1FQU5cIjtcbn0pKE1ldHJpY1JlZHVjdGlvbiA9IGV4cG9ydHMuTWV0cmljUmVkdWN0aW9uIHx8IChleHBvcnRzLk1ldHJpY1JlZHVjdGlvbiA9IHt9KSk7XG52YXIgR3JhcGhSdW5uZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEdyYXBoUnVubmVyKG1hdGgsIHNlc3Npb24sIGV2ZW50T2JzZXJ2ZXIpIHtcbiAgICAgICAgdGhpcy5tYXRoID0gbWF0aDtcbiAgICAgICAgdGhpcy5zZXNzaW9uID0gc2Vzc2lvbjtcbiAgICAgICAgdGhpcy5ldmVudE9ic2VydmVyID0gZXZlbnRPYnNlcnZlcjtcbiAgICAgICAgdGhpcy5sYXN0Q29zdFRpbWVzdGFtcCA9IDA7XG4gICAgICAgIHRoaXMubGFzdEV2YWxUaW1lc3RhbXAgPSAwO1xuICAgICAgICB0aGlzLnRvdGFsSWRsZVRpbWVNcyA9IDA7XG4gICAgICAgIHRoaXMucmVzZXRTdGF0aXN0aWNzKCk7XG4gICAgICAgIHRoaXMuemVyb1NjYWxhciA9IG5kYXJyYXlfMS5TY2FsYXIubmV3KDApO1xuICAgIH1cbiAgICBHcmFwaFJ1bm5lci5wcm90b3R5cGUucmVzZXRTdGF0aXN0aWNzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnRvdGFsQmF0Y2hlc1RyYWluZWQgPSAwO1xuICAgICAgICB0aGlzLnRvdGFsSWRsZVRpbWVNcyA9IDA7XG4gICAgICAgIHRoaXMubGFzdFN0b3BUaW1lc3RhbXAgPSBudWxsO1xuICAgIH07XG4gICAgR3JhcGhSdW5uZXIucHJvdG90eXBlLnRyYWluID0gZnVuY3Rpb24gKGNvc3RUZW5zb3IsIHRyYWluRmVlZEVudHJpZXMsIGJhdGNoU2l6ZSwgb3B0aW1pemVyLCBudW1CYXRjaGVzLCBtZXRyaWNUZW5zb3IsIG1ldHJpY0ZlZWRFbnRyaWVzLCBtZXRyaWNCYXRjaFNpemUsIG1ldHJpY1JlZHVjdGlvbiwgZXZhbEludGVydmFsTXMsIGNvc3RJbnRlcnZhbE1zKSB7XG4gICAgICAgIGlmIChtZXRyaWNSZWR1Y3Rpb24gPT09IHZvaWQgMCkgeyBtZXRyaWNSZWR1Y3Rpb24gPSBNZXRyaWNSZWR1Y3Rpb24uTUVBTjsgfVxuICAgICAgICBpZiAoZXZhbEludGVydmFsTXMgPT09IHZvaWQgMCkgeyBldmFsSW50ZXJ2YWxNcyA9IERFRkFVTFRfRVZBTF9JTlRFUlZBTF9NUzsgfVxuICAgICAgICBpZiAoY29zdEludGVydmFsTXMgPT09IHZvaWQgMCkgeyBjb3N0SW50ZXJ2YWxNcyA9IERFRkFVTFRfQ09TVF9JTlRFUlZBTF9NUzsgfVxuICAgICAgICB0aGlzLmNvc3RUZW5zb3IgPSBjb3N0VGVuc29yO1xuICAgICAgICB0aGlzLnRyYWluRmVlZEVudHJpZXMgPSB0cmFpbkZlZWRFbnRyaWVzO1xuICAgICAgICB0aGlzLm1ldHJpY1RlbnNvciA9IG1ldHJpY1RlbnNvcjtcbiAgICAgICAgdGhpcy5tZXRyaWNGZWVkRW50cmllcyA9IG1ldHJpY0ZlZWRFbnRyaWVzO1xuICAgICAgICBpZiAobWV0cmljQmF0Y2hTaXplICE9IG51bGwgJiYgdGhpcy5tZXRyaWNCYXRjaFNpemUgIT09IG1ldHJpY0JhdGNoU2l6ZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMubWV0cmljQmF0Y2hTaXplU2NhbGFyICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1ldHJpY0JhdGNoU2l6ZVNjYWxhci5kaXNwb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm1ldHJpY0JhdGNoU2l6ZVNjYWxhciA9IG5kYXJyYXlfMS5TY2FsYXIubmV3KG1ldHJpY0JhdGNoU2l6ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tZXRyaWNCYXRjaFNpemUgPSBtZXRyaWNCYXRjaFNpemU7XG4gICAgICAgIHRoaXMubWV0cmljUmVkdWN0aW9uID0gbWV0cmljUmVkdWN0aW9uO1xuICAgICAgICB0aGlzLmJhdGNoU2l6ZSA9IGJhdGNoU2l6ZTtcbiAgICAgICAgdGhpcy5vcHRpbWl6ZXIgPSBvcHRpbWl6ZXI7XG4gICAgICAgIHRoaXMubWV0cmljSW50ZXJ2YWxNcyA9IGV2YWxJbnRlcnZhbE1zO1xuICAgICAgICB0aGlzLmNvc3RJbnRlcnZhbE1zID0gY29zdEludGVydmFsTXM7XG4gICAgICAgIHRoaXMuY3VycmVudFRyYWluTG9vcE51bUJhdGNoZXMgPSBudW1CYXRjaGVzO1xuICAgICAgICB0aGlzLmJhdGNoZXNUcmFpbmVkVGhpc1J1biA9IDA7XG4gICAgICAgIHRoaXMuaXNUcmFpbmluZyA9IHRydWU7XG4gICAgICAgIHRoaXMudHJhaW5TdGFydFRpbWVzdGFtcCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICB0aGlzLnRyYWluTmV0d29yaygpO1xuICAgIH07XG4gICAgR3JhcGhSdW5uZXIucHJvdG90eXBlLnN0b3BUcmFpbmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pc1RyYWluaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMubGFzdFN0b3BUaW1lc3RhbXAgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICB9O1xuICAgIEdyYXBoUnVubmVyLnByb3RvdHlwZS5yZXN1bWVUcmFpbmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pc1RyYWluaW5nID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMubGFzdFN0b3BUaW1lc3RhbXAgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy50b3RhbElkbGVUaW1lTXMgKz0gcGVyZm9ybWFuY2Uubm93KCkgLSB0aGlzLmxhc3RTdG9wVGltZXN0YW1wO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudHJhaW5OZXR3b3JrKCk7XG4gICAgfTtcbiAgICBHcmFwaFJ1bm5lci5wcm90b3R5cGUudHJhaW5OZXR3b3JrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5iYXRjaGVzVHJhaW5lZFRoaXNSdW4gPT09IHRoaXMuY3VycmVudFRyYWluTG9vcE51bUJhdGNoZXMpIHtcbiAgICAgICAgICAgIHRoaXMuc3RvcFRyYWluaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmlzVHJhaW5pbmcpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmV2ZW50T2JzZXJ2ZXIuZG9uZVRyYWluaW5nQ2FsbGJhY2sgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRPYnNlcnZlci5kb25lVHJhaW5pbmdDYWxsYmFjaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdGFydCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICB2YXIgc2hvdWxkQ29tcHV0ZUNvc3QgPSB0aGlzLmV2ZW50T2JzZXJ2ZXIuYXZnQ29zdENhbGxiYWNrICE9IG51bGwgJiZcbiAgICAgICAgICAgIChzdGFydCAtIHRoaXMubGFzdENvc3RUaW1lc3RhbXAgPiB0aGlzLmNvc3RJbnRlcnZhbE1zKTtcbiAgICAgICAgaWYgKHNob3VsZENvbXB1dGVDb3N0KSB7XG4gICAgICAgICAgICB0aGlzLmxhc3RDb3N0VGltZXN0YW1wID0gc3RhcnQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNvc3RSZWR1Y3Rpb24gPSBzaG91bGRDb21wdXRlQ29zdCA/IHNlc3Npb25fMS5Db3N0UmVkdWN0aW9uLk1FQU4gOiBzZXNzaW9uXzEuQ29zdFJlZHVjdGlvbi5OT05FO1xuICAgICAgICB0aGlzLm1hdGguc2NvcGUoZnVuY3Rpb24gKGtlZXApIHtcbiAgICAgICAgICAgIHZhciBhdmdDb3N0ID0gX3RoaXMuc2Vzc2lvbi50cmFpbihfdGhpcy5jb3N0VGVuc29yLCBfdGhpcy50cmFpbkZlZWRFbnRyaWVzLCBfdGhpcy5iYXRjaFNpemUsIF90aGlzLm9wdGltaXplciwgY29zdFJlZHVjdGlvbik7XG4gICAgICAgICAgICBpZiAoc2hvdWxkQ29tcHV0ZUNvc3QpIHtcbiAgICAgICAgICAgICAgICB2YXIgdHJhaW5UaW1lID0gcGVyZm9ybWFuY2Uubm93KCkgLSBzdGFydDtcbiAgICAgICAgICAgICAgICBfdGhpcy5ldmVudE9ic2VydmVyLmF2Z0Nvc3RDYWxsYmFjayhhdmdDb3N0KTtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuZXZlbnRPYnNlcnZlci50cmFpbkV4YW1wbGVzUGVyU2VjQ2FsbGJhY2sgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZXhhbXBsZXNQZXJTZWMgPSAoX3RoaXMuYmF0Y2hTaXplICogMTAwMCAvIHRyYWluVGltZSk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmV2ZW50T2JzZXJ2ZXIudHJhaW5FeGFtcGxlc1BlclNlY0NhbGxiYWNrKGV4YW1wbGVzUGVyU2VjKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoX3RoaXMuZXZlbnRPYnNlcnZlci5tZXRyaWNDYWxsYmFjayAhPSBudWxsICYmXG4gICAgICAgICAgICAgICAgX3RoaXMubWV0cmljRmVlZEVudHJpZXMgIT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgIHN0YXJ0IC0gX3RoaXMubGFzdEV2YWxUaW1lc3RhbXAgPiBfdGhpcy5tZXRyaWNJbnRlcnZhbE1zKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMubGFzdEV2YWxUaW1lc3RhbXAgPSBzdGFydDtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMubGFzdENvbXB1dGVkTWV0cmljICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMubGFzdENvbXB1dGVkTWV0cmljLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX3RoaXMubGFzdENvbXB1dGVkTWV0cmljID0gX3RoaXMuY29tcHV0ZU1ldHJpYygpO1xuICAgICAgICAgICAgICAgIF90aGlzLmV2ZW50T2JzZXJ2ZXIubWV0cmljQ2FsbGJhY2soX3RoaXMubGFzdENvbXB1dGVkTWV0cmljKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChfdGhpcy5ldmVudE9ic2VydmVyLnRvdGFsVGltZUNhbGxiYWNrICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5ldmVudE9ic2VydmVyLnRvdGFsVGltZUNhbGxiYWNrKChzdGFydCAtIF90aGlzLnRyYWluU3RhcnRUaW1lc3RhbXApIC8gMTAwMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy5iYXRjaGVzVHJhaW5lZFRoaXNSdW4rKztcbiAgICAgICAgICAgIF90aGlzLnRvdGFsQmF0Y2hlc1RyYWluZWQrKztcbiAgICAgICAgICAgIGlmIChfdGhpcy5ldmVudE9ic2VydmVyLmJhdGNoZXNUcmFpbmVkQ2FsbGJhY2sgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmV2ZW50T2JzZXJ2ZXIuYmF0Y2hlc1RyYWluZWRDYWxsYmFjayhfdGhpcy50b3RhbEJhdGNoZXNUcmFpbmVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy50cmFpbk5ldHdvcmsoKTsgfSk7XG4gICAgfTtcbiAgICBHcmFwaFJ1bm5lci5wcm90b3R5cGUuaW5mZXIgPSBmdW5jdGlvbiAoaW5mZXJlbmNlVGVuc29yLCBpbmZlcmVuY2VGZWVkRW50cmllcywgaW5mZXJlbmNlRXhhbXBsZUludGVydmFsTXMsIGluZmVyZW5jZUV4YW1wbGVDb3VudCwgbnVtUGFzc2VzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChpbmZlcmVuY2VFeGFtcGxlSW50ZXJ2YWxNcyA9PT0gdm9pZCAwKSB7IGluZmVyZW5jZUV4YW1wbGVJbnRlcnZhbE1zID0gREVGQVVMVF9JTkZFUkVOQ0VfRVhBTVBMRV9JTlRFUlZBTF9NUzsgfVxuICAgICAgICBpZiAoaW5mZXJlbmNlRXhhbXBsZUNvdW50ID09PSB2b2lkIDApIHsgaW5mZXJlbmNlRXhhbXBsZUNvdW50ID0gNTsgfVxuICAgICAgICBpZiAodGhpcy5ldmVudE9ic2VydmVyLmluZmVyZW5jZUV4YW1wbGVzQ2FsbGJhY2sgPT0gbnVsbCAmJlxuICAgICAgICAgICAgdGhpcy5ldmVudE9ic2VydmVyLmluZmVyZW5jZUV4YW1wbGVzUGVyU2VjQ2FsbGJhY2sgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3Qgc3RhcnQgaW5mZXJlbmNlIGxvb3AsIG5vIGluZmVyZW5jZSBleGFtcGxlIG9yICcgK1xuICAgICAgICAgICAgICAgICdleGFtcGxlcy9zZWMgb2JzZXJ2ZXIgcHJvdmlkZWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbmZlcmVuY2VGZWVkRW50cmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGZlZWRFbnRyeSA9IGluZmVyZW5jZUZlZWRFbnRyaWVzW2ldO1xuICAgICAgICAgICAgaWYgKGZlZWRFbnRyeS5kYXRhIGluc3RhbmNlb2YgbmRhcnJheV8xLk5EQXJyYXkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBzdGFydCBpbmZlcmVuY2Ugb24gdGhlIG1vZGVsIHJ1bm5lciB3aXRoIGZlZWQgZW50cmllcyBvZiAnICtcbiAgICAgICAgICAgICAgICAgICAgJ3R5cGUgTkRBcnJheS4gUGxlYXNlIHVzZSBJbnB1dFByb3ZpZGVycy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmluZmVyZW5jZUV4YW1wbGVJbnRlcnZhbE1zID0gaW5mZXJlbmNlRXhhbXBsZUludGVydmFsTXM7XG4gICAgICAgIHRoaXMuaW5mZXJlbmNlVGVuc29yID0gaW5mZXJlbmNlVGVuc29yO1xuICAgICAgICB0aGlzLmluZmVyZW5jZUZlZWRFbnRyaWVzID0gaW5mZXJlbmNlRmVlZEVudHJpZXM7XG4gICAgICAgIHRoaXMuaW5mZXJlbmNlRXhhbXBsZUNvdW50ID0gaW5mZXJlbmNlRXhhbXBsZUNvdW50O1xuICAgICAgICB0aGlzLmN1cnJlbnRJbmZlcmVuY2VMb29wTnVtUGFzc2VzID0gbnVtUGFzc2VzO1xuICAgICAgICBpZiAoIXRoaXMuaXNJbmZlcnJpbmcpIHtcbiAgICAgICAgICAgIHRoaXMuaW5mZXJlbmNlUGFzc2VzVGhpc1J1biA9IDA7XG4gICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuaW5mZXJOZXR3b3JrKCk7IH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXNJbmZlcnJpbmcgPSB0cnVlO1xuICAgIH07XG4gICAgR3JhcGhSdW5uZXIucHJvdG90eXBlLmluZmVyTmV0d29yayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCF0aGlzLmlzSW5mZXJyaW5nIHx8XG4gICAgICAgICAgICB0aGlzLmluZmVyZW5jZVBhc3Nlc1RoaXNSdW4gPT09IHRoaXMuY3VycmVudEluZmVyZW5jZUxvb3BOdW1QYXNzZXMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1hdGguc2NvcGUoZnVuY3Rpb24gKGtlZXAsIHRyYWNrKSB7XG4gICAgICAgICAgICB2YXIgZmVlZHMgPSBbXTtcbiAgICAgICAgICAgIHZhciBpbmZlcmVuY2VWYWx1ZXMgPSBbXTtcbiAgICAgICAgICAgIHZhciBzdGFydCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBfdGhpcy5pbmZlcmVuY2VFeGFtcGxlQ291bnQ7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBuZGFycmF5RmVlZEVudHJpZXMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IF90aGlzLmluZmVyZW5jZUZlZWRFbnRyaWVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmZWVkRW50cnkgPSBfdGhpcy5pbmZlcmVuY2VGZWVkRW50cmllc1tqXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5leHRDb3B5ID0gZmVlZEVudHJ5LmRhdGEuZ2V0TmV4dENvcHkoX3RoaXMubWF0aCk7XG4gICAgICAgICAgICAgICAgICAgIG5kYXJyYXlGZWVkRW50cmllcy5wdXNoKHsgdGVuc29yOiBmZWVkRW50cnkudGVuc29yLCBkYXRhOiB0cmFjayhuZXh0Q29weSkgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZlZWRzLnB1c2gobmRhcnJheUZlZWRFbnRyaWVzKTtcbiAgICAgICAgICAgICAgICBpbmZlcmVuY2VWYWx1ZXMucHVzaChfdGhpcy5zZXNzaW9uLmV2YWwoX3RoaXMuaW5mZXJlbmNlVGVuc29yLCBuZGFycmF5RmVlZEVudHJpZXMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChfdGhpcy5ldmVudE9ic2VydmVyLmluZmVyZW5jZUV4YW1wbGVzUGVyU2VjQ2FsbGJhY2sgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGluZmVyZW5jZVZhbHVlc1tpbmZlcmVuY2VWYWx1ZXMubGVuZ3RoIC0gMV0uZ2V0VmFsdWVzKCk7XG4gICAgICAgICAgICAgICAgdmFyIGluZmVyZW5jZUV4YW1wbGVzUGVyU2VjVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpIC0gc3RhcnQ7XG4gICAgICAgICAgICAgICAgdmFyIGV4YW1wbGVzUGVyU2VjID0gKF90aGlzLmluZmVyZW5jZUV4YW1wbGVDb3VudCAqIDEwMDAgLyBpbmZlcmVuY2VFeGFtcGxlc1BlclNlY1RpbWUpO1xuICAgICAgICAgICAgICAgIF90aGlzLmV2ZW50T2JzZXJ2ZXIuaW5mZXJlbmNlRXhhbXBsZXNQZXJTZWNDYWxsYmFjayhleGFtcGxlc1BlclNlYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoX3RoaXMuZXZlbnRPYnNlcnZlci5pbmZlcmVuY2VFeGFtcGxlc0NhbGxiYWNrICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5ldmVudE9ic2VydmVyLmluZmVyZW5jZUV4YW1wbGVzQ2FsbGJhY2soZmVlZHMsIGluZmVyZW5jZVZhbHVlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy5pbmZlcmVuY2VQYXNzZXNUaGlzUnVuKys7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmxhc3RJbmZlclRpbWVvdXRJRCA9IHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmluZmVyTmV0d29yaygpOyB9LCB0aGlzLmluZmVyZW5jZUV4YW1wbGVJbnRlcnZhbE1zKTtcbiAgICB9O1xuICAgIEdyYXBoUnVubmVyLnByb3RvdHlwZS5zdG9wSW5mZXJyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmlzSW5mZXJyaW5nID0gZmFsc2U7XG4gICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGhpcy5sYXN0SW5mZXJUaW1lb3V0SUQpO1xuICAgIH07XG4gICAgR3JhcGhSdW5uZXIucHJvdG90eXBlLmlzSW5mZXJlbmNlUnVubmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNJbmZlcnJpbmc7XG4gICAgfTtcbiAgICBHcmFwaFJ1bm5lci5wcm90b3R5cGUuY29tcHV0ZU1ldHJpYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMubWV0cmljRmVlZEVudHJpZXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgY29tcHV0ZSBtZXRyaWMsIG5vIG1ldHJpYyBGZWVkRW50cmllcyBwcm92aWRlZC4nKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbWV0cmljID0gdGhpcy56ZXJvU2NhbGFyO1xuICAgICAgICByZXR1cm4gdGhpcy5tYXRoLnNjb3BlKGZ1bmN0aW9uIChrZWVwKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IF90aGlzLm1ldHJpY0JhdGNoU2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1ldHJpY1ZhbHVlID0gX3RoaXMuc2Vzc2lvbi5ldmFsKF90aGlzLm1ldHJpY1RlbnNvciwgX3RoaXMubWV0cmljRmVlZEVudHJpZXMpO1xuICAgICAgICAgICAgICAgIG1ldHJpYyA9IF90aGlzLm1hdGguYWRkKG1ldHJpYywgbWV0cmljVmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKF90aGlzLm1ldHJpY1JlZHVjdGlvbiA9PT0gTWV0cmljUmVkdWN0aW9uLk1FQU4pIHtcbiAgICAgICAgICAgICAgICBtZXRyaWMgPSBfdGhpcy5tYXRoLmRpdmlkZShtZXRyaWMsIF90aGlzLm1ldHJpY0JhdGNoU2l6ZVNjYWxhcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWV0cmljO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEdyYXBoUnVubmVyLnByb3RvdHlwZS5nZXRUb3RhbEJhdGNoZXNUcmFpbmVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b3RhbEJhdGNoZXNUcmFpbmVkO1xuICAgIH07XG4gICAgR3JhcGhSdW5uZXIucHJvdG90eXBlLmdldExhc3RDb21wdXRlZE1ldHJpYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGFzdENvbXB1dGVkTWV0cmljO1xuICAgIH07XG4gICAgR3JhcGhSdW5uZXIucHJvdG90eXBlLnNldE1hdGggPSBmdW5jdGlvbiAobWF0aCkge1xuICAgICAgICB0aGlzLm1hdGggPSBtYXRoO1xuICAgIH07XG4gICAgR3JhcGhSdW5uZXIucHJvdG90eXBlLnNldFNlc3Npb24gPSBmdW5jdGlvbiAoc2Vzc2lvbikge1xuICAgICAgICB0aGlzLnNlc3Npb24gPSBzZXNzaW9uO1xuICAgIH07XG4gICAgR3JhcGhSdW5uZXIucHJvdG90eXBlLnNldEluZmVyZW5jZVRlbnNvciA9IGZ1bmN0aW9uIChpbmZlcmVuY2VUZW5zb3IpIHtcbiAgICAgICAgdGhpcy5pbmZlcmVuY2VUZW5zb3IgPSBpbmZlcmVuY2VUZW5zb3I7XG4gICAgfTtcbiAgICBHcmFwaFJ1bm5lci5wcm90b3R5cGUuc2V0SW5mZXJlbmNlRXhhbXBsZUNvdW50ID0gZnVuY3Rpb24gKGluZmVyZW5jZUV4YW1wbGVDb3VudCkge1xuICAgICAgICB0aGlzLmluZmVyZW5jZUV4YW1wbGVDb3VudCA9IGluZmVyZW5jZUV4YW1wbGVDb3VudDtcbiAgICB9O1xuICAgIHJldHVybiBHcmFwaFJ1bm5lcjtcbn0oKSk7XG5leHBvcnRzLkdyYXBoUnVubmVyID0gR3JhcGhSdW5uZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ncmFwaF9ydW5uZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgeGhyX2RhdGFzZXQgPSByZXF1aXJlKFwiLi9kYXRhL3hoci1kYXRhc2V0XCIpO1xuZXhwb3J0cy54aHJfZGF0YXNldCA9IHhocl9kYXRhc2V0O1xudmFyIGVudmlyb25tZW50ID0gcmVxdWlyZShcIi4vZW52aXJvbm1lbnRcIik7XG5leHBvcnRzLmVudmlyb25tZW50ID0gZW52aXJvbm1lbnQ7XG52YXIgY29udl91dGlsID0gcmVxdWlyZShcIi4vbWF0aC9jb252X3V0aWxcIik7XG5leHBvcnRzLmNvbnZfdXRpbCA9IGNvbnZfdXRpbDtcbnZhciBncGdwdV91dGlsID0gcmVxdWlyZShcIi4vbWF0aC93ZWJnbC9ncGdwdV91dGlsXCIpO1xuZXhwb3J0cy5ncGdwdV91dGlsID0gZ3BncHVfdXRpbDtcbnZhciByZW5kZXJfbmRhcnJheV9ncHVfdXRpbCA9IHJlcXVpcmUoXCIuL21hdGgvd2ViZ2wvcmVuZGVyX25kYXJyYXlfZ3B1X3V0aWxcIik7XG5leHBvcnRzLnJlbmRlcl9uZGFycmF5X2dwdV91dGlsID0gcmVuZGVyX25kYXJyYXlfZ3B1X3V0aWw7XG52YXIgd2ViZ2xfdXRpbCA9IHJlcXVpcmUoXCIuL21hdGgvd2ViZ2wvd2ViZ2xfdXRpbFwiKTtcbmV4cG9ydHMud2ViZ2xfdXRpbCA9IHdlYmdsX3V0aWw7XG52YXIgdGVzdF91dGlsID0gcmVxdWlyZShcIi4vdGVzdF91dGlsXCIpO1xuZXhwb3J0cy50ZXN0X3V0aWwgPSB0ZXN0X3V0aWw7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG5leHBvcnRzLnV0aWwgPSB1dGlsO1xudmFyIHZlcnNpb25fMSA9IHJlcXVpcmUoXCIuL3ZlcnNpb25cIik7XG5leHBvcnRzLnZlcnNpb24gPSB2ZXJzaW9uXzEudmVyc2lvbjtcbnZhciBjaGVja3BvaW50X2xvYWRlcl8xID0gcmVxdWlyZShcIi4vZGF0YS9jaGVja3BvaW50X2xvYWRlclwiKTtcbmV4cG9ydHMuQ2hlY2twb2ludExvYWRlciA9IGNoZWNrcG9pbnRfbG9hZGVyXzEuQ2hlY2twb2ludExvYWRlcjtcbnZhciBkYXRhc2V0XzEgPSByZXF1aXJlKFwiLi9kYXRhL2RhdGFzZXRcIik7XG5leHBvcnRzLkluTWVtb3J5RGF0YXNldCA9IGRhdGFzZXRfMS5Jbk1lbW9yeURhdGFzZXQ7XG52YXIgaW5wdXRfcHJvdmlkZXJfMSA9IHJlcXVpcmUoXCIuL2RhdGEvaW5wdXRfcHJvdmlkZXJcIik7XG5leHBvcnRzLkluQ1BVTWVtb3J5U2h1ZmZsZWRJbnB1dFByb3ZpZGVyQnVpbGRlciA9IGlucHV0X3Byb3ZpZGVyXzEuSW5DUFVNZW1vcnlTaHVmZmxlZElucHV0UHJvdmlkZXJCdWlsZGVyO1xuZXhwb3J0cy5JbkdQVU1lbW9yeVNodWZmbGVkSW5wdXRQcm92aWRlckJ1aWxkZXIgPSBpbnB1dF9wcm92aWRlcl8xLkluR1BVTWVtb3J5U2h1ZmZsZWRJbnB1dFByb3ZpZGVyQnVpbGRlcjtcbnZhciB4aHJfZGF0YXNldF8xID0gcmVxdWlyZShcIi4vZGF0YS94aHItZGF0YXNldFwiKTtcbmV4cG9ydHMuWGhyRGF0YXNldCA9IHhocl9kYXRhc2V0XzEuWGhyRGF0YXNldDtcbnZhciBlbnZpcm9ubWVudF8xID0gcmVxdWlyZShcIi4vZW52aXJvbm1lbnRcIik7XG5leHBvcnRzLkVOViA9IGVudmlyb25tZW50XzEuRU5WO1xuZXhwb3J0cy5FbnZpcm9ubWVudCA9IGVudmlyb25tZW50XzEuRW52aXJvbm1lbnQ7XG52YXIgZ3JhcGhfMSA9IHJlcXVpcmUoXCIuL2dyYXBoL2dyYXBoXCIpO1xuZXhwb3J0cy5HcmFwaCA9IGdyYXBoXzEuR3JhcGg7XG5leHBvcnRzLlRlbnNvciA9IGdyYXBoXzEuVGVuc29yO1xudmFyIGFkYWRlbHRhX29wdGltaXplcl8xID0gcmVxdWlyZShcIi4vZ3JhcGgvb3B0aW1pemVycy9hZGFkZWx0YV9vcHRpbWl6ZXJcIik7XG5leHBvcnRzLkFkYWRlbHRhT3B0aW1pemVyID0gYWRhZGVsdGFfb3B0aW1pemVyXzEuQWRhZGVsdGFPcHRpbWl6ZXI7XG52YXIgYWRhZ3JhZF9vcHRpbWl6ZXJfMSA9IHJlcXVpcmUoXCIuL2dyYXBoL29wdGltaXplcnMvYWRhZ3JhZF9vcHRpbWl6ZXJcIik7XG5leHBvcnRzLkFkYWdyYWRPcHRpbWl6ZXIgPSBhZGFncmFkX29wdGltaXplcl8xLkFkYWdyYWRPcHRpbWl6ZXI7XG52YXIgYWRhbV9vcHRpbWl6ZXJfMSA9IHJlcXVpcmUoXCIuL2dyYXBoL29wdGltaXplcnMvYWRhbV9vcHRpbWl6ZXJcIik7XG5leHBvcnRzLkFkYW1PcHRpbWl6ZXIgPSBhZGFtX29wdGltaXplcl8xLkFkYW1PcHRpbWl6ZXI7XG52YXIgYWRhbWF4X29wdGltaXplcl8xID0gcmVxdWlyZShcIi4vZ3JhcGgvb3B0aW1pemVycy9hZGFtYXhfb3B0aW1pemVyXCIpO1xuZXhwb3J0cy5BZGFtYXhPcHRpbWl6ZXIgPSBhZGFtYXhfb3B0aW1pemVyXzEuQWRhbWF4T3B0aW1pemVyO1xudmFyIG1vbWVudHVtX29wdGltaXplcl8xID0gcmVxdWlyZShcIi4vZ3JhcGgvb3B0aW1pemVycy9tb21lbnR1bV9vcHRpbWl6ZXJcIik7XG5leHBvcnRzLk1vbWVudHVtT3B0aW1pemVyID0gbW9tZW50dW1fb3B0aW1pemVyXzEuTW9tZW50dW1PcHRpbWl6ZXI7XG52YXIgb3B0aW1pemVyXzEgPSByZXF1aXJlKFwiLi9ncmFwaC9vcHRpbWl6ZXJzL29wdGltaXplclwiKTtcbmV4cG9ydHMuT3B0aW1pemVyID0gb3B0aW1pemVyXzEuT3B0aW1pemVyO1xudmFyIHJtc3Byb3Bfb3B0aW1pemVyXzEgPSByZXF1aXJlKFwiLi9ncmFwaC9vcHRpbWl6ZXJzL3Jtc3Byb3Bfb3B0aW1pemVyXCIpO1xuZXhwb3J0cy5STVNQcm9wT3B0aW1pemVyID0gcm1zcHJvcF9vcHRpbWl6ZXJfMS5STVNQcm9wT3B0aW1pemVyO1xudmFyIHNnZF9vcHRpbWl6ZXJfMSA9IHJlcXVpcmUoXCIuL2dyYXBoL29wdGltaXplcnMvc2dkX29wdGltaXplclwiKTtcbmV4cG9ydHMuU0dET3B0aW1pemVyID0gc2dkX29wdGltaXplcl8xLlNHRE9wdGltaXplcjtcbnZhciBzZXNzaW9uXzEgPSByZXF1aXJlKFwiLi9ncmFwaC9zZXNzaW9uXCIpO1xuZXhwb3J0cy5Db3N0UmVkdWN0aW9uID0gc2Vzc2lvbl8xLkNvc3RSZWR1Y3Rpb247XG5leHBvcnRzLlNlc3Npb24gPSBzZXNzaW9uXzEuU2Vzc2lvbjtcbnZhciBncmFwaF9ydW5uZXJfMSA9IHJlcXVpcmUoXCIuL2dyYXBoX3J1bm5lclwiKTtcbmV4cG9ydHMuR3JhcGhSdW5uZXIgPSBncmFwaF9ydW5uZXJfMS5HcmFwaFJ1bm5lcjtcbmV4cG9ydHMuTWV0cmljUmVkdWN0aW9uID0gZ3JhcGhfcnVubmVyXzEuTWV0cmljUmVkdWN0aW9uO1xudmFyIGluaXRpYWxpemVyc18xID0gcmVxdWlyZShcIi4vaW5pdGlhbGl6ZXJzXCIpO1xuZXhwb3J0cy5Db25zdGFudEluaXRpYWxpemVyID0gaW5pdGlhbGl6ZXJzXzEuQ29uc3RhbnRJbml0aWFsaXplcjtcbmV4cG9ydHMuTkRBcnJheUluaXRpYWxpemVyID0gaW5pdGlhbGl6ZXJzXzEuTkRBcnJheUluaXRpYWxpemVyO1xuZXhwb3J0cy5PbmVzSW5pdGlhbGl6ZXIgPSBpbml0aWFsaXplcnNfMS5PbmVzSW5pdGlhbGl6ZXI7XG5leHBvcnRzLlJhbmRvbU5vcm1hbEluaXRpYWxpemVyID0gaW5pdGlhbGl6ZXJzXzEuUmFuZG9tTm9ybWFsSW5pdGlhbGl6ZXI7XG5leHBvcnRzLlJhbmRvbVRydW5jYXRlZE5vcm1hbEluaXRpYWxpemVyID0gaW5pdGlhbGl6ZXJzXzEuUmFuZG9tVHJ1bmNhdGVkTm9ybWFsSW5pdGlhbGl6ZXI7XG5leHBvcnRzLlJhbmRvbVVuaWZvcm1Jbml0aWFsaXplciA9IGluaXRpYWxpemVyc18xLlJhbmRvbVVuaWZvcm1Jbml0aWFsaXplcjtcbmV4cG9ydHMuVmFyaWFuY2VTY2FsaW5nSW5pdGlhbGl6ZXIgPSBpbml0aWFsaXplcnNfMS5WYXJpYW5jZVNjYWxpbmdJbml0aWFsaXplcjtcbmV4cG9ydHMuWmVyb3NJbml0aWFsaXplciA9IGluaXRpYWxpemVyc18xLlplcm9zSW5pdGlhbGl6ZXI7XG52YXIgbWF0aF8xID0gcmVxdWlyZShcIi4vbWF0aC9tYXRoXCIpO1xuZXhwb3J0cy5NYXRyaXhPcmllbnRhdGlvbiA9IG1hdGhfMS5NYXRyaXhPcmllbnRhdGlvbjtcbmV4cG9ydHMuTkRBcnJheU1hdGggPSBtYXRoXzEuTkRBcnJheU1hdGg7XG52YXIgbWF0aF9jcHVfMSA9IHJlcXVpcmUoXCIuL21hdGgvbWF0aF9jcHVcIik7XG5leHBvcnRzLk5EQXJyYXlNYXRoQ1BVID0gbWF0aF9jcHVfMS5OREFycmF5TWF0aENQVTtcbnZhciBtYXRoX2dwdV8xID0gcmVxdWlyZShcIi4vbWF0aC9tYXRoX2dwdVwiKTtcbmV4cG9ydHMuTkRBcnJheU1hdGhHUFUgPSBtYXRoX2dwdV8xLk5EQXJyYXlNYXRoR1BVO1xudmFyIG5kYXJyYXlfMSA9IHJlcXVpcmUoXCIuL21hdGgvbmRhcnJheVwiKTtcbmV4cG9ydHMuaW5pdGlhbGl6ZUdQVSA9IG5kYXJyYXlfMS5pbml0aWFsaXplR1BVO1xudmFyIG5kYXJyYXlfMiA9IHJlcXVpcmUoXCIuL21hdGgvbmRhcnJheVwiKTtcbmV4cG9ydHMuQXJyYXkxRCA9IG5kYXJyYXlfMi5BcnJheTFEO1xuZXhwb3J0cy5BcnJheTJEID0gbmRhcnJheV8yLkFycmF5MkQ7XG5leHBvcnRzLkFycmF5M0QgPSBuZGFycmF5XzIuQXJyYXkzRDtcbmV4cG9ydHMuQXJyYXk0RCA9IG5kYXJyYXlfMi5BcnJheTREO1xuZXhwb3J0cy5OREFycmF5ID0gbmRhcnJheV8yLk5EQXJyYXk7XG5leHBvcnRzLlNjYWxhciA9IG5kYXJyYXlfMi5TY2FsYXI7XG52YXIgZ3BncHVfY29udGV4dF8xID0gcmVxdWlyZShcIi4vbWF0aC93ZWJnbC9ncGdwdV9jb250ZXh0XCIpO1xuZXhwb3J0cy5HUEdQVUNvbnRleHQgPSBncGdwdV9jb250ZXh0XzEuR1BHUFVDb250ZXh0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgbmRhcnJheV8xID0gcmVxdWlyZShcIi4vbWF0aC9uZGFycmF5XCIpO1xudmFyIFZhcmlhbmNlU2NhbGluZ0luaXRpYWxpemVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBWYXJpYW5jZVNjYWxpbmdJbml0aWFsaXplcihzY2FsZSwgbW9kZSwgZGlzdHJpYnV0aW9uKSB7XG4gICAgICAgIGlmIChzY2FsZSA9PT0gdm9pZCAwKSB7IHNjYWxlID0gMS4wOyB9XG4gICAgICAgIGlmIChtb2RlID09PSB2b2lkIDApIHsgbW9kZSA9ICdmYW5faW4nOyB9XG4gICAgICAgIGlmIChkaXN0cmlidXRpb24gPT09IHZvaWQgMCkgeyBkaXN0cmlidXRpb24gPSAnbm9ybWFsJzsgfVxuICAgICAgICB0aGlzLnNjYWxlID0gc2NhbGU7XG4gICAgICAgIHRoaXMubW9kZSA9IG1vZGU7XG4gICAgICAgIHRoaXMuZGlzdHJpYnV0aW9uID0gZGlzdHJpYnV0aW9uO1xuICAgIH1cbiAgICBWYXJpYW5jZVNjYWxpbmdJbml0aWFsaXplci5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uICh3ZWlnaHRzU2hhcGUsIGlucHV0VW5pdHMsIG91dHB1dFVuaXRzKSB7XG4gICAgICAgIHZhciBuID0gMDtcbiAgICAgICAgaWYgKHRoaXMubW9kZSA9PT0gJ2Zhbl9pbicpIHtcbiAgICAgICAgICAgIG4gPSBpbnB1dFVuaXRzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMubW9kZSA9PT0gJ2Zhbl9vdXQnKSB7XG4gICAgICAgICAgICBuID0gb3V0cHV0VW5pdHM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5tb2RlID09PSAnZmFuX2F2ZycpIHtcbiAgICAgICAgICAgIG4gPSAoaW5wdXRVbml0cyArIG91dHB1dFVuaXRzKSAvIDI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIG1vZGUgZm9yIHZhcmlhbmNlIHNjYWxpbmcgaW5pdGlhbGl6ZXI6IFwiICsgdGhpcy5tb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5kaXN0cmlidXRpb24gPT09ICdub3JtYWwnKSB7XG4gICAgICAgICAgICByZXR1cm4gbmRhcnJheV8xLk5EQXJyYXkucmFuZFRydW5jYXRlZE5vcm1hbCh3ZWlnaHRzU2hhcGUsIDAuMCwgTWF0aC5zcXJ0KHRoaXMuc2NhbGUgLyBuKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5kaXN0cmlidXRpb24gPT09ICd1bmlmb3JtJykge1xuICAgICAgICAgICAgcmV0dXJuIG5kYXJyYXlfMS5OREFycmF5LnJhbmRVbmlmb3JtKHdlaWdodHNTaGFwZSwgMC4wLCBNYXRoLnNxcnQoMyAqIHRoaXMuc2NhbGUgLyBuKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIGRpc3RyaWJ1dGlvbiBmb3IgdmFyaWFuY2Ugc2NhbGluZyBpbml0aWFsaXplcjogXCIgK1xuICAgICAgICAgICAgICAgIChcIlwiICsgdGhpcy5kaXN0cmlidXRpb24pKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFZhcmlhbmNlU2NhbGluZ0luaXRpYWxpemVyO1xufSgpKTtcbmV4cG9ydHMuVmFyaWFuY2VTY2FsaW5nSW5pdGlhbGl6ZXIgPSBWYXJpYW5jZVNjYWxpbmdJbml0aWFsaXplcjtcbnZhciBaZXJvc0luaXRpYWxpemVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBaZXJvc0luaXRpYWxpemVyKCkge1xuICAgIH1cbiAgICBaZXJvc0luaXRpYWxpemVyLnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gKHdlaWdodHNTaGFwZSwgaW5wdXRVbml0cywgb3V0cHV0VW5pdHMpIHtcbiAgICAgICAgcmV0dXJuIG5kYXJyYXlfMS5OREFycmF5Lnplcm9zKHdlaWdodHNTaGFwZSk7XG4gICAgfTtcbiAgICByZXR1cm4gWmVyb3NJbml0aWFsaXplcjtcbn0oKSk7XG5leHBvcnRzLlplcm9zSW5pdGlhbGl6ZXIgPSBaZXJvc0luaXRpYWxpemVyO1xudmFyIE9uZXNJbml0aWFsaXplciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gT25lc0luaXRpYWxpemVyKCkge1xuICAgIH1cbiAgICBPbmVzSW5pdGlhbGl6ZXIucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAod2VpZ2h0c1NoYXBlLCBpbnB1dFVuaXRzLCBvdXRwdXRVbml0cykge1xuICAgICAgICB2YXIgdmFsdWVzID0gbmRhcnJheV8xLk5EQXJyYXkuemVyb3Mod2VpZ2h0c1NoYXBlKTtcbiAgICAgICAgdmFsdWVzLmZpbGwoMSk7XG4gICAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgfTtcbiAgICByZXR1cm4gT25lc0luaXRpYWxpemVyO1xufSgpKTtcbmV4cG9ydHMuT25lc0luaXRpYWxpemVyID0gT25lc0luaXRpYWxpemVyO1xudmFyIENvbnN0YW50SW5pdGlhbGl6ZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENvbnN0YW50SW5pdGlhbGl6ZXIodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlID09PSB2b2lkIDApIHsgdmFsdWUgPSAwOyB9XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gICAgQ29uc3RhbnRJbml0aWFsaXplci5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uICh3ZWlnaHRzU2hhcGUsIGlucHV0VW5pdHMsIG91dHB1dFVuaXRzKSB7XG4gICAgICAgIHZhciB2YWx1ZXMgPSBuZGFycmF5XzEuTkRBcnJheS56ZXJvcyh3ZWlnaHRzU2hhcGUpO1xuICAgICAgICB2YWx1ZXMuZmlsbCh0aGlzLnZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICB9O1xuICAgIHJldHVybiBDb25zdGFudEluaXRpYWxpemVyO1xufSgpKTtcbmV4cG9ydHMuQ29uc3RhbnRJbml0aWFsaXplciA9IENvbnN0YW50SW5pdGlhbGl6ZXI7XG52YXIgTkRBcnJheUluaXRpYWxpemVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBOREFycmF5SW5pdGlhbGl6ZXIobmRhcnJheSkge1xuICAgICAgICB0aGlzLm5kYXJyYXkgPSBuZGFycmF5O1xuICAgIH1cbiAgICBOREFycmF5SW5pdGlhbGl6ZXIucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAod2VpZ2h0c1NoYXBlLCBpbnB1dFVuaXRzLCBvdXRwdXRVbml0cykge1xuICAgICAgICByZXR1cm4gdGhpcy5uZGFycmF5O1xuICAgIH07XG4gICAgcmV0dXJuIE5EQXJyYXlJbml0aWFsaXplcjtcbn0oKSk7XG5leHBvcnRzLk5EQXJyYXlJbml0aWFsaXplciA9IE5EQXJyYXlJbml0aWFsaXplcjtcbnZhciBSYW5kb21Ob3JtYWxJbml0aWFsaXplciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmFuZG9tTm9ybWFsSW5pdGlhbGl6ZXIobWVhbiwgc3RkZXYpIHtcbiAgICAgICAgaWYgKG1lYW4gPT09IHZvaWQgMCkgeyBtZWFuID0gMDsgfVxuICAgICAgICBpZiAoc3RkZXYgPT09IHZvaWQgMCkgeyBzdGRldiA9IC4wNTsgfVxuICAgICAgICB0aGlzLm1lYW4gPSBtZWFuO1xuICAgICAgICB0aGlzLnN0ZGV2ID0gc3RkZXY7XG4gICAgfVxuICAgIFJhbmRvbU5vcm1hbEluaXRpYWxpemVyLnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gKHdlaWdodHNTaGFwZSwgaW5wdXRVbml0cywgb3V0cHV0VW5pdHMpIHtcbiAgICAgICAgcmV0dXJuIG5kYXJyYXlfMS5OREFycmF5LnJhbmROb3JtYWwod2VpZ2h0c1NoYXBlLCB0aGlzLm1lYW4sIHRoaXMuc3RkZXYpO1xuICAgIH07XG4gICAgcmV0dXJuIFJhbmRvbU5vcm1hbEluaXRpYWxpemVyO1xufSgpKTtcbmV4cG9ydHMuUmFuZG9tTm9ybWFsSW5pdGlhbGl6ZXIgPSBSYW5kb21Ob3JtYWxJbml0aWFsaXplcjtcbnZhciBSYW5kb21UcnVuY2F0ZWROb3JtYWxJbml0aWFsaXplciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmFuZG9tVHJ1bmNhdGVkTm9ybWFsSW5pdGlhbGl6ZXIobWVhbiwgc3RkZXYpIHtcbiAgICAgICAgaWYgKG1lYW4gPT09IHZvaWQgMCkgeyBtZWFuID0gMDsgfVxuICAgICAgICBpZiAoc3RkZXYgPT09IHZvaWQgMCkgeyBzdGRldiA9IC4wNTsgfVxuICAgICAgICB0aGlzLm1lYW4gPSBtZWFuO1xuICAgICAgICB0aGlzLnN0ZGV2ID0gc3RkZXY7XG4gICAgfVxuICAgIFJhbmRvbVRydW5jYXRlZE5vcm1hbEluaXRpYWxpemVyLnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gKHdlaWdodHNTaGFwZSwgaW5wdXRVbml0cywgb3V0cHV0VW5pdHMpIHtcbiAgICAgICAgcmV0dXJuIG5kYXJyYXlfMS5OREFycmF5LnJhbmRUcnVuY2F0ZWROb3JtYWwod2VpZ2h0c1NoYXBlLCB0aGlzLm1lYW4sIHRoaXMuc3RkZXYpO1xuICAgIH07XG4gICAgcmV0dXJuIFJhbmRvbVRydW5jYXRlZE5vcm1hbEluaXRpYWxpemVyO1xufSgpKTtcbmV4cG9ydHMuUmFuZG9tVHJ1bmNhdGVkTm9ybWFsSW5pdGlhbGl6ZXIgPSBSYW5kb21UcnVuY2F0ZWROb3JtYWxJbml0aWFsaXplcjtcbnZhciBSYW5kb21Vbmlmb3JtSW5pdGlhbGl6ZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJhbmRvbVVuaWZvcm1Jbml0aWFsaXplcihtaW52YWwsIG1heHZhbCkge1xuICAgICAgICBpZiAobWludmFsID09PSB2b2lkIDApIHsgbWludmFsID0gLS4wNTsgfVxuICAgICAgICBpZiAobWF4dmFsID09PSB2b2lkIDApIHsgbWF4dmFsID0gLjA1OyB9XG4gICAgICAgIHRoaXMubWludmFsID0gbWludmFsO1xuICAgICAgICB0aGlzLm1heHZhbCA9IG1heHZhbDtcbiAgICB9XG4gICAgUmFuZG9tVW5pZm9ybUluaXRpYWxpemVyLnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gKHdlaWdodHNTaGFwZSwgaW5wdXRVbml0cywgb3V0cHV0VW5pdHMpIHtcbiAgICAgICAgcmV0dXJuIG5kYXJyYXlfMS5OREFycmF5LnJhbmRVbmlmb3JtKHdlaWdodHNTaGFwZSwgdGhpcy5taW52YWwsIHRoaXMubWF4dmFsKTtcbiAgICB9O1xuICAgIHJldHVybiBSYW5kb21Vbmlmb3JtSW5pdGlhbGl6ZXI7XG59KCkpO1xuZXhwb3J0cy5SYW5kb21Vbmlmb3JtSW5pdGlhbGl6ZXIgPSBSYW5kb21Vbmlmb3JtSW5pdGlhbGl6ZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbml0aWFsaXplcnMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgbmRhcnJheV8xID0gcmVxdWlyZShcIi4vbmRhcnJheVwiKTtcbnZhciBUYW5IRnVuYyA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVGFuSEZ1bmMoKSB7XG4gICAgfVxuICAgIFRhbkhGdW5jLnByb3RvdHlwZS5vdXRwdXQgPSBmdW5jdGlvbiAobWF0aCwgeCkge1xuICAgICAgICByZXR1cm4gbWF0aC5zY29wZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbWF0aC50YW5oKHgpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFRhbkhGdW5jLnByb3RvdHlwZS5kZXIgPSBmdW5jdGlvbiAobWF0aCwgeCwgeSkge1xuICAgICAgICByZXR1cm4gbWF0aC5zY29wZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgeVNxdWFyZWQgPSBtYXRoLmVsZW1lbnRXaXNlTXVsKHksIHkpO1xuICAgICAgICAgICAgcmV0dXJuIG1hdGguc2NhbGFyTWludXNBcnJheShuZGFycmF5XzEuU2NhbGFyLk9ORSwgeVNxdWFyZWQpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFRhbkhGdW5jLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgIHJldHVybiBUYW5IRnVuYztcbn0oKSk7XG5leHBvcnRzLlRhbkhGdW5jID0gVGFuSEZ1bmM7XG52YXIgUmVMVUZ1bmMgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJlTFVGdW5jKCkge1xuICAgIH1cbiAgICBSZUxVRnVuYy5wcm90b3R5cGUub3V0cHV0ID0gZnVuY3Rpb24gKG1hdGgsIHgpIHtcbiAgICAgICAgcmV0dXJuIG1hdGguc2NvcGUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG1hdGgucmVsdSh4KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBSZUxVRnVuYy5wcm90b3R5cGUuZGVyID0gZnVuY3Rpb24gKG1hdGgsIHgsIHkpIHtcbiAgICAgICAgcmV0dXJuIG1hdGguc2NvcGUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG1hdGguc3RlcCh4KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBSZUxVRnVuYy5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICByZXR1cm4gUmVMVUZ1bmM7XG59KCkpO1xuZXhwb3J0cy5SZUxVRnVuYyA9IFJlTFVGdW5jO1xudmFyIExlYWt5UmVsdUZ1bmMgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIExlYWt5UmVsdUZ1bmMoYWxwaGEpIHtcbiAgICAgICAgdGhpcy5hbHBoYSA9IGFscGhhO1xuICAgIH1cbiAgICBMZWFreVJlbHVGdW5jLnByb3RvdHlwZS5vdXRwdXQgPSBmdW5jdGlvbiAobWF0aCwgeCkge1xuICAgICAgICByZXR1cm4gbWF0aC5sZWFreVJlbHUoeCwgdGhpcy5hbHBoYSk7XG4gICAgfTtcbiAgICBMZWFreVJlbHVGdW5jLnByb3RvdHlwZS5kZXIgPSBmdW5jdGlvbiAobWF0aCwgeCwgeSkge1xuICAgICAgICByZXR1cm4gbWF0aC5zdGVwKHgsIHRoaXMuYWxwaGEpO1xuICAgIH07XG4gICAgTGVha3lSZWx1RnVuYy5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICByZXR1cm4gTGVha3lSZWx1RnVuYztcbn0oKSk7XG5leHBvcnRzLkxlYWt5UmVsdUZ1bmMgPSBMZWFreVJlbHVGdW5jO1xudmFyIFNpZ21vaWRGdW5jID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTaWdtb2lkRnVuYygpIHtcbiAgICB9XG4gICAgU2lnbW9pZEZ1bmMucHJvdG90eXBlLm91dHB1dCA9IGZ1bmN0aW9uIChtYXRoLCB4KSB7XG4gICAgICAgIHJldHVybiBtYXRoLnNjb3BlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBtYXRoLnNpZ21vaWQoeCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgU2lnbW9pZEZ1bmMucHJvdG90eXBlLmRlciA9IGZ1bmN0aW9uIChtYXRoLCB4LCB5KSB7XG4gICAgICAgIHJldHVybiBtYXRoLnNjb3BlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB5U3F1YXJlZCA9IG1hdGguZWxlbWVudFdpc2VNdWwoeSwgeSk7XG4gICAgICAgICAgICByZXR1cm4gbWF0aC5zdWJTdHJpY3QoeSwgeVNxdWFyZWQpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFNpZ21vaWRGdW5jLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgIHJldHVybiBTaWdtb2lkRnVuYztcbn0oKSk7XG5leHBvcnRzLlNpZ21vaWRGdW5jID0gU2lnbW9pZEZ1bmM7XG52YXIgU3F1YXJlRnVuYyA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU3F1YXJlRnVuYygpIHtcbiAgICB9XG4gICAgU3F1YXJlRnVuYy5wcm90b3R5cGUub3V0cHV0ID0gZnVuY3Rpb24gKG1hdGgsIHgpIHtcbiAgICAgICAgcmV0dXJuIG1hdGguc2NvcGUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG1hdGguZWxlbWVudFdpc2VNdWwoeCwgeCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgU3F1YXJlRnVuYy5wcm90b3R5cGUuZGVyID0gZnVuY3Rpb24gKG1hdGgsIHgsIHkpIHtcbiAgICAgICAgcmV0dXJuIG1hdGguc2NvcGUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG1hdGguc2NhbGFyVGltZXNBcnJheShuZGFycmF5XzEuU2NhbGFyLlRXTywgeCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgU3F1YXJlRnVuYy5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICByZXR1cm4gU3F1YXJlRnVuYztcbn0oKSk7XG5leHBvcnRzLlNxdWFyZUZ1bmMgPSBTcXVhcmVGdW5jO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWN0aXZhdGlvbl9mdW5jdGlvbnMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5mdW5jdGlvbiBheGVzQXJlSW5uZXJNb3N0RGltcyhheGVzLCByYW5rKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBheGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGlmIChheGVzW2F4ZXMubGVuZ3RoIC0gaSAtIDFdICE9PSByYW5rIC0gMSAtIGkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmV4cG9ydHMuYXhlc0FyZUlubmVyTW9zdERpbXMgPSBheGVzQXJlSW5uZXJNb3N0RGltcztcbmZ1bmN0aW9uIGNvbWJpbmVMb2NhdGlvbnMob3V0cHV0TG9jLCByZWR1Y2VMb2MsIGF4ZXMpIHtcbiAgICB2YXIgcmFuayA9IG91dHB1dExvYy5sZW5ndGggKyByZWR1Y2VMb2MubGVuZ3RoO1xuICAgIHZhciBsb2MgPSBbXTtcbiAgICB2YXIgb3V0SWR4ID0gMDtcbiAgICB2YXIgcmVkdWNlSWR4ID0gMDtcbiAgICBmb3IgKHZhciBkaW0gPSAwOyBkaW0gPCByYW5rOyBkaW0rKykge1xuICAgICAgICBpZiAoYXhlcy5pbmRleE9mKGRpbSkgPT09IC0xKSB7XG4gICAgICAgICAgICBsb2MucHVzaChvdXRwdXRMb2Nbb3V0SWR4KytdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxvYy5wdXNoKHJlZHVjZUxvY1tyZWR1Y2VJZHgrK10pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBsb2M7XG59XG5leHBvcnRzLmNvbWJpbmVMb2NhdGlvbnMgPSBjb21iaW5lTG9jYXRpb25zO1xuZnVuY3Rpb24gY29tcHV0ZU91dEFuZFJlZHVjZVNoYXBlcyhhU2hhcGUsIGF4ZXMpIHtcbiAgICB2YXIgb3V0U2hhcGUgPSBbXTtcbiAgICB2YXIgcmFuayA9IGFTaGFwZS5sZW5ndGg7XG4gICAgZm9yICh2YXIgZGltID0gMDsgZGltIDwgcmFuazsgZGltKyspIHtcbiAgICAgICAgaWYgKGF4ZXMuaW5kZXhPZihkaW0pID09PSAtMSkge1xuICAgICAgICAgICAgb3V0U2hhcGUucHVzaChhU2hhcGVbZGltXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIHJlZHVjZVNoYXBlID0gYXhlcy5tYXAoZnVuY3Rpb24gKGRpbSkgeyByZXR1cm4gYVNoYXBlW2RpbV07IH0pO1xuICAgIHJldHVybiBbb3V0U2hhcGUsIHJlZHVjZVNoYXBlXTtcbn1cbmV4cG9ydHMuY29tcHV0ZU91dEFuZFJlZHVjZVNoYXBlcyA9IGNvbXB1dGVPdXRBbmRSZWR1Y2VTaGFwZXM7XG5mdW5jdGlvbiBleHBhbmRTaGFwZVRvS2VlcERpbShzaGFwZSwgYXhlcykge1xuICAgIHZhciByZWR1Y2VTdWJTaGFwZSA9IGF4ZXMubWFwKGZ1bmN0aW9uICh4KSB7IHJldHVybiAxOyB9KTtcbiAgICByZXR1cm4gY29tYmluZUxvY2F0aW9ucyhzaGFwZSwgcmVkdWNlU3ViU2hhcGUsIGF4ZXMpO1xufVxuZXhwb3J0cy5leHBhbmRTaGFwZVRvS2VlcERpbSA9IGV4cGFuZFNoYXBlVG9LZWVwRGltO1xuZnVuY3Rpb24gcGFyc2VBeGlzUGFyYW0oYXhpcywgc2hhcGUpIHtcbiAgICBpZiAoYXhpcyA9PSBudWxsKSB7XG4gICAgICAgIGF4aXMgPSBzaGFwZS5tYXAoZnVuY3Rpb24gKHMsIGkpIHsgcmV0dXJuIGk7IH0pO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgKGF4aXMpID09PSAnbnVtYmVyJykge1xuICAgICAgICBheGlzID0gW2F4aXNdO1xuICAgIH1cbiAgICByZXR1cm4gYXhpcztcbn1cbmV4cG9ydHMucGFyc2VBeGlzUGFyYW0gPSBwYXJzZUF4aXNQYXJhbTtcbmZ1bmN0aW9uIGFzc2VydEF4ZXNBcmVJbm5lck1vc3REaW1zKG1zZywgYXhlcywgcmFuaykge1xuICAgIGlmICghYXhlc0FyZUlubmVyTW9zdERpbXMoYXhlcywgcmFuaykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyArIFwiIHN1cHBvcnRzIG9ubHkgaW5uZXItbW9zdCBheGVzIGZvciBub3cuIFwiICtcbiAgICAgICAgICAgIChcIkdvdCBheGVzIFwiICsgYXhlcyArIFwiIGFuZCByYW5rLVwiICsgcmFuayArIFwiIGlucHV0LlwiKSk7XG4gICAgfVxufVxuZXhwb3J0cy5hc3NlcnRBeGVzQXJlSW5uZXJNb3N0RGltcyA9IGFzc2VydEF4ZXNBcmVJbm5lck1vc3REaW1zO1xuZnVuY3Rpb24gZ2V0UGVybXV0ZWRBeGVzKGF4ZXMsIHJhbmspIHtcbiAgICBpZiAoYXhlc0FyZUlubmVyTW9zdERpbXMoYXhlcywgcmFuaykpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJhbms7ICsraSkge1xuICAgICAgICBpZiAoYXhlcy5pbmRleE9mKGkpID09PSAtMSkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goaSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXhlcy5mb3JFYWNoKGZ1bmN0aW9uIChheGlzKSB7IHJldHVybiByZXN1bHQucHVzaChheGlzKTsgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMuZ2V0UGVybXV0ZWRBeGVzID0gZ2V0UGVybXV0ZWRBeGVzO1xuZnVuY3Rpb24gZ2V0SW5uZXJNb3N0QXhlcyhudW1BeGVzLCByYW5rKSB7XG4gICAgdmFyIHJlcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSByYW5rIC0gbnVtQXhlczsgaSA8IHJhbms7ICsraSkge1xuICAgICAgICByZXMucHVzaChpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbmV4cG9ydHMuZ2V0SW5uZXJNb3N0QXhlcyA9IGdldElubmVyTW9zdEF4ZXM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1heGlzX3V0aWwuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5mdW5jdGlvbiBnZXRCcm9hZGNhc3REaW1zKGluU2hhcGUsIG91dFNoYXBlKSB7XG4gICAgdmFyIGluUmFuayA9IGluU2hhcGUubGVuZ3RoO1xuICAgIHZhciBkaW1zID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpblJhbms7IGkrKykge1xuICAgICAgICB2YXIgZGltID0gaW5SYW5rIC0gMSAtIGk7XG4gICAgICAgIHZhciBhID0gaW5TaGFwZVtkaW1dIHx8IDE7XG4gICAgICAgIHZhciBiID0gb3V0U2hhcGVbb3V0U2hhcGUubGVuZ3RoIC0gMSAtIGldIHx8IDE7XG4gICAgICAgIGlmIChiID4gMSAmJiBhID09PSAxKSB7XG4gICAgICAgICAgICBkaW1zLnVuc2hpZnQoZGltKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGltcztcbn1cbmV4cG9ydHMuZ2V0QnJvYWRjYXN0RGltcyA9IGdldEJyb2FkY2FzdERpbXM7XG5mdW5jdGlvbiBicm9hZGNhc3REaW1zQXJlT3V0ZXIoZGltcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGltcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoZGltc1tpXSAhPT0gaSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZXhwb3J0cy5icm9hZGNhc3REaW1zQXJlT3V0ZXIgPSBicm9hZGNhc3REaW1zQXJlT3V0ZXI7XG5mdW5jdGlvbiBhc3NlcnRBbmRHZXRCcm9hZGNhc3RTaGFwZShzaGFwZUEsIHNoYXBlQikge1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICB2YXIgZXJyTXNnID0gXCJPcGVyYW5kcyBjb3VsZCBub3QgYmUgYnJvYWRjYXN0IHRvZ2V0aGVyIHdpdGggc2hhcGVzIFwiICtcbiAgICAgICAgKHNoYXBlQSArIFwiIGFuZCBcIiArIHNoYXBlQiArIFwiLlwiKTtcbiAgICB2YXIgbCA9IE1hdGgubWF4KHNoYXBlQS5sZW5ndGgsIHNoYXBlQi5sZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHZhciBhID0gc2hhcGVBW3NoYXBlQS5sZW5ndGggLSBpIC0gMV0gfHwgMTtcbiAgICAgICAgdmFyIGIgPSBzaGFwZUJbc2hhcGVCLmxlbmd0aCAtIGkgLSAxXSB8fCAxO1xuICAgICAgICBpZiAoYSA+IDEgJiYgYiA+IDEgJiYgYSAhPT0gYikge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoZXJyTXNnKTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQudW5zaGlmdChNYXRoLm1heChhLCBiKSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnRzLmFzc2VydEFuZEdldEJyb2FkY2FzdFNoYXBlID0gYXNzZXJ0QW5kR2V0QnJvYWRjYXN0U2hhcGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1icm9hZGNhc3RfdXRpbC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG5mdW5jdGlvbiBhc3NlcnRQYXJhbXMoYVNoYXBlLCBiU2hhcGUsIGF4aXMpIHtcbiAgICB2YXIgYVJhbmsgPSBhU2hhcGUubGVuZ3RoO1xuICAgIHZhciBiUmFuayA9IGJTaGFwZS5sZW5ndGg7XG4gICAgdXRpbC5hc3NlcnQoYVNoYXBlLmxlbmd0aCA9PT0gYlNoYXBlLmxlbmd0aCwgXCJFcnJvciBpbiBjb25jYXRcIiArIGFSYW5rICsgXCJEOiByYW5rIG9mIHgxIChcIiArIGFSYW5rICsgXCIpIGFuZCB4MiAoXCIgKyBiUmFuayArIFwiKSBcIiArXG4gICAgICAgIFwibXVzdCBiZSB0aGUgc2FtZS5cIik7XG4gICAgdXRpbC5hc3NlcnQoYXhpcyA+PSAwICYmIGF4aXMgPCBhUmFuaywgXCJFcnJvciBpbiBjb25jYXRcIiArIGFSYW5rICsgXCJEOiBheGlzIG11c3QgYmUgXCIgK1xuICAgICAgICAoXCJiZXR3ZWVuIDAgYW5kIFwiICsgKGFSYW5rIC0gMSkgKyBcIi5cIikpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYVJhbms7IGkrKykge1xuICAgICAgICB1dGlsLmFzc2VydCgoaSA9PT0gYXhpcykgfHwgKGFTaGFwZVtpXSA9PT0gYlNoYXBlW2ldKSwgXCJFcnJvciBpbiBjb25jYXRcIiArIGFSYW5rICsgXCJEOiBTaGFwZSAoXCIgKyBhU2hhcGUgKyBcIikgZG9lcyBub3QgbWF0Y2ggXCIgK1xuICAgICAgICAgICAgKFwiKFwiICsgYlNoYXBlICsgXCIpIGFsb25nIHRoZSBub24tY29uY2F0ZW5hdGVkIGF4aXMgXCIgKyBpICsgXCIuXCIpKTtcbiAgICB9XG59XG5leHBvcnRzLmFzc2VydFBhcmFtcyA9IGFzc2VydFBhcmFtcztcbmZ1bmN0aW9uIGNvbXB1dGVPdXRTaGFwZSh4MVNoYXBlLCB4MlNoYXBlLCBheGlzKSB7XG4gICAgdXRpbC5hc3NlcnQoeDFTaGFwZS5sZW5ndGggPT09IHgyU2hhcGUubGVuZ3RoLCAneDEgYW5kIHgyIHNob3VsZCBoYXZlIHRoZSBzYW1lIHJhbmsuJyk7XG4gICAgdmFyIG91dHB1dFNoYXBlID0geDFTaGFwZS5zbGljZSgpO1xuICAgIG91dHB1dFNoYXBlW2F4aXNdICs9IHgyU2hhcGVbYXhpc107XG4gICAgcmV0dXJuIG91dHB1dFNoYXBlO1xufVxuZXhwb3J0cy5jb21wdXRlT3V0U2hhcGUgPSBjb21wdXRlT3V0U2hhcGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25jYXRfdXRpbC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG5mdW5jdGlvbiBjb21wdXRlRGVwdGh3aXNlQ29udjJESW5mbyhpblNoYXBlLCBmaWx0ZXJTaGFwZSwgc3RyaWRlcywgcGFkKSB7XG4gICAgdmFyIGZpbHRlckhlaWdodCA9IGZpbHRlclNoYXBlWzBdLCBmaWx0ZXJXaWR0aCA9IGZpbHRlclNoYXBlWzFdLCBpbkNoYW5uZWxzID0gZmlsdGVyU2hhcGVbMl0sIGNoYW5uZWxNdWwgPSBmaWx0ZXJTaGFwZVszXTtcbiAgICB2YXIgX2EgPSBwYXJzZVR1cGxlUGFyYW0oc3RyaWRlcyksIHN0cmlkZUhlaWdodCA9IF9hWzBdLCBzdHJpZGVXaWR0aCA9IF9hWzFdO1xuICAgIHZhciBpbkhlaWdodCA9IGluU2hhcGVbMV07XG4gICAgdmFyIGluV2lkdGggPSBpblNoYXBlWzJdO1xuICAgIHZhciBiYXRjaFNpemUgPSBpblNoYXBlWzBdO1xuICAgIHZhciBfYiA9IGdldFBhZEFuZE91dEluZm8ocGFkLCBpbkhlaWdodCwgaW5XaWR0aCwgc3RyaWRlSGVpZ2h0LCBzdHJpZGVXaWR0aCwgZmlsdGVySGVpZ2h0LCBmaWx0ZXJXaWR0aCksIHBhZEluZm8gPSBfYi5wYWRJbmZvLCBvdXRIZWlnaHQgPSBfYi5vdXRIZWlnaHQsIG91dFdpZHRoID0gX2Iub3V0V2lkdGg7XG4gICAgdmFyIG91dENoYW5uZWxzID0gaW5DaGFubmVscyAqIGNoYW5uZWxNdWw7XG4gICAgdmFyIG91dFNoYXBlID0gW2JhdGNoU2l6ZSwgb3V0SGVpZ2h0LCBvdXRXaWR0aCwgb3V0Q2hhbm5lbHNdO1xuICAgIHJldHVybiB7XG4gICAgICAgIGluU2hhcGU6IGluU2hhcGUsXG4gICAgICAgIG91dFNoYXBlOiBvdXRTaGFwZSxcbiAgICAgICAgY2hhbm5lbE11bDogY2hhbm5lbE11bCxcbiAgICAgICAgc3RyaWRlSGVpZ2h0OiBzdHJpZGVIZWlnaHQsXG4gICAgICAgIHN0cmlkZVdpZHRoOiBzdHJpZGVXaWR0aCxcbiAgICAgICAgZmlsdGVySGVpZ2h0OiBmaWx0ZXJIZWlnaHQsXG4gICAgICAgIGZpbHRlcldpZHRoOiBmaWx0ZXJXaWR0aCxcbiAgICAgICAgcGFkSW5mbzogcGFkSW5mb1xuICAgIH07XG59XG5leHBvcnRzLmNvbXB1dGVEZXB0aHdpc2VDb252MkRJbmZvID0gY29tcHV0ZURlcHRod2lzZUNvbnYyREluZm87XG5mdW5jdGlvbiBjb21wdXRlQ29udjJESW5mbyhpblNoYXBlLCBmaWx0ZXJIZWlnaHQsIGZpbHRlcldpZHRoLCBvdXREZXB0aCwgc3RyaWRlSGVpZ2h0LCBzdHJpZGVXaWR0aCwgcGFkKSB7XG4gICAgdmFyIGluSGVpZ2h0ID0gaW5TaGFwZVswXTtcbiAgICB2YXIgaW5XaWR0aCA9IGluU2hhcGVbMV07XG4gICAgdmFyIF9hID0gZ2V0UGFkQW5kT3V0SW5mbyhwYWQsIGluSGVpZ2h0LCBpbldpZHRoLCBzdHJpZGVIZWlnaHQsIHN0cmlkZVdpZHRoLCBmaWx0ZXJIZWlnaHQsIGZpbHRlcldpZHRoKSwgcGFkSW5mbyA9IF9hLnBhZEluZm8sIG91dEhlaWdodCA9IF9hLm91dEhlaWdodCwgb3V0V2lkdGggPSBfYS5vdXRXaWR0aDtcbiAgICB2YXIgb3V0U2hhcGUgPSBbb3V0SGVpZ2h0LCBvdXRXaWR0aCwgb3V0RGVwdGhdO1xuICAgIHJldHVybiB7XG4gICAgICAgIGluU2hhcGU6IGluU2hhcGUsXG4gICAgICAgIG91dFNoYXBlOiBvdXRTaGFwZSxcbiAgICAgICAgcGFkSW5mbzogcGFkSW5mbyxcbiAgICAgICAgc3RyaWRlSGVpZ2h0OiBzdHJpZGVIZWlnaHQsXG4gICAgICAgIHN0cmlkZVdpZHRoOiBzdHJpZGVXaWR0aCxcbiAgICAgICAgZmlsdGVySGVpZ2h0OiBmaWx0ZXJIZWlnaHQsXG4gICAgICAgIGZpbHRlcldpZHRoOiBmaWx0ZXJXaWR0aFxuICAgIH07XG59XG5leHBvcnRzLmNvbXB1dGVDb252MkRJbmZvID0gY29tcHV0ZUNvbnYyREluZm87XG5mdW5jdGlvbiBjb21wdXRlT3V0cHV0U2hhcGUzRChpblNoYXBlLCBmaWVsZFNpemUsIG91dERlcHRoLCBzdHJpZGUsIHplcm9QYWQpIHtcbiAgICBpZiAoemVyb1BhZCA9PSBudWxsKSB7XG4gICAgICAgIHplcm9QYWQgPSBjb21wdXRlRGVmYXVsdFBhZChpblNoYXBlLCBmaWVsZFNpemUsIHN0cmlkZSk7XG4gICAgfVxuICAgIHZhciBpbnB1dFJvd3MgPSBpblNoYXBlWzBdO1xuICAgIHZhciBpbnB1dENvbHMgPSBpblNoYXBlWzFdO1xuICAgIHZhciBvdXRwdXRSb3dzID0gKGlucHV0Um93cyAtIGZpZWxkU2l6ZSArIDIgKiB6ZXJvUGFkKSAvIHN0cmlkZSArIDE7XG4gICAgdXRpbC5hc3NlcnQodXRpbC5pc0ludChvdXRwdXRSb3dzKSwgXCJUaGUgb3V0cHV0ICMgb2Ygcm93cyAoXCIgKyBvdXRwdXRSb3dzICsgXCIpIG11c3QgYmUgYW4gaW50ZWdlci4gQ2hhbmdlIHRoZSBcIiArXG4gICAgICAgIFwic3RyaWRlIGFuZC9vciB6ZXJvIHBhZCBwYXJhbWV0ZXJzXCIpO1xuICAgIHZhciBvdXRwdXRDb2xzID0gKGlucHV0Q29scyAtIGZpZWxkU2l6ZSArIDIgKiB6ZXJvUGFkKSAvIHN0cmlkZSArIDE7XG4gICAgdXRpbC5hc3NlcnQodXRpbC5pc0ludChvdXRwdXRDb2xzKSwgXCJUaGUgb3V0cHV0ICMgb2YgY29sdW1ucyAoXCIgKyBvdXRwdXRDb2xzICsgXCIpIG11c3QgYmUgYW4gaW50ZWdlci4gQ2hhbmdlIFwiICtcbiAgICAgICAgXCJ0aGUgc3RyaWRlIGFuZC9vciB6ZXJvIHBhZCBwYXJhbWV0ZXJzXCIpO1xuICAgIHJldHVybiBbb3V0cHV0Um93cywgb3V0cHV0Q29scywgb3V0RGVwdGhdO1xufVxuZXhwb3J0cy5jb21wdXRlT3V0cHV0U2hhcGUzRCA9IGNvbXB1dGVPdXRwdXRTaGFwZTNEO1xuZnVuY3Rpb24gY29tcHV0ZURlZmF1bHRQYWQoaW5wdXRTaGFwZSwgZmllbGRTaXplLCBzdHJpZGUpIHtcbiAgICByZXR1cm4gTWF0aC5mbG9vcigoaW5wdXRTaGFwZVswXSAqIChzdHJpZGUgLSAxKSAtIHN0cmlkZSArIGZpZWxkU2l6ZSkgLyAyKTtcbn1cbmV4cG9ydHMuY29tcHV0ZURlZmF1bHRQYWQgPSBjb21wdXRlRGVmYXVsdFBhZDtcbmZ1bmN0aW9uIGNvbXB1dGVXZWlnaHRzU2hhcGU0RChpbnB1dERlcHRoLCBvdXRwdXREZXB0aCwgZmlsdGVySGVpZ2h0LCBmaWx0ZXJXaWR0aCkge1xuICAgIHJldHVybiBbZmlsdGVySGVpZ2h0LCBmaWx0ZXJXaWR0aCwgaW5wdXREZXB0aCwgb3V0cHV0RGVwdGhdO1xufVxuZXhwb3J0cy5jb21wdXRlV2VpZ2h0c1NoYXBlNEQgPSBjb21wdXRlV2VpZ2h0c1NoYXBlNEQ7XG5mdW5jdGlvbiBjb21wdXRlRGlsYXRlZFJDKHJjLCBvcmlnU3RyaWRlKSB7XG4gICAgdmFyIHJvd3NEaWxhdGVkID0gKHJjWzBdIC0gMSkgKiBvcmlnU3RyaWRlICsgMTtcbiAgICB2YXIgY29sc0RpbGF0ZWQgPSAocmNbMV0gLSAxKSAqIG9yaWdTdHJpZGUgKyAxO1xuICAgIHJldHVybiBbcm93c0RpbGF0ZWQsIGNvbHNEaWxhdGVkXTtcbn1cbmV4cG9ydHMuY29tcHV0ZURpbGF0ZWRSQyA9IGNvbXB1dGVEaWxhdGVkUkM7XG5mdW5jdGlvbiBwYXJzZVR1cGxlUGFyYW0ocGFyYW0pIHtcbiAgICByZXR1cm4gdHlwZW9mIHBhcmFtID09PSAnbnVtYmVyJyA/IFtwYXJhbSwgcGFyYW1dIDogcGFyYW07XG59XG5mdW5jdGlvbiBnZXRQYWRBbmRPdXRJbmZvKHBhZCwgaW5IZWlnaHQsIGluV2lkdGgsIHN0cmlkZUhlaWdodCwgc3RyaWRlV2lkdGgsIGZpbHRlckhlaWdodCwgZmlsdGVyV2lkdGgpIHtcbiAgICB2YXIgcGFkSW5mbztcbiAgICB2YXIgb3V0SGVpZ2h0O1xuICAgIHZhciBvdXRXaWR0aDtcbiAgICBpZiAodHlwZW9mIHBhZCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcGFkSW5mbyA9IHsgdG9wOiBwYWQsIGJvdHRvbTogcGFkLCBsZWZ0OiBwYWQsIHJpZ2h0OiBwYWQgfTtcbiAgICAgICAgdmFyIG91dFNoYXBlID0gY29tcHV0ZU91dHB1dFNoYXBlM0QoW2luSGVpZ2h0LCBpbldpZHRoLCAxXSwgZmlsdGVySGVpZ2h0LCAxLCBzdHJpZGVIZWlnaHQsIHBhZCk7XG4gICAgICAgIG91dEhlaWdodCA9IG91dFNoYXBlWzBdO1xuICAgICAgICBvdXRXaWR0aCA9IG91dFNoYXBlWzFdO1xuICAgIH1cbiAgICBlbHNlIGlmIChwYWQgPT09ICdzYW1lJykge1xuICAgICAgICBvdXRIZWlnaHQgPSBNYXRoLmNlaWwoaW5IZWlnaHQgLyBzdHJpZGVIZWlnaHQpO1xuICAgICAgICBvdXRXaWR0aCA9IE1hdGguY2VpbChpbldpZHRoIC8gc3RyaWRlV2lkdGgpO1xuICAgICAgICB2YXIgcGFkQWxvbmdIZWlnaHQgPSAob3V0SGVpZ2h0IC0gMSkgKiBzdHJpZGVIZWlnaHQgKyBmaWx0ZXJIZWlnaHQgLSBpbkhlaWdodDtcbiAgICAgICAgdmFyIHBhZEFsb25nV2lkdGggPSAob3V0V2lkdGggLSAxKSAqIHN0cmlkZVdpZHRoICsgZmlsdGVyV2lkdGggLSBpbldpZHRoO1xuICAgICAgICB2YXIgdG9wXzEgPSBNYXRoLmZsb29yKHBhZEFsb25nSGVpZ2h0IC8gMik7XG4gICAgICAgIHZhciBib3R0b20gPSBwYWRBbG9uZ0hlaWdodCAtIHRvcF8xO1xuICAgICAgICB2YXIgbGVmdCA9IE1hdGguZmxvb3IocGFkQWxvbmdXaWR0aCAvIDIpO1xuICAgICAgICB2YXIgcmlnaHQgPSBwYWRBbG9uZ1dpZHRoIC0gbGVmdDtcbiAgICAgICAgcGFkSW5mbyA9IHsgdG9wOiB0b3BfMSwgYm90dG9tOiBib3R0b20sIGxlZnQ6IGxlZnQsIHJpZ2h0OiByaWdodCB9O1xuICAgIH1cbiAgICBlbHNlIGlmIChwYWQgPT09ICd2YWxpZCcpIHtcbiAgICAgICAgcGFkSW5mbyA9IHsgdG9wOiAwLCBib3R0b206IDAsIGxlZnQ6IDAsIHJpZ2h0OiAwIH07XG4gICAgICAgIG91dEhlaWdodCA9IE1hdGguY2VpbCgoaW5IZWlnaHQgLSBmaWx0ZXJIZWlnaHQgKyAxKSAvIHN0cmlkZUhlaWdodCk7XG4gICAgICAgIG91dFdpZHRoID0gTWF0aC5jZWlsKChpbldpZHRoIC0gZmlsdGVyV2lkdGggKyAxKSAvIHN0cmlkZVdpZHRoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IEVycm9yKFwiVW5rbm93biBwYWRkaW5nIHBhcmFtZXRlcjogXCIgKyBwYWQpO1xuICAgIH1cbiAgICByZXR1cm4geyBwYWRJbmZvOiBwYWRJbmZvLCBvdXRIZWlnaHQ6IG91dEhlaWdodCwgb3V0V2lkdGg6IG91dFdpZHRoIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb252X3V0aWwuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5mdW5jdGlvbiB2YWxpZGF0ZVNoYXBlcyhzb3VyY2VTaXplLCBkZXN0U2l6ZSkge1xuICAgIHZhciBzcmNBcmVhID0gc291cmNlU2l6ZVswXSAqIHNvdXJjZVNpemVbMV07XG4gICAgdmFyIGRzdEFyZWEgPSBkZXN0U2l6ZVswXSAqIGRlc3RTaXplWzFdO1xuICAgIGlmIChzcmNBcmVhICE9PSBkc3RBcmVhKSB7XG4gICAgICAgIHZhciBzcmNTdHIgPSBcIltcIiArIHNvdXJjZVNpemVbMF0gKyBcIiwgXCIgKyBzb3VyY2VTaXplWzFdICsgXCJdXCI7XG4gICAgICAgIHZhciBkc3RTdHIgPSBcIltcIiArIGRlc3RTaXplWzBdICsgXCIsIFwiICsgZGVzdFNpemVbMV0gKyBcIl1cIjtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY29weTJEIHNoYXBlcyBoYXZlIGRpZmZlcmVudCBhcmVhczpcXG4gIHNvdXJjZVNpemUgXCIgKyBzcmNTdHIgK1xuICAgICAgICAgICAgKFwiLCBhcmVhIFwiICsgc3JjQXJlYSArIFwiXFxuICBkZXN0U2l6ZSBcIiArIGRzdFN0ciArIFwiLCBhcmVhIFwiICsgZHN0QXJlYSkpO1xuICAgIH1cbn1cbmV4cG9ydHMudmFsaWRhdGVTaGFwZXMgPSB2YWxpZGF0ZVNoYXBlcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvcHkyZF91dGlsLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIG5kYXJyYXlfMSA9IHJlcXVpcmUoXCIuL25kYXJyYXlcIik7XG52YXIgU3F1YXJlQ29zdEZ1bmMgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNxdWFyZUNvc3RGdW5jKCkge1xuICAgICAgICB0aGlzLmhhbGZPbmUgPSBuZGFycmF5XzEuU2NhbGFyLm5ldygwLjUpO1xuICAgIH1cbiAgICBTcXVhcmVDb3N0RnVuYy5wcm90b3R5cGUuY29zdCA9IGZ1bmN0aW9uIChtYXRoLCB4MSwgeDIpIHtcbiAgICAgICAgdmFyIGRpZmYgPSBtYXRoLnN1YlN0cmljdCh4MSwgeDIpO1xuICAgICAgICB2YXIgZGlmZlNxdWFyZWQgPSBtYXRoLmVsZW1lbnRXaXNlTXVsKGRpZmYsIGRpZmYpO1xuICAgICAgICB2YXIgcmVzdWx0ID0gbWF0aC5zY2FsYXJUaW1lc0FycmF5KHRoaXMuaGFsZk9uZSwgZGlmZlNxdWFyZWQpO1xuICAgICAgICBkaWZmLmRpc3Bvc2UoKTtcbiAgICAgICAgZGlmZlNxdWFyZWQuZGlzcG9zZSgpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgU3F1YXJlQ29zdEZ1bmMucHJvdG90eXBlLmRlciA9IGZ1bmN0aW9uIChtYXRoLCB4MSwgeDIpIHtcbiAgICAgICAgcmV0dXJuIG1hdGguc3ViU3RyaWN0KHgxLCB4Mik7XG4gICAgfTtcbiAgICBTcXVhcmVDb3N0RnVuYy5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5oYWxmT25lLmRpc3Bvc2UoKTtcbiAgICB9O1xuICAgIHJldHVybiBTcXVhcmVDb3N0RnVuYztcbn0oKSk7XG5leHBvcnRzLlNxdWFyZUNvc3RGdW5jID0gU3F1YXJlQ29zdEZ1bmM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb3N0X2Z1bmN0aW9ucy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG52YXIgYXhpc191dGlsID0gcmVxdWlyZShcIi4vYXhpc191dGlsXCIpO1xudmFyIGJyb2FkY2FzdF91dGlsID0gcmVxdWlyZShcIi4vYnJvYWRjYXN0X3V0aWxcIik7XG52YXIgY29uY2F0X3V0aWwgPSByZXF1aXJlKFwiLi9jb25jYXRfdXRpbFwiKTtcbnZhciBjb252X3V0aWwgPSByZXF1aXJlKFwiLi9jb252X3V0aWxcIik7XG52YXIgY29weTJkX3V0aWwgPSByZXF1aXJlKFwiLi9jb3B5MmRfdXRpbFwiKTtcbnZhciBuZGFycmF5XzEgPSByZXF1aXJlKFwiLi9uZGFycmF5XCIpO1xudmFyIHNsaWNlX3V0aWwgPSByZXF1aXJlKFwiLi9zbGljZV91dGlsXCIpO1xudmFyIFN1bVR5cGVzTWFwO1xuKGZ1bmN0aW9uIChTdW1UeXBlc01hcCkge1xuICAgIFN1bVR5cGVzTWFwW1wiZmxvYXQzMlwiXSA9IFwiZmxvYXQzMlwiO1xuICAgIFN1bVR5cGVzTWFwW1wiaW50MzJcIl0gPSBcImludDMyXCI7XG4gICAgU3VtVHlwZXNNYXBbXCJib29sXCJdID0gXCJpbnQzMlwiO1xufSkoU3VtVHlwZXNNYXAgPSBleHBvcnRzLlN1bVR5cGVzTWFwIHx8IChleHBvcnRzLlN1bVR5cGVzTWFwID0ge30pKTtcbnZhciBOREFycmF5TWF0aCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTkRBcnJheU1hdGgoc2FmZU1vZGUpIHtcbiAgICAgICAgdGhpcy5zYWZlTW9kZSA9IHNhZmVNb2RlO1xuICAgICAgICB0aGlzLm5kYXJyYXlTY29wZXMgPSBbXTtcbiAgICAgICAgdGhpcy5uZGFycmF5c1RvS2VlcCA9IFtdO1xuICAgICAgICB0aGlzLmFjdGl2ZVNjb3BlTkRBcnJheXNUb0tlZXAgPSBbXTtcbiAgICAgICAgdGhpcy5kZWJ1Z01vZGUgPSBmYWxzZTtcbiAgICB9XG4gICAgTkRBcnJheU1hdGgucHJvdG90eXBlLnNjb3BlID0gZnVuY3Rpb24gKHNjb3BlRm4pIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5zdGFydFNjb3BlKCk7XG4gICAgICAgIHZhciBrZWVwRm4gPSBmdW5jdGlvbiAobmRhcnJheSkgeyByZXR1cm4gX3RoaXMua2VlcChuZGFycmF5KTsgfTtcbiAgICAgICAgdmFyIHRyYWNrRm4gPSBmdW5jdGlvbiAobmRhcnJheSkgeyByZXR1cm4gX3RoaXMudHJhY2sobmRhcnJheSk7IH07XG4gICAgICAgIHZhciByZXN1bHQgPSBzY29wZUZuKGtlZXBGbiwgdHJhY2tGbik7XG4gICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICByZXN1bHQudGhlbihmdW5jdGlvbiAocikgeyByZXR1cm4gX3RoaXMuZW5kU2NvcGUocik7IH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZW5kU2NvcGUocmVzdWx0KTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS5lbmFibGVEZWJ1Z01vZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZGVidWdNb2RlID0gdHJ1ZTtcbiAgICAgICAgY29uc29sZS53YXJuKCdEZWJ1Z2dpbmcgbW9kZSBpcyBPTi4gVGhlIG91dHB1dCBvZiBldmVyeSBtYXRoIGNhbGwgd2lsbCAnICtcbiAgICAgICAgICAgICdiZSBkb3dubG9hZGVkIHRvIENQVSBhbmQgY2hlY2tlZCBmb3IgTmFOcy4gJyArXG4gICAgICAgICAgICAnVGhpcyBzaWduaWZpY2FudGx5IGltcGFjdHMgcGVyZm9ybWFuY2UuJyk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUuc3RhcnRTY29wZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG5ld1Njb3BlID0gW107XG4gICAgICAgIHRoaXMubmRhcnJheVNjb3Blcy5wdXNoKG5ld1Njb3BlKTtcbiAgICAgICAgdGhpcy5hY3RpdmVTY29wZSA9IG5ld1Njb3BlO1xuICAgICAgICB2YXIgbmV3TkRBcnJheXNUb0tlZXAgPSBbXTtcbiAgICAgICAgdGhpcy5uZGFycmF5c1RvS2VlcC5wdXNoKG5ld05EQXJyYXlzVG9LZWVwKTtcbiAgICAgICAgdGhpcy5hY3RpdmVTY29wZU5EQXJyYXlzVG9LZWVwID0gbmV3TkRBcnJheXNUb0tlZXA7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUuZXh0cmFjdE5EQXJyYXlzRnJvbVNjb3BlUmVzdWx0ID0gZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICBpZiAocmVzdWx0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgbmRhcnJheV8xLk5EQXJyYXkpIHtcbiAgICAgICAgICAgIHJldHVybiBbcmVzdWx0XTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGlzdCA9IFtdO1xuICAgICAgICB2YXIgcmVzdWx0T2JqID0gcmVzdWx0O1xuICAgICAgICBmb3IgKHZhciBrIGluIHJlc3VsdE9iaikge1xuICAgICAgICAgICAgdmFyIHZhbCA9IHJlc3VsdE9ialtrXTtcbiAgICAgICAgICAgIGlmICh2YWwgaW5zdGFuY2VvZiBuZGFycmF5XzEuTkRBcnJheSkge1xuICAgICAgICAgICAgICAgIGxpc3QucHVzaCh2YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsaXN0O1xuICAgIH07XG4gICAgTkRBcnJheU1hdGgucHJvdG90eXBlLmVuZFNjb3BlID0gZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgYXJyYXlzVG9LZWVwID0gdGhpcy5hY3RpdmVTY29wZU5EQXJyYXlzVG9LZWVwO1xuICAgICAgICB2YXIgcmVzdWx0QXJyYXlzID0gdGhpcy5leHRyYWN0TkRBcnJheXNGcm9tU2NvcGVSZXN1bHQocmVzdWx0KTtcbiAgICAgICAgYXJyYXlzVG9LZWVwID0gYXJyYXlzVG9LZWVwLmNvbmNhdChyZXN1bHRBcnJheXMpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYWN0aXZlU2NvcGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBuZGFycmF5ID0gdGhpcy5hY3RpdmVTY29wZVtpXTtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzTkRBcnJheURhdGFJbkxpc3QobmRhcnJheSwgYXJyYXlzVG9LZWVwKSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmRhcnJheS5kaXNwb3NlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5uZGFycmF5U2NvcGVzLnBvcCgpO1xuICAgICAgICB0aGlzLmFjdGl2ZVNjb3BlID0gdGhpcy5uZGFycmF5U2NvcGVzLmxlbmd0aCA9PT0gMCA/XG4gICAgICAgICAgICBudWxsIDpcbiAgICAgICAgICAgIHRoaXMubmRhcnJheVNjb3Blc1t0aGlzLm5kYXJyYXlTY29wZXMubGVuZ3RoIC0gMV07XG4gICAgICAgIHJlc3VsdEFycmF5cy5mb3JFYWNoKGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgIGlmICghX3RoaXMuaXNOREFycmF5RGF0YUluTGlzdCh2YWwsIF90aGlzLmFjdGl2ZVNjb3BlTkRBcnJheXNUb0tlZXApKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMudHJhY2sodmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubmRhcnJheXNUb0tlZXAucG9wKCk7XG4gICAgICAgIHRoaXMuYWN0aXZlU2NvcGVOREFycmF5c1RvS2VlcCA9IHRoaXMubmRhcnJheXNUb0tlZXAubGVuZ3RoID09PSAwID9cbiAgICAgICAgICAgIG51bGwgOlxuICAgICAgICAgICAgdGhpcy5uZGFycmF5c1RvS2VlcFt0aGlzLm5kYXJyYXlzVG9LZWVwLmxlbmd0aCAtIDFdO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGgucHJvdG90eXBlLmlzTkRBcnJheURhdGFJbkxpc3QgPSBmdW5jdGlvbiAobmRhcnJheSwgbmRhcnJheUxpc3QpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZGFycmF5TGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKG5kYXJyYXlMaXN0W2ldLmdldERhdGEoKSA9PT0gbmRhcnJheS5nZXREYXRhKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUua2VlcCA9IGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlU2NvcGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuc2FmZU1vZGUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBhcmUgdXNpbmcgbWF0aCBpbiBzYWZlIG1vZGUuIEVuY2xvc2UgYWxsICcgK1xuICAgICAgICAgICAgICAgICAgICAnbWF0aC5tZXRob2QoKSBjYWxscyBpbnNpZGUgYSBzY29wZTogJyArXG4gICAgICAgICAgICAgICAgICAgICdtYXRoLnNjb3BlKCgpID0+IHttYXRoLm1ldGhvZCgpOy4uLn0pIHRvIGF2b2lkIG1lbW9yeSAnICtcbiAgICAgICAgICAgICAgICAgICAgJ2xlYWtzLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFjdGl2ZVNjb3BlTkRBcnJheXNUb0tlZXAucHVzaChyZXN1bHQpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgTkRBcnJheU1hdGgucHJvdG90eXBlLmNoZWNrRm9yTmFOID0gZnVuY3Rpb24gKHZhbHMsIGR0eXBlLCBuYW1lKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFscy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHV0aWwuaXNWYWxOYU4odmFsc1tpXSwgZHR5cGUpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJUaGUgcmVzdWx0IG9mIHRoZSBsYXN0IG1hdGguXCIgKyBuYW1lICsgXCIgaGFzIE5hTnMuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUudHJhY2sgPSBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZVNjb3BlID09IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNhZmVNb2RlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgYXJlIHVzaW5nIG1hdGggaW4gc2FmZSBtb2RlLiBFbmNsb3NlIGFsbCAnICtcbiAgICAgICAgICAgICAgICAgICAgJ21hdGgubWV0aG9kKCkgY2FsbHMgaW5zaWRlIGEgc2NvcGU6ICcgK1xuICAgICAgICAgICAgICAgICAgICAnbWF0aC5zY29wZSgoKSA9PiB7bWF0aC5tZXRob2QoKTsuLi59KSB0byBhdm9pZCBtZW1vcnkgJyArXG4gICAgICAgICAgICAgICAgICAgICdsZWFrcy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hY3RpdmVTY29wZS5wdXNoKHJlc3VsdCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUubWF0TXVsID0gZnVuY3Rpb24gKGEsIGIsIGFPcmllbnRhdGlvbiwgYk9yaWVudGF0aW9uKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChhT3JpZW50YXRpb24gPT09IHZvaWQgMCkgeyBhT3JpZW50YXRpb24gPSBNYXRyaXhPcmllbnRhdGlvbi5SRUdVTEFSOyB9XG4gICAgICAgIGlmIChiT3JpZW50YXRpb24gPT09IHZvaWQgMCkgeyBiT3JpZW50YXRpb24gPSBNYXRyaXhPcmllbnRhdGlvbi5SRUdVTEFSOyB9XG4gICAgICAgIHZhciBpbm5lclNoYXBlQSA9IChhT3JpZW50YXRpb24gPT09IE1hdHJpeE9yaWVudGF0aW9uLlJFR1VMQVIpID8gYS5zaGFwZVsxXSA6IGEuc2hhcGVbMF07XG4gICAgICAgIHZhciBpbm5lclNoYXBlQiA9IChiT3JpZW50YXRpb24gPT09IE1hdHJpeE9yaWVudGF0aW9uLlJFR1VMQVIpID8gYi5zaGFwZVswXSA6IGIuc2hhcGVbMV07XG4gICAgICAgIHV0aWwuYXNzZXJ0KGEucmFuayA9PT0gMiAmJiBiLnJhbmsgPT09IDIsIFwiRXJyb3IgaW4gbWF0TXVsOiBpbnB1dHMgbXVzdCBiZSByYW5rIDIsIGdvdCByYW5rcyBcIiArIGEucmFuayArXG4gICAgICAgICAgICAoXCIgYW5kIFwiICsgYi5yYW5rICsgXCIuXCIpKTtcbiAgICAgICAgdXRpbC5hc3NlcnQoaW5uZXJTaGFwZUEgPT09IGlubmVyU2hhcGVCLCBcIkVycm9yIGluIG1hdE11bDogaW5uZXIgc2hhcGVzIChcIiArIGlubmVyU2hhcGVBICsgXCIpIGFuZCAoXCIgK1xuICAgICAgICAgICAgKGlubmVyU2hhcGVCICsgXCIpIG9mIE5EQXJyYXlzIHdpdGggc2hhcGVzIFwiICsgYS5zaGFwZSArIFwiIGFuZCBcIikgK1xuICAgICAgICAgICAgKGIuc2hhcGUgKyBcIiBhbmQgb3JpZW50YXRpb25zIFwiICsgTWF0cml4T3JpZW50YXRpb25bYU9yaWVudGF0aW9uXSkgK1xuICAgICAgICAgICAgKFwiIGFuZCBcIiArIE1hdHJpeE9yaWVudGF0aW9uW2JPcmllbnRhdGlvbl0gKyBcIiBtdXN0IG1hdGNoLlwiKSk7XG4gICAgICAgIHJldHVybiB0aGlzLmV4ZWN1dGVPcCgnbWF0TXVsJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMubWF0TXVsSW50ZXJuYWwoYSwgYiwgYU9yaWVudGF0aW9uLCBiT3JpZW50YXRpb24pOyB9KTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS5leGVjdXRlT3AgPSBmdW5jdGlvbiAobmFtZSwgZikge1xuICAgICAgICB2YXIgc3RhcnQ7XG4gICAgICAgIGlmICh0aGlzLmRlYnVnTW9kZSkge1xuICAgICAgICAgICAgc3RhcnQgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzdWx0ID0gZigpO1xuICAgICAgICBpZiAodGhpcy5kZWJ1Z01vZGUpIHtcbiAgICAgICAgICAgIHZhciB2YWxzID0gcmVzdWx0LmdldFZhbHVlcygpO1xuICAgICAgICAgICAgdmFyIHRpbWUgPSB1dGlsLnJpZ2h0UGFkKHBlcmZvcm1hbmNlLm5vdygpIC0gc3RhcnQgKyBcIm1zXCIsIDkpO1xuICAgICAgICAgICAgdmFyIHBhZGRlZE5hbWUgPSB1dGlsLnJpZ2h0UGFkKG5hbWUsIDI1KTtcbiAgICAgICAgICAgIHZhciByYW5rID0gcmVzdWx0LnJhbms7XG4gICAgICAgICAgICB2YXIgc2l6ZSA9IHJlc3VsdC5zaXplO1xuICAgICAgICAgICAgdmFyIHNoYXBlID0gdXRpbC5yaWdodFBhZChyZXN1bHQuc2hhcGUudG9TdHJpbmcoKSwgMTQpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCIlY1wiICsgcGFkZGVkTmFtZSArIFwiXFx0JWNcIiArIHRpbWUgKyBcIlxcdCVjXCIgKyByYW5rICsgXCJEIFwiICsgc2hhcGUgKyBcIlxcdCVjXCIgKyBzaXplLCAnZm9udC13ZWlnaHQ6Ym9sZCcsICdjb2xvcjpyZWQnLCAnY29sb3I6Ymx1ZScsICdjb2xvcjogb3JhbmdlJyk7XG4gICAgICAgICAgICB0aGlzLmNoZWNrRm9yTmFOKHZhbHMsIHJlc3VsdC5kdHlwZSwgbmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMudHJhY2socmVzdWx0KTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS52ZWN0b3JUaW1lc01hdHJpeCA9IGZ1bmN0aW9uICh2LCBtYXRyaXgpIHtcbiAgICAgICAgdXRpbC5hc3NlcnQodi5yYW5rID09PSAxLCBcIkVycm9yIGluIHZlY3RvclRpbWVzTWF0cml4OiBmaXJzdCBpbnB1dCBtdXN0IGJlIHJhbmsgMSwgYnV0IGdvdCBcIiArXG4gICAgICAgICAgICAoXCJyYW5rIFwiICsgdi5yYW5rICsgXCIuXCIpKTtcbiAgICAgICAgdXRpbC5hc3NlcnQobWF0cml4LnJhbmsgPT09IDIsIFwiRXJyb3IgaW4gdmVjdG9yVGltZXNNYXRyaXg6IHNlY29uZCBpbnB1dCBtdXN0IGJlIHJhbmsgMiwgYnV0IGdvdCBcIiArXG4gICAgICAgICAgICAoXCJyYW5rIFwiICsgbWF0cml4LnJhbmsgKyBcIi5cIikpO1xuICAgICAgICB1dGlsLmFzc2VydCh2LnNpemUgPT09IG1hdHJpeC5zaGFwZVswXSwgXCJFcnJvciBpbiB2ZWN0b3JUaW1lc01hdHJpeDogc2l6ZSBvZiB2ZWN0b3IgKFwiICsgdi5zaXplICsgXCIpIFwiICtcbiAgICAgICAgICAgIChcIm11c3QgbWF0Y2ggZmlyc3QgZGltZW5zaW9uIG9mIG1hdHJpeCAoXCIgKyBtYXRyaXguc2hhcGVbMF0gKyBcIilcIikpO1xuICAgICAgICByZXR1cm4gdGhpcy5tYXRNdWwodi5hczJEKDEsIC0xKSwgbWF0cml4KS5hczFEKCk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUubWF0cml4VGltZXNWZWN0b3IgPSBmdW5jdGlvbiAobWF0cml4LCB2KSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0KHYucmFuayA9PT0gMSwgXCJFcnJvciBpbiBtYXRyaXhUaW1lc1ZlY3Rvcjogc2Vjb25kIGlucHV0IG11c3QgcmFuayAxLCBidXQgZ290IFwiICtcbiAgICAgICAgICAgIChcInJhbmsgXCIgKyB2LnJhbmsgKyBcIi5cIikpO1xuICAgICAgICB1dGlsLmFzc2VydChtYXRyaXgucmFuayA9PT0gMiwgXCJFcnJvciBpbiBtYXRyaXhUaW1lc1ZlY3RvcjogZmlyc3QgaW5wdXQgbXVzdCBiZSBhIHJhbmsgMiwgYnV0IGdvdCBcIiArXG4gICAgICAgICAgICAoXCJyYW5rIFwiICsgbWF0cml4LnJhbmsgKyBcIi5cIikpO1xuICAgICAgICB1dGlsLmFzc2VydCh2LnNpemUgPT09IG1hdHJpeC5zaGFwZVsxXSwgXCJFcnJvciBpbiBtYXRyaXhUaW1lc1ZlY3Rvcjogc2l6ZSBvZiBmaXJzdCByYW5rIDEgaW5wdXQgXCIgKyB2LnNpemUgKyBcIiBcIiArXG4gICAgICAgICAgICBcIm11c3QgbWF0Y2ggaW5uZXIgZGltZW5zaW9uIG9mIHNlY29uZCByYW5rIDIgaW5wdXQsIGJ1dCBnb3QgXCIgK1xuICAgICAgICAgICAgKFwic2hhcGUgXCIgKyBtYXRyaXguc2hhcGUgKyBcIi5cIikpO1xuICAgICAgICByZXR1cm4gdGhpcy5tYXRNdWwobWF0cml4LCB2LmFzMkQoLTEsIDEpKS5hczFEKCk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUuZG90UHJvZHVjdCA9IGZ1bmN0aW9uICh2MSwgdjIpIHtcbiAgICAgICAgdXRpbC5hc3NlcnQodjEucmFuayA9PT0gMSAmJiB2Mi5yYW5rID09PSAxLCBcIkVycm9yIGluIGRvdFByb2R1Y3Q6IGlucHV0cyBtdXN0IGJlIHJhbmsgMSwgYnV0IGdvdCByYW5rcyBcIiArXG4gICAgICAgICAgICAodjEucmFuayArIFwiIGFuZCBcIiArIHYyLnJhbmsgKyBcIi5cIikpO1xuICAgICAgICB1dGlsLmFzc2VydCh2MS5zaXplID09PSB2Mi5zaXplLCBcIkVycm9yIGluIGRvdFByb2R1Y3Q6IHNpemUgb2YgaW5wdXRzIChcIiArIHYxLnNpemUgKyBcIikgYW5kIChcIiArXG4gICAgICAgICAgICAodjIuc2l6ZSArIFwiKSBtdXN0IG1hdGNoLlwiKSk7XG4gICAgICAgIHJldHVybiB0aGlzLm1hdE11bCh2MS5hczJEKDEsIC0xKSwgdjIuYXMyRCgtMSwgMSkpLmFzU2NhbGFyKCk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUub3V0ZXJQcm9kdWN0ID0gZnVuY3Rpb24gKHYxLCB2Mikge1xuICAgICAgICB1dGlsLmFzc2VydCh2MS5yYW5rID09PSAxICYmIHYyLnJhbmsgPT09IDEsIFwiRXJyb3IgaW4gb3V0ZXJQcm9kdWN0OiBpbnB1dHMgbXVzdCBiZSByYW5rIDEsIGJ1dCBnb3QgcmFua3MgXCIgK1xuICAgICAgICAgICAgKHYxLnJhbmsgKyBcIiBhbmQgXCIgKyB2Mi5yYW5rICsgXCIuXCIpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubWF0TXVsKHYxLmFzMkQoLTEsIDEpLCB2Mi5hczJEKDEsIC0xKSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAobmRhcnJheSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gdGhpcy5leGVjdXRlT3AoJ2Nsb25lJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuY2xvbmVJbnRlcm5hbChuZGFycmF5KTsgfSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUucmVzaGFwZSA9IGZ1bmN0aW9uIChuZGFycmF5LCBuZXdTaGFwZSkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ21hdGgucmVzaGFwZSgpIGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSBjYWxsIHJlc2hhcGUoKSAnICtcbiAgICAgICAgICAgICdkaXJlY3RseSBvbiB0aGUgbmRhcnJheSBvYmplY3QnKTtcbiAgICAgICAgcmV0dXJuIG5kYXJyYXkucmVzaGFwZShuZXdTaGFwZSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUuc2xpY2UxRCA9IGZ1bmN0aW9uIChpbnB1dCwgYmVnaW4sIHNpemUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgc2xpY2VfdXRpbC5hc3NlcnRQYXJhbXNWYWxpZChpbnB1dCwgW2JlZ2luXSwgW3NpemVdKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhlY3V0ZU9wKCdzbGljZTFEJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuc2xpY2UxREludGVybmFsKGlucHV0LCBiZWdpbiwgc2l6ZSk7IH0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGgucHJvdG90eXBlLnNsaWNlMkQgPSBmdW5jdGlvbiAoaW5wdXQsIGJlZ2luLCBzaXplKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHNsaWNlX3V0aWwuYXNzZXJ0UGFyYW1zVmFsaWQoaW5wdXQsIGJlZ2luLCBzaXplKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhlY3V0ZU9wKCdzbGljZTJEJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuc2xpY2UyREludGVybmFsKGlucHV0LCBiZWdpbiwgc2l6ZSk7IH0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGgucHJvdG90eXBlLnNsaWNlM0QgPSBmdW5jdGlvbiAoaW5wdXQsIGJlZ2luLCBzaXplKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHNsaWNlX3V0aWwuYXNzZXJ0UGFyYW1zVmFsaWQoaW5wdXQsIGJlZ2luLCBzaXplKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhlY3V0ZU9wKCdzbGljZTNEJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuc2xpY2UzREludGVybmFsKGlucHV0LCBiZWdpbiwgc2l6ZSk7IH0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGgucHJvdG90eXBlLnNsaWNlNEQgPSBmdW5jdGlvbiAoaW5wdXQsIGJlZ2luLCBzaXplKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHNsaWNlX3V0aWwuYXNzZXJ0UGFyYW1zVmFsaWQoaW5wdXQsIGJlZ2luLCBzaXplKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhlY3V0ZU9wKCdzbGljZTREJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuc2xpY2U0REludGVybmFsKGlucHV0LCBiZWdpbiwgc2l6ZSk7IH0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGgucHJvdG90eXBlLmNvcHkyRCA9IGZ1bmN0aW9uIChzb3VyY2UsIHNvdXJjZUJlZ2luLCBzb3VyY2VTaXplLCBkZXN0LCBkZXN0QmVnaW4sIGRlc3RTaXplKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHV0aWwuYXNzZXJ0KHNvdXJjZUJlZ2luWzBdICsgc291cmNlU2l6ZVswXSA8PSBzb3VyY2Uuc2hhcGVbMF0gJiZcbiAgICAgICAgICAgIHNvdXJjZUJlZ2luWzFdICsgc291cmNlU2l6ZVsxXSA8PSBzb3VyY2Uuc2hhcGVbMV0sIFwiRXJyb3IgaW4gY29weTJEOiByZXF1ZXN0ZWQgc291cmNlIHN0YXJ0IHBvc2l0aW9uIFwiICsgc291cmNlQmVnaW4gKyBcIiBcIiArXG4gICAgICAgICAgICAoXCJhbmQgc291cmNlIHNpemUgXCIgKyBzb3VyY2VTaXplICsgXCIgd291bGQgb3ZlcmZsb3cgc291cmNlIE5EQXJyYXlcIikgK1xuICAgICAgICAgICAgKFwib2Ygc2hhcGUgXCIgKyBzb3VyY2Uuc2hhcGUgKyBcIi5cIikpO1xuICAgICAgICB1dGlsLmFzc2VydChkZXN0QmVnaW5bMF0gKyBkZXN0U2l6ZVswXSA8PSBkZXN0LnNoYXBlWzBdICYmXG4gICAgICAgICAgICBkZXN0QmVnaW5bMV0gKyBkZXN0U2l6ZVsxXSA8PSBkZXN0LnNoYXBlWzFdLCBcIkVycm9yIGluIGNvcHkyRDogcmVxdWVzdGVkIGRlc3Qgc3RhcnQgcG9zaXRpb24gXCIgKyBkZXN0QmVnaW4gKyBcIiBcIiArXG4gICAgICAgICAgICAoXCJhbmQgc291cmNlIHNpemUgXCIgKyBkZXN0U2l6ZSArIFwiIHdvdWxkIG92ZXJmbG93IGRlc3QgTkRBcnJheSBvZlwiKSArXG4gICAgICAgICAgICAoXCJzaGFwZSBcIiArIGRlc3Quc2hhcGUgKyBcIi5cIikpO1xuICAgICAgICBjb3B5MmRfdXRpbC52YWxpZGF0ZVNoYXBlcyhzb3VyY2VTaXplLCBkZXN0U2l6ZSk7XG4gICAgICAgIHRoaXMuZXhlY3V0ZU9wKCdjb3B5MkQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5jb3B5MkRJbnRlcm5hbChzb3VyY2UsIHNvdXJjZUJlZ2luLCBzb3VyY2VTaXplLCBkZXN0LCBkZXN0QmVnaW4sIGRlc3RTaXplKTtcbiAgICAgICAgICAgIHJldHVybiBkZXN0O1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS5jb25jYXQxRCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGNvbmNhdF91dGlsLmFzc2VydFBhcmFtcyhhLnNoYXBlLCBiLnNoYXBlLCAwKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhlY3V0ZU9wKCdjb25jYXQxRCcsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmNvbmNhdDFESW50ZXJuYWwoYSwgYik7IH0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGgucHJvdG90eXBlLmNvbmNhdDJEID0gZnVuY3Rpb24gKGEsIGIsIGF4aXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgY29uY2F0X3V0aWwuYXNzZXJ0UGFyYW1zKGEuc2hhcGUsIGIuc2hhcGUsIGF4aXMpO1xuICAgICAgICByZXR1cm4gdGhpcy5leGVjdXRlT3AoJ2NvbmNhdDJEJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuY29uY2F0MkRJbnRlcm5hbChhLCBiLCBheGlzKTsgfSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUuY29uY2F0M0QgPSBmdW5jdGlvbiAobmRhcnJheTEsIG5kYXJyYXkyLCBheGlzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGNvbmNhdF91dGlsLmFzc2VydFBhcmFtcyhuZGFycmF5MS5zaGFwZSwgbmRhcnJheTIuc2hhcGUsIGF4aXMpO1xuICAgICAgICByZXR1cm4gdGhpcy5leGVjdXRlT3AoJ2NvbmNhdDNEJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuY29uY2F0M0RJbnRlcm5hbChuZGFycmF5MSwgbmRhcnJheTIsIGF4aXMpOyB9KTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS5jb25jYXQ0RCA9IGZ1bmN0aW9uIChuZGFycmF5MSwgbmRhcnJheTIsIGF4aXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgY29uY2F0X3V0aWwuYXNzZXJ0UGFyYW1zKG5kYXJyYXkxLnNoYXBlLCBuZGFycmF5Mi5zaGFwZSwgYXhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzLmV4ZWN1dGVPcCgnY29uY2F0NEQnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5jb25jYXQ0REludGVybmFsKG5kYXJyYXkxLCBuZGFycmF5MiwgYXhpcyk7IH0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGgucHJvdG90eXBlLmxvZ1N1bUV4cCA9IGZ1bmN0aW9uIChpbnB1dCwgYXhpcywga2VlcERpbXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKGF4aXMgPT09IHZvaWQgMCkgeyBheGlzID0gbnVsbDsgfVxuICAgICAgICBpZiAoa2VlcERpbXMgPT09IHZvaWQgMCkgeyBrZWVwRGltcyA9IGZhbHNlOyB9XG4gICAgICAgIHZhciBheGVzID0gYXhpc191dGlsLnBhcnNlQXhpc1BhcmFtKGF4aXMsIGlucHV0LnNoYXBlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhlY3V0ZU9wKCdsb2dTdW1FeHAnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgeE1heCA9IF90aGlzLm1heChpbnB1dCwgYXhlcywgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgYSA9IF90aGlzLnN1YnRyYWN0KGlucHV0LCB4TWF4KTtcbiAgICAgICAgICAgIHZhciBiID0gX3RoaXMuZXhwKGEpO1xuICAgICAgICAgICAgdmFyIGMgPSBfdGhpcy5zdW0oYiwgYXhlcyk7XG4gICAgICAgICAgICB2YXIgZCA9IF90aGlzLmxvZyhjKTtcbiAgICAgICAgICAgIHZhciByZXMgPSBfdGhpcy5hZGQoeE1heC5yZXNoYXBlKGQuc2hhcGUpLCBkKTtcbiAgICAgICAgICAgIGlmIChrZWVwRGltcykge1xuICAgICAgICAgICAgICAgIHZhciBuZXdTaGFwZSA9IGF4aXNfdXRpbC5leHBhbmRTaGFwZVRvS2VlcERpbShyZXMuc2hhcGUsIGF4ZXMpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXMucmVzaGFwZShuZXdTaGFwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS5zdW0gPSBmdW5jdGlvbiAoaW5wdXQsIGF4aXMsIGtlZXBEaW1zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChheGlzID09PSB2b2lkIDApIHsgYXhpcyA9IG51bGw7IH1cbiAgICAgICAgaWYgKGtlZXBEaW1zID09PSB2b2lkIDApIHsga2VlcERpbXMgPSBmYWxzZTsgfVxuICAgICAgICB2YXIgb3JpZ0F4ZXMgPSBheGlzX3V0aWwucGFyc2VBeGlzUGFyYW0oYXhpcywgaW5wdXQuc2hhcGUpO1xuICAgICAgICB2YXIgYXhlcyA9IG9yaWdBeGVzO1xuICAgICAgICB2YXIgcGVybXV0ZWRBeGVzID0gYXhpc191dGlsLmdldFBlcm11dGVkQXhlcyhheGVzLCBpbnB1dC5yYW5rKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhlY3V0ZU9wKCdzdW0nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAocGVybXV0ZWRBeGVzICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpbnB1dCA9IF90aGlzLnRyYW5zcG9zZShpbnB1dCwgcGVybXV0ZWRBeGVzKTtcbiAgICAgICAgICAgICAgICBheGVzID0gYXhpc191dGlsLmdldElubmVyTW9zdEF4ZXMoYXhlcy5sZW5ndGgsIGlucHV0LnJhbmspO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHJlcyA9IF90aGlzLnN1bUludGVybmFsKGlucHV0LCBheGVzKTtcbiAgICAgICAgICAgIGlmIChrZWVwRGltcykge1xuICAgICAgICAgICAgICAgIHZhciBuZXdTaGFwZSA9IGF4aXNfdXRpbC5leHBhbmRTaGFwZVRvS2VlcERpbShyZXMuc2hhcGUsIG9yaWdBeGVzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzLnJlc2hhcGUobmV3U2hhcGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUubWVhbiA9IGZ1bmN0aW9uICh4LCBheGlzLCBrZWVwRGltcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoYXhpcyA9PT0gdm9pZCAwKSB7IGF4aXMgPSBudWxsOyB9XG4gICAgICAgIGlmIChrZWVwRGltcyA9PT0gdm9pZCAwKSB7IGtlZXBEaW1zID0gZmFsc2U7IH1cbiAgICAgICAgdmFyIGF4ZXMgPSBheGlzX3V0aWwucGFyc2VBeGlzUGFyYW0oYXhpcywgeC5zaGFwZSk7XG4gICAgICAgIHZhciBzaGFwZXMgPSBheGlzX3V0aWwuY29tcHV0ZU91dEFuZFJlZHVjZVNoYXBlcyh4LnNoYXBlLCBheGVzKTtcbiAgICAgICAgdmFyIHJlZHVjZVNoYXBlID0gc2hhcGVzWzFdO1xuICAgICAgICB2YXIgcmVkdWNlU2l6ZSA9IHV0aWwuc2l6ZUZyb21TaGFwZShyZWR1Y2VTaGFwZSk7XG4gICAgICAgIHJldHVybiB0aGlzLmV4ZWN1dGVPcCgnbWVhbicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5zY29wZShmdW5jdGlvbiAoa2VlcCwgdHJhY2spIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzID0gX3RoaXMuZGl2aWRlKHgsIHRyYWNrKG5kYXJyYXlfMS5TY2FsYXIubmV3KHJlZHVjZVNpemUpKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLnN1bShyZXMsIGF4aXMsIGtlZXBEaW1zKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS5hcmdNaW4gPSBmdW5jdGlvbiAoaW5wdXQsIGF4aXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKGF4aXMgPT09IHZvaWQgMCkgeyBheGlzID0gbnVsbDsgfVxuICAgICAgICB2YXIgYXhlcyA9IGF4aXNfdXRpbC5wYXJzZUF4aXNQYXJhbShheGlzLCBpbnB1dC5zaGFwZSk7XG4gICAgICAgIHZhciBwZXJtdXRlZEF4ZXMgPSBheGlzX3V0aWwuZ2V0UGVybXV0ZWRBeGVzKGF4ZXMsIGlucHV0LnJhbmspO1xuICAgICAgICByZXR1cm4gdGhpcy5leGVjdXRlT3AoJ2FyZ01pbicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChwZXJtdXRlZEF4ZXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlucHV0ID0gX3RoaXMudHJhbnNwb3NlKGlucHV0LCBwZXJtdXRlZEF4ZXMpO1xuICAgICAgICAgICAgICAgIGF4ZXMgPSBheGlzX3V0aWwuZ2V0SW5uZXJNb3N0QXhlcyhheGVzLmxlbmd0aCwgaW5wdXQucmFuayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuYXJnTWluSW50ZXJuYWwoaW5wdXQsIGF4ZXMpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS5hcmdNYXggPSBmdW5jdGlvbiAoaW5wdXQsIGF4aXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKGF4aXMgPT09IHZvaWQgMCkgeyBheGlzID0gbnVsbDsgfVxuICAgICAgICB2YXIgYXhlcyA9IGF4aXNfdXRpbC5wYXJzZUF4aXNQYXJhbShheGlzLCBpbnB1dC5zaGFwZSk7XG4gICAgICAgIHZhciBwZXJtdXRlZEF4ZXMgPSBheGlzX3V0aWwuZ2V0UGVybXV0ZWRBeGVzKGF4ZXMsIGlucHV0LnJhbmspO1xuICAgICAgICByZXR1cm4gdGhpcy5leGVjdXRlT3AoJ2FyZ01heCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChwZXJtdXRlZEF4ZXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlucHV0ID0gX3RoaXMudHJhbnNwb3NlKGlucHV0LCBwZXJtdXRlZEF4ZXMpO1xuICAgICAgICAgICAgICAgIGF4ZXMgPSBheGlzX3V0aWwuZ2V0SW5uZXJNb3N0QXhlcyhheGVzLmxlbmd0aCwgaW5wdXQucmFuayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuYXJnTWF4SW50ZXJuYWwoaW5wdXQsIGF4ZXMpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS5hcmdNYXhFcXVhbHMgPSBmdW5jdGlvbiAoeDEsIHgyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHV0aWwuYXNzZXJ0U2hhcGVzTWF0Y2goeDEuc2hhcGUsIHgyLnNoYXBlLCAnRXJyb3IgaW4gYXJnTWF4RXF1YWxzOiAnKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhlY3V0ZU9wKCdhcmdNYXhFcXVhbHMnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5zY29wZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuZXF1YWwoX3RoaXMuYXJnTWF4KHgxKSwgX3RoaXMuYXJnTWF4KHgyKSk7XG4gICAgICAgIH0pOyB9KTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS5lcXVhbCA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiB0aGlzLmV4ZWN1dGVPcCgnZXF1YWwnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5lcXVhbEludGVybmFsKHgsIHkpOyB9KTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS5lcXVhbFN0cmljdCA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0U2hhcGVzTWF0Y2goeC5zaGFwZSwgeS5zaGFwZSwgJ0Vycm9yIGluIGVxdWFsU3RyaWN0OiAnKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXF1YWwoeCwgeSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUudG9wSyA9IGZ1bmN0aW9uIChuZGFycmF5LCBrKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHV0aWwuYXNzZXJ0KGsgPD0gbmRhcnJheS5zaXplLCBcIkVycm9yIGluIHRvcEs6IGsgdmFsdWUgKFwiICsgayArIFwiKSBtdXN0IGJlIGxlc3MgdGhhbiBzaXplIG9mIGlucHV0IFwiICtcbiAgICAgICAgICAgIChcIm5kYXJyYXksIGdvdCBzaGFwZSBcIiArIG5kYXJyYXkuc2hhcGUgKyBcIi5cIikpO1xuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICB0aGlzLmV4ZWN1dGVPcCgndG9wSycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IF90aGlzLnRvcEtJbnRlcm5hbChuZGFycmF5LCBrKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQudmFsdWVzO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy50cmFjayhyZXN1bHQuaW5kaWNlcyk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUubWluID0gZnVuY3Rpb24gKGlucHV0LCBheGlzLCBrZWVwRGltcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoYXhpcyA9PT0gdm9pZCAwKSB7IGF4aXMgPSBudWxsOyB9XG4gICAgICAgIGlmIChrZWVwRGltcyA9PT0gdm9pZCAwKSB7IGtlZXBEaW1zID0gZmFsc2U7IH1cbiAgICAgICAgdmFyIG9yaWdBeGVzID0gYXhpc191dGlsLnBhcnNlQXhpc1BhcmFtKGF4aXMsIGlucHV0LnNoYXBlKTtcbiAgICAgICAgdmFyIGF4ZXMgPSBvcmlnQXhlcztcbiAgICAgICAgdmFyIHBlcm11dGVkQXhlcyA9IGF4aXNfdXRpbC5nZXRQZXJtdXRlZEF4ZXMoYXhlcywgaW5wdXQucmFuayk7XG4gICAgICAgIHJldHVybiB0aGlzLmV4ZWN1dGVPcCgnbWluJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHBlcm11dGVkQXhlcyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaW5wdXQgPSBfdGhpcy50cmFuc3Bvc2UoaW5wdXQsIHBlcm11dGVkQXhlcyk7XG4gICAgICAgICAgICAgICAgYXhlcyA9IGF4aXNfdXRpbC5nZXRJbm5lck1vc3RBeGVzKGF4ZXMubGVuZ3RoLCBpbnB1dC5yYW5rKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciByZXMgPSBfdGhpcy5taW5JbnRlcm5hbChpbnB1dCwgYXhlcyk7XG4gICAgICAgICAgICBpZiAoa2VlcERpbXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmV3U2hhcGUgPSBheGlzX3V0aWwuZXhwYW5kU2hhcGVUb0tlZXBEaW0ocmVzLnNoYXBlLCBvcmlnQXhlcyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcy5yZXNoYXBlKG5ld1NoYXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGgucHJvdG90eXBlLm1heCA9IGZ1bmN0aW9uIChpbnB1dCwgYXhpcywga2VlcERpbXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKGF4aXMgPT09IHZvaWQgMCkgeyBheGlzID0gbnVsbDsgfVxuICAgICAgICBpZiAoa2VlcERpbXMgPT09IHZvaWQgMCkgeyBrZWVwRGltcyA9IGZhbHNlOyB9XG4gICAgICAgIHZhciBvcmlnQXhlcyA9IGF4aXNfdXRpbC5wYXJzZUF4aXNQYXJhbShheGlzLCBpbnB1dC5zaGFwZSk7XG4gICAgICAgIHZhciBheGVzID0gb3JpZ0F4ZXM7XG4gICAgICAgIHZhciBwZXJtdXRlZEF4ZXMgPSBheGlzX3V0aWwuZ2V0UGVybXV0ZWRBeGVzKGF4ZXMsIGlucHV0LnJhbmspO1xuICAgICAgICByZXR1cm4gdGhpcy5leGVjdXRlT3AoJ21heCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChwZXJtdXRlZEF4ZXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlucHV0ID0gX3RoaXMudHJhbnNwb3NlKGlucHV0LCBwZXJtdXRlZEF4ZXMpO1xuICAgICAgICAgICAgICAgIGF4ZXMgPSBheGlzX3V0aWwuZ2V0SW5uZXJNb3N0QXhlcyhheGVzLmxlbmd0aCwgaW5wdXQucmFuayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcmVzID0gX3RoaXMubWF4SW50ZXJuYWwoaW5wdXQsIGF4ZXMpO1xuICAgICAgICAgICAgaWYgKGtlZXBEaW1zKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5ld1NoYXBlID0gYXhpc191dGlsLmV4cGFuZFNoYXBlVG9LZWVwRGltKHJlcy5zaGFwZSwgb3JpZ0F4ZXMpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXMucmVzaGFwZShuZXdTaGFwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS5zb2Z0bWF4ID0gZnVuY3Rpb24gKGxvZ2l0cywgZGltKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChkaW0gPT09IHZvaWQgMCkgeyBkaW0gPSAtMTsgfVxuICAgICAgICBpZiAoZGltID09PSAtMSkge1xuICAgICAgICAgICAgZGltID0gbG9naXRzLnJhbmsgLSAxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkaW0gIT09IGxvZ2l0cy5yYW5rIC0gMSkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ1NvZnRtYXggYWxvbmcgYSBub24tbGFzdCBkaW1lbnNpb24gaXMgbm90IHlldCBzdXBwb3J0ZWQuICcgK1xuICAgICAgICAgICAgICAgIChcIkxvZ2l0cyB3YXMgcmFuayBcIiArIGxvZ2l0cy5yYW5rICsgXCIgYW5kIGRpbSB3YXMgXCIgKyBkaW0pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5leGVjdXRlT3AoJ3NvZnRtYXgnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuc2NvcGUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBsc2UgPSBfdGhpcy5sb2dTdW1FeHAobG9naXRzLCBbZGltXSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgdmFyIGxvZ1Jlc3VsdCA9IF90aGlzLnN1YnRyYWN0KGxvZ2l0cywgbHNlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuZXhwKGxvZ1Jlc3VsdCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUuc3dpdGNoRGltID0gZnVuY3Rpb24gKGEsIG5ld0RpbSkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc3Bvc2UoYSwgbmV3RGltKTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS50aWxlID0gZnVuY3Rpb24gKGEsIHJlcHMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdXRpbC5hc3NlcnQoYS5yYW5rID09PSByZXBzLmxlbmd0aCwgXCJFcnJvciBpbiB0cmFuc3Bvc2U6IHJhbmsgb2YgaW5wdXQgXCIgKyBhLnJhbmsgKyBcIiBcIiArXG4gICAgICAgICAgICAoXCJtdXN0IG1hdGNoIGxlbmd0aCBvZiByZXBzIFwiICsgcmVwcyArIFwiLlwiKSk7XG4gICAgICAgIHJldHVybiB0aGlzLmV4ZWN1dGVPcCgndGlsZScsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLnRpbGVJbnRlcm5hbChhLCByZXBzKTsgfSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUudHJhbnNwb3NlID0gZnVuY3Rpb24gKGEsIHBlcm0pIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHBlcm0gPT0gbnVsbCkge1xuICAgICAgICAgICAgcGVybSA9IGEuc2hhcGUubWFwKGZ1bmN0aW9uIChzLCBpKSB7IHJldHVybiBpOyB9KS5yZXZlcnNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdXRpbC5hc3NlcnQoYS5yYW5rID09PSBwZXJtLmxlbmd0aCwgXCJFcnJvciBpbiB0cmFuc3Bvc2U6IHJhbmsgb2YgaW5wdXQgXCIgKyBhLnJhbmsgKyBcIiBcIiArXG4gICAgICAgICAgICAoXCJtdXN0IG1hdGNoIGxlbmd0aCBvZiBwZXJtIFwiICsgcGVybSArIFwiLlwiKSk7XG4gICAgICAgIHJldHVybiB0aGlzLmV4ZWN1dGVPcCgndHJhbnNwb3NlJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMudHJhbnNwb3NlSW50ZXJuYWwoYSwgcGVybSk7IH0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGgucHJvdG90eXBlLnNjYWxhclBsdXNBcnJheSA9IGZ1bmN0aW9uIChjLCBhKSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0KGMuc2l6ZSA9PT0gMSwgXCJFcnJvciBpbiBzY2FsYXJQbHVzQXJyYXk6IGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgcmFuayAwLCBidXQgZ290IFwiICtcbiAgICAgICAgICAgIChcInJhbmsgXCIgKyBjLnJhbmsgKyBcIi5cIikpO1xuICAgICAgICByZXR1cm4gdGhpcy5hZGQoYywgYSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUuc2NhbGFyTWludXNBcnJheSA9IGZ1bmN0aW9uIChjLCBhKSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0KGMuc2l6ZSA9PT0gMSwgXCJFcnJvciBpbiBzY2FsYXJNaW51c0FycmF5OiBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIHJhbmsgMCwgYnV0IGdvdCBcIiArXG4gICAgICAgICAgICAoXCJyYW5rIFwiICsgYy5yYW5rICsgXCIuXCIpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3VidHJhY3QoYywgYSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUuYXJyYXlNaW51c1NjYWxhciA9IGZ1bmN0aW9uIChhLCBjKSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0KGMuc2l6ZSA9PT0gMSwgXCJFcnJvciBpbiBhcnJheU1pbnVzU2NhbGFyOiBzZWNvbmQgYXJndW1lbnQgbXVzdCBiZSByYW5rIDAsIGJ1dCBcIiArXG4gICAgICAgICAgICAoXCJnb3QgcmFuayBcIiArIGMucmFuayArIFwiLlwiKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnN1YnRyYWN0KGEsIGMpO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGgucHJvdG90eXBlLm5lZyA9IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiB0aGlzLmV4ZWN1dGVPcCgnbmVnJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMubmVnSW50ZXJuYWwoYSk7IH0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGgucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGJyb2FkY2FzdF91dGlsLmFzc2VydEFuZEdldEJyb2FkY2FzdFNoYXBlKGEuc2hhcGUsIGIuc2hhcGUpO1xuICAgICAgICByZXR1cm4gdGhpcy5leGVjdXRlT3AoJ2FkZCcsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmFkZEludGVybmFsKGEsIGIpOyB9KTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS5hZGRTdHJpY3QgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICB1dGlsLmFzc2VydFNoYXBlc01hdGNoKGEuc2hhcGUsIGIuc2hhcGUsICdFcnJvciBpbiBhZGRTdHJpY3Q6ICcpO1xuICAgICAgICByZXR1cm4gdGhpcy5hZGQoYSwgYik7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUuc3VidHJhY3QgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBicm9hZGNhc3RfdXRpbC5hc3NlcnRBbmRHZXRCcm9hZGNhc3RTaGFwZShhLnNoYXBlLCBiLnNoYXBlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhlY3V0ZU9wKCdzdWJ0cmFjdCcsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLnN1YnRyYWN0SW50ZXJuYWwoYSwgYik7IH0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGgucHJvdG90eXBlLnN1YiA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN1YnRyYWN0KGEsIGIpO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGgucHJvdG90eXBlLnN1YlN0cmljdCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0U2hhcGVzTWF0Y2goYS5zaGFwZSwgYi5zaGFwZSwgJ0Vycm9yIGluIHN1YlN0cmljdDogJyk7XG4gICAgICAgIHJldHVybiB0aGlzLnN1YnRyYWN0KGEsIGIpO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGgucHJvdG90eXBlLm11bHRpcGx5ID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgYnJvYWRjYXN0X3V0aWwuYXNzZXJ0QW5kR2V0QnJvYWRjYXN0U2hhcGUoYS5zaGFwZSwgYi5zaGFwZSk7XG4gICAgICAgIHJldHVybiB0aGlzLmV4ZWN1dGVPcCgnbXVsdGlwbHknLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5tdWx0aXBseUludGVybmFsKGEsIGIpOyB9KTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS5lbGVtZW50V2lzZU11bCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm11bHRpcGx5U3RyaWN0KGEsIGIpO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGgucHJvdG90eXBlLm11bHRpcGx5U3RyaWN0ID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgdXRpbC5hc3NlcnRTaGFwZXNNYXRjaChhLnNoYXBlLCBiLnNoYXBlLCAnRXJyb3IgaW4gbXVsdGlwbHlTdHJpY3Q6ICcpO1xuICAgICAgICByZXR1cm4gdGhpcy5tdWx0aXBseShhLCBiKTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS5kaXZpZGUgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBicm9hZGNhc3RfdXRpbC5hc3NlcnRBbmRHZXRCcm9hZGNhc3RTaGFwZShhLnNoYXBlLCBiLnNoYXBlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhlY3V0ZU9wKCdkaXZpZGUnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5kaXZpZGVJbnRlcm5hbChhLCBiKTsgfSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUuZGl2aWRlU3RyaWN0ID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgdXRpbC5hc3NlcnRTaGFwZXNNYXRjaChhLnNoYXBlLCBiLnNoYXBlLCAnRXJyb3IgaW4gZGl2aWRlU3RyaWN0OiAnKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGl2aWRlKGEsIGIpO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGgucHJvdG90eXBlLnNjYWxhckRpdmlkZWRCeUFycmF5ID0gZnVuY3Rpb24gKGMsIGEpIHtcbiAgICAgICAgdXRpbC5hc3NlcnQoYy5zaXplID09PSAxLCBcIkVycm9yIGluIHNjYWxhckRpdmlkZWRCeUFycmF5OiBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIHJhbmsgMCwgYnV0IFwiICtcbiAgICAgICAgICAgIChcImdvdCBOREFycmF5IG9mIHJhbmsgXCIgKyBjLnJhbmsgKyBcIi5cIikpO1xuICAgICAgICByZXR1cm4gdGhpcy5kaXZpZGUoYywgYSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUuYXJyYXlEaXZpZGVkQnlTY2FsYXIgPSBmdW5jdGlvbiAoYSwgYykge1xuICAgICAgICB1dGlsLmFzc2VydChjLnNpemUgPT09IDEsIFwiRXJyb3IgaW4gYXJyYXlEaXZpZGVkQnlTY2FsYXI6IHNlY29uZCBhcmd1bWVudCBtdXN0IGJlIHJhbmsgMCwgXCIgK1xuICAgICAgICAgICAgKFwiYnV0IGdvdCBOREFycmF5IG9mIHJhbmsgXCIgKyBjLnJhbmsgKyBcIi5cIikpO1xuICAgICAgICByZXR1cm4gdGhpcy5kaXZpZGUoYSwgYyk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUuY2VpbCA9IGZ1bmN0aW9uIChuZGFycmF5KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiB0aGlzLmV4ZWN1dGVPcCgnY2VpbCcsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmNlaWxJbnRlcm5hbChuZGFycmF5KTsgfSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUuZmxvb3IgPSBmdW5jdGlvbiAobmRhcnJheSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gdGhpcy5leGVjdXRlT3AoJ2Zsb29yJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuZmxvb3JJbnRlcm5hbChuZGFycmF5KTsgfSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUuZXhwID0gZnVuY3Rpb24gKG5kYXJyYXkpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhlY3V0ZU9wKCdleHAnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5leHBJbnRlcm5hbChuZGFycmF5KTsgfSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUubG9nID0gZnVuY3Rpb24gKG5kYXJyYXkpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhlY3V0ZU9wKCdsb2cnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5sb2dJbnRlcm5hbChuZGFycmF5KTsgfSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUuc3FydCA9IGZ1bmN0aW9uIChuZGFycmF5KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiB0aGlzLmV4ZWN1dGVPcCgnc3FydCcsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLnNxcnRJbnRlcm5hbChuZGFycmF5KTsgfSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUuc3F1YXJlID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhlY3V0ZU9wKCdzcXVhcmUnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5zcXVhcmVJbnRlcm5hbCh4KTsgfSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUuYWJzID0gZnVuY3Rpb24gKG5kYXJyYXkpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhlY3V0ZU9wKCdhYnMnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5hYnNJbnRlcm5hbChuZGFycmF5KTsgfSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUuY2xpcCA9IGZ1bmN0aW9uIChuZGFycmF5LCBtaW4sIG1heCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB1dGlsLmFzc2VydCgobWluIDw9IG1heCksIFwiRXJyb3IgaW4gY2xpcDogbWluIChcIiArIG1pbiArIFwiKSBtdXN0IGJlXCIgK1xuICAgICAgICAgICAgKFwibGVzcyB0aGFuIG9yIGVxdWFsIHRvIG1heCAoXCIgKyBtYXggKyBcIikuXCIpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhlY3V0ZU9wKCdjbGlwJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuY2xpcEludGVybmFsKG5kYXJyYXksIG1pbiwgbWF4KTsgfSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUucmVsdSA9IGZ1bmN0aW9uIChuZGFycmF5KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiB0aGlzLmV4ZWN1dGVPcCgncmVsdScsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLnJlbHVJbnRlcm5hbChuZGFycmF5KTsgfSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUuZWx1ID0gZnVuY3Rpb24gKG5kYXJyYXkpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhlY3V0ZU9wKCdlbHUnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5lbHVJbnRlcm5hbChuZGFycmF5KTsgfSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUubGVha3lSZWx1ID0gZnVuY3Rpb24gKG5kYXJyYXksIGFscGhhKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChhbHBoYSA9PT0gdm9pZCAwKSB7IGFscGhhID0gMC4yOyB9XG4gICAgICAgIHJldHVybiB0aGlzLmV4ZWN1dGVPcCgnbGVha3lSZWx1JywgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMubGVha3lSZWx1SW50ZXJuYWwobmRhcnJheSwgYWxwaGEpOyB9KTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS5zaWdtb2lkID0gZnVuY3Rpb24gKG5kYXJyYXkpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhlY3V0ZU9wKCdzaWdtb2lkJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuc2lnbW9pZEludGVybmFsKG5kYXJyYXkpOyB9KTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS5zaW4gPSBmdW5jdGlvbiAobmRhcnJheSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gdGhpcy5leGVjdXRlT3AoJ3NpbicsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLnNpbkludGVybmFsKG5kYXJyYXkpOyB9KTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS5jb3MgPSBmdW5jdGlvbiAobmRhcnJheSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gdGhpcy5leGVjdXRlT3AoJ2NvcycsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmNvc0ludGVybmFsKG5kYXJyYXkpOyB9KTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS50YW4gPSBmdW5jdGlvbiAobmRhcnJheSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gdGhpcy5leGVjdXRlT3AoJ3RhbicsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLnRhbkludGVybmFsKG5kYXJyYXkpOyB9KTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS5hc2luID0gZnVuY3Rpb24gKG5kYXJyYXkpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhlY3V0ZU9wKCdhc2luJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuYXNpbkludGVybmFsKG5kYXJyYXkpOyB9KTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS5hY29zID0gZnVuY3Rpb24gKG5kYXJyYXkpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhlY3V0ZU9wKCdhY29zJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuYWNvc0ludGVybmFsKG5kYXJyYXkpOyB9KTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS5hdGFuID0gZnVuY3Rpb24gKG5kYXJyYXkpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhlY3V0ZU9wKCdhdGFuJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuYXRhbkludGVybmFsKG5kYXJyYXkpOyB9KTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS5zaW5oID0gZnVuY3Rpb24gKG5kYXJyYXkpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhlY3V0ZU9wKCdzaW5oJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuc2luaEludGVybmFsKG5kYXJyYXkpOyB9KTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS5jb3NoID0gZnVuY3Rpb24gKG5kYXJyYXkpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhlY3V0ZU9wKCdjb3NoJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuY29zaEludGVybmFsKG5kYXJyYXkpOyB9KTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS50YW5oID0gZnVuY3Rpb24gKG5kYXJyYXkpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhlY3V0ZU9wKCd0YW5oJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMudGFuaEludGVybmFsKG5kYXJyYXkpOyB9KTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS5zdGVwID0gZnVuY3Rpb24gKG5kYXJyYXksIGFscGhhKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChhbHBoYSA9PT0gdm9pZCAwKSB7IGFscGhhID0gMC4wOyB9XG4gICAgICAgIHJldHVybiB0aGlzLmV4ZWN1dGVPcCgnc3RlcCcsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLnN0ZXBJbnRlcm5hbChuZGFycmF5LCBhbHBoYSk7IH0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGgucHJvdG90eXBlLnNjYWxlZEFycmF5QWRkID0gZnVuY3Rpb24gKGMxLCBhLCBjMiwgYikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB1dGlsLmFzc2VydChjMS5zaXplID09PSAxLCBcIkVycm9yIGluIHNjYWxlZEFycmF5QWRkOiBmaXJzdCBhcmd1bWVudCBtdXN0IHJhbmsgMCwgYnV0IGdvdCBcIiArXG4gICAgICAgICAgICAoXCIgcmFuayBcIiArIGMxLnJhbmsgKyBcIi5cIikpO1xuICAgICAgICB1dGlsLmFzc2VydChjMi5zaXplID09PSAxLCBcIkVycm9yIGluIHNjYWxlZEFycmF5QWRkOiB0aGlyZCBhcmd1bWVudCBtdXN0IGJlIHJhbmsgMCwgYnV0IGdvdCBcIiArXG4gICAgICAgICAgICAoXCJOREFycmF5IG9mIHJhbmsgXCIgKyBjMi5yYW5rICsgXCIuXCIpKTtcbiAgICAgICAgdXRpbC5hc3NlcnRTaGFwZXNNYXRjaChhLnNoYXBlLCBiLnNoYXBlLCAnRXJyb3IgaW4gc2NhbGVkQXJyYXlBZGQ6ICcpO1xuICAgICAgICByZXR1cm4gdGhpcy5leGVjdXRlT3AoJ3NjYWxlZEFycmF5QWRkJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuc2NhbGVkQXJyYXlBZGRJbnRlcm5hbChjMSwgYSwgYzIsIGIpOyB9KTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS5zY2FsYXJUaW1lc0FycmF5ID0gZnVuY3Rpb24gKGMsIGEpIHtcbiAgICAgICAgdXRpbC5hc3NlcnQoYy5zaXplID09PSAxLCBcIkVycm9yIGluIGFycmF5RGl2aWRlZEJ5U2NhbGFyOiBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIHJhbmsgMCwgYnV0IFwiICtcbiAgICAgICAgICAgIChcImdvdCByYW5rIFwiICsgYy5yYW5rICsgXCIuXCIpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubXVsdGlwbHkoYywgYSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUuZWxlbWVudFdpc2VNdWxCcm9hZGNhc3QgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICB1dGlsLmFzc2VydChhLnJhbmsgPT09IDIsIFwiRXJyb3IgaW4gZWxlbWVudFdpc2VNdWxCcm9hZGNhc3Q6IGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgXCIgK1xuICAgICAgICAgICAgKFwicmFuayAyLCBidXQgZ290IHJhbmsgXCIgKyBhLnJhbmsgKyBcIi5cIikpO1xuICAgICAgICB1dGlsLmFzc2VydChiLnJhbmsgPT09IDIsIFwiRXJyb3IgaW4gZWxlbWVudFdpc2VNdWxCcm9hZGNhc3Q6IHNlY29uZCBhcmd1bWVudCBtdXN0IGJlIFwiICtcbiAgICAgICAgICAgIChcInJhbmsgMiwgYnV0IGdvdCByYW5rIFwiICsgYi5yYW5rICsgXCIuXCIpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubXVsdGlwbHkoYSwgYik7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUuY29udjJkID0gZnVuY3Rpb24gKHgsIGZpbHRlciwgYmlhcywgc3RyaWRlcywgcGFkKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHV0aWwuYXNzZXJ0KHgucmFuayA9PT0gMywgXCJFcnJvciBpbiBjb252MmQ6IHggbXVzdCBiZSByYW5rIDMsIGJ1dCBnb3QgcmFuayBcIiArIHgucmFuayArIFwiLlwiKTtcbiAgICAgICAgdXRpbC5hc3NlcnQoZmlsdGVyLnJhbmsgPT09IDQsIFwiRXJyb3IgaW4gY29udjJkOiBmaWx0ZXIgbXVzdCBiZSByYW5rIDQsIGJ1dCBnb3QgcmFuayBcIiArXG4gICAgICAgICAgICAoZmlsdGVyLnJhbmsgKyBcIi5cIikpO1xuICAgICAgICBpZiAoYmlhcyAhPSBudWxsKSB7XG4gICAgICAgICAgICB1dGlsLmFzc2VydChiaWFzLnJhbmsgPT09IDEsIFwiRXJyb3IgaW4gY29udjJkOiBiaWFzIG11c3QgYmUgcmFuayAxLCBidXQgZ290IHJhbmsgXCIgK1xuICAgICAgICAgICAgICAgIChiaWFzLnJhbmsgKyBcIi5cIikpO1xuICAgICAgICB9XG4gICAgICAgIHV0aWwuYXNzZXJ0KHguc2hhcGVbMl0gPT09IGZpbHRlci5zaGFwZVsyXSwgXCJFcnJvciBpbiBjb252MmQ6IGRlcHRoIG9mIGlucHV0IChcIiArIHguc2hhcGVbMl0gKyBcIikgbXVzdCBtYXRjaCAgXCIgK1xuICAgICAgICAgICAgKFwiaW5wdXQgZGVwdGggZm9yIGZpbHRlciBcIiArIGZpbHRlci5zaGFwZVsyXSArIFwiLlwiKSk7XG4gICAgICAgIHZhciBmaWx0ZXJIZWlnaHQgPSBmaWx0ZXIuc2hhcGVbMF07XG4gICAgICAgIHZhciBmaWx0ZXJXaWR0aCA9IGZpbHRlci5zaGFwZVsxXTtcbiAgICAgICAgdmFyIG91dERlcHRoID0gZmlsdGVyLnNoYXBlWzNdO1xuICAgICAgICB2YXIgX2EgPSBwYXJzZVR1cGxlUGFyYW0oc3RyaWRlcyksIHN0cmlkZUhlaWdodCA9IF9hWzBdLCBzdHJpZGVXaWR0aCA9IF9hWzFdO1xuICAgICAgICB2YXIgY29udkluZm8gPSBjb252X3V0aWwuY29tcHV0ZUNvbnYyREluZm8oeC5zaGFwZSwgZmlsdGVySGVpZ2h0LCBmaWx0ZXJXaWR0aCwgb3V0RGVwdGgsIHN0cmlkZUhlaWdodCwgc3RyaWRlV2lkdGgsIHBhZCk7XG4gICAgICAgIHJldHVybiB0aGlzLmV4ZWN1dGVPcCgnY29udjJkJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuY29udjJkSW50ZXJuYWwoeCwgZmlsdGVyLCBiaWFzLCBjb252SW5mbyk7IH0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGgucHJvdG90eXBlLmNvbnYyZEJhY2tQcm9wID0gZnVuY3Rpb24gKHgsIGR5LCBmaWx0ZXIsIHN0cmlkZXMsIHBhZCkge1xuICAgICAgICB2YXIgZHcgPSB0aGlzLmNvbnYyZERlckZpbHRlcih4LCBkeSwgZmlsdGVyLnNoYXBlLCBzdHJpZGVzLCBwYWQpO1xuICAgICAgICB2YXIgZGIgPSB0aGlzLmNvbnYyZERlckJpYXMoZHkpO1xuICAgICAgICB2YXIgZHggPSB0aGlzLmNvbnYyZERlcklucHV0KHguc2hhcGUsIGR5LCBmaWx0ZXIsIHN0cmlkZXMsIHBhZCk7XG4gICAgICAgIHJldHVybiB7IGRiOiBkYiwgZHc6IGR3LCBkeDogZHggfTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS5jb252MmREZXJJbnB1dCA9IGZ1bmN0aW9uIChpblNoYXBlLCBkeSwgZmlsdGVyLCBzdHJpZGVzLCBwYWQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGluRGVwdGggPSBpblNoYXBlWzJdO1xuICAgICAgICB2YXIgb3V0RGVwdGggPSBkeS5zaGFwZVsyXTtcbiAgICAgICAgdXRpbC5hc3NlcnQoaW5TaGFwZS5sZW5ndGggPT09IDMsIFwiRXJyb3IgaW4gY29udjJkRGVySW5wdXQ6IHggbXVzdCBiZSByYW5rIDMsIGJ1dCBnb3QgcmFuayBcIiArXG4gICAgICAgICAgICAoaW5TaGFwZS5sZW5ndGggKyBcIi5cIikpO1xuICAgICAgICB1dGlsLmFzc2VydChkeS5yYW5rID09PSAzLCBcIkVycm9yIGluIGNvbnYyZERlcklucHV0OiBkeSBtdXN0IGJlIHJhbmsgMywgYnV0IGdvdCBcIiArXG4gICAgICAgICAgICAoXCJyYW5rIFwiICsgZHkucmFuaykpO1xuICAgICAgICB1dGlsLmFzc2VydChmaWx0ZXIucmFuayA9PT0gNCwgXCJFcnJvciBpbiBjb252MmREZXJJbnB1dDogZmlsdGVyIG11c3QgYmUgcmFuayA0LCBidXQgZ290IFwiICtcbiAgICAgICAgICAgIChcInJhbmsgXCIgKyBmaWx0ZXIucmFuaykpO1xuICAgICAgICB1dGlsLmFzc2VydChpbkRlcHRoID09PSBmaWx0ZXIuc2hhcGVbMl0sIFwiRXJyb3IgaW4gY29udjJkRGVySW5wdXQ6IGRlcHRoIG9mIGlucHV0IChcIiArIGluRGVwdGggKyBcIikgbXVzdCBcIiArXG4gICAgICAgICAgICAoXCJtYXRjaCBpbnB1dCBkZXB0aCBmb3IgZmlsdGVyIFwiICsgZmlsdGVyLnNoYXBlWzJdICsgXCIuXCIpKTtcbiAgICAgICAgdXRpbC5hc3NlcnQob3V0RGVwdGggPT09IGZpbHRlci5zaGFwZVszXSwgXCJFcnJvciBpbiBjb252MmREZXJJbnB1dDogZGVwdGggb2Ygb3V0cHV0IChcIiArIG91dERlcHRoICsgXCIpIG11c3RcIiArXG4gICAgICAgICAgICAoXCJtYXRjaCBvdXRwdXQgZGVwdGggZm9yIGZpbHRlciBcIiArIGZpbHRlci5zaGFwZVszXSArIFwiLlwiKSk7XG4gICAgICAgIHZhciBmaWx0ZXJIZWlnaHQgPSBmaWx0ZXIuc2hhcGVbMF07XG4gICAgICAgIHZhciBmaWx0ZXJXaWR0aCA9IGZpbHRlci5zaGFwZVsxXTtcbiAgICAgICAgdmFyIF9hID0gcGFyc2VUdXBsZVBhcmFtKHN0cmlkZXMpLCBzdHJpZGVIZWlnaHQgPSBfYVswXSwgc3RyaWRlV2lkdGggPSBfYVsxXTtcbiAgICAgICAgdmFyIGNvbnZJbmZvID0gY29udl91dGlsLmNvbXB1dGVDb252MkRJbmZvKGluU2hhcGUsIGZpbHRlckhlaWdodCwgZmlsdGVyV2lkdGgsIG91dERlcHRoLCBzdHJpZGVIZWlnaHQsIHN0cmlkZVdpZHRoLCBwYWQpO1xuICAgICAgICByZXR1cm4gdGhpcy5leGVjdXRlT3AoJ2NvbnYyZERlcklucHV0JywgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuY29udjJkRGVySW5wdXRJbnRlcm5hbChkeSwgZmlsdGVyLCBjb252SW5mbyk7IH0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGgucHJvdG90eXBlLmNvbnYyZERlckJpYXMgPSBmdW5jdGlvbiAoZHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhY2sodGhpcy5jb252MmREZXJCaWFzSW50ZXJuYWwoZHkpKTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS5jb252MmREZXJGaWx0ZXIgPSBmdW5jdGlvbiAoeCwgZHksIGZpbHRlclNpemUsIHN0cmlkZXMsIHBhZCkge1xuICAgICAgICB1dGlsLmFzc2VydCh4LnJhbmsgPT09IDMsIFwiRXJyb3IgaW4gY29udjJkRGVyRmlsdGVyOiB4IG11c3QgYmUgcmFuayAzLCBidXQgZ290IHNoYXBlIFwiICtcbiAgICAgICAgICAgICh4LnNoYXBlICsgXCIuXCIpKTtcbiAgICAgICAgdXRpbC5hc3NlcnQoZHkucmFuayA9PT0gMywgXCJFcnJvciBpbiBjb252MmREZXJGaWx0ZXI6IGR5IG11c3QgYmUgcmFuayAzLCBidXQgZ290IHNoYXBlIFwiICtcbiAgICAgICAgICAgIChkeS5zaGFwZSArIFwiLlwiKSk7XG4gICAgICAgIHV0aWwuYXNzZXJ0KGZpbHRlclNpemUubGVuZ3RoID09PSA0LCBcIkVycm9yIGluIGNvbnYyZERlckZpbHRlcjogZmlsdGVyU2l6ZSBtdXN0IGJlIGxlbmd0aCA0LCBidXQgZ290IFwiICtcbiAgICAgICAgICAgIChmaWx0ZXJTaXplICsgXCIuXCIpKTtcbiAgICAgICAgdXRpbC5hc3NlcnQoeC5zaGFwZVsyXSA9PT0gZmlsdGVyU2l6ZVsyXSwgXCJFcnJvciBpbiBjb252MmREZXJGaWx0ZXI6IGRlcHRoIG9mIHggXCIgKyB4LnNoYXBlWzJdICsgXCIpIG11c3QgXCIgK1xuICAgICAgICAgICAgKFwibWF0Y2ggaW5wdXQgZGVwdGggaW4gZmlsdGVyIChcIiArIGZpbHRlclNpemVbMl0gKyBcIi5cIikpO1xuICAgICAgICB1dGlsLmFzc2VydChkeS5zaGFwZVsyXSA9PT0gZmlsdGVyU2l6ZVszXSwgXCJFcnJvciBpbiBjb252MmREZXJGaWx0ZXI6IGRlcHRoIG9mIGR5IChcIiArIGR5LnNoYXBlWzJdICsgXCIpIG11c3QgXCIgK1xuICAgICAgICAgICAgKFwibWF0Y2ggb3V0cHV0IGRlcHRoIGZvciBmaWx0ZXIgKFwiICsgZmlsdGVyU2l6ZVszXSArIFwiKS5cIikpO1xuICAgICAgICB2YXIgZmlsdGVySGVpZ2h0ID0gZmlsdGVyU2l6ZVswXTtcbiAgICAgICAgdmFyIGZpbHRlcldpZHRoID0gZmlsdGVyU2l6ZVsxXTtcbiAgICAgICAgdmFyIG91dERlcHRoID0gZmlsdGVyU2l6ZVszXTtcbiAgICAgICAgdmFyIF9hID0gcGFyc2VUdXBsZVBhcmFtKHN0cmlkZXMpLCBzdHJpZGVIZWlnaHQgPSBfYVswXSwgc3RyaWRlV2lkdGggPSBfYVsxXTtcbiAgICAgICAgdmFyIGNvbnZJbmZvID0gY29udl91dGlsLmNvbXB1dGVDb252MkRJbmZvKHguc2hhcGUsIGZpbHRlckhlaWdodCwgZmlsdGVyV2lkdGgsIG91dERlcHRoLCBzdHJpZGVIZWlnaHQsIHN0cmlkZVdpZHRoLCBwYWQpO1xuICAgICAgICByZXR1cm4gdGhpcy50cmFjayh0aGlzLmNvbnYyZERlckZpbHRlckludGVybmFsKHgsIGR5LCBjb252SW5mbykpO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGgucHJvdG90eXBlLmNvbnYyZFRyYW5zcG9zZSA9IGZ1bmN0aW9uICh4LCBmaWx0ZXIsIG91dHB1dFNoYXBlLCBzdHJpZGVzLCBwYWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udjJkRGVySW5wdXQob3V0cHV0U2hhcGUsIHgsIGZpbHRlciwgc3RyaWRlcywgcGFkKTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS5kZXB0aHdpc2VDb252MkQgPSBmdW5jdGlvbiAoaW5wdXQsIGZpbHRlciwgc3RyaWRlcywgcGFkLCByYXRlcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAocmF0ZXMgPT09IHZvaWQgMCkgeyByYXRlcyA9IFsxLCAxXTsgfVxuICAgICAgICB2YXIgaW5wdXQ0RCA9IGlucHV0O1xuICAgICAgICB2YXIgcmVzaGFwZWRUbzREID0gZmFsc2U7XG4gICAgICAgIGlmIChpbnB1dC5yYW5rID09PSAzKSB7XG4gICAgICAgICAgICByZXNoYXBlZFRvNEQgPSB0cnVlO1xuICAgICAgICAgICAgaW5wdXQ0RCA9IGlucHV0LmFzNEQoMSwgaW5wdXQuc2hhcGVbMF0sIGlucHV0LnNoYXBlWzFdLCBpbnB1dC5zaGFwZVsyXSk7XG4gICAgICAgIH1cbiAgICAgICAgdXRpbC5hc3NlcnQoaW5wdXQ0RC5yYW5rID09PSA0LCBcIkVycm9yIGluIGRlcHRod2lzZUNvbnYyRDogaW5wdXQgbXVzdCBiZSByYW5rIDQsIGJ1dCBnb3QgXCIgK1xuICAgICAgICAgICAgKFwicmFuayBcIiArIGlucHV0NEQucmFuayArIFwiLlwiKSk7XG4gICAgICAgIHV0aWwuYXNzZXJ0KGZpbHRlci5yYW5rID09PSA0LCBcIkVycm9yIGluIGRlcHRod2lzZUNvbnYyRDogZmlsdGVyIG11c3QgYmUgcmFuayA0LCBidXQgZ290IHJhbmsgXCIgK1xuICAgICAgICAgICAgKGZpbHRlci5yYW5rICsgXCIuXCIpKTtcbiAgICAgICAgdXRpbC5hc3NlcnQoaW5wdXQ0RC5zaGFwZVszXSA9PT0gZmlsdGVyLnNoYXBlWzJdLCBcIkVycm9yIGluIGRlcHRod2lzZUNvbnYyRDogbnVtYmVyIG9mIGlucHV0IGNoYW5uZWxzIFwiICtcbiAgICAgICAgICAgIChcIihcIiArIGlucHV0NEQuc2hhcGVbM10gKyBcIikgbXVzdCBtYXRjaCB0aGUgaW5DaGFubmVscyBkaW1lbnNpb24gaW4gXCIpICtcbiAgICAgICAgICAgIChcImZpbHRlciBcIiArIGZpbHRlci5zaGFwZVsyXSArIFwiLlwiKSk7XG4gICAgICAgIHJhdGVzID0gcmF0ZXMgfHwgWzEsIDFdO1xuICAgICAgICB2YXIgX2EgPSBwYXJzZVR1cGxlUGFyYW0ocmF0ZXMpLCByYXRlSGVpZ2h0ID0gX2FbMF0sIHJhdGVXaWR0aCA9IF9hWzFdO1xuICAgICAgICB1dGlsLmFzc2VydChyYXRlSGVpZ2h0ID09PSAxICYmIHJhdGVXaWR0aCA9PT0gMSwgJ0Vycm9yIGluIGRlcHRod2lzZUNvbnYyRDogcmF0ZXMgZ3JlYXRlciB0aGFuIDEgYXJlIG5vdCB5ZXQgJyArXG4gICAgICAgICAgICAoXCJzdXBwb3J0ZWQuIEdvdCByYXRlcyAnXCIgKyByYXRlcyArIFwiJ1wiKSk7XG4gICAgICAgIHZhciBjb252SW5mbyA9IGNvbnZfdXRpbC5jb21wdXRlRGVwdGh3aXNlQ29udjJESW5mbyhpbnB1dDRELnNoYXBlLCBmaWx0ZXIuc2hhcGUsIHN0cmlkZXMsIHBhZCk7XG4gICAgICAgIHJldHVybiB0aGlzLmV4ZWN1dGVPcCgnZGVwdGh3aXNlQ29udjJEJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHJlcyA9IF90aGlzLmRlcHRod2lzZUNvbnYyREludGVybmFsKGlucHV0NEQsIGZpbHRlciwgY29udkluZm8pO1xuICAgICAgICAgICAgaWYgKHJlc2hhcGVkVG80RCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXMuYXMzRChyZXMuc2hhcGVbMV0sIHJlcy5zaGFwZVsyXSwgcmVzLnNoYXBlWzNdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGgucHJvdG90eXBlLm1heFBvb2wgPSBmdW5jdGlvbiAoeCwgZmlsdGVyU2l6ZSwgc3RyaWRlcywgcGFkKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHV0aWwuYXNzZXJ0KHgucmFuayA9PT0gMywgXCJFcnJvciBpbiBtYXhQb29sOiB4IG11c3QgYmUgcmFuayAzIGJ1dCBnb3QgcmFuayBcIiArIHgucmFuayArIFwiLlwiKTtcbiAgICAgICAgdmFyIF9hID0gcGFyc2VUdXBsZVBhcmFtKGZpbHRlclNpemUpLCBmaWx0ZXJIZWlnaHQgPSBfYVswXSwgZmlsdGVyV2lkdGggPSBfYVsxXTtcbiAgICAgICAgdmFyIG91dERlcHRoID0geC5zaGFwZVsyXTtcbiAgICAgICAgdmFyIF9iID0gcGFyc2VUdXBsZVBhcmFtKHN0cmlkZXMpLCBzdHJpZGVIZWlnaHQgPSBfYlswXSwgc3RyaWRlV2lkdGggPSBfYlsxXTtcbiAgICAgICAgdmFyIGNvbnZJbmZvID0gY29udl91dGlsLmNvbXB1dGVDb252MkRJbmZvKHguc2hhcGUsIGZpbHRlckhlaWdodCwgZmlsdGVyV2lkdGgsIG91dERlcHRoLCBzdHJpZGVIZWlnaHQsIHN0cmlkZVdpZHRoLCBwYWQpO1xuICAgICAgICByZXR1cm4gdGhpcy5leGVjdXRlT3AoJ21heFBvb2wnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5tYXhQb29sSW50ZXJuYWwoeCwgY29udkluZm8pOyB9KTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS5tYXhQb29sQmFja3Byb3AgPSBmdW5jdGlvbiAoZHksIHgsIGZpbHRlclNpemUsIHN0cmlkZXMsIHBhZCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB1dGlsLmFzc2VydChkeS5yYW5rID09PSAzLCBcIkVycm9yIGluIG1heFBvb2xCYWNrcHJvcDogZHkgbXVzdCBiZSByYW5rIDMgYnV0IGdvdCByYW5rIFwiICtcbiAgICAgICAgICAgIChkeS5yYW5rICsgXCIuXCIpKTtcbiAgICAgICAgdXRpbC5hc3NlcnQoeC5yYW5rID09PSAzLCBcIkVycm9yIGluIG1heFBvb2xCYWNrcHJvcDogeCBtdXN0IGJlIHJhbmsgMyBidXQgZ290IHJhbmsgXCIgK1xuICAgICAgICAgICAgKHgucmFuayArIFwiLlwiKSk7XG4gICAgICAgIHZhciBfYSA9IHBhcnNlVHVwbGVQYXJhbShmaWx0ZXJTaXplKSwgZmlsdGVySGVpZ2h0ID0gX2FbMF0sIGZpbHRlcldpZHRoID0gX2FbMV07XG4gICAgICAgIHZhciBvdXREZXB0aCA9IHguc2hhcGVbMl07XG4gICAgICAgIHZhciBfYiA9IHBhcnNlVHVwbGVQYXJhbShzdHJpZGVzKSwgc3RyaWRlSGVpZ2h0ID0gX2JbMF0sIHN0cmlkZVdpZHRoID0gX2JbMV07XG4gICAgICAgIHZhciBjb252SW5mbyA9IGNvbnZfdXRpbC5jb21wdXRlQ29udjJESW5mbyh4LnNoYXBlLCBmaWx0ZXJIZWlnaHQsIGZpbHRlcldpZHRoLCBvdXREZXB0aCwgc3RyaWRlSGVpZ2h0LCBzdHJpZGVXaWR0aCwgcGFkKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhlY3V0ZU9wKCdtYXhQb29sQmFja3Byb3AnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5tYXhQb29sQmFja3Byb3BJbnRlcm5hbChkeSwgeCwgY29udkluZm8pOyB9KTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS5taW5Qb29sID0gZnVuY3Rpb24gKHgsIGZpbHRlclNpemUsIHN0cmlkZXMsIHBhZCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB1dGlsLmFzc2VydCh4LnJhbmsgPT09IDMsIFwiRXJyb3IgaW4gbWluUG9vbDogeCBtdXN0IGJlIHJhbmsgMyBidXQgZ290IHJhbmsgXCIgKyB4LnJhbmsgKyBcIi5cIik7XG4gICAgICAgIHZhciBfYSA9IHBhcnNlVHVwbGVQYXJhbShmaWx0ZXJTaXplKSwgZmlsdGVySGVpZ2h0ID0gX2FbMF0sIGZpbHRlcldpZHRoID0gX2FbMV07XG4gICAgICAgIHZhciBvdXREZXB0aCA9IHguc2hhcGVbMl07XG4gICAgICAgIHZhciBfYiA9IHBhcnNlVHVwbGVQYXJhbShzdHJpZGVzKSwgc3RyaWRlSGVpZ2h0ID0gX2JbMF0sIHN0cmlkZVdpZHRoID0gX2JbMV07XG4gICAgICAgIHZhciBjb252SW5mbyA9IGNvbnZfdXRpbC5jb21wdXRlQ29udjJESW5mbyh4LnNoYXBlLCBmaWx0ZXJIZWlnaHQsIGZpbHRlcldpZHRoLCBvdXREZXB0aCwgc3RyaWRlSGVpZ2h0LCBzdHJpZGVXaWR0aCwgcGFkKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhlY3V0ZU9wKCdtaW5Qb29sJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMubWluUG9vbEludGVybmFsKHgsIGNvbnZJbmZvKTsgfSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUuYXZnUG9vbCA9IGZ1bmN0aW9uICh4LCBmaWx0ZXJTaXplLCBzdHJpZGVzLCBwYWQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdXRpbC5hc3NlcnQoeC5yYW5rID09PSAzLCBcIkVycm9yIGluIGF2Z1Bvb2w6IHggbXVzdCBiZSByYW5rIDMgYnV0IGdvdCByYW5rIFwiICsgeC5yYW5rICsgXCIuXCIpO1xuICAgICAgICB2YXIgX2EgPSBwYXJzZVR1cGxlUGFyYW0oZmlsdGVyU2l6ZSksIGZpbHRlckhlaWdodCA9IF9hWzBdLCBmaWx0ZXJXaWR0aCA9IF9hWzFdO1xuICAgICAgICB2YXIgb3V0RGVwdGggPSB4LnNoYXBlWzJdO1xuICAgICAgICB2YXIgX2IgPSBwYXJzZVR1cGxlUGFyYW0oc3RyaWRlcyksIHN0cmlkZUhlaWdodCA9IF9iWzBdLCBzdHJpZGVXaWR0aCA9IF9iWzFdO1xuICAgICAgICB2YXIgY29udkluZm8gPSBjb252X3V0aWwuY29tcHV0ZUNvbnYyREluZm8oeC5zaGFwZSwgZmlsdGVySGVpZ2h0LCBmaWx0ZXJXaWR0aCwgb3V0RGVwdGgsIHN0cmlkZUhlaWdodCwgc3RyaWRlV2lkdGgsIHBhZCk7XG4gICAgICAgIHJldHVybiB0aGlzLmV4ZWN1dGVPcCgnYXZnUG9vbCcsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmF2Z1Bvb2xJbnRlcm5hbCh4LCBjb252SW5mbyk7IH0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGgucHJvdG90eXBlLnJlc2l6ZUJpbGluZWFyM0QgPSBmdW5jdGlvbiAoeCwgbmV3U2hhcGUyRCwgYWxpZ25Db3JuZXJzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChhbGlnbkNvcm5lcnMgPT09IHZvaWQgMCkgeyBhbGlnbkNvcm5lcnMgPSBmYWxzZTsgfVxuICAgICAgICB1dGlsLmFzc2VydCh4LnJhbmsgPT09IDMsIFwiRXJyb3IgaW4gcmVzaXplQmlsaW5lYXIzRDogeCBtdXN0IGJlIHJhbmsgMyBidXQgZ290IHJhbmsgXCIgKyB4LnJhbmsgKyBcIi5cIik7XG4gICAgICAgIHV0aWwuYXNzZXJ0KG5ld1NoYXBlMkQubGVuZ3RoID09PSAyLCBcIkVycm9yIGluIHJlc2l6ZUJpbGluZWFyM0Q6IG5ldyBzaGFwZSBtdXN0IDJELCBidXQgZ290IHNoYXBlIFwiICtcbiAgICAgICAgICAgIChuZXdTaGFwZTJEICsgXCIuXCIpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhlY3V0ZU9wKCdyZXNpemVCaWxpbmVhcjNEJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMucmVzaXplQmlsaW5lYXIzREludGVybmFsKHgsIG5ld1NoYXBlMkQsIGFsaWduQ29ybmVycyk7IH0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGgucHJvdG90eXBlLmJhdGNoTm9ybWFsaXphdGlvbjJEID0gZnVuY3Rpb24gKHgsIG1lYW4sIHZhcmlhbmNlLCB2YXJpYW5jZUVwc2lsb24sIHNjYWxlLCBvZmZzZXQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHZhcmlhbmNlRXBzaWxvbiA9PT0gdm9pZCAwKSB7IHZhcmlhbmNlRXBzaWxvbiA9IC4wMDE7IH1cbiAgICAgICAgdXRpbC5hc3NlcnQoeC5yYW5rID09PSAyLCBcIkVycm9yIGluIGJhdGNoTm9ybWFsaXphdGlvbjNEOiB4IG11c3QgYmUgcmFuayAzIGJ1dCBnb3QgcmFuayBcIiArXG4gICAgICAgICAgICAoeC5yYW5rICsgXCIuXCIpKTtcbiAgICAgICAgdXRpbC5hc3NlcnQobWVhbi5yYW5rID09PSAyIHx8IG1lYW4ucmFuayA9PT0gMSwgXCJFcnJvciBpbiBiYXRjaE5vcm1hbGl6YXRpb24yRDogbWVhbiBtdXN0IGJlIHJhbmsgMiBvciByYW5rIDEgYnV0IFwiICtcbiAgICAgICAgICAgIChcImdvdCByYW5rIFwiICsgbWVhbi5yYW5rICsgXCIuXCIpKTtcbiAgICAgICAgdXRpbC5hc3NlcnQodmFyaWFuY2UucmFuayA9PT0gMiB8fCB2YXJpYW5jZS5yYW5rID09PSAxLCBcIkVycm9yIGluIGJhdGNoTm9ybWFsaXphdGlvbjJEOiB2YXJpYW5jZSBtdXN0IGJlIHJhbmsgMiBvciByYW5rIDEgXCIgK1xuICAgICAgICAgICAgKFwiYnV0IGdvdCByYW5rIFwiICsgdmFyaWFuY2UucmFuayArIFwiLlwiKSk7XG4gICAgICAgIGlmIChzY2FsZSAhPSBudWxsKSB7XG4gICAgICAgICAgICB1dGlsLmFzc2VydChzY2FsZS5yYW5rID09PSAyIHx8IHNjYWxlLnJhbmsgPT09IDEsIFwiRXJyb3IgaW4gYmF0Y2hOb3JtYWxpemF0aW9uMkQ6IHNjYWxlIG11c3QgYmUgcmFuayAyIG9yIHJhbmsgMSBcIiArXG4gICAgICAgICAgICAgICAgKFwiYnV0IGdvdCByYW5rIFwiICsgc2NhbGUucmFuayArIFwiLlwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9mZnNldCAhPSBudWxsKSB7XG4gICAgICAgICAgICB1dGlsLmFzc2VydChvZmZzZXQucmFuayA9PT0gMiB8fCBvZmZzZXQucmFuayA9PT0gMSwgXCJFcnJvciBpbiBiYXRjaE5vcm1hbGl6YXRpb24yRDogb2Zmc2V0IG11c3QgYmUgcmFuayAyIG9yIHJhbmsgMSBcIiArXG4gICAgICAgICAgICAgICAgKFwiYnV0IGdvdCByYW5rIFwiICsgb2Zmc2V0LnJhbmsgKyBcIi5cIikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmV4ZWN1dGVPcCgnYmF0Y2hOb3JtMkQnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5iYXRjaE5vcm1hbGl6YXRpb24yREludGVybmFsKHgsIG1lYW4sIHZhcmlhbmNlLCB2YXJpYW5jZUVwc2lsb24sIHNjYWxlLCBvZmZzZXQpOyB9KTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS5iYXRjaE5vcm1hbGl6YXRpb24zRCA9IGZ1bmN0aW9uICh4LCBtZWFuLCB2YXJpYW5jZSwgdmFyaWFuY2VFcHNpbG9uLCBzY2FsZSwgb2Zmc2V0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh2YXJpYW5jZUVwc2lsb24gPT09IHZvaWQgMCkgeyB2YXJpYW5jZUVwc2lsb24gPSAuMDAxOyB9XG4gICAgICAgIHV0aWwuYXNzZXJ0KHgucmFuayA9PT0gMywgXCJFcnJvciBpbiBiYXRjaE5vcm1hbGl6YXRpb24zRDogeCBtdXN0IGJlIHJhbmsgMyBidXQgZ290IHJhbmsgXCIgK1xuICAgICAgICAgICAgKHgucmFuayArIFwiLlwiKSk7XG4gICAgICAgIHV0aWwuYXNzZXJ0KG1lYW4ucmFuayA9PT0gMyB8fCBtZWFuLnJhbmsgPT09IDEsIFwiRXJyb3IgaW4gYmF0Y2hOb3JtYWxpemF0aW9uM0Q6IG1lYW4gbXVzdCBiZSByYW5rIDMgb3IgcmFuayAxIGJ1dCBcIiArXG4gICAgICAgICAgICAoXCJnb3QgcmFuayBcIiArIG1lYW4ucmFuayArIFwiLlwiKSk7XG4gICAgICAgIHV0aWwuYXNzZXJ0KHZhcmlhbmNlLnJhbmsgPT09IDMgfHwgdmFyaWFuY2UucmFuayA9PT0gMSwgXCJFcnJvciBpbiBiYXRjaE5vcm1hbGl6YXRpb24zRDogdmFyaWFuY2UgbXVzdCBiZSByYW5rIDMgb3IgcmFuayAxIFwiICtcbiAgICAgICAgICAgIChcImJ1dCBnb3QgcmFuayBcIiArIHZhcmlhbmNlLnJhbmsgKyBcIi5cIikpO1xuICAgICAgICBpZiAoc2NhbGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgdXRpbC5hc3NlcnQoc2NhbGUucmFuayA9PT0gMyB8fCBzY2FsZS5yYW5rID09PSAxLCBcIkVycm9yIGluIGJhdGNoTm9ybWFsaXphdGlvbjNEOiBzY2FsZSBtdXN0IGJlIHJhbmsgMyBvciByYW5rIDEgXCIgK1xuICAgICAgICAgICAgICAgIChcImJ1dCBnb3QgcmFuayBcIiArIHNjYWxlLnJhbmsgKyBcIi5cIikpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvZmZzZXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgdXRpbC5hc3NlcnQob2Zmc2V0LnJhbmsgPT09IDMgfHwgb2Zmc2V0LnJhbmsgPT09IDEsIFwiRXJyb3IgaW4gYmF0Y2hOb3JtYWxpemF0aW9uM0Q6IG9mZnNldCBtdXN0IGJlIHJhbmsgMyBvciByYW5rIDEgXCIgK1xuICAgICAgICAgICAgICAgIChcImJ1dCBnb3QgcmFuayBcIiArIG9mZnNldC5yYW5rICsgXCIuXCIpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5leGVjdXRlT3AoJ2JhdGNoTm9ybTNEJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuYmF0Y2hOb3JtYWxpemF0aW9uM0RJbnRlcm5hbCh4LCBtZWFuLCB2YXJpYW5jZSwgdmFyaWFuY2VFcHNpbG9uLCBzY2FsZSwgb2Zmc2V0KTsgfSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUubXVsdGlSTk5DZWxsID0gZnVuY3Rpb24gKGxzdG1DZWxscywgZGF0YSwgYywgaCkge1xuICAgICAgICB2YXIgcmVzID0gdGhpcy5zY29wZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgaW5wdXQgPSBkYXRhO1xuICAgICAgICAgICAgdmFyIG5ld1N0YXRlcyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsc3RtQ2VsbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgb3V0cHV0ID0gbHN0bUNlbGxzW2ldKGlucHV0LCBjW2ldLCBoW2ldKTtcbiAgICAgICAgICAgICAgICBuZXdTdGF0ZXMucHVzaChvdXRwdXRbMF0pO1xuICAgICAgICAgICAgICAgIG5ld1N0YXRlcy5wdXNoKG91dHB1dFsxXSk7XG4gICAgICAgICAgICAgICAgaW5wdXQgPSBvdXRwdXRbMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3U3RhdGVzO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIG5ld0MgPSBbXTtcbiAgICAgICAgdmFyIG5ld0ggPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICAgIG5ld0MucHVzaChyZXNbaV0pO1xuICAgICAgICAgICAgbmV3SC5wdXNoKHJlc1tpICsgMV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbbmV3QywgbmV3SF07XG4gICAgfTtcbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUuYmFzaWNMU1RNQ2VsbCA9IGZ1bmN0aW9uIChmb3JnZXRCaWFzLCBsc3RtS2VybmVsLCBsc3RtQmlhcywgZGF0YSwgYywgaCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgcmVzID0gdGhpcy5zY29wZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgY29tYmluZWQgPSBfdGhpcy5jb25jYXQyRChkYXRhLCBoLCAxKTtcbiAgICAgICAgICAgIHZhciB3ZWlnaHRlZCA9IF90aGlzLm1hdE11bChjb21iaW5lZCwgbHN0bUtlcm5lbCk7XG4gICAgICAgICAgICB2YXIgcmVzID0gX3RoaXMuYWRkKHdlaWdodGVkLCBsc3RtQmlhcyk7XG4gICAgICAgICAgICB2YXIgYmF0Y2hTaXplID0gcmVzLnNoYXBlWzBdO1xuICAgICAgICAgICAgdmFyIHNsaWNlQ29scyA9IHJlcy5zaGFwZVsxXSAvIDQ7XG4gICAgICAgICAgICB2YXIgc2xpY2VTaXplID0gW2JhdGNoU2l6ZSwgc2xpY2VDb2xzXTtcbiAgICAgICAgICAgIHZhciBpID0gX3RoaXMuc2xpY2UyRChyZXMsIFswLCAwXSwgc2xpY2VTaXplKTtcbiAgICAgICAgICAgIHZhciBqID0gX3RoaXMuc2xpY2UyRChyZXMsIFswLCBzbGljZUNvbHNdLCBzbGljZVNpemUpO1xuICAgICAgICAgICAgdmFyIGYgPSBfdGhpcy5zbGljZTJEKHJlcywgWzAsIHNsaWNlQ29scyAqIDJdLCBzbGljZVNpemUpO1xuICAgICAgICAgICAgdmFyIG8gPSBfdGhpcy5zbGljZTJEKHJlcywgWzAsIHNsaWNlQ29scyAqIDNdLCBzbGljZVNpemUpO1xuICAgICAgICAgICAgdmFyIG5ld0MgPSBfdGhpcy5hZGRTdHJpY3QoX3RoaXMubXVsdGlwbHlTdHJpY3QoYywgX3RoaXMuc2lnbW9pZChfdGhpcy5zY2FsYXJQbHVzQXJyYXkoZm9yZ2V0QmlhcywgZikpKSwgX3RoaXMubXVsdGlwbHlTdHJpY3QoX3RoaXMuc2lnbW9pZChpKSwgX3RoaXMudGFuaChqKSkpO1xuICAgICAgICAgICAgdmFyIG5ld0ggPSBfdGhpcy5tdWx0aXBseVN0cmljdChfdGhpcy50YW5oKG5ld0MpLCBfdGhpcy5zaWdtb2lkKG8pKTtcbiAgICAgICAgICAgIHJldHVybiBbbmV3QywgbmV3SF07XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gW3Jlc1swXSwgcmVzWzFdXTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS5tdWx0aW5vbWlhbCA9IGZ1bmN0aW9uIChwcm9iYWJpbGl0aWVzLCBudW1TYW1wbGVzLCBzZWVkKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBudW1PdXRjb21lcyA9IHByb2JhYmlsaXRpZXMuc2l6ZTtcbiAgICAgICAgaWYgKG51bU91dGNvbWVzIDwgMikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXJyb3IgaW4gbXVsdGlub21pYWw6IHlvdSBuZWVkIGF0IGxlYXN0IDIgb3V0Y29tZXMsIGJ1dCBnb3QgXCIgK1xuICAgICAgICAgICAgICAgIChudW1PdXRjb21lcyArIFwiLlwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb2JhYmlsaXRpZXMucmFuayA+IDIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlJhbmsgb2YgcHJvYmFiaWxpdGllcyBtdXN0IGJlIDEgb3IgMiwgYnV0IGlzIFwiICsgcHJvYmFiaWxpdGllcy5yYW5rKTtcbiAgICAgICAgfVxuICAgICAgICBzZWVkID0gc2VlZCB8fCBNYXRoLnJhbmRvbSgpO1xuICAgICAgICB2YXIgb3JpZ1JhbmsgPSBwcm9iYWJpbGl0aWVzLnJhbms7XG4gICAgICAgIGlmIChwcm9iYWJpbGl0aWVzLnJhbmsgPT09IDEpIHtcbiAgICAgICAgICAgIHByb2JhYmlsaXRpZXMgPSBwcm9iYWJpbGl0aWVzLmFzMkQoMSwgLTEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmV4ZWN1dGVPcCgnbXVsdGlub21pYWwnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcmVzID0gX3RoaXMubXVsdGlub21pYWxJbnRlcm5hbChwcm9iYWJpbGl0aWVzLCBudW1TYW1wbGVzLCBzZWVkKTtcbiAgICAgICAgICAgIGlmIChvcmlnUmFuayA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXMuYXMxRCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUub25lSG90ID0gZnVuY3Rpb24gKGluZGljZXMsIGRlcHRoLCBvblZhbHVlLCBvZmZWYWx1ZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAob25WYWx1ZSA9PT0gdm9pZCAwKSB7IG9uVmFsdWUgPSAxOyB9XG4gICAgICAgIGlmIChvZmZWYWx1ZSA9PT0gdm9pZCAwKSB7IG9mZlZhbHVlID0gMDsgfVxuICAgICAgICBpZiAoZGVwdGggPCAyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFcnJvciBpbiBvbmVIb3Q6IGRlcHRoIG11c3QgYmUgPj0yLCBidXQgaXQgaXMgXCIgKyBkZXB0aCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZXhlY3V0ZU9wKCdvbmVIb3QnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5vbmVIb3RJbnRlcm5hbChpbmRpY2VzLCBkZXB0aCwgb25WYWx1ZSwgb2ZmVmFsdWUpOyB9KTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS5tb21lbnRzID0gZnVuY3Rpb24gKHgsIGF4aXMsIGtlZXBEaW1zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChheGlzID09PSB2b2lkIDApIHsgYXhpcyA9IG51bGw7IH1cbiAgICAgICAgaWYgKGtlZXBEaW1zID09PSB2b2lkIDApIHsga2VlcERpbXMgPSBmYWxzZTsgfVxuICAgICAgICB2YXIgYXhlcyA9IGF4aXNfdXRpbC5wYXJzZUF4aXNQYXJhbShheGlzLCB4LnNoYXBlKTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuc2NvcGUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG1lYW4gPSBfdGhpcy5tZWFuKHgsIGF4ZXMsIGtlZXBEaW1zKTtcbiAgICAgICAgICAgIHZhciBrZWVwRGltc1NoYXBlID0gbWVhbi5zaGFwZTtcbiAgICAgICAgICAgIGlmICgha2VlcERpbXMpIHtcbiAgICAgICAgICAgICAgICBrZWVwRGltc1NoYXBlID0gYXhpc191dGlsLmV4cGFuZFNoYXBlVG9LZWVwRGltKG1lYW4uc2hhcGUsIGF4ZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGRldlNxdWFyZWQgPSBfdGhpcy5zcXVhcmUoX3RoaXMuc3VidHJhY3QoeCwgbWVhbi5yZXNoYXBlKGtlZXBEaW1zU2hhcGUpKSk7XG4gICAgICAgICAgICB2YXIgdmFyaWFuY2UgPSBfdGhpcy5tZWFuKGRldlNxdWFyZWQsIGF4ZXMsIGtlZXBEaW1zKTtcbiAgICAgICAgICAgIHJldHVybiB7IG1lYW46IG1lYW4sIHZhcmlhbmNlOiB2YXJpYW5jZSB9O1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIHJldHVybiBOREFycmF5TWF0aDtcbn0oKSk7XG5leHBvcnRzLk5EQXJyYXlNYXRoID0gTkRBcnJheU1hdGg7XG52YXIgTWF0cml4T3JpZW50YXRpb247XG4oZnVuY3Rpb24gKE1hdHJpeE9yaWVudGF0aW9uKSB7XG4gICAgTWF0cml4T3JpZW50YXRpb25bTWF0cml4T3JpZW50YXRpb25bXCJSRUdVTEFSXCJdID0gMF0gPSBcIlJFR1VMQVJcIjtcbiAgICBNYXRyaXhPcmllbnRhdGlvbltNYXRyaXhPcmllbnRhdGlvbltcIlRSQU5TUE9TRURcIl0gPSAxXSA9IFwiVFJBTlNQT1NFRFwiO1xufSkoTWF0cml4T3JpZW50YXRpb24gPSBleHBvcnRzLk1hdHJpeE9yaWVudGF0aW9uIHx8IChleHBvcnRzLk1hdHJpeE9yaWVudGF0aW9uID0ge30pKTtcbmZ1bmN0aW9uIHBhcnNlVHVwbGVQYXJhbShwYXJhbSkge1xuICAgIHJldHVybiB0eXBlb2YgcGFyYW0gPT09ICdudW1iZXInID8gW3BhcmFtLCBwYXJhbV0gOiBwYXJhbTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1hdGguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBzZWVkcmFuZG9tID0gcmVxdWlyZShcInNlZWRyYW5kb21cIik7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xudmFyIGF4aXNfdXRpbCA9IHJlcXVpcmUoXCIuL2F4aXNfdXRpbFwiKTtcbnZhciBicm9hZGNhc3RfdXRpbCA9IHJlcXVpcmUoXCIuL2Jyb2FkY2FzdF91dGlsXCIpO1xudmFyIGNvbmNhdF91dGlsID0gcmVxdWlyZShcIi4vY29uY2F0X3V0aWxcIik7XG52YXIgY29udl91dGlsID0gcmVxdWlyZShcIi4vY29udl91dGlsXCIpO1xudmFyIGNvcHkyRF91dGlsID0gcmVxdWlyZShcIi4vY29weTJkX3V0aWxcIik7XG52YXIgbWF0aF8xID0gcmVxdWlyZShcIi4vbWF0aFwiKTtcbnZhciBuZGFycmF5XzEgPSByZXF1aXJlKFwiLi9uZGFycmF5XCIpO1xudmFyIE5EQXJyYXlNYXRoQ1BVID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTkRBcnJheU1hdGhDUFUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTkRBcnJheU1hdGhDUFUoc2FmZU1vZGUpIHtcbiAgICAgICAgaWYgKHNhZmVNb2RlID09PSB2b2lkIDApIHsgc2FmZU1vZGUgPSBmYWxzZTsgfVxuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgc2FmZU1vZGUpIHx8IHRoaXM7XG4gICAgfVxuICAgIE5EQXJyYXlNYXRoQ1BVLnByb3RvdHlwZS5jbG9uZUludGVybmFsID0gZnVuY3Rpb24gKG5kYXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIG5kYXJyYXlfMS5OREFycmF5Lm1ha2UobmRhcnJheS5zaGFwZSwgeyB2YWx1ZXM6IG5ldyBGbG9hdDMyQXJyYXkobmRhcnJheS5nZXRWYWx1ZXMoKSkgfSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aENQVS5wcm90b3R5cGUuc2xpY2UxREludGVybmFsID0gZnVuY3Rpb24gKGlucHV0LCBiZWdpbiwgc2l6ZSkge1xuICAgICAgICB2YXIgbmV3VmFscyA9IGlucHV0LmdldFZhbHVlcygpLnNsaWNlKGJlZ2luLCBiZWdpbiArIHNpemUpO1xuICAgICAgICByZXR1cm4gbmRhcnJheV8xLkFycmF5MUQubmV3KG5ld1ZhbHMpO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhDUFUucHJvdG90eXBlLnNsaWNlMkRJbnRlcm5hbCA9IGZ1bmN0aW9uIChpbnB1dCwgYmVnaW4sIHNpemUpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IG5kYXJyYXlfMS5BcnJheTJELnplcm9zKHNpemUpO1xuICAgICAgICB2YXIgc3RhcnRJID0gYmVnaW5bMF0sIHN0YXJ0SiA9IGJlZ2luWzFdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemVbMF07ICsraSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBzaXplWzFdOyArK2opIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsID0gaW5wdXQuZ2V0KGkgKyBzdGFydEksIGogKyBzdGFydEopO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5zZXQodmFsLCBpLCBqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhDUFUucHJvdG90eXBlLnNsaWNlM0RJbnRlcm5hbCA9IGZ1bmN0aW9uIChpbnB1dCwgYmVnaW4sIHNpemUpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IG5kYXJyYXlfMS5BcnJheTNELnplcm9zKHNpemUpO1xuICAgICAgICB2YXIgc3RhcnRJID0gYmVnaW5bMF0sIHN0YXJ0SiA9IGJlZ2luWzFdLCBzdGFydEsgPSBiZWdpblsyXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplWzBdOyArK2kpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgc2l6ZVsxXTsgKytqKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBzaXplWzJdOyArK2spIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbCA9IGlucHV0LmdldChpICsgc3RhcnRJLCBqICsgc3RhcnRKLCBrICsgc3RhcnRLKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnNldCh2YWwsIGksIGosIGspO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhDUFUucHJvdG90eXBlLnNsaWNlNERJbnRlcm5hbCA9IGZ1bmN0aW9uIChpbnB1dCwgYmVnaW4sIHNpemUpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IG5kYXJyYXlfMS5BcnJheTRELnplcm9zKHNpemUpO1xuICAgICAgICB2YXIgc3RhcnRJID0gYmVnaW5bMF0sIHN0YXJ0SiA9IGJlZ2luWzFdLCBzdGFydEsgPSBiZWdpblsyXSwgc3RhcnRMID0gYmVnaW5bM107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZVswXTsgKytpKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHNpemVbMV07ICsraikge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgc2l6ZVsyXTsgKytrKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGwgPSAwOyBsIDwgc2l6ZVszXTsgKytsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsID0gaW5wdXQuZ2V0KGkgKyBzdGFydEksIGogKyBzdGFydEosIGsgKyBzdGFydEssIGwgKyBzdGFydEwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnNldCh2YWwsIGksIGosIGssIGwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aENQVS5wcm90b3R5cGUuY29weTJESW50ZXJuYWwgPSBmdW5jdGlvbiAoc291cmNlLCBzb3VyY2VCZWdpblJvd0NvbCwgc291cmNlU2l6ZVJvd0NvbCwgZGVzdCwgZGVzdEJlZ2luUm93Q29sLCBkZXN0U2l6ZVJvd0NvbCkge1xuICAgICAgICBjb3B5MkRfdXRpbC52YWxpZGF0ZVNoYXBlcyhzb3VyY2VTaXplUm93Q29sLCBkZXN0U2l6ZVJvd0NvbCk7XG4gICAgICAgIHZhciBzcmNWYWx1ZXMgPSBzb3VyY2UuZ2V0VmFsdWVzKCk7XG4gICAgICAgIHZhciBkc3RWYWx1ZXMgPSBkZXN0LmdldFZhbHVlcygpO1xuICAgICAgICB2YXIgbiA9IHNvdXJjZVNpemVSb3dDb2xbMF0gKiBzb3VyY2VTaXplUm93Q29sWzFdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgICAgICAgdmFyIHNyY1JvdyA9IHNvdXJjZUJlZ2luUm93Q29sWzBdICsgTWF0aC5mbG9vcihpIC8gc291cmNlU2l6ZVJvd0NvbFsxXSk7XG4gICAgICAgICAgICB2YXIgc3JjQ29sID0gc291cmNlQmVnaW5Sb3dDb2xbMV0gKyAoaSAlIHNvdXJjZVNpemVSb3dDb2xbMV0pO1xuICAgICAgICAgICAgdmFyIHNyY09mZiA9IHNyY1JvdyAqIHNvdXJjZS5zaGFwZVsxXSArIHNyY0NvbDtcbiAgICAgICAgICAgIHZhciBkc3RSb3cgPSBkZXN0QmVnaW5Sb3dDb2xbMF0gKyBNYXRoLmZsb29yKGkgLyBkZXN0U2l6ZVJvd0NvbFsxXSk7XG4gICAgICAgICAgICB2YXIgZHN0Q29sID0gZGVzdEJlZ2luUm93Q29sWzFdICsgKGkgJSBkZXN0U2l6ZVJvd0NvbFsxXSk7XG4gICAgICAgICAgICB2YXIgZHN0T2ZmID0gZHN0Um93ICogZGVzdC5zaGFwZVsxXSArIGRzdENvbDtcbiAgICAgICAgICAgIGRzdFZhbHVlc1tkc3RPZmZdID0gc3JjVmFsdWVzW3NyY09mZl07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoQ1BVLnByb3RvdHlwZS5jb25jYXQxREludGVybmFsID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgdmFyIG91dFNoYXBlID0gY29uY2F0X3V0aWwuY29tcHV0ZU91dFNoYXBlKGEuc2hhcGUsIGIuc2hhcGUsIDApO1xuICAgICAgICB2YXIgcmVzdWx0ID0gbmRhcnJheV8xLkFycmF5MUQuemVyb3Mob3V0U2hhcGUpO1xuICAgICAgICB2YXIgYVZhbHMgPSBhLmdldFZhbHVlcygpO1xuICAgICAgICB2YXIgYlZhbHMgPSBiLmdldFZhbHVlcygpO1xuICAgICAgICB2YXIgdmFscyA9IHJlc3VsdC5nZXRWYWx1ZXMoKTtcbiAgICAgICAgdmFscy5zZXQoYVZhbHMsIDApO1xuICAgICAgICB2YWxzLnNldChiVmFscywgYS5zaXplKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoQ1BVLnByb3RvdHlwZS5jb25jYXQyREludGVybmFsID0gZnVuY3Rpb24gKGEsIGIsIGF4aXMpIHtcbiAgICAgICAgdmFyIG91dFNoYXBlID0gY29uY2F0X3V0aWwuY29tcHV0ZU91dFNoYXBlKGEuc2hhcGUsIGIuc2hhcGUsIGF4aXMpO1xuICAgICAgICB2YXIgcmVzdWx0ID0gbmRhcnJheV8xLkFycmF5MkQuemVyb3Mob3V0U2hhcGUpO1xuICAgICAgICBpZiAoYXhpcyA9PT0gMCkge1xuICAgICAgICAgICAgdmFyIGFWYWxzID0gYS5nZXRWYWx1ZXMoKTtcbiAgICAgICAgICAgIHZhciBiVmFscyA9IGIuZ2V0VmFsdWVzKCk7XG4gICAgICAgICAgICB2YXIgdmFscyA9IHJlc3VsdC5nZXRWYWx1ZXMoKTtcbiAgICAgICAgICAgIHZhbHMuc2V0KGFWYWxzLCAwKTtcbiAgICAgICAgICAgIHZhbHMuc2V0KGJWYWxzLCBhLnNpemUpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG91dFNoYXBlWzBdOyArK2kpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgb3V0U2hhcGVbMV07ICsraikge1xuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IFtpLCBqXTtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4W2F4aXNdIDwgYS5zaGFwZVtheGlzXSkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGEuZ2V0KGksIGopO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXhbYXhpc10gLT0gYS5zaGFwZVtheGlzXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGkyID0gaW5kZXhbMF0sIGoyID0gaW5kZXhbMV07XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gYi5nZXQoaTIsIGoyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0LnNldCh2YWx1ZSwgaSwgaik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoQ1BVLnByb3RvdHlwZS5jb25jYXQzREludGVybmFsID0gZnVuY3Rpb24gKGEsIGIsIGF4aXMpIHtcbiAgICAgICAgdmFyIG91dFNoYXBlID0gY29uY2F0X3V0aWwuY29tcHV0ZU91dFNoYXBlKGEuc2hhcGUsIGIuc2hhcGUsIGF4aXMpO1xuICAgICAgICB2YXIgcmVzdWx0ID0gbmRhcnJheV8xLkFycmF5M0QuemVyb3Mob3V0U2hhcGUpO1xuICAgICAgICBpZiAoYXhpcyA9PT0gMCkge1xuICAgICAgICAgICAgdmFyIGFWYWxzID0gYS5nZXRWYWx1ZXMoKTtcbiAgICAgICAgICAgIHZhciBiVmFscyA9IGIuZ2V0VmFsdWVzKCk7XG4gICAgICAgICAgICB2YXIgdmFscyA9IHJlc3VsdC5nZXRWYWx1ZXMoKTtcbiAgICAgICAgICAgIHZhbHMuc2V0KGFWYWxzLCAwKTtcbiAgICAgICAgICAgIHZhbHMuc2V0KGJWYWxzLCBhLnNpemUpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG91dFNoYXBlWzBdOyArK2kpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgb3V0U2hhcGVbMV07ICsraikge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgb3V0U2hhcGVbMl07ICsraykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBbaSwgaiwga107XG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4W2F4aXNdIDwgYS5zaGFwZVtheGlzXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBhLmdldChpLCBqLCBrKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4W2F4aXNdIC09IGEuc2hhcGVbYXhpc107XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaTIgPSBpbmRleFswXSwgajIgPSBpbmRleFsxXSwgazIgPSBpbmRleFsyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gYi5nZXQoaTIsIGoyLCBrMik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnNldCh2YWx1ZSwgaSwgaiwgayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aENQVS5wcm90b3R5cGUuY29uY2F0NERJbnRlcm5hbCA9IGZ1bmN0aW9uIChhLCBiLCBheGlzKSB7XG4gICAgICAgIHZhciBvdXRTaGFwZSA9IGNvbmNhdF91dGlsLmNvbXB1dGVPdXRTaGFwZShhLnNoYXBlLCBiLnNoYXBlLCBheGlzKTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IG5kYXJyYXlfMS5BcnJheTRELnplcm9zKG91dFNoYXBlKTtcbiAgICAgICAgaWYgKGF4aXMgPT09IDApIHtcbiAgICAgICAgICAgIHZhciBhVmFscyA9IGEuZ2V0VmFsdWVzKCk7XG4gICAgICAgICAgICB2YXIgYlZhbHMgPSBiLmdldFZhbHVlcygpO1xuICAgICAgICAgICAgdmFyIHZhbHMgPSByZXN1bHQuZ2V0VmFsdWVzKCk7XG4gICAgICAgICAgICB2YWxzLnNldChhVmFscywgMCk7XG4gICAgICAgICAgICB2YWxzLnNldChiVmFscywgYS5zaXplKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvdXRTaGFwZVswXTsgKytpKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG91dFNoYXBlWzFdOyArK2opIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IG91dFNoYXBlWzJdOyArK2spIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgbCA9IDA7IGwgPCBvdXRTaGFwZVszXTsgKytsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBbaSwgaiwgaywgbF07XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXhbYXhpc10gPCBhLnNoYXBlW2F4aXNdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBhLmdldChpLCBqLCBrLCBsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4W2F4aXNdIC09IGEuc2hhcGVbYXhpc107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGkyID0gaW5kZXhbMF0sIGoyID0gaW5kZXhbMV0sIGsyID0gaW5kZXhbMl0sIGwyID0gaW5kZXhbM107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBiLmdldChpMiwgajIsIGsyLCBsMik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuc2V0KHZhbHVlLCBpLCBqLCBrLCBsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhDUFUucHJvdG90eXBlLnNjYWxlZEFycmF5QWRkSW50ZXJuYWwgPSBmdW5jdGlvbiAoYzEsIGEsIGMyLCBiKSB7XG4gICAgICAgIHZhciBjMVZhbCA9IGMxLmdldCgpO1xuICAgICAgICB2YXIgYzJWYWwgPSBjMi5nZXQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnJvYWRjYXN0ZWRCaW5hcnlPcChhLCBiLCAnZmxvYXQzMicsIGZ1bmN0aW9uIChhVmFsLCBiVmFsKSB7XG4gICAgICAgICAgICByZXR1cm4gYzFWYWwgKiBhVmFsICsgYzJWYWwgKiBiVmFsO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoQ1BVLnByb3RvdHlwZS5uZWdJbnRlcm5hbCA9IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNjYWxhclRpbWVzQXJyYXkobmRhcnJheV8xLlNjYWxhci5ORUdfT05FLCBhKTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoQ1BVLnByb3RvdHlwZS5hZGRJbnRlcm5hbCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNjYWxlZEFycmF5QWRkSW50ZXJuYWwobmRhcnJheV8xLlNjYWxhci5PTkUsIGEsIG5kYXJyYXlfMS5TY2FsYXIuT05FLCBiKTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoQ1BVLnByb3RvdHlwZS5zdWJ0cmFjdEludGVybmFsID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NhbGVkQXJyYXlBZGRJbnRlcm5hbChuZGFycmF5XzEuU2NhbGFyLk9ORSwgYSwgbmRhcnJheV8xLlNjYWxhci5ORUdfT05FLCBiKTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoQ1BVLnByb3RvdHlwZS5tYXRNdWxJbnRlcm5hbCA9IGZ1bmN0aW9uIChhLCBiLCBhT3JpZW50YXRpb24sIGJPcmllbnRhdGlvbikge1xuICAgICAgICBpZiAoYU9yaWVudGF0aW9uID09PSB2b2lkIDApIHsgYU9yaWVudGF0aW9uID0gbWF0aF8xLk1hdHJpeE9yaWVudGF0aW9uLlJFR1VMQVI7IH1cbiAgICAgICAgaWYgKGJPcmllbnRhdGlvbiA9PT0gdm9pZCAwKSB7IGJPcmllbnRhdGlvbiA9IG1hdGhfMS5NYXRyaXhPcmllbnRhdGlvbi5SRUdVTEFSOyB9XG4gICAgICAgIHZhciBzaGFyZWREaW0gPSAoYU9yaWVudGF0aW9uID09PSBtYXRoXzEuTWF0cml4T3JpZW50YXRpb24uUkVHVUxBUikgPyBhLnNoYXBlWzFdIDogYS5zaGFwZVswXTtcbiAgICAgICAgdmFyIGxlZnREaW0gPSAoYU9yaWVudGF0aW9uID09PSBtYXRoXzEuTWF0cml4T3JpZW50YXRpb24uUkVHVUxBUikgPyBhLnNoYXBlWzBdIDogYS5zaGFwZVsxXTtcbiAgICAgICAgdmFyIHJpZ2h0RGltID0gKGJPcmllbnRhdGlvbiA9PT0gbWF0aF8xLk1hdHJpeE9yaWVudGF0aW9uLlJFR1VMQVIpID8gYi5zaGFwZVsxXSA6IGIuc2hhcGVbMF07XG4gICAgICAgIHZhciBub3JtYWxHZXR0ZXIgPSBmdW5jdGlvbiAobWF0cml4LCBpLCBqKSB7XG4gICAgICAgICAgICByZXR1cm4gbWF0cml4LmdldChpLCBqKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHRyYW5zcG9zZWRHZXR0ZXIgPSBmdW5jdGlvbiAobWF0cml4LCBpLCBqKSB7XG4gICAgICAgICAgICByZXR1cm4gbWF0cml4LmdldChqLCBpKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGFHZXR0ZXIgPSAoYU9yaWVudGF0aW9uID09PSBtYXRoXzEuTWF0cml4T3JpZW50YXRpb24uUkVHVUxBUikgP1xuICAgICAgICAgICAgbm9ybWFsR2V0dGVyIDpcbiAgICAgICAgICAgIHRyYW5zcG9zZWRHZXR0ZXI7XG4gICAgICAgIHZhciBiR2V0dGVyID0gKGJPcmllbnRhdGlvbiA9PT0gbWF0aF8xLk1hdHJpeE9yaWVudGF0aW9uLlJFR1VMQVIpID9cbiAgICAgICAgICAgIG5vcm1hbEdldHRlciA6XG4gICAgICAgICAgICB0cmFuc3Bvc2VkR2V0dGVyO1xuICAgICAgICB2YXIgdmFsdWVzID0gbmV3IEZsb2F0MzJBcnJheShsZWZ0RGltICogcmlnaHREaW0pO1xuICAgICAgICB2YXIgaW5kZXggPSAwO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlZnREaW07ICsraSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCByaWdodERpbTsgKytqKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN1bSA9IDA7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBzaGFyZWREaW07ICsraykge1xuICAgICAgICAgICAgICAgICAgICBzdW0gKz0gYUdldHRlcihhLCBpLCBrKSAqIGJHZXR0ZXIoYiwgaywgaik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhbHVlc1tpbmRleCsrXSA9IHN1bTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmRhcnJheV8xLkFycmF5MkQubmV3KFtsZWZ0RGltLCByaWdodERpbV0sIHZhbHVlcyk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aENQVS5wcm90b3R5cGUubXVsdGlwbHlJbnRlcm5hbCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHZhciBuZXdTaGFwZSA9IGJyb2FkY2FzdF91dGlsLmFzc2VydEFuZEdldEJyb2FkY2FzdFNoYXBlKGEuc2hhcGUsIGIuc2hhcGUpO1xuICAgICAgICB2YXIgbmV3VmFsdWVzID0gbmV3IEZsb2F0MzJBcnJheSh1dGlsLnNpemVGcm9tU2hhcGUobmV3U2hhcGUpKTtcbiAgICAgICAgdmFyIGFWYWx1ZXMgPSBhLmdldFZhbHVlcygpO1xuICAgICAgICB2YXIgYlZhbHVlcyA9IGIuZ2V0VmFsdWVzKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmV3VmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBuZXdWYWx1ZXNbaV0gPSBhVmFsdWVzW2kgJSBhLnNpemVdICogYlZhbHVlc1tpICUgYi5zaXplXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmRhcnJheV8xLk5EQXJyYXkubWFrZShuZXdTaGFwZSwgeyB2YWx1ZXM6IG5ld1ZhbHVlcyB9KTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoQ1BVLnByb3RvdHlwZS5kaXZpZGVJbnRlcm5hbCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHZhciBuZXdTaGFwZSA9IGJyb2FkY2FzdF91dGlsLmFzc2VydEFuZEdldEJyb2FkY2FzdFNoYXBlKGEuc2hhcGUsIGIuc2hhcGUpO1xuICAgICAgICB2YXIgbmV3VmFsdWVzID0gbmV3IEZsb2F0MzJBcnJheSh1dGlsLnNpemVGcm9tU2hhcGUobmV3U2hhcGUpKTtcbiAgICAgICAgdmFyIGFWYWx1ZXMgPSBhLmdldFZhbHVlcygpO1xuICAgICAgICB2YXIgYlZhbHVlcyA9IGIuZ2V0VmFsdWVzKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmV3VmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBuZXdWYWx1ZXNbaV0gPSBhVmFsdWVzW2kgJSBhLnNpemVdIC8gYlZhbHVlc1tpICUgYi5zaXplXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmRhcnJheV8xLk5EQXJyYXkubWFrZShuZXdTaGFwZSwgeyB2YWx1ZXM6IG5ld1ZhbHVlcyB9LCAnZmxvYXQzMicpO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhDUFUucHJvdG90eXBlLnN1bUludGVybmFsID0gZnVuY3Rpb24gKGlucHV0LCBheGVzKSB7XG4gICAgICAgIGF4aXNfdXRpbC5hc3NlcnRBeGVzQXJlSW5uZXJNb3N0RGltcygnc3VtJywgYXhlcywgaW5wdXQucmFuayk7XG4gICAgICAgIHZhciBfYSA9IGF4aXNfdXRpbC5jb21wdXRlT3V0QW5kUmVkdWNlU2hhcGVzKGlucHV0LnNoYXBlLCBheGVzKSwgb3V0U2hhcGUgPSBfYVswXSwgcmVkdWNlU2hhcGUgPSBfYVsxXTtcbiAgICAgICAgdmFyIHJlc3VsdER0eXBlID0gbWF0aF8xLlN1bVR5cGVzTWFwW2lucHV0LmR0eXBlXTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IG5kYXJyYXlfMS5OREFycmF5Lnplcm9zKG91dFNoYXBlLCByZXN1bHREdHlwZSk7XG4gICAgICAgIHZhciByZWR1Y2VTaXplID0gdXRpbC5zaXplRnJvbVNoYXBlKHJlZHVjZVNoYXBlKTtcbiAgICAgICAgdmFyIHZhbHMgPSByZXN1bHQuZ2V0VmFsdWVzKCk7XG4gICAgICAgIHZhciBhVmFscyA9IGlucHV0LmdldFZhbHVlcygpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSBpICogcmVkdWNlU2l6ZTtcbiAgICAgICAgICAgIHZhciBzdW0gPSAwO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCByZWR1Y2VTaXplOyArK2opIHtcbiAgICAgICAgICAgICAgICBzdW0gKz0gYVZhbHNbb2Zmc2V0ICsgal07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YWxzW2ldID0gc3VtO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aENQVS5wcm90b3R5cGUuYXJnTWluSW50ZXJuYWwgPSBmdW5jdGlvbiAoaW5wdXQsIGF4ZXMpIHtcbiAgICAgICAgYXhpc191dGlsLmFzc2VydEF4ZXNBcmVJbm5lck1vc3REaW1zKCdhcmdNaW4nLCBheGVzLCBpbnB1dC5yYW5rKTtcbiAgICAgICAgdmFyIF9hID0gYXhpc191dGlsLmNvbXB1dGVPdXRBbmRSZWR1Y2VTaGFwZXMoaW5wdXQuc2hhcGUsIGF4ZXMpLCBvdXRTaGFwZSA9IF9hWzBdLCByZWR1Y2VTaGFwZSA9IF9hWzFdO1xuICAgICAgICB2YXIgcmVzdWx0ID0gbmRhcnJheV8xLk5EQXJyYXkuemVyb3Mob3V0U2hhcGUsICdpbnQzMicpO1xuICAgICAgICB2YXIgcmVkdWNlU2l6ZSA9IHV0aWwuc2l6ZUZyb21TaGFwZShyZWR1Y2VTaGFwZSk7XG4gICAgICAgIHZhciB2YWxzID0gcmVzdWx0LmdldFZhbHVlcygpO1xuICAgICAgICB2YXIgYVZhbHMgPSBpbnB1dC5nZXRWYWx1ZXMoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWxzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gaSAqIHJlZHVjZVNpemU7XG4gICAgICAgICAgICB2YXIgbWluID0gYVZhbHNbb2Zmc2V0XTtcbiAgICAgICAgICAgIHZhciBtaW5JbmRleCA9IDA7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHJlZHVjZVNpemU7ICsraikge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGFWYWxzW29mZnNldCArIGpdO1xuICAgICAgICAgICAgICAgIGlmIChpc05hTih2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbWluSW5kZXggPSB1dGlsLk5BTl9JTlQzMjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA8IG1pbikge1xuICAgICAgICAgICAgICAgICAgICBtaW4gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgbWluSW5kZXggPSBqO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhbHNbaV0gPSBtaW5JbmRleDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhDUFUucHJvdG90eXBlLmFyZ01heEludGVybmFsID0gZnVuY3Rpb24gKGlucHV0LCBheGVzKSB7XG4gICAgICAgIGF4aXNfdXRpbC5hc3NlcnRBeGVzQXJlSW5uZXJNb3N0RGltcygnYXJnTWF4JywgYXhlcywgaW5wdXQucmFuayk7XG4gICAgICAgIHZhciBfYSA9IGF4aXNfdXRpbC5jb21wdXRlT3V0QW5kUmVkdWNlU2hhcGVzKGlucHV0LnNoYXBlLCBheGVzKSwgb3V0U2hhcGUgPSBfYVswXSwgcmVkdWNlU2hhcGUgPSBfYVsxXTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IG5kYXJyYXlfMS5OREFycmF5Lnplcm9zKG91dFNoYXBlLCAnaW50MzInKTtcbiAgICAgICAgdmFyIHJlZHVjZVNpemUgPSB1dGlsLnNpemVGcm9tU2hhcGUocmVkdWNlU2hhcGUpO1xuICAgICAgICB2YXIgdmFscyA9IHJlc3VsdC5nZXRWYWx1ZXMoKTtcbiAgICAgICAgdmFyIGFWYWxzID0gaW5wdXQuZ2V0VmFsdWVzKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFscy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIG9mZnNldCA9IGkgKiByZWR1Y2VTaXplO1xuICAgICAgICAgICAgdmFyIG1heCA9IGFWYWxzW29mZnNldF07XG4gICAgICAgICAgICB2YXIgbWF4SW5kZXggPSAwO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCByZWR1Y2VTaXplOyArK2opIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBhVmFsc1tvZmZzZXQgKyBqXTtcbiAgICAgICAgICAgICAgICBpZiAoaXNOYU4odmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIG1heEluZGV4ID0gdXRpbC5OQU5fSU5UMzI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPiBtYXgpIHtcbiAgICAgICAgICAgICAgICAgICAgbWF4ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIG1heEluZGV4ID0gajtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YWxzW2ldID0gbWF4SW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoQ1BVLnByb3RvdHlwZS5lcXVhbEludGVybmFsID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnJvYWRjYXN0ZWRCaW5hcnlPcChhLCBiLCAnYm9vbCcsIGZ1bmN0aW9uIChhVmFsLCBiVmFsKSB7XG4gICAgICAgICAgICBpZiAodXRpbC5pc1ZhbE5hTihhVmFsLCBhLmR0eXBlKSB8fCB1dGlsLmlzVmFsTmFOKGJWYWwsIGIuZHR5cGUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHV0aWwuZ2V0TmFOKCdib29sJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKGFWYWwgPT09IGJWYWwpID8gMSA6IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhDUFUucHJvdG90eXBlLnRvcEtJbnRlcm5hbCA9IGZ1bmN0aW9uIChuZGFycmF5LCBrKSB7XG4gICAgICAgIHZhciB2YWx1ZXMgPSBuZGFycmF5LmdldFZhbHVlcygpO1xuICAgICAgICB2YXIgdmFsdWVzQW5kSW5kaWNlcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFsdWVzQW5kSW5kaWNlcy5wdXNoKHsgdmFsdWU6IHZhbHVlc1tpXSwgaW5kZXg6IGkgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFsdWVzQW5kSW5kaWNlcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gYi52YWx1ZSAtIGEudmFsdWU7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgdG9wa1ZhbHVlcyA9IG5ldyBGbG9hdDMyQXJyYXkoayk7XG4gICAgICAgIHZhciB0b3BrSW5kaWNlcyA9IG5ldyBGbG9hdDMyQXJyYXkoayk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgazsgaSsrKSB7XG4gICAgICAgICAgICB0b3BrVmFsdWVzW2ldID0gdmFsdWVzQW5kSW5kaWNlc1tpXS52YWx1ZTtcbiAgICAgICAgICAgIHRvcGtJbmRpY2VzW2ldID0gdmFsdWVzQW5kSW5kaWNlc1tpXS5pbmRleDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyB2YWx1ZXM6IG5kYXJyYXlfMS5BcnJheTFELm5ldyh0b3BrVmFsdWVzKSwgaW5kaWNlczogbmRhcnJheV8xLkFycmF5MUQubmV3KHRvcGtJbmRpY2VzKSB9O1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhDUFUucHJvdG90eXBlLm1pbkludGVybmFsID0gZnVuY3Rpb24gKGlucHV0LCBheGVzKSB7XG4gICAgICAgIGF4aXNfdXRpbC5hc3NlcnRBeGVzQXJlSW5uZXJNb3N0RGltcygnbWluJywgYXhlcywgaW5wdXQucmFuayk7XG4gICAgICAgIHZhciBfYSA9IGF4aXNfdXRpbC5jb21wdXRlT3V0QW5kUmVkdWNlU2hhcGVzKGlucHV0LnNoYXBlLCBheGVzKSwgb3V0U2hhcGUgPSBfYVswXSwgcmVkdWNlU2hhcGUgPSBfYVsxXTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IG5kYXJyYXlfMS5OREFycmF5Lnplcm9zKG91dFNoYXBlLCBpbnB1dC5kdHlwZSk7XG4gICAgICAgIHZhciByZWR1Y2VTaXplID0gdXRpbC5zaXplRnJvbVNoYXBlKHJlZHVjZVNoYXBlKTtcbiAgICAgICAgdmFyIHZhbHMgPSByZXN1bHQuZ2V0VmFsdWVzKCk7XG4gICAgICAgIHZhciBhVmFscyA9IGlucHV0LmdldFZhbHVlcygpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSBpICogcmVkdWNlU2l6ZTtcbiAgICAgICAgICAgIHZhciBtaW4gPSBhVmFsc1swXTtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcmVkdWNlU2l6ZTsgKytqKSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gYVZhbHNbb2Zmc2V0ICsgal07XG4gICAgICAgICAgICAgICAgaWYgKGlzTmFOKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBtaW4gPSBOdW1iZXIuTmFOO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlIDwgbWluKSB7XG4gICAgICAgICAgICAgICAgICAgIG1pbiA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhbHNbaV0gPSBtaW47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoQ1BVLnByb3RvdHlwZS5tYXhJbnRlcm5hbCA9IGZ1bmN0aW9uIChpbnB1dCwgYXhlcykge1xuICAgICAgICBheGlzX3V0aWwuYXNzZXJ0QXhlc0FyZUlubmVyTW9zdERpbXMoJ21heCcsIGF4ZXMsIGlucHV0LnJhbmspO1xuICAgICAgICB2YXIgX2EgPSBheGlzX3V0aWwuY29tcHV0ZU91dEFuZFJlZHVjZVNoYXBlcyhpbnB1dC5zaGFwZSwgYXhlcyksIG91dFNoYXBlID0gX2FbMF0sIHJlZHVjZVNoYXBlID0gX2FbMV07XG4gICAgICAgIHZhciByZXN1bHQgPSBuZGFycmF5XzEuTkRBcnJheS56ZXJvcyhvdXRTaGFwZSwgaW5wdXQuZHR5cGUpO1xuICAgICAgICB2YXIgcmVkdWNlU2l6ZSA9IHV0aWwuc2l6ZUZyb21TaGFwZShyZWR1Y2VTaGFwZSk7XG4gICAgICAgIHZhciB2YWxzID0gcmVzdWx0LmdldFZhbHVlcygpO1xuICAgICAgICB2YXIgYVZhbHMgPSBpbnB1dC5nZXRWYWx1ZXMoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWxzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gaSAqIHJlZHVjZVNpemU7XG4gICAgICAgICAgICB2YXIgbWF4ID0gYVZhbHNbb2Zmc2V0XTtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcmVkdWNlU2l6ZTsgKytqKSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gYVZhbHNbb2Zmc2V0ICsgal07XG4gICAgICAgICAgICAgICAgaWYgKGlzTmFOKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBtYXggPSBOdW1iZXIuTmFOO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID4gbWF4KSB7XG4gICAgICAgICAgICAgICAgICAgIG1heCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhbHNbaV0gPSBtYXg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoQ1BVLnByb3RvdHlwZS5jZWlsSW50ZXJuYWwgPSBmdW5jdGlvbiAobmRhcnJheSkge1xuICAgICAgICB2YXIgdmFsdWVzID0gbmRhcnJheS5nZXRWYWx1ZXMoKTtcbiAgICAgICAgdmFyIG5ld1ZhbHVlcyA9IG5ldyBGbG9hdDMyQXJyYXkodmFsdWVzLmxlbmd0aCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBuZXdWYWx1ZXNbaV0gPSBNYXRoLmNlaWwodmFsdWVzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmRhcnJheV8xLk5EQXJyYXkubWFrZShuZGFycmF5LnNoYXBlLCB7IHZhbHVlczogbmV3VmFsdWVzIH0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhDUFUucHJvdG90eXBlLmZsb29ySW50ZXJuYWwgPSBmdW5jdGlvbiAobmRhcnJheSkge1xuICAgICAgICB2YXIgdmFsdWVzID0gbmRhcnJheS5nZXRWYWx1ZXMoKTtcbiAgICAgICAgdmFyIG5ld1ZhbHVlcyA9IG5ldyBGbG9hdDMyQXJyYXkodmFsdWVzLmxlbmd0aCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBuZXdWYWx1ZXNbaV0gPSBNYXRoLmZsb29yKHZhbHVlc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5kYXJyYXlfMS5OREFycmF5Lm1ha2UobmRhcnJheS5zaGFwZSwgeyB2YWx1ZXM6IG5ld1ZhbHVlcyB9KTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoQ1BVLnByb3RvdHlwZS5leHBJbnRlcm5hbCA9IGZ1bmN0aW9uIChuZGFycmF5KSB7XG4gICAgICAgIHZhciB2YWx1ZXMgPSBuZGFycmF5LmdldFZhbHVlcygpO1xuICAgICAgICB2YXIgbmV3VmFsdWVzID0gbmV3IEZsb2F0MzJBcnJheSh2YWx1ZXMubGVuZ3RoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIG5ld1ZhbHVlc1tpXSA9IE1hdGguZXhwKHZhbHVlc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5kYXJyYXlfMS5OREFycmF5Lm1ha2UobmRhcnJheS5zaGFwZSwgeyB2YWx1ZXM6IG5ld1ZhbHVlcyB9KTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoQ1BVLnByb3RvdHlwZS5sb2dJbnRlcm5hbCA9IGZ1bmN0aW9uIChuZGFycmF5KSB7XG4gICAgICAgIHZhciB2YWx1ZXMgPSBuZGFycmF5LmdldFZhbHVlcygpO1xuICAgICAgICB2YXIgbmV3VmFsdWVzID0gbmV3IEZsb2F0MzJBcnJheSh2YWx1ZXMubGVuZ3RoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHZhbHVlc1tpXTtcbiAgICAgICAgICAgIG5ld1ZhbHVlc1tpXSA9IE1hdGgubG9nKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmRhcnJheV8xLk5EQXJyYXkubWFrZShuZGFycmF5LnNoYXBlLCB7IHZhbHVlczogbmV3VmFsdWVzIH0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhDUFUucHJvdG90eXBlLnNxcnRJbnRlcm5hbCA9IGZ1bmN0aW9uIChuZGFycmF5KSB7XG4gICAgICAgIHZhciB2YWx1ZXMgPSBuZGFycmF5LmdldFZhbHVlcygpO1xuICAgICAgICB2YXIgbmV3VmFsdWVzID0gbmV3IEZsb2F0MzJBcnJheSh2YWx1ZXMubGVuZ3RoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHZhbHVlc1tpXTtcbiAgICAgICAgICAgIG5ld1ZhbHVlc1tpXSA9IE1hdGguc3FydCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5kYXJyYXlfMS5OREFycmF5Lm1ha2UobmRhcnJheS5zaGFwZSwgeyB2YWx1ZXM6IG5ld1ZhbHVlcyB9KTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoQ1BVLnByb3RvdHlwZS5zcXVhcmVJbnRlcm5hbCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHZhciB2YWx1ZXMgPSB4LmdldFZhbHVlcygpO1xuICAgICAgICB2YXIgbmV3VmFsdWVzID0gbmV3IEZsb2F0MzJBcnJheSh2YWx1ZXMubGVuZ3RoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHZhbHVlc1tpXTtcbiAgICAgICAgICAgIG5ld1ZhbHVlc1tpXSA9IHZhbHVlICogdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5kYXJyYXlfMS5OREFycmF5Lm1ha2UoeC5zaGFwZSwgeyB2YWx1ZXM6IG5ld1ZhbHVlcyB9KTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoQ1BVLnByb3RvdHlwZS5yZWx1SW50ZXJuYWwgPSBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgICAgdmFyIHJlcyA9IG5kYXJyYXlfMS5OREFycmF5Lnplcm9zKGlucHV0LnNoYXBlLCBpbnB1dC5kdHlwZSk7XG4gICAgICAgIHZhciByZXNWYWxzID0gcmVzLmdldFZhbHVlcygpO1xuICAgICAgICB2YXIgaW5WYWxzID0gaW5wdXQuZ2V0VmFsdWVzKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5WYWxzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgdmFsID0gaW5WYWxzW2ldO1xuICAgICAgICAgICAgaWYgKHV0aWwuaXNWYWxOYU4odmFsLCBpbnB1dC5kdHlwZSkpIHtcbiAgICAgICAgICAgICAgICByZXNWYWxzW2ldID0gdXRpbC5nZXROYU4ocmVzLmR0eXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc1ZhbHNbaV0gPSBNYXRoLm1heCgwLCBpblZhbHNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aENQVS5wcm90b3R5cGUuZWx1SW50ZXJuYWwgPSBmdW5jdGlvbiAobmRhcnJheSkge1xuICAgICAgICB2YXIgcmVzdWx0VmFsdWVzID0gbmV3IEZsb2F0MzJBcnJheShuZGFycmF5LnNpemUpO1xuICAgICAgICB2YXIgdmFsdWVzID0gbmRhcnJheS5kYXRhU3luYygpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIHYgPSB2YWx1ZXNbaV07XG4gICAgICAgICAgICBpZiAodiA+PSAwKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0VmFsdWVzW2ldID0gdjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdFZhbHVlc1tpXSA9IChNYXRoLmV4cCh2KSAtIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZGFycmF5XzEuTkRBcnJheS5tYWtlKG5kYXJyYXkuc2hhcGUsIHsgdmFsdWVzOiByZXN1bHRWYWx1ZXMgfSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aENQVS5wcm90b3R5cGUubGVha3lSZWx1SW50ZXJuYWwgPSBmdW5jdGlvbiAobmRhcnJheSwgYWxwaGEpIHtcbiAgICAgICAgdmFyIHJlc3VsdFZhbHVlcyA9IG5ldyBGbG9hdDMyQXJyYXkobmRhcnJheS5zaXplKTtcbiAgICAgICAgdmFyIHZhbHVlcyA9IG5kYXJyYXkuZGF0YVN5bmMoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciB2ID0gdmFsdWVzW2ldO1xuICAgICAgICAgICAgaWYgKHYgPj0gMCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdFZhbHVlc1tpXSA9IHY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHRWYWx1ZXNbaV0gPSBhbHBoYSAqIHY7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5kYXJyYXlfMS5OREFycmF5Lm1ha2UobmRhcnJheS5zaGFwZSwgeyB2YWx1ZXM6IHJlc3VsdFZhbHVlcyB9KTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoQ1BVLnByb3RvdHlwZS5jbGlwSW50ZXJuYWwgPSBmdW5jdGlvbiAobmRhcnJheSwgbWluLCBtYXgpIHtcbiAgICAgICAgdmFyIHJlc3VsdFZhbHVlcyA9IG5ldyBGbG9hdDMyQXJyYXkobmRhcnJheS5zaXplKTtcbiAgICAgICAgdmFyIHZhbHVlcyA9IG5kYXJyYXkuZ2V0VmFsdWVzKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICByZXN1bHRWYWx1ZXNbaV0gPSBNYXRoLm1pbihtYXgsIE1hdGgubWF4KG1pbiwgdmFsdWVzW2ldKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5kYXJyYXlfMS5OREFycmF5Lm1ha2UobmRhcnJheS5zaGFwZSwgeyB2YWx1ZXM6IHJlc3VsdFZhbHVlcyB9KTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoQ1BVLnByb3RvdHlwZS5hYnNJbnRlcm5hbCA9IGZ1bmN0aW9uIChuZGFycmF5KSB7XG4gICAgICAgIHZhciByZXN1bHRWYWx1ZXMgPSBuZXcgRmxvYXQzMkFycmF5KG5kYXJyYXkuc2l6ZSk7XG4gICAgICAgIHZhciB2YWx1ZXMgPSBuZGFycmF5LmdldFZhbHVlcygpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgcmVzdWx0VmFsdWVzW2ldID0gTWF0aC5hYnModmFsdWVzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmRhcnJheV8xLk5EQXJyYXkubWFrZShuZGFycmF5LnNoYXBlLCB7IHZhbHVlczogcmVzdWx0VmFsdWVzIH0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhDUFUucHJvdG90eXBlLnNpZ21vaWRJbnRlcm5hbCA9IGZ1bmN0aW9uIChuZGFycmF5KSB7XG4gICAgICAgIHZhciByZXN1bHRWYWx1ZXMgPSBuZXcgRmxvYXQzMkFycmF5KG5kYXJyYXkuc2l6ZSk7XG4gICAgICAgIHZhciB2YWx1ZXMgPSBuZGFycmF5LmdldFZhbHVlcygpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgcmVzdWx0VmFsdWVzW2ldID0gMSAvICgxICsgTWF0aC5leHAoLXZhbHVlc1tpXSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZGFycmF5XzEuTkRBcnJheS5tYWtlKG5kYXJyYXkuc2hhcGUsIHsgdmFsdWVzOiByZXN1bHRWYWx1ZXMgfSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aENQVS5wcm90b3R5cGUuc2luSW50ZXJuYWwgPSBmdW5jdGlvbiAobmRhcnJheSkge1xuICAgICAgICB2YXIgcmVzdWx0VmFsdWVzID0gbmV3IEZsb2F0MzJBcnJheShuZGFycmF5LnNpemUpO1xuICAgICAgICB2YXIgdmFsdWVzID0gbmRhcnJheS5nZXRWYWx1ZXMoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHJlc3VsdFZhbHVlc1tpXSA9IE1hdGguc2luKHZhbHVlc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5kYXJyYXlfMS5OREFycmF5Lm1ha2UobmRhcnJheS5zaGFwZSwgeyB2YWx1ZXM6IHJlc3VsdFZhbHVlcyB9KTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoQ1BVLnByb3RvdHlwZS5jb3NJbnRlcm5hbCA9IGZ1bmN0aW9uIChuZGFycmF5KSB7XG4gICAgICAgIHZhciByZXN1bHRWYWx1ZXMgPSBuZXcgRmxvYXQzMkFycmF5KG5kYXJyYXkuc2l6ZSk7XG4gICAgICAgIHZhciB2YWx1ZXMgPSBuZGFycmF5LmdldFZhbHVlcygpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgcmVzdWx0VmFsdWVzW2ldID0gTWF0aC5jb3ModmFsdWVzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmRhcnJheV8xLk5EQXJyYXkubWFrZShuZGFycmF5LnNoYXBlLCB7IHZhbHVlczogcmVzdWx0VmFsdWVzIH0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhDUFUucHJvdG90eXBlLnRhbkludGVybmFsID0gZnVuY3Rpb24gKG5kYXJyYXkpIHtcbiAgICAgICAgdmFyIHJlc3VsdFZhbHVlcyA9IG5ldyBGbG9hdDMyQXJyYXkobmRhcnJheS5zaXplKTtcbiAgICAgICAgdmFyIHZhbHVlcyA9IG5kYXJyYXkuZ2V0VmFsdWVzKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICByZXN1bHRWYWx1ZXNbaV0gPSBNYXRoLnRhbih2YWx1ZXNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZGFycmF5XzEuTkRBcnJheS5tYWtlKG5kYXJyYXkuc2hhcGUsIHsgdmFsdWVzOiByZXN1bHRWYWx1ZXMgfSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aENQVS5wcm90b3R5cGUuYXNpbkludGVybmFsID0gZnVuY3Rpb24gKG5kYXJyYXkpIHtcbiAgICAgICAgdmFyIHJlc3VsdFZhbHVlcyA9IG5ldyBGbG9hdDMyQXJyYXkobmRhcnJheS5zaXplKTtcbiAgICAgICAgdmFyIHZhbHVlcyA9IG5kYXJyYXkuZ2V0VmFsdWVzKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICByZXN1bHRWYWx1ZXNbaV0gPSBNYXRoLmFzaW4odmFsdWVzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmRhcnJheV8xLk5EQXJyYXkubWFrZShuZGFycmF5LnNoYXBlLCB7IHZhbHVlczogcmVzdWx0VmFsdWVzIH0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhDUFUucHJvdG90eXBlLmFjb3NJbnRlcm5hbCA9IGZ1bmN0aW9uIChuZGFycmF5KSB7XG4gICAgICAgIHZhciByZXN1bHRWYWx1ZXMgPSBuZXcgRmxvYXQzMkFycmF5KG5kYXJyYXkuc2l6ZSk7XG4gICAgICAgIHZhciB2YWx1ZXMgPSBuZGFycmF5LmdldFZhbHVlcygpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgcmVzdWx0VmFsdWVzW2ldID0gTWF0aC5hY29zKHZhbHVlc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5kYXJyYXlfMS5OREFycmF5Lm1ha2UobmRhcnJheS5zaGFwZSwgeyB2YWx1ZXM6IHJlc3VsdFZhbHVlcyB9KTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoQ1BVLnByb3RvdHlwZS5hdGFuSW50ZXJuYWwgPSBmdW5jdGlvbiAobmRhcnJheSkge1xuICAgICAgICB2YXIgcmVzdWx0VmFsdWVzID0gbmV3IEZsb2F0MzJBcnJheShuZGFycmF5LnNpemUpO1xuICAgICAgICB2YXIgdmFsdWVzID0gbmRhcnJheS5nZXRWYWx1ZXMoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHJlc3VsdFZhbHVlc1tpXSA9IE1hdGguYXRhbih2YWx1ZXNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZGFycmF5XzEuTkRBcnJheS5tYWtlKG5kYXJyYXkuc2hhcGUsIHsgdmFsdWVzOiByZXN1bHRWYWx1ZXMgfSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aENQVS5wcm90b3R5cGUuc2luaEludGVybmFsID0gZnVuY3Rpb24gKG5kYXJyYXkpIHtcbiAgICAgICAgdmFyIHJlc3VsdFZhbHVlcyA9IG5ldyBGbG9hdDMyQXJyYXkobmRhcnJheS5zaXplKTtcbiAgICAgICAgdmFyIHZhbHVlcyA9IG5kYXJyYXkuZ2V0VmFsdWVzKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICByZXN1bHRWYWx1ZXNbaV0gPSBNYXRoLnNpbmgodmFsdWVzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmRhcnJheV8xLk5EQXJyYXkubWFrZShuZGFycmF5LnNoYXBlLCB7IHZhbHVlczogcmVzdWx0VmFsdWVzIH0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhDUFUucHJvdG90eXBlLmNvc2hJbnRlcm5hbCA9IGZ1bmN0aW9uIChuZGFycmF5KSB7XG4gICAgICAgIHZhciByZXN1bHRWYWx1ZXMgPSBuZXcgRmxvYXQzMkFycmF5KG5kYXJyYXkuc2l6ZSk7XG4gICAgICAgIHZhciB2YWx1ZXMgPSBuZGFycmF5LmdldFZhbHVlcygpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgcmVzdWx0VmFsdWVzW2ldID0gTWF0aC5jb3NoKHZhbHVlc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5kYXJyYXlfMS5OREFycmF5Lm1ha2UobmRhcnJheS5zaGFwZSwgeyB2YWx1ZXM6IHJlc3VsdFZhbHVlcyB9KTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoQ1BVLnByb3RvdHlwZS50YW5oSW50ZXJuYWwgPSBmdW5jdGlvbiAobmRhcnJheSkge1xuICAgICAgICB2YXIgcmVzdWx0VmFsdWVzID0gbmV3IEZsb2F0MzJBcnJheShuZGFycmF5LnNpemUpO1xuICAgICAgICB2YXIgdmFsdWVzID0gbmRhcnJheS5nZXRWYWx1ZXMoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHJlc3VsdFZhbHVlc1tpXSA9IHV0aWwudGFuaCh2YWx1ZXNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZGFycmF5XzEuTkRBcnJheS5tYWtlKG5kYXJyYXkuc2hhcGUsIHsgdmFsdWVzOiByZXN1bHRWYWx1ZXMgfSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aENQVS5wcm90b3R5cGUuc3RlcEludGVybmFsID0gZnVuY3Rpb24gKG5kYXJyYXksIGFscGhhKSB7XG4gICAgICAgIGlmIChhbHBoYSA9PT0gdm9pZCAwKSB7IGFscGhhID0gMDsgfVxuICAgICAgICB2YXIgcmVzdWx0VmFsdWVzID0gbmV3IEZsb2F0MzJBcnJheShuZGFycmF5LnNpemUpO1xuICAgICAgICB2YXIgdmFsdWVzID0gbmRhcnJheS5nZXRWYWx1ZXMoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHZhbHVlc1tpXTtcbiAgICAgICAgICAgIHJlc3VsdFZhbHVlc1tpXSA9IHZhbHVlID4gMCA/IDEgOiAodmFsdWUgPCAwID8gYWxwaGEgOiB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5kYXJyYXlfMS5OREFycmF5Lm1ha2UobmRhcnJheS5zaGFwZSwgeyB2YWx1ZXM6IHJlc3VsdFZhbHVlcyB9KTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoQ1BVLnByb3RvdHlwZS5jb252MmRJbnRlcm5hbCA9IGZ1bmN0aW9uICh4LCBmaWx0ZXIsIGJpYXMsIGNvbnZJbmZvKSB7XG4gICAgICAgIHZhciBfYSA9IHguc2hhcGUsIHhSb3dzID0gX2FbMF0sIHhDb2xzID0gX2FbMV0sIGlucHV0RGVwdGggPSBfYVsyXTtcbiAgICAgICAgdmFyIGZpbHRlckhlaWdodCA9IGZpbHRlci5zaGFwZVswXTtcbiAgICAgICAgdmFyIGZpbHRlcldpZHRoID0gZmlsdGVyLnNoYXBlWzFdO1xuICAgICAgICB2YXIgb3V0RGVwdGggPSBmaWx0ZXIuc2hhcGVbM107XG4gICAgICAgIHZhciBwYWRMZWZ0ID0gY29udkluZm8ucGFkSW5mby5sZWZ0O1xuICAgICAgICB2YXIgcGFkVG9wID0gY29udkluZm8ucGFkSW5mby50b3A7XG4gICAgICAgIHZhciB5ID0gbmRhcnJheV8xLkFycmF5M0QuemVyb3MoY29udkluZm8ub3V0U2hhcGUpO1xuICAgICAgICBmb3IgKHZhciBkMiA9IDA7IGQyIDwgb3V0RGVwdGg7ICsrZDIpIHtcbiAgICAgICAgICAgIGZvciAodmFyIHlSID0gMDsgeVIgPCB5LnNoYXBlWzBdOyArK3lSKSB7XG4gICAgICAgICAgICAgICAgdmFyIHhSQ29ybmVyID0geVIgKiBjb252SW5mby5zdHJpZGVIZWlnaHQgLSBwYWRMZWZ0O1xuICAgICAgICAgICAgICAgIHZhciB4Uk1pbiA9IE1hdGgubWF4KDAsIHhSQ29ybmVyKTtcbiAgICAgICAgICAgICAgICB2YXIgeFJNYXggPSBNYXRoLm1pbih4Um93cywgZmlsdGVySGVpZ2h0ICsgeFJDb3JuZXIpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIHlDID0gMDsgeUMgPCB5LnNoYXBlWzFdOyArK3lDKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB4Q0Nvcm5lciA9IHlDICogY29udkluZm8uc3RyaWRlV2lkdGggLSBwYWRUb3A7XG4gICAgICAgICAgICAgICAgICAgIHZhciB4Q01pbiA9IE1hdGgubWF4KDAsIHhDQ29ybmVyKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHhDTWF4ID0gTWF0aC5taW4oeENvbHMsIGZpbHRlcldpZHRoICsgeENDb3JuZXIpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZG90UHJvZCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHhSID0geFJNaW47IHhSIDwgeFJNYXg7ICsreFIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB3UiA9IHhSIC0geFJDb3JuZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB4QyA9IHhDTWluOyB4QyA8IHhDTWF4OyArK3hDKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHdDID0geEMgLSB4Q0Nvcm5lcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBkMSA9IDA7IGQxIDwgaW5wdXREZXB0aDsgKytkMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGl4ZWwgPSB4LmdldCh4UiwgeEMsIGQxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHdlaWdodCA9IGZpbHRlci5nZXQod1IsIHdDLCBkMSwgZDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb3RQcm9kICs9IHBpeGVsICogd2VpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgYmlhc1ZhbCA9IChiaWFzICE9IG51bGwpID8gYmlhcy5nZXQoZDIpIDogMDtcbiAgICAgICAgICAgICAgICAgICAgeS5zZXQoZG90UHJvZCArIGJpYXNWYWwsIHlSLCB5QywgZDIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoQ1BVLnByb3RvdHlwZS5jb252MmREZXJJbnB1dEludGVybmFsID0gZnVuY3Rpb24gKGR5LCBmaWx0ZXIsIGNvbnZJbmZvKSB7XG4gICAgICAgIHZhciBpbkRlcHRoID0gZmlsdGVyLnNoYXBlWzJdO1xuICAgICAgICB2YXIgb3V0RGVwdGggPSBmaWx0ZXIuc2hhcGVbM107XG4gICAgICAgIHZhciB5Um93cyA9IGR5LnNoYXBlWzBdO1xuICAgICAgICB2YXIgeUNvbHMgPSBkeS5zaGFwZVsxXTtcbiAgICAgICAgdmFyIGZpbHRlckhlaWdodCA9IGZpbHRlci5zaGFwZVswXTtcbiAgICAgICAgdmFyIGZpbHRlcldpZHRoID0gZmlsdGVyLnNoYXBlWzFdO1xuICAgICAgICB2YXIgdG9wUGFkID0gZmlsdGVySGVpZ2h0IC0gMSAtIGNvbnZJbmZvLnBhZEluZm8udG9wO1xuICAgICAgICB2YXIgbGVmdFBhZCA9IGZpbHRlcldpZHRoIC0gMSAtIGNvbnZJbmZvLnBhZEluZm8ubGVmdDtcbiAgICAgICAgdmFyIHN0cmlkZUhlaWdodCA9IGNvbnZJbmZvLnN0cmlkZUhlaWdodDtcbiAgICAgICAgdmFyIHN0cmlkZVdpZHRoID0gY29udkluZm8uc3RyaWRlV2lkdGg7XG4gICAgICAgIHZhciBkeCA9IG5kYXJyYXlfMS5BcnJheTNELnplcm9zKGNvbnZJbmZvLmluU2hhcGUpO1xuICAgICAgICBmb3IgKHZhciBkMSA9IDA7IGQxIDwgaW5EZXB0aDsgKytkMSkge1xuICAgICAgICAgICAgZm9yICh2YXIgeFIgPSAwOyB4UiA8IGR4LnNoYXBlWzBdOyArK3hSKSB7XG4gICAgICAgICAgICAgICAgdmFyIHhSQ29ybmVyID0geFIgLSBsZWZ0UGFkO1xuICAgICAgICAgICAgICAgIHZhciB4Uk1pbiA9IE1hdGgubWF4KDAsIE1hdGguY2VpbCh4UkNvcm5lciAvIHN0cmlkZUhlaWdodCkpO1xuICAgICAgICAgICAgICAgIHZhciB5Uk1heCA9IE1hdGgubWluKHlSb3dzLCAoZmlsdGVySGVpZ2h0ICsgeFJDb3JuZXIpIC8gc3RyaWRlSGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciB4QyA9IDA7IHhDIDwgZHguc2hhcGVbMV07ICsreEMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHhDQ29ybmVyID0geEMgLSB0b3BQYWQ7XG4gICAgICAgICAgICAgICAgICAgIHZhciB4Q01pbiA9IE1hdGgubWF4KDAsIE1hdGguY2VpbCh4Q0Nvcm5lciAvIHN0cmlkZVdpZHRoKSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciB5Q01heCA9IE1hdGgubWluKHlDb2xzLCAoZmlsdGVyV2lkdGggKyB4Q0Nvcm5lcikgLyBzdHJpZGVXaWR0aCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkb3RQcm9kID0gMDtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgeVIgPSB4Uk1pbjsgeVIgPCB5Uk1heDsgKyt5Uikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHdSID0geVIgKiBzdHJpZGVIZWlnaHQgLSB4UkNvcm5lcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHlDID0geENNaW47IHlDIDwgeUNNYXg7ICsreUMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgd0MgPSB5QyAqIHN0cmlkZVdpZHRoIC0geENDb3JuZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgZDIgPSAwOyBkMiA8IG91dERlcHRoOyArK2QyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwaXhlbCA9IGR5LmdldCh5UiwgeUMsIGQyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHdlaWdodCA9IGZpbHRlci5nZXQoZmlsdGVySGVpZ2h0IC0gMSAtIHdSLCBmaWx0ZXJXaWR0aCAtIDEgLSB3QywgZDEsIGQyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG90UHJvZCArPSBwaXhlbCAqIHdlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZHguc2V0KGRvdFByb2QsIHhSLCB4QywgZDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZHg7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aENQVS5wcm90b3R5cGUuY29udjJkRGVyRmlsdGVySW50ZXJuYWwgPSBmdW5jdGlvbiAoeCwgZFksIGNvbnZJbmZvKSB7XG4gICAgICAgIHZhciBpbnB1dERlcHRoID0geC5zaGFwZVsyXTtcbiAgICAgICAgdmFyIG91dHB1dERlcHRoID0gZFkuc2hhcGVbMl07XG4gICAgICAgIHZhciBzdHJpZGVIZWlnaHQgPSBjb252SW5mby5zdHJpZGVIZWlnaHQ7XG4gICAgICAgIHZhciBzdHJpZGVXaWR0aCA9IGNvbnZJbmZvLnN0cmlkZVdpZHRoO1xuICAgICAgICB2YXIgZmlsdGVySGVpZ2h0ID0gY29udkluZm8uZmlsdGVySGVpZ2h0O1xuICAgICAgICB2YXIgZmlsdGVyV2lkdGggPSBjb252SW5mby5maWx0ZXJXaWR0aDtcbiAgICAgICAgdmFyIHdlaWdodHNTaGFwZSA9IGNvbnZfdXRpbC5jb21wdXRlV2VpZ2h0c1NoYXBlNEQoaW5wdXREZXB0aCwgb3V0cHV0RGVwdGgsIGZpbHRlckhlaWdodCwgZmlsdGVyV2lkdGgpO1xuICAgICAgICB2YXIgZFcgPSBuZGFycmF5XzEuQXJyYXk0RC56ZXJvcyh3ZWlnaHRzU2hhcGUpO1xuICAgICAgICB2YXIgeU51bVJvd3MgPSBkWS5zaGFwZVswXTtcbiAgICAgICAgdmFyIHlOdW1Db2xzID0gZFkuc2hhcGVbMV07XG4gICAgICAgIHZhciB4TnVtUm93cyA9IHguc2hhcGVbMF07XG4gICAgICAgIHZhciB4TnVtQ29scyA9IHguc2hhcGVbMV07XG4gICAgICAgIHZhciBsZWZ0UGFkID0gY29udkluZm8ucGFkSW5mby5sZWZ0O1xuICAgICAgICB2YXIgdG9wUGFkID0gY29udkluZm8ucGFkSW5mby50b3A7XG4gICAgICAgIGZvciAodmFyIHdSID0gMDsgd1IgPCBmaWx0ZXJIZWlnaHQ7ICsrd1IpIHtcbiAgICAgICAgICAgIHZhciB5Uk1pbiA9IE1hdGgubWF4KDAsIE1hdGguY2VpbCgodG9wUGFkIC0gd1IpIC8gc3RyaWRlSGVpZ2h0KSk7XG4gICAgICAgICAgICB2YXIgeVJNYXggPSBNYXRoLm1pbih5TnVtUm93cywgKHhOdW1Sb3dzICsgdG9wUGFkIC0gd1IpIC8gc3RyaWRlSGVpZ2h0KTtcbiAgICAgICAgICAgIGZvciAodmFyIHdDID0gMDsgd0MgPCBmaWx0ZXJXaWR0aDsgKyt3Qykge1xuICAgICAgICAgICAgICAgIHZhciB5Q01pbiA9IE1hdGgubWF4KDAsIE1hdGguY2VpbCgobGVmdFBhZCAtIHdDKSAvIHN0cmlkZVdpZHRoKSk7XG4gICAgICAgICAgICAgICAgdmFyIHlDTWF4ID0gTWF0aC5taW4oeU51bUNvbHMsICh4TnVtQ29scyArIGxlZnRQYWQgLSB3QykgLyBzdHJpZGVXaWR0aCk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgZDEgPSAwOyBkMSA8IGlucHV0RGVwdGg7ICsrZDEpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgZDIgPSAwOyBkMiA8IG91dHB1dERlcHRoOyArK2QyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZG90UHJvZCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB5UiA9IHlSTWluOyB5UiA8IHlSTWF4OyArK3lSKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHhSID0gd1IgKyB5UiAqIHN0cmlkZUhlaWdodCAtIHRvcFBhZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB5QyA9IHlDTWluOyB5QyA8IHlDTWF4OyArK3lDKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB4QyA9IHdDICsgeUMgKiBzdHJpZGVXaWR0aCAtIGxlZnRQYWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvdFByb2QgKz0geC5nZXQoeFIsIHhDLCBkMSkgKiBkWS5nZXQoeVIsIHlDLCBkMik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZFcuc2V0KGRvdFByb2QsIHdSLCB3QywgZDEsIGQyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZFc7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aENQVS5wcm90b3R5cGUuY29udjJkRGVyQmlhc0ludGVybmFsID0gZnVuY3Rpb24gKGRZKSB7XG4gICAgICAgIHZhciBvdXRwdXREZXB0aCA9IGRZLnNoYXBlWzJdO1xuICAgICAgICB2YXIgbnVtUm93cyA9IGRZLnNoYXBlWzBdO1xuICAgICAgICB2YXIgbnVtQ29scyA9IGRZLnNoYXBlWzFdO1xuICAgICAgICB2YXIgdmFsdWVzID0gbmV3IEZsb2F0MzJBcnJheShvdXRwdXREZXB0aCk7XG4gICAgICAgIGZvciAodmFyIGQyID0gMDsgZDIgPCBvdXRwdXREZXB0aDsgKytkMikge1xuICAgICAgICAgICAgdmFyIHN1bSA9IDA7XG4gICAgICAgICAgICBmb3IgKHZhciByID0gMDsgciA8IG51bVJvd3M7ICsrcikge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGMgPSAwOyBjIDwgbnVtQ29sczsgKytjKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1bSArPSBkWS5nZXQociwgYywgZDIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhbHVlc1tkMl0gPSBzdW07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5kYXJyYXlfMS5BcnJheTFELm5ldyh2YWx1ZXMpO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhDUFUucHJvdG90eXBlLmRlcHRod2lzZUNvbnYyREludGVybmFsID0gZnVuY3Rpb24gKGlucHV0LCBmaWx0ZXIsIGNvbnZJbmZvKSB7XG4gICAgICAgIHZhciBfYSA9IGNvbnZJbmZvLmluU2hhcGUsIG51bUJhdGNoZXMgPSBfYVswXSwgeFJvd3MgPSBfYVsxXSwgeENvbHMgPSBfYVsyXSwgaW5DaGFubmVscyA9IF9hWzNdO1xuICAgICAgICB2YXIgZmlsdGVySGVpZ2h0ID0gY29udkluZm8uZmlsdGVySGVpZ2h0O1xuICAgICAgICB2YXIgZmlsdGVyV2lkdGggPSBjb252SW5mby5maWx0ZXJXaWR0aDtcbiAgICAgICAgdmFyIHBhZExlZnQgPSBjb252SW5mby5wYWRJbmZvLmxlZnQ7XG4gICAgICAgIHZhciBwYWRUb3AgPSBjb252SW5mby5wYWRJbmZvLnRvcDtcbiAgICAgICAgdmFyIHlSb3dzID0gY29udkluZm8ub3V0U2hhcGVbMV07XG4gICAgICAgIHZhciB5Q29scyA9IGNvbnZJbmZvLm91dFNoYXBlWzJdO1xuICAgICAgICB2YXIgY2hNdWwgPSBjb252SW5mby5jaGFubmVsTXVsO1xuICAgICAgICB2YXIgeSA9IG5kYXJyYXlfMS5BcnJheTRELnplcm9zKGNvbnZJbmZvLm91dFNoYXBlKTtcbiAgICAgICAgZm9yICh2YXIgYiA9IDA7IGIgPCBudW1CYXRjaGVzOyArK2IpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGQxID0gMDsgZDEgPCBpbkNoYW5uZWxzOyArK2QxKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgeVIgPSAwOyB5UiA8IHlSb3dzOyArK3lSKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB4UkNvcm5lciA9IHlSICogY29udkluZm8uc3RyaWRlSGVpZ2h0IC0gcGFkTGVmdDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHhSTWluID0gTWF0aC5tYXgoMCwgeFJDb3JuZXIpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgeFJNYXggPSBNYXRoLm1pbih4Um93cywgZmlsdGVySGVpZ2h0ICsgeFJDb3JuZXIpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB5QyA9IDA7IHlDIDwgeUNvbHM7ICsreUMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB4Q0Nvcm5lciA9IHlDICogY29udkluZm8uc3RyaWRlV2lkdGggLSBwYWRUb3A7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgeENNaW4gPSBNYXRoLm1heCgwLCB4Q0Nvcm5lcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgeENNYXggPSBNYXRoLm1pbih4Q29scywgZmlsdGVyV2lkdGggKyB4Q0Nvcm5lcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBxID0gMDsgcSA8IGNoTXVsOyArK3EpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZG90UHJvZCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgeFIgPSB4Uk1pbjsgeFIgPCB4Uk1heDsgKyt4Uikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgd1IgPSB4UiAtIHhSQ29ybmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB4QyA9IHhDTWluOyB4QyA8IHhDTWF4OyArK3hDKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgd0MgPSB4QyAtIHhDQ29ybmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBpeGVsID0gaW5wdXQuZ2V0KGIsIHhSLCB4QywgZDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHdlaWdodCA9IGZpbHRlci5nZXQod1IsIHdDLCBkMSwgcSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb3RQcm9kICs9IHBpeGVsICogd2VpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkuc2V0KGRvdFByb2QsIGIsIHlSLCB5QywgZDEgKiBjaE11bCArIHEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB5O1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhDUFUucHJvdG90eXBlLnRpbGVJbnRlcm5hbCA9IGZ1bmN0aW9uIChhLCByZXBzKSB7XG4gICAgICAgIHZhciBuZXdTaGFwZSA9IG5ldyBBcnJheShhLnJhbmspO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5ld1NoYXBlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBuZXdTaGFwZVtpXSA9IGEuc2hhcGVbaV0gKiByZXBzW2ldO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkdHlwZTtcbiAgICAgICAgaWYgKGEuZHR5cGUgPT09ICdmbG9hdDMyJykge1xuICAgICAgICAgICAgZHR5cGUgPSBGbG9hdDMyQXJyYXk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYS5kdHlwZSA9PT0gJ2ludDMyJykge1xuICAgICAgICAgICAgZHR5cGUgPSBJbnQzMkFycmF5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGEuZHR5cGUgPT09ICdib29sJykge1xuICAgICAgICAgICAgZHR5cGUgPSBVaW50OEFycmF5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRHR5cGUgXCIgKyBhLmR0eXBlICsgXCIgbm90IHN1cHBvcnRlZCBmb3IgdGlsZVwiKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzdWx0VmFsdWVzID0gbmV3IGR0eXBlKHV0aWwuc2l6ZUZyb21TaGFwZShuZXdTaGFwZSkpO1xuICAgICAgICB2YXIgcmVzdWx0ID0gbmRhcnJheV8xLk5EQXJyYXkubWFrZShuZXdTaGFwZSwgeyB2YWx1ZXM6IHJlc3VsdFZhbHVlcyB9LCBhLmR0eXBlKTtcbiAgICAgICAgdmFyIHZhbHVlcyA9IGEuZ2V0VmFsdWVzKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVzdWx0LnNpemU7ICsraSkge1xuICAgICAgICAgICAgdmFyIG5ld0xvYyA9IHJlc3VsdC5pbmRleFRvTG9jKGkpO1xuICAgICAgICAgICAgdmFyIG9yaWdpbmFsTG9jID0gbmV3IEFycmF5KGEucmFuayk7XG4gICAgICAgICAgICBmb3IgKHZhciBpXzEgPSAwOyBpXzEgPCBvcmlnaW5hbExvYy5sZW5ndGg7IGlfMSsrKSB7XG4gICAgICAgICAgICAgICAgb3JpZ2luYWxMb2NbaV8xXSA9IG5ld0xvY1tpXzFdICUgYS5zaGFwZVtpXzFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG9yaWdpbmFsSW5kZXggPSBhLmxvY1RvSW5kZXgob3JpZ2luYWxMb2MpO1xuICAgICAgICAgICAgcmVzdWx0VmFsdWVzW2ldID0gdmFsdWVzW29yaWdpbmFsSW5kZXhdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aENQVS5wcm90b3R5cGUudHJhbnNwb3NlSW50ZXJuYWwgPSBmdW5jdGlvbiAoYSwgcGVybSkge1xuICAgICAgICB2YXIgbmV3U2hhcGUgPSBuZXcgQXJyYXkoYS5yYW5rKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZXdTaGFwZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbmV3U2hhcGVbaV0gPSBhLnNoYXBlW3Blcm1baV1dO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXN1bHRWYWx1ZXMgPSBuZXcgRmxvYXQzMkFycmF5KGEuc2l6ZSk7XG4gICAgICAgIHZhciB2YWx1ZXMgPSBhLmdldFZhbHVlcygpO1xuICAgICAgICB2YXIgcmVzdWx0ID0gbmRhcnJheV8xLk5EQXJyYXkubWFrZShuZXdTaGFwZSwgeyB2YWx1ZXM6IHJlc3VsdFZhbHVlcyB9KTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhLnNpemU7ICsraSkge1xuICAgICAgICAgICAgdmFyIGxvYyA9IGEuaW5kZXhUb0xvYyhpKTtcbiAgICAgICAgICAgIHZhciBuZXdMb2MgPSBuZXcgQXJyYXkobG9jLmxlbmd0aCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpXzIgPSAwOyBpXzIgPCBuZXdMb2MubGVuZ3RoOyBpXzIrKykge1xuICAgICAgICAgICAgICAgIG5ld0xvY1tpXzJdID0gbG9jW3Blcm1baV8yXV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbmV3SW5kZXggPSByZXN1bHQubG9jVG9JbmRleChuZXdMb2MpO1xuICAgICAgICAgICAgcmVzdWx0VmFsdWVzW25ld0luZGV4XSA9IHZhbHVlc1tpXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhDUFUucHJvdG90eXBlLnBvb2wgPSBmdW5jdGlvbiAoeCwgY29udkluZm8sIHBvb2xUeXBlKSB7XG4gICAgICAgIHZhciBfYSA9IHguc2hhcGUsIHhSb3dzID0gX2FbMF0sIHhDb2xzID0gX2FbMV0sIGRlcHRoID0gX2FbMl07XG4gICAgICAgIHZhciBzdHJpZGVIZWlnaHQgPSBjb252SW5mby5zdHJpZGVIZWlnaHQ7XG4gICAgICAgIHZhciBzdHJpZGVXaWR0aCA9IGNvbnZJbmZvLnN0cmlkZVdpZHRoO1xuICAgICAgICB2YXIgZmlsdGVySGVpZ2h0ID0gY29udkluZm8uZmlsdGVySGVpZ2h0O1xuICAgICAgICB2YXIgZmlsdGVyV2lkdGggPSBjb252SW5mby5maWx0ZXJXaWR0aDtcbiAgICAgICAgdmFyIHkgPSBuZGFycmF5XzEuQXJyYXkzRC56ZXJvcyhjb252SW5mby5vdXRTaGFwZSk7XG4gICAgICAgIHZhciBwYWRUb3AgPSBjb252SW5mby5wYWRJbmZvLnRvcDtcbiAgICAgICAgdmFyIHBhZExlZnQgPSBjb252SW5mby5wYWRJbmZvLmxlZnQ7XG4gICAgICAgIGZvciAodmFyIGQgPSAwOyBkIDwgZGVwdGg7ICsrZCkge1xuICAgICAgICAgICAgZm9yICh2YXIgeVIgPSAwOyB5UiA8IHkuc2hhcGVbMF07ICsreVIpIHtcbiAgICAgICAgICAgICAgICB2YXIgeFJDb3JuZXIgPSB5UiAqIHN0cmlkZUhlaWdodCAtIHBhZFRvcDtcbiAgICAgICAgICAgICAgICB2YXIgeFJNaW4gPSBNYXRoLm1heCgwLCB4UkNvcm5lcik7XG4gICAgICAgICAgICAgICAgdmFyIHhSTWF4ID0gTWF0aC5taW4oeFJvd3MsIGZpbHRlckhlaWdodCArIHhSQ29ybmVyKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciB5QyA9IDA7IHlDIDwgeS5zaGFwZVsxXTsgKyt5Qykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgeENDb3JuZXIgPSB5QyAqIHN0cmlkZVdpZHRoIC0gcGFkTGVmdDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHhDTWluID0gTWF0aC5tYXgoMCwgeENDb3JuZXIpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgeENNYXggPSBNYXRoLm1pbih4Q29scywgZmlsdGVyV2lkdGggKyB4Q0Nvcm5lcik7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtaW5NYXhWYWx1ZSA9IChwb29sVHlwZSA9PT0gJ21heCcgPyBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGF2Z1ZhbHVlID0gMDtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgeFIgPSB4Uk1pbjsgeFIgPCB4Uk1heDsgKyt4Uikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgeEMgPSB4Q01pbjsgeEMgPCB4Q01heDsgKyt4Qykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwaXhlbCA9IHguZ2V0KHhSLCB4QywgZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzTmFOKHBpeGVsKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW5NYXhWYWx1ZSA9IE5hTjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXZnVmFsdWUgPSBOYU47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHBvb2xUeXBlID09PSAnbWF4JyAmJiBwaXhlbCA+IG1pbk1heFZhbHVlKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAocG9vbFR5cGUgPT09ICdtaW4nICYmIHBpeGVsIDwgbWluTWF4VmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbk1heFZhbHVlID0gcGl4ZWw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBvb2xUeXBlID09PSAnYXZnJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdmdWYWx1ZSArPSBwaXhlbCAvIChmaWx0ZXJIZWlnaHQgKiBmaWx0ZXJXaWR0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzTmFOKG1pbk1heFZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHkuc2V0KHBvb2xUeXBlID09PSAnYXZnJyA/IGF2Z1ZhbHVlIDogbWluTWF4VmFsdWUsIHlSLCB5QywgZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB5O1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhDUFUucHJvdG90eXBlLm1heFBvb2xJbnRlcm5hbCA9IGZ1bmN0aW9uICh4LCBjb252SW5mbykge1xuICAgICAgICByZXR1cm4gdGhpcy5wb29sKHgsIGNvbnZJbmZvLCAnbWF4Jyk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aENQVS5wcm90b3R5cGUubWF4UG9vbFBvc2l0aW9ucyA9IGZ1bmN0aW9uICh4LCBjb252SW5mbykge1xuICAgICAgICB2YXIgX2EgPSB4LnNoYXBlLCB4Um93cyA9IF9hWzBdLCB4Q29scyA9IF9hWzFdLCBkZXB0aCA9IF9hWzJdO1xuICAgICAgICB2YXIgb3V0cHV0U2hhcGUgPSBjb252SW5mby5vdXRTaGFwZTtcbiAgICAgICAgdmFyIG1heFBvc2l0aW9ucyA9IG5kYXJyYXlfMS5BcnJheTNELnplcm9zKG91dHB1dFNoYXBlKTtcbiAgICAgICAgdmFyIHN0cmlkZUhlaWdodCA9IGNvbnZJbmZvLnN0cmlkZUhlaWdodDtcbiAgICAgICAgdmFyIHN0cmlkZVdpZHRoID0gY29udkluZm8uc3RyaWRlV2lkdGg7XG4gICAgICAgIHZhciBmaWx0ZXJIZWlnaHQgPSBjb252SW5mby5maWx0ZXJIZWlnaHQ7XG4gICAgICAgIHZhciBmaWx0ZXJXaWR0aCA9IGNvbnZJbmZvLmZpbHRlcldpZHRoO1xuICAgICAgICB2YXIgcGFkVG9wID0gY29udkluZm8ucGFkSW5mby50b3A7XG4gICAgICAgIHZhciBwYWRMZWZ0ID0gY29udkluZm8ucGFkSW5mby5sZWZ0O1xuICAgICAgICBmb3IgKHZhciBkID0gMDsgZCA8IGRlcHRoOyArK2QpIHtcbiAgICAgICAgICAgIGZvciAodmFyIHlSID0gMDsgeVIgPCBvdXRwdXRTaGFwZVswXTsgKyt5Uikge1xuICAgICAgICAgICAgICAgIHZhciB4UkNvcm5lciA9IHlSICogc3RyaWRlSGVpZ2h0IC0gcGFkVG9wO1xuICAgICAgICAgICAgICAgIHZhciB4Uk1pbiA9IE1hdGgubWF4KDAsIHhSQ29ybmVyKTtcbiAgICAgICAgICAgICAgICB2YXIgeFJNYXggPSBNYXRoLm1pbih4Um93cywgZmlsdGVySGVpZ2h0ICsgeFJDb3JuZXIpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIHlDID0gMDsgeUMgPCBvdXRwdXRTaGFwZVsxXTsgKyt5Qykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgeENDb3JuZXIgPSB5QyAqIHN0cmlkZVdpZHRoIC0gcGFkTGVmdDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHhDTWluID0gTWF0aC5tYXgoMCwgeENDb3JuZXIpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgeENNYXggPSBNYXRoLm1pbih4Q29scywgZmlsdGVyV2lkdGggKyB4Q0Nvcm5lcik7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtYXhWYWx1ZSA9IE51bWJlci5ORUdBVElWRV9JTkZJTklUWTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1heFBvc2l0aW9uID0gLTE7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHhSID0geFJNaW47IHhSIDwgeFJNYXg7ICsreFIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB3UiA9IHhSIC0geFJDb3JuZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB4QyA9IHhDTWluOyB4QyA8IHhDTWF4OyArK3hDKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHdDID0geEMgLSB4Q0Nvcm5lcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGl4ZWwgPSB4LmdldCh4UiwgeEMsIGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwaXhlbCA+IG1heFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heFZhbHVlID0gcGl4ZWw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heFBvc2l0aW9uID0gd1IgKiBmaWx0ZXJXaWR0aCArIHdDO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBtYXhQb3NpdGlvbnMuc2V0KG1heFBvc2l0aW9uLCB5UiwgeUMsIGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWF4UG9zaXRpb25zO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhDUFUucHJvdG90eXBlLm1heFBvb2xCYWNrcHJvcEludGVybmFsID0gZnVuY3Rpb24gKGR5LCB4LCBjb252SW5mbykge1xuICAgICAgICB2YXIgbWF4UG9zaXRpb25zID0gdGhpcy5tYXhQb29sUG9zaXRpb25zKHgsIGNvbnZJbmZvKTtcbiAgICAgICAgdmFyIHN0cmlkZUhlaWdodCA9IGNvbnZJbmZvLnN0cmlkZUhlaWdodDtcbiAgICAgICAgdmFyIHN0cmlkZVdpZHRoID0gY29udkluZm8uc3RyaWRlV2lkdGg7XG4gICAgICAgIHZhciBmaWx0ZXJIZWlnaHQgPSBjb252SW5mby5maWx0ZXJIZWlnaHQ7XG4gICAgICAgIHZhciBmaWx0ZXJXaWR0aCA9IGNvbnZJbmZvLmZpbHRlcldpZHRoO1xuICAgICAgICB2YXIgcGFkTGVmdCA9IGZpbHRlcldpZHRoIC0gMSAtIGNvbnZJbmZvLnBhZEluZm8ubGVmdDtcbiAgICAgICAgdmFyIHBhZFRvcCA9IGZpbHRlckhlaWdodCAtIDEgLSBjb252SW5mby5wYWRJbmZvLnRvcDtcbiAgICAgICAgdmFyIF9hID0gZHkuc2hhcGUsIGR5Um93cyA9IF9hWzBdLCBkeUNvbHMgPSBfYVsxXSwgZGVwdGggPSBfYVsyXTtcbiAgICAgICAgdmFyIGR4ID0gbmRhcnJheV8xLkFycmF5M0QuemVyb3MoeC5zaGFwZSk7XG4gICAgICAgIGZvciAodmFyIGQgPSAwOyBkIDwgZGVwdGg7ICsrZCkge1xuICAgICAgICAgICAgZm9yICh2YXIgZHhSID0gMDsgZHhSIDwgZHguc2hhcGVbMF07ICsrZHhSKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgZHhDID0gMDsgZHhDIDwgZHguc2hhcGVbMV07ICsrZHhDKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkeVJDb3JuZXIgPSBkeFIgLSBwYWRUb3A7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkeUNDb3JuZXIgPSBkeEMgLSBwYWRMZWZ0O1xuICAgICAgICAgICAgICAgICAgICB2YXIgZG90UHJvZCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHdSID0gMDsgd1IgPCBmaWx0ZXJIZWlnaHQ7ICsrd1IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkeVIgPSAoZHlSQ29ybmVyICsgd1IpIC8gc3RyaWRlSGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGR5UiA8IDAgfHwgZHlSID49IGR5Um93cyB8fCBNYXRoLmZsb29yKGR5UikgIT09IGR5Uikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgd0MgPSAwOyB3QyA8IGZpbHRlcldpZHRoOyArK3dDKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGR5QyA9IChkeUNDb3JuZXIgKyB3QykgLyBzdHJpZGVXaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZHlDIDwgMCB8fCBkeUMgPj0gZHlDb2xzIHx8IE1hdGguZmxvb3IoZHlDKSAhPT0gZHlDKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWF4UG9zID0gZmlsdGVySGVpZ2h0ICogZmlsdGVyV2lkdGggLSAxIC1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF4UG9zaXRpb25zLmdldChkeVIsIGR5QywgZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGN1clBvcyA9IHdSICogZmlsdGVyV2lkdGggKyB3QztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWFzayA9IG1heFBvcyA9PT0gY3VyUG9zID8gMSA6IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hc2sgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwaXhlbCA9IGR5LmdldChkeVIsIGR5QywgZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG90UHJvZCArPSBwaXhlbCAqIG1hc2s7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZHguc2V0KGRvdFByb2QsIGR4UiwgZHhDLCBkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGR4O1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhDUFUucHJvdG90eXBlLm1pblBvb2xJbnRlcm5hbCA9IGZ1bmN0aW9uICh4LCBjb252SW5mbykge1xuICAgICAgICByZXR1cm4gdGhpcy5wb29sKHgsIGNvbnZJbmZvLCAnbWluJyk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aENQVS5wcm90b3R5cGUuYXZnUG9vbEludGVybmFsID0gZnVuY3Rpb24gKHgsIGNvbnZJbmZvKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBvb2woeCwgY29udkluZm8sICdhdmcnKTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoQ1BVLnByb3RvdHlwZS5yZXNpemVCaWxpbmVhcjNESW50ZXJuYWwgPSBmdW5jdGlvbiAoeCwgbmV3U2hhcGUyRCwgYWxpZ25Db3JuZXJzKSB7XG4gICAgICAgIHZhciBvdXRwdXQgPSBuZGFycmF5XzEuQXJyYXkzRC56ZXJvcyhbbmV3U2hhcGUyRFswXSwgbmV3U2hhcGUyRFsxXSwgeC5zaGFwZVsyXV0pO1xuICAgICAgICB2YXIgZWZmZWN0aXZlSW5wdXRTaXplID0gYWxpZ25Db3JuZXJzID8gW3guc2hhcGVbMF0gLSAxLCB4LnNoYXBlWzFdIC0gMSwgeC5zaGFwZVsyXV0gOiB4LnNoYXBlO1xuICAgICAgICB2YXIgZWZmZWN0aXZlT3V0cHV0U2l6ZSA9IGFsaWduQ29ybmVycyA/XG4gICAgICAgICAgICBbb3V0cHV0LnNoYXBlWzBdIC0gMSwgb3V0cHV0LnNoYXBlWzFdIC0gMSwgb3V0cHV0LnNoYXBlWzJdXSA6XG4gICAgICAgICAgICBvdXRwdXQuc2hhcGU7XG4gICAgICAgIGZvciAodmFyIHIgPSAwOyByIDwgb3V0cHV0LnNoYXBlWzBdOyByKyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIGMgPSAwOyBjIDwgb3V0cHV0LnNoYXBlWzFdOyBjKyspIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBkID0gMDsgZCA8IG91dHB1dC5zaGFwZVsyXTsgZCsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzb3VyY2VGcmFjUm93ID0gKGVmZmVjdGl2ZUlucHV0U2l6ZVswXSkgKiByIC8gKGVmZmVjdGl2ZU91dHB1dFNpemVbMF0pO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc291cmNlRnJhY0NvbCA9IChlZmZlY3RpdmVJbnB1dFNpemVbMV0pICogYyAvIChlZmZlY3RpdmVPdXRwdXRTaXplWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNvdXJjZVJvd0Zsb29yID0gTWF0aC5mbG9vcihzb3VyY2VGcmFjUm93KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNvdXJjZVJvd0NlaWwgPSBNYXRoLm1pbih4LnNoYXBlWzBdIC0gMSwgTWF0aC5jZWlsKHNvdXJjZUZyYWNSb3cpKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNvdXJjZUNvbEZsb29yID0gTWF0aC5mbG9vcihzb3VyY2VGcmFjQ29sKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNvdXJjZUNvbENlaWwgPSBNYXRoLm1pbih4LnNoYXBlWzFdIC0gMSwgTWF0aC5jZWlsKHNvdXJjZUZyYWNDb2wpKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRvcExlZnQgPSB4LmdldChzb3VyY2VSb3dGbG9vciwgc291cmNlQ29sRmxvb3IsIGQpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYm90dG9tTGVmdCA9IHguZ2V0KHNvdXJjZVJvd0NlaWwsIHNvdXJjZUNvbEZsb29yLCBkKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRvcFJpZ2h0ID0geC5nZXQoc291cmNlUm93Rmxvb3IsIHNvdXJjZUNvbENlaWwsIGQpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYm90dG9tUmlnaHQgPSB4LmdldChzb3VyY2VSb3dDZWlsLCBzb3VyY2VDb2xDZWlsLCBkKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJvd0ZyYWMgPSBzb3VyY2VGcmFjUm93IC0gc291cmNlUm93Rmxvb3I7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb2xGcmFjID0gc291cmNlRnJhY0NvbCAtIHNvdXJjZUNvbEZsb29yO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdG9wXzEgPSB0b3BMZWZ0ICsgKHRvcFJpZ2h0IC0gdG9wTGVmdCkgKiBjb2xGcmFjO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYm90dG9tID0gYm90dG9tTGVmdCArIChib3R0b21SaWdodCAtIGJvdHRvbUxlZnQpICogY29sRnJhYztcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5ld1ZhbHVlID0gdG9wXzEgKyAoYm90dG9tIC0gdG9wXzEpICogcm93RnJhYztcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnNldChuZXdWYWx1ZSwgciwgYywgZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aENQVS5wcm90b3R5cGUuYmF0Y2hOb3JtYWxpemF0aW9uMkRJbnRlcm5hbCA9IGZ1bmN0aW9uICh4LCBtZWFuLCB2YXJpYW5jZSwgdmFyaWFuY2VFcHNpbG9uLCBzY2FsZSwgb2Zmc2V0KSB7XG4gICAgICAgIHZhciB4VmFsdWVzID0geC5nZXRWYWx1ZXMoKTtcbiAgICAgICAgdmFyIG1lYW5WYWx1ZXMgPSBtZWFuLmdldFZhbHVlcygpO1xuICAgICAgICB2YXIgdmFyaWFuY2VWYWx1ZXMgPSB2YXJpYW5jZS5nZXRWYWx1ZXMoKTtcbiAgICAgICAgdmFyIHNjYWxlVmFsdWVzID0gc2NhbGUgPyBzY2FsZS5nZXRWYWx1ZXMoKSA6IG5ldyBGbG9hdDMyQXJyYXkoWzFdKTtcbiAgICAgICAgdmFyIG9mZnNldFZhbHVlcyA9IG9mZnNldCA/IG9mZnNldC5nZXRWYWx1ZXMoKSA6IG5ldyBGbG9hdDMyQXJyYXkoWzBdKTtcbiAgICAgICAgdmFyIG91dFZhbHVlcyA9IG5ldyBGbG9hdDMyQXJyYXkoeFZhbHVlcy5sZW5ndGgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHhWYWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIG91dFZhbHVlc1tpXSA9IG9mZnNldFZhbHVlc1tpICUgb2Zmc2V0VmFsdWVzLmxlbmd0aF0gK1xuICAgICAgICAgICAgICAgICh4VmFsdWVzW2ldIC0gbWVhblZhbHVlc1tpICUgbWVhblZhbHVlcy5sZW5ndGhdKSAqXG4gICAgICAgICAgICAgICAgICAgIHNjYWxlVmFsdWVzW2kgJSBzY2FsZVZhbHVlcy5sZW5ndGhdIC9cbiAgICAgICAgICAgICAgICAgICAgTWF0aC5zcXJ0KHZhcmlhbmNlVmFsdWVzW2kgJSB2YXJpYW5jZVZhbHVlcy5sZW5ndGhdICsgdmFyaWFuY2VFcHNpbG9uKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmRhcnJheV8xLkFycmF5MkQubmV3KHguc2hhcGUsIG91dFZhbHVlcyk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aENQVS5wcm90b3R5cGUuYmF0Y2hOb3JtYWxpemF0aW9uM0RJbnRlcm5hbCA9IGZ1bmN0aW9uICh4LCBtZWFuLCB2YXJpYW5jZSwgdmFyaWFuY2VFcHNpbG9uLCBzY2FsZSwgb2Zmc2V0KSB7XG4gICAgICAgIHZhciB4VmFsdWVzID0geC5nZXRWYWx1ZXMoKTtcbiAgICAgICAgdmFyIG1lYW5WYWx1ZXMgPSBtZWFuLmdldFZhbHVlcygpO1xuICAgICAgICB2YXIgdmFyaWFuY2VWYWx1ZXMgPSB2YXJpYW5jZS5nZXRWYWx1ZXMoKTtcbiAgICAgICAgdmFyIHNjYWxlVmFsdWVzID0gc2NhbGUgPyBzY2FsZS5nZXRWYWx1ZXMoKSA6IG5ldyBGbG9hdDMyQXJyYXkoWzFdKTtcbiAgICAgICAgdmFyIG9mZnNldFZhbHVlcyA9IG9mZnNldCA/IG9mZnNldC5nZXRWYWx1ZXMoKSA6IG5ldyBGbG9hdDMyQXJyYXkoWzBdKTtcbiAgICAgICAgdmFyIG91dFZhbHVlcyA9IG5ldyBGbG9hdDMyQXJyYXkoeFZhbHVlcy5sZW5ndGgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHhWYWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIG91dFZhbHVlc1tpXSA9IG9mZnNldFZhbHVlc1tpICUgb2Zmc2V0VmFsdWVzLmxlbmd0aF0gK1xuICAgICAgICAgICAgICAgICh4VmFsdWVzW2ldIC0gbWVhblZhbHVlc1tpICUgbWVhblZhbHVlcy5sZW5ndGhdKSAqXG4gICAgICAgICAgICAgICAgICAgIHNjYWxlVmFsdWVzW2kgJSBzY2FsZVZhbHVlcy5sZW5ndGhdIC9cbiAgICAgICAgICAgICAgICAgICAgTWF0aC5zcXJ0KHZhcmlhbmNlVmFsdWVzW2kgJSB2YXJpYW5jZVZhbHVlcy5sZW5ndGhdICsgdmFyaWFuY2VFcHNpbG9uKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmRhcnJheV8xLkFycmF5M0QubmV3KHguc2hhcGUsIG91dFZhbHVlcyk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aENQVS5wcm90b3R5cGUubXVsdGlub21pYWxJbnRlcm5hbCA9IGZ1bmN0aW9uIChwcm9iYWJpbGl0aWVzLCBudW1TYW1wbGVzLCBzZWVkKSB7XG4gICAgICAgIHZhciBiYXRjaFNpemUgPSBwcm9iYWJpbGl0aWVzLnNoYXBlWzBdO1xuICAgICAgICB2YXIgbnVtRXZlbnRzID0gcHJvYmFiaWxpdGllcy5zaGFwZVsxXTtcbiAgICAgICAgdmFyIHJlcyA9IG5kYXJyYXlfMS5BcnJheTJELnplcm9zKFtiYXRjaFNpemUsIG51bVNhbXBsZXNdLCAnaW50MzInKTtcbiAgICAgICAgdmFyIHJlc1ZhbHMgPSByZXMuZ2V0VmFsdWVzKCk7XG4gICAgICAgIHZhciBwcm9iVmFscyA9IHByb2JhYmlsaXRpZXMuZ2V0VmFsdWVzKCk7XG4gICAgICAgIGZvciAodmFyIGIgPSAwOyBiIDwgYmF0Y2hTaXplOyArK2IpIHtcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSBiICogbnVtRXZlbnRzO1xuICAgICAgICAgICAgdmFyIGNkZiA9IG5ldyBGbG9hdDMyQXJyYXkobnVtRXZlbnRzIC0gMSk7XG4gICAgICAgICAgICBjZGZbMF0gPSBwcm9iVmFsc1tvZmZzZXRdO1xuICAgICAgICAgICAgZm9yICh2YXIgZXZlbnRfMSA9IDE7IGV2ZW50XzEgPCBjZGYubGVuZ3RoOyArK2V2ZW50XzEpIHtcbiAgICAgICAgICAgICAgICBjZGZbZXZlbnRfMV0gPSBjZGZbZXZlbnRfMSAtIDFdICsgcHJvYlZhbHNbb2Zmc2V0ICsgZXZlbnRfMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcmFuZG9tID0gc2VlZHJhbmRvbS5hbGVhKHNlZWQudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICB2YXIgb3V0T2Zmc2V0ID0gYiAqIG51bVNhbXBsZXM7XG4gICAgICAgICAgICBmb3IgKHZhciBzYW1wbGVJZCA9IDA7IHNhbXBsZUlkIDwgbnVtU2FtcGxlczsgKytzYW1wbGVJZCkge1xuICAgICAgICAgICAgICAgIHZhciByID0gcmFuZG9tKCk7XG4gICAgICAgICAgICAgICAgcmVzVmFsc1tvdXRPZmZzZXQgKyBzYW1wbGVJZF0gPSBjZGYubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGV2ZW50XzIgPSAwOyBldmVudF8yIDwgY2RmLmxlbmd0aDsgZXZlbnRfMisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyIDwgY2RmW2V2ZW50XzJdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNWYWxzW291dE9mZnNldCArIHNhbXBsZUlkXSA9IGV2ZW50XzI7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhDUFUucHJvdG90eXBlLm9uZUhvdEludGVybmFsID0gZnVuY3Rpb24gKGluZGljZXMsIGRlcHRoLCBvblZhbHVlLCBvZmZWYWx1ZSkge1xuICAgICAgICB2YXIgcmVzID0gbmV3IEZsb2F0MzJBcnJheShpbmRpY2VzLnNpemUgKiBkZXB0aCk7XG4gICAgICAgIHJlcy5maWxsKG9mZlZhbHVlKTtcbiAgICAgICAgZm9yICh2YXIgZXZlbnRfMyA9IDA7IGV2ZW50XzMgPCBpbmRpY2VzLnNpemU7ICsrZXZlbnRfMykge1xuICAgICAgICAgICAgcmVzW2V2ZW50XzMgKiBkZXB0aCArIGluZGljZXMuZ2V0KGV2ZW50XzMpXSA9IG9uVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5kYXJyYXlfMS5BcnJheTJELm5ldyhbaW5kaWNlcy5zaXplLCBkZXB0aF0sIHJlcyk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aENQVS5wcm90b3R5cGUuYnJvYWRjYXN0ZWRCaW5hcnlPcCA9IGZ1bmN0aW9uIChhLCBiLCBkdHlwZSwgb3ApIHtcbiAgICAgICAgdmFyIG5ld1NoYXBlID0gYnJvYWRjYXN0X3V0aWwuYXNzZXJ0QW5kR2V0QnJvYWRjYXN0U2hhcGUoYS5zaGFwZSwgYi5zaGFwZSk7XG4gICAgICAgIHZhciByZXN1bHQgPSBuZGFycmF5XzEuTkRBcnJheS56ZXJvcyhuZXdTaGFwZSwgZHR5cGUpO1xuICAgICAgICB2YXIgbmV3VmFsdWVzID0gcmVzdWx0LmdldFZhbHVlcygpO1xuICAgICAgICB2YXIgYVZhbHVlcyA9IGEuZ2V0VmFsdWVzKCk7XG4gICAgICAgIHZhciBiVmFsdWVzID0gYi5nZXRWYWx1ZXMoKTtcbiAgICAgICAgdmFyIGFCcm9hZGNhc3REaW1zID0gYnJvYWRjYXN0X3V0aWwuZ2V0QnJvYWRjYXN0RGltcyhhLnNoYXBlLCBuZXdTaGFwZSk7XG4gICAgICAgIHZhciBiQnJvYWRjYXN0RGltcyA9IGJyb2FkY2FzdF91dGlsLmdldEJyb2FkY2FzdERpbXMoYi5zaGFwZSwgbmV3U2hhcGUpO1xuICAgICAgICB2YXIgX2xvb3BfMSA9IGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICB2YXIgbG9jID0gcmVzdWx0LmluZGV4VG9Mb2MoaSk7XG4gICAgICAgICAgICB2YXIgYUxvYyA9IGxvYy5zbGljZSgtYS5yYW5rKTtcbiAgICAgICAgICAgIGFCcm9hZGNhc3REaW1zLmZvckVhY2goZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGFMb2NbZF0gPSAwOyB9KTtcbiAgICAgICAgICAgIHZhciBhSW5kZXggPSBhLmxvY1RvSW5kZXgoYUxvYyk7XG4gICAgICAgICAgICB2YXIgYkxvYyA9IGxvYy5zbGljZSgtYi5yYW5rKTtcbiAgICAgICAgICAgIGJCcm9hZGNhc3REaW1zLmZvckVhY2goZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGJMb2NbZF0gPSAwOyB9KTtcbiAgICAgICAgICAgIHZhciBiSW5kZXggPSBiLmxvY1RvSW5kZXgoYkxvYyk7XG4gICAgICAgICAgICBuZXdWYWx1ZXNbaV0gPSBvcChhVmFsdWVzW2FJbmRleF0sIGJWYWx1ZXNbYkluZGV4XSk7XG4gICAgICAgIH07XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmV3VmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBfbG9vcF8xKGkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICByZXR1cm4gTkRBcnJheU1hdGhDUFU7XG59KG1hdGhfMS5OREFycmF5TWF0aCkpO1xuZXhwb3J0cy5OREFycmF5TWF0aENQVSA9IE5EQXJyYXlNYXRoQ1BVO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWF0aF9jcHUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG52YXIgYXhpc191dGlsID0gcmVxdWlyZShcIi4vYXhpc191dGlsXCIpO1xudmFyIG1hdGhfMSA9IHJlcXVpcmUoXCIuL21hdGhcIik7XG52YXIgbmRhcnJheSA9IHJlcXVpcmUoXCIuL25kYXJyYXlcIik7XG52YXIgbmRhcnJheV8xID0gcmVxdWlyZShcIi4vbmRhcnJheVwiKTtcbnZhciByZWR1Y2VfdXRpbCA9IHJlcXVpcmUoXCIuL3JlZHVjZV91dGlsXCIpO1xudmFyIGFkZHNjYWxlZG1hdF9ncHVfMSA9IHJlcXVpcmUoXCIuL3dlYmdsL2FkZHNjYWxlZG1hdF9ncHVcIik7XG52YXIgYXJnbWlubWF4X2dwdV8xID0gcmVxdWlyZShcIi4vd2ViZ2wvYXJnbWlubWF4X2dwdVwiKTtcbnZhciBiYXRjaG5vcm1fZ3B1XzEgPSByZXF1aXJlKFwiLi93ZWJnbC9iYXRjaG5vcm1fZ3B1XCIpO1xudmFyIGJpbmFyeW9wX2dwdSA9IHJlcXVpcmUoXCIuL3dlYmdsL2JpbmFyeW9wX2dwdVwiKTtcbnZhciBiaW5hcnlvcF9ncHVfMSA9IHJlcXVpcmUoXCIuL3dlYmdsL2JpbmFyeW9wX2dwdVwiKTtcbnZhciBjbGlwX2dwdV8xID0gcmVxdWlyZShcIi4vd2ViZ2wvY2xpcF9ncHVcIik7XG52YXIgY29uY2F0X2dwdV8xID0gcmVxdWlyZShcIi4vd2ViZ2wvY29uY2F0X2dwdVwiKTtcbnZhciBjb252X2JhY2twcm9wX2dwdV8xID0gcmVxdWlyZShcIi4vd2ViZ2wvY29udl9iYWNrcHJvcF9ncHVcIik7XG52YXIgY29udl9ncHVfMSA9IHJlcXVpcmUoXCIuL3dlYmdsL2NvbnZfZ3B1XCIpO1xudmFyIGNvbnZfZ3B1X2RlcHRod2lzZV8xID0gcmVxdWlyZShcIi4vd2ViZ2wvY29udl9ncHVfZGVwdGh3aXNlXCIpO1xudmFyIGNvcHlfZ3B1XzEgPSByZXF1aXJlKFwiLi93ZWJnbC9jb3B5X2dwdVwiKTtcbnZhciBncGdwdV9jb250ZXh0XzEgPSByZXF1aXJlKFwiLi93ZWJnbC9ncGdwdV9jb250ZXh0XCIpO1xudmFyIGdwZ3B1X21hdGggPSByZXF1aXJlKFwiLi93ZWJnbC9ncGdwdV9tYXRoXCIpO1xudmFyIGdwZ3B1X3V0aWwgPSByZXF1aXJlKFwiLi93ZWJnbC9ncGdwdV91dGlsXCIpO1xudmFyIG1heF9wb29sX2JhY2twcm9wX2dwdV8xID0gcmVxdWlyZShcIi4vd2ViZ2wvbWF4X3Bvb2xfYmFja3Byb3BfZ3B1XCIpO1xudmFyIG11bG1hdF9ncHVfMSA9IHJlcXVpcmUoXCIuL3dlYmdsL211bG1hdF9ncHVcIik7XG52YXIgbXVsdGlub21pYWxfZ3B1XzEgPSByZXF1aXJlKFwiLi93ZWJnbC9tdWx0aW5vbWlhbF9ncHVcIik7XG52YXIgb25laG90X2dwdV8xID0gcmVxdWlyZShcIi4vd2ViZ2wvb25laG90X2dwdVwiKTtcbnZhciBwb29sX2dwdV8xID0gcmVxdWlyZShcIi4vd2ViZ2wvcG9vbF9ncHVcIik7XG52YXIgcmVkdWNlX2dwdV8xID0gcmVxdWlyZShcIi4vd2ViZ2wvcmVkdWNlX2dwdVwiKTtcbnZhciByZXNpemVfYmlsaW5lYXJfZ3B1XzEgPSByZXF1aXJlKFwiLi93ZWJnbC9yZXNpemVfYmlsaW5lYXJfZ3B1XCIpO1xudmFyIHNsaWNlX2dwdV8xID0gcmVxdWlyZShcIi4vd2ViZ2wvc2xpY2VfZ3B1XCIpO1xudmFyIHRleHR1cmVfbWFuYWdlcl8xID0gcmVxdWlyZShcIi4vd2ViZ2wvdGV4dHVyZV9tYW5hZ2VyXCIpO1xudmFyIHRpbGVfZ3B1XzEgPSByZXF1aXJlKFwiLi93ZWJnbC90aWxlX2dwdVwiKTtcbnZhciB0cmFuc3Bvc2VfZ3B1XzEgPSByZXF1aXJlKFwiLi93ZWJnbC90cmFuc3Bvc2VfZ3B1XCIpO1xudmFyIHVuYXJ5X29wID0gcmVxdWlyZShcIi4vd2ViZ2wvdW5hcnlvcF9ncHVcIik7XG52YXIgdW5hcnlvcF9ncHVfMSA9IHJlcXVpcmUoXCIuL3dlYmdsL3VuYXJ5b3BfZ3B1XCIpO1xudmFyIHdlYmdsX3V0aWwgPSByZXF1aXJlKFwiLi93ZWJnbC93ZWJnbF91dGlsXCIpO1xudmFyIE5EQXJyYXlNYXRoR1BVID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTkRBcnJheU1hdGhHUFUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTkRBcnJheU1hdGhHUFUoZ3BncHUsIHNhZmVNb2RlKSB7XG4gICAgICAgIGlmIChzYWZlTW9kZSA9PT0gdm9pZCAwKSB7IHNhZmVNb2RlID0gZmFsc2U7IH1cbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgc2FmZU1vZGUpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmJpbmFyeUNhY2hlID0ge307XG4gICAgICAgIGlmIChncGdwdSA9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgZ2wgPSBncGdwdV91dGlsLmNyZWF0ZVdlYkdMQ29udGV4dCgpO1xuICAgICAgICAgICAgX3RoaXMuZ3BncHUgPSBuZXcgZ3BncHVfY29udGV4dF8xLkdQR1BVQ29udGV4dChnbCk7XG4gICAgICAgICAgICBfdGhpcy5ncGdwdUNyZWF0ZWRMb2NhbGx5ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIF90aGlzLmdwZ3B1ID0gZ3BncHU7XG4gICAgICAgICAgICBfdGhpcy5ncGdwdUNyZWF0ZWRMb2NhbGx5ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMudGV4dHVyZU1hbmFnZXIgPSBuZXcgdGV4dHVyZV9tYW5hZ2VyXzEuVGV4dHVyZU1hbmFnZXIoX3RoaXMuZ3BncHUpO1xuICAgICAgICBuZGFycmF5LmluaXRpYWxpemVHUFUoX3RoaXMuZ3BncHUsIF90aGlzLnRleHR1cmVNYW5hZ2VyKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBOREFycmF5TWF0aEdQVS5wcm90b3R5cGUuZ2V0R1BHUFVDb250ZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ncGdwdTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoR1BVLnByb3RvdHlwZS5jbG9uZUludGVybmFsID0gZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgdmFyIHRleFNoYXBlID0gYS5nZXRUZXh0dXJlU2hhcGVSQygpO1xuICAgICAgICB2YXIgc291cmNlID0gYS5hczJEKHRleFNoYXBlWzBdLCB0ZXhTaGFwZVsxXSk7XG4gICAgICAgIHZhciBvdXRwdXQgPSB0aGlzLm1ha2VPdXRwdXRBcnJheSh0ZXhTaGFwZSwgYS5kdHlwZSk7XG4gICAgICAgIHRoaXMuY29weTJEKHNvdXJjZSwgWzAsIDBdLCB0ZXhTaGFwZSwgb3V0cHV0LCBbMCwgMF0sIHRleFNoYXBlKTtcbiAgICAgICAgcmV0dXJuIG91dHB1dC5yZXNoYXBlKGEuc2hhcGUpO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhHUFUucHJvdG90eXBlLnNsaWNlMURJbnRlcm5hbCA9IGZ1bmN0aW9uIChpbnB1dCwgYmVnaW4sIHNpemUpIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgc2xpY2VfZ3B1XzEuU2xpY2VQcm9ncmFtKFtzaXplXSk7XG4gICAgICAgIHZhciBjdXN0b21TZXR1cCA9IHByb2dyYW0uZ2V0Q3VzdG9tU2V0dXBGdW5jKFtiZWdpbl0pO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFtpbnB1dF0sIG51bGwsIGN1c3RvbVNldHVwKTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoR1BVLnByb3RvdHlwZS5zbGljZTJESW50ZXJuYWwgPSBmdW5jdGlvbiAoaW5wdXQsIGJlZ2luLCBzaXplKSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IHNsaWNlX2dwdV8xLlNsaWNlUHJvZ3JhbShzaXplKTtcbiAgICAgICAgdmFyIGN1c3RvbVNldHVwID0gcHJvZ3JhbS5nZXRDdXN0b21TZXR1cEZ1bmMoYmVnaW4pO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFtpbnB1dF0sIG51bGwsIGN1c3RvbVNldHVwKTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoR1BVLnByb3RvdHlwZS5zbGljZTNESW50ZXJuYWwgPSBmdW5jdGlvbiAoaW5wdXQsIGJlZ2luLCBzaXplKSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IHNsaWNlX2dwdV8xLlNsaWNlUHJvZ3JhbShzaXplKTtcbiAgICAgICAgdmFyIGN1c3RvbVNldHVwID0gcHJvZ3JhbS5nZXRDdXN0b21TZXR1cEZ1bmMoYmVnaW4pO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFtpbnB1dF0sIG51bGwsIGN1c3RvbVNldHVwKTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoR1BVLnByb3RvdHlwZS5zbGljZTRESW50ZXJuYWwgPSBmdW5jdGlvbiAoaW5wdXQsIGJlZ2luLCBzaXplKSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IHNsaWNlX2dwdV8xLlNsaWNlUHJvZ3JhbShzaXplKTtcbiAgICAgICAgdmFyIGN1c3RvbVNldHVwID0gcHJvZ3JhbS5nZXRDdXN0b21TZXR1cEZ1bmMoYmVnaW4pO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFtpbnB1dF0sIG51bGwsIGN1c3RvbVNldHVwKTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoR1BVLnByb3RvdHlwZS5jb3B5MkRJbnRlcm5hbCA9IGZ1bmN0aW9uIChzb3VyY2UsIHNvdXJjZUJlZ2luUm93Q29sLCBzb3VyY2VTaXplUm93Q29sLCBkZXN0LCBkZXN0QmVnaW5Sb3dDb2wsIGRlc3RTaXplUm93Q29sKSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IGNvcHlfZ3B1XzEuQ29weTJEUHJvZ3JhbShzb3VyY2VTaXplUm93Q29sWzFdLCBkZXN0U2l6ZVJvd0NvbFsxXSk7XG4gICAgICAgIHZhciBjdXN0b21TZXR1cCA9IHByb2dyYW0uZ2V0Q3VzdG9tU2V0dXBGdW5jKHNvdXJjZUJlZ2luUm93Q29sLCBkZXN0QmVnaW5Sb3dDb2wsIGRlc3RTaXplUm93Q29sKTtcbiAgICAgICAgdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFtzb3VyY2VdLCBkZXN0LCBjdXN0b21TZXR1cCk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aEdQVS5wcm90b3R5cGUuY29uY2F0MURJbnRlcm5hbCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IGNvbmNhdF9ncHVfMS5Db25jYXRQcm9ncmFtKGEuc2hhcGUsIGIuc2hhcGUsIDApO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFthLCBiXSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aEdQVS5wcm90b3R5cGUuY29uY2F0MkRJbnRlcm5hbCA9IGZ1bmN0aW9uIChhLCBiLCBheGlzKSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IGNvbmNhdF9ncHVfMS5Db25jYXRQcm9ncmFtKGEuc2hhcGUsIGIuc2hhcGUsIGF4aXMpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFthLCBiXSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aEdQVS5wcm90b3R5cGUuY29uY2F0M0RJbnRlcm5hbCA9IGZ1bmN0aW9uICh4MSwgeDIsIGF4aXMpIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgY29uY2F0X2dwdV8xLkNvbmNhdFByb2dyYW0oeDEuc2hhcGUsIHgyLnNoYXBlLCBheGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbeDEsIHgyXSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aEdQVS5wcm90b3R5cGUuY29uY2F0NERJbnRlcm5hbCA9IGZ1bmN0aW9uICh4MSwgeDIsIGF4aXMpIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgY29uY2F0X2dwdV8xLkNvbmNhdFByb2dyYW0oeDEuc2hhcGUsIHgyLnNoYXBlLCBheGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbeDEsIHgyXSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aEdQVS5wcm90b3R5cGUuc2NhbGVkQXJyYXlBZGRJbnRlcm5hbCA9IGZ1bmN0aW9uIChjMSwgYSwgYzIsIGIpIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgYWRkc2NhbGVkbWF0X2dwdV8xLkFkZFNjYWxlZE1hdFByb2dyYW0oYS5zaGFwZSwgYi5zaGFwZSk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW2EsIGIsIGMxLCBjMl0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhHUFUucHJvdG90eXBlLm5lZ0ludGVybmFsID0gZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgdW5hcnlvcF9ncHVfMS5VbmFyeU9wUHJvZ3JhbShhLnNoYXBlLCB1bmFyeV9vcC5ORUcpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFthXSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aEdQVS5wcm90b3R5cGUubWFrZU91dHB1dEFycmF5ID0gZnVuY3Rpb24gKHNoYXBlLCBkdHlwZSkge1xuICAgICAgICB2YXIgdGV4dHVyZVNoYXBlUkMgPSB3ZWJnbF91dGlsLmdldFRleHR1cmVTaGFwZUZyb21Mb2dpY2FsU2hhcGUodGhpcy5ncGdwdS5nbCwgc2hhcGUpO1xuICAgICAgICB2YXIgdGV4dHVyZSA9IHRoaXMudGV4dHVyZU1hbmFnZXIuYWNxdWlyZVRleHR1cmUodGV4dHVyZVNoYXBlUkMpO1xuICAgICAgICByZXR1cm4gbmRhcnJheV8xLk5EQXJyYXkubWFrZShzaGFwZSwgeyB0ZXh0dXJlOiB0ZXh0dXJlLCB0ZXh0dXJlU2hhcGVSQzogdGV4dHVyZVNoYXBlUkMgfSwgZHR5cGUpO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhHUFUucHJvdG90eXBlLmNvbXBpbGVBbmRSdW4gPSBmdW5jdGlvbiAocHJvZ3JhbSwgaW5wdXRzLCBvdXRwdXQsIGN1c3RvbVNldHVwKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChvdXRwdXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgb3V0cHV0ID0gdGhpcy5tYWtlT3V0cHV0QXJyYXkocHJvZ3JhbS5vdXRwdXRTaGFwZSwgaW5wdXRzWzBdLmR0eXBlKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIga2V5ID0gZ3BncHVfbWF0aC5tYWtlU2hhZGVyS2V5KHByb2dyYW0sIGlucHV0cywgb3V0cHV0KTtcbiAgICAgICAgdmFyIGJpbmFyeSA9IHRoaXMuZ2V0QW5kU2F2ZUJpbmFyeShrZXksIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBncGdwdV9tYXRoLmNvbXBpbGVQcm9ncmFtKF90aGlzLmdwZ3B1LCBwcm9ncmFtLCBpbnB1dHMsIG91dHB1dCk7XG4gICAgICAgIH0pO1xuICAgICAgICBncGdwdV9tYXRoLnJ1blByb2dyYW0oYmluYXJ5LCBpbnB1dHMsIG91dHB1dCwgY3VzdG9tU2V0dXApO1xuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhHUFUucHJvdG90eXBlLm1hdE11bEludGVybmFsID0gZnVuY3Rpb24gKGEsIGIsIGFPcmllbnRhdGlvbiwgYk9yaWVudGF0aW9uKSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IG11bG1hdF9ncHVfMS5NYXRNdWxQcm9ncmFtKGEuc2hhcGUsIGIuc2hhcGUsIGFPcmllbnRhdGlvbiwgYk9yaWVudGF0aW9uKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbYSwgYl0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhHUFUucHJvdG90eXBlLm11bHRpcGx5SW50ZXJuYWwgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyBiaW5hcnlvcF9ncHVfMS5CaW5hcnlPcFByb2dyYW0oYmluYXJ5b3BfZ3B1Lk1VTCwgYS5zaGFwZSwgYi5zaGFwZSk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW2EsIGJdKTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoR1BVLnByb3RvdHlwZS5iYXRjaE5vcm1hbGl6YXRpb24yREludGVybmFsID0gZnVuY3Rpb24gKHgsIG1lYW4sIHZhcmlhbmNlLCB2YXJpYW5jZUVwc2lsb24sIHNjYWxlLCBvZmZzZXQpIHtcbiAgICAgICAgdmFyIGlucHV0cyA9IFt4LCBtZWFuLCB2YXJpYW5jZV07XG4gICAgICAgIHZhciBvZmZzZXRTaGFwZSA9IG51bGw7XG4gICAgICAgIGlmIChvZmZzZXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgb2Zmc2V0U2hhcGUgPSBvZmZzZXQuc2hhcGU7XG4gICAgICAgICAgICBpbnB1dHMucHVzaChvZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzY2FsZVNoYXBlID0gbnVsbDtcbiAgICAgICAgaWYgKHNjYWxlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHNjYWxlU2hhcGUgPSBzY2FsZS5zaGFwZTtcbiAgICAgICAgICAgIGlucHV0cy5wdXNoKHNjYWxlKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyBiYXRjaG5vcm1fZ3B1XzEuQmF0Y2hOb3JtUHJvZ3JhbSh4LnNoYXBlLCBtZWFuLnNoYXBlLCB2YXJpYW5jZS5zaGFwZSwgb2Zmc2V0U2hhcGUsIHNjYWxlU2hhcGUsIHZhcmlhbmNlRXBzaWxvbik7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgaW5wdXRzKTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoR1BVLnByb3RvdHlwZS5iYXRjaE5vcm1hbGl6YXRpb24zREludGVybmFsID0gZnVuY3Rpb24gKHgsIG1lYW4sIHZhcmlhbmNlLCB2YXJpYW5jZUVwc2lsb24sIHNjYWxlLCBvZmZzZXQpIHtcbiAgICAgICAgdmFyIGlucHV0cyA9IFt4LCBtZWFuLCB2YXJpYW5jZV07XG4gICAgICAgIHZhciBvZmZzZXRTaGFwZSA9IG51bGw7XG4gICAgICAgIGlmIChvZmZzZXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgb2Zmc2V0U2hhcGUgPSBvZmZzZXQuc2hhcGU7XG4gICAgICAgICAgICBpbnB1dHMucHVzaChvZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzY2FsZVNoYXBlID0gbnVsbDtcbiAgICAgICAgaWYgKHNjYWxlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHNjYWxlU2hhcGUgPSBzY2FsZS5zaGFwZTtcbiAgICAgICAgICAgIGlucHV0cy5wdXNoKHNjYWxlKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyBiYXRjaG5vcm1fZ3B1XzEuQmF0Y2hOb3JtUHJvZ3JhbSh4LnNoYXBlLCBtZWFuLnNoYXBlLCB2YXJpYW5jZS5zaGFwZSwgb2Zmc2V0U2hhcGUsIHNjYWxlU2hhcGUsIHZhcmlhbmNlRXBzaWxvbik7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgaW5wdXRzKTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoR1BVLnByb3RvdHlwZS50aWxlSW50ZXJuYWwgPSBmdW5jdGlvbiAoYSwgcmVwcykge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyB0aWxlX2dwdV8xLlRpbGVQcm9ncmFtKGEuc2hhcGUsIHJlcHMpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFthXSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aEdQVS5wcm90b3R5cGUudHJhbnNwb3NlSW50ZXJuYWwgPSBmdW5jdGlvbiAoYSwgcGVybSkge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyB0cmFuc3Bvc2VfZ3B1XzEuVHJhbnNwb3NlUHJvZ3JhbShhLnNoYXBlLCBwZXJtKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbYV0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhHUFUucHJvdG90eXBlLnJlZHVjZSA9IGZ1bmN0aW9uIChhLCByZWR1Y2VUeXBlLCBkdHlwZSkge1xuICAgICAgICB2YXIgYmF0Y2hTaXplID0gYS5zaGFwZVswXTtcbiAgICAgICAgdmFyIGluU2l6ZSA9IGEuc2hhcGVbMV07XG4gICAgICAgIHZhciB3aW5kb3dTaXplID0gcmVkdWNlX3V0aWwuY29tcHV0ZU9wdGltYWxXaW5kb3dTaXplKGluU2l6ZSk7XG4gICAgICAgIHZhciByZWR1Y2VJbmZvID0geyB3aW5kb3dTaXplOiB3aW5kb3dTaXplLCBpblNpemU6IGluU2l6ZSwgYmF0Y2hTaXplOiBiYXRjaFNpemUgfTtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgcmVkdWNlX2dwdV8xLlJlZHVjZVByb2dyYW0ocmVkdWNlSW5mbywgcmVkdWNlVHlwZSk7XG4gICAgICAgIHZhciBfYSA9IHByb2dyYW0ub3V0cHV0U2hhcGUsIHJvd3MgPSBfYVswXSwgY29scyA9IF9hWzFdO1xuICAgICAgICB2YXIgb3V0cHV0ID0gdGhpcy5tYWtlT3V0cHV0QXJyYXkocHJvZ3JhbS5vdXRwdXRTaGFwZSwgZHR5cGUpLmFzMkQocm93cywgY29scyk7XG4gICAgICAgIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbYV0sIG91dHB1dCk7XG4gICAgICAgIGlmIChvdXRwdXQuc2hhcGVbMV0gPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucmVkdWNlKG91dHB1dCwgcmVkdWNlVHlwZSwgZHR5cGUpO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhHUFUucHJvdG90eXBlLmFyZ1JlZHVjZSA9IGZ1bmN0aW9uIChhLCByZWR1Y2VUeXBlLCBiZXN0SW5kaWNlc0EpIHtcbiAgICAgICAgaWYgKGJlc3RJbmRpY2VzQSA9PT0gdm9pZCAwKSB7IGJlc3RJbmRpY2VzQSA9IG51bGw7IH1cbiAgICAgICAgdmFyIGJhdGNoU2l6ZSA9IGEuc2hhcGVbMF07XG4gICAgICAgIHZhciBpblNpemUgPSBhLnNoYXBlWzFdO1xuICAgICAgICBpZiAoYmVzdEluZGljZXNBICE9IG51bGwpIHtcbiAgICAgICAgICAgIGJhdGNoU2l6ZSA9IGJlc3RJbmRpY2VzQS5zaGFwZVswXTtcbiAgICAgICAgICAgIGluU2l6ZSA9IGJlc3RJbmRpY2VzQS5zaGFwZVsxXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgd2luZG93U2l6ZSA9IHJlZHVjZV91dGlsLmNvbXB1dGVPcHRpbWFsV2luZG93U2l6ZShpblNpemUpO1xuICAgICAgICB2YXIgcmVkdWNlSW5mbyA9IHsgd2luZG93U2l6ZTogd2luZG93U2l6ZSwgaW5TaXplOiBpblNpemUsIGJhdGNoU2l6ZTogYmF0Y2hTaXplIH07XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IGFyZ21pbm1heF9ncHVfMS5BcmdNaW5NYXhQcm9ncmFtKHJlZHVjZUluZm8sIHJlZHVjZVR5cGUsIGJlc3RJbmRpY2VzQSA9PSBudWxsKTtcbiAgICAgICAgdmFyIF9hID0gcHJvZ3JhbS5vdXRwdXRTaGFwZSwgcm93cyA9IF9hWzBdLCBjb2xzID0gX2FbMV07XG4gICAgICAgIHZhciBvdXRwdXQgPSB0aGlzLm1ha2VPdXRwdXRBcnJheShwcm9ncmFtLm91dHB1dFNoYXBlLCAnaW50MzInKS5hczJEKHJvd3MsIGNvbHMpO1xuICAgICAgICB2YXIgaW5wdXRzID0gW2FdO1xuICAgICAgICBpZiAoYmVzdEluZGljZXNBICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlucHV0cy5wdXNoKGJlc3RJbmRpY2VzQSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIGlucHV0cywgb3V0cHV0KTtcbiAgICAgICAgaWYgKG91dHB1dC5zaGFwZVsxXSA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5hcmdSZWR1Y2UoYSwgcmVkdWNlVHlwZSwgb3V0cHV0KTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoR1BVLnByb3RvdHlwZS5zdW1JbnRlcm5hbCA9IGZ1bmN0aW9uIChhLCBheGVzKSB7XG4gICAgICAgIGF4aXNfdXRpbC5hc3NlcnRBeGVzQXJlSW5uZXJNb3N0RGltcygnc3VtJywgYXhlcywgYS5yYW5rKTtcbiAgICAgICAgdmFyIF9hID0gYXhpc191dGlsLmNvbXB1dGVPdXRBbmRSZWR1Y2VTaGFwZXMoYS5zaGFwZSwgYXhlcyksIG91dFNoYXBlID0gX2FbMF0sIHJlZHVjZVNoYXBlID0gX2FbMV07XG4gICAgICAgIHZhciBpblNpemUgPSB1dGlsLnNpemVGcm9tU2hhcGUocmVkdWNlU2hhcGUpO1xuICAgICAgICB2YXIgYTJEID0gYS5hczJEKC0xLCBpblNpemUpO1xuICAgICAgICB2YXIgb3V0cHV0RFR5cGUgPSBtYXRoXzEuU3VtVHlwZXNNYXBbYS5kdHlwZV07XG4gICAgICAgIHJldHVybiB0aGlzLnJlZHVjZShhMkQsICdzdW0nLCBvdXRwdXREVHlwZSkucmVzaGFwZShvdXRTaGFwZSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aEdQVS5wcm90b3R5cGUuYXJnTWluSW50ZXJuYWwgPSBmdW5jdGlvbiAoYSwgYXhlcykge1xuICAgICAgICBheGlzX3V0aWwuYXNzZXJ0QXhlc0FyZUlubmVyTW9zdERpbXMoJ2FyZ01pbicsIGF4ZXMsIGEucmFuayk7XG4gICAgICAgIHZhciBfYSA9IGF4aXNfdXRpbC5jb21wdXRlT3V0QW5kUmVkdWNlU2hhcGVzKGEuc2hhcGUsIGF4ZXMpLCBvdXRTaGFwZSA9IF9hWzBdLCByZWR1Y2VTaGFwZSA9IF9hWzFdO1xuICAgICAgICB2YXIgaW5TaXplID0gdXRpbC5zaXplRnJvbVNoYXBlKHJlZHVjZVNoYXBlKTtcbiAgICAgICAgdmFyIGEyRCA9IGEuYXMyRCgtMSwgaW5TaXplKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXJnUmVkdWNlKGEyRCwgJ21pbicpLnJlc2hhcGUob3V0U2hhcGUpO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhHUFUucHJvdG90eXBlLmFyZ01heEludGVybmFsID0gZnVuY3Rpb24gKGEsIGF4ZXMpIHtcbiAgICAgICAgYXhpc191dGlsLmFzc2VydEF4ZXNBcmVJbm5lck1vc3REaW1zKCdhcmdNYXgnLCBheGVzLCBhLnJhbmspO1xuICAgICAgICB2YXIgX2EgPSBheGlzX3V0aWwuY29tcHV0ZU91dEFuZFJlZHVjZVNoYXBlcyhhLnNoYXBlLCBheGVzKSwgb3V0U2hhcGUgPSBfYVswXSwgcmVkdWNlU2hhcGUgPSBfYVsxXTtcbiAgICAgICAgdmFyIGluU2l6ZSA9IHV0aWwuc2l6ZUZyb21TaGFwZShyZWR1Y2VTaGFwZSk7XG4gICAgICAgIHZhciBhMkQgPSBhLmFzMkQoLTEsIGluU2l6ZSk7XG4gICAgICAgIHJldHVybiB0aGlzLmFyZ1JlZHVjZShhMkQsICdtYXgnKS5yZXNoYXBlKG91dFNoYXBlKTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoR1BVLnByb3RvdHlwZS5lcXVhbEludGVybmFsID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgYmluYXJ5b3BfZ3B1XzEuQmluYXJ5T3BQcm9ncmFtKGJpbmFyeW9wX2dwdS5FUVVBTCwgeC5zaGFwZSwgeS5zaGFwZSk7XG4gICAgICAgIHZhciBvdXRwdXQgPSB0aGlzLm1ha2VPdXRwdXRBcnJheShwcm9ncmFtLm91dHB1dFNoYXBlLCAnYm9vbCcpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFt4LCB5XSwgb3V0cHV0KTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoR1BVLnByb3RvdHlwZS50b3BLSW50ZXJuYWwgPSBmdW5jdGlvbiAobmRhcnJheSwgaykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RvcEsgR1BVIG5vdCB5ZXQgaW1wbGVtZW50ZWQhJyk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aEdQVS5wcm90b3R5cGUubWluSW50ZXJuYWwgPSBmdW5jdGlvbiAoYSwgYXhlcykge1xuICAgICAgICBheGlzX3V0aWwuYXNzZXJ0QXhlc0FyZUlubmVyTW9zdERpbXMoJ21pbicsIGF4ZXMsIGEucmFuayk7XG4gICAgICAgIHZhciBfYSA9IGF4aXNfdXRpbC5jb21wdXRlT3V0QW5kUmVkdWNlU2hhcGVzKGEuc2hhcGUsIGF4ZXMpLCBvdXRTaGFwZSA9IF9hWzBdLCByZWR1Y2VTaGFwZSA9IF9hWzFdO1xuICAgICAgICB2YXIgaW5TaXplID0gdXRpbC5zaXplRnJvbVNoYXBlKHJlZHVjZVNoYXBlKTtcbiAgICAgICAgdmFyIGEyRCA9IGEuYXMyRCgtMSwgaW5TaXplKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVkdWNlKGEyRCwgJ21pbicsIGEyRC5kdHlwZSkucmVzaGFwZShvdXRTaGFwZSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aEdQVS5wcm90b3R5cGUubWF4SW50ZXJuYWwgPSBmdW5jdGlvbiAoYSwgYXhlcykge1xuICAgICAgICBheGlzX3V0aWwuYXNzZXJ0QXhlc0FyZUlubmVyTW9zdERpbXMoJ21heCcsIGF4ZXMsIGEucmFuayk7XG4gICAgICAgIHZhciBfYSA9IGF4aXNfdXRpbC5jb21wdXRlT3V0QW5kUmVkdWNlU2hhcGVzKGEuc2hhcGUsIGF4ZXMpLCBvdXRTaGFwZSA9IF9hWzBdLCByZWR1Y2VTaGFwZSA9IF9hWzFdO1xuICAgICAgICB2YXIgaW5TaXplID0gdXRpbC5zaXplRnJvbVNoYXBlKHJlZHVjZVNoYXBlKTtcbiAgICAgICAgdmFyIGEyRCA9IGEuYXMyRCgtMSwgaW5TaXplKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVkdWNlKGEyRCwgJ21heCcsIGEyRC5kdHlwZSkucmVzaGFwZShvdXRTaGFwZSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aEdQVS5wcm90b3R5cGUuZGl2aWRlSW50ZXJuYWwgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyBiaW5hcnlvcF9ncHVfMS5CaW5hcnlPcFByb2dyYW0oYmluYXJ5b3BfZ3B1LkRJViwgYS5zaGFwZSwgYi5zaGFwZSk7XG4gICAgICAgIHZhciBvdXRwdXQgPSB0aGlzLm1ha2VPdXRwdXRBcnJheShwcm9ncmFtLm91dHB1dFNoYXBlLCAnZmxvYXQzMicpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFthLCBiXSwgb3V0cHV0KTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoR1BVLnByb3RvdHlwZS5hZGRJbnRlcm5hbCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IGJpbmFyeW9wX2dwdV8xLkJpbmFyeU9wUHJvZ3JhbShiaW5hcnlvcF9ncHUuQURELCBhLnNoYXBlLCBiLnNoYXBlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbYSwgYl0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhHUFUucHJvdG90eXBlLnN1YnRyYWN0SW50ZXJuYWwgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyBiaW5hcnlvcF9ncHVfMS5CaW5hcnlPcFByb2dyYW0oYmluYXJ5b3BfZ3B1LlNVQiwgYS5zaGFwZSwgYi5zaGFwZSk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW2EsIGJdKTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoR1BVLnByb3RvdHlwZS5jZWlsSW50ZXJuYWwgPSBmdW5jdGlvbiAoYSkge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyB1bmFyeW9wX2dwdV8xLlVuYXJ5T3BQcm9ncmFtKGEuc2hhcGUsIHVuYXJ5X29wLkNFSUwpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFthXSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aEdQVS5wcm90b3R5cGUuZmxvb3JJbnRlcm5hbCA9IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IHVuYXJ5b3BfZ3B1XzEuVW5hcnlPcFByb2dyYW0oYS5zaGFwZSwgdW5hcnlfb3AuRkxPT1IpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFthXSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aEdQVS5wcm90b3R5cGUuZXhwSW50ZXJuYWwgPSBmdW5jdGlvbiAoYSkge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyB1bmFyeW9wX2dwdV8xLlVuYXJ5T3BQcm9ncmFtKGEuc2hhcGUsIHVuYXJ5X29wLkVYUCk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW2FdKTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoR1BVLnByb3RvdHlwZS5sb2dJbnRlcm5hbCA9IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IHVuYXJ5b3BfZ3B1XzEuVW5hcnlPcFByb2dyYW0oYS5zaGFwZSwgdW5hcnlfb3AuTE9HKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbYV0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhHUFUucHJvdG90eXBlLnNxcnRJbnRlcm5hbCA9IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IHVuYXJ5b3BfZ3B1XzEuVW5hcnlPcFByb2dyYW0oYS5zaGFwZSwgdW5hcnlfb3AuU1FSVCk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW2FdKTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoR1BVLnByb3RvdHlwZS5zcXVhcmVJbnRlcm5hbCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IHVuYXJ5b3BfZ3B1XzEuVW5hcnlPcFByb2dyYW0oeC5zaGFwZSwgdW5hcnlfb3AuU1FVQVJFKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbeF0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhHUFUucHJvdG90eXBlLnJlbHVJbnRlcm5hbCA9IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IHVuYXJ5b3BfZ3B1XzEuVW5hcnlPcFByb2dyYW0oYS5zaGFwZSwgdW5hcnlfb3AuUkVMVSk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW2FdKTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoR1BVLnByb3RvdHlwZS5lbHVJbnRlcm5hbCA9IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IHVuYXJ5b3BfZ3B1XzEuVW5hcnlPcFByb2dyYW0oYS5zaGFwZSwgdW5hcnlfb3AuRUxVKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbYV0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhHUFUucHJvdG90eXBlLmxlYWt5UmVsdUludGVybmFsID0gZnVuY3Rpb24gKGEsIGFscGhhKSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IHVuYXJ5b3BfZ3B1XzEuVW5hcnlPcFByb2dyYW0oYS5zaGFwZSwgdW5hcnlfb3AuTEVBS1lfUkVMVShhbHBoYSkpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFthXSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aEdQVS5wcm90b3R5cGUuY2xpcEludGVybmFsID0gZnVuY3Rpb24gKGEsIG1pbiwgbWF4KSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IGNsaXBfZ3B1XzEuQ2xpcFByb2dyYW0oYS5zaGFwZSwgbWluLCBtYXgpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFthXSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aEdQVS5wcm90b3R5cGUuYWJzSW50ZXJuYWwgPSBmdW5jdGlvbiAoYSkge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyB1bmFyeW9wX2dwdV8xLlVuYXJ5T3BQcm9ncmFtKGEuc2hhcGUsIHVuYXJ5X29wLkFCUyk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW2FdKTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoR1BVLnByb3RvdHlwZS5zaWdtb2lkSW50ZXJuYWwgPSBmdW5jdGlvbiAoYSkge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyB1bmFyeW9wX2dwdV8xLlVuYXJ5T3BQcm9ncmFtKGEuc2hhcGUsIHVuYXJ5X29wLlNJR01PSUQpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFthXSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aEdQVS5wcm90b3R5cGUuc2luSW50ZXJuYWwgPSBmdW5jdGlvbiAoYSkge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyB1bmFyeW9wX2dwdV8xLlVuYXJ5T3BQcm9ncmFtKGEuc2hhcGUsIHVuYXJ5X29wLlNJTik7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW2FdKTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoR1BVLnByb3RvdHlwZS5jb3NJbnRlcm5hbCA9IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IHVuYXJ5b3BfZ3B1XzEuVW5hcnlPcFByb2dyYW0oYS5zaGFwZSwgdW5hcnlfb3AuQ09TKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbYV0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhHUFUucHJvdG90eXBlLnRhbkludGVybmFsID0gZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgdW5hcnlvcF9ncHVfMS5VbmFyeU9wUHJvZ3JhbShhLnNoYXBlLCB1bmFyeV9vcC5UQU4pO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFthXSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aEdQVS5wcm90b3R5cGUuYXNpbkludGVybmFsID0gZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgdW5hcnlvcF9ncHVfMS5VbmFyeU9wUHJvZ3JhbShhLnNoYXBlLCB1bmFyeV9vcC5BU0lOKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbYV0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhHUFUucHJvdG90eXBlLmFjb3NJbnRlcm5hbCA9IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IHVuYXJ5b3BfZ3B1XzEuVW5hcnlPcFByb2dyYW0oYS5zaGFwZSwgdW5hcnlfb3AuQUNPUyk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW2FdKTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoR1BVLnByb3RvdHlwZS5hdGFuSW50ZXJuYWwgPSBmdW5jdGlvbiAoYSkge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyB1bmFyeW9wX2dwdV8xLlVuYXJ5T3BQcm9ncmFtKGEuc2hhcGUsIHVuYXJ5X29wLkFUQU4pO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFthXSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aEdQVS5wcm90b3R5cGUuc2luaEludGVybmFsID0gZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgdW5hcnlvcF9ncHVfMS5VbmFyeU9wUHJvZ3JhbShhLnNoYXBlLCB1bmFyeV9vcC5TSU5IKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbYV0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhHUFUucHJvdG90eXBlLmNvc2hJbnRlcm5hbCA9IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IHVuYXJ5b3BfZ3B1XzEuVW5hcnlPcFByb2dyYW0oYS5zaGFwZSwgdW5hcnlfb3AuQ09TSCk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW2FdKTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoR1BVLnByb3RvdHlwZS50YW5oSW50ZXJuYWwgPSBmdW5jdGlvbiAoYSkge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyB1bmFyeW9wX2dwdV8xLlVuYXJ5T3BQcm9ncmFtKGEuc2hhcGUsIHVuYXJ5X29wLlRBTkgpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFthXSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aEdQVS5wcm90b3R5cGUuc3RlcEludGVybmFsID0gZnVuY3Rpb24gKGEsIGFscGhhKSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IHVuYXJ5b3BfZ3B1XzEuVW5hcnlPcFByb2dyYW0oYS5zaGFwZSwgdW5hcnlfb3AuU1RFUChhbHBoYSkpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFthXSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aEdQVS5wcm90b3R5cGUuY29udjJkSW50ZXJuYWwgPSBmdW5jdGlvbiAoeCwgZmlsdGVyLCBiaWFzLCBjb252SW5mbykge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyBjb252X2dwdV8xLkNvbnYyRFByb2dyYW0oY29udkluZm8sIGJpYXMgIT0gbnVsbCk7XG4gICAgICAgIHZhciBpbnB1dHMgPSBiaWFzICE9IG51bGwgPyBbeCwgZmlsdGVyLCBiaWFzXSA6IFt4LCBmaWx0ZXJdO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIGlucHV0cyk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aEdQVS5wcm90b3R5cGUuY29udjJkRGVySW5wdXRJbnRlcm5hbCA9IGZ1bmN0aW9uIChkeSwgZmlsdGVyLCBjb252SW5mbykge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyBjb252X2JhY2twcm9wX2dwdV8xLkNvbnYyRERlcklucHV0UHJvZ3JhbShjb252SW5mbyk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW2R5LCBmaWx0ZXJdKTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoR1BVLnByb3RvdHlwZS5jb252MmREZXJGaWx0ZXJJbnRlcm5hbCA9IGZ1bmN0aW9uICh4LCBkWSwgY29udkluZm8pIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgY29udl9iYWNrcHJvcF9ncHVfMS5Db252MkREZXJXZWlnaHRzUHJvZ3JhbShjb252SW5mbyk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW3gsIGRZXSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aEdQVS5wcm90b3R5cGUuY29udjJkRGVyQmlhc0ludGVybmFsID0gZnVuY3Rpb24gKGRZKSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IGNvbnZfYmFja3Byb3BfZ3B1XzEuQ29udjJERGVyQmlhc1Byb2dyYW0oZFkuc2hhcGUpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFtkWV0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhHUFUucHJvdG90eXBlLmRlcHRod2lzZUNvbnYyREludGVybmFsID0gZnVuY3Rpb24gKGlucHV0LCBmaWx0ZXIsIGNvbnZJbmZvKSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IGNvbnZfZ3B1X2RlcHRod2lzZV8xLkRlcHRod2lzZUNvbnYyRFByb2dyYW0oY29udkluZm8pO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFtpbnB1dCwgZmlsdGVyXSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aEdQVS5wcm90b3R5cGUubWF4UG9vbEludGVybmFsID0gZnVuY3Rpb24gKHgsIGNvbnZJbmZvKSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IHBvb2xfZ3B1XzEuUG9vbDJEUHJvZ3JhbShjb252SW5mbywgJ21heCcsIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbeF0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhHUFUucHJvdG90eXBlLm1pblBvb2xJbnRlcm5hbCA9IGZ1bmN0aW9uICh4LCBjb252SW5mbykge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyBwb29sX2dwdV8xLlBvb2wyRFByb2dyYW0oY29udkluZm8sICdtaW4nLCBmYWxzZSk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW3hdKTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoR1BVLnByb3RvdHlwZS5hdmdQb29sSW50ZXJuYWwgPSBmdW5jdGlvbiAoeCwgY29udkluZm8pIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgcG9vbF9ncHVfMS5Qb29sMkRQcm9ncmFtKGNvbnZJbmZvLCAnYXZnJywgZmFsc2UpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFt4XSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aEdQVS5wcm90b3R5cGUubWF4UG9vbEJhY2twcm9wSW50ZXJuYWwgPSBmdW5jdGlvbiAoZHksIHgsIGNvbnZJbmZvKSB7XG4gICAgICAgIHZhciBnZXRQb3NpdGlvbnMgPSB0cnVlO1xuICAgICAgICB2YXIgbWF4UG9vbFBvc2l0aW9uc1Byb2dyYW0gPSBuZXcgcG9vbF9ncHVfMS5Qb29sMkRQcm9ncmFtKGNvbnZJbmZvLCAnbWF4JywgZ2V0UG9zaXRpb25zKTtcbiAgICAgICAgdmFyIG1heFBvb2xQb3NpdGlvbnMgPSB0aGlzLmNvbXBpbGVBbmRSdW4obWF4UG9vbFBvc2l0aW9uc1Byb2dyYW0sIFt4XSk7XG4gICAgICAgIHZhciBtYXhQb29sQmFja1Byb3BQcm9ncmFtID0gbmV3IG1heF9wb29sX2JhY2twcm9wX2dwdV8xLk1heFBvb2wyREJhY2twcm9wUHJvZ3JhbShjb252SW5mbyk7XG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLmNvbXBpbGVBbmRSdW4obWF4UG9vbEJhY2tQcm9wUHJvZ3JhbSwgW2R5LCBtYXhQb29sUG9zaXRpb25zXSk7XG4gICAgICAgIG1heFBvb2xQb3NpdGlvbnMuZGlzcG9zZSgpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhHUFUucHJvdG90eXBlLnJlc2l6ZUJpbGluZWFyM0RJbnRlcm5hbCA9IGZ1bmN0aW9uICh4LCBuZXdTaGFwZTJELCBhbGlnbkNvcm5lcnMpIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgcmVzaXplX2JpbGluZWFyX2dwdV8xLlJlc2l6ZUJpbGluZWFyM0RQcm9ncmFtKHguc2hhcGUsIG5ld1NoYXBlMkQsIGFsaWduQ29ybmVycyk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW3hdKTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoR1BVLnByb3RvdHlwZS5tdWx0aW5vbWlhbEludGVybmFsID0gZnVuY3Rpb24gKHByb2JzLCBudW1TYW1wbGVzLCBzZWVkKSB7XG4gICAgICAgIHZhciBiYXRjaFNpemUgPSBwcm9icy5zaGFwZVswXTtcbiAgICAgICAgdmFyIG51bU91dGNvbWVzID0gcHJvYnMuc2hhcGVbMV07XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IG11bHRpbm9taWFsX2dwdV8xLk11bHRpbm9taWFsUHJvZ3JhbShiYXRjaFNpemUsIG51bU91dGNvbWVzLCBudW1TYW1wbGVzKTtcbiAgICAgICAgdmFyIG91dHB1dCA9IHRoaXMubWFrZU91dHB1dEFycmF5KHByb2dyYW0ub3V0cHV0U2hhcGUsICdpbnQzMicpO1xuICAgICAgICB2YXIgY3VzdG9tU2V0dXAgPSBwcm9ncmFtLmdldEN1c3RvbVNldHVwRnVuYyhzZWVkKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbcHJvYnNdLCBvdXRwdXQsIGN1c3RvbVNldHVwKTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoR1BVLnByb3RvdHlwZS5vbmVIb3RJbnRlcm5hbCA9IGZ1bmN0aW9uIChpbmRpY2VzLCBkZXB0aCwgb25WYWx1ZSwgb2ZmVmFsdWUpIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgb25laG90X2dwdV8xLk9uZUhvdFByb2dyYW0oaW5kaWNlcy5zaXplLCBkZXB0aCwgb25WYWx1ZSwgb2ZmVmFsdWUpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFtpbmRpY2VzXSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aEdQVS5wcm90b3R5cGUuZ2V0QW5kU2F2ZUJpbmFyeSA9IGZ1bmN0aW9uIChrZXksIGdldEJpbmFyeSkge1xuICAgICAgICBpZiAoIShrZXkgaW4gdGhpcy5iaW5hcnlDYWNoZSkpIHtcbiAgICAgICAgICAgIHRoaXMuYmluYXJ5Q2FjaGVba2V5XSA9IGdldEJpbmFyeSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmJpbmFyeUNhY2hlW2tleV07XG4gICAgfTtcbiAgICBOREFycmF5TWF0aEdQVS5wcm90b3R5cGUuZ2V0VGV4dHVyZU1hbmFnZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRleHR1cmVNYW5hZ2VyO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhHUFUucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiB0aGlzLmJpbmFyeUNhY2hlKSB7XG4gICAgICAgICAgICB0aGlzLmdwZ3B1LmRlbGV0ZVByb2dyYW0odGhpcy5iaW5hcnlDYWNoZVtrZXldLndlYkdMUHJvZ3JhbSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50ZXh0dXJlTWFuYWdlci5kaXNwb3NlKCk7XG4gICAgICAgIGlmICh0aGlzLmdwZ3B1Q3JlYXRlZExvY2FsbHkpIHtcbiAgICAgICAgICAgIHRoaXMuZ3BncHUuZGlzcG9zZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gTkRBcnJheU1hdGhHUFU7XG59KG1hdGhfMS5OREFycmF5TWF0aCkpO1xuZXhwb3J0cy5OREFycmF5TWF0aEdQVSA9IE5EQXJyYXlNYXRoR1BVO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWF0aF9ncHUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUocmVzdWx0LnZhbHVlKTsgfSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9fZ2VuZXJhdG9yID0gKHRoaXMgJiYgdGhpcy5fX2dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IHlbb3BbMF0gJiAyID8gXCJyZXR1cm5cIiA6IG9wWzBdID8gXCJ0aHJvd1wiIDogXCJuZXh0XCJdKSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbMCwgdC52YWx1ZV07XG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcbiAgICB9XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGVudmlyb25tZW50XzEgPSByZXF1aXJlKFwiLi4vZW52aXJvbm1lbnRcIik7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xudmFyIHRleF91dGlsXzEgPSByZXF1aXJlKFwiLi93ZWJnbC90ZXhfdXRpbFwiKTtcbnZhciB3ZWJnbF91dGlsID0gcmVxdWlyZShcIi4vd2ViZ2wvd2ViZ2xfdXRpbFwiKTtcbmV4cG9ydHMuR1BHUFUgPSBudWxsO1xuZXhwb3J0cy5URVhUVVJFX01BTkFHRVIgPSBudWxsO1xudmFyIERUeXBlO1xuKGZ1bmN0aW9uIChEVHlwZSkge1xuICAgIERUeXBlW1wiZmxvYXQzMlwiXSA9IFwiZmxvYXQzMlwiO1xuICAgIERUeXBlW1wiaW50MzJcIl0gPSBcImludDMyXCI7XG4gICAgRFR5cGVbXCJib29sXCJdID0gXCJib29sXCI7XG59KShEVHlwZSA9IGV4cG9ydHMuRFR5cGUgfHwgKGV4cG9ydHMuRFR5cGUgPSB7fSkpO1xuZnVuY3Rpb24gaW5pdGlhbGl6ZUdQVShncGdwdSwgdGV4dHVyZU1hbmFnZXIpIHtcbiAgICBleHBvcnRzLkdQR1BVID0gZ3BncHU7XG4gICAgZXhwb3J0cy5URVhUVVJFX01BTkFHRVIgPSB0ZXh0dXJlTWFuYWdlcjtcbn1cbmV4cG9ydHMuaW5pdGlhbGl6ZUdQVSA9IGluaXRpYWxpemVHUFU7XG5mdW5jdGlvbiB0aHJvd0lmR1BVTm90SW5pdGlhbGl6ZWQoKSB7XG4gICAgaWYgKGV4cG9ydHMuR1BHUFUgPT0gbnVsbCB8fCBleHBvcnRzLlRFWFRVUkVfTUFOQUdFUiA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignR1BVIG5vdCBpbnRpYWxpemVkLicpO1xuICAgIH1cbn1cbnZhciBOREFycmF5ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBOREFycmF5KHNoYXBlLCBkYXRhLCBkdHlwZSkge1xuICAgICAgICB1dGlsLmFzc2VydChkYXRhLnZhbHVlcyAhPSBudWxsIHx8IGRhdGEudGV4dHVyZSAhPSBudWxsLCAnRWl0aGVyIGB2YWx1ZXNgIG9yIGB0ZXh0dXJlYCBtdXN0IGJlIGRlZmluZWQnKTtcbiAgICAgICAgdXRpbC5hc3NlcnQoZGF0YS50ZXh0dXJlID09IG51bGwgfHwgKGRhdGEudGV4dHVyZVNoYXBlUkMgIT0gbnVsbCksICdgdGV4dHVyZVNoYXBlYCBtdXN0IGJlIGRlZmluZWQgd2hlbiBgdGV4dHVyZWAgaXMgZGVmaW5lZCcpO1xuICAgICAgICB0aGlzLnNpemUgPSB1dGlsLnNpemVGcm9tU2hhcGUoc2hhcGUpO1xuICAgICAgICBpZiAoZGF0YS52YWx1ZXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgdXRpbC5hc3NlcnQodGhpcy5zaXplID09PSBkYXRhLnZhbHVlcy5sZW5ndGgsIFwiQ29uc3RydWN0aW5nIG5kYXJyYXkgb2Ygc2hhcGUgKFwiICsgdGhpcy5zaXplICsgXCIpIHNob3VsZCBtYXRjaCB0aGUgXCIgK1xuICAgICAgICAgICAgICAgIChcImxlbmd0aCBvZiB2YWx1ZXMgKFwiICsgZGF0YS52YWx1ZXMubGVuZ3RoICsgXCIpXCIpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNoYXBlID0gc2hhcGU7XG4gICAgICAgIGlmIChkYXRhLnRleHR1cmVUeXBlID09IG51bGwpIHtcbiAgICAgICAgICAgIGRhdGEudGV4dHVyZVR5cGUgPSB0ZXhfdXRpbF8xLlRleHR1cmVUeXBlLkRFRkFVTFQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5uZGFycmF5RGF0YSA9IGRhdGE7XG4gICAgICAgIHRoaXMuZHR5cGUgPSBkdHlwZSB8fCAnZmxvYXQzMic7XG4gICAgICAgIHZhciBkaW0gPSB0aGlzLnNoYXBlLmxlbmd0aDtcbiAgICAgICAgaWYgKGRpbSA8IDIpIHtcbiAgICAgICAgICAgIHRoaXMuc3RyaWRlcyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zdHJpZGVzID0gbmV3IEFycmF5KGRpbSAtIDEpO1xuICAgICAgICAgICAgdGhpcy5zdHJpZGVzW2RpbSAtIDJdID0gdGhpcy5zaGFwZVtkaW0gLSAxXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBkaW0gLSAzOyBpID49IDA7IC0taSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RyaWRlc1tpXSA9IHRoaXMuc3RyaWRlc1tpICsgMV0gKiB0aGlzLnNoYXBlW2kgKyAxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBOREFycmF5Lnplcm9zID0gZnVuY3Rpb24gKHNoYXBlLCBkdHlwZSkge1xuICAgICAgICB2YXIgdmFsdWVzID0gbWFrZVplcm9zVHlwZWRBcnJheSh1dGlsLnNpemVGcm9tU2hhcGUoc2hhcGUpLCBkdHlwZSk7XG4gICAgICAgIHJldHVybiBOREFycmF5Lm1ha2Uoc2hhcGUsIHsgdmFsdWVzOiB2YWx1ZXMgfSwgZHR5cGUpO1xuICAgIH07XG4gICAgTkRBcnJheS56ZXJvc0xpa2UgPSBmdW5jdGlvbiAoYW5vdGhlcikge1xuICAgICAgICByZXR1cm4gTkRBcnJheS56ZXJvcyhhbm90aGVyLnNoYXBlLCBhbm90aGVyLmR0eXBlKTtcbiAgICB9O1xuICAgIE5EQXJyYXkubGlrZSA9IGZ1bmN0aW9uIChhbm90aGVyKSB7XG4gICAgICAgIHZhciBuZXdWYWx1ZXMgPSBjb3B5VHlwZWRBcnJheShhbm90aGVyLmdldFZhbHVlcygpLCBhbm90aGVyLmR0eXBlKTtcbiAgICAgICAgcmV0dXJuIE5EQXJyYXkubWFrZShhbm90aGVyLnNoYXBlLCB7IHZhbHVlczogbmV3VmFsdWVzIH0sIGFub3RoZXIuZHR5cGUpO1xuICAgIH07XG4gICAgTkRBcnJheS5tYWtlID0gZnVuY3Rpb24gKHNoYXBlLCBkYXRhLCBkdHlwZSkge1xuICAgICAgICBpZiAoZGF0YS5pc0Rpc3Bvc2VkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgbWFrZSBuZXcgTkRBcnJheSBmcm9tIGRpc3Bvc2VkIE5EQXJyYXlEYXRhLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKHNoYXBlLmxlbmd0aCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU2NhbGFyKGRhdGEsIGR0eXBlKTtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEFycmF5MUQoZGF0YSwgZHR5cGUpO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQXJyYXkyRChzaGFwZSwgZGF0YSwgZHR5cGUpO1xuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQXJyYXkzRChzaGFwZSwgZGF0YSwgZHR5cGUpO1xuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQXJyYXk0RChzaGFwZSwgZGF0YSwgZHR5cGUpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IE5EQXJyYXkoc2hhcGUsIGRhdGEsIGR0eXBlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTkRBcnJheS5mcm9tUGl4ZWxzID0gZnVuY3Rpb24gKHBpeGVscywgbnVtQ2hhbm5lbHMpIHtcbiAgICAgICAgaWYgKG51bUNoYW5uZWxzID09PSB2b2lkIDApIHsgbnVtQ2hhbm5lbHMgPSAzOyB9XG4gICAgICAgIGlmIChudW1DaGFubmVscyA+IDQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNvbnN0cnVjdCBOREFycmF5IHdpdGggbW9yZSB0aGFuIDQgY2hhbm5lbHMgZnJvbSBwaXhlbHMuJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNoYXBlID0gW3BpeGVscy5oZWlnaHQsIHBpeGVscy53aWR0aCwgbnVtQ2hhbm5lbHNdO1xuICAgICAgICB2YXIgdGV4dHVyZVNoYXBlUkMgPSBbc2hhcGVbMF0sIHNoYXBlWzFdXTtcbiAgICAgICAgdmFyIHRleHR1cmUgPSBleHBvcnRzLlRFWFRVUkVfTUFOQUdFUi5hY3F1aXJlVGV4dHVyZSh0ZXh0dXJlU2hhcGVSQyk7XG4gICAgICAgIHZhciB0ZXh0dXJlVHlwZSA9IHRleF91dGlsXzEuVGV4dHVyZVR5cGUuUkdCQV9DT0xPUjtcbiAgICAgICAgZXhwb3J0cy5HUEdQVS51cGxvYWRQaXhlbERhdGFUb1RleHR1cmUodGV4dHVyZSwgcGl4ZWxzKTtcbiAgICAgICAgcmV0dXJuIEFycmF5M0QubWFrZShzaGFwZSwgeyB0ZXh0dXJlOiB0ZXh0dXJlLCB0ZXh0dXJlU2hhcGVSQzogdGV4dHVyZVNoYXBlUkMsIHRleHR1cmVUeXBlOiB0ZXh0dXJlVHlwZSB9KTtcbiAgICB9O1xuICAgIE5EQXJyYXkucHJvdG90eXBlLnJlc2hhcGUgPSBmdW5jdGlvbiAobmV3U2hhcGUpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgbmV3U2hhcGUgPSB1dGlsLmluZmVyRnJvbUltcGxpY2l0U2hhcGUobmV3U2hhcGUsIHRoaXMuc2l6ZSk7XG4gICAgICAgIGlmICh1dGlsLmFycmF5c0VxdWFsKHRoaXMuc2hhcGUsIG5ld1NoYXBlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgdXRpbC5hc3NlcnQodGhpcy5zaXplID09PSB1dGlsLnNpemVGcm9tU2hhcGUobmV3U2hhcGUpLCAnbmV3IHNoYXBlIGFuZCBvbGQgc2hhcGUgbXVzdCBoYXZlIHRoZSBzYW1lIG51bWJlciBvZiBlbGVtZW50cy4nKTtcbiAgICAgICAgcmV0dXJuIE5EQXJyYXkubWFrZShuZXdTaGFwZSwgdGhpcy5uZGFycmF5RGF0YSwgdGhpcy5kdHlwZSk7XG4gICAgfTtcbiAgICBOREFycmF5LnByb3RvdHlwZS5mbGF0dGVuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcyBpbnN0YW5jZW9mIEFycmF5MUQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmFzMUQoKTtcbiAgICB9O1xuICAgIE5EQXJyYXkucHJvdG90eXBlLmFzU2NhbGFyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB1dGlsLmFzc2VydCh0aGlzLnNpemUgPT09IDEsICdUaGUgYXJyYXkgbXVzdCBoYXZlIG9ubHkgMSBlbGVtZW50LicpO1xuICAgICAgICByZXR1cm4gdGhpcy5yZXNoYXBlKFtdKTtcbiAgICB9O1xuICAgIE5EQXJyYXkucHJvdG90eXBlLmFzMUQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlc2hhcGUoW3RoaXMuc2l6ZV0pO1xuICAgIH07XG4gICAgTkRBcnJheS5wcm90b3R5cGUuYXMyRCA9IGZ1bmN0aW9uIChyb3dzLCBjb2x1bW5zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlc2hhcGUoW3Jvd3MsIGNvbHVtbnNdKTtcbiAgICB9O1xuICAgIE5EQXJyYXkucHJvdG90eXBlLmFzM0QgPSBmdW5jdGlvbiAocm93cywgY29sdW1ucywgZGVwdGgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzaGFwZShbcm93cywgY29sdW1ucywgZGVwdGhdKTtcbiAgICB9O1xuICAgIE5EQXJyYXkucHJvdG90eXBlLmFzNEQgPSBmdW5jdGlvbiAocm93cywgY29sdW1ucywgZGVwdGgsIGRlcHRoMikge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXNoYXBlKFtyb3dzLCBjb2x1bW5zLCBkZXB0aCwgZGVwdGgyXSk7XG4gICAgfTtcbiAgICBOREFycmF5LnByb3RvdHlwZS5hc1R5cGUgPSBmdW5jdGlvbiAoZHR5cGUpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgdmFyIG5ld0RhdGEgPSB0aGlzLmdldERhdGEoKTtcbiAgICAgICAgaWYgKG5ld0RhdGEudmFsdWVzICE9IG51bGwpIHtcbiAgICAgICAgICAgIG5ld0RhdGEgPSB7IHZhbHVlczogdG9UeXBlZEFycmF5KG5ld0RhdGEudmFsdWVzLCBkdHlwZSkgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gTkRBcnJheS5tYWtlKHRoaXMuc2hhcGUsIG5ld0RhdGEsIGR0eXBlKTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOREFycmF5LnByb3RvdHlwZSwgXCJyYW5rXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2hhcGUubGVuZ3RoO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBOREFycmF5LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBsb2NzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBsb2NzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgdmFyIGluZGV4ID0gbG9jc1tsb2NzLmxlbmd0aCAtIDFdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxvY3MubGVuZ3RoIC0gMTsgKytpKSB7XG4gICAgICAgICAgICBpbmRleCArPSB0aGlzLnN0cmlkZXNbaV0gKiBsb2NzW2ldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmdldFZhbHVlcygpW2luZGV4XTtcbiAgICB9O1xuICAgIE5EQXJyYXkucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgbG9jcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgbG9jc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICB0aGlzLnNldC5hcHBseSh0aGlzLCBbdGhpcy5nZXQuYXBwbHkodGhpcywgbG9jcykgKyB2YWx1ZV0uY29uY2F0KGxvY3MpKTtcbiAgICB9O1xuICAgIE5EQXJyYXkucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgbG9jcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgbG9jc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICB2YXIgaW5kZXggPSBsb2NzW2xvY3MubGVuZ3RoIC0gMV07XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbG9jcy5sZW5ndGggLSAxOyArK2kpIHtcbiAgICAgICAgICAgIGluZGV4ICs9IHRoaXMuc3RyaWRlc1tpXSAqIGxvY3NbaV07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5nZXRWYWx1ZXMoKVtpbmRleF0gPSB2YWx1ZTtcbiAgICB9O1xuICAgIE5EQXJyYXkucHJvdG90eXBlLnZhbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGxvY3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGxvY3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0LCB0aGlzLmRhdGEoKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiwgdGhpcy5nZXQuYXBwbHkodGhpcywgbG9jcyldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIE5EQXJyYXkucHJvdG90eXBlLmxvY1RvSW5kZXggPSBmdW5jdGlvbiAobG9jcykge1xuICAgICAgICB2YXIgaW5kZXggPSBsb2NzW2xvY3MubGVuZ3RoIC0gMV07XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbG9jcy5sZW5ndGggLSAxOyArK2kpIHtcbiAgICAgICAgICAgIGluZGV4ICs9IHRoaXMuc3RyaWRlc1tpXSAqIGxvY3NbaV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH07XG4gICAgTkRBcnJheS5wcm90b3R5cGUuaW5kZXhUb0xvYyA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICB2YXIgbG9jcyA9IG5ldyBBcnJheSh0aGlzLnNoYXBlLmxlbmd0aCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbG9jcy5sZW5ndGggLSAxOyArK2kpIHtcbiAgICAgICAgICAgIGxvY3NbaV0gPSBNYXRoLmZsb29yKGluZGV4IC8gdGhpcy5zdHJpZGVzW2ldKTtcbiAgICAgICAgICAgIGluZGV4IC09IGxvY3NbaV0gKiB0aGlzLnN0cmlkZXNbaV07XG4gICAgICAgIH1cbiAgICAgICAgbG9jc1tsb2NzLmxlbmd0aCAtIDFdID0gaW5kZXg7XG4gICAgICAgIHJldHVybiBsb2NzO1xuICAgIH07XG4gICAgTkRBcnJheS5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICB0aGlzLmdldFZhbHVlcygpLmZpbGwodmFsdWUpO1xuICAgIH07XG4gICAgTkRBcnJheS5wcm90b3R5cGUuZ2V0RGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmRhcnJheURhdGE7XG4gICAgfTtcbiAgICBOREFycmF5LnByb3RvdHlwZS5nZXRWYWx1ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFTeW5jKCk7XG4gICAgfTtcbiAgICBOREFycmF5LnByb3RvdHlwZS5nZXRWYWx1ZXNBc3luYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YSgpO1xuICAgIH07XG4gICAgTkRBcnJheS5wcm90b3R5cGUuZGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF9hLCBxdWVyeUZuO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2IubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm5kYXJyYXlEYXRhLnZhbHVlcyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyLCB0aGlzLm5kYXJyYXlEYXRhLnZhbHVlc107XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShlbnZpcm9ubWVudF8xLkVOVi5nZXQoJ1dFQkdMX0dFVF9CVUZGRVJfU1VCX0RBVEFfQVNZTkNfRVhURU5TSU9OX0VOQUJMRUQnKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubmRhcnJheURhdGEudGV4dHVyZVR5cGUgPT09IHRleF91dGlsXzEuVGV4dHVyZVR5cGUuREVGQVVMVCkpIHJldHVybiBbMywgMl07XG4gICAgICAgICAgICAgICAgICAgICAgICBfYSA9IHRoaXMubmRhcnJheURhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQsIGV4cG9ydHMuR1BHUFUuZG93bmxvYWRNYXRyaXhGcm9tVGV4dHVyZUFzeW5jKHRoaXMubmRhcnJheURhdGEudGV4dHVyZSwgdGhpcy5uZGFycmF5RGF0YS50ZXh0dXJlU2hhcGVSQ1swXSwgdGhpcy5uZGFycmF5RGF0YS50ZXh0dXJlU2hhcGVSQ1sxXSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS52YWx1ZXMgPSBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIsIHRoaXMubmRhcnJheURhdGEudmFsdWVzXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEhZW52aXJvbm1lbnRfMS5FTlYuZ2V0KCdXRUJHTF9ESVNKT0lOVF9RVUVSWV9USU1FUl9FWFRFTlNJT05fRU5BQkxFRCcpKSByZXR1cm4gWzMsIDRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0LCB0aGlzLmRhdGFTeW5jKCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6IHJldHVybiBbMiwgX2Iuc2VudCgpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnlGbiA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCwgZXhwb3J0cy5HUEdQVS5ydW5RdWVyeShxdWVyeUZuKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiwgdGhpcy5kYXRhU3luYygpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBOREFycmF5LnByb3RvdHlwZS5kYXRhU3luYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgaWYgKHRoaXMubmRhcnJheURhdGEudmFsdWVzID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93SWZHUFVOb3RJbml0aWFsaXplZCgpO1xuICAgICAgICAgICAgdmFyIHZhbHVlcyA9IHZvaWQgMDtcbiAgICAgICAgICAgIGlmICh0aGlzLm5kYXJyYXlEYXRhLnRleHR1cmVUeXBlID09PSB0ZXhfdXRpbF8xLlRleHR1cmVUeXBlLkRFRkFVTFQpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZXMgPSBleHBvcnRzLkdQR1BVLmRvd25sb2FkTWF0cml4RnJvbVRleHR1cmUodGhpcy5uZGFycmF5RGF0YS50ZXh0dXJlLCB0aGlzLm5kYXJyYXlEYXRhLnRleHR1cmVTaGFwZVJDWzBdLCB0aGlzLm5kYXJyYXlEYXRhLnRleHR1cmVTaGFwZVJDWzFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhbHVlcyA9IGV4cG9ydHMuR1BHUFUuZG93bmxvYWRNYXRyaXhGcm9tUkdCQUNvbG9yVGV4dHVyZSh0aGlzLm5kYXJyYXlEYXRhLnRleHR1cmUsIHRoaXMubmRhcnJheURhdGEudGV4dHVyZVNoYXBlUkNbMF0sIHRoaXMubmRhcnJheURhdGEudGV4dHVyZVNoYXBlUkNbMV0sIHRoaXMuc2hhcGVbMl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5uZGFycmF5RGF0YS52YWx1ZXMgPSBmbG9hdDMyVG9UeXBlZEFycmF5KHZhbHVlcywgdGhpcy5kdHlwZSk7XG4gICAgICAgICAgICB0aGlzLmRpc3Bvc2VUZXh0dXJlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubmRhcnJheURhdGEudmFsdWVzO1xuICAgIH07XG4gICAgTkRBcnJheS5wcm90b3R5cGUudXBsb2FkVG9HUFUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRocm93SWZHUFVOb3RJbml0aWFsaXplZCgpO1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICB0aGlzLm5kYXJyYXlEYXRhLnRleHR1cmVTaGFwZVJDID1cbiAgICAgICAgICAgIHdlYmdsX3V0aWwuZ2V0VGV4dHVyZVNoYXBlRnJvbUxvZ2ljYWxTaGFwZShleHBvcnRzLkdQR1BVLmdsLCB0aGlzLnNoYXBlKTtcbiAgICAgICAgdGhpcy5uZGFycmF5RGF0YS50ZXh0dXJlID1cbiAgICAgICAgICAgIGV4cG9ydHMuVEVYVFVSRV9NQU5BR0VSLmFjcXVpcmVUZXh0dXJlKHRoaXMubmRhcnJheURhdGEudGV4dHVyZVNoYXBlUkMpO1xuICAgICAgICB0aGlzLm5kYXJyYXlEYXRhLnRleHR1cmVUeXBlID0gdGV4X3V0aWxfMS5UZXh0dXJlVHlwZS5ERUZBVUxUO1xuICAgICAgICBleHBvcnRzLkdQR1BVLnVwbG9hZE1hdHJpeFRvVGV4dHVyZSh0aGlzLm5kYXJyYXlEYXRhLnRleHR1cmUsIHRoaXMubmRhcnJheURhdGEudGV4dHVyZVNoYXBlUkNbMF0sIHRoaXMubmRhcnJheURhdGEudGV4dHVyZVNoYXBlUkNbMV0sIHR5cGVkQXJyYXlUb0Zsb2F0MzIodGhpcy5uZGFycmF5RGF0YS52YWx1ZXMsIHRoaXMuZHR5cGUpKTtcbiAgICAgICAgdGhpcy5uZGFycmF5RGF0YS52YWx1ZXMgPSBudWxsO1xuICAgIH07XG4gICAgTkRBcnJheS5wcm90b3R5cGUuZ2V0VGV4dHVyZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgaWYgKHRoaXMubmRhcnJheURhdGEudGV4dHVyZSA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnVwbG9hZFRvR1BVKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubmRhcnJheURhdGEudGV4dHVyZTtcbiAgICB9O1xuICAgIE5EQXJyYXkucHJvdG90eXBlLmdldFRleHR1cmVTaGFwZVJDID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICBpZiAodGhpcy5uZGFycmF5RGF0YS50ZXh0dXJlU2hhcGVSQyA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnVwbG9hZFRvR1BVKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubmRhcnJheURhdGEudGV4dHVyZVNoYXBlUkM7XG4gICAgfTtcbiAgICBOREFycmF5LnByb3RvdHlwZS50aHJvd0lmRGlzcG9zZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLm5kYXJyYXlEYXRhLmlzRGlzcG9zZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5EQXJyYXkgaXMgZGlzcG9zZWQuXCIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBOREFycmF5LnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLm5kYXJyYXlEYXRhLnZhbHVlcyA9IG51bGw7XG4gICAgICAgIHRoaXMuc2hhcGUgPSBudWxsO1xuICAgICAgICB0aGlzLm5kYXJyYXlEYXRhLmlzRGlzcG9zZWQgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy5uZGFycmF5RGF0YS50ZXh0dXJlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuZGlzcG9zZVRleHR1cmUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTkRBcnJheS5wcm90b3R5cGUuZGlzcG9zZVRleHR1cmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRocm93SWZHUFVOb3RJbml0aWFsaXplZCgpO1xuICAgICAgICBleHBvcnRzLlRFWFRVUkVfTUFOQUdFUi5yZWxlYXNlVGV4dHVyZSh0aGlzLm5kYXJyYXlEYXRhLnRleHR1cmUsIHRoaXMubmRhcnJheURhdGEudGV4dHVyZVNoYXBlUkMpO1xuICAgICAgICB0aGlzLm5kYXJyYXlEYXRhLnRleHR1cmUgPSBudWxsO1xuICAgICAgICB0aGlzLm5kYXJyYXlEYXRhLnRleHR1cmVTaGFwZVJDID0gbnVsbDtcbiAgICAgICAgdGhpcy5uZGFycmF5RGF0YS50ZXh0dXJlVHlwZSA9IG51bGw7XG4gICAgfTtcbiAgICBOREFycmF5LnByb3RvdHlwZS5pbkdQVSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubmRhcnJheURhdGEudGV4dHVyZSAhPSBudWxsO1xuICAgIH07XG4gICAgTkRBcnJheS5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZHR5cGUgPT09IHQuZHR5cGUgJiYgdXRpbC5hcnJheXNFcXVhbCh0aGlzLnNoYXBlLCB0LnNoYXBlKSAmJlxuICAgICAgICAgICAgdXRpbC5hcnJheXNFcXVhbCh0aGlzLmdldFZhbHVlcygpLCB0LmdldFZhbHVlcygpKTtcbiAgICB9O1xuICAgIE5EQXJyYXkucmFuZCA9IGZ1bmN0aW9uIChzaGFwZSwgcmFuZEZ1bmN0aW9uKSB7XG4gICAgICAgIHZhciBzaXplID0gdXRpbC5zaXplRnJvbVNoYXBlKHNoYXBlKTtcbiAgICAgICAgdmFyIHZhbHVlcyA9IG5ldyBGbG9hdDMyQXJyYXkoc2l6ZSk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICB2YWx1ZXNbaV0gPSByYW5kRnVuY3Rpb24oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gTkRBcnJheS5tYWtlKHNoYXBlLCB7IHZhbHVlczogdmFsdWVzIH0pO1xuICAgIH07XG4gICAgTkRBcnJheS5yYW5kTm9ybWFsID0gZnVuY3Rpb24gKHNoYXBlLCBtZWFuLCBzdGREZXYpIHtcbiAgICAgICAgaWYgKG1lYW4gPT09IHZvaWQgMCkgeyBtZWFuID0gMDsgfVxuICAgICAgICBpZiAoc3RkRGV2ID09PSB2b2lkIDApIHsgc3RkRGV2ID0gMTsgfVxuICAgICAgICByZXR1cm4gTkRBcnJheS5yYW5kKHNoYXBlLCBmdW5jdGlvbiAoKSB7IHJldHVybiB1dGlsLnJhbmRHYXVzcyhtZWFuLCBzdGREZXYpOyB9KTtcbiAgICB9O1xuICAgIE5EQXJyYXkucmFuZFRydW5jYXRlZE5vcm1hbCA9IGZ1bmN0aW9uIChzaGFwZSwgbWVhbiwgc3RkRGV2KSB7XG4gICAgICAgIGlmIChtZWFuID09PSB2b2lkIDApIHsgbWVhbiA9IDA7IH1cbiAgICAgICAgaWYgKHN0ZERldiA9PT0gdm9pZCAwKSB7IHN0ZERldiA9IDE7IH1cbiAgICAgICAgcmV0dXJuIE5EQXJyYXkucmFuZChzaGFwZSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gdXRpbC5yYW5kR2F1c3MobWVhbiwgc3RkRGV2LCB0cnVlKTsgfSk7XG4gICAgfTtcbiAgICBOREFycmF5LnJhbmRVbmlmb3JtID0gZnVuY3Rpb24gKHNoYXBlLCBhLCBiKSB7XG4gICAgICAgIHJldHVybiBOREFycmF5LnJhbmQoc2hhcGUsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHV0aWwucmFuZFVuaWZvcm0oYSwgYik7IH0pO1xuICAgIH07XG4gICAgcmV0dXJuIE5EQXJyYXk7XG59KCkpO1xuZXhwb3J0cy5OREFycmF5ID0gTkRBcnJheTtcbnZhciBTY2FsYXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTY2FsYXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU2NhbGFyKGRhdGEsIGR0eXBlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChkYXRhLnRleHR1cmUgIT0gbnVsbCkge1xuICAgICAgICAgICAgZGF0YS50ZXh0dXJlU2hhcGVSQyA9IFsxLCAxXTtcbiAgICAgICAgfVxuICAgICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIFtdLCBkYXRhLCBkdHlwZSkgfHwgdGhpcztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBTY2FsYXIubmV3ID0gZnVuY3Rpb24gKHZhbHVlLCBkdHlwZSkge1xuICAgICAgICB2YXIgdmFsdWVzID0gW3ZhbHVlXTtcbiAgICAgICAgcmV0dXJuIG5ldyBTY2FsYXIoeyB2YWx1ZXM6IHRvVHlwZWRBcnJheSh2YWx1ZXMsIGR0eXBlKSB9LCBkdHlwZSk7XG4gICAgfTtcbiAgICBTY2FsYXIucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VmFsdWVzKClbMF07XG4gICAgfTtcbiAgICBTY2FsYXIucHJvdG90eXBlLnZhbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQsIHRoaXMuZGF0YSgpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyLCB0aGlzLmdldCgpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBTY2FsYXIucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0aGlzLmdldFZhbHVlcygpWzBdID0gdmFsdWU7XG4gICAgfTtcbiAgICBTY2FsYXIucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0aGlzLmdldFZhbHVlcygpWzBdICs9IHZhbHVlO1xuICAgIH07XG4gICAgU2NhbGFyLnByb3RvdHlwZS5hc1R5cGUgPSBmdW5jdGlvbiAoZHR5cGUpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUuYXNUeXBlLmNhbGwodGhpcywgZHR5cGUpO1xuICAgIH07XG4gICAgU2NhbGFyLnByb3RvdHlwZS5sb2NUb0luZGV4ID0gZnVuY3Rpb24gKGxvYykge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9O1xuICAgIFNjYWxhci5wcm90b3R5cGUuaW5kZXhUb0xvYyA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfTtcbiAgICBTY2FsYXIuWkVSTyA9IFNjYWxhci5uZXcoMCk7XG4gICAgU2NhbGFyLk9ORSA9IFNjYWxhci5uZXcoMSk7XG4gICAgU2NhbGFyLlRXTyA9IFNjYWxhci5uZXcoMik7XG4gICAgU2NhbGFyLk5FR19PTkUgPSBTY2FsYXIubmV3KC0xKTtcbiAgICByZXR1cm4gU2NhbGFyO1xufShOREFycmF5KSk7XG5leHBvcnRzLlNjYWxhciA9IFNjYWxhcjtcbnZhciBBcnJheTFEID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQXJyYXkxRCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBcnJheTFEKGRhdGEsIGR0eXBlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBzaGFwZSA9IChkYXRhLnZhbHVlcyAhPSBudWxsKSA/XG4gICAgICAgICAgICBbZGF0YS52YWx1ZXMubGVuZ3RoXSA6XG4gICAgICAgICAgICBbdXRpbC5zaXplRnJvbVNoYXBlKGRhdGEudGV4dHVyZVNoYXBlUkMpXTtcbiAgICAgICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBzaGFwZSwgZGF0YSwgZHR5cGUpIHx8IHRoaXM7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgQXJyYXkxRC5uZXcgPSBmdW5jdGlvbiAodmFsdWVzLCBkdHlwZSkge1xuICAgICAgICBpZiAoIWluc3RhbmNlb2ZUeXBlZEFycmF5KHZhbHVlcykpIHtcbiAgICAgICAgICAgIHZhciBpbmZlcnJlZFNoYXBlID0gdXRpbC5pbmZlclNoYXBlKHZhbHVlcyk7XG4gICAgICAgICAgICB1dGlsLmFzc2VydChpbmZlcnJlZFNoYXBlLmxlbmd0aCA9PT0gMSwgXCJFcnJvciBjb25zdHJ1Y3RpbmcgQXJyYXkxRC4gU2hhcGUgb2YgdmFsdWVzIFwiICsgaW5mZXJyZWRTaGFwZSArIFwiIGlzIFwiICtcbiAgICAgICAgICAgICAgICBcIm5vdCAxIGRpbWVuc2lvbmFsLlwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEFycmF5MUQoeyB2YWx1ZXM6IHRvVHlwZWRBcnJheSh2YWx1ZXMsIGR0eXBlKSB9LCBkdHlwZSk7XG4gICAgfTtcbiAgICBBcnJheTFELnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoaSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRWYWx1ZXMoKVtpXTtcbiAgICB9O1xuICAgIEFycmF5MUQucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uICh2YWx1ZSwgaSkge1xuICAgICAgICB0aGlzLmdldFZhbHVlcygpW2ldID0gdmFsdWU7XG4gICAgfTtcbiAgICBBcnJheTFELnByb3RvdHlwZS52YWwgPSBmdW5jdGlvbiAoaSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCwgdGhpcy5kYXRhKCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIsIHRoaXMuZ2V0KGkpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBBcnJheTFELnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAodmFsdWUsIGkpIHtcbiAgICAgICAgdGhpcy5nZXRWYWx1ZXMoKVtpXSArPSB2YWx1ZTtcbiAgICB9O1xuICAgIEFycmF5MUQucHJvdG90eXBlLmxvY1RvSW5kZXggPSBmdW5jdGlvbiAobG9jKSB7XG4gICAgICAgIHJldHVybiBsb2NbMF07XG4gICAgfTtcbiAgICBBcnJheTFELnByb3RvdHlwZS5pbmRleFRvTG9jID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgIHJldHVybiBbaW5kZXhdO1xuICAgIH07XG4gICAgQXJyYXkxRC5wcm90b3R5cGUuYXNUeXBlID0gZnVuY3Rpb24gKGR0eXBlKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLmFzVHlwZS5jYWxsKHRoaXMsIGR0eXBlKTtcbiAgICB9O1xuICAgIEFycmF5MUQuemVyb3MgPSBmdW5jdGlvbiAoc2hhcGUsIGR0eXBlKSB7XG4gICAgICAgIHJldHVybiBOREFycmF5Lnplcm9zKHNoYXBlLCBkdHlwZSk7XG4gICAgfTtcbiAgICBBcnJheTFELnJhbmROb3JtYWwgPSBmdW5jdGlvbiAoc2hhcGUsIG1lYW4sIHN0ZERldikge1xuICAgICAgICBpZiAobWVhbiA9PT0gdm9pZCAwKSB7IG1lYW4gPSAwOyB9XG4gICAgICAgIGlmIChzdGREZXYgPT09IHZvaWQgMCkgeyBzdGREZXYgPSAxOyB9XG4gICAgICAgIHJldHVybiBOREFycmF5LnJhbmQoc2hhcGUsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHV0aWwucmFuZEdhdXNzKG1lYW4sIHN0ZERldik7IH0pO1xuICAgIH07XG4gICAgQXJyYXkxRC5yYW5kVHJ1bmNhdGVkTm9ybWFsID0gZnVuY3Rpb24gKHNoYXBlLCBtZWFuLCBzdGREZXYpIHtcbiAgICAgICAgaWYgKG1lYW4gPT09IHZvaWQgMCkgeyBtZWFuID0gMDsgfVxuICAgICAgICBpZiAoc3RkRGV2ID09PSB2b2lkIDApIHsgc3RkRGV2ID0gMTsgfVxuICAgICAgICByZXR1cm4gTkRBcnJheS5yYW5kKHNoYXBlLCBmdW5jdGlvbiAoKSB7IHJldHVybiB1dGlsLnJhbmRHYXVzcyhtZWFuLCBzdGREZXYsIHRydWUpOyB9KTtcbiAgICB9O1xuICAgIEFycmF5MUQucmFuZFVuaWZvcm0gPSBmdW5jdGlvbiAoc2hhcGUsIGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIE5EQXJyYXkucmFuZChzaGFwZSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gdXRpbC5yYW5kVW5pZm9ybShhLCBiKTsgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gQXJyYXkxRDtcbn0oTkRBcnJheSkpO1xuZXhwb3J0cy5BcnJheTFEID0gQXJyYXkxRDtcbnZhciBBcnJheTJEID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQXJyYXkyRCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBcnJheTJEKHNoYXBlLCBkYXRhLCBkdHlwZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB1dGlsLmFzc2VydChzaGFwZS5sZW5ndGggPT09IDIsICdTaGFwZSBzaG91bGQgYmUgb2YgbGVuZ3RoIDInKTtcbiAgICAgICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBzaGFwZSwgZGF0YSwgZHR5cGUpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnN0cmlkZTAgPSBfdGhpcy5zdHJpZGVzWzBdO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEFycmF5MkQubmV3ID0gZnVuY3Rpb24gKHNoYXBlLCB2YWx1ZXMsIGR0eXBlKSB7XG4gICAgICAgIGlmICghaW5zdGFuY2VvZlR5cGVkQXJyYXkodmFsdWVzKSkge1xuICAgICAgICAgICAgdmFyIGluZmVycmVkU2hhcGUgPSB1dGlsLmluZmVyU2hhcGUodmFsdWVzKTtcbiAgICAgICAgICAgIGlmIChpbmZlcnJlZFNoYXBlLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICB1dGlsLmFzc2VydFNoYXBlc01hdGNoKHNoYXBlLCBpbmZlcnJlZFNoYXBlLCBcIkVycm9yIHdoZW4gY29uc3RydWN0aW5nIEFycmF5MkQuIFNoYXBlIG9mIHZhbHVlcyBcIiArXG4gICAgICAgICAgICAgICAgICAgIChpbmZlcnJlZFNoYXBlICsgXCIgZG9lcyBub3QgbWF0Y2ggdGhlIHByb3ZpZGVkIHNoYXBlIFwiKSArXG4gICAgICAgICAgICAgICAgICAgIChzaGFwZSArIFwiLiBcIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQXJyYXkyRChzaGFwZSwgeyB2YWx1ZXM6IHRvVHlwZWRBcnJheSh2YWx1ZXMsIGR0eXBlKSB9LCBkdHlwZSk7XG4gICAgfTtcbiAgICBBcnJheTJELnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoaSwgaikge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRWYWx1ZXMoKVt0aGlzLnN0cmlkZTAgKiBpICsgal07XG4gICAgfTtcbiAgICBBcnJheTJELnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAodmFsdWUsIGksIGopIHtcbiAgICAgICAgdGhpcy5nZXRWYWx1ZXMoKVt0aGlzLnN0cmlkZTAgKiBpICsgal0gPSB2YWx1ZTtcbiAgICB9O1xuICAgIEFycmF5MkQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uICh2YWx1ZSwgaSwgaikge1xuICAgICAgICB0aGlzLmdldFZhbHVlcygpW3RoaXMuc3RyaWRlMCAqIGkgKyBqXSArPSB2YWx1ZTtcbiAgICB9O1xuICAgIEFycmF5MkQucHJvdG90eXBlLnZhbCA9IGZ1bmN0aW9uIChpLCBqKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0LCB0aGlzLmRhdGEoKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiwgdGhpcy5nZXQoaSwgaildO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEFycmF5MkQucHJvdG90eXBlLmxvY1RvSW5kZXggPSBmdW5jdGlvbiAobG9jcykge1xuICAgICAgICByZXR1cm4gdGhpcy5zdHJpZGUwICogbG9jc1swXSArIGxvY3NbMV07XG4gICAgfTtcbiAgICBBcnJheTJELnByb3RvdHlwZS5pbmRleFRvTG9jID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgIHJldHVybiBbTWF0aC5mbG9vcihpbmRleCAvIHRoaXMuc3RyaWRlMCksIGluZGV4ICUgdGhpcy5zdHJpZGUwXTtcbiAgICB9O1xuICAgIEFycmF5MkQucHJvdG90eXBlLmFzVHlwZSA9IGZ1bmN0aW9uIChkdHlwZSkge1xuICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS5hc1R5cGUuY2FsbCh0aGlzLCBkdHlwZSk7XG4gICAgfTtcbiAgICBBcnJheTJELnplcm9zID0gZnVuY3Rpb24gKHNoYXBlLCBkdHlwZSkge1xuICAgICAgICByZXR1cm4gTkRBcnJheS56ZXJvcyhzaGFwZSwgZHR5cGUpO1xuICAgIH07XG4gICAgQXJyYXkyRC5yYW5kTm9ybWFsID0gZnVuY3Rpb24gKHNoYXBlLCBtZWFuLCBzdGREZXYpIHtcbiAgICAgICAgaWYgKG1lYW4gPT09IHZvaWQgMCkgeyBtZWFuID0gMDsgfVxuICAgICAgICBpZiAoc3RkRGV2ID09PSB2b2lkIDApIHsgc3RkRGV2ID0gMTsgfVxuICAgICAgICByZXR1cm4gTkRBcnJheS5yYW5kKHNoYXBlLCBmdW5jdGlvbiAoKSB7IHJldHVybiB1dGlsLnJhbmRHYXVzcyhtZWFuLCBzdGREZXYpOyB9KTtcbiAgICB9O1xuICAgIEFycmF5MkQucmFuZFRydW5jYXRlZE5vcm1hbCA9IGZ1bmN0aW9uIChzaGFwZSwgbWVhbiwgc3RkRGV2KSB7XG4gICAgICAgIGlmIChtZWFuID09PSB2b2lkIDApIHsgbWVhbiA9IDA7IH1cbiAgICAgICAgaWYgKHN0ZERldiA9PT0gdm9pZCAwKSB7IHN0ZERldiA9IDE7IH1cbiAgICAgICAgcmV0dXJuIE5EQXJyYXkucmFuZChzaGFwZSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gdXRpbC5yYW5kR2F1c3MobWVhbiwgc3RkRGV2LCB0cnVlKTsgfSk7XG4gICAgfTtcbiAgICBBcnJheTJELnJhbmRVbmlmb3JtID0gZnVuY3Rpb24gKHNoYXBlLCBhLCBiKSB7XG4gICAgICAgIHJldHVybiBOREFycmF5LnJhbmQoc2hhcGUsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHV0aWwucmFuZFVuaWZvcm0oYSwgYik7IH0pO1xuICAgIH07XG4gICAgcmV0dXJuIEFycmF5MkQ7XG59KE5EQXJyYXkpKTtcbmV4cG9ydHMuQXJyYXkyRCA9IEFycmF5MkQ7XG52YXIgQXJyYXkzRCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFycmF5M0QsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQXJyYXkzRChzaGFwZSwgZGF0YSwgZHR5cGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdXRpbC5hc3NlcnQoc2hhcGUubGVuZ3RoID09PSAzLCAnU2hhcGUgc2hvdWxkIGJlIG9mIGxlbmd0aCAzJyk7XG4gICAgICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgc2hhcGUsIGRhdGEsIGR0eXBlKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5zdHJpZGUwID0gX3RoaXMuc3RyaWRlc1swXTtcbiAgICAgICAgX3RoaXMuc3RyaWRlMSA9IF90aGlzLnN0cmlkZXNbMV07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgQXJyYXkzRC5uZXcgPSBmdW5jdGlvbiAoc2hhcGUsIHZhbHVlcywgZHR5cGUpIHtcbiAgICAgICAgaWYgKCFpbnN0YW5jZW9mVHlwZWRBcnJheSh2YWx1ZXMpKSB7XG4gICAgICAgICAgICB2YXIgaW5mZXJyZWRTaGFwZSA9IHV0aWwuaW5mZXJTaGFwZSh2YWx1ZXMpO1xuICAgICAgICAgICAgaWYgKGluZmVycmVkU2hhcGUubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIHV0aWwuYXNzZXJ0U2hhcGVzTWF0Y2goc2hhcGUsIGluZmVycmVkU2hhcGUsIFwiRXJyb3Igd2hlbiBjb25zdHJ1Y3RpbmcgQXJyYXkzRC4gU2hhcGUgb2YgdmFsdWVzIFwiICtcbiAgICAgICAgICAgICAgICAgICAgKGluZmVycmVkU2hhcGUgKyBcIiBkb2VzIG5vdCBtYXRjaCB0aGUgcHJvdmlkZWQgc2hhcGUgXCIpICtcbiAgICAgICAgICAgICAgICAgICAgKHNoYXBlICsgXCIuIFwiKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBBcnJheTNEKHNoYXBlLCB7IHZhbHVlczogdG9UeXBlZEFycmF5KHZhbHVlcywgZHR5cGUpIH0sIGR0eXBlKTtcbiAgICB9O1xuICAgIEFycmF5M0QucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChpLCBqLCBrKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFZhbHVlcygpW3RoaXMuc3RyaWRlMCAqIGkgKyB0aGlzLnN0cmlkZTEgKiBqICsga107XG4gICAgfTtcbiAgICBBcnJheTNELnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAodmFsdWUsIGksIGosIGspIHtcbiAgICAgICAgdGhpcy5nZXRWYWx1ZXMoKVt0aGlzLnN0cmlkZTAgKiBpICsgdGhpcy5zdHJpZGUxICogaiArIGtdID0gdmFsdWU7XG4gICAgfTtcbiAgICBBcnJheTNELnByb3RvdHlwZS52YWwgPSBmdW5jdGlvbiAoaSwgaiwgaykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCwgdGhpcy5kYXRhKCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIsIHRoaXMuZ2V0KGksIGosIGspXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBBcnJheTNELnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAodmFsdWUsIGksIGosIGspIHtcbiAgICAgICAgdGhpcy5nZXRWYWx1ZXMoKVt0aGlzLnN0cmlkZTAgKiBpICsgdGhpcy5zdHJpZGUxICogaiArIGtdICs9IHZhbHVlO1xuICAgIH07XG4gICAgQXJyYXkzRC5wcm90b3R5cGUubG9jVG9JbmRleCA9IGZ1bmN0aW9uIChsb2NzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0cmlkZTAgKiBsb2NzWzBdICsgdGhpcy5zdHJpZGUxICogbG9jc1sxXSArIGxvY3NbMl07XG4gICAgfTtcbiAgICBBcnJheTNELnByb3RvdHlwZS5pbmRleFRvTG9jID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgIHZhciBpID0gTWF0aC5mbG9vcihpbmRleCAvIHRoaXMuc3RyaWRlMCk7XG4gICAgICAgIGluZGV4IC09IGkgKiB0aGlzLnN0cmlkZTA7XG4gICAgICAgIHJldHVybiBbaSwgTWF0aC5mbG9vcihpbmRleCAvIHRoaXMuc3RyaWRlMSksIGluZGV4ICUgdGhpcy5zdHJpZGUxXTtcbiAgICB9O1xuICAgIEFycmF5M0QucHJvdG90eXBlLmFzVHlwZSA9IGZ1bmN0aW9uIChkdHlwZSkge1xuICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS5hc1R5cGUuY2FsbCh0aGlzLCBkdHlwZSk7XG4gICAgfTtcbiAgICBBcnJheTNELnplcm9zID0gZnVuY3Rpb24gKHNoYXBlLCBkdHlwZSkge1xuICAgICAgICByZXR1cm4gTkRBcnJheS56ZXJvcyhzaGFwZSwgZHR5cGUpO1xuICAgIH07XG4gICAgQXJyYXkzRC5yYW5kTm9ybWFsID0gZnVuY3Rpb24gKHNoYXBlLCBtZWFuLCBzdGREZXYpIHtcbiAgICAgICAgaWYgKG1lYW4gPT09IHZvaWQgMCkgeyBtZWFuID0gMDsgfVxuICAgICAgICBpZiAoc3RkRGV2ID09PSB2b2lkIDApIHsgc3RkRGV2ID0gMTsgfVxuICAgICAgICByZXR1cm4gTkRBcnJheS5yYW5kKHNoYXBlLCBmdW5jdGlvbiAoKSB7IHJldHVybiB1dGlsLnJhbmRHYXVzcyhtZWFuLCBzdGREZXYpOyB9KTtcbiAgICB9O1xuICAgIEFycmF5M0QucmFuZFRydW5jYXRlZE5vcm1hbCA9IGZ1bmN0aW9uIChzaGFwZSwgbWVhbiwgc3RkRGV2KSB7XG4gICAgICAgIGlmIChtZWFuID09PSB2b2lkIDApIHsgbWVhbiA9IDA7IH1cbiAgICAgICAgaWYgKHN0ZERldiA9PT0gdm9pZCAwKSB7IHN0ZERldiA9IDE7IH1cbiAgICAgICAgcmV0dXJuIE5EQXJyYXkucmFuZChzaGFwZSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gdXRpbC5yYW5kR2F1c3MobWVhbiwgc3RkRGV2LCB0cnVlKTsgfSk7XG4gICAgfTtcbiAgICBBcnJheTNELnJhbmRVbmlmb3JtID0gZnVuY3Rpb24gKHNoYXBlLCBhLCBiKSB7XG4gICAgICAgIHJldHVybiBOREFycmF5LnJhbmQoc2hhcGUsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHV0aWwucmFuZFVuaWZvcm0oYSwgYik7IH0pO1xuICAgIH07XG4gICAgcmV0dXJuIEFycmF5M0Q7XG59KE5EQXJyYXkpKTtcbmV4cG9ydHMuQXJyYXkzRCA9IEFycmF5M0Q7XG52YXIgQXJyYXk0RCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFycmF5NEQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQXJyYXk0RChzaGFwZSwgZGF0YSwgZHR5cGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdXRpbC5hc3NlcnQoc2hhcGUubGVuZ3RoID09PSA0LCAnU2hhcGUgc2hvdWxkIGJlIG9mIGxlbmd0aCA0Jyk7XG4gICAgICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgc2hhcGUsIGRhdGEsIGR0eXBlKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5zdHJpZGUwID0gX3RoaXMuc3RyaWRlc1swXTtcbiAgICAgICAgX3RoaXMuc3RyaWRlMSA9IF90aGlzLnN0cmlkZXNbMV07XG4gICAgICAgIF90aGlzLnN0cmlkZTIgPSBfdGhpcy5zdHJpZGVzWzJdO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEFycmF5NEQubmV3ID0gZnVuY3Rpb24gKHNoYXBlLCB2YWx1ZXMsIGR0eXBlKSB7XG4gICAgICAgIGlmICghaW5zdGFuY2VvZlR5cGVkQXJyYXkodmFsdWVzKSkge1xuICAgICAgICAgICAgdmFyIGluZmVycmVkU2hhcGUgPSB1dGlsLmluZmVyU2hhcGUodmFsdWVzKTtcbiAgICAgICAgICAgIGlmIChpbmZlcnJlZFNoYXBlLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICB1dGlsLmFzc2VydFNoYXBlc01hdGNoKHNoYXBlLCBpbmZlcnJlZFNoYXBlLCBcIkVycm9yIHdoZW4gY29uc3RydWN0aW5nIEFycmF5NEQuIFNoYXBlIG9mIHZhbHVlcyBcIiArXG4gICAgICAgICAgICAgICAgICAgIChpbmZlcnJlZFNoYXBlICsgXCIgZG9lcyBub3QgbWF0Y2ggdGhlIHByb3ZpZGVkIHNoYXBlIFwiKSArXG4gICAgICAgICAgICAgICAgICAgIChzaGFwZSArIFwiLiBcIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQXJyYXk0RChzaGFwZSwgeyB2YWx1ZXM6IHRvVHlwZWRBcnJheSh2YWx1ZXMsIGR0eXBlKSB9LCBkdHlwZSk7XG4gICAgfTtcbiAgICBBcnJheTRELnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoaSwgaiwgaywgbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRWYWx1ZXMoKVt0aGlzLnN0cmlkZTAgKiBpICsgdGhpcy5zdHJpZGUxICogaiArIHRoaXMuc3RyaWRlMiAqIGsgKyBsXTtcbiAgICB9O1xuICAgIEFycmF5NEQucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uICh2YWx1ZSwgaSwgaiwgaywgbCkge1xuICAgICAgICB0aGlzLmdldFZhbHVlcygpW3RoaXMuc3RyaWRlMCAqIGkgKyB0aGlzLnN0cmlkZTEgKiBqICsgdGhpcy5zdHJpZGUyICogayArIGxdID0gdmFsdWU7XG4gICAgfTtcbiAgICBBcnJheTRELnByb3RvdHlwZS52YWwgPSBmdW5jdGlvbiAoaSwgaiwgaywgbCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCwgdGhpcy5kYXRhKCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIsIHRoaXMuZ2V0KGksIGosIGssIGwpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBBcnJheTRELnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAodmFsdWUsIGksIGosIGssIGwpIHtcbiAgICAgICAgdGhpcy5nZXRWYWx1ZXMoKVt0aGlzLnN0cmlkZTAgKiBpICsgdGhpcy5zdHJpZGUxICogaiArIHRoaXMuc3RyaWRlMiAqIGsgKyBsXSArPSB2YWx1ZTtcbiAgICB9O1xuICAgIEFycmF5NEQucHJvdG90eXBlLmxvY1RvSW5kZXggPSBmdW5jdGlvbiAobG9jcykge1xuICAgICAgICByZXR1cm4gdGhpcy5zdHJpZGUwICogbG9jc1swXSArIHRoaXMuc3RyaWRlMSAqIGxvY3NbMV0gK1xuICAgICAgICAgICAgdGhpcy5zdHJpZGUyICogbG9jc1syXSArIGxvY3NbM107XG4gICAgfTtcbiAgICBBcnJheTRELnByb3RvdHlwZS5pbmRleFRvTG9jID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgIHZhciBpID0gTWF0aC5mbG9vcihpbmRleCAvIHRoaXMuc3RyaWRlMCk7XG4gICAgICAgIGluZGV4IC09IGkgKiB0aGlzLnN0cmlkZTA7XG4gICAgICAgIHZhciBqID0gTWF0aC5mbG9vcihpbmRleCAvIHRoaXMuc3RyaWRlMSk7XG4gICAgICAgIGluZGV4IC09IGogKiB0aGlzLnN0cmlkZTE7XG4gICAgICAgIHJldHVybiBbaSwgaiwgTWF0aC5mbG9vcihpbmRleCAvIHRoaXMuc3RyaWRlMiksIGluZGV4ICUgdGhpcy5zdHJpZGUyXTtcbiAgICB9O1xuICAgIEFycmF5NEQucHJvdG90eXBlLmFzVHlwZSA9IGZ1bmN0aW9uIChkdHlwZSkge1xuICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS5hc1R5cGUuY2FsbCh0aGlzLCBkdHlwZSk7XG4gICAgfTtcbiAgICBBcnJheTRELnplcm9zID0gZnVuY3Rpb24gKHNoYXBlLCBkdHlwZSkge1xuICAgICAgICByZXR1cm4gTkRBcnJheS56ZXJvcyhzaGFwZSwgZHR5cGUpO1xuICAgIH07XG4gICAgQXJyYXk0RC5yYW5kTm9ybWFsID0gZnVuY3Rpb24gKHNoYXBlLCBtZWFuLCBzdGREZXYpIHtcbiAgICAgICAgaWYgKG1lYW4gPT09IHZvaWQgMCkgeyBtZWFuID0gMDsgfVxuICAgICAgICBpZiAoc3RkRGV2ID09PSB2b2lkIDApIHsgc3RkRGV2ID0gMTsgfVxuICAgICAgICByZXR1cm4gTkRBcnJheS5yYW5kKHNoYXBlLCBmdW5jdGlvbiAoKSB7IHJldHVybiB1dGlsLnJhbmRHYXVzcyhtZWFuLCBzdGREZXYpOyB9KTtcbiAgICB9O1xuICAgIEFycmF5NEQucmFuZFRydW5jYXRlZE5vcm1hbCA9IGZ1bmN0aW9uIChzaGFwZSwgbWVhbiwgc3RkRGV2KSB7XG4gICAgICAgIGlmIChtZWFuID09PSB2b2lkIDApIHsgbWVhbiA9IDA7IH1cbiAgICAgICAgaWYgKHN0ZERldiA9PT0gdm9pZCAwKSB7IHN0ZERldiA9IDE7IH1cbiAgICAgICAgcmV0dXJuIE5EQXJyYXkucmFuZChzaGFwZSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gdXRpbC5yYW5kR2F1c3MobWVhbiwgc3RkRGV2LCB0cnVlKTsgfSk7XG4gICAgfTtcbiAgICBBcnJheTRELnJhbmRVbmlmb3JtID0gZnVuY3Rpb24gKHNoYXBlLCBhLCBiKSB7XG4gICAgICAgIHJldHVybiBOREFycmF5LnJhbmQoc2hhcGUsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHV0aWwucmFuZFVuaWZvcm0oYSwgYik7IH0pO1xuICAgIH07XG4gICAgcmV0dXJuIEFycmF5NEQ7XG59KE5EQXJyYXkpKTtcbmV4cG9ydHMuQXJyYXk0RCA9IEFycmF5NEQ7XG5mdW5jdGlvbiBjb3B5VHlwZWRBcnJheShhcnJheSwgZHR5cGUpIHtcbiAgICBpZiAoZHR5cGUgPT0gbnVsbCB8fCBkdHlwZSA9PT0gJ2Zsb2F0MzInKSB7XG4gICAgICAgIHJldHVybiBuZXcgRmxvYXQzMkFycmF5KGFycmF5KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZHR5cGUgPT09ICdpbnQzMicpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBJbnQzMkFycmF5KGFycmF5KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZHR5cGUgPT09ICdib29sJykge1xuICAgICAgICB2YXIgYm9vbCA9IG5ldyBVaW50OEFycmF5KGFycmF5Lmxlbmd0aCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYm9vbC5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIHZhbCA9IGFycmF5W2ldO1xuICAgICAgICAgICAgaWYgKHV0aWwuaXNWYWxOYU4odmFsLCAnYm9vbCcpKSB7XG4gICAgICAgICAgICAgICAgYm9vbFtpXSA9IHV0aWwuZ2V0TmFOKCdib29sJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWwpIHtcbiAgICAgICAgICAgICAgICBib29sW2ldID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYm9vbDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gZGF0YSB0eXBlIFwiICsgZHR5cGUpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGluc3RhbmNlb2ZUeXBlZEFycmF5KGEpIHtcbiAgICByZXR1cm4gYSBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSB8fCBhIGluc3RhbmNlb2YgSW50MzJBcnJheSB8fFxuICAgICAgICBhIGluc3RhbmNlb2YgVWludDhBcnJheTtcbn1cbmZ1bmN0aW9uIG5vQ29udmVyc2lvbk5lZWRlZChhLCBkdHlwZSkge1xuICAgIHJldHVybiAoYSBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSAmJiBkdHlwZSA9PT0gJ2Zsb2F0MzInKSB8fFxuICAgICAgICAoYSBpbnN0YW5jZW9mIEludDMyQXJyYXkgJiYgZHR5cGUgPT09ICdpbnQzMicpIHx8XG4gICAgICAgIChhIGluc3RhbmNlb2YgVWludDhBcnJheSAmJiBkdHlwZSA9PT0gJ2Jvb2wnKTtcbn1cbmZ1bmN0aW9uIHRvVHlwZWRBcnJheShhLCBkdHlwZSkge1xuICAgIGlmIChub0NvbnZlcnNpb25OZWVkZWQoYSwgZHR5cGUpKSB7XG4gICAgICAgIHJldHVybiBhO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShhKSkge1xuICAgICAgICBhID0gdXRpbC5mbGF0dGVuKGEpO1xuICAgIH1cbiAgICByZXR1cm4gY29weVR5cGVkQXJyYXkoYSwgZHR5cGUpO1xufVxuZnVuY3Rpb24gbWFrZVplcm9zVHlwZWRBcnJheShzaXplLCBkdHlwZSkge1xuICAgIGlmIChkdHlwZSA9PSBudWxsIHx8IGR0eXBlID09PSAnZmxvYXQzMicpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoc2l6ZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGR0eXBlID09PSAnaW50MzInKSB7XG4gICAgICAgIHJldHVybiBuZXcgSW50MzJBcnJheShzaXplKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZHR5cGUgPT09ICdib29sJykge1xuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoc2l6ZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGRhdGEgdHlwZSBcIiArIGR0eXBlKTtcbiAgICB9XG59XG5mdW5jdGlvbiB0eXBlZEFycmF5VG9GbG9hdDMyKGEsIGR0eXBlKSB7XG4gICAgaWYgKGEgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIGE7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YXIgcmVzID0gbmV3IEZsb2F0MzJBcnJheShhLmxlbmd0aCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgdmFsID0gYVtpXTtcbiAgICAgICAgICAgIHJlc1tpXSA9IHV0aWwuaXNWYWxOYU4odmFsLCBkdHlwZSkgPyBOYU4gOiB2YWw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG59XG5mdW5jdGlvbiBmbG9hdDMyVG9UeXBlZEFycmF5KGEsIGR0eXBlKSB7XG4gICAgaWYgKGR0eXBlID09PSAnZmxvYXQzMicpIHtcbiAgICAgICAgcmV0dXJuIGE7XG4gICAgfVxuICAgIGVsc2UgaWYgKGR0eXBlID09PSAnaW50MzInIHx8IGR0eXBlID09PSAnYm9vbCcpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IChkdHlwZSA9PT0gJ2ludDMyJykgPyBuZXcgSW50MzJBcnJheShhLmxlbmd0aCkgOlxuICAgICAgICAgICAgbmV3IFVpbnQ4QXJyYXkoYS5sZW5ndGgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlc3VsdC5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIHZhbCA9IGFbaV07XG4gICAgICAgICAgICB2YWwgPSBpc05hTih2YWwpID8gdXRpbC5nZXROYU4oZHR5cGUpIDogTWF0aC5yb3VuZCh2YWwpO1xuICAgICAgICAgICAgcmVzdWx0W2ldID0gdmFsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGR0eXBlIFwiICsgZHR5cGUpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5kYXJyYXkuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlBBUkFMTEVMSVpFX1RIUkVTSE9MRCA9IDMwO1xuZnVuY3Rpb24gY29tcHV0ZU9wdGltYWxXaW5kb3dTaXplKGluU2l6ZSkge1xuICAgIGlmIChpblNpemUgPD0gZXhwb3J0cy5QQVJBTExFTElaRV9USFJFU0hPTEQpIHtcbiAgICAgICAgcmV0dXJuIGluU2l6ZTtcbiAgICB9XG4gICAgcmV0dXJuIG5lYXJlc3REaXZpc29yKGluU2l6ZSwgTWF0aC5mbG9vcihNYXRoLnNxcnQoaW5TaXplKSkpO1xufVxuZXhwb3J0cy5jb21wdXRlT3B0aW1hbFdpbmRvd1NpemUgPSBjb21wdXRlT3B0aW1hbFdpbmRvd1NpemU7XG5mdW5jdGlvbiBuZWFyZXN0RGl2aXNvcihzaXplLCBzdGFydCkge1xuICAgIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IHNpemU7ICsraSkge1xuICAgICAgICBpZiAoc2l6ZSAlIGkgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzaXplO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVkdWNlX3V0aWwuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xuZnVuY3Rpb24gYXNzZXJ0UGFyYW1zVmFsaWQoaW5wdXQsIGJlZ2luLCBzaXplKSB7XG4gICAgdXRpbC5hc3NlcnQoaW5wdXQucmFuayA9PT0gYmVnaW4ubGVuZ3RoLCBcIkVycm9yIGluIHNsaWNlXCIgKyBpbnB1dC5yYW5rICsgXCJEOiBMZW5ndGggb2YgYmVnaW4gXCIgKyBiZWdpbiArIFwiIG11c3QgXCIgK1xuICAgICAgICAoXCJtYXRjaCB0aGUgcmFuayBvZiB0aGUgYXJyYXkgKFwiICsgaW5wdXQucmFuayArIFwiKS5cIikpO1xuICAgIHV0aWwuYXNzZXJ0KGlucHV0LnJhbmsgPT09IHNpemUubGVuZ3RoLCBcIkVycm9yIGluIHNsaWNlXCIgKyBpbnB1dC5yYW5rICsgXCJEOiBMZW5ndGggb2Ygc2l6ZSBcIiArIHNpemUgKyBcIiBtdXN0IFwiICtcbiAgICAgICAgKFwibWF0Y2ggdGhlIHJhbmsgb2YgdGhlIGFycmF5IChcIiArIGlucHV0LnJhbmsgKyBcIikuXCIpKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlucHV0LnJhbms7ICsraSkge1xuICAgICAgICB1dGlsLmFzc2VydChiZWdpbltpXSArIHNpemVbaV0gPD0gaW5wdXQuc2hhcGVbaV0sIFwiRXJyb3IgaW4gc2xpY2VcIiArIGlucHV0LnJhbmsgKyBcIkQ6IGJlZ2luW1wiICsgaSArIFwiXSArIHNpemVbXCIgKyBpICsgXCJdIFwiICtcbiAgICAgICAgICAgIChcIihcIiArIChiZWdpbltpXSArIHNpemVbaV0pICsgXCIpIHdvdWxkIG92ZXJmbG93IGlucHV0LnNoYXBlW1wiICsgaSArIFwiXSAoXCIgKyBpbnB1dC5zaGFwZVtpXSArIFwiKVwiKSk7XG4gICAgfVxufVxuZXhwb3J0cy5hc3NlcnRQYXJhbXNWYWxpZCA9IGFzc2VydFBhcmFtc1ZhbGlkO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2xpY2VfdXRpbC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBicm9hZGNhc3RfdXRpbCA9IHJlcXVpcmUoXCIuLi9icm9hZGNhc3RfdXRpbFwiKTtcbnZhciBBZGRTY2FsZWRNYXRQcm9ncmFtID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBZGRTY2FsZWRNYXRQcm9ncmFtKGFTaGFwZSwgYlNoYXBlKSB7XG4gICAgICAgIHRoaXMudmFyaWFibGVOYW1lcyA9IFsnQScsICdCJywgJ2MxJywgJ2MyJ107XG4gICAgICAgIHRoaXMuc3VwcG9ydHNCcm9hZGNhc3RpbmcgPSB0cnVlO1xuICAgICAgICB0aGlzLm91dHB1dFNoYXBlID1cbiAgICAgICAgICAgIGJyb2FkY2FzdF91dGlsLmFzc2VydEFuZEdldEJyb2FkY2FzdFNoYXBlKGFTaGFwZSwgYlNoYXBlKTtcbiAgICAgICAgdGhpcy51c2VyQ29kZSA9IFwiXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgZmxvYXQgYSA9IGdldEFBdE91dENvb3JkcygpO1xcbiAgICAgICAgZmxvYXQgYiA9IGdldEJBdE91dENvb3JkcygpO1xcbiAgICAgICAgZmxvYXQgYzEgPSBnZXRDMSgpO1xcbiAgICAgICAgZmxvYXQgYzIgPSBnZXRDMigpO1xcbiAgICAgICAgc2V0T3V0cHV0KGRvdCh2ZWMyKGMxLCBjMiksIHZlYzIoYSwgYikpKTtcXG4gICAgICB9XFxuICAgIFwiO1xuICAgIH1cbiAgICByZXR1cm4gQWRkU2NhbGVkTWF0UHJvZ3JhbTtcbn0oKSk7XG5leHBvcnRzLkFkZFNjYWxlZE1hdFByb2dyYW0gPSBBZGRTY2FsZWRNYXRQcm9ncmFtO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWRkc2NhbGVkbWF0X2dwdS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBBcmdNaW5NYXhQcm9ncmFtID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBcmdNaW5NYXhQcm9ncmFtKHJlZHVjZUluZm8sIG9wLCBmaXJzdFBhc3MpIHtcbiAgICAgICAgdGhpcy52YXJpYWJsZU5hbWVzID0gWydBJ107XG4gICAgICAgIHZhciB3aW5kb3dTaXplID0gcmVkdWNlSW5mby53aW5kb3dTaXplO1xuICAgICAgICB2YXIgYmF0Y2hTaXplID0gcmVkdWNlSW5mby5iYXRjaFNpemU7XG4gICAgICAgIHZhciBpblNpemUgPSByZWR1Y2VJbmZvLmluU2l6ZTtcbiAgICAgICAgdmFyIG91dFNpemUgPSBNYXRoLmNlaWwoaW5TaXplIC8gd2luZG93U2l6ZSk7XG4gICAgICAgIGlmICghZmlyc3RQYXNzKSB7XG4gICAgICAgICAgICB0aGlzLnZhcmlhYmxlTmFtZXMucHVzaCgnYmVzdEluZGljZXNBJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vdXRwdXRTaGFwZSA9IFtiYXRjaFNpemUsIG91dFNpemVdO1xuICAgICAgICB2YXIgY29tcE9wID0gKG9wID09PSAnbWF4JykgPyAnPicgOiAnPCc7XG4gICAgICAgIHZhciBpbmRleFNuaXBwZXQgPSBmaXJzdFBhc3MgP1xuICAgICAgICAgICAgJ2luT2Zmc2V0ICsgaTsnIDpcbiAgICAgICAgICAgICdyb3VuZChnZXRCZXN0SW5kaWNlc0EoYmF0Y2gsIGluT2Zmc2V0ICsgaSkpOyc7XG4gICAgICAgIHRoaXMudXNlckNvZGUgPSBcIlxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWMyIGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgaW50IGJhdGNoID0gY29vcmRzWzBdO1xcbiAgICAgICAgaW50IG91dElkeCA9IGNvb3Jkc1sxXTtcXG4gICAgICAgIGludCBpbk9mZnNldCA9IG91dElkeCAqIFwiICsgd2luZG93U2l6ZSArIFwiO1xcblxcbiAgICAgICAgaW50IGJlc3RJbmRleCA9IDA7XFxuICAgICAgICBmbG9hdCBiZXN0VmFsdWUgPSBnZXRBKGJhdGNoLCBpbk9mZnNldCk7XFxuXFxuICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IFwiICsgd2luZG93U2l6ZSArIFwiOyBpKyspIHtcXG4gICAgICAgICAgaW50IGluSWR4ID0gXCIgKyBpbmRleFNuaXBwZXQgKyBcIjtcXG4gICAgICAgICAgZmxvYXQgY2FuZGlkYXRlID0gZ2V0QShiYXRjaCwgaW5JZHgpO1xcbiAgICAgICAgICBpZiAoaXNOYU4oY2FuZGlkYXRlKSkge1xcbiAgICAgICAgICAgIHNldE91dHB1dChjYW5kaWRhdGUpO1xcbiAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICBpZiAoY2FuZGlkYXRlIFwiICsgY29tcE9wICsgXCIgYmVzdFZhbHVlKSB7XFxuICAgICAgICAgICAgYmVzdFZhbHVlID0gY2FuZGlkYXRlO1xcbiAgICAgICAgICAgIGJlc3RJbmRleCA9IGluSWR4O1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICBzZXRPdXRwdXQoZmxvYXQoYmVzdEluZGV4KSk7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgcmV0dXJuIEFyZ01pbk1heFByb2dyYW07XG59KCkpO1xuZXhwb3J0cy5BcmdNaW5NYXhQcm9ncmFtID0gQXJnTWluTWF4UHJvZ3JhbTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFyZ21pbm1heF9ncHUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgYnJvYWRjYXN0X3V0aWwgPSByZXF1aXJlKFwiLi4vYnJvYWRjYXN0X3V0aWxcIik7XG52YXIgQmF0Y2hOb3JtUHJvZ3JhbSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQmF0Y2hOb3JtUHJvZ3JhbSh4U2hhcGUsIG1lYW5TaGFwZSwgdmFyaWFuY2VTaGFwZSwgb2Zmc2V0U2hhcGUsIHNjYWxlU2hhcGUsIHZhcmlhbmNlRXBzaWxvbikge1xuICAgICAgICB0aGlzLm91dHB1dFNoYXBlID0gW107XG4gICAgICAgIHRoaXMuc3VwcG9ydHNCcm9hZGNhc3RpbmcgPSB0cnVlO1xuICAgICAgICB0aGlzLnZhcmlhYmxlTmFtZXMgPSBbJ3gnLCAnbWVhbicsICd2YXJpYW5jZSddO1xuICAgICAgICBicm9hZGNhc3RfdXRpbC5hc3NlcnRBbmRHZXRCcm9hZGNhc3RTaGFwZSh4U2hhcGUsIG1lYW5TaGFwZSk7XG4gICAgICAgIGJyb2FkY2FzdF91dGlsLmFzc2VydEFuZEdldEJyb2FkY2FzdFNoYXBlKHhTaGFwZSwgdmFyaWFuY2VTaGFwZSk7XG4gICAgICAgIHZhciBvZmZzZXRTbmlwcGV0ID0gJzAuMCc7XG4gICAgICAgIGlmIChvZmZzZXRTaGFwZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBicm9hZGNhc3RfdXRpbC5hc3NlcnRBbmRHZXRCcm9hZGNhc3RTaGFwZSh4U2hhcGUsIG9mZnNldFNoYXBlKTtcbiAgICAgICAgICAgIHRoaXMudmFyaWFibGVOYW1lcy5wdXNoKCdvZmZzZXQnKTtcbiAgICAgICAgICAgIG9mZnNldFNuaXBwZXQgPSAnZ2V0T2Zmc2V0QXRPdXRDb29yZHMoKSc7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNjYWxlU25pcHBldCA9ICcxLjAnO1xuICAgICAgICBpZiAoc2NhbGVTaGFwZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBicm9hZGNhc3RfdXRpbC5hc3NlcnRBbmRHZXRCcm9hZGNhc3RTaGFwZSh4U2hhcGUsIHNjYWxlU2hhcGUpO1xuICAgICAgICAgICAgdGhpcy52YXJpYWJsZU5hbWVzLnB1c2goJ3NjYWxlJyk7XG4gICAgICAgICAgICBzY2FsZVNuaXBwZXQgPSAnZ2V0U2NhbGVBdE91dENvb3JkcygpJztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm91dHB1dFNoYXBlID0geFNoYXBlO1xuICAgICAgICB0aGlzLnVzZXJDb2RlID0gXCJcXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBmbG9hdCB4ID0gZ2V0WEF0T3V0Q29vcmRzKCk7XFxuICAgICAgICBmbG9hdCBtZWFuID0gZ2V0TWVhbkF0T3V0Q29vcmRzKCk7XFxuICAgICAgICBmbG9hdCB2YXJpYW5jZSA9IGdldFZhcmlhbmNlQXRPdXRDb29yZHMoKTtcXG4gICAgICAgIGZsb2F0IG9mZnNldCA9IFwiICsgb2Zmc2V0U25pcHBldCArIFwiO1xcbiAgICAgICAgZmxvYXQgc2NhbGUgPSBcIiArIHNjYWxlU25pcHBldCArIFwiO1xcbiAgICAgICAgZmxvYXQgaW52ID0gc2NhbGUgLyBzcXJ0KHZhcmlhbmNlICsgZmxvYXQoXCIgKyB2YXJpYW5jZUVwc2lsb24gKyBcIikpO1xcbiAgICAgICAgc2V0T3V0cHV0KCh4IC0gbWVhbikgKiBpbnYgKyBvZmZzZXQpO1xcbiAgICAgIH1cXG4gICAgXCI7XG4gICAgfVxuICAgIHJldHVybiBCYXRjaE5vcm1Qcm9ncmFtO1xufSgpKTtcbmV4cG9ydHMuQmF0Y2hOb3JtUHJvZ3JhbSA9IEJhdGNoTm9ybVByb2dyYW07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iYXRjaG5vcm1fZ3B1LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGJyb2FkY2FzdF91dGlsID0gcmVxdWlyZShcIi4uL2Jyb2FkY2FzdF91dGlsXCIpO1xuZXhwb3J0cy5BREQgPSAncmV0dXJuIGEgKyBiOyc7XG5leHBvcnRzLlNVQiA9ICdyZXR1cm4gYSAtIGI7JztcbmV4cG9ydHMuTVVMID0gJ3JldHVybiBhICogYjsnO1xuZXhwb3J0cy5ESVYgPSAncmV0dXJuIGEgLyBiOyc7XG5leHBvcnRzLkVRVUFMID0gXCJcXG4gIGlmIChpc05hTihhKSkgcmV0dXJuIGE7XFxuICBpZiAoaXNOYU4oYikpIHJldHVybiBiO1xcbiAgcmV0dXJuIGZsb2F0KGEgPT0gYik7XFxuXCI7XG52YXIgQmluYXJ5T3BQcm9ncmFtID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBCaW5hcnlPcFByb2dyYW0ob3AsIGFTaGFwZSwgYlNoYXBlKSB7XG4gICAgICAgIHRoaXMudmFyaWFibGVOYW1lcyA9IFsnQScsICdCJ107XG4gICAgICAgIHRoaXMuc3VwcG9ydHNCcm9hZGNhc3RpbmcgPSB0cnVlO1xuICAgICAgICB0aGlzLm91dHB1dFNoYXBlID1cbiAgICAgICAgICAgIGJyb2FkY2FzdF91dGlsLmFzc2VydEFuZEdldEJyb2FkY2FzdFNoYXBlKGFTaGFwZSwgYlNoYXBlKTtcbiAgICAgICAgdGhpcy51c2VyQ29kZSA9IFwiXFxuICAgICAgZmxvYXQgYmluYXJ5T3BlcmF0aW9uKGZsb2F0IGEsIGZsb2F0IGIpIHtcXG4gICAgICAgIFwiICsgb3AgKyBcIlxcbiAgICAgIH1cXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBmbG9hdCBhID0gZ2V0QUF0T3V0Q29vcmRzKCk7XFxuICAgICAgICBmbG9hdCBiID0gZ2V0QkF0T3V0Q29vcmRzKCk7XFxuICAgICAgICBzZXRPdXRwdXQoYmluYXJ5T3BlcmF0aW9uKGEsIGIpKTtcXG4gICAgICB9XFxuICAgIFwiO1xuICAgIH1cbiAgICByZXR1cm4gQmluYXJ5T3BQcm9ncmFtO1xufSgpKTtcbmV4cG9ydHMuQmluYXJ5T3BQcm9ncmFtID0gQmluYXJ5T3BQcm9ncmFtO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmluYXJ5b3BfZ3B1LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIENsaXBQcm9ncmFtID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDbGlwUHJvZ3JhbShhU2hhcGUsIG1pbiwgbWF4KSB7XG4gICAgICAgIHRoaXMudmFyaWFibGVOYW1lcyA9IFsnQSddO1xuICAgICAgICB0aGlzLm91dHB1dFNoYXBlID0gYVNoYXBlO1xuICAgICAgICB2YXIgbWluRml4ZWQgPSBtaW4udG9GaXhlZCgyMCk7XG4gICAgICAgIHZhciBtYXhGaXhlZCA9IG1heC50b0ZpeGVkKDIwKTtcbiAgICAgICAgdGhpcy51c2VyQ29kZSA9IFwiXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgZmxvYXQgdmFsdWUgPSBnZXRBQXRPdXRDb29yZHMoKTtcXG4gICAgICAgIGlmIChpc05hTih2YWx1ZSkpIHtcXG4gICAgICAgICAgc2V0T3V0cHV0KHZhbHVlKTtcXG4gICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgc2V0T3V0cHV0KGNsYW1wKHZhbHVlLCBcIiArIG1pbkZpeGVkICsgXCIsIFwiICsgbWF4Rml4ZWQgKyBcIikpO1xcbiAgICAgIH1cXG4gICAgXCI7XG4gICAgfVxuICAgIHJldHVybiBDbGlwUHJvZ3JhbTtcbn0oKSk7XG5leHBvcnRzLkNsaXBQcm9ncmFtID0gQ2xpcFByb2dyYW07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jbGlwX2dwdS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBjb25jYXRfdXRpbCA9IHJlcXVpcmUoXCIuLi9jb25jYXRfdXRpbFwiKTtcbnZhciBzaGFkZXJfY29tcGlsZXJfMSA9IHJlcXVpcmUoXCIuL3NoYWRlcl9jb21waWxlclwiKTtcbnZhciBDb25jYXRQcm9ncmFtID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDb25jYXRQcm9ncmFtKGFTaGFwZSwgYlNoYXBlLCBheGlzKSB7XG4gICAgICAgIHRoaXMudmFyaWFibGVOYW1lcyA9IFsnQScsICdCJ107XG4gICAgICAgIHRoaXMub3V0cHV0U2hhcGUgPSBbXTtcbiAgICAgICAgdmFyIHlBeGVzID0gWyd5UicsICd5QycsICd5RCcsICd5VyddO1xuICAgICAgICB2YXIgY29uY2F0QXhpcyA9IHlBeGVzW2F4aXNdO1xuICAgICAgICB0aGlzLm91dHB1dFNoYXBlID0gY29uY2F0X3V0aWwuY29tcHV0ZU91dFNoYXBlKGFTaGFwZSwgYlNoYXBlLCBheGlzKTtcbiAgICAgICAgdmFyIGRUeXBlID0gc2hhZGVyX2NvbXBpbGVyXzEuZ2V0Q29vcmRzRGF0YVR5cGUoYVNoYXBlLmxlbmd0aCk7XG4gICAgICAgIHZhciB1bnBhY2tTbmlwcGV0ID0gZ2V0VW5wYWNrKGFTaGFwZS5sZW5ndGgpO1xuICAgICAgICB2YXIgc2FtcGxlQ29vcmRzID0gZ2V0U2FtcGxlQ29vcmRzKGFTaGFwZS5sZW5ndGgpO1xuICAgICAgICB0aGlzLnVzZXJDb2RlID0gXCJcXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBcIiArIGRUeXBlICsgXCIgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBcIiArIHVucGFja1NuaXBwZXQgKyBcIlxcblxcbiAgICAgICAgZmxvYXQgdmFsdWUgPSAwLjA7XFxuICAgICAgICBpZiAoXCIgKyBjb25jYXRBeGlzICsgXCIgPCBcIiArIGFTaGFwZVtheGlzXSArIFwiKSB7XFxuICAgICAgICAgIHZhbHVlID0gZ2V0QShcIiArIHNhbXBsZUNvb3JkcyArIFwiKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIFwiICsgY29uY2F0QXhpcyArIFwiIC09IFwiICsgYVNoYXBlW2F4aXNdICsgXCI7XFxuICAgICAgICAgIHZhbHVlID0gZ2V0QihcIiArIHNhbXBsZUNvb3JkcyArIFwiKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHNldE91dHB1dCh2YWx1ZSk7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgcmV0dXJuIENvbmNhdFByb2dyYW07XG59KCkpO1xuZXhwb3J0cy5Db25jYXRQcm9ncmFtID0gQ29uY2F0UHJvZ3JhbTtcbmZ1bmN0aW9uIGdldFNhbXBsZUNvb3JkcyhyYW5rKSB7XG4gICAgaWYgKHJhbmsgPT09IDEpIHtcbiAgICAgICAgcmV0dXJuICd5Uic7XG4gICAgfVxuICAgIGVsc2UgaWYgKHJhbmsgPT09IDIpIHtcbiAgICAgICAgcmV0dXJuICd5UiwgeUMnO1xuICAgIH1cbiAgICBlbHNlIGlmIChyYW5rID09PSAzKSB7XG4gICAgICAgIHJldHVybiAneVIsIHlDLCB5RCc7XG4gICAgfVxuICAgIGVsc2UgaWYgKHJhbmsgPT09IDQpIHtcbiAgICAgICAgcmV0dXJuICd5UiwgeUMsIHlELCB5Vyc7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBFcnJvcihcIkNvbmNhdCBmb3IgcmFuayBcIiArIHJhbmsgKyBcIiBpcyBub3QgeWV0IHN1cHBvcnRlZFwiKTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRVbnBhY2socmFuaykge1xuICAgIHZhciByZXMgPSByYW5rID09PSAxID8gJ2ludCB5UiA9IGNvb3JkczsnIDogJ2ludCB5UiA9IGNvb3Jkcy54Oyc7XG4gICAgaWYgKHJhbmsgPiAxKSB7XG4gICAgICAgIHJlcyArPSAnXFxuaW50IHlDID0gY29vcmRzLnk7JztcbiAgICB9XG4gICAgaWYgKHJhbmsgPiAyKSB7XG4gICAgICAgIHJlcyArPSAnXFxuaW50IHlEID0gY29vcmRzLno7JztcbiAgICB9XG4gICAgaWYgKHJhbmsgPiAzKSB7XG4gICAgICAgIHJlcyArPSAnXFxuaW50IHlXID0gY29vcmRzLnc7JztcbiAgICB9XG4gICAgaWYgKHJhbmsgPiA0KSB7XG4gICAgICAgIHRocm93IEVycm9yKFwiQ29uY2F0IGZvciByYW5rIFwiICsgcmFuayArIFwiIGlzIG5vdCB5ZXQgc3VwcG9ydGVkXCIpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29uY2F0X2dwdS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBjb252X3V0aWwgPSByZXF1aXJlKFwiLi4vY29udl91dGlsXCIpO1xudmFyIENvbnYyRERlcldlaWdodHNQcm9ncmFtID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDb252MkREZXJXZWlnaHRzUHJvZ3JhbShjb252SW5mbykge1xuICAgICAgICB0aGlzLnZhcmlhYmxlTmFtZXMgPSBbJ3gnLCAnZHknXTtcbiAgICAgICAgdmFyIF9hID0gY29udkluZm8ub3V0U2hhcGUsIHlOdW1Sb3dzID0gX2FbMF0sIHlOdW1Db2xzID0gX2FbMV0sIG91dERlcHRoID0gX2FbMl07XG4gICAgICAgIHZhciBfYiA9IGNvbnZJbmZvLmluU2hhcGUsIHhOdW1Sb3dzID0gX2JbMF0sIHhOdW1Db2xzID0gX2JbMV0sIGluRGVwdGggPSBfYlsyXTtcbiAgICAgICAgdmFyIHN0cmlkZUhlaWdodCA9IGNvbnZJbmZvLnN0cmlkZUhlaWdodDtcbiAgICAgICAgdmFyIHN0cmlkZVdpZHRoID0gY29udkluZm8uc3RyaWRlV2lkdGg7XG4gICAgICAgIHRoaXMub3V0cHV0U2hhcGUgPSBjb252X3V0aWwuY29tcHV0ZVdlaWdodHNTaGFwZTREKGluRGVwdGgsIG91dERlcHRoLCBjb252SW5mby5maWx0ZXJIZWlnaHQsIGNvbnZJbmZvLmZpbHRlcldpZHRoKTtcbiAgICAgICAgdmFyIHBhZFRvcCA9IGNvbnZJbmZvLnBhZEluZm8udG9wO1xuICAgICAgICB2YXIgcGFkTGVmdCA9IGNvbnZJbmZvLnBhZEluZm8ubGVmdDtcbiAgICAgICAgdGhpcy51c2VyQ29kZSA9IFwiXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzQgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpbnQgd1IgPSBjb29yZHMueDtcXG4gICAgICAgIGludCB3QyA9IGNvb3Jkcy55O1xcbiAgICAgICAgaW50IGQxID0gY29vcmRzLno7XFxuICAgICAgICBpbnQgZDIgPSBjb29yZHMudztcXG5cXG4gICAgICAgIC8vIENvbnZvbHZlIHgoPywgPywgZDEpIHdpdGggZHkoOiwgOiwgZDIpIHRvIGdldCBkdyh3Uiwgd0MsIGQxLCBkMikuXFxuICAgICAgICAvLyA/ID0gdG8gYmUgZGV0ZXJtaW5lZC4gOiA9IGFjcm9zcyBhbGwgdmFsdWVzIGluIHRoYXQgYXhpcy5cXG4gICAgICAgIGZsb2F0IGRvdFByb2QgPSAwLjA7XFxuICAgICAgICBmb3IgKGludCB5UiA9IDA7IHlSIDwgXCIgKyB5TnVtUm93cyArIFwiOyB5UisrKSB7XFxuICAgICAgICAgIGludCB4UiA9IHdSICsgeVIgKiBcIiArIHN0cmlkZUhlaWdodCArIFwiIC0gXCIgKyBwYWRUb3AgKyBcIjtcXG5cXG4gICAgICAgICAgaWYgKHhSIDwgMCB8fCB4UiA+PSBcIiArIHhOdW1Sb3dzICsgXCIpIHtcXG4gICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBmb3IgKGludCB5QyA9IDA7IHlDIDwgXCIgKyB5TnVtQ29scyArIFwiOyB5QysrKSB7XFxuICAgICAgICAgICAgaW50IHhDID0gd0MgKyB5QyAqIFwiICsgc3RyaWRlV2lkdGggKyBcIiAtIFwiICsgcGFkTGVmdCArIFwiO1xcblxcbiAgICAgICAgICAgIGlmICh4QyA8IDAgfHwgeEMgPj0gXCIgKyB4TnVtQ29scyArIFwiKSB7XFxuICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgZmxvYXQgZHlWYWx1ZSA9IGdldER5KHlSLCB5QywgZDIpO1xcbiAgICAgICAgICAgIGZsb2F0IHhWYWx1ZSA9IGdldFgoeFIsIHhDLCBkMSk7XFxuICAgICAgICAgICAgZG90UHJvZCArPSAoeFZhbHVlICogZHlWYWx1ZSk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIHNldE91dHB1dChkb3RQcm9kKTtcXG4gICAgICB9XFxuICAgIFwiO1xuICAgIH1cbiAgICByZXR1cm4gQ29udjJERGVyV2VpZ2h0c1Byb2dyYW07XG59KCkpO1xuZXhwb3J0cy5Db252MkREZXJXZWlnaHRzUHJvZ3JhbSA9IENvbnYyRERlcldlaWdodHNQcm9ncmFtO1xudmFyIENvbnYyRERlcklucHV0UHJvZ3JhbSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ29udjJERGVySW5wdXRQcm9ncmFtKGNvbnZJbmZvKSB7XG4gICAgICAgIHRoaXMudmFyaWFibGVOYW1lcyA9IFsnZHknLCAnVyddO1xuICAgICAgICB2YXIgX2EgPSBjb252SW5mby5vdXRTaGFwZSwgeVJvd3MgPSBfYVswXSwgeUNvbHMgPSBfYVsxXSwgb3V0RGVwdGggPSBfYVsyXTtcbiAgICAgICAgdGhpcy5vdXRwdXRTaGFwZSA9IGNvbnZJbmZvLmluU2hhcGU7XG4gICAgICAgIHZhciBmaWx0ZXJIZWlnaHQgPSBjb252SW5mby5maWx0ZXJIZWlnaHQ7XG4gICAgICAgIHZhciBmaWx0ZXJXaWR0aCA9IGNvbnZJbmZvLmZpbHRlcldpZHRoO1xuICAgICAgICB2YXIgc3RyaWRlSGVpZ2h0ID0gY29udkluZm8uc3RyaWRlSGVpZ2h0O1xuICAgICAgICB2YXIgc3RyaWRlV2lkdGggPSBjb252SW5mby5zdHJpZGVXaWR0aDtcbiAgICAgICAgdmFyIHBhZFRvcCA9IGZpbHRlckhlaWdodCAtIDEgLSBjb252SW5mby5wYWRJbmZvLnRvcDtcbiAgICAgICAgdmFyIHBhZExlZnQgPSBmaWx0ZXJXaWR0aCAtIDEgLSBjb252SW5mby5wYWRJbmZvLmxlZnQ7XG4gICAgICAgIHRoaXMudXNlckNvZGUgPSBcIlxcbiAgICAgIGNvbnN0IGl2ZWMyIHBhZHMgPSBpdmVjMihcIiArIHBhZFRvcCArIFwiLCBcIiArIHBhZExlZnQgKyBcIik7XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzMgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpbnQgZDEgPSBjb29yZHMuejtcXG5cXG4gICAgICAgIGl2ZWMyIGR5Q29ybmVyID0gY29vcmRzLnh5IC0gcGFkcztcXG4gICAgICAgIGludCBkeVJDb3JuZXIgPSBkeUNvcm5lci54O1xcbiAgICAgICAgaW50IGR5Q0Nvcm5lciA9IGR5Q29ybmVyLnk7XFxuXFxuICAgICAgICAvLyBDb252b2x2ZSBkeSg/LCA/LCBkMikgd2l0aCB3KDosIDosIGQxLCBkMikgdG8gY29tcHV0ZSBkeCh4UiwgeEMsIGQxKS5cXG4gICAgICAgIC8vID8gPSB0byBiZSBkZXRlcm1pbmVkLiA6ID0gYWNyb3NzIGFsbCB2YWx1ZXMgaW4gdGhhdCBheGlzLlxcbiAgICAgICAgZmxvYXQgZG90UHJvZCA9IDAuMDtcXG4gICAgICAgIGZvciAoaW50IHdSID0gMDsgd1IgPCBcIiArIGZpbHRlckhlaWdodCArIFwiOyB3UisrKSB7XFxuICAgICAgICAgIGZsb2F0IGR5UiA9IGZsb2F0KGR5UkNvcm5lciArIHdSKSAvIFwiICsgc3RyaWRlSGVpZ2h0ICsgXCIuMDtcXG5cXG4gICAgICAgICAgaWYgKGR5UiA8IDAuMCB8fCBkeVIgPj0gXCIgKyB5Um93cyArIFwiLjAgfHwgZnJhY3QoZHlSKSA+IDAuMCkge1xcbiAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIGludCBpZHlSID0gaW50KGR5Uik7XFxuXFxuICAgICAgICAgIGludCB3UlBlcm0gPSBcIiArIGZpbHRlckhlaWdodCArIFwiIC0gMSAtIHdSO1xcblxcbiAgICAgICAgICBmb3IgKGludCB3QyA9IDA7IHdDIDwgXCIgKyBmaWx0ZXJXaWR0aCArIFwiOyB3QysrKSB7XFxuICAgICAgICAgICAgZmxvYXQgZHlDID0gZmxvYXQoZHlDQ29ybmVyICsgd0MpIC8gXCIgKyBzdHJpZGVXaWR0aCArIFwiLjA7XFxuXFxuICAgICAgICAgICAgaWYgKGR5QyA8IDAuMCB8fCBkeUMgPj0gXCIgKyB5Q29scyArIFwiLjAgfHwgZnJhY3QoZHlDKSA+IDAuMCkge1xcbiAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGludCBpZHlDID0gaW50KGR5Qyk7XFxuXFxuICAgICAgICAgICAgaW50IHdDUGVybSA9IFwiICsgZmlsdGVyV2lkdGggKyBcIiAtIDEgLSB3QztcXG5cXG4gICAgICAgICAgICBmb3IgKGludCBkMiA9IDA7IGQyIDwgXCIgKyBvdXREZXB0aCArIFwiOyBkMisrKSB7XFxuICAgICAgICAgICAgICBmbG9hdCB4VmFsdWUgPSBnZXREeShpZHlSLCBpZHlDLCBkMik7XFxuICAgICAgICAgICAgICBmbG9hdCB3VmFsdWUgPSBnZXRXKHdSUGVybSwgd0NQZXJtLCBkMSwgZDIpO1xcbiAgICAgICAgICAgICAgZG90UHJvZCArPSB4VmFsdWUgKiB3VmFsdWU7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICBzZXRPdXRwdXQoZG90UHJvZCk7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgcmV0dXJuIENvbnYyRERlcklucHV0UHJvZ3JhbTtcbn0oKSk7XG5leHBvcnRzLkNvbnYyRERlcklucHV0UHJvZ3JhbSA9IENvbnYyRERlcklucHV0UHJvZ3JhbTtcbnZhciBDb252MkREZXJCaWFzUHJvZ3JhbSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ29udjJERGVyQmlhc1Byb2dyYW0oeVNoYXBlKSB7XG4gICAgICAgIHRoaXMudmFyaWFibGVOYW1lcyA9IFsnZHknXTtcbiAgICAgICAgdmFyIHlOdW1Sb3dzID0geVNoYXBlWzBdLCB5TnVtQ29scyA9IHlTaGFwZVsxXSwgb3V0cHV0RGVwdGggPSB5U2hhcGVbMl07XG4gICAgICAgIHRoaXMub3V0cHV0U2hhcGUgPSBbb3V0cHV0RGVwdGhdO1xuICAgICAgICB0aGlzLnVzZXJDb2RlID0gXCJcXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpbnQgZDIgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG5cXG4gICAgICAgIGZsb2F0IGRlckJpYXMgPSAwLjA7XFxuICAgICAgICBmb3IgKGludCB5UiA9IDA7IHlSIDwgXCIgKyB5TnVtUm93cyArIFwiOyB5UisrKSB7XFxuICAgICAgICAgIGZvciAoaW50IHlDID0gMDsgeUMgPCBcIiArIHlOdW1Db2xzICsgXCI7IHlDKyspIHtcXG4gICAgICAgICAgICBkZXJCaWFzICs9IGdldER5KHlSLCB5QywgZDIpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICBzZXRPdXRwdXQoZGVyQmlhcyk7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgcmV0dXJuIENvbnYyRERlckJpYXNQcm9ncmFtO1xufSgpKTtcbmV4cG9ydHMuQ29udjJERGVyQmlhc1Byb2dyYW0gPSBDb252MkREZXJCaWFzUHJvZ3JhbTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbnZfYmFja3Byb3BfZ3B1LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIENvbnYyRFByb2dyYW0gPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENvbnYyRFByb2dyYW0oY29udkluZm8sIGhhc0JpYXMpIHtcbiAgICAgICAgdGhpcy52YXJpYWJsZU5hbWVzID0gWyd4JywgJ1cnXTtcbiAgICAgICAgaWYgKGhhc0JpYXMpIHtcbiAgICAgICAgICAgIHRoaXMudmFyaWFibGVOYW1lcy5wdXNoKCdiaWFzJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vdXRwdXRTaGFwZSA9IGNvbnZJbmZvLm91dFNoYXBlO1xuICAgICAgICB2YXIgYmlhc1NuaXBwZXQgPSBoYXNCaWFzID8gJ2RvdFByb2QgKz0gZ2V0QmlhcyhkMik7JyA6ICcnO1xuICAgICAgICB2YXIgX2EgPSBjb252SW5mby5pblNoYXBlLCB4TnVtUm93cyA9IF9hWzBdLCB4TnVtQ29scyA9IF9hWzFdLCBpbnB1dERlcHRoID0gX2FbMl07XG4gICAgICAgIHZhciBwYWRUb3AgPSBjb252SW5mby5wYWRJbmZvLnRvcDtcbiAgICAgICAgdmFyIHBhZExlZnQgPSBjb252SW5mby5wYWRJbmZvLmxlZnQ7XG4gICAgICAgIHZhciBzdHJpZGVIZWlnaHQgPSBjb252SW5mby5zdHJpZGVIZWlnaHQ7XG4gICAgICAgIHZhciBzdHJpZGVXaWR0aCA9IGNvbnZJbmZvLnN0cmlkZVdpZHRoO1xuICAgICAgICB2YXIgZmlsdGVySGVpZ2h0ID0gY29udkluZm8uZmlsdGVySGVpZ2h0O1xuICAgICAgICB2YXIgZmlsdGVyV2lkdGggPSBjb252SW5mby5maWx0ZXJXaWR0aDtcbiAgICAgICAgdmFyIGlucHV0RGVwdGhOZWFyZXN0VmVjNCA9IE1hdGguZmxvb3IoaW5wdXREZXB0aCAvIDQpICogNDtcbiAgICAgICAgdmFyIGlucHV0RGVwdGhWZWM0UmVtYWluZGVyID0gaW5wdXREZXB0aCAlIDQ7XG4gICAgICAgIHRoaXMudXNlckNvZGUgPSBcIlxcbiAgICAgIGNvbnN0IGl2ZWMyIHN0cmlkZXMgPSBpdmVjMihcIiArIHN0cmlkZUhlaWdodCArIFwiLCBcIiArIHN0cmlkZVdpZHRoICsgXCIpO1xcbiAgICAgIGNvbnN0IGl2ZWMyIHBhZHMgPSBpdmVjMihcIiArIHBhZFRvcCArIFwiLCBcIiArIHBhZExlZnQgKyBcIik7XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzMgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpbnQgZDIgPSBjb29yZHMuejtcXG5cXG4gICAgICAgIGl2ZWMyIHhSQ0Nvcm5lciA9IGNvb3Jkcy54eSAqIHN0cmlkZXMgLSBwYWRzO1xcbiAgICAgICAgaW50IHhSQ29ybmVyID0geFJDQ29ybmVyLng7XFxuICAgICAgICBpbnQgeENDb3JuZXIgPSB4UkNDb3JuZXIueTtcXG5cXG4gICAgICAgIC8vIENvbnZvbHZlIHgoPywgPywgZDEpIHdpdGggdyg6LCA6LCBkMSwgZDIpIHRvIGdldCB5KHlSLCB5QywgZDIpLlxcbiAgICAgICAgLy8gPyA9IHRvIGJlIGRldGVybWluZWQuIDogPSBhY3Jvc3MgYWxsIHZhbHVlcyBpbiB0aGF0IGF4aXMuXFxuICAgICAgICBmbG9hdCBkb3RQcm9kID0gMC4wO1xcbiAgICAgICAgZm9yIChpbnQgd1IgPSAwOyB3UiA8IFwiICsgZmlsdGVySGVpZ2h0ICsgXCI7IHdSKyspIHtcXG4gICAgICAgICAgaW50IHhSID0geFJDb3JuZXIgKyB3UjtcXG5cXG4gICAgICAgICAgaWYgKHhSIDwgMCB8fCB4UiA+PSBcIiArIHhOdW1Sb3dzICsgXCIpIHtcXG4gICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBmb3IgKGludCB3QyA9IDA7IHdDIDwgXCIgKyBmaWx0ZXJXaWR0aCArIFwiOyB3QysrKSB7XFxuICAgICAgICAgICAgaW50IHhDID0geENDb3JuZXIgKyB3QztcXG5cXG4gICAgICAgICAgICBpZiAoeEMgPCAwIHx8IHhDID49IFwiICsgeE51bUNvbHMgKyBcIikge1xcbiAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGZvciAoaW50IGQxID0gMDsgZDEgPCBcIiArIGlucHV0RGVwdGhOZWFyZXN0VmVjNCArIFwiOyBkMSArPSA0KSB7XFxuICAgICAgICAgICAgICB2ZWM0IHhWYWx1ZXMgPSB2ZWM0KFxcbiAgICAgICAgICAgICAgICBnZXRYKHhSLCB4QywgZDEpLFxcbiAgICAgICAgICAgICAgICBnZXRYKHhSLCB4QywgZDEgKyAxKSxcXG4gICAgICAgICAgICAgICAgZ2V0WCh4UiwgeEMsIGQxICsgMiksXFxuICAgICAgICAgICAgICAgIGdldFgoeFIsIHhDLCBkMSArIDMpXFxuICAgICAgICAgICAgICApO1xcbiAgICAgICAgICAgICAgdmVjNCB3VmFsdWVzID0gdmVjNChcXG4gICAgICAgICAgICAgICAgZ2V0Vyh3Uiwgd0MsIGQxLCBkMiksXFxuICAgICAgICAgICAgICAgIGdldFcod1IsIHdDLCBkMSArIDEsIGQyKSxcXG4gICAgICAgICAgICAgICAgZ2V0Vyh3Uiwgd0MsIGQxICsgMiwgZDIpLFxcbiAgICAgICAgICAgICAgICBnZXRXKHdSLCB3QywgZDEgKyAzLCBkMilcXG4gICAgICAgICAgICAgICk7XFxuXFxuICAgICAgICAgICAgICBkb3RQcm9kICs9IGRvdCh4VmFsdWVzLCB3VmFsdWVzKTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgaWYgKFwiICsgKGlucHV0RGVwdGhWZWM0UmVtYWluZGVyID09PSAxKSArIFwiKSB7XFxuICAgICAgICAgICAgICBkb3RQcm9kICs9XFxuICAgICAgICAgICAgICAgIGdldFgoeFIsIHhDLCBcIiArIGlucHV0RGVwdGhOZWFyZXN0VmVjNCArIFwiKSAqXFxuICAgICAgICAgICAgICAgIGdldFcod1IsIHdDLCBcIiArIGlucHV0RGVwdGhOZWFyZXN0VmVjNCArIFwiLCBkMik7XFxuICAgICAgICAgICAgfSBlbHNlIGlmIChcIiArIChpbnB1dERlcHRoVmVjNFJlbWFpbmRlciA9PT0gMikgKyBcIikge1xcbiAgICAgICAgICAgICAgdmVjMiB4VmFsdWVzID0gdmVjMihcXG4gICAgICAgICAgICAgICAgZ2V0WCh4UiwgeEMsIFwiICsgaW5wdXREZXB0aE5lYXJlc3RWZWM0ICsgXCIpLFxcbiAgICAgICAgICAgICAgICBnZXRYKHhSLCB4QywgXCIgKyBpbnB1dERlcHRoTmVhcmVzdFZlYzQgKyBcIiArIDEpXFxuICAgICAgICAgICAgICApO1xcbiAgICAgICAgICAgICAgdmVjMiB3VmFsdWVzID0gdmVjMihcXG4gICAgICAgICAgICAgICAgZ2V0Vyh3Uiwgd0MsIFwiICsgaW5wdXREZXB0aE5lYXJlc3RWZWM0ICsgXCIsIGQyKSxcXG4gICAgICAgICAgICAgICAgZ2V0Vyh3Uiwgd0MsIFwiICsgaW5wdXREZXB0aE5lYXJlc3RWZWM0ICsgXCIgKyAxLCBkMilcXG4gICAgICAgICAgICAgICk7XFxuICAgICAgICAgICAgICBkb3RQcm9kICs9IGRvdCh4VmFsdWVzLCB3VmFsdWVzKTtcXG4gICAgICAgICAgICB9IGVsc2UgaWYgKFwiICsgKGlucHV0RGVwdGhWZWM0UmVtYWluZGVyID09PSAzKSArIFwiKSB7XFxuICAgICAgICAgICAgICB2ZWMzIHhWYWx1ZXMgPSB2ZWMzKFxcbiAgICAgICAgICAgICAgICBnZXRYKHhSLCB4QywgXCIgKyBpbnB1dERlcHRoTmVhcmVzdFZlYzQgKyBcIiksXFxuICAgICAgICAgICAgICAgIGdldFgoeFIsIHhDLCBcIiArIGlucHV0RGVwdGhOZWFyZXN0VmVjNCArIFwiICsgMSksXFxuICAgICAgICAgICAgICAgIGdldFgoeFIsIHhDLCBcIiArIGlucHV0RGVwdGhOZWFyZXN0VmVjNCArIFwiICsgMilcXG4gICAgICAgICAgICAgICk7XFxuICAgICAgICAgICAgICB2ZWMzIHdWYWx1ZXMgPSB2ZWMzKFxcbiAgICAgICAgICAgICAgICBnZXRXKHdSLCB3QywgXCIgKyBpbnB1dERlcHRoTmVhcmVzdFZlYzQgKyBcIiwgZDIpLFxcbiAgICAgICAgICAgICAgICBnZXRXKHdSLCB3QywgXCIgKyBpbnB1dERlcHRoTmVhcmVzdFZlYzQgKyBcIiArIDEsIGQyKSxcXG4gICAgICAgICAgICAgICAgZ2V0Vyh3Uiwgd0MsIFwiICsgaW5wdXREZXB0aE5lYXJlc3RWZWM0ICsgXCIgKyAyLCBkMilcXG4gICAgICAgICAgICAgICk7XFxuICAgICAgICAgICAgICBkb3RQcm9kICs9IGRvdCh4VmFsdWVzLCB3VmFsdWVzKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIFwiICsgYmlhc1NuaXBwZXQgKyBcIlxcbiAgICAgICAgc2V0T3V0cHV0KGRvdFByb2QpO1xcbiAgICAgIH1cXG4gICAgXCI7XG4gICAgfVxuICAgIHJldHVybiBDb252MkRQcm9ncmFtO1xufSgpKTtcbmV4cG9ydHMuQ29udjJEUHJvZ3JhbSA9IENvbnYyRFByb2dyYW07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb252X2dwdS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBEZXB0aHdpc2VDb252MkRQcm9ncmFtID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEZXB0aHdpc2VDb252MkRQcm9ncmFtKGNvbnZJbmZvKSB7XG4gICAgICAgIHRoaXMudmFyaWFibGVOYW1lcyA9IFsneCcsICdXJ107XG4gICAgICAgIHRoaXMub3V0cHV0U2hhcGUgPSBjb252SW5mby5vdXRTaGFwZTtcbiAgICAgICAgdmFyIHhOdW1Sb3dzID0gY29udkluZm8uaW5TaGFwZVsxXTtcbiAgICAgICAgdmFyIHhOdW1Db2xzID0gY29udkluZm8uaW5TaGFwZVsyXTtcbiAgICAgICAgdmFyIHBhZFRvcCA9IGNvbnZJbmZvLnBhZEluZm8udG9wO1xuICAgICAgICB2YXIgcGFkTGVmdCA9IGNvbnZJbmZvLnBhZEluZm8ubGVmdDtcbiAgICAgICAgdmFyIHN0cmlkZUhlaWdodCA9IGNvbnZJbmZvLnN0cmlkZUhlaWdodDtcbiAgICAgICAgdmFyIHN0cmlkZVdpZHRoID0gY29udkluZm8uc3RyaWRlV2lkdGg7XG4gICAgICAgIHZhciBmaWx0ZXJIZWlnaHQgPSBjb252SW5mby5maWx0ZXJIZWlnaHQ7XG4gICAgICAgIHZhciBmaWx0ZXJXaWR0aCA9IGNvbnZJbmZvLmZpbHRlcldpZHRoO1xuICAgICAgICB2YXIgY2hhbm5lbE11bCA9IGNvbnZJbmZvLmNoYW5uZWxNdWw7XG4gICAgICAgIHRoaXMudXNlckNvZGUgPSBcIlxcbiAgICAgIGNvbnN0IGl2ZWMyIHN0cmlkZXMgPSBpdmVjMihcIiArIHN0cmlkZUhlaWdodCArIFwiLCBcIiArIHN0cmlkZVdpZHRoICsgXCIpO1xcbiAgICAgIGNvbnN0IGl2ZWMyIHBhZHMgPSBpdmVjMihcIiArIHBhZFRvcCArIFwiLCBcIiArIHBhZExlZnQgKyBcIik7XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzQgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpbnQgYmF0Y2ggPSBjb29yZHMueDtcXG4gICAgICAgIGl2ZWMyIHhSQ0Nvcm5lciA9IGNvb3Jkcy55eiAqIHN0cmlkZXMgLSBwYWRzO1xcbiAgICAgICAgaW50IGQyID0gY29vcmRzLnc7XFxuICAgICAgICBpbnQgZDEgPSBkMiAvIFwiICsgY2hhbm5lbE11bCArIFwiO1xcbiAgICAgICAgaW50IHEgPSBkMiAtIGQxICogXCIgKyBjaGFubmVsTXVsICsgXCI7XFxuXFxuICAgICAgICBpbnQgeFJDb3JuZXIgPSB4UkNDb3JuZXIueDtcXG4gICAgICAgIGludCB4Q0Nvcm5lciA9IHhSQ0Nvcm5lci55O1xcblxcbiAgICAgICAgLy8gQ29udm9sdmUgeCg/LCA/LCBkMSkgd2l0aCB3KDosIDosIGQxLCBxKSB0byBnZXQgeSh5UiwgeUMsIGQyKS5cXG4gICAgICAgIC8vID8gPSB0byBiZSBkZXRlcm1pbmVkLiA6ID0gYWNyb3NzIGFsbCB2YWx1ZXMgaW4gdGhhdCBheGlzLlxcbiAgICAgICAgZmxvYXQgZG90UHJvZCA9IDAuMDtcXG4gICAgICAgIC8vIFRPRE8oZHNtaWxrb3YpOiBGbGF0dGVuIHRoZSB0d28gZm9yIGxvb3BzIGFuZCB2ZWM0IHRoZSBvcGVyYXRpb25zLlxcbiAgICAgICAgZm9yIChpbnQgd1IgPSAwOyB3UiA8IFwiICsgZmlsdGVySGVpZ2h0ICsgXCI7IHdSKyspIHtcXG4gICAgICAgICAgaW50IHhSID0geFJDb3JuZXIgKyB3UjtcXG5cXG4gICAgICAgICAgaWYgKHhSIDwgMCB8fCB4UiA+PSBcIiArIHhOdW1Sb3dzICsgXCIpIHtcXG4gICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBmb3IgKGludCB3QyA9IDA7IHdDIDwgXCIgKyBmaWx0ZXJXaWR0aCArIFwiOyB3QysrKSB7XFxuICAgICAgICAgICAgaW50IHhDID0geENDb3JuZXIgKyB3QztcXG5cXG4gICAgICAgICAgICBpZiAoeEMgPCAwIHx8IHhDID49IFwiICsgeE51bUNvbHMgKyBcIikge1xcbiAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGZsb2F0IHhWYWwgPSBnZXRYKGJhdGNoLCB4UiwgeEMsIGQxKTtcXG4gICAgICAgICAgICBmbG9hdCB3VmFsID0gZ2V0Vyh3Uiwgd0MsIGQxLCBxKTtcXG4gICAgICAgICAgICBkb3RQcm9kICs9IHhWYWwgKiB3VmFsO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICBzZXRPdXRwdXQoZG90UHJvZCk7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgcmV0dXJuIERlcHRod2lzZUNvbnYyRFByb2dyYW07XG59KCkpO1xuZXhwb3J0cy5EZXB0aHdpc2VDb252MkRQcm9ncmFtID0gRGVwdGh3aXNlQ29udjJEUHJvZ3JhbTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbnZfZ3B1X2RlcHRod2lzZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBDb3B5MkRQcm9ncmFtID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDb3B5MkRQcm9ncmFtKHNyY051bUNvbHMsIGRlc3ROdW1Db2xzKSB7XG4gICAgICAgIHRoaXMudmFyaWFibGVOYW1lcyA9IFsnc291cmNlJ107XG4gICAgICAgIHRoaXMub3V0cHV0U2hhcGUgPSBudWxsO1xuICAgICAgICB0aGlzLnVzZXJDb2RlID0gXCJcXG4gICAgICB1bmlmb3JtIGl2ZWMyIHNvdXJjZVN0YXJ0O1xcbiAgICAgIHVuaWZvcm0gaXZlYzIgZGVzdFN0YXJ0O1xcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWMyIGRlc3RDb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKSAtIGRlc3RTdGFydDtcXG4gICAgICAgIGludCBpbmRleCA9IGRlc3RDb29yZHMueCAqIFwiICsgZGVzdE51bUNvbHMgKyBcIiArIGRlc3RDb29yZHMueTtcXG4gICAgICAgIGludCByID0gaW5kZXggLyBcIiArIHNyY051bUNvbHMgKyBcIjtcXG4gICAgICAgIGl2ZWMyIHNvdXJjZUNvb3JkcyA9IHNvdXJjZVN0YXJ0ICsgaXZlYzIociwgaW5kZXggLSByICogXCIgKyBzcmNOdW1Db2xzICsgXCIpO1xcbiAgICAgICAgc2V0T3V0cHV0KGdldFNvdXJjZShzb3VyY2VDb29yZHMueCwgc291cmNlQ29vcmRzLnkpKTtcXG4gICAgICB9XFxuICAgIFwiO1xuICAgIH1cbiAgICBDb3B5MkRQcm9ncmFtLnByb3RvdHlwZS5nZXRDdXN0b21TZXR1cEZ1bmMgPSBmdW5jdGlvbiAoc291cmNlU3RhcnQsIGRlc3RTdGFydCwgZGVzdFNpemUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChncGdwdSwgd2ViR0xQcm9ncmFtKSB7XG4gICAgICAgICAgICBncGdwdS5zZXRPdXRwdXRNYXRyaXhXcml0ZVJlZ2lvbihkZXN0U3RhcnRbMF0sIGRlc3RTaXplWzBdLCBkZXN0U3RhcnRbMV0sIGRlc3RTaXplWzFdKTtcbiAgICAgICAgICAgIHZhciBzb3VyY2VTdGFydENSTG9jID0gZ3BncHUuZ2V0VW5pZm9ybUxvY2F0aW9uKHdlYkdMUHJvZ3JhbSwgJ3NvdXJjZVN0YXJ0Jyk7XG4gICAgICAgICAgICBncGdwdS5nbC51bmlmb3JtMmkoc291cmNlU3RhcnRDUkxvYywgc291cmNlU3RhcnRbMF0sIHNvdXJjZVN0YXJ0WzFdKTtcbiAgICAgICAgICAgIHZhciBkZXN0U3RhcnRDUkxvYyA9IGdwZ3B1LmdldFVuaWZvcm1Mb2NhdGlvbih3ZWJHTFByb2dyYW0sICdkZXN0U3RhcnQnKTtcbiAgICAgICAgICAgIGdwZ3B1LmdsLnVuaWZvcm0yaShkZXN0U3RhcnRDUkxvYywgZGVzdFN0YXJ0WzBdLCBkZXN0U3RhcnRbMV0pO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgcmV0dXJuIENvcHkyRFByb2dyYW07XG59KCkpO1xuZXhwb3J0cy5Db3B5MkRQcm9ncmFtID0gQ29weTJEUHJvZ3JhbTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvcHlfZ3B1LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZShyZXN1bHQudmFsdWUpOyB9KS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19nZW5lcmF0b3IgPSAodGhpcyAmJiB0aGlzLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0geVtvcFswXSAmIDIgPyBcInJldHVyblwiIDogb3BbMF0gPyBcInRocm93XCIgOiBcIm5leHRcIl0pICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFswLCB0LnZhbHVlXTtcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuICAgIH1cbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZW52aXJvbm1lbnRfMSA9IHJlcXVpcmUoXCIuLi8uLi9lbnZpcm9ubWVudFwiKTtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4uLy4uL3V0aWxcIik7XG52YXIgZ3BncHVfdXRpbCA9IHJlcXVpcmUoXCIuL2dwZ3B1X3V0aWxcIik7XG52YXIgdGV4X3V0aWwgPSByZXF1aXJlKFwiLi90ZXhfdXRpbFwiKTtcbnZhciB3ZWJnbF91dGlsID0gcmVxdWlyZShcIi4vd2ViZ2xfdXRpbFwiKTtcbnZhciBHUEdQVUNvbnRleHQgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEdQR1BVQ29udGV4dChnbCkge1xuICAgICAgICB0aGlzLm91dHB1dFRleHR1cmUgPSBudWxsO1xuICAgICAgICB0aGlzLnByb2dyYW0gPSBudWxsO1xuICAgICAgICB0aGlzLmRpc3Bvc2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYXV0b0RlYnVnVmFsaWRhdGUgPSBmYWxzZTtcbiAgICAgICAgaWYgKGdsICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuZ2wgPSBnbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZ2wgPSBncGdwdV91dGlsLmNyZWF0ZVdlYkdMQ29udGV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbnZpcm9ubWVudF8xLkVOVi5nZXQoJ1dFQkdMX1ZFUlNJT04nKSA9PT0gMSkge1xuICAgICAgICAgICAgdGhpcy50ZXh0dXJlRmxvYXRFeHRlbnNpb24gPVxuICAgICAgICAgICAgICAgIHdlYmdsX3V0aWwuZ2V0RXh0ZW5zaW9uT3JUaHJvdyh0aGlzLmdsLCAnT0VTX3RleHR1cmVfZmxvYXQnKTtcbiAgICAgICAgICAgIHRoaXMuY29sb3JCdWZmZXJGbG9hdEV4dGVuc2lvbiA9XG4gICAgICAgICAgICAgICAgdGhpcy5nbC5nZXRFeHRlbnNpb24oJ1dFQkdMX2NvbG9yX2J1ZmZlcl9mbG9hdCcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jb2xvckJ1ZmZlckZsb2F0RXh0ZW5zaW9uID1cbiAgICAgICAgICAgICAgICB3ZWJnbF91dGlsLmdldEV4dGVuc2lvbk9yVGhyb3codGhpcy5nbCwgJ0VYVF9jb2xvcl9idWZmZXJfZmxvYXQnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxvc2VDb250ZXh0RXh0ZW5zaW9uID1cbiAgICAgICAgICAgIHdlYmdsX3V0aWwuZ2V0RXh0ZW5zaW9uT3JUaHJvdyh0aGlzLmdsLCAnV0VCR0xfbG9zZV9jb250ZXh0Jyk7XG4gICAgICAgIGlmIChlbnZpcm9ubWVudF8xLkVOVi5nZXQoJ1dFQkdMX0dFVF9CVUZGRVJfU1VCX0RBVEFfQVNZTkNfRVhURU5TSU9OX0VOQUJMRUQnKSkge1xuICAgICAgICAgICAgdGhpcy5nZXRCdWZmZXJTdWJEYXRhQXN5bmNFeHRlbnNpb24gPVxuICAgICAgICAgICAgICAgIHRoaXMuZ2wuZ2V0RXh0ZW5zaW9uKCdXRUJHTF9nZXRfYnVmZmVyX3N1Yl9kYXRhX2FzeW5jJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52ZXJ0ZXhCdWZmZXIgPSBncGdwdV91dGlsLmNyZWF0ZVZlcnRleEJ1ZmZlcih0aGlzLmdsKTtcbiAgICAgICAgdGhpcy5pbmRleEJ1ZmZlciA9IGdwZ3B1X3V0aWwuY3JlYXRlSW5kZXhCdWZmZXIodGhpcy5nbCk7XG4gICAgICAgIHRoaXMuZnJhbWVidWZmZXIgPSB3ZWJnbF91dGlsLmNyZWF0ZUZyYW1lYnVmZmVyKHRoaXMuZ2wpO1xuICAgIH1cbiAgICBHUEdQVUNvbnRleHQucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIGlmICh0aGlzLnByb2dyYW0gIT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdEaXNwb3NpbmcgYSBHUEdQVUNvbnRleHQgdGhhdCBzdGlsbCBoYXMgYSBib3VuZCBXZWJHTFByb2dyYW0uJyArXG4gICAgICAgICAgICAgICAgJyBUaGlzIGlzIHByb2JhYmx5IGEgcmVzb3VyY2UgbGVhaywgZGVsZXRlIHRoZSBwcm9ncmFtIHdpdGggJyArXG4gICAgICAgICAgICAgICAgJ0dQR1BVQ29udGV4dC5kZWxldGVQcm9ncmFtIGJlZm9yZSBkaXNwb3NpbmcuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3V0cHV0VGV4dHVyZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ0Rpc3Bvc2luZyBhIEdQR1BVQ29udGV4dCB0aGF0IHN0aWxsIGhhcyBhIGJvdW5kIG91dHB1dCBtYXRyaXggJyArXG4gICAgICAgICAgICAgICAgJ3RleHR1cmUuICBUaGlzIGlzIHByb2JhYmx5IGEgcmVzb3VyY2UgbGVhaywgZGVsZXRlIHRoZSBvdXRwdXQgJyArXG4gICAgICAgICAgICAgICAgJ21hdHJpeCB0ZXh0dXJlIHdpdGggR1BHUFVDb250ZXh0LmRlbGV0ZU1hdHJpeFRleHR1cmUgYmVmb3JlICcgK1xuICAgICAgICAgICAgICAgICdkaXNwb3NpbmcuJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGdsID0gdGhpcy5nbDtcbiAgICAgICAgd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmZpbmlzaCgpOyB9KTtcbiAgICAgICAgd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgbnVsbCk7IH0pO1xuICAgICAgICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuZGVsZXRlRnJhbWVidWZmZXIoX3RoaXMuZnJhbWVidWZmZXIpOyB9KTtcbiAgICAgICAgd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBudWxsKTsgfSk7XG4gICAgICAgIHdlYmdsX3V0aWwuY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5kZWxldGVCdWZmZXIoX3RoaXMudmVydGV4QnVmZmVyKTsgfSk7XG4gICAgICAgIHdlYmdsX3V0aWwuY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5iaW5kQnVmZmVyKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBudWxsKTsgfSk7XG4gICAgICAgIHdlYmdsX3V0aWwuY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5kZWxldGVCdWZmZXIoX3RoaXMuaW5kZXhCdWZmZXIpOyB9KTtcbiAgICAgICAgdGhpcy5sb3NlQ29udGV4dEV4dGVuc2lvbi5sb3NlQ29udGV4dCgpO1xuICAgICAgICB0aGlzLmRpc3Bvc2VkID0gdHJ1ZTtcbiAgICB9O1xuICAgIEdQR1BVQ29udGV4dC5wcm90b3R5cGUuZW5hYmxlQXV0b21hdGljRGVidWdWYWxpZGF0aW9uID0gZnVuY3Rpb24gKGVuYWJsZWQpIHtcbiAgICAgICAgdGhpcy5hdXRvRGVidWdWYWxpZGF0ZSA9IGVuYWJsZWQ7XG4gICAgICAgIHdlYmdsX3V0aWwuZW5hYmxlRGVidWdXZWJHTEVycm9yQ2hlY2tpbmcoZW5hYmxlZCk7XG4gICAgfTtcbiAgICBHUEdQVUNvbnRleHQucHJvdG90eXBlLmNyZWF0ZU1hdHJpeFRleHR1cmUgPSBmdW5jdGlvbiAocm93cywgY29sdW1ucykge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gZ3BncHVfdXRpbC5jcmVhdGVNYXRyaXhUZXh0dXJlKHRoaXMuZ2wsIHJvd3MsIGNvbHVtbnMpO1xuICAgIH07XG4gICAgR1BHUFVDb250ZXh0LnByb3RvdHlwZS51cGxvYWRQaXhlbERhdGFUb1RleHR1cmUgPSBmdW5jdGlvbiAodGV4dHVyZSwgcGl4ZWxzKSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIGdwZ3B1X3V0aWwudXBsb2FkUGl4ZWxEYXRhVG9UZXh0dXJlKHRoaXMuZ2wsIHRleHR1cmUsIHBpeGVscyk7XG4gICAgfTtcbiAgICBHUEdQVUNvbnRleHQucHJvdG90eXBlLmNyZWF0ZVBhY2tlZE1hdHJpeFRleHR1cmUgPSBmdW5jdGlvbiAocm93cywgY29sdW1ucykge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gZ3BncHVfdXRpbC5jcmVhdGVQYWNrZWRNYXRyaXhUZXh0dXJlKHRoaXMuZ2wsIHJvd3MsIGNvbHVtbnMpO1xuICAgIH07XG4gICAgR1BHUFVDb250ZXh0LnByb3RvdHlwZS5kZWxldGVNYXRyaXhUZXh0dXJlID0gZnVuY3Rpb24gKHRleHR1cmUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgaWYgKHRoaXMub3V0cHV0VGV4dHVyZSA9PT0gdGV4dHVyZSkge1xuICAgICAgICAgICAgd2ViZ2xfdXRpbC51bmJpbmRDb2xvclRleHR1cmVGcm9tRnJhbWVidWZmZXIodGhpcy5nbCwgdGhpcy5mcmFtZWJ1ZmZlcik7XG4gICAgICAgICAgICB0aGlzLm91dHB1dFRleHR1cmUgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHdlYmdsX3V0aWwuY2FsbEFuZENoZWNrKHRoaXMuZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmdsLmRlbGV0ZVRleHR1cmUodGV4dHVyZSk7IH0pO1xuICAgIH07XG4gICAgR1BHUFVDb250ZXh0LnByb3RvdHlwZS51cGxvYWRNYXRyaXhUb1RleHR1cmUgPSBmdW5jdGlvbiAodGV4dHVyZSwgcm93cywgY29sdW1ucywgbWF0cml4KSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHZhciBudW1DaGFubmVscyA9IDE7XG4gICAgICAgIHJldHVybiBncGdwdV91dGlsLnVwbG9hZE1hdHJpeFRvVGV4dHVyZSh0aGlzLmdsLCB0ZXh0dXJlLCByb3dzLCBjb2x1bW5zLCBtYXRyaXgsIG51bUNoYW5uZWxzKTtcbiAgICB9O1xuICAgIEdQR1BVQ29udGV4dC5wcm90b3R5cGUudXBsb2FkTWF0cml4VG9QYWNrZWRUZXh0dXJlID0gZnVuY3Rpb24gKHRleHR1cmUsIHJvd3MsIGNvbHVtbnMsIG1hdHJpeCkge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gZ3BncHVfdXRpbC51cGxvYWRNYXRyaXhUb1BhY2tlZFRleHR1cmUodGhpcy5nbCwgdGV4dHVyZSwgcm93cywgY29sdW1ucywgbWF0cml4KTtcbiAgICB9O1xuICAgIEdQR1BVQ29udGV4dC5wcm90b3R5cGUuZG93bmxvYWRNYXRyaXhGcm9tVGV4dHVyZSA9IGZ1bmN0aW9uICh0ZXh0dXJlLCByb3dzLCBjb2x1bW5zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiB0aGlzLmRvd25sb2FkTWF0cml4RHJpdmVyKHRleHR1cmUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBncGdwdV91dGlsLmRvd25sb2FkTWF0cml4RnJvbU91dHB1dFRleHR1cmUoX3RoaXMuZ2wsIHJvd3MsIGNvbHVtbnMpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEdQR1BVQ29udGV4dC5wcm90b3R5cGUuZG93bmxvYWRNYXRyaXhGcm9tVGV4dHVyZUFzeW5jID0gZnVuY3Rpb24gKHRleHR1cmUsIHJvd3MsIGNvbHVtbnMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5nZXRCdWZmZXJTdWJEYXRhQXN5bmNFeHRlbnNpb24gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZG93bmxvYWQgbWF0cml4IGZyb20gb3V0cHV0IHRleHR1cmUgYXN5bmNocm9ub3VzbHksIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiV0VCR0xfZ2V0X2J1ZmZlcl9zdWJfZGF0YV9hc3luYyBpcyBub3QgZW5hYmxlZC5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBbMiwgdGhpcy5kb3dubG9hZE1hdHJpeERyaXZlckFzeW5jKHRleHR1cmUsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdwZ3B1X3V0aWwuZG93bmxvYWRNYXRyaXhGcm9tT3V0cHV0VGV4dHVyZUFzeW5jKF90aGlzLmdsLCBfdGhpcy5nZXRCdWZmZXJTdWJEYXRhQXN5bmNFeHRlbnNpb24sIHJvd3MsIGNvbHVtbnMpOyB9KV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBHUEdQVUNvbnRleHQucHJvdG90eXBlLmRvd25sb2FkTWF0cml4RnJvbVJHQkFDb2xvclRleHR1cmUgPSBmdW5jdGlvbiAodGV4dHVyZSwgcm93cywgY29sdW1ucywgY2hhbm5lbHMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRoaXMuZG93bmxvYWRNYXRyaXhEcml2ZXIodGV4dHVyZSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ3BncHVfdXRpbC5kb3dubG9hZE1hdHJpeEZyb21SR0JBQ29sb3JUZXh0dXJlKF90aGlzLmdsLCByb3dzLCBjb2x1bW5zLCBjaGFubmVscyk7IH0pO1xuICAgIH07XG4gICAgR1BHUFVDb250ZXh0LnByb3RvdHlwZS5kb3dubG9hZE1hdHJpeEZyb21QYWNrZWRUZXh0dXJlID0gZnVuY3Rpb24gKHRleHR1cmUsIHJvd3MsIGNvbHVtbnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRoaXMuZG93bmxvYWRNYXRyaXhEcml2ZXIodGV4dHVyZSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ3BncHVfdXRpbC5kb3dubG9hZE1hdHJpeEZyb21QYWNrZWRPdXRwdXRUZXh0dXJlKF90aGlzLmdsLCByb3dzLCBjb2x1bW5zKTsgfSk7XG4gICAgfTtcbiAgICBHUEdQVUNvbnRleHQucHJvdG90eXBlLmNyZWF0ZVByb2dyYW0gPSBmdW5jdGlvbiAoZnJhZ21lbnRTaGFkZXJTb3VyY2UpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgdmFyIGdsID0gdGhpcy5nbDtcbiAgICAgICAgdmFyIGZyYWdtZW50U2hhZGVyID0gd2ViZ2xfdXRpbC5jcmVhdGVGcmFnbWVudFNoYWRlcihnbCwgZnJhZ21lbnRTaGFkZXJTb3VyY2UpO1xuICAgICAgICB2YXIgdmVydGV4U2hhZGVyID0gZ3BncHVfdXRpbC5jcmVhdGVWZXJ0ZXhTaGFkZXIoZ2wpO1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IHdlYmdsX3V0aWwuY3JlYXRlUHJvZ3JhbShnbCk7XG4gICAgICAgIHdlYmdsX3V0aWwuY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgdmVydGV4U2hhZGVyKTsgfSk7XG4gICAgICAgIHdlYmdsX3V0aWwuY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgZnJhZ21lbnRTaGFkZXIpOyB9KTtcbiAgICAgICAgd2ViZ2xfdXRpbC5saW5rUHJvZ3JhbShnbCwgcHJvZ3JhbSk7XG4gICAgICAgIGlmICh0aGlzLmF1dG9EZWJ1Z1ZhbGlkYXRlKSB7XG4gICAgICAgICAgICB3ZWJnbF91dGlsLnZhbGlkYXRlUHJvZ3JhbShnbCwgcHJvZ3JhbSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByb2dyYW07XG4gICAgfTtcbiAgICBHUEdQVUNvbnRleHQucHJvdG90eXBlLmRlbGV0ZVByb2dyYW0gPSBmdW5jdGlvbiAocHJvZ3JhbSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICBpZiAocHJvZ3JhbSA9PT0gdGhpcy5wcm9ncmFtKSB7XG4gICAgICAgICAgICB0aGlzLnByb2dyYW0gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9ncmFtICE9IG51bGwpIHtcbiAgICAgICAgICAgIHdlYmdsX3V0aWwuY2FsbEFuZENoZWNrKHRoaXMuZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmdsLmRlbGV0ZVByb2dyYW0ocHJvZ3JhbSk7IH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBHUEdQVUNvbnRleHQucHJvdG90eXBlLnNldFByb2dyYW0gPSBmdW5jdGlvbiAocHJvZ3JhbSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICB0aGlzLnByb2dyYW0gPSBwcm9ncmFtO1xuICAgICAgICBpZiAoKHRoaXMucHJvZ3JhbSAhPSBudWxsKSAmJiB0aGlzLmF1dG9EZWJ1Z1ZhbGlkYXRlKSB7XG4gICAgICAgICAgICB3ZWJnbF91dGlsLnZhbGlkYXRlUHJvZ3JhbSh0aGlzLmdsLCB0aGlzLnByb2dyYW0pO1xuICAgICAgICB9XG4gICAgICAgIHdlYmdsX3V0aWwuY2FsbEFuZENoZWNrKHRoaXMuZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmdsLnVzZVByb2dyYW0ocHJvZ3JhbSk7IH0pO1xuICAgIH07XG4gICAgR1BHUFVDb250ZXh0LnByb3RvdHlwZS5nZXRVbmlmb3JtTG9jYXRpb24gPSBmdW5jdGlvbiAocHJvZ3JhbSwgdW5pZm9ybU5hbWUpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIHdlYmdsX3V0aWwuZ2V0UHJvZ3JhbVVuaWZvcm1Mb2NhdGlvbk9yVGhyb3codGhpcy5nbCwgcHJvZ3JhbSwgdW5pZm9ybU5hbWUpO1xuICAgIH07XG4gICAgR1BHUFVDb250ZXh0LnByb3RvdHlwZS5nZXRBdHRyaWJ1dGVMb2NhdGlvbiA9IGZ1bmN0aW9uIChwcm9ncmFtLCBhdHRyaWJ1dGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIHdlYmdsX3V0aWwuY2FsbEFuZENoZWNrKHRoaXMuZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sIGF0dHJpYnV0ZSk7IH0pO1xuICAgIH07XG4gICAgR1BHUFVDb250ZXh0LnByb3RvdHlwZS5nZXRVbmlmb3JtTG9jYXRpb25Ob1Rocm93ID0gZnVuY3Rpb24gKHByb2dyYW0sIHVuaWZvcm1OYW1lKSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiB0aGlzLmdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCB1bmlmb3JtTmFtZSk7XG4gICAgfTtcbiAgICBHUEdQVUNvbnRleHQucHJvdG90eXBlLnNldElucHV0TWF0cml4VGV4dHVyZSA9IGZ1bmN0aW9uIChpbnB1dE1hdHJpeFRleHR1cmUsIHVuaWZvcm1Mb2NhdGlvbiwgdGV4dHVyZVVuaXQpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgdGhpcy50aHJvd0lmTm9Qcm9ncmFtKCk7XG4gICAgICAgIHdlYmdsX3V0aWwuYmluZFRleHR1cmVUb1Byb2dyYW1Vbmlmb3JtU2FtcGxlcih0aGlzLmdsLCB0aGlzLnByb2dyYW0sIGlucHV0TWF0cml4VGV4dHVyZSwgdW5pZm9ybUxvY2F0aW9uLCB0ZXh0dXJlVW5pdCk7XG4gICAgfTtcbiAgICBHUEdQVUNvbnRleHQucHJvdG90eXBlLnNldE91dHB1dE1hdHJpeFRleHR1cmUgPSBmdW5jdGlvbiAob3V0cHV0TWF0cml4VGV4dHVyZSwgcm93cywgY29sdW1ucykge1xuICAgICAgICB0aGlzLnNldE91dHB1dE1hdHJpeFRleHR1cmVEcml2ZXIob3V0cHV0TWF0cml4VGV4dHVyZSwgY29sdW1ucywgcm93cyk7XG4gICAgfTtcbiAgICBHUEdQVUNvbnRleHQucHJvdG90eXBlLnNldE91dHB1dFBhY2tlZE1hdHJpeFRleHR1cmUgPSBmdW5jdGlvbiAob3V0cHV0UGFja2VkTWF0cml4VGV4dHVyZSwgcm93cywgY29sdW1ucykge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICB2YXIgX2EgPSB0ZXhfdXRpbC5nZXRQYWNrZWRNYXRyaXhUZXh0dXJlU2hhcGVXaWR0aEhlaWdodChyb3dzLCBjb2x1bW5zKSwgd2lkdGggPSBfYVswXSwgaGVpZ2h0ID0gX2FbMV07XG4gICAgICAgIHRoaXMuc2V0T3V0cHV0TWF0cml4VGV4dHVyZURyaXZlcihvdXRwdXRQYWNrZWRNYXRyaXhUZXh0dXJlLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB9O1xuICAgIEdQR1BVQ29udGV4dC5wcm90b3R5cGUuc2V0T3V0cHV0TWF0cml4V3JpdGVSZWdpb24gPSBmdW5jdGlvbiAoc3RhcnRSb3csIG51bVJvd3MsIHN0YXJ0Q29sdW1uLCBudW1Db2x1bW5zKSB7XG4gICAgICAgIHRoaXMuc2V0T3V0cHV0TWF0cml4V3JpdGVSZWdpb25Ecml2ZXIoc3RhcnRDb2x1bW4sIHN0YXJ0Um93LCBudW1Db2x1bW5zLCBudW1Sb3dzKTtcbiAgICB9O1xuICAgIEdQR1BVQ29udGV4dC5wcm90b3R5cGUuc2V0T3V0cHV0UGFja2VkTWF0cml4V3JpdGVSZWdpb24gPSBmdW5jdGlvbiAoc3RhcnRSb3csIG51bVJvd3MsIHN0YXJ0Q29sdW1uLCBudW1Db2x1bW5zKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignc2V0T3V0cHV0UGFja2VkTWF0cml4V3JpdGVSZWdpb24gbm90IGltcGxlbWVudGVkLicpO1xuICAgIH07XG4gICAgR1BHUFVDb250ZXh0LnByb3RvdHlwZS5kZWJ1Z1ZhbGlkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5wcm9ncmFtICE9IG51bGwpIHtcbiAgICAgICAgICAgIHdlYmdsX3V0aWwudmFsaWRhdGVQcm9ncmFtKHRoaXMuZ2wsIHRoaXMucHJvZ3JhbSk7XG4gICAgICAgIH1cbiAgICAgICAgd2ViZ2xfdXRpbC52YWxpZGF0ZUZyYW1lYnVmZmVyKHRoaXMuZ2wpO1xuICAgIH07XG4gICAgR1BHUFVDb250ZXh0LnByb3RvdHlwZS5leGVjdXRlUHJvZ3JhbSA9IGZ1bmN0aW9uIChhdHRyaWJMb2NhdGlvbnMpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgdGhpcy50aHJvd0lmTm9Qcm9ncmFtKCk7XG4gICAgICAgIHZhciBnbCA9IHRoaXMuZ2w7XG4gICAgICAgIGdwZ3B1X3V0aWwuYmluZFZlcnRleFByb2dyYW1BdHRyaWJ1dGVTdHJlYW1zKGdsLCB0aGlzLnByb2dyYW0sIHRoaXMudmVydGV4QnVmZmVyLCBhdHRyaWJMb2NhdGlvbnMpO1xuICAgICAgICBpZiAodGhpcy5hdXRvRGVidWdWYWxpZGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5kZWJ1Z1ZhbGlkYXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmRyYXdFbGVtZW50cyhnbC5UUklBTkdMRVMsIDYsIGdsLlVOU0lHTkVEX1NIT1JULCAwKTsgfSk7XG4gICAgfTtcbiAgICBHUEdQVUNvbnRleHQucHJvdG90eXBlLmJsb2NrVW50aWxBbGxQcm9ncmFtc0NvbXBsZXRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2sodGhpcy5nbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuZ2wuZmluaXNoKCk7IH0pO1xuICAgIH07XG4gICAgR1BHUFVDb250ZXh0LnByb3RvdHlwZS5ydW5RdWVyeSA9IGZ1bmN0aW9uIChxdWVyeUZuKSB7XG4gICAgICAgIGlmIChlbnZpcm9ubWVudF8xLkVOVi5nZXQoJ1dFQkdMX1ZFUlNJT04nKSA9PT0gMikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucnVuUXVlcnlXZWJHTDIocXVlcnlGbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucnVuUXVlcnlXZWJHTDEocXVlcnlGbik7XG4gICAgfTtcbiAgICBHUEdQVUNvbnRleHQucHJvdG90eXBlLnJ1blF1ZXJ5V2ViR0wyID0gZnVuY3Rpb24gKGJlbmNobWFyaykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgZXh0ID0gd2ViZ2xfdXRpbC5nZXRFeHRlbnNpb25PclRocm93KHRoaXMuZ2wsICdFWFRfZGlzam9pbnRfdGltZXJfcXVlcnlfd2ViZ2wyJyk7XG4gICAgICAgIHZhciBxdWVyeSA9IHRoaXMuZ2wuY3JlYXRlUXVlcnkoKTtcbiAgICAgICAgdGhpcy5nbC5iZWdpblF1ZXJ5KGV4dC5USU1FX0VMQVBTRURfRVhULCBxdWVyeSk7XG4gICAgICAgIGJlbmNobWFyaygpO1xuICAgICAgICB0aGlzLmdsLmVuZFF1ZXJ5KGV4dC5USU1FX0VMQVBTRURfRVhUKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIHZhciBxdWVyeUdQVSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXZhaWxhYmxlID0gX3RoaXMuZ2xcbiAgICAgICAgICAgICAgICAgICAgLmdldFF1ZXJ5UGFyYW1ldGVyKHF1ZXJ5LCBfdGhpcy5nbC5RVUVSWV9SRVNVTFRfQVZBSUxBQkxFKTtcbiAgICAgICAgICAgICAgICB2YXIgZGlzam9pbnQgPSBfdGhpcy5nbC5nZXRQYXJhbWV0ZXIoZXh0LkdQVV9ESVNKT0lOVF9FWFQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBhdmFpbGFibGUgJiYgIWRpc2pvaW50O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBnZXRUaW1lRWxhcHNlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGltZUVsYXBzZWROYW5vcyA9IF90aGlzLmdsXG4gICAgICAgICAgICAgICAgICAgIC5nZXRRdWVyeVBhcmFtZXRlcihxdWVyeSwgX3RoaXMuZ2wuUVVFUllfUkVTVUxUKTtcbiAgICAgICAgICAgICAgICByZXNvbHZlKHRpbWVFbGFwc2VkTmFub3MgLyAxMDAwMDAwKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgcmVzb2x2ZVdpdGhXYXJuaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignRGlzam9pbnQgcXVlcnkgdGltZXIgbmV2ZXIgYXZhaWxhYmxlLicpO1xuICAgICAgICAgICAgICAgIHJlc29sdmUoLTEpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHV0aWwucmVwZWF0ZWRUcnkocXVlcnlHUFUpLnRoZW4oZ2V0VGltZUVsYXBzZWQpLmNhdGNoKHJlc29sdmVXaXRoV2FybmluZyk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgR1BHUFVDb250ZXh0LnByb3RvdHlwZS5ydW5RdWVyeVdlYkdMMSA9IGZ1bmN0aW9uIChiZW5jaG1hcmspIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGV4dCA9IHdlYmdsX3V0aWwuZ2V0RXh0ZW5zaW9uT3JUaHJvdyh0aGlzLmdsLCAnRVhUX2Rpc2pvaW50X3RpbWVyX3F1ZXJ5Jyk7XG4gICAgICAgIHZhciBxdWVyeSA9IGV4dC5jcmVhdGVRdWVyeUVYVCgpO1xuICAgICAgICBleHQuYmVnaW5RdWVyeUVYVChleHQuVElNRV9FTEFQU0VEX0VYVCwgcXVlcnkpO1xuICAgICAgICBiZW5jaG1hcmsoKTtcbiAgICAgICAgZXh0LmVuZFF1ZXJ5RVhUKGV4dC5USU1FX0VMQVBTRURfRVhUKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIHZhciBxdWVyeUdQVSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXZhaWxhYmxlID0gZXh0LmdldFF1ZXJ5T2JqZWN0RVhUKHF1ZXJ5LCBleHQuUVVFUllfUkVTVUxUX0FWQUlMQUJMRV9FWFQpO1xuICAgICAgICAgICAgICAgIHZhciBkaXNqb2ludCA9IF90aGlzLmdsLmdldFBhcmFtZXRlcihleHQuR1BVX0RJU0pPSU5UX0VYVCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF2YWlsYWJsZSAmJiAhZGlzam9pbnQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIGdldFRpbWVFbGFwc2VkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciB0aW1lRWxhcHNlZE5hbm9zID0gZXh0LmdldFF1ZXJ5T2JqZWN0RVhUKHF1ZXJ5LCBleHQuUVVFUllfUkVTVUxUX0VYVCk7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSh0aW1lRWxhcHNlZE5hbm9zIC8gMTAwMDAwMCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIHJlc29sdmVXaXRoV2FybmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ0Rpc2pvaW50IHF1ZXJ5IHRpbWVyIG5ldmVyIGF2YWlsYWJsZS4nKTtcbiAgICAgICAgICAgICAgICByZXNvbHZlKC0xKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB1dGlsLnJlcGVhdGVkVHJ5KHF1ZXJ5R1BVKS50aGVuKGdldFRpbWVFbGFwc2VkKS5jYXRjaChyZXNvbHZlV2l0aFdhcm5pbmcpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEdQR1BVQ29udGV4dC5wcm90b3R5cGUuZG93bmxvYWRNYXRyaXhEcml2ZXJTZXR1cCA9IGZ1bmN0aW9uICh0ZXh0dXJlKSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHdlYmdsX3V0aWwuYmluZENvbG9yVGV4dHVyZVRvRnJhbWVidWZmZXIodGhpcy5nbCwgdGV4dHVyZSwgdGhpcy5mcmFtZWJ1ZmZlcik7XG4gICAgICAgIGlmICh0aGlzLmF1dG9EZWJ1Z1ZhbGlkYXRlKSB7XG4gICAgICAgICAgICB3ZWJnbF91dGlsLnZhbGlkYXRlRnJhbWVidWZmZXIodGhpcy5nbCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEdQR1BVQ29udGV4dC5wcm90b3R5cGUuZG93bmxvYWRNYXRyaXhEcml2ZXJUZWFyZG93biA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMub3V0cHV0VGV4dHVyZSAhPSBudWxsKSB7XG4gICAgICAgICAgICB3ZWJnbF91dGlsLmJpbmRDb2xvclRleHR1cmVUb0ZyYW1lYnVmZmVyKHRoaXMuZ2wsIHRoaXMub3V0cHV0VGV4dHVyZSwgdGhpcy5mcmFtZWJ1ZmZlcik7XG4gICAgICAgICAgICBpZiAodGhpcy5hdXRvRGVidWdWYWxpZGF0ZSkge1xuICAgICAgICAgICAgICAgIHdlYmdsX3V0aWwudmFsaWRhdGVGcmFtZWJ1ZmZlcih0aGlzLmdsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHdlYmdsX3V0aWwudW5iaW5kQ29sb3JUZXh0dXJlRnJvbUZyYW1lYnVmZmVyKHRoaXMuZ2wsIHRoaXMuZnJhbWVidWZmZXIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBHUEdQVUNvbnRleHQucHJvdG90eXBlLmRvd25sb2FkTWF0cml4RHJpdmVyID0gZnVuY3Rpb24gKHRleHR1cmUsIGRvd25sb2FkQW5kRGVjb2RlKSB7XG4gICAgICAgIHRoaXMuZG93bmxvYWRNYXRyaXhEcml2ZXJTZXR1cCh0ZXh0dXJlKTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGRvd25sb2FkQW5kRGVjb2RlKCk7XG4gICAgICAgIHRoaXMuZG93bmxvYWRNYXRyaXhEcml2ZXJUZWFyZG93bigpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgR1BHUFVDb250ZXh0LnByb3RvdHlwZS5kb3dubG9hZE1hdHJpeERyaXZlckFzeW5jID0gZnVuY3Rpb24gKHRleHR1cmUsIGRvd25sb2FkQW5kRGVjb2RlKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRvd25sb2FkTWF0cml4RHJpdmVyU2V0dXAodGV4dHVyZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQsIGRvd25sb2FkQW5kRGVjb2RlKCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRvd25sb2FkTWF0cml4RHJpdmVyVGVhcmRvd24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiwgcmVzdWx0XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBHUEdQVUNvbnRleHQucHJvdG90eXBlLnNldE91dHB1dE1hdHJpeFRleHR1cmVEcml2ZXIgPSBmdW5jdGlvbiAob3V0cHV0TWF0cml4VGV4dHVyZU1heWJlUGFja2VkLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHZhciBnbCA9IHRoaXMuZ2w7XG4gICAgICAgIHdlYmdsX3V0aWwuYmluZENvbG9yVGV4dHVyZVRvRnJhbWVidWZmZXIoZ2wsIG91dHB1dE1hdHJpeFRleHR1cmVNYXliZVBhY2tlZCwgdGhpcy5mcmFtZWJ1ZmZlcik7XG4gICAgICAgIGlmICh0aGlzLmF1dG9EZWJ1Z1ZhbGlkYXRlKSB7XG4gICAgICAgICAgICB3ZWJnbF91dGlsLnZhbGlkYXRlRnJhbWVidWZmZXIoZ2wpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3V0cHV0VGV4dHVyZSA9IG91dHB1dE1hdHJpeFRleHR1cmVNYXliZVBhY2tlZDtcbiAgICAgICAgd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLnZpZXdwb3J0KDAsIDAsIHdpZHRoLCBoZWlnaHQpOyB9KTtcbiAgICAgICAgd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLnNjaXNzb3IoMCwgMCwgd2lkdGgsIGhlaWdodCk7IH0pO1xuICAgIH07XG4gICAgR1BHUFVDb250ZXh0LnByb3RvdHlwZS5zZXRPdXRwdXRNYXRyaXhXcml0ZVJlZ2lvbkRyaXZlciA9IGZ1bmN0aW9uICh4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHdlYmdsX3V0aWwuY2FsbEFuZENoZWNrKHRoaXMuZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmdsLnNjaXNzb3IoeCwgeSwgd2lkdGgsIGhlaWdodCk7IH0pO1xuICAgIH07XG4gICAgR1BHUFVDb250ZXh0LnByb3RvdHlwZS50aHJvd0lmRGlzcG9zZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmRpc3Bvc2VkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0F0dGVtcHRlZCB0byB1c2UgZGlzcG9zZWQgR1BHUFVDb250ZXh0LicpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBHUEdQVUNvbnRleHQucHJvdG90eXBlLnRocm93SWZOb1Byb2dyYW0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnByb2dyYW0gPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBHUFUgcHJvZ3JhbSBpcyBjdXJyZW50bHkgc2V0LicpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gR1BHUFVDb250ZXh0O1xufSgpKTtcbmV4cG9ydHMuR1BHUFVDb250ZXh0ID0gR1BHUFVDb250ZXh0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z3BncHVfY29udGV4dC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBlbnZpcm9ubWVudF8xID0gcmVxdWlyZShcIi4uLy4uL2Vudmlyb25tZW50XCIpO1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vLi4vdXRpbFwiKTtcbnZhciBzaGFkZXJfY29tcGlsZXIgPSByZXF1aXJlKFwiLi9zaGFkZXJfY29tcGlsZXJcIik7XG52YXIgQVRUUklCVVRFX05BTUVTID0gWyd1dicsICdjbGlwU3BhY2VQb3MnXTtcbnZhciBOQU5fVU5JRk9STV9OQU1FID0gJ05hTic7XG5mdW5jdGlvbiBzaG91bGRVcGxvYWROYU5Vbmlmb3JtKCkge1xuICAgIHJldHVybiAhZW52aXJvbm1lbnRfMS5FTlYuZ2V0KCdXRUJHTF9GTE9BVF9URVhUVVJFX0VOQUJMRUQnKTtcbn1cbmZ1bmN0aW9uIGNvbXBpbGVQcm9ncmFtKGdwZ3B1LCBwcm9ncmFtLCBpbnB1dHMsIG91dHB1dCkge1xuICAgIHZhciB1c2VyQ29kZSA9IHByb2dyYW0udXNlckNvZGU7XG4gICAgdmFyIGlucHV0SW5mb3MgPSBpbnB1dHMubWFwKGZ1bmN0aW9uIChpbnB1dCwgaSkge1xuICAgICAgICB2YXIgc2hhcGVJbmZvID0ge1xuICAgICAgICAgICAgbG9naWNhbFNoYXBlOiBpbnB1dC5zaGFwZSxcbiAgICAgICAgICAgIHRleFNoYXBlOiBpbnB1dC5nZXRUZXh0dXJlU2hhcGVSQygpLFxuICAgICAgICAgICAgdGV4dHVyZVR5cGU6IGlucHV0LmdldERhdGEoKS50ZXh0dXJlVHlwZVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4geyBuYW1lOiBwcm9ncmFtLnZhcmlhYmxlTmFtZXNbaV0sIHNoYXBlSW5mbzogc2hhcGVJbmZvIH07XG4gICAgfSk7XG4gICAgdmFyIGluU2hhcGVJbmZvcyA9IGlucHV0SW5mb3MubWFwKGZ1bmN0aW9uICh4KSB7IHJldHVybiB4LnNoYXBlSW5mbzsgfSk7XG4gICAgdmFyIG91dFNoYXBlSW5mbyA9IHtcbiAgICAgICAgbG9naWNhbFNoYXBlOiBvdXRwdXQuc2hhcGUsXG4gICAgICAgIHRleFNoYXBlOiBvdXRwdXQuZ2V0VGV4dHVyZVNoYXBlUkMoKSxcbiAgICAgICAgdGV4dHVyZVR5cGU6IG91dHB1dC5nZXREYXRhKCkudGV4dHVyZVR5cGVcbiAgICB9O1xuICAgIHZhciBzb3VyY2UgPSBzaGFkZXJfY29tcGlsZXIubWFrZVNoYWRlcihpbnB1dEluZm9zLCBvdXRTaGFwZUluZm8sIHVzZXJDb2RlLCBwcm9ncmFtLnN1cHBvcnRzQnJvYWRjYXN0aW5nID09PSB0cnVlKTtcbiAgICB2YXIgd2ViR0xQcm9ncmFtID0gZ3BncHUuY3JlYXRlUHJvZ3JhbShzb3VyY2UpO1xuICAgIHZhciB1bmlmb3JtTG9jYXRpb25zID0ge307XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9ncmFtLnZhcmlhYmxlTmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHVuaWZvcm1OYW1lID0gcHJvZ3JhbS52YXJpYWJsZU5hbWVzW2ldO1xuICAgICAgICB1bmlmb3JtTG9jYXRpb25zW3VuaWZvcm1OYW1lXSA9XG4gICAgICAgICAgICBncGdwdS5nZXRVbmlmb3JtTG9jYXRpb24od2ViR0xQcm9ncmFtLCB1bmlmb3JtTmFtZSk7XG4gICAgfVxuICAgIHZhciBhdHRyaWJ1dGVMb2NhdGlvbnMgPSB7fTtcbiAgICBBVFRSSUJVVEVfTkFNRVMuZm9yRWFjaChmdW5jdGlvbiAoYXR0cmlidXRlKSB7XG4gICAgICAgIGF0dHJpYnV0ZUxvY2F0aW9uc1thdHRyaWJ1dGVdID1cbiAgICAgICAgICAgIGdwZ3B1LmdldEF0dHJpYnV0ZUxvY2F0aW9uKHdlYkdMUHJvZ3JhbSwgYXR0cmlidXRlKTtcbiAgICB9KTtcbiAgICBpZiAoc2hvdWxkVXBsb2FkTmFOVW5pZm9ybSgpKSB7XG4gICAgICAgIHVuaWZvcm1Mb2NhdGlvbnNbTkFOX1VOSUZPUk1fTkFNRV0gPVxuICAgICAgICAgICAgZ3BncHUuZ2V0VW5pZm9ybUxvY2F0aW9uKHdlYkdMUHJvZ3JhbSwgTkFOX1VOSUZPUk1fTkFNRSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHByb2dyYW06IHByb2dyYW0sXG4gICAgICAgIHNvdXJjZTogc291cmNlLFxuICAgICAgICB3ZWJHTFByb2dyYW06IHdlYkdMUHJvZ3JhbSxcbiAgICAgICAgdW5pZm9ybUxvY2F0aW9uczogdW5pZm9ybUxvY2F0aW9ucyxcbiAgICAgICAgYXR0cmlidXRlTG9jYXRpb25zOiBhdHRyaWJ1dGVMb2NhdGlvbnMsXG4gICAgICAgIGdwZ3B1OiBncGdwdSxcbiAgICAgICAgaW5TaGFwZUluZm9zOiBpblNoYXBlSW5mb3MsXG4gICAgICAgIG91dFNoYXBlSW5mbzogb3V0U2hhcGVJbmZvXG4gICAgfTtcbn1cbmV4cG9ydHMuY29tcGlsZVByb2dyYW0gPSBjb21waWxlUHJvZ3JhbTtcbmZ1bmN0aW9uIHZhbGlkYXRlQmluYXJ5QW5kUHJvZ3JhbShzaGFwZUluZm9zLCBpbnB1dHMpIHtcbiAgICBpZiAoc2hhcGVJbmZvcy5sZW5ndGggIT09IGlucHV0cy5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJCaW5hcnkgd2FzIGNvbXBpbGVkIHdpdGggXCIgKyBzaGFwZUluZm9zLmxlbmd0aCArIFwiIGlucHV0cywgYnV0IFwiICtcbiAgICAgICAgICAgIChcIndhcyBleGVjdXRlZCB3aXRoIFwiICsgaW5wdXRzLmxlbmd0aCArIFwiIGlucHV0c1wiKSk7XG4gICAgfVxuICAgIHNoYXBlSW5mb3MuZm9yRWFjaChmdW5jdGlvbiAocywgaSkge1xuICAgICAgICB2YXIgc2hhcGVBID0gcy5sb2dpY2FsU2hhcGU7XG4gICAgICAgIHZhciB0ZXhTaGFwZUEgPSBzLnRleFNoYXBlO1xuICAgICAgICB2YXIgc2hhcGVCID0gaW5wdXRzW2ldLnNoYXBlO1xuICAgICAgICB2YXIgdGV4U2hhcGVCID0gaW5wdXRzW2ldLmdldFRleHR1cmVTaGFwZVJDKCk7XG4gICAgICAgIGlmICghdXRpbC5hcnJheXNFcXVhbChzaGFwZUEsIHNoYXBlQikpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwiQmluYXJ5IHdhcyBjb21waWxlZCB3aXRoIGRpZmZlcmVudCBzaGFwZXMgdGhhbiBcIiArXG4gICAgICAgICAgICAgICAgKFwidGhlIGN1cnJlbnQgYXJncy4gU2hhcGVzIFwiICsgc2hhcGVBICsgXCIgYW5kIFwiICsgc2hhcGVCICsgXCIgbXVzdCBtYXRjaFwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF1dGlsLmFycmF5c0VxdWFsKHRleFNoYXBlQSwgdGV4U2hhcGVCKSkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJCaW5hcnkgd2FzIGNvbXBpbGVkIHdpdGggZGlmZmVyZW50IHRleHR1cmUgc2hhcGVzIHRoYW4gdGhlXCIgK1xuICAgICAgICAgICAgICAgIChcIiBjdXJyZW50IGFyZ3MuIFNoYXBlIFwiICsgdGV4U2hhcGVBICsgXCIgYW5kIFwiICsgdGV4U2hhcGVCICsgXCIgbXVzdCBtYXRjaFwiKSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmZ1bmN0aW9uIHJ1blByb2dyYW0oYmluYXJ5LCBpbnB1dHMsIG91dHB1dCwgY3VzdG9tU2V0dXApIHtcbiAgICB2YWxpZGF0ZUJpbmFyeUFuZFByb2dyYW0oYmluYXJ5LmluU2hhcGVJbmZvcywgaW5wdXRzKTtcbiAgICB2YWxpZGF0ZUJpbmFyeUFuZFByb2dyYW0oW2JpbmFyeS5vdXRTaGFwZUluZm9dLCBbb3V0cHV0XSk7XG4gICAgdmFyIG91dFRleCA9IG91dHB1dC5nZXRUZXh0dXJlKCk7XG4gICAgdmFyIG91dFRleFNoYXBlID0gb3V0cHV0LmdldFRleHR1cmVTaGFwZVJDKCk7XG4gICAgdmFyIGdwZ3B1ID0gYmluYXJ5LmdwZ3B1O1xuICAgIGdwZ3B1LnNldE91dHB1dE1hdHJpeFRleHR1cmUob3V0VGV4LCBvdXRUZXhTaGFwZVswXSwgb3V0VGV4U2hhcGVbMV0pO1xuICAgIGdwZ3B1LnNldFByb2dyYW0oYmluYXJ5LndlYkdMUHJvZ3JhbSk7XG4gICAgaW5wdXRzLmZvckVhY2goZnVuY3Rpb24gKGlucHV0LCBpKSB7XG4gICAgICAgIHZhciB0ZXggPSBpbnB1dC5nZXRUZXh0dXJlKCk7XG4gICAgICAgIHZhciB2YXJpYWJsZU5hbWUgPSBiaW5hcnkucHJvZ3JhbS52YXJpYWJsZU5hbWVzW2ldO1xuICAgICAgICB2YXIgdmFyaWFibGVVbmlmb3JtTG9jYXRpb24gPSBiaW5hcnkudW5pZm9ybUxvY2F0aW9uc1t2YXJpYWJsZU5hbWVdO1xuICAgICAgICBncGdwdS5zZXRJbnB1dE1hdHJpeFRleHR1cmUodGV4LCB2YXJpYWJsZVVuaWZvcm1Mb2NhdGlvbiwgaSk7XG4gICAgfSk7XG4gICAgaWYgKHNob3VsZFVwbG9hZE5hTlVuaWZvcm0oKSkge1xuICAgICAgICBncGdwdS5nbC51bmlmb3JtMWYoYmluYXJ5LnVuaWZvcm1Mb2NhdGlvbnNbTkFOX1VOSUZPUk1fTkFNRV0sIE5hTik7XG4gICAgfVxuICAgIGlmIChjdXN0b21TZXR1cCAhPSBudWxsKSB7XG4gICAgICAgIGN1c3RvbVNldHVwKGdwZ3B1LCBiaW5hcnkud2ViR0xQcm9ncmFtKTtcbiAgICB9XG4gICAgZ3BncHUuZXhlY3V0ZVByb2dyYW0oYmluYXJ5LmF0dHJpYnV0ZUxvY2F0aW9ucyk7XG59XG5leHBvcnRzLnJ1blByb2dyYW0gPSBydW5Qcm9ncmFtO1xuZnVuY3Rpb24gbWFrZVNoYWRlcktleShwcm9ncmFtLCBpbnB1dHMsIG91dHB1dCkge1xuICAgIHZhciBrZXlJbnB1dHMgPSAnJztcbiAgICBpbnB1dHMuY29uY2F0KG91dHB1dCkuZm9yRWFjaChmdW5jdGlvbiAoeCkge1xuICAgICAgICBrZXlJbnB1dHMgKz0geC5zaGFwZSArIFwiX1wiICsgeC5nZXRUZXh0dXJlU2hhcGVSQygpO1xuICAgIH0pO1xuICAgIHZhciBrZXlVc2VyQ29kZSA9IHByb2dyYW0udXNlckNvZGU7XG4gICAgdmFyIGtleUJyb2FkY2FzdCA9IChwcm9ncmFtLnN1cHBvcnRzQnJvYWRjYXN0aW5nID09PSB0cnVlKS50b1N0cmluZygpO1xuICAgIHZhciBrZXkgPSBwcm9ncmFtLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAga2V5ICs9ICdfJyArIGtleUJyb2FkY2FzdCArICdfJyArIGtleUlucHV0cyArICdfJyArIGtleVVzZXJDb2RlO1xuICAgIHJldHVybiBrZXk7XG59XG5leHBvcnRzLm1ha2VTaGFkZXJLZXkgPSBtYWtlU2hhZGVyS2V5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z3BncHVfbWF0aC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUocmVzdWx0LnZhbHVlKTsgfSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9fZ2VuZXJhdG9yID0gKHRoaXMgJiYgdGhpcy5fX2dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IHlbb3BbMF0gJiAyID8gXCJyZXR1cm5cIiA6IG9wWzBdID8gXCJ0aHJvd1wiIDogXCJuZXh0XCJdKSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbMCwgdC52YWx1ZV07XG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcbiAgICB9XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGVudmlyb25tZW50XzEgPSByZXF1aXJlKFwiLi4vLi4vZW52aXJvbm1lbnRcIik7XG52YXIgdGV4X3V0aWwgPSByZXF1aXJlKFwiLi90ZXhfdXRpbFwiKTtcbnZhciB3ZWJnbF91dGlsID0gcmVxdWlyZShcIi4vd2ViZ2xfdXRpbFwiKTtcbmZ1bmN0aW9uIGdldFdlYkdMQ29udGV4dEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYWxwaGE6IGZhbHNlLFxuICAgICAgICBhbnRpYWxpYXM6IGZhbHNlLFxuICAgICAgICBwcmVtdWx0aXBsaWVkQWxwaGE6IGZhbHNlLFxuICAgICAgICBwcmVzZXJ2ZURyYXdpbmdCdWZmZXI6IGZhbHNlLFxuICAgICAgICBkZXB0aDogZmFsc2UsXG4gICAgICAgIHN0ZW5jaWw6IGZhbHNlLFxuICAgICAgICBmYWlsSWZNYWpvclBlcmZvcm1hbmNlQ2F2ZWF0OiB0cnVlXG4gICAgfTtcbn1cbmV4cG9ydHMuZ2V0V2ViR0xDb250ZXh0QXR0cmlidXRlcyA9IGdldFdlYkdMQ29udGV4dEF0dHJpYnV0ZXM7XG5mdW5jdGlvbiBjcmVhdGVXZWJHTENvbnRleHQoY2FudmFzKSB7XG4gICAgdmFyIGF0dHJpYnV0ZXMgPSBnZXRXZWJHTENvbnRleHRBdHRyaWJ1dGVzKCk7XG4gICAgdmFyIGdsO1xuICAgIGlmIChjYW52YXMgIT0gbnVsbCkge1xuICAgICAgICBnbCA9IHdlYmdsX3V0aWwuY3JlYXRlV2ViR0xSZW5kZXJpbmdDb250ZXh0RnJvbUNhbnZhcyhjYW52YXMsIGF0dHJpYnV0ZXMpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZ2wgPSB3ZWJnbF91dGlsLmNyZWF0ZVdlYkdMUmVuZGVyaW5nQ29udGV4dChhdHRyaWJ1dGVzKTtcbiAgICB9XG4gICAgd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmRpc2FibGUoZ2wuREVQVEhfVEVTVCk7IH0pO1xuICAgIHdlYmdsX3V0aWwuY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5kaXNhYmxlKGdsLlNURU5DSUxfVEVTVCk7IH0pO1xuICAgIHdlYmdsX3V0aWwuY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5kaXNhYmxlKGdsLkJMRU5EKTsgfSk7XG4gICAgd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmRpc2FibGUoZ2wuRElUSEVSKTsgfSk7XG4gICAgd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmRpc2FibGUoZ2wuUE9MWUdPTl9PRkZTRVRfRklMTCk7IH0pO1xuICAgIHdlYmdsX3V0aWwuY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5kaXNhYmxlKGdsLlNBTVBMRV9DT1ZFUkFHRSk7IH0pO1xuICAgIHdlYmdsX3V0aWwuY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5lbmFibGUoZ2wuU0NJU1NPUl9URVNUKTsgfSk7XG4gICAgd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmVuYWJsZShnbC5DVUxMX0ZBQ0UpOyB9KTtcbiAgICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuY3VsbEZhY2UoZ2wuQkFDSyk7IH0pO1xuICAgIHJldHVybiBnbDtcbn1cbmV4cG9ydHMuY3JlYXRlV2ViR0xDb250ZXh0ID0gY3JlYXRlV2ViR0xDb250ZXh0O1xuZnVuY3Rpb24gY3JlYXRlVmVydGV4U2hhZGVyKGdsKSB7XG4gICAgdmFyIHZlcnRleFNoYWRlclNvdXJjZSA9IFwiXFxuICAgIHByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4gICAgYXR0cmlidXRlIHZlYzMgY2xpcFNwYWNlUG9zO1xcbiAgICBhdHRyaWJ1dGUgdmVjMiB1djtcXG4gICAgdmFyeWluZyB2ZWMyIHJlc3VsdFVWO1xcblxcbiAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgZ2xfUG9zaXRpb24gPSB2ZWM0KGNsaXBTcGFjZVBvcywgMSk7XFxuICAgICAgcmVzdWx0VVYgPSB1djtcXG4gICAgfVwiO1xuICAgIHJldHVybiB3ZWJnbF91dGlsLmNyZWF0ZVZlcnRleFNoYWRlcihnbCwgdmVydGV4U2hhZGVyU291cmNlKTtcbn1cbmV4cG9ydHMuY3JlYXRlVmVydGV4U2hhZGVyID0gY3JlYXRlVmVydGV4U2hhZGVyO1xuZnVuY3Rpb24gY3JlYXRlVmVydGV4QnVmZmVyKGdsKSB7XG4gICAgdmFyIHZlcnRleEFycmF5ID0gbmV3IEZsb2F0MzJBcnJheShbLTEsIDEsIDAsIDAsIDEsIC0xLCAtMSwgMCwgMCwgMCwgMSwgMSwgMCwgMSwgMSwgMSwgLTEsIDAsIDEsIDBdKTtcbiAgICByZXR1cm4gd2ViZ2xfdXRpbC5jcmVhdGVTdGF0aWNWZXJ0ZXhCdWZmZXIoZ2wsIHZlcnRleEFycmF5KTtcbn1cbmV4cG9ydHMuY3JlYXRlVmVydGV4QnVmZmVyID0gY3JlYXRlVmVydGV4QnVmZmVyO1xuZnVuY3Rpb24gY3JlYXRlSW5kZXhCdWZmZXIoZ2wpIHtcbiAgICB2YXIgdHJpYW5nbGVWZXJ0ZXhJbmRpY2VzID0gbmV3IFVpbnQxNkFycmF5KFswLCAxLCAyLCAyLCAxLCAzXSk7XG4gICAgcmV0dXJuIHdlYmdsX3V0aWwuY3JlYXRlU3RhdGljSW5kZXhCdWZmZXIoZ2wsIHRyaWFuZ2xlVmVydGV4SW5kaWNlcyk7XG59XG5leHBvcnRzLmNyZWF0ZUluZGV4QnVmZmVyID0gY3JlYXRlSW5kZXhCdWZmZXI7XG5mdW5jdGlvbiBnZXRUZXh0dXJlSW50ZXJuYWxGb3JtYXQoZ2wsIG51bUNoYW5uZWxzKSB7XG4gICAgaWYgKCFlbnZpcm9ubWVudF8xLkVOVi5nZXQoJ1dFQkdMX0ZMT0FUX1RFWFRVUkVfRU5BQkxFRCcpKSB7XG4gICAgICAgIHJldHVybiBnbC5SR0JBO1xuICAgIH1cbiAgICBpZiAoZW52aXJvbm1lbnRfMS5FTlYuZ2V0KCdXRUJHTF9WRVJTSU9OJykgPT09IDIpIHtcbiAgICAgICAgaWYgKG51bUNoYW5uZWxzID09PSA0KSB7XG4gICAgICAgICAgICByZXR1cm4gZ2wuUkdCQTMyRjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ2wuUjMyRjtcbiAgICB9XG4gICAgcmV0dXJuIGdsLlJHQkE7XG59XG5mdW5jdGlvbiBnZXRUZXh0dXJlRm9ybWF0KGdsLCBudW1DaGFubmVscykge1xuICAgIGlmICghZW52aXJvbm1lbnRfMS5FTlYuZ2V0KCdXRUJHTF9GTE9BVF9URVhUVVJFX0VOQUJMRUQnKSkge1xuICAgICAgICByZXR1cm4gZ2wuUkdCQTtcbiAgICB9XG4gICAgaWYgKGVudmlyb25tZW50XzEuRU5WLmdldCgnV0VCR0xfVkVSU0lPTicpID09PSAyKSB7XG4gICAgICAgIGlmIChudW1DaGFubmVscyA9PT0gNCkge1xuICAgICAgICAgICAgcmV0dXJuIGdsLlJHQkE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdsLlJFRDtcbiAgICB9XG4gICAgcmV0dXJuIGdsLlJHQkE7XG59XG5mdW5jdGlvbiBnZXRUZXh0dXJlVHlwZShnbCkge1xuICAgIGlmICghZW52aXJvbm1lbnRfMS5FTlYuZ2V0KCdXRUJHTF9GTE9BVF9URVhUVVJFX0VOQUJMRUQnKSkge1xuICAgICAgICByZXR1cm4gZ2wuVU5TSUdORURfQllURTtcbiAgICB9XG4gICAgcmV0dXJuIGdsLkZMT0FUO1xufVxuZnVuY3Rpb24gY3JlYXRlQW5kQ29uZmlndXJlVGV4dHVyZShnbCwgd2lkdGgsIGhlaWdodCwgbnVtQ2hhbm5lbHMpIHtcbiAgICB3ZWJnbF91dGlsLnZhbGlkYXRlVGV4dHVyZVNpemUoZ2wsIHdpZHRoLCBoZWlnaHQpO1xuICAgIHZhciB0ZXh0dXJlID0gd2ViZ2xfdXRpbC5jcmVhdGVUZXh0dXJlKGdsKTtcbiAgICB2YXIgdGV4MmQgPSBnbC5URVhUVVJFXzJEO1xuICAgIHZhciBpbnRlcm5hbEZvcm1hdCA9IGdldFRleHR1cmVJbnRlcm5hbEZvcm1hdChnbCwgbnVtQ2hhbm5lbHMpO1xuICAgIHZhciBmb3JtYXQgPSBnZXRUZXh0dXJlRm9ybWF0KGdsLCBudW1DaGFubmVscyk7XG4gICAgd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmJpbmRUZXh0dXJlKHRleDJkLCB0ZXh0dXJlKTsgfSk7XG4gICAgd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLnRleFBhcmFtZXRlcmkodGV4MmQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbC5DTEFNUF9UT19FREdFKTsgfSk7XG4gICAgd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLnRleFBhcmFtZXRlcmkodGV4MmQsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbC5DTEFNUF9UT19FREdFKTsgfSk7XG4gICAgd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLnRleFBhcmFtZXRlcmkodGV4MmQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZ2wuTkVBUkVTVCk7IH0pO1xuICAgIHdlYmdsX3V0aWwuY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC50ZXhQYXJhbWV0ZXJpKHRleDJkLCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLk5FQVJFU1QpOyB9KTtcbiAgICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wudGV4SW1hZ2UyRCh0ZXgyZCwgMCwgaW50ZXJuYWxGb3JtYXQsIHdpZHRoLCBoZWlnaHQsIDAsIGZvcm1hdCwgZ2V0VGV4dHVyZVR5cGUoZ2wpLCBudWxsKTsgfSk7XG4gICAgd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIG51bGwpOyB9KTtcbiAgICByZXR1cm4gdGV4dHVyZTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZU1hdHJpeFRleHR1cmUoZ2wsIHJvd3MsIGNvbHVtbnMpIHtcbiAgICB2YXIgX2EgPSB0ZXhfdXRpbC5nZXRVbnBhY2tlZE1hdHJpeFRleHR1cmVTaGFwZVdpZHRoSGVpZ2h0KHJvd3MsIGNvbHVtbnMpLCB3aWR0aCA9IF9hWzBdLCBoZWlnaHQgPSBfYVsxXTtcbiAgICB2YXIgbnVtQ2hhbm5lbHMgPSAxO1xuICAgIHJldHVybiBjcmVhdGVBbmRDb25maWd1cmVUZXh0dXJlKGdsLCB3aWR0aCwgaGVpZ2h0LCBudW1DaGFubmVscyk7XG59XG5leHBvcnRzLmNyZWF0ZU1hdHJpeFRleHR1cmUgPSBjcmVhdGVNYXRyaXhUZXh0dXJlO1xuZnVuY3Rpb24gY3JlYXRlQ29sb3JNYXRyaXhUZXh0dXJlKGdsLCByb3dzLCBjb2x1bW5zKSB7XG4gICAgdmFyIF9hID0gdGV4X3V0aWwuZ2V0Q29sb3JNYXRyaXhUZXh0dXJlU2hhcGVXaWR0aEhlaWdodChyb3dzLCBjb2x1bW5zKSwgd2lkdGggPSBfYVswXSwgaGVpZ2h0ID0gX2FbMV07XG4gICAgdmFyIG51bUNoYW5uZWxzID0gNDtcbiAgICByZXR1cm4gY3JlYXRlQW5kQ29uZmlndXJlVGV4dHVyZShnbCwgd2lkdGgsIGhlaWdodCwgbnVtQ2hhbm5lbHMpO1xufVxuZXhwb3J0cy5jcmVhdGVDb2xvck1hdHJpeFRleHR1cmUgPSBjcmVhdGVDb2xvck1hdHJpeFRleHR1cmU7XG5mdW5jdGlvbiBjcmVhdGVQYWNrZWRNYXRyaXhUZXh0dXJlKGdsLCByb3dzLCBjb2x1bW5zKSB7XG4gICAgdmFyIF9hID0gdGV4X3V0aWwuZ2V0UGFja2VkTWF0cml4VGV4dHVyZVNoYXBlV2lkdGhIZWlnaHQocm93cywgY29sdW1ucyksIHdpZHRoID0gX2FbMF0sIGhlaWdodCA9IF9hWzFdO1xuICAgIHZhciBudW1DaGFubmVscyA9IDQ7XG4gICAgcmV0dXJuIGNyZWF0ZUFuZENvbmZpZ3VyZVRleHR1cmUoZ2wsIHdpZHRoLCBoZWlnaHQsIG51bUNoYW5uZWxzKTtcbn1cbmV4cG9ydHMuY3JlYXRlUGFja2VkTWF0cml4VGV4dHVyZSA9IGNyZWF0ZVBhY2tlZE1hdHJpeFRleHR1cmU7XG5mdW5jdGlvbiBiaW5kVmVydGV4UHJvZ3JhbUF0dHJpYnV0ZVN0cmVhbXMoZ2wsIHByb2dyYW0sIHZlcnRleEJ1ZmZlciwgYXR0cmliTG9jYXRpb25zKSB7XG4gICAgdmFyIHBvc09mZnNldCA9IDA7XG4gICAgdmFyIHV2T2Zmc2V0ID0gMyAqIDQ7XG4gICAgdmFyIHN0cmlkZSA9ICgzICogNCkgKyAoMiAqIDQpO1xuICAgIHdlYmdsX3V0aWwuY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgdmVydGV4QnVmZmVyKTsgfSk7XG4gICAgd2ViZ2xfdXRpbC5iaW5kVmVydGV4QnVmZmVyVG9Qcm9ncmFtQXR0cmlidXRlKGdsLCBwcm9ncmFtLCAnY2xpcFNwYWNlUG9zJywgdmVydGV4QnVmZmVyLCAzLCBzdHJpZGUsIHBvc09mZnNldCwgYXR0cmliTG9jYXRpb25zKTtcbiAgICB3ZWJnbF91dGlsLmJpbmRWZXJ0ZXhCdWZmZXJUb1Byb2dyYW1BdHRyaWJ1dGUoZ2wsIHByb2dyYW0sICd1dicsIHZlcnRleEJ1ZmZlciwgMiwgc3RyaWRlLCB1dk9mZnNldCwgYXR0cmliTG9jYXRpb25zKTtcbn1cbmV4cG9ydHMuYmluZFZlcnRleFByb2dyYW1BdHRyaWJ1dGVTdHJlYW1zID0gYmluZFZlcnRleFByb2dyYW1BdHRyaWJ1dGVTdHJlYW1zO1xuZnVuY3Rpb24gdXBsb2FkUGl4ZWxEYXRhVG9UZXh0dXJlKGdsLCB0ZXh0dXJlLCBwaXhlbHMpIHtcbiAgICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSk7IH0pO1xuICAgIHdlYmdsX3V0aWwuY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIHBpeGVscyk7IH0pO1xuICAgIHdlYmdsX3V0aWwuY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBudWxsKTsgfSk7XG59XG5leHBvcnRzLnVwbG9hZFBpeGVsRGF0YVRvVGV4dHVyZSA9IHVwbG9hZFBpeGVsRGF0YVRvVGV4dHVyZTtcbmZ1bmN0aW9uIHVwbG9hZERhdGFUb1RleHR1cmUoZ2wsIHRleHR1cmUsIHdpZHRoLCBoZWlnaHQsIGRhdGEsIG51bUNoYW5uZWxzKSB7XG4gICAgdmFyIHRleHR1cmVGb3JtYXQgPSBnZXRUZXh0dXJlRm9ybWF0KGdsLCBudW1DaGFubmVscyk7XG4gICAgd2ViZ2xfdXRpbC52YWxpZGF0ZVRleHR1cmVTaXplKGdsLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSk7IH0pO1xuICAgIHdlYmdsX3V0aWwuY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC50ZXhTdWJJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIDAsIDAsIHdpZHRoLCBoZWlnaHQsIHRleHR1cmVGb3JtYXQsIGdldFRleHR1cmVUeXBlKGdsKSwgZGF0YSk7IH0pO1xuICAgIHdlYmdsX3V0aWwuY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBudWxsKTsgfSk7XG59XG5mdW5jdGlvbiB1cGxvYWRNYXRyaXhUb1RleHR1cmUoZ2wsIHRleHR1cmUsIHJvd3MsIGNvbHVtbnMsIG1hdHJpeCwgbnVtQ2hhbm5lbHMpIHtcbiAgICB2YXIgX2EgPSB0ZXhfdXRpbC5nZXRVbnBhY2tlZE1hdHJpeFRleHR1cmVTaGFwZVdpZHRoSGVpZ2h0KHJvd3MsIGNvbHVtbnMpLCB3ID0gX2FbMF0sIGggPSBfYVsxXTtcbiAgICB2YXIgdW5wYWNrZWRBcnJheTtcbiAgICBpZiAoZW52aXJvbm1lbnRfMS5FTlYuZ2V0KCdXRUJHTF9GTE9BVF9URVhUVVJFX0VOQUJMRUQnKSkge1xuICAgICAgICB2YXIgY2hhbm5lbHNQZXJUZXh0dXJlID0gbnVtQ2hhbm5lbHMgPT09IDEgPyB3ZWJnbF91dGlsLmdldENoYW5uZWxzUGVyVGV4dHVyZSgpIDogbnVtQ2hhbm5lbHM7XG4gICAgICAgIGlmIChjaGFubmVsc1BlclRleHR1cmUgPT09IDEpIHtcbiAgICAgICAgICAgIHVucGFja2VkQXJyYXkgPSBtYXRyaXg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB1bnBhY2tlZEFycmF5ID1cbiAgICAgICAgICAgICAgICBuZXcgRmxvYXQzMkFycmF5KHRleF91dGlsLmdldFVucGFja2VkQXJyYXlTaXplRnJvbU1hdHJpeFNpemUobWF0cml4Lmxlbmd0aCwgY2hhbm5lbHNQZXJUZXh0dXJlKSk7XG4gICAgICAgICAgICB0ZXhfdXRpbC5lbmNvZGVNYXRyaXhUb1VucGFja2VkQXJyYXkobWF0cml4LCB1bnBhY2tlZEFycmF5LCBjaGFubmVsc1BlclRleHR1cmUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB1bnBhY2tlZEFycmF5ID0gdGV4X3V0aWwuZW5jb2RlRmxvYXRBcnJheShtYXRyaXgpO1xuICAgIH1cbiAgICB1cGxvYWREYXRhVG9UZXh0dXJlKGdsLCB0ZXh0dXJlLCB3LCBoLCB1bnBhY2tlZEFycmF5LCBudW1DaGFubmVscyk7XG59XG5leHBvcnRzLnVwbG9hZE1hdHJpeFRvVGV4dHVyZSA9IHVwbG9hZE1hdHJpeFRvVGV4dHVyZTtcbmZ1bmN0aW9uIHVwbG9hZE1hdHJpeFRvUGFja2VkVGV4dHVyZShnbCwgdGV4dHVyZSwgcm93cywgY29sdW1ucywgbWF0cml4KSB7XG4gICAgdmFyIF9hID0gdGV4X3V0aWwuZ2V0UGFja2VkTWF0cml4VGV4dHVyZVNoYXBlV2lkdGhIZWlnaHQocm93cywgY29sdW1ucyksIHcgPSBfYVswXSwgaCA9IF9hWzFdO1xuICAgIHZhciBwYWNrZWRSR0JBID0gbmV3IEZsb2F0MzJBcnJheSh0ZXhfdXRpbC5nZXRQYWNrZWRSR0JBQXJyYXlTaXplRnJvbU1hdHJpeFNoYXBlKHJvd3MsIGNvbHVtbnMpKTtcbiAgICB0ZXhfdXRpbC5lbmNvZGVNYXRyaXhUb1BhY2tlZFJHQkEobWF0cml4LCByb3dzLCBjb2x1bW5zLCBwYWNrZWRSR0JBKTtcbiAgICB2YXIgbnVtQ2hhbm5lbHMgPSA0O1xuICAgIHVwbG9hZERhdGFUb1RleHR1cmUoZ2wsIHRleHR1cmUsIHcsIGgsIHBhY2tlZFJHQkEsIG51bUNoYW5uZWxzKTtcbn1cbmV4cG9ydHMudXBsb2FkTWF0cml4VG9QYWNrZWRUZXh0dXJlID0gdXBsb2FkTWF0cml4VG9QYWNrZWRUZXh0dXJlO1xuZnVuY3Rpb24gZ2V0RG93bmxvYWRUYXJnZXRBcnJheUJ1ZmZlcihyb3dzLCBjb2x1bW5zLCBjaGFubmVsc1BlclRleHR1cmUpIHtcbiAgICB2YXIgaXNGbG9hdFRleHR1cmUgPSBlbnZpcm9ubWVudF8xLkVOVi5nZXQoJ1dFQkdMX0ZMT0FUX1RFWFRVUkVfRU5BQkxFRCcpO1xuICAgIHZhciBkb3dubG9hZFRhcmdldDtcbiAgICBpZiAoaXNGbG9hdFRleHR1cmUpIHtcbiAgICAgICAgZG93bmxvYWRUYXJnZXQgPVxuICAgICAgICAgICAgbmV3IEZsb2F0MzJBcnJheSh0ZXhfdXRpbC5nZXRVbnBhY2tlZEFycmF5U2l6ZUZyb21NYXRyaXhTaXplKHJvd3MgKiBjb2x1bW5zLCBjaGFubmVsc1BlclRleHR1cmUpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGRvd25sb2FkVGFyZ2V0ID0gbmV3IFVpbnQ4QXJyYXkocm93cyAqIGNvbHVtbnMgKiBjaGFubmVsc1BlclRleHR1cmUpO1xuICAgIH1cbiAgICByZXR1cm4gZG93bmxvYWRUYXJnZXQ7XG59XG5mdW5jdGlvbiBkZWNvZGVEb3dubG9hZFRhcmdldEFycmF5QnVmZmVyKGRvd25sb2FkVGFyZ2V0LCByb3dzLCBjb2x1bW5zLCBjaGFubmVsc1BlclBpeGVsKSB7XG4gICAgdmFyIGlzRmxvYXRUZXh0dXJlID0gZW52aXJvbm1lbnRfMS5FTlYuZ2V0KCdXRUJHTF9GTE9BVF9URVhUVVJFX0VOQUJMRUQnKTtcbiAgICBpZiAoaXNGbG9hdFRleHR1cmUpIHtcbiAgICAgICAgdmFyIG1hdHJpeCA9IG5ldyBGbG9hdDMyQXJyYXkocm93cyAqIGNvbHVtbnMpO1xuICAgICAgICB0ZXhfdXRpbC5kZWNvZGVNYXRyaXhGcm9tVW5wYWNrZWRBcnJheShkb3dubG9hZFRhcmdldCwgbWF0cml4LCBjaGFubmVsc1BlclBpeGVsKTtcbiAgICAgICAgcmV0dXJuIG1hdHJpeDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB0ZXhfdXRpbC5kZWNvZGVUb0Zsb2F0QXJyYXkoZG93bmxvYWRUYXJnZXQpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGRvd25sb2FkTWF0cml4RnJvbU91dHB1dFRleHR1cmVBc3luYyhnbCwgZ2V0QnVmZmVyU3ViRGF0YUFzeW5jRXh0ZW5zaW9uLCByb3dzLCBjb2x1bW5zKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZ2wyLCBjaGFubmVsc1BlclBpeGVsLCBkb3dubG9hZFRhcmdldCwgYnVmZmVyU2l6ZUJ5dGVzLCBidWZmZXI7XG4gICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgIGdsMiA9IGdsO1xuICAgICAgICAgICAgICAgICAgICBjaGFubmVsc1BlclBpeGVsID0gNDtcbiAgICAgICAgICAgICAgICAgICAgZG93bmxvYWRUYXJnZXQgPSBnZXREb3dubG9hZFRhcmdldEFycmF5QnVmZmVyKHJvd3MsIGNvbHVtbnMsIGNoYW5uZWxzUGVyUGl4ZWwpO1xuICAgICAgICAgICAgICAgICAgICBidWZmZXJTaXplQnl0ZXMgPSBkb3dubG9hZFRhcmdldCBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSA/XG4gICAgICAgICAgICAgICAgICAgICAgICBkb3dubG9hZFRhcmdldC5sZW5ndGggKiA0IDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvd25sb2FkVGFyZ2V0O1xuICAgICAgICAgICAgICAgICAgICBidWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmJpbmRCdWZmZXIoZ2wyLlBJWEVMX1BBQ0tfQlVGRkVSLCBidWZmZXIpOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmJ1ZmZlckRhdGEoZ2wyLlBJWEVMX1BBQ0tfQlVGRkVSLCBidWZmZXJTaXplQnl0ZXMsIGdsLlNUQVRJQ19EUkFXKTsgfSk7XG4gICAgICAgICAgICAgICAgICAgIHdlYmdsX3V0aWwuY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2wyLnJlYWRQaXhlbHMoMCwgMCwgY29sdW1ucywgcm93cywgZ2wuUkdCQSwgZ2V0VGV4dHVyZVR5cGUoZ2wpLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCwgZ2V0QnVmZmVyU3ViRGF0YUFzeW5jRXh0ZW5zaW9uLmdldEJ1ZmZlclN1YkRhdGFBc3luYyhnbDIuUElYRUxfUEFDS19CVUZGRVIsIDAsIGRvd25sb2FkVGFyZ2V0KV07XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiwgZGVjb2RlRG93bmxvYWRUYXJnZXRBcnJheUJ1ZmZlcihkb3dubG9hZFRhcmdldCwgcm93cywgY29sdW1ucywgY2hhbm5lbHNQZXJQaXhlbCldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbmV4cG9ydHMuZG93bmxvYWRNYXRyaXhGcm9tT3V0cHV0VGV4dHVyZUFzeW5jID0gZG93bmxvYWRNYXRyaXhGcm9tT3V0cHV0VGV4dHVyZUFzeW5jO1xuZnVuY3Rpb24gZG93bmxvYWRNYXRyaXhGcm9tT3V0cHV0VGV4dHVyZShnbCwgcm93cywgY29sdW1ucykge1xuICAgIHZhciBfYSA9IHRleF91dGlsLmdldFVucGFja2VkTWF0cml4VGV4dHVyZVNoYXBlV2lkdGhIZWlnaHQocm93cywgY29sdW1ucyksIHcgPSBfYVswXSwgaCA9IF9hWzFdO1xuICAgIHZhciBjaGFubmVsc1BlclBpeGVsID0gNDtcbiAgICB2YXIgZG93bmxvYWRUYXJnZXQgPSBnZXREb3dubG9hZFRhcmdldEFycmF5QnVmZmVyKHJvd3MsIGNvbHVtbnMsIGNoYW5uZWxzUGVyUGl4ZWwpO1xuICAgIHdlYmdsX3V0aWwuY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5yZWFkUGl4ZWxzKDAsIDAsIHcsIGgsIGdsLlJHQkEsIGdldFRleHR1cmVUeXBlKGdsKSwgZG93bmxvYWRUYXJnZXQpOyB9KTtcbiAgICByZXR1cm4gZGVjb2RlRG93bmxvYWRUYXJnZXRBcnJheUJ1ZmZlcihkb3dubG9hZFRhcmdldCwgcm93cywgY29sdW1ucywgY2hhbm5lbHNQZXJQaXhlbCk7XG59XG5leHBvcnRzLmRvd25sb2FkTWF0cml4RnJvbU91dHB1dFRleHR1cmUgPSBkb3dubG9hZE1hdHJpeEZyb21PdXRwdXRUZXh0dXJlO1xuZnVuY3Rpb24gZG93bmxvYWRNYXRyaXhGcm9tUkdCQUNvbG9yVGV4dHVyZShnbCwgcm93cywgY29sdW1ucywgY2hhbm5lbHMpIHtcbiAgICB2YXIgc2l6ZSA9IHJvd3MgKiBjb2x1bW5zICogNDtcbiAgICB2YXIgZG93bmxvYWRUYXJnZXQgPSBuZXcgVWludDhBcnJheShzaXplKTtcbiAgICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wucmVhZFBpeGVscygwLCAwLCBjb2x1bW5zLCByb3dzLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCBkb3dubG9hZFRhcmdldCk7IH0pO1xuICAgIHZhciBwYWNrZWRSR0JBID0gbmV3IEZsb2F0MzJBcnJheShzaXplKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRvd25sb2FkVGFyZ2V0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHBhY2tlZFJHQkFbaV0gPSBkb3dubG9hZFRhcmdldFtpXTtcbiAgICB9XG4gICAgdmFyIG1hdHJpeCA9IG5ldyBGbG9hdDMyQXJyYXkocm93cyAqIGNvbHVtbnMgKiBjaGFubmVscyk7XG4gICAgdGV4X3V0aWwuZGVjb2RlTWF0cml4RnJvbVVucGFja2VkQ29sb3JSR0JBQXJyYXkocGFja2VkUkdCQSwgbWF0cml4LCBjaGFubmVscyk7XG4gICAgcmV0dXJuIG1hdHJpeDtcbn1cbmV4cG9ydHMuZG93bmxvYWRNYXRyaXhGcm9tUkdCQUNvbG9yVGV4dHVyZSA9IGRvd25sb2FkTWF0cml4RnJvbVJHQkFDb2xvclRleHR1cmU7XG5mdW5jdGlvbiBkb3dubG9hZE1hdHJpeEZyb21QYWNrZWRPdXRwdXRUZXh0dXJlKGdsLCByb3dzLCBjb2x1bW5zKSB7XG4gICAgdmFyIF9hID0gdGV4X3V0aWwuZ2V0UGFja2VkTWF0cml4VGV4dHVyZVNoYXBlV2lkdGhIZWlnaHQocm93cywgY29sdW1ucyksIHcgPSBfYVswXSwgaCA9IF9hWzFdO1xuICAgIHZhciBwYWNrZWRSR0JBID0gbmV3IEZsb2F0MzJBcnJheSh0ZXhfdXRpbC5nZXRQYWNrZWRSR0JBQXJyYXlTaXplRnJvbU1hdHJpeFNoYXBlKHJvd3MsIGNvbHVtbnMpKTtcbiAgICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wucmVhZFBpeGVscygwLCAwLCB3LCBoLCBnbC5SR0JBLCBnZXRUZXh0dXJlVHlwZShnbCksIHBhY2tlZFJHQkEpOyB9KTtcbiAgICB2YXIgbWF0cml4ID0gbmV3IEZsb2F0MzJBcnJheShyb3dzICogY29sdW1ucyk7XG4gICAgcmV0dXJuIHRleF91dGlsLmRlY29kZU1hdHJpeEZyb21QYWNrZWRSR0JBKHBhY2tlZFJHQkEsIHJvd3MsIGNvbHVtbnMsIG1hdHJpeCk7XG59XG5leHBvcnRzLmRvd25sb2FkTWF0cml4RnJvbVBhY2tlZE91dHB1dFRleHR1cmUgPSBkb3dubG9hZE1hdHJpeEZyb21QYWNrZWRPdXRwdXRUZXh0dXJlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z3BncHVfdXRpbC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBNYXhQb29sMkRCYWNrcHJvcFByb2dyYW0gPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1heFBvb2wyREJhY2twcm9wUHJvZ3JhbShjb252SW5mbykge1xuICAgICAgICB0aGlzLnZhcmlhYmxlTmFtZXMgPSBbJ2R5JywgJ21heFBvcyddO1xuICAgICAgICB0aGlzLm91dHB1dFNoYXBlID0gY29udkluZm8uaW5TaGFwZTtcbiAgICAgICAgdmFyIGR5Um93cyA9IGNvbnZJbmZvLm91dFNoYXBlWzBdO1xuICAgICAgICB2YXIgZHlDb2xzID0gY29udkluZm8ub3V0U2hhcGVbMV07XG4gICAgICAgIHZhciBmaWx0ZXJIZWlnaHQgPSBjb252SW5mby5maWx0ZXJIZWlnaHQ7XG4gICAgICAgIHZhciBmaWx0ZXJXaWR0aCA9IGNvbnZJbmZvLmZpbHRlcldpZHRoO1xuICAgICAgICB2YXIgc3RyaWRlSGVpZ2h0ID0gY29udkluZm8uc3RyaWRlSGVpZ2h0O1xuICAgICAgICB2YXIgc3RyaWRlV2lkdGggPSBjb252SW5mby5zdHJpZGVXaWR0aDtcbiAgICAgICAgdmFyIHBhZFRvcCA9IGZpbHRlckhlaWdodCAtIDEgLSBjb252SW5mby5wYWRJbmZvLnRvcDtcbiAgICAgICAgdmFyIHBhZExlZnQgPSBmaWx0ZXJXaWR0aCAtIDEgLSBjb252SW5mby5wYWRJbmZvLmxlZnQ7XG4gICAgICAgIHZhciBsYXN0SW5kZXggPSBmaWx0ZXJIZWlnaHQgKiBmaWx0ZXJXaWR0aCAtIDE7XG4gICAgICAgIHRoaXMudXNlckNvZGUgPSBcIlxcbiAgICAgIGNvbnN0IGl2ZWMyIHBhZHMgPSBpdmVjMihcIiArIHBhZFRvcCArIFwiLCBcIiArIHBhZExlZnQgKyBcIik7XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzMgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpbnQgZCA9IGNvb3Jkcy56O1xcblxcbiAgICAgICAgaXZlYzIgZHlSQ0Nvcm5lciA9IGNvb3Jkcy54eSAtIHBhZHM7XFxuICAgICAgICBpbnQgZHlSQ29ybmVyID0gZHlSQ0Nvcm5lci54O1xcbiAgICAgICAgaW50IGR5Q0Nvcm5lciA9IGR5UkNDb3JuZXIueTtcXG5cXG4gICAgICAgIC8vIENvbnZvbHZlIGR5KD8sID8sIGQpIHdpdGggcG9zIG1hc2soOiwgOiwgZCkgdG8gZ2V0IGR4KHhSLCB4QywgZCkuXFxuICAgICAgICAvLyA/ID0gdG8gYmUgZGV0ZXJtaW5lZC4gOiA9IGFjcm9zcyBhbGwgdmFsdWVzIGluIHRoYXQgYXhpcy5cXG4gICAgICAgIGZsb2F0IGRvdFByb2QgPSAwLjA7XFxuICAgICAgICBmb3IgKGludCB3UiA9IDA7IHdSIDwgXCIgKyBmaWx0ZXJIZWlnaHQgKyBcIjsgd1IrKykge1xcbiAgICAgICAgICBmbG9hdCBkeVIgPSBmbG9hdChkeVJDb3JuZXIgKyB3UikgLyBcIiArIHN0cmlkZUhlaWdodCArIFwiLjA7XFxuXFxuICAgICAgICAgIGlmIChkeVIgPCAwLjAgfHwgZHlSID49IFwiICsgZHlSb3dzICsgXCIuMCB8fCBmcmFjdChkeVIpID4gMC4wKSB7XFxuICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgaW50IGlkeVIgPSBpbnQoZHlSKTtcXG5cXG4gICAgICAgICAgZm9yIChpbnQgd0MgPSAwOyB3QyA8IFwiICsgZmlsdGVyV2lkdGggKyBcIjsgd0MrKykge1xcbiAgICAgICAgICAgIGZsb2F0IGR5QyA9IGZsb2F0KGR5Q0Nvcm5lciArIHdDKSAvIFwiICsgc3RyaWRlV2lkdGggKyBcIi4wO1xcblxcbiAgICAgICAgICAgIGlmIChkeUMgPCAwLjAgfHwgZHlDID49IFwiICsgZHlDb2xzICsgXCIuMCB8fCBmcmFjdChkeUMpID4gMC4wKSB7XFxuICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgaW50IGlkeUMgPSBpbnQoZHlDKTtcXG5cXG4gICAgICAgICAgICBmbG9hdCBkeVZhbHVlID0gZ2V0RHkoaWR5UiwgaWR5QywgZCk7XFxuICAgICAgICAgICAgaW50IG1heFBvc1ZhbHVlID0gXCIgKyBsYXN0SW5kZXggKyBcIiAtIGludChnZXRNYXhQb3MoaWR5UiwgaWR5QywgZCkpO1xcblxcbiAgICAgICAgICAgIC8vIEdldCB0aGUgY3VycmVudCB2YWx1ZSwgY2hlY2sgaXQgYWdhaW5zdCB0aGUgdmFsdWUgZnJvbSB0aGVcXG4gICAgICAgICAgICAvLyBwb3NpdGlvbiBtYXRyaXguXFxuICAgICAgICAgICAgaW50IGN1clBvc1ZhbHVlID0gd1IgKiBcIiArIGZpbHRlcldpZHRoICsgXCIgKyB3QztcXG4gICAgICAgICAgICBmbG9hdCBtYXNrID0gZmxvYXQobWF4UG9zVmFsdWUgPT0gY3VyUG9zVmFsdWUgPyAxLjAgOiAwLjApO1xcblxcbiAgICAgICAgICAgIGRvdFByb2QgKz0gZHlWYWx1ZSAqIG1hc2s7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIHNldE91dHB1dChkb3RQcm9kKTtcXG4gICAgICB9XFxuICAgIFwiO1xuICAgIH1cbiAgICByZXR1cm4gTWF4UG9vbDJEQmFja3Byb3BQcm9ncmFtO1xufSgpKTtcbmV4cG9ydHMuTWF4UG9vbDJEQmFja3Byb3BQcm9ncmFtID0gTWF4UG9vbDJEQmFja3Byb3BQcm9ncmFtO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWF4X3Bvb2xfYmFja3Byb3BfZ3B1LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIG1hdGhfMSA9IHJlcXVpcmUoXCIuLi9tYXRoXCIpO1xudmFyIE1hdE11bFByb2dyYW0gPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1hdE11bFByb2dyYW0oYVNoYXBlLCBiU2hhcGUsIGFPcmllbnQsIGJPcmllbnQpIHtcbiAgICAgICAgaWYgKGFPcmllbnQgPT09IHZvaWQgMCkgeyBhT3JpZW50ID0gbWF0aF8xLk1hdHJpeE9yaWVudGF0aW9uLlJFR1VMQVI7IH1cbiAgICAgICAgaWYgKGJPcmllbnQgPT09IHZvaWQgMCkgeyBiT3JpZW50ID0gbWF0aF8xLk1hdHJpeE9yaWVudGF0aW9uLlJFR1VMQVI7IH1cbiAgICAgICAgdGhpcy52YXJpYWJsZU5hbWVzID0gWydtYXRyaXhBJywgJ21hdHJpeEInXTtcbiAgICAgICAgdmFyIG91dGVyU2hhcGVBID0gKGFPcmllbnQgPT09IG1hdGhfMS5NYXRyaXhPcmllbnRhdGlvbi5SRUdVTEFSKSA/IGFTaGFwZVswXSA6IGFTaGFwZVsxXTtcbiAgICAgICAgdmFyIG91dGVyU2hhcGVCID0gKGJPcmllbnQgPT09IG1hdGhfMS5NYXRyaXhPcmllbnRhdGlvbi5SRUdVTEFSKSA/IGJTaGFwZVsxXSA6IGJTaGFwZVswXTtcbiAgICAgICAgdGhpcy5vdXRwdXRTaGFwZSA9IFtvdXRlclNoYXBlQSwgb3V0ZXJTaGFwZUJdO1xuICAgICAgICB2YXIgc2hhcmVkRGltID0gKGFPcmllbnQgPT09IG1hdGhfMS5NYXRyaXhPcmllbnRhdGlvbi5SRUdVTEFSID8gYVNoYXBlWzFdIDogYVNoYXBlWzBdKTtcbiAgICAgICAgdmFyIGFTbmlwcGV0RnJvbU9mZnNldCA9IGZ1bmN0aW9uICh2ZWM0T2Zmc2V0LCBpbmRleFZhcikge1xuICAgICAgICAgICAgcmV0dXJuIChhT3JpZW50ID09PSBtYXRoXzEuTWF0cml4T3JpZW50YXRpb24uUkVHVUxBUikgP1xuICAgICAgICAgICAgICAgIFwiYVJvdywgXCIgKyBpbmRleFZhciArIFwiICsgXCIgKyB2ZWM0T2Zmc2V0IDpcbiAgICAgICAgICAgICAgICBpbmRleFZhciArIFwiICsgXCIgKyB2ZWM0T2Zmc2V0ICsgXCIsIGFSb3dcIjtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGJTbmlwcGV0RnJvbU9mZnNldCA9IGZ1bmN0aW9uICh2ZWM0T2Zmc2V0LCBpbmRleFZhcikge1xuICAgICAgICAgICAgcmV0dXJuIChiT3JpZW50ID09PSBtYXRoXzEuTWF0cml4T3JpZW50YXRpb24uUkVHVUxBUikgP1xuICAgICAgICAgICAgICAgIGluZGV4VmFyICsgXCIgKyBcIiArIHZlYzRPZmZzZXQgKyBcIiwgYkNvbFwiIDpcbiAgICAgICAgICAgICAgICBcImJDb2wsIFwiICsgaW5kZXhWYXIgKyBcIiArIFwiICsgdmVjNE9mZnNldDtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHNoYXJlZERpbU5lYXJlc3RWZWM0ID0gTWF0aC5mbG9vcihzaGFyZWREaW0gLyA0KSAqIDQ7XG4gICAgICAgIHZhciBzaGFyZWREaW1WZWM0UmVtYWluZGVyID0gc2hhcmVkRGltICUgNDtcbiAgICAgICAgdGhpcy51c2VyQ29kZSA9IFwiIGZsb2F0IGRvdEFSb3dCQ29sKGludCBhUm93LCBpbnQgYkNvbCkge1xcbiAgICAgIGZsb2F0IHJlc3VsdCA9IDAuMDtcXG4gICAgICBmb3IgKGludCBpID0gMDsgaSA8IFwiICsgc2hhcmVkRGltTmVhcmVzdFZlYzQgKyBcIjsgaSArPSA0KSB7XFxuICAgICAgICB2ZWM0IGEgPSB2ZWM0KFxcbiAgICAgICAgICBnZXRNYXRyaXhBKFwiICsgYVNuaXBwZXRGcm9tT2Zmc2V0KDAsICdpJykgKyBcIiksXFxuICAgICAgICAgIGdldE1hdHJpeEEoXCIgKyBhU25pcHBldEZyb21PZmZzZXQoMSwgJ2knKSArIFwiKSxcXG4gICAgICAgICAgZ2V0TWF0cml4QShcIiArIGFTbmlwcGV0RnJvbU9mZnNldCgyLCAnaScpICsgXCIpLFxcbiAgICAgICAgICBnZXRNYXRyaXhBKFwiICsgYVNuaXBwZXRGcm9tT2Zmc2V0KDMsICdpJykgKyBcIilcXG4gICAgICAgICk7XFxuICAgICAgICB2ZWM0IGIgPSB2ZWM0KFxcbiAgICAgICAgICBnZXRNYXRyaXhCKFwiICsgYlNuaXBwZXRGcm9tT2Zmc2V0KDAsICdpJykgKyBcIiksXFxuICAgICAgICAgIGdldE1hdHJpeEIoXCIgKyBiU25pcHBldEZyb21PZmZzZXQoMSwgJ2knKSArIFwiKSxcXG4gICAgICAgICAgZ2V0TWF0cml4QihcIiArIGJTbmlwcGV0RnJvbU9mZnNldCgyLCAnaScpICsgXCIpLFxcbiAgICAgICAgICBnZXRNYXRyaXhCKFwiICsgYlNuaXBwZXRGcm9tT2Zmc2V0KDMsICdpJykgKyBcIilcXG4gICAgICAgICk7XFxuXFxuICAgICAgICByZXN1bHQgKz0gZG90KGEsIGIpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoXCIgKyAoc2hhcmVkRGltVmVjNFJlbWFpbmRlciA9PT0gMSkgKyBcIikge1xcbiAgICAgICAgcmVzdWx0ICs9IGdldE1hdHJpeEEoXCIgKyBhU25pcHBldEZyb21PZmZzZXQoMCwgc2hhcmVkRGltTmVhcmVzdFZlYzQpICsgXCIpICpcXG4gICAgICAgICAgZ2V0TWF0cml4QihcIiArIGJTbmlwcGV0RnJvbU9mZnNldCgwLCBzaGFyZWREaW1OZWFyZXN0VmVjNCkgKyBcIik7XFxuICAgICAgfSBlbHNlIGlmIChcIiArIChzaGFyZWREaW1WZWM0UmVtYWluZGVyID09PSAyKSArIFwiKSB7XFxuICAgICAgICB2ZWMyIGEgPSB2ZWMyKFxcbiAgICAgICAgICBnZXRNYXRyaXhBKFwiICsgYVNuaXBwZXRGcm9tT2Zmc2V0KDAsIHNoYXJlZERpbU5lYXJlc3RWZWM0KSArIFwiKSxcXG4gICAgICAgICAgZ2V0TWF0cml4QShcIiArIGFTbmlwcGV0RnJvbU9mZnNldCgxLCBzaGFyZWREaW1OZWFyZXN0VmVjNCkgKyBcIilcXG4gICAgICAgICk7XFxuICAgICAgICB2ZWMyIGIgPSB2ZWMyKFxcbiAgICAgICAgICBnZXRNYXRyaXhCKFwiICsgYlNuaXBwZXRGcm9tT2Zmc2V0KDAsIHNoYXJlZERpbU5lYXJlc3RWZWM0KSArIFwiKSxcXG4gICAgICAgICAgZ2V0TWF0cml4QihcIiArIGJTbmlwcGV0RnJvbU9mZnNldCgxLCBzaGFyZWREaW1OZWFyZXN0VmVjNCkgKyBcIilcXG4gICAgICAgICk7XFxuICAgICAgICByZXN1bHQgKz0gZG90KGEsIGIpO1xcbiAgICAgIH0gZWxzZSBpZiAoXCIgKyAoc2hhcmVkRGltVmVjNFJlbWFpbmRlciA9PT0gMykgKyBcIikge1xcbiAgICAgICAgdmVjMyBhID0gdmVjMyhcXG4gICAgICAgICAgZ2V0TWF0cml4QShcIiArIGFTbmlwcGV0RnJvbU9mZnNldCgwLCBzaGFyZWREaW1OZWFyZXN0VmVjNCkgKyBcIiksXFxuICAgICAgICAgIGdldE1hdHJpeEEoXCIgKyBhU25pcHBldEZyb21PZmZzZXQoMSwgc2hhcmVkRGltTmVhcmVzdFZlYzQpICsgXCIpLFxcbiAgICAgICAgICBnZXRNYXRyaXhBKFwiICsgYVNuaXBwZXRGcm9tT2Zmc2V0KDIsIHNoYXJlZERpbU5lYXJlc3RWZWM0KSArIFwiKVxcbiAgICAgICAgKTtcXG4gICAgICAgIHZlYzMgYiA9IHZlYzMoXFxuICAgICAgICAgIGdldE1hdHJpeEIoXCIgKyBiU25pcHBldEZyb21PZmZzZXQoMCwgc2hhcmVkRGltTmVhcmVzdFZlYzQpICsgXCIpLFxcbiAgICAgICAgICBnZXRNYXRyaXhCKFwiICsgYlNuaXBwZXRGcm9tT2Zmc2V0KDEsIHNoYXJlZERpbU5lYXJlc3RWZWM0KSArIFwiKSxcXG4gICAgICAgICAgZ2V0TWF0cml4QihcIiArIGJTbmlwcGV0RnJvbU9mZnNldCgyLCBzaGFyZWREaW1OZWFyZXN0VmVjNCkgKyBcIilcXG4gICAgICAgICk7XFxuICAgICAgICByZXN1bHQgKz0gZG90KGEsIGIpO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gcmVzdWx0O1xcbiAgICB9XFxuXFxuICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICBpdmVjMiByZXNSQyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgIHNldE91dHB1dChkb3RBUm93QkNvbChyZXNSQy54LCByZXNSQy55KSk7XFxuICAgIH1cXG4gICAgXCI7XG4gICAgfVxuICAgIHJldHVybiBNYXRNdWxQcm9ncmFtO1xufSgpKTtcbmV4cG9ydHMuTWF0TXVsUHJvZ3JhbSA9IE1hdE11bFByb2dyYW07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tdWxtYXRfZ3B1LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIE11bHRpbm9taWFsUHJvZ3JhbSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTXVsdGlub21pYWxQcm9ncmFtKGJhdGNoU2l6ZSwgbnVtT3V0Y29tZXMsIG51bVNhbXBsZXMpIHtcbiAgICAgICAgdGhpcy52YXJpYWJsZU5hbWVzID0gWydwcm9icyddO1xuICAgICAgICB0aGlzLm91dHB1dFNoYXBlID0gW2JhdGNoU2l6ZSwgbnVtU2FtcGxlc107XG4gICAgICAgIHRoaXMudXNlckNvZGUgPSBcIlxcbiAgICAgIHVuaWZvcm0gZmxvYXQgc2VlZDtcXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjMiBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIGludCBiYXRjaCA9IGNvb3Jkc1swXTtcXG5cXG4gICAgICAgIGZsb2F0IHIgPSByYW5kb20oc2VlZCk7XFxuICAgICAgICBmbG9hdCBjZGYgPSAwLjA7XFxuXFxuICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IFwiICsgKG51bU91dGNvbWVzIC0gMSkgKyBcIjsgaSsrKSB7XFxuICAgICAgICAgIGNkZiArPSBnZXRQcm9icyhiYXRjaCwgaSk7XFxuXFxuICAgICAgICAgIGlmIChyIDwgY2RmKSB7XFxuICAgICAgICAgICAgc2V0T3V0cHV0KGZsb2F0KGkpKTtcXG4gICAgICAgICAgICByZXR1cm47XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG5cXG4gICAgICAgIC8vIElmIG5vIG90aGVyIGV2ZW50IGhhcHBlbmVkLCBsYXN0IGV2ZW50IGhhcHBlbmVkLlxcbiAgICAgICAgc2V0T3V0cHV0KGZsb2F0KFwiICsgKG51bU91dGNvbWVzIC0gMSkgKyBcIikpO1xcbiAgICAgIH1cXG4gICAgXCI7XG4gICAgfVxuICAgIE11bHRpbm9taWFsUHJvZ3JhbS5wcm90b3R5cGUuZ2V0Q3VzdG9tU2V0dXBGdW5jID0gZnVuY3Rpb24gKHNlZWQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChncGdwdSwgd2ViR0xQcm9ncmFtKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMuc2VlZExvYyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuc2VlZExvYyA9IGdwZ3B1LmdldFVuaWZvcm1Mb2NhdGlvbih3ZWJHTFByb2dyYW0sICdzZWVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBncGdwdS5nbC51bmlmb3JtMWYoX3RoaXMuc2VlZExvYywgc2VlZCk7XG4gICAgICAgIH07XG4gICAgfTtcbiAgICByZXR1cm4gTXVsdGlub21pYWxQcm9ncmFtO1xufSgpKTtcbmV4cG9ydHMuTXVsdGlub21pYWxQcm9ncmFtID0gTXVsdGlub21pYWxQcm9ncmFtO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bXVsdGlub21pYWxfZ3B1LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIE9uZUhvdFByb2dyYW0gPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE9uZUhvdFByb2dyYW0obnVtSW5kaWNlcywgZGVwdGgsIG9uVmFsdWUsIG9mZlZhbHVlKSB7XG4gICAgICAgIHRoaXMudmFyaWFibGVOYW1lcyA9IFsnaW5kaWNlcyddO1xuICAgICAgICB0aGlzLm91dHB1dFNoYXBlID0gW251bUluZGljZXMsIGRlcHRoXTtcbiAgICAgICAgdGhpcy51c2VyQ29kZSA9IFwiXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzIgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpbnQgaW5kZXggPSByb3VuZChnZXRJbmRpY2VzKGNvb3Jkcy54KSk7XFxuICAgICAgICBzZXRPdXRwdXQobWl4KGZsb2F0KFwiICsgb2ZmVmFsdWUgKyBcIiksIGZsb2F0KFwiICsgb25WYWx1ZSArIFwiKSxcXG4gICAgICAgICAgICAgICAgICAgICAgZmxvYXQoaW5kZXggPT0gY29vcmRzLnkpKSk7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgT25lSG90UHJvZ3JhbS5wcm90b3R5cGUuZ2V0Q3VzdG9tU2V0dXBGdW5jID0gZnVuY3Rpb24gKHNlZWQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChncGdwdSwgd2ViR0xQcm9ncmFtKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMuc2VlZExvYyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuc2VlZExvYyA9IGdwZ3B1LmdldFVuaWZvcm1Mb2NhdGlvbih3ZWJHTFByb2dyYW0sICdzZWVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBncGdwdS5nbC51bmlmb3JtMWYoX3RoaXMuc2VlZExvYywgc2VlZCk7XG4gICAgICAgIH07XG4gICAgfTtcbiAgICByZXR1cm4gT25lSG90UHJvZ3JhbTtcbn0oKSk7XG5leHBvcnRzLk9uZUhvdFByb2dyYW0gPSBPbmVIb3RQcm9ncmFtO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b25laG90X2dwdS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBQb29sMkRQcm9ncmFtID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQb29sMkRQcm9ncmFtKGNvbnZJbmZvLCBwb29sVHlwZSwgY29tcHV0ZVBvc2l0aW9ucykge1xuICAgICAgICB0aGlzLnZhcmlhYmxlTmFtZXMgPSBbJ3gnXTtcbiAgICAgICAgaWYgKHBvb2xUeXBlID09PSAnYXZnJyAmJiBjb21wdXRlUG9zaXRpb25zKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBjb21wdXRlIHBvc2l0aW9ucyBmb3IgYXZlcmFnZSBwb29sLicpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBmaWx0ZXJIZWlnaHQgPSBjb252SW5mby5maWx0ZXJIZWlnaHQ7XG4gICAgICAgIHZhciBmaWx0ZXJXaWR0aCA9IGNvbnZJbmZvLmZpbHRlcldpZHRoO1xuICAgICAgICB2YXIgc3RyaWRlSGVpZ2h0ID0gY29udkluZm8uc3RyaWRlSGVpZ2h0O1xuICAgICAgICB2YXIgc3RyaWRlV2lkdGggPSBjb252SW5mby5zdHJpZGVXaWR0aDtcbiAgICAgICAgdmFyIHhOdW1Sb3dzID0gY29udkluZm8uaW5TaGFwZVswXTtcbiAgICAgICAgdmFyIHhOdW1Db2xzID0gY29udkluZm8uaW5TaGFwZVsxXTtcbiAgICAgICAgdmFyIHBhZFRvcCA9IGNvbnZJbmZvLnBhZEluZm8udG9wO1xuICAgICAgICB2YXIgcGFkTGVmdCA9IGNvbnZJbmZvLnBhZEluZm8ubGVmdDtcbiAgICAgICAgdGhpcy5vdXRwdXRTaGFwZSA9IGNvbnZJbmZvLm91dFNoYXBlO1xuICAgICAgICB2YXIgaXNBdmdQb29sID0gcG9vbFR5cGUgPT09ICdhdmcnO1xuICAgICAgICB2YXIgaW5pdGlhbGl6YXRpb25WYWx1ZSA9ICcwLjAnO1xuICAgICAgICBpZiAoIWlzQXZnUG9vbCkge1xuICAgICAgICAgICAgaWYgKHBvb2xUeXBlID09PSAnbWluJykge1xuICAgICAgICAgICAgICAgIGluaXRpYWxpemF0aW9uVmFsdWUgPSAnMS4wIC8gMC4wJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGluaXRpYWxpemF0aW9uVmFsdWUgPSAnLTEuMCAvIDAuMCc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbXB1dGVQb3NpdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBjb21wYXJlT3BfMSA9IHBvb2xUeXBlID09PSAnbWluJyA/ICc8PScgOiAnPj0nO1xuICAgICAgICAgICAgdGhpcy51c2VyQ29kZSA9IFwiXFxuICAgICAgICBjb25zdCBpdmVjMiBzdHJpZGVzID0gaXZlYzIoXCIgKyBzdHJpZGVIZWlnaHQgKyBcIiwgXCIgKyBzdHJpZGVXaWR0aCArIFwiKTtcXG4gICAgICAgIGNvbnN0IGl2ZWMyIHBhZHMgPSBpdmVjMihcIiArIHBhZFRvcCArIFwiLCBcIiArIHBhZExlZnQgKyBcIik7XFxuXFxuICAgICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICAgIGl2ZWMzIGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgICBpbnQgZCA9IGNvb3Jkcy56O1xcblxcbiAgICAgICAgICBpdmVjMiB4UkNDb3JuZXIgPSBjb29yZHMueHkgKiBzdHJpZGVzIC0gcGFkcztcXG4gICAgICAgICAgaW50IHhSQ29ybmVyID0geFJDQ29ybmVyLng7XFxuICAgICAgICAgIGludCB4Q0Nvcm5lciA9IHhSQ0Nvcm5lci55O1xcblxcbiAgICAgICAgICAvLyBtYXgvbWluIHgoPywgPywgZCkgdG8gZ2V0IHkoeVIsIHlDLCBkKS5cXG4gICAgICAgICAgLy8gPyA9IHRvIGJlIGRldGVybWluZWRcXG4gICAgICAgICAgZmxvYXQgbWluTWF4VmFsdWUgPSAwLjA7XFxuICAgICAgICAgIGZsb2F0IG1pbk1heFZhbHVlRm91bmQgPSAwLjA7XFxuICAgICAgICAgIGludCBtaW5NYXhQb3NpdGlvbiA9IDA7XFxuICAgICAgICAgIGZsb2F0IGF2Z1ZhbHVlID0gMC4wO1xcblxcbiAgICAgICAgICBmb3IgKGludCB3UiA9IDA7IHdSIDwgXCIgKyBmaWx0ZXJIZWlnaHQgKyBcIjsgd1IrKykge1xcbiAgICAgICAgICAgIGludCB4UiA9IHhSQ29ybmVyICsgd1I7XFxuXFxuICAgICAgICAgICAgaWYgKHhSIDwgMCB8fCB4UiA+PSBcIiArIHhOdW1Sb3dzICsgXCIpIHtcXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBmb3IgKGludCB3QyA9IDA7IHdDIDwgXCIgKyBmaWx0ZXJXaWR0aCArIFwiOyB3QysrKSB7XFxuICAgICAgICAgICAgICBpbnQgeEMgPSB4Q0Nvcm5lciArIHdDO1xcblxcbiAgICAgICAgICAgICAgaWYgKHhDIDwgMCB8fCB4QyA+PSBcIiArIHhOdW1Db2xzICsgXCIpIHtcXG4gICAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICBmbG9hdCB2YWx1ZSA9IGdldFgoeFIsIHhDLCBkKTtcXG5cXG4gICAgICAgICAgICAgIGlmIChpc05hTih2YWx1ZSkpIHtcXG4gICAgICAgICAgICAgICAgc2V0T3V0cHV0KHZhbHVlKTtcXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgLy8gSWYgYSBtaW4gLyBtYXggdmFsdWUgaGFzIGFscmVhZHkgYmVlbiBmb3VuZCwgdXNlIGl0LiBJZiBub3QsXFxuICAgICAgICAgICAgICAvLyB1c2UgdGhlIGN1cnJlbnQgdmFsdWUuXFxuICAgICAgICAgICAgICBmbG9hdCBjdXJyTWluTWF4VmFsdWUgPSBtaXgoXFxuICAgICAgICAgICAgICAgICAgdmFsdWUsIG1pbk1heFZhbHVlLCBtaW5NYXhWYWx1ZUZvdW5kKTtcXG4gICAgICAgICAgICAgIGlmICh2YWx1ZSBcIiArIGNvbXBhcmVPcF8xICsgXCIgY3Vyck1pbk1heFZhbHVlKSB7XFxuICAgICAgICAgICAgICAgIG1pbk1heFZhbHVlID0gdmFsdWU7XFxuICAgICAgICAgICAgICAgIG1pbk1heFZhbHVlRm91bmQgPSAxLjA7XFxuICAgICAgICAgICAgICAgIG1pbk1heFBvc2l0aW9uID0gd1IgKiBcIiArIGZpbHRlcldpZHRoICsgXCIgKyB3QztcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgc2V0T3V0cHV0KGZsb2F0KG1pbk1heFBvc2l0aW9uKSk7XFxuICAgICAgICB9XFxuICAgICAgXCI7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNvbXBhcmVPcCA9IHBvb2xUeXBlID09PSAnbWluJyA/ICdtaW4nIDogJ21heCc7XG4gICAgICAgIHZhciByZXR1cm5WYWx1ZSA9IHBvb2xUeXBlICsgXCIoXCIgKyBwb29sVHlwZSArIFwiKFwiICsgcG9vbFR5cGUgKyBcIihcIiArXG4gICAgICAgICAgICAnbWluTWF4VmFsdWVbMF0sIG1pbk1heFZhbHVlWzFdKSwgbWluTWF4VmFsdWVbMl0pLCBtaW5NYXhWYWx1ZVszXSknO1xuICAgICAgICBpZiAocG9vbFR5cGUgPT09ICdhdmcnKSB7XG4gICAgICAgICAgICByZXR1cm5WYWx1ZSA9IFwiYXZnVmFsdWUgLyBcIiArIGZpbHRlckhlaWdodCAqIGZpbHRlcldpZHRoICsgXCIuMFwiO1xuICAgICAgICB9XG4gICAgICAgIHZhciBmaWx0ZXJXaWR0aE5lYXJlc3RWZWM0ID0gTWF0aC5mbG9vcihmaWx0ZXJXaWR0aCAvIDQpICogNDtcbiAgICAgICAgdmFyIGZpbHRlcldpZHRoVmVjNFJlbWFpbmRlciA9IGZpbHRlcldpZHRoICUgNDtcbiAgICAgICAgdmFyIHVwZGF0ZVNuaXBwZXQgPSBcIlxcbiAgICAgIGlmIChoYXNOYU4odmFsdWVzKSkge1xcbiAgICAgICAgc2V0T3V0cHV0KGdldE5hTih2YWx1ZXMpKTtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuICAgICAgaWYgKFwiICsgaXNBdmdQb29sICsgXCIpIHtcXG4gICAgICAgIGF2Z1ZhbHVlICs9IGRvdCh2YWx1ZXMsIG9uZXMpO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBtaW5NYXhWYWx1ZSA9IFwiICsgY29tcGFyZU9wICsgXCIodmFsdWVzLCBtaW5NYXhWYWx1ZSk7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICAgICAgdGhpcy51c2VyQ29kZSA9IFwiXFxuICAgICAgY29uc3QgaXZlYzIgc3RyaWRlcyA9IGl2ZWMyKFwiICsgc3RyaWRlSGVpZ2h0ICsgXCIsIFwiICsgc3RyaWRlV2lkdGggKyBcIik7XFxuICAgICAgY29uc3QgaXZlYzIgcGFkcyA9IGl2ZWMyKFwiICsgcGFkVG9wICsgXCIsIFwiICsgcGFkTGVmdCArIFwiKTtcXG4gICAgICBjb25zdCBmbG9hdCBpbml0aWFsaXphdGlvblZhbHVlID0gXCIgKyBpbml0aWFsaXphdGlvblZhbHVlICsgXCI7XFxuICAgICAgY29uc3QgdmVjNCBvbmVzID0gdmVjNCgxLjAsIDEuMCwgMS4wLCAxLjApO1xcblxcbiAgICAgIGZsb2F0IGdldFZhbHVlKGludCB4UiwgaW50IHhDLCBpbnQgZCkge1xcbiAgICAgICAgaWYgKHhDIDwgMCB8fCB4QyA+PSBcIiArIHhOdW1Db2xzICsgXCIpIHtcXG4gICAgICAgICAgcmV0dXJuIGluaXRpYWxpemF0aW9uVmFsdWU7XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gZ2V0WCh4UiwgeEMsIGQpO1xcbiAgICAgIH1cXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjMyBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIGludCBkID0gY29vcmRzLno7XFxuXFxuICAgICAgICBpdmVjMiB4UkNDb3JuZXIgPSBjb29yZHMueHkgKiBzdHJpZGVzIC0gcGFkcztcXG4gICAgICAgIGludCB4UkNvcm5lciA9IHhSQ0Nvcm5lci54O1xcbiAgICAgICAgaW50IHhDQ29ybmVyID0geFJDQ29ybmVyLnk7XFxuXFxuICAgICAgICAvLyBtYXgvbWluIHgoPywgPywgZCkgdG8gZ2V0IHkoeVIsIHlDLCBkKS5cXG4gICAgICAgIC8vID8gPSB0byBiZSBkZXRlcm1pbmVkXFxuICAgICAgICB2ZWM0IG1pbk1heFZhbHVlID0gdmVjNChcIiArIGluaXRpYWxpemF0aW9uVmFsdWUgKyBcIik7XFxuICAgICAgICBmbG9hdCBhdmdWYWx1ZSA9IDAuMDtcXG5cXG4gICAgICAgIGZvciAoaW50IHdSID0gMDsgd1IgPCBcIiArIGZpbHRlckhlaWdodCArIFwiOyB3UisrKSB7XFxuICAgICAgICAgIGludCB4UiA9IHhSQ29ybmVyICsgd1I7XFxuXFxuICAgICAgICAgIGlmICh4UiA8IDAgfHwgeFIgPj0gXCIgKyB4TnVtUm93cyArIFwiKSB7XFxuICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgZm9yIChpbnQgd0MgPSAwOyB3QyA8IFwiICsgZmlsdGVyV2lkdGhOZWFyZXN0VmVjNCArIFwiOyB3QyArPSA0KSB7XFxuICAgICAgICAgICAgaW50IHhDID0geENDb3JuZXIgKyB3QztcXG5cXG4gICAgICAgICAgICB2ZWM0IHZhbHVlcyA9IHZlYzQoXFxuICAgICAgICAgICAgICBnZXRWYWx1ZSh4UiwgeEMsIGQpLFxcbiAgICAgICAgICAgICAgZ2V0VmFsdWUoeFIsIHhDICsgMSwgZCksXFxuICAgICAgICAgICAgICBnZXRWYWx1ZSh4UiwgeEMgKyAyLCBkKSxcXG4gICAgICAgICAgICAgIGdldFZhbHVlKHhSLCB4QyArIDMsIGQpXFxuICAgICAgICAgICAgKTtcXG5cXG4gICAgICAgICAgICBcIiArIHVwZGF0ZVNuaXBwZXQgKyBcIlxcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGludCB4QyA9IHhDQ29ybmVyICsgXCIgKyBmaWx0ZXJXaWR0aE5lYXJlc3RWZWM0ICsgXCI7XFxuICAgICAgICAgIGlmIChcIiArIChmaWx0ZXJXaWR0aFZlYzRSZW1haW5kZXIgPT09IDEpICsgXCIpIHtcXG4gICAgICAgICAgICB2ZWM0IHZhbHVlcyA9IHZlYzQoXFxuICAgICAgICAgICAgICBnZXRWYWx1ZSh4UiwgeEMsIGQpLFxcbiAgICAgICAgICAgICAgaW5pdGlhbGl6YXRpb25WYWx1ZSxcXG4gICAgICAgICAgICAgIGluaXRpYWxpemF0aW9uVmFsdWUsXFxuICAgICAgICAgICAgICBpbml0aWFsaXphdGlvblZhbHVlXFxuICAgICAgICAgICAgKTtcXG4gICAgICAgICAgICBcIiArIHVwZGF0ZVNuaXBwZXQgKyBcIlxcbiAgICAgICAgICB9IGVsc2UgaWYgKFwiICsgKGZpbHRlcldpZHRoVmVjNFJlbWFpbmRlciA9PT0gMikgKyBcIikge1xcbiAgICAgICAgICAgIHZlYzQgdmFsdWVzID0gdmVjNChcXG4gICAgICAgICAgICAgIGdldFZhbHVlKHhSLCB4QywgZCksXFxuICAgICAgICAgICAgICBnZXRWYWx1ZSh4UiwgeEMgKyAxLCBkKSxcXG4gICAgICAgICAgICAgIGluaXRpYWxpemF0aW9uVmFsdWUsXFxuICAgICAgICAgICAgICBpbml0aWFsaXphdGlvblZhbHVlXFxuICAgICAgICAgICAgKTtcXG5cXG4gICAgICAgICAgICBcIiArIHVwZGF0ZVNuaXBwZXQgKyBcIlxcbiAgICAgICAgICB9IGVsc2UgaWYgKFwiICsgKGZpbHRlcldpZHRoVmVjNFJlbWFpbmRlciA9PT0gMykgKyBcIikge1xcbiAgICAgICAgICAgIHZlYzQgdmFsdWVzID0gdmVjNChcXG4gICAgICAgICAgICAgIGdldFZhbHVlKHhSLCB4QywgZCksXFxuICAgICAgICAgICAgICBnZXRWYWx1ZSh4UiwgeEMgKyAxLCBkKSxcXG4gICAgICAgICAgICAgIGdldFZhbHVlKHhSLCB4QyArIDIsIGQpLFxcbiAgICAgICAgICAgICAgaW5pdGlhbGl6YXRpb25WYWx1ZVxcbiAgICAgICAgICAgICk7XFxuXFxuICAgICAgICAgICAgXCIgKyB1cGRhdGVTbmlwcGV0ICsgXCJcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgc2V0T3V0cHV0KFwiICsgcmV0dXJuVmFsdWUgKyBcIik7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgcmV0dXJuIFBvb2wyRFByb2dyYW07XG59KCkpO1xuZXhwb3J0cy5Qb29sMkRQcm9ncmFtID0gUG9vbDJEUHJvZ3JhbTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBvb2xfZ3B1LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIFJlZHVjZVByb2dyYW0gPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJlZHVjZVByb2dyYW0ocmVkdWNlSW5mbywgcmVkdWNlVHlwZSkge1xuICAgICAgICB0aGlzLnZhcmlhYmxlTmFtZXMgPSBbJ3gnXTtcbiAgICAgICAgdmFyIHdpbmRvd1NpemUgPSByZWR1Y2VJbmZvLndpbmRvd1NpemU7XG4gICAgICAgIHZhciBiYXRjaFNpemUgPSByZWR1Y2VJbmZvLmJhdGNoU2l6ZTtcbiAgICAgICAgdmFyIGluU2l6ZSA9IHJlZHVjZUluZm8uaW5TaXplO1xuICAgICAgICB2YXIgb3V0U2l6ZSA9IE1hdGguY2VpbChpblNpemUgLyB3aW5kb3dTaXplKTtcbiAgICAgICAgdGhpcy5vdXRwdXRTaGFwZSA9IFtiYXRjaFNpemUsIG91dFNpemVdO1xuICAgICAgICB2YXIgaXNSZWR1Y2VTdW0gPSByZWR1Y2VUeXBlID09PSAnc3VtJztcbiAgICAgICAgdmFyIGluaXRpYWxpemF0aW9uVmFsdWUgPSAnMC4wJztcbiAgICAgICAgaWYgKCFpc1JlZHVjZVN1bSkge1xuICAgICAgICAgICAgaWYgKHJlZHVjZVR5cGUgPT09ICdtaW4nKSB7XG4gICAgICAgICAgICAgICAgaW5pdGlhbGl6YXRpb25WYWx1ZSA9ICcxLjAgLyAwLjAnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaW5pdGlhbGl6YXRpb25WYWx1ZSA9ICctMS4wIC8gMC4wJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgY29tcGFyZU9wID0gcmVkdWNlVHlwZSA9PT0gJ21pbicgPyAnbWluJyA6ICdtYXgnO1xuICAgICAgICB2YXIgcmV0dXJuVmFsdWUgPSByZWR1Y2VUeXBlICsgXCIoXCIgKyByZWR1Y2VUeXBlICsgXCIoXCIgKyByZWR1Y2VUeXBlICsgXCIoXCIgK1xuICAgICAgICAgICAgJ21pbk1heFZhbHVlWzBdLCBtaW5NYXhWYWx1ZVsxXSksIG1pbk1heFZhbHVlWzJdKSwgbWluTWF4VmFsdWVbM10pJztcbiAgICAgICAgaWYgKHJlZHVjZVR5cGUgPT09ICdzdW0nKSB7XG4gICAgICAgICAgICByZXR1cm5WYWx1ZSA9IFwic3VtVmFsdWVcIjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgd2luZG93U2l6ZU5lYXJlc3RWZWM0ID0gTWF0aC5mbG9vcih3aW5kb3dTaXplIC8gNCkgKiA0O1xuICAgICAgICB2YXIgd2luZG93U2l6ZVZlYzRSZW1haW5kZXIgPSB3aW5kb3dTaXplICUgNDtcbiAgICAgICAgdmFyIHVwZGF0ZVNuaXBwZXQgPSBcIlxcbiAgICAgIGlmIChcIiArIGlzUmVkdWNlU3VtICsgXCIpIHtcXG4gICAgICAgIHN1bVZhbHVlICs9IGRvdCh2YWx1ZXMsIG9uZXMpO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBpZiAoaGFzTmFOKHZhbHVlcykpIHtcXG4gICAgICAgICAgc2V0T3V0cHV0KGdldE5hTih2YWx1ZXMpKTtcXG4gICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgfVxcbiAgICAgICAgbWluTWF4VmFsdWUgPSBcIiArIGNvbXBhcmVPcCArIFwiKHZhbHVlcywgbWluTWF4VmFsdWUpO1xcbiAgICAgIH1cXG4gICAgXCI7XG4gICAgICAgIHZhciBjaGVja091dE9mQm91bmRzID0gJyc7XG4gICAgICAgIGlmIChpblNpemUgJSB3aW5kb3dTaXplID4gMCkge1xuICAgICAgICAgICAgY2hlY2tPdXRPZkJvdW5kcyA9IFwiXFxuICAgICAgICBpZiAoaW5JZHggPCAwIHx8IGluSWR4ID49IFwiICsgaW5TaXplICsgXCIpIHtcXG4gICAgICAgICAgcmV0dXJuIGluaXRpYWxpemF0aW9uVmFsdWU7XFxuICAgICAgICB9XFxuICAgICAgXCI7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51c2VyQ29kZSA9IFwiXFxuICAgICAgY29uc3QgZmxvYXQgaW5pdGlhbGl6YXRpb25WYWx1ZSA9IFwiICsgaW5pdGlhbGl6YXRpb25WYWx1ZSArIFwiO1xcbiAgICAgIGNvbnN0IHZlYzQgb25lcyA9IHZlYzQoMS4wLCAxLjAsIDEuMCwgMS4wKTtcXG5cXG4gICAgICBmbG9hdCBnZXRWYWx1ZShpbnQgYmF0Y2gsIGludCBpbklkeCkge1xcbiAgICAgICAgXCIgKyBjaGVja091dE9mQm91bmRzICsgXCJcXG4gICAgICAgIHJldHVybiBnZXRYKGJhdGNoLCBpbklkeCk7XFxuICAgICAgfVxcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWMyIGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgaW50IGJhdGNoID0gY29vcmRzWzBdO1xcbiAgICAgICAgaW50IG91dElkeCA9IGNvb3Jkc1sxXTtcXG4gICAgICAgIGludCBpbk9mZnNldCA9IG91dElkeCAqIFwiICsgd2luZG93U2l6ZSArIFwiO1xcblxcbiAgICAgICAgdmVjNCBtaW5NYXhWYWx1ZSA9IHZlYzQoXCIgKyBpbml0aWFsaXphdGlvblZhbHVlICsgXCIpO1xcbiAgICAgICAgZmxvYXQgc3VtVmFsdWUgPSAwLjA7XFxuXFxuICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IFwiICsgd2luZG93U2l6ZU5lYXJlc3RWZWM0ICsgXCI7IGkgKz0gNCkge1xcbiAgICAgICAgICBpbnQgaW5JZHggPSBpbk9mZnNldCArIGk7XFxuICAgICAgICAgIHZlYzQgdmFsdWVzID0gdmVjNChcXG4gICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgaW5JZHgpLFxcbiAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCBpbklkeCArIDEpLFxcbiAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCBpbklkeCArIDIpLFxcbiAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCBpbklkeCArIDMpXFxuICAgICAgICAgICk7XFxuXFxuICAgICAgICAgIFwiICsgdXBkYXRlU25pcHBldCArIFwiXFxuICAgICAgICB9XFxuXFxuICAgICAgICBpbnQgaW5JZHggPSBpbk9mZnNldCArIFwiICsgd2luZG93U2l6ZU5lYXJlc3RWZWM0ICsgXCI7XFxuICAgICAgICBpZiAoXCIgKyAod2luZG93U2l6ZVZlYzRSZW1haW5kZXIgPT09IDEpICsgXCIpIHtcXG4gICAgICAgICAgdmVjNCB2YWx1ZXMgPSB2ZWM0KFxcbiAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCBpbklkeCksXFxuICAgICAgICAgICAgaW5pdGlhbGl6YXRpb25WYWx1ZSxcXG4gICAgICAgICAgICBpbml0aWFsaXphdGlvblZhbHVlLFxcbiAgICAgICAgICAgIGluaXRpYWxpemF0aW9uVmFsdWVcXG4gICAgICAgICAgKTtcXG4gICAgICAgICAgXCIgKyB1cGRhdGVTbmlwcGV0ICsgXCJcXG4gICAgICAgIH0gZWxzZSBpZiAoXCIgKyAod2luZG93U2l6ZVZlYzRSZW1haW5kZXIgPT09IDIpICsgXCIpIHtcXG4gICAgICAgICAgdmVjNCB2YWx1ZXMgPSB2ZWM0KFxcbiAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCBpbklkeCksXFxuICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIGluSWR4ICsgMSksXFxuICAgICAgICAgICAgaW5pdGlhbGl6YXRpb25WYWx1ZSxcXG4gICAgICAgICAgICBpbml0aWFsaXphdGlvblZhbHVlXFxuICAgICAgICAgICk7XFxuICAgICAgICAgIFwiICsgdXBkYXRlU25pcHBldCArIFwiXFxuICAgICAgICB9IGVsc2UgaWYgKFwiICsgKHdpbmRvd1NpemVWZWM0UmVtYWluZGVyID09PSAzKSArIFwiKSB7XFxuICAgICAgICAgIHZlYzQgdmFsdWVzID0gdmVjNChcXG4gICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgaW5JZHgpLFxcbiAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCBpbklkeCArIDEpLFxcbiAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCBpbklkeCArIDIpLFxcbiAgICAgICAgICAgIGluaXRpYWxpemF0aW9uVmFsdWVcXG4gICAgICAgICAgKTtcXG4gICAgICAgICAgXCIgKyB1cGRhdGVTbmlwcGV0ICsgXCJcXG4gICAgICAgIH1cXG4gICAgICAgIHNldE91dHB1dChcIiArIHJldHVyblZhbHVlICsgXCIpO1xcbiAgICAgIH1cXG4gICAgXCI7XG4gICAgfVxuICAgIHJldHVybiBSZWR1Y2VQcm9ncmFtO1xufSgpKTtcbmV4cG9ydHMuUmVkdWNlUHJvZ3JhbSA9IFJlZHVjZVByb2dyYW07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWR1Y2VfZ3B1LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHdlYmdsX3V0aWwgPSByZXF1aXJlKFwiLi93ZWJnbF91dGlsXCIpO1xuZnVuY3Rpb24gZ2V0UmVuZGVyUkdCU2hhZGVyKGdwZ3B1LCBkZXN0aW5hdGlvbldpZHRoKSB7XG4gICAgdmFyIGZyYWdtZW50U2hhZGVyU291cmNlID0gXCJcXG4gICAgcHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbiAgICB1bmlmb3JtIHNhbXBsZXIyRCBzb3VyY2U7XFxuICAgIHZhcnlpbmcgdmVjMiByZXN1bHRVVjtcXG5cXG4gICAgY29uc3QgZmxvYXQgZGVzdGluYXRpb25XaWR0aCA9IFwiICsgZGVzdGluYXRpb25XaWR0aCArIFwiLjA7XFxuICAgIGNvbnN0IGZsb2F0IGEgPSAxLjA7XFxuXFxuICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICBmbG9hdCB4ciA9IGZsb29yKHJlc3VsdFVWLnMgKiBkZXN0aW5hdGlvbldpZHRoKSAqIDMuMDtcXG4gICAgICB2ZWMzIHggPSB4ciArIHZlYzMoMCwgMSwgMik7XFxuXFxuICAgICAgZmxvYXQgc291cmNlV2lkdGggPSBkZXN0aW5hdGlvbldpZHRoICogMy4wO1xcbiAgICAgIHZlYzMgdSA9ICh4ICsgMC41KSAvIHNvdXJjZVdpZHRoO1xcbiAgICAgIGZsb2F0IHYgPSAxLjAgLSByZXN1bHRVVi50O1xcblxcbiAgICAgIGZsb2F0IHIgPSB0ZXh0dXJlMkQoc291cmNlLCB2ZWMyKHVbMF0sIHYpKS5yO1xcbiAgICAgIGZsb2F0IGcgPSB0ZXh0dXJlMkQoc291cmNlLCB2ZWMyKHVbMV0sIHYpKS5yO1xcbiAgICAgIGZsb2F0IGIgPSB0ZXh0dXJlMkQoc291cmNlLCB2ZWMyKHVbMl0sIHYpKS5yO1xcblxcbiAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQociwgZywgYiwgYSk7XFxuICAgIH1cIjtcbiAgICByZXR1cm4gZ3BncHUuY3JlYXRlUHJvZ3JhbShmcmFnbWVudFNoYWRlclNvdXJjZSk7XG59XG5leHBvcnRzLmdldFJlbmRlclJHQlNoYWRlciA9IGdldFJlbmRlclJHQlNoYWRlcjtcbmZ1bmN0aW9uIHJlbmRlclRvQ2FudmFzKGdwZ3B1LCByZW5kZXJTaGFkZXIsIHNvdXJjZVRleCkge1xuICAgIHdlYmdsX3V0aWwuYmluZENhbnZhc1RvRnJhbWVidWZmZXIoZ3BncHUuZ2wpO1xuICAgIHJlbmRlclRvRnJhbWVidWZmZXIoZ3BncHUsIHJlbmRlclNoYWRlciwgc291cmNlVGV4KTtcbn1cbmV4cG9ydHMucmVuZGVyVG9DYW52YXMgPSByZW5kZXJUb0NhbnZhcztcbmZ1bmN0aW9uIHJlbmRlclRvRnJhbWVidWZmZXIoZ3BncHUsIHJlbmRlclNoYWRlciwgc291cmNlVGV4KSB7XG4gICAgZ3BncHUuc2V0UHJvZ3JhbShyZW5kZXJTaGFkZXIpO1xuICAgIHZhciBzb3VyY2VTYW1wbGVyTG9jYXRpb24gPSB3ZWJnbF91dGlsLmdldFByb2dyYW1Vbmlmb3JtTG9jYXRpb25PclRocm93KGdwZ3B1LmdsLCByZW5kZXJTaGFkZXIsICdzb3VyY2UnKTtcbiAgICBncGdwdS5zZXRJbnB1dE1hdHJpeFRleHR1cmUoc291cmNlVGV4LCBzb3VyY2VTYW1wbGVyTG9jYXRpb24sIDApO1xuICAgIGdwZ3B1LmV4ZWN1dGVQcm9ncmFtKCk7XG59XG5leHBvcnRzLnJlbmRlclRvRnJhbWVidWZmZXIgPSByZW5kZXJUb0ZyYW1lYnVmZmVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVuZGVyX25kYXJyYXlfZ3B1X3V0aWwuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgUmVzaXplQmlsaW5lYXIzRFByb2dyYW0gPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJlc2l6ZUJpbGluZWFyM0RQcm9ncmFtKGlucHV0U2hhcGUsIG91dHB1dERpbWVuc2lvbnNSb3dDb2wsIGFsaWduQ29ybmVycykge1xuICAgICAgICB0aGlzLnZhcmlhYmxlTmFtZXMgPSBbJ0EnXTtcbiAgICAgICAgdGhpcy5vdXRwdXRTaGFwZSA9IFtdO1xuICAgICAgICB2YXIgZGVwdGggPSBpbnB1dFNoYXBlWzJdO1xuICAgICAgICB0aGlzLm91dHB1dFNoYXBlID1cbiAgICAgICAgICAgIFtvdXRwdXREaW1lbnNpb25zUm93Q29sWzBdLCBvdXRwdXREaW1lbnNpb25zUm93Q29sWzFdLCBkZXB0aF07XG4gICAgICAgIHZhciBlZmZlY3RpdmVJbnB1dFNoYXBlID0gYWxpZ25Db3JuZXJzID9cbiAgICAgICAgICAgIFtpbnB1dFNoYXBlWzBdIC0gMSwgaW5wdXRTaGFwZVsxXSAtIDEsIGRlcHRoXSA6XG4gICAgICAgICAgICBpbnB1dFNoYXBlO1xuICAgICAgICB2YXIgZWZmZWN0aXZlT3V0cHV0U2hhcGUgPSBhbGlnbkNvcm5lcnMgP1xuICAgICAgICAgICAgW3RoaXMub3V0cHV0U2hhcGVbMF0gLSAxLCB0aGlzLm91dHB1dFNoYXBlWzFdIC0gMSwgZGVwdGhdIDpcbiAgICAgICAgICAgIHRoaXMub3V0cHV0U2hhcGU7XG4gICAgICAgIHRoaXMudXNlckNvZGUgPSBcIlxcbiAgICAgIGNvbnN0IHZlYzIgZWZmZWN0aXZlSW5wdXRPdmVyT3V0cHV0UmF0aW9SQyA9IHZlYzIoXFxuICAgICAgICAgIFwiICsgZWZmZWN0aXZlSW5wdXRTaGFwZVswXSAvIGVmZmVjdGl2ZU91dHB1dFNoYXBlWzBdICsgXCIsXFxuICAgICAgICAgIFwiICsgZWZmZWN0aXZlSW5wdXRTaGFwZVsxXSAvIGVmZmVjdGl2ZU91dHB1dFNoYXBlWzFdICsgXCIpO1xcbiAgICAgIGNvbnN0IHZlYzIgaW5wdXRTaGFwZVJDID0gdmVjMihcIiArIGlucHV0U2hhcGVbMF0gKyBcIi4wLCBcIiArIGlucHV0U2hhcGVbMV0gKyBcIi4wKTtcXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjMyBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIGl2ZWMyIHlSQyA9IGNvb3Jkcy54eTtcXG4gICAgICAgIGludCBkID0gY29vcmRzLno7XFxuXFxuICAgICAgICAvLyBGcmFjdGlvbmFsIHNvdXJjZSBpbmRleC5cXG4gICAgICAgIHZlYzIgc291cmNlRnJhY0luZGV4UkMgPSB2ZWMyKHlSQykgKiBlZmZlY3RpdmVJbnB1dE92ZXJPdXRwdXRSYXRpb1JDO1xcblxcbiAgICAgICAgLy8gQ29tcHV0ZSB0aGUgZm91ciBpbnRlZ2VyIGluZGljZXMuXFxuICAgICAgICBpdmVjMiBzb3VyY2VGbG9vclJDID0gaXZlYzIoc291cmNlRnJhY0luZGV4UkMpO1xcbiAgICAgICAgaXZlYzIgc291cmNlQ2VpbFJDID0gaXZlYzIoXFxuICAgICAgICAgIG1pbihpbnB1dFNoYXBlUkMgLSAxLjAsIGNlaWwoc291cmNlRnJhY0luZGV4UkMpKSk7XFxuXFxuICAgICAgICBmbG9hdCB0b3BMZWZ0ID0gZ2V0QShzb3VyY2VGbG9vclJDLngsIHNvdXJjZUZsb29yUkMueSwgZCk7XFxuICAgICAgICBmbG9hdCBib3R0b21MZWZ0ID0gZ2V0QShzb3VyY2VDZWlsUkMueCwgc291cmNlRmxvb3JSQy55LCBkKTtcXG4gICAgICAgIGZsb2F0IHRvcFJpZ2h0ID0gZ2V0QShzb3VyY2VGbG9vclJDLngsIHNvdXJjZUNlaWxSQy55LCBkKTtcXG4gICAgICAgIGZsb2F0IGJvdHRvbVJpZ2h0ID0gZ2V0QShzb3VyY2VDZWlsUkMueCwgc291cmNlQ2VpbFJDLnksIGQpO1xcblxcbiAgICAgICAgdmVjMiBmcmFjUkMgPSBzb3VyY2VGcmFjSW5kZXhSQyAtIHZlYzIoc291cmNlRmxvb3JSQyk7XFxuXFxuICAgICAgICBmbG9hdCB0b3AgPSB0b3BMZWZ0ICsgKHRvcFJpZ2h0IC0gdG9wTGVmdCkgKiBmcmFjUkMueTtcXG4gICAgICAgIGZsb2F0IGJvdHRvbSA9IGJvdHRvbUxlZnQgKyAoYm90dG9tUmlnaHQgLSBib3R0b21MZWZ0KSAqIGZyYWNSQy55O1xcbiAgICAgICAgZmxvYXQgbmV3VmFsdWUgPSB0b3AgKyAoYm90dG9tIC0gdG9wKSAqIGZyYWNSQy54O1xcblxcbiAgICAgICAgc2V0T3V0cHV0KG5ld1ZhbHVlKTtcXG4gICAgICB9XFxuICAgIFwiO1xuICAgIH1cbiAgICByZXR1cm4gUmVzaXplQmlsaW5lYXIzRFByb2dyYW07XG59KCkpO1xuZXhwb3J0cy5SZXNpemVCaWxpbmVhcjNEUHJvZ3JhbSA9IFJlc2l6ZUJpbGluZWFyM0RQcm9ncmFtO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVzaXplX2JpbGluZWFyX2dwdS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBlbnZpcm9ubWVudF8xID0gcmVxdWlyZShcIi4uLy4uL2Vudmlyb25tZW50XCIpO1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vLi4vdXRpbFwiKTtcbnZhciBicm9hZGNhc3RfdXRpbCA9IHJlcXVpcmUoXCIuLi9icm9hZGNhc3RfdXRpbFwiKTtcbnZhciB0ZXhfdXRpbCA9IHJlcXVpcmUoXCIuL3RleF91dGlsXCIpO1xudmFyIHRleF91dGlsXzEgPSByZXF1aXJlKFwiLi90ZXhfdXRpbFwiKTtcbmZ1bmN0aW9uIG1ha2VTaGFkZXIoaW5wdXRzSW5mbywgb3V0cHV0U2hhcGUsIHVzZXJDb2RlLCBicm9hZGNhc3QpIHtcbiAgICB2YXIgc2FtcGxlU25pcHBldCA9IGdldFNhbXBsZVNuaXBwZXQoKTtcbiAgICB2YXIgc2V0T3V0cHV0U25pcHBldCA9IGdldFNldE91dHB1dFNuaXBwZXQoKTtcbiAgICB2YXIgaW5wdXRQcmVmaXhTbmlwcGV0ID0gaW5wdXRzSW5mby5tYXAoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIFwidW5pZm9ybSBzYW1wbGVyMkQgXCIgKyB4Lm5hbWUgKyBcIjtcIjsgfSkuam9pbignXFxuJyk7XG4gICAgdmFyIGlucHV0U2FtcGxpbmdTbmlwcGV0ID0gaW5wdXRzSW5mby5tYXAoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIGdldElucHV0U2FtcGxpbmdTbmlwcGV0KHgsIG91dHB1dFNoYXBlLCBicm9hZGNhc3QpOyB9KVxuICAgICAgICAuam9pbignXFxuJyk7XG4gICAgdmFyIG91dFRleFNoYXBlID0gb3V0cHV0U2hhcGUudGV4U2hhcGU7XG4gICAgdmFyIG91dHB1dFNhbXBsaW5nU25pcHBldCA9IGdldE91dHB1dFNhbXBsaW5nU25pcHBldChvdXRwdXRTaGFwZS5sb2dpY2FsU2hhcGUsIG91dFRleFNoYXBlKTtcbiAgICB2YXIgc291cmNlID0gW1xuICAgICAgICBTSEFERVJfUFJFRklYLCBzYW1wbGVTbmlwcGV0LCBzZXRPdXRwdXRTbmlwcGV0LCBpbnB1dFByZWZpeFNuaXBwZXQsXG4gICAgICAgIG91dHB1dFNhbXBsaW5nU25pcHBldCwgaW5wdXRTYW1wbGluZ1NuaXBwZXQsIHVzZXJDb2RlXG4gICAgXS5qb2luKCdcXG4nKTtcbiAgICByZXR1cm4gc291cmNlO1xufVxuZXhwb3J0cy5tYWtlU2hhZGVyID0gbWFrZVNoYWRlcjtcbmZ1bmN0aW9uIGdldFNhbXBsZVNuaXBwZXQoKSB7XG4gICAgcmV0dXJuIGVudmlyb25tZW50XzEuRU5WLmdldCgnV0VCR0xfRkxPQVRfVEVYVFVSRV9FTkFCTEVEJykgP1xuICAgICAgICBGTE9BVF9URVhUVVJFX1NBTVBMRV9TTklQUEVUIDpcbiAgICAgICAgVU5TSUdORURfQllURV9URVhUVVJFX1NBTVBMRV9TTklQUEVUO1xufVxuZnVuY3Rpb24gZ2V0U2V0T3V0cHV0U25pcHBldCgpIHtcbiAgICByZXR1cm4gZW52aXJvbm1lbnRfMS5FTlYuZ2V0KCdXRUJHTF9GTE9BVF9URVhUVVJFX0VOQUJMRUQnKSA/XG4gICAgICAgIEZMT0FUX1RFWFRVUkVfU0VUT1VUUFVUX1NOSVBQRVQgOlxuICAgICAgICBVTlNJR05FRF9CWVRFX1RFWFRVUkVfU0VUT1VUUFVUX1NOSVBQRVQ7XG59XG5mdW5jdGlvbiBnZXRTYW1wbGVyRnJvbUluSW5mbyhpbkluZm8pIHtcbiAgICB2YXIgc2hhcGUgPSBpbkluZm8uc2hhcGVJbmZvLmxvZ2ljYWxTaGFwZTtcbiAgICBzd2l0Y2ggKHNoYXBlLmxlbmd0aCkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICByZXR1cm4gZ2V0U2FtcGxlclNjYWxhcihpbkluZm8pO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICByZXR1cm4gZ2V0U2FtcGxlcjFEKGluSW5mbyk7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIHJldHVybiBnZXRTYW1wbGVyMkQoaW5JbmZvKTtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgcmV0dXJuIGdldFNhbXBsZXIzRChpbkluZm8pO1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICByZXR1cm4gZ2V0U2FtcGxlcjREKGluSW5mbyk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3Ioc2hhcGUubGVuZ3RoICsgXCItRCBpbnB1dCBzYW1wbGluZ1wiICtcbiAgICAgICAgICAgICAgICBcIiBpcyBub3QgeWV0IHN1cHBvcnRlZFwiKTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRJbnB1dFNhbXBsaW5nU25pcHBldChpbkluZm8sIG91dFNoYXBlSW5mbywgYnJvYWRjYXN0KSB7XG4gICAgdmFyIHJlcyA9IGdldFNhbXBsZXJGbGF0KGluSW5mbyk7XG4gICAgcmVzICs9IGdldFNhbXBsZXJGcm9tSW5JbmZvKGluSW5mbyk7XG4gICAgaWYgKGJyb2FkY2FzdCB8fFxuICAgICAgICB1dGlsLmFycmF5c0VxdWFsKGluSW5mby5zaGFwZUluZm8ubG9naWNhbFNoYXBlLCBvdXRTaGFwZUluZm8ubG9naWNhbFNoYXBlKSkge1xuICAgICAgICByZXMgKz0gZ2V0U2FtcGxlckF0T3V0cHV0Q29vcmRzKGluSW5mbywgb3V0U2hhcGVJbmZvLCBicm9hZGNhc3QpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuZnVuY3Rpb24gZ2V0T3V0cHV0U2FtcGxpbmdTbmlwcGV0KG91dFNoYXBlLCBvdXRUZXhTaGFwZSkge1xuICAgIHN3aXRjaCAob3V0U2hhcGUubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIHJldHVybiBnZXRPdXRwdXRTY2FsYXJDb29yZHMoKTtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgcmV0dXJuIGdldE91dHB1dDFEQ29vcmRzKG91dFNoYXBlLCBvdXRUZXhTaGFwZSk7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIHJldHVybiBnZXRPdXRwdXQyRENvb3JkcyhvdXRTaGFwZSwgb3V0VGV4U2hhcGUpO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICByZXR1cm4gZ2V0T3V0cHV0M0RDb29yZHMob3V0U2hhcGUsIG91dFRleFNoYXBlKTtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgcmV0dXJuIGdldE91dHB1dDREQ29vcmRzKG91dFNoYXBlLCBvdXRUZXhTaGFwZSk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3Iob3V0U2hhcGUubGVuZ3RoICsgXCItRCBvdXRwdXQgc2FtcGxpbmcgaXMgbm90IHlldCBzdXBwb3J0ZWRcIik7XG4gICAgfVxufVxudmFyIFNBTVBMRV8xRF9TTklQUEVUID0gXCJcXG52ZWMyIFVWZnJvbTFEKGludCB0ZXhOdW1SLCBpbnQgdGV4TnVtQywgaW50IGluZGV4KSB7XFxuICBpbnQgdGV4UiA9IGluZGV4IC8gdGV4TnVtQztcXG4gIGludCB0ZXhDID0gaW5kZXggLSB0ZXhSICogdGV4TnVtQztcXG4gIHJldHVybiAodmVjMih0ZXhDLCB0ZXhSKSArIGhhbGZDUikgLyB2ZWMyKHRleE51bUMsIHRleE51bVIpO1xcbn1cXG5cIjtcbnZhciBTQU1QTEVfMkRfU05JUFBFVCA9IFwiXFxudmVjMiBVVmZyb20yRChpbnQgdGV4TnVtUiwgaW50IHRleE51bUMsIGludCBudW1DLCBpbnQgcm93LCBpbnQgY29sKSB7XFxuICBpbnQgaW5kZXggPSByb3cgKiBudW1DICsgY29sO1xcbiAgaW50IHRleFIgPSBpbmRleCAvIHRleE51bUM7XFxuICBpbnQgdGV4QyA9IGluZGV4IC0gdGV4UiAqIHRleE51bUM7XFxuICByZXR1cm4gKHZlYzIodGV4QywgdGV4UikgKyBoYWxmQ1IpIC8gdmVjMih0ZXhOdW1DLCB0ZXhOdW1SKTtcXG59XFxuXCI7XG52YXIgU0FNUExFXzNEX1NOSVBQRVQgPSBcIlxcbnZlYzIgVVZmcm9tM0QoaW50IHRleE51bVIsIGludCB0ZXhOdW1DLCBpbnQgc3RyaWRlMCxcXG4gICAgaW50IHN0cmlkZTEsIGludCByb3csIGludCBjb2wsIGludCBkZXB0aCkge1xcbiAgLy8gRXhwbGljaXRseSB1c2UgaW50ZWdlciBvcGVyYXRpb25zIGFzIGRvdCgpIG9ubHkgd29ya3Mgb24gZmxvYXRzLlxcbiAgaW50IGluZGV4ID0gcm93ICogc3RyaWRlMCArIGNvbCAqIHN0cmlkZTEgKyBkZXB0aDtcXG4gIGludCB0ZXhSID0gaW5kZXggLyB0ZXhOdW1DO1xcbiAgaW50IHRleEMgPSBpbmRleCAtIHRleFIgKiB0ZXhOdW1DO1xcbiAgcmV0dXJuICh2ZWMyKHRleEMsIHRleFIpICsgaGFsZkNSKSAvIHZlYzIodGV4TnVtQywgdGV4TnVtUik7XFxufVxcblwiO1xudmFyIFNBTVBMRV80RF9TTklQUEVUID0gXCJcXG52ZWMyIFVWZnJvbTREKGludCB0ZXhOdW1SLCBpbnQgdGV4TnVtQywgaW50IHN0cmlkZTAsXFxuICAgIGludCBzdHJpZGUxLCBpbnQgc3RyaWRlMiwgaW50IHJvdywgaW50IGNvbCwgaW50IGRlcHRoLFxcbiAgICBpbnQgZGVwdGgyKSB7XFxuICAvLyBFeHBsaWNpdGx5IHVzZSBpbnRlZ2VyIG9wZXJhdGlvbnMgYXMgZG90KCkgb25seSB3b3JrcyBvbiBmbG9hdHMuXFxuICBpbnQgaW5kZXggPSByb3cgKiBzdHJpZGUwICsgY29sICogc3RyaWRlMSArIGRlcHRoICogc3RyaWRlMiArIGRlcHRoMjtcXG4gIGludCB0ZXhSID0gaW5kZXggLyB0ZXhOdW1DO1xcbiAgaW50IHRleEMgPSBpbmRleCAtIHRleFIgKiB0ZXhOdW1DO1xcbiAgcmV0dXJuICh2ZWMyKHRleEMsIHRleFIpICsgaGFsZkNSKSAvIHZlYzIodGV4TnVtQywgdGV4TnVtUik7XFxufVxcblwiO1xudmFyIFVOU0lHTkVEX0JZVEVfVEVYVFVSRV9TQU1QTEVfU05JUFBFVCA9IFwiXFxuICB1bmlmb3JtIGZsb2F0IE5hTjtcXG5cXG4gIGNvbnN0IHZlYzQgZmxvYXREZWx0YXMgPSB2ZWM0KFxcbiAgICAgIDEuMCxcXG4gICAgICAxLjAgLyAyNTUuMCxcXG4gICAgICAxLjAgLyAoMjU1LjAgKiAyNTUuMCksXFxuICAgICAgMS4wIC8gKDI1NS4wICogMjU1LjAgKiAyNTUuMClcXG4gICk7XFxuICBjb25zdCBmbG9hdCBtaW5WYWx1ZSA9IFwiICsgdGV4X3V0aWwuRkxPQVRfTUlOICsgXCIuMDtcXG4gIGNvbnN0IGZsb2F0IG1heFZhbHVlID0gXCIgKyB0ZXhfdXRpbC5GTE9BVF9NQVggKyBcIi4wO1xcbiAgY29uc3QgZmxvYXQgcmFuZ2UgPSAobWF4VmFsdWUgLSBtaW5WYWx1ZSkgLyAyNTUuMDtcXG4gIGNvbnN0IHZlYzIgZG90UmFuZ2UgPSB2ZWMyKDEuMCwgcmFuZ2UpO1xcblxcbiAgZmxvYXQgc2FtcGxlKHNhbXBsZXIyRCB0ZXh0dXJlLCB2ZWMyIHV2KSB7XFxuICAgIHZlYzQgc2FtcGxlVmFsdWUgPSB0ZXh0dXJlMkQodGV4dHVyZSwgdXYpO1xcbiAgICBpZiAoYWxsKGVxdWFsKHNhbXBsZVZhbHVlLCB2ZWM0KFwiICsgdGV4X3V0aWwuQllURV9OQU5fVkFMVUUgKyBcIikpKSkge1xcbiAgICAgIHJldHVybiBOYU47XFxuICAgIH1cXG5cXG4gICAgdmVjNCBlbmNWYWx1ZSA9IGZsb29yKHNhbXBsZVZhbHVlICogMjU1LjAgKyAwLjUpO1xcbiAgICBmbG9hdCBkZWNvZGVkVmFsdWUgPSBkb3QoZW5jVmFsdWUsIGZsb2F0RGVsdGFzKTtcXG4gICAgcmV0dXJuIGRvdCh2ZWMyKG1pblZhbHVlLCBkZWNvZGVkVmFsdWUpLCBkb3RSYW5nZSk7XFxuICB9XFxuXCI7XG52YXIgVU5TSUdORURfQllURV9URVhUVVJFX1NFVE9VVFBVVF9TTklQUEVUID0gXCJcXG4gIGNvbnN0IHZlYzQgZmxvYXRQb3dlcnMgPSB2ZWM0KFxcbiAgICAxLjAsXFxuICAgIDI1NS4wLFxcbiAgICAyNTUuMCAqIDI1NS4wLFxcbiAgICAyNTUuMCAqIDI1NS4wICogMjU1LjBcXG4gICk7XFxuICBjb25zdCB2ZWMyIHJlY2lwUmFuZ2UgPSB2ZWMyKDEuMC9yYW5nZSk7XFxuICBjb25zdCB2ZWMyIHJlY2lwUmFuZ2UyNTUgPSB2ZWMyKDEuMC8obWF4VmFsdWUgLSBtaW5WYWx1ZSkpO1xcblxcbiAgdm9pZCBzZXRPdXRwdXQoZmxvYXQgZGVjb2RlZFZhbHVlKSB7XFxuICAgIGlmIChpc05hTihkZWNvZGVkVmFsdWUpKSB7XFxuICAgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNChcIiArIHRleF91dGlsLkJZVEVfTkFOX1ZBTFVFICsgXCIpO1xcbiAgICAgIHJldHVybjtcXG4gICAgfVxcblxcbiAgICBmbG9hdCBhID0gZG90KHZlYzIoZGVjb2RlZFZhbHVlLCAtbWluVmFsdWUpLCByZWNpcFJhbmdlKTtcXG4gICAgZmxvYXQgYiA9IGZyYWN0KGEpICogMjU1LjA7XFxuICAgIGZsb2F0IGMgPSBmcmFjdChiKSAqIDI1NS4wO1xcbiAgICBmbG9hdCBkID0gZnJhY3QoYykgKiAyNTUuMDtcXG4gICAgZ2xfRnJhZ0NvbG9yID0gZmxvb3IodmVjNChhLCBiLCBjLCBkKSkgLyAyNTUuMDtcXG5cXG4gICAgLy8gVE9ETyhkc21pbGtvdik6IFZlcnNpb24gYWJvdmUgZ2V0cyBiZXR0ZXIgYWNjdXJhY3kgYnV0IHByb2JhYmx5IHNsb3dlclxcbiAgICAvLyB0aGFuIHRoZSB2ZXJzaW9uIGJlbG93LiBCZW5jaG1hcmsgdG8gZGV0ZXJtaW5lIGlmIHRoZSBhY2N1cmFjeSBpcyB3b3J0aFxcbiAgICAvLyB0aGUgY29zdC5cXG5cXG4gICAgLy8gZmxvYXQgbm9ybVZhbHVlID0gZG90KHZlYzIoZGVjb2RlZFZhbHVlLCAtbWluVmFsdWUpLCByZWNpcFJhbmdlMjU1KTtcXG4gICAgLy8gdmVjNCBmID0gbm9ybVZhbHVlICogZmxvYXRQb3dlcnM7XFxuICAgIC8vIGdsX0ZyYWdDb2xvciA9IGZsb29yKGZyYWN0KGYpICogMjU1LjApIC8gMjU1LjA7XFxuICB9XFxuXCI7XG52YXIgRkxPQVRfVEVYVFVSRV9TQU1QTEVfU05JUFBFVCA9IFwiXFxuICBmbG9hdCBzYW1wbGUoc2FtcGxlcjJEIHRleHR1cmUsIHZlYzIgdXYpIHtcXG4gICAgcmV0dXJuIHRleHR1cmUyRCh0ZXh0dXJlLCB1dikucjtcXG4gIH1cXG5cIjtcbnZhciBGTE9BVF9URVhUVVJFX1NFVE9VVFBVVF9TTklQUEVUID0gXCJcXG4gIHZvaWQgc2V0T3V0cHV0KGZsb2F0IHZhbCkge1xcbiAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KHZhbCwgMCwgMCwgMCk7XFxuICB9XFxuXCI7XG52YXIgU0hBREVSX1BSRUZJWCA9IFwiXFxuICBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuICBwcmVjaXNpb24gaGlnaHAgaW50O1xcbiAgdmFyeWluZyB2ZWMyIHJlc3VsdFVWO1xcbiAgY29uc3QgdmVjMiBoYWxmQ1IgPSB2ZWMyKDAuNSwgMC41KTtcXG5cXG4gIGJvb2wgaXNOYU4oZmxvYXQgdmFsKSB7XFxuICAgIHJldHVybiB2YWwgPT0gdmFsID8gZmFsc2UgOiB0cnVlO1xcbiAgfVxcblxcbiAgYm9vbCBoYXNOYU4odmVjNCB2YWx1ZXMpIHtcXG4gICAgcmV0dXJuIGFueShub3RFcXVhbCh2YWx1ZXMsIHZhbHVlcykpO1xcbiAgfVxcblxcbiAgZmxvYXQgZ2V0TmFOKHZlYzQgdmFsdWVzKSB7XFxuICAgIHJldHVybiBkb3QodmVjNCgxKSwgdmFsdWVzKTtcXG4gIH1cXG5cXG4gIGludCByb3VuZChmbG9hdCB2YWx1ZSkge1xcbiAgICByZXR1cm4gaW50KGZsb29yKHZhbHVlICsgMC41KSk7XFxuICB9XFxuXFxuICBpbnQgaW1vZChpbnQgeCwgaW50IHkpIHtcXG4gICAgcmV0dXJuIHggLSB5ICogKHggLyB5KTtcXG4gIH1cXG5cXG4gIGNvbnN0IHZlYzIgcmFuZG9tQ29uc3QgPSB2ZWMyKFxcbiAgICAyMy4xNDA2OTI2MzI3NzkyNiwgLy8gZV5waSAoR2VsZm9uZCdzIGNvbnN0YW50KVxcbiAgICAgMi42NjUxNDQxNDI2OTAyMjUgLy8gMl5zcXJ0KDIpIChHZWxmb25kXFx1MjAxM1NjaG5laWRlciBjb25zdGFudClcXG4gICk7XFxuXFxuICBmbG9hdCByYW5kb20oZmxvYXQgc2VlZCkge1xcbiAgICAgIHJldHVybiBmcmFjdChjb3MoZG90KHJlc3VsdFVWICogc2VlZCwgcmFuZG9tQ29uc3QpKSAqIDEyMzQ1LjY3ODkpO1xcbiAgfVxcblxcbiAgZmxvYXQgc2FtcGxlVVZBbmREZXB0aChzYW1wbGVyMkQgdGV4dHVyZSwgdmVjMiB1diwgaW50IGRlcHRoKSB7XFxuICAgIGZsb2F0IHZhbHVlO1xcbiAgICBpZiAoZGVwdGggPT0gMCkge1xcbiAgICAgIHZhbHVlID0gdGV4dHVyZTJEKHRleHR1cmUsIHV2KS5yO1xcbiAgICB9IGVsc2UgaWYgKGRlcHRoID09IDEpIHtcXG4gICAgICB2YWx1ZSA9IHRleHR1cmUyRCh0ZXh0dXJlLCB1dikuZztcXG4gICAgfSBlbHNlIGlmIChkZXB0aCA9PSAyKSB7XFxuICAgICAgdmFsdWUgPSB0ZXh0dXJlMkQodGV4dHVyZSwgdXYpLmI7XFxuICAgIH0gZWxzZSBpZiAoZGVwdGggPT0gMykge1xcbiAgICAgIHZhbHVlID0gdGV4dHVyZTJEKHRleHR1cmUsIHV2KS5hO1xcbiAgICB9XFxuICAgIHJldHVybiBmbG9vcih2YWx1ZSAqIDI1NS4wICsgMC41KTtcXG4gIH1cXG5cXG4gIFwiICsgU0FNUExFXzFEX1NOSVBQRVQgKyBcIlxcbiAgXCIgKyBTQU1QTEVfMkRfU05JUFBFVCArIFwiXFxuICBcIiArIFNBTVBMRV8zRF9TTklQUEVUICsgXCJcXG4gIFwiICsgU0FNUExFXzREX1NOSVBQRVQgKyBcIlxcblwiO1xuZnVuY3Rpb24gZ2V0T3V0cHV0U2NhbGFyQ29vcmRzKCkge1xuICAgIHJldHVybiBcIlxcbiAgICBpbnQgZ2V0T3V0cHV0Q29vcmRzKCkge1xcbiAgICAgIHJldHVybiAwO1xcbiAgICB9XFxuICBcIjtcbn1cbmZ1bmN0aW9uIGdldE91dHB1dDFEQ29vcmRzKHNoYXBlLCB0ZXhTaGFwZSkge1xuICAgIGlmICh0ZXhTaGFwZVswXSA9PT0gMSkge1xuICAgICAgICByZXR1cm4gXCJcXG4gICAgICBpbnQgZ2V0T3V0cHV0Q29vcmRzKCkge1xcbiAgICAgICAgcmV0dXJuIGludChyZXN1bHRVVi54ICogXCIgKyB0ZXhTaGFwZVsxXSArIFwiLjApO1xcbiAgICAgIH1cXG4gICAgXCI7XG4gICAgfVxuICAgIGlmICh0ZXhTaGFwZVsxXSA9PT0gMSkge1xuICAgICAgICByZXR1cm4gXCJcXG4gICAgICBpbnQgZ2V0T3V0cHV0Q29vcmRzKCkge1xcbiAgICAgICAgcmV0dXJuIGludChyZXN1bHRVVi55ICogXCIgKyB0ZXhTaGFwZVswXSArIFwiLjApO1xcbiAgICAgIH1cXG4gICAgXCI7XG4gICAgfVxuICAgIHJldHVybiBcIlxcbiAgICBpbnQgZ2V0T3V0cHV0Q29vcmRzKCkge1xcbiAgICAgIGl2ZWMyIHJlc1RleFJDID0gaXZlYzIocmVzdWx0VVYueXggKlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVjMihcIiArIHRleFNoYXBlWzBdICsgXCIsIFwiICsgdGV4U2hhcGVbMV0gKyBcIikpO1xcbiAgICAgIHJldHVybiByZXNUZXhSQy54ICogXCIgKyB0ZXhTaGFwZVsxXSArIFwiICsgcmVzVGV4UkMueTtcXG4gICAgfVxcbiAgXCI7XG59XG5mdW5jdGlvbiBnZXRPdXRwdXQzRENvb3JkcyhzaGFwZSwgdGV4U2hhcGUpIHtcbiAgICB2YXIgc3RyaWRlMCA9IHNoYXBlWzFdICogc2hhcGVbMl07XG4gICAgdmFyIHN0cmlkZTEgPSBzaGFwZVsyXTtcbiAgICByZXR1cm4gXCJcXG4gICAgaXZlYzMgZ2V0T3V0cHV0Q29vcmRzKCkge1xcbiAgICAgIGl2ZWMyIHJlc1RleFJDID0gaXZlYzIocmVzdWx0VVYueXggKlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVjMihcIiArIHRleFNoYXBlWzBdICsgXCIsIFwiICsgdGV4U2hhcGVbMV0gKyBcIikpO1xcbiAgICAgIGludCBpbmRleCA9IHJlc1RleFJDLnggKiBcIiArIHRleFNoYXBlWzFdICsgXCIgKyByZXNUZXhSQy55O1xcbiAgICAgIGludCByID0gaW5kZXggLyBcIiArIHN0cmlkZTAgKyBcIjtcXG4gICAgICBpbmRleCAtPSByICogXCIgKyBzdHJpZGUwICsgXCI7XFxuICAgICAgaW50IGMgPSBpbmRleCAvIFwiICsgc3RyaWRlMSArIFwiO1xcbiAgICAgIGludCBkID0gaW5kZXggLSBjICogXCIgKyBzdHJpZGUxICsgXCI7XFxuICAgICAgcmV0dXJuIGl2ZWMzKHIsIGMsIGQpO1xcbiAgICB9XFxuICBcIjtcbn1cbmZ1bmN0aW9uIGdldE91dHB1dDREQ29vcmRzKHNoYXBlLCB0ZXhTaGFwZSkge1xuICAgIHZhciBzdHJpZGUyID0gc2hhcGVbM107XG4gICAgdmFyIHN0cmlkZTEgPSBzaGFwZVsyXSAqIHN0cmlkZTI7XG4gICAgdmFyIHN0cmlkZTAgPSBzaGFwZVsxXSAqIHN0cmlkZTE7XG4gICAgcmV0dXJuIFwiXFxuICAgIGl2ZWM0IGdldE91dHB1dENvb3JkcygpIHtcXG4gICAgICBpdmVjMiByZXNUZXhSQyA9IGl2ZWMyKHJlc3VsdFVWLnl4ICpcXG4gICAgICAgIHZlYzIoXCIgKyB0ZXhTaGFwZVswXSArIFwiLCBcIiArIHRleFNoYXBlWzFdICsgXCIpKTtcXG4gICAgICBpbnQgaW5kZXggPSByZXNUZXhSQy54ICogXCIgKyB0ZXhTaGFwZVsxXSArIFwiICsgcmVzVGV4UkMueTtcXG5cXG4gICAgICBpbnQgciA9IGluZGV4IC8gXCIgKyBzdHJpZGUwICsgXCI7XFxuICAgICAgaW5kZXggLT0gciAqIFwiICsgc3RyaWRlMCArIFwiO1xcblxcbiAgICAgIGludCBjID0gaW5kZXggLyBcIiArIHN0cmlkZTEgKyBcIjtcXG4gICAgICBpbmRleCAtPSBjICogXCIgKyBzdHJpZGUxICsgXCI7XFxuXFxuICAgICAgaW50IGQgPSBpbmRleCAvIFwiICsgc3RyaWRlMiArIFwiO1xcbiAgICAgIGludCBkMiA9IGluZGV4IC0gZCAqIFwiICsgc3RyaWRlMiArIFwiO1xcblxcbiAgICAgIHJldHVybiBpdmVjNChyLCBjLCBkLCBkMik7XFxuICAgIH1cXG4gIFwiO1xufVxuZnVuY3Rpb24gZ2V0T3V0cHV0MkRDb29yZHMoc2hhcGUsIHRleFNoYXBlKSB7XG4gICAgaWYgKHV0aWwuYXJyYXlzRXF1YWwoc2hhcGUsIHRleFNoYXBlKSkge1xuICAgICAgICByZXR1cm4gXCJcXG4gICAgICBpdmVjMiBnZXRPdXRwdXRDb29yZHMoKSB7XFxuICAgICAgICByZXR1cm4gaXZlYzIocmVzdWx0VVYueXggKiB2ZWMyKFwiICsgdGV4U2hhcGVbMF0gKyBcIiwgXCIgKyB0ZXhTaGFwZVsxXSArIFwiKSk7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgaWYgKHNoYXBlWzFdID09PSAxKSB7XG4gICAgICAgIHJldHVybiBcIlxcbiAgICAgIGl2ZWMyIGdldE91dHB1dENvb3JkcygpIHtcXG4gICAgICAgIGl2ZWMyIHJlc1RleFJDID0gaXZlYzIocmVzdWx0VVYueXggKlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZWMyKFwiICsgdGV4U2hhcGVbMF0gKyBcIiwgXCIgKyB0ZXhTaGFwZVsxXSArIFwiKSk7XFxuICAgICAgICBpbnQgaW5kZXggPSByZXNUZXhSQy54ICogXCIgKyB0ZXhTaGFwZVsxXSArIFwiICsgcmVzVGV4UkMueTtcXG4gICAgICAgIHJldHVybiBpdmVjMihpbmRleCwgMCk7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgaWYgKHNoYXBlWzBdID09PSAxKSB7XG4gICAgICAgIHJldHVybiBcIlxcbiAgICAgIGl2ZWMyIGdldE91dHB1dENvb3JkcygpIHtcXG4gICAgICAgIGl2ZWMyIHJlc1RleFJDID0gaXZlYzIocmVzdWx0VVYueXggKlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZWMyKFwiICsgdGV4U2hhcGVbMF0gKyBcIiwgXCIgKyB0ZXhTaGFwZVsxXSArIFwiKSk7XFxuICAgICAgICBpbnQgaW5kZXggPSByZXNUZXhSQy54ICogXCIgKyB0ZXhTaGFwZVsxXSArIFwiICsgcmVzVGV4UkMueTtcXG4gICAgICAgIHJldHVybiBpdmVjMigwLCBpbmRleCk7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgcmV0dXJuIFwiXFxuICAgIGl2ZWMyIGdldE91dHB1dENvb3JkcygpIHtcXG4gICAgICBpdmVjMiByZXNUZXhSQyA9IGl2ZWMyKHJlc3VsdFVWLnl4ICpcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIoXCIgKyB0ZXhTaGFwZVswXSArIFwiLCBcIiArIHRleFNoYXBlWzFdICsgXCIpKTtcXG4gICAgICBpbnQgaW5kZXggPSByZXNUZXhSQy54ICogXCIgKyB0ZXhTaGFwZVsxXSArIFwiICsgcmVzVGV4UkMueTtcXG4gICAgICBpbnQgciA9IGluZGV4IC8gXCIgKyBzaGFwZVsxXSArIFwiO1xcbiAgICAgIGludCBjID0gaW5kZXggLSByICogXCIgKyBzaGFwZVsxXSArIFwiO1xcbiAgICAgIHJldHVybiBpdmVjMihyLCBjKTtcXG4gICAgfVxcbiAgXCI7XG59XG5mdW5jdGlvbiBnZXRTYW1wbGVyU2NhbGFyKGlucHV0SW5mbykge1xuICAgIHZhciB0ZXhOYW1lID0gaW5wdXRJbmZvLm5hbWU7XG4gICAgdmFyIGZ1bmNOYW1lID0gJ2dldCcgKyB0ZXhOYW1lLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgdGV4TmFtZS5zbGljZSgxKTtcbiAgICByZXR1cm4gXCJcXG4gICAgZmxvYXQgXCIgKyBmdW5jTmFtZSArIFwiKCkge1xcbiAgICAgIHJldHVybiBzYW1wbGUoXCIgKyB0ZXhOYW1lICsgXCIsIGhhbGZDUik7XFxuICAgIH1cXG4gIFwiO1xufVxuZnVuY3Rpb24gZ2V0U2FtcGxlcjFEKGlucHV0SW5mbykge1xuICAgIHZhciB0ZXhOYW1lID0gaW5wdXRJbmZvLm5hbWU7XG4gICAgdmFyIGZ1bmNOYW1lID0gJ2dldCcgKyB0ZXhOYW1lLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgdGV4TmFtZS5zbGljZSgxKTtcbiAgICByZXR1cm4gXCJcXG4gICAgZmxvYXQgXCIgKyBmdW5jTmFtZSArIFwiKGludCBpbmRleCkge1xcbiAgICAgIHJldHVybiBcIiArIGZ1bmNOYW1lICsgXCJGbGF0KGluZGV4KTtcXG4gICAgfVxcbiAgXCI7XG59XG5mdW5jdGlvbiBnZXRTYW1wbGVyMkQoaW5wdXRJbmZvKSB7XG4gICAgdmFyIHNoYXBlID0gaW5wdXRJbmZvLnNoYXBlSW5mby5sb2dpY2FsU2hhcGU7XG4gICAgdmFyIHRleFNoYXBlID0gaW5wdXRJbmZvLnNoYXBlSW5mby50ZXhTaGFwZTtcbiAgICB2YXIgdGV4TmFtZSA9IGlucHV0SW5mby5uYW1lO1xuICAgIHZhciBmdW5jTmFtZSA9ICdnZXQnICsgdGV4TmFtZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHRleE5hbWUuc2xpY2UoMSk7XG4gICAgdmFyIHRleE51bVIgPSB0ZXhTaGFwZVswXTtcbiAgICB2YXIgdGV4TnVtQyA9IHRleFNoYXBlWzFdO1xuICAgIGlmICh1dGlsLmFycmF5c0VxdWFsKHNoYXBlLCB0ZXhTaGFwZSkpIHtcbiAgICAgICAgcmV0dXJuIFwiXFxuICAgIGZsb2F0IFwiICsgZnVuY05hbWUgKyBcIihpbnQgcm93LCBpbnQgY29sKSB7XFxuICAgICAgdmVjMiB1diA9ICh2ZWMyKGNvbCwgcm93KSArIGhhbGZDUikgLyB2ZWMyKFwiICsgdGV4TnVtQyArIFwiLjAsIFwiICsgdGV4TnVtUiArIFwiLjApO1xcbiAgICAgIHJldHVybiBzYW1wbGUoXCIgKyB0ZXhOYW1lICsgXCIsIHV2KTtcXG4gICAgfVxcbiAgXCI7XG4gICAgfVxuICAgIHZhciBfYSA9IHV0aWwuc3F1ZWV6ZVNoYXBlKHNoYXBlKSwgbmV3U2hhcGUgPSBfYS5uZXdTaGFwZSwga2VwdERpbXMgPSBfYS5rZXB0RGltcztcbiAgICB2YXIgc3F1ZWV6ZWRTaGFwZSA9IG5ld1NoYXBlO1xuICAgIGlmIChzcXVlZXplZFNoYXBlLmxlbmd0aCA8IHNoYXBlLmxlbmd0aCkge1xuICAgICAgICB2YXIgbmV3SW5wdXRJbmZvID0gc3F1ZWV6ZUlucHV0SW5mbyhpbnB1dEluZm8sIHNxdWVlemVkU2hhcGUpO1xuICAgICAgICB2YXIgcGFyYW1zID0gWydyb3cnLCAnY29sJ107XG4gICAgICAgIHJldHVybiBcIlxcbiAgICAgIFwiICsgZ2V0U2FtcGxlckZyb21JbkluZm8obmV3SW5wdXRJbmZvKSArIFwiXFxuICAgICAgZmxvYXQgXCIgKyBmdW5jTmFtZSArIFwiKGludCByb3csIGludCBjb2wpIHtcXG4gICAgICAgIHJldHVybiBcIiArIGZ1bmNOYW1lICsgXCIoXCIgKyBnZXRTcXVlZXplZFBhcmFtcyhwYXJhbXMsIGtlcHREaW1zKSArIFwiKTtcXG4gICAgICB9XFxuICAgIFwiO1xuICAgIH1cbiAgICBpZiAodGV4TnVtQyA9PT0gMSkge1xuICAgICAgICByZXR1cm4gXCJcXG4gICAgZmxvYXQgXCIgKyBmdW5jTmFtZSArIFwiKGludCByb3csIGludCBjb2wpIHtcXG4gICAgICBpbnQgaW5kZXggPSByb3cgKiBcIiArIHNoYXBlWzFdICsgXCIgKyBjb2w7XFxuICAgICAgdmVjMiB1diA9IHZlYzIoMC41LCAoZmxvYXQoaW5kZXgpICsgMC41KSAvIFwiICsgdGV4TnVtUiArIFwiLjApO1xcbiAgICAgIHJldHVybiBzYW1wbGUoXCIgKyB0ZXhOYW1lICsgXCIsIHV2KTtcXG4gICAgfVxcbiAgXCI7XG4gICAgfVxuICAgIGlmICh0ZXhOdW1SID09PSAxKSB7XG4gICAgICAgIHJldHVybiBcIlxcbiAgICBmbG9hdCBcIiArIGZ1bmNOYW1lICsgXCIoaW50IHJvdywgaW50IGNvbCkge1xcbiAgICAgIGludCBpbmRleCA9IHJvdyAqIFwiICsgc2hhcGVbMV0gKyBcIiArIGNvbDtcXG4gICAgICB2ZWMyIHV2ID0gdmVjMigoZmxvYXQoaW5kZXgpICsgMC41KSAvIFwiICsgdGV4TnVtQyArIFwiLjAsIDAuNSk7XFxuICAgICAgcmV0dXJuIHNhbXBsZShcIiArIHRleE5hbWUgKyBcIiwgdXYpO1xcbiAgICB9XFxuICBcIjtcbiAgICB9XG4gICAgcmV0dXJuIFwiXFxuICBmbG9hdCBcIiArIGZ1bmNOYW1lICsgXCIoaW50IHJvdywgaW50IGNvbCkge1xcbiAgICB2ZWMyIHV2ID0gVVZmcm9tMkQoXCIgKyB0ZXhOdW1SICsgXCIsIFwiICsgdGV4TnVtQyArIFwiLCBcIiArIHNoYXBlWzFdICsgXCIsIHJvdywgY29sKTtcXG4gICAgcmV0dXJuIHNhbXBsZShcIiArIHRleE5hbWUgKyBcIiwgdXYpO1xcbiAgfVxcblwiO1xufVxuZnVuY3Rpb24gZ2V0U2FtcGxlcjNEKGlucHV0SW5mbykge1xuICAgIHZhciB0ZXhTaGFwZSA9IGlucHV0SW5mby5zaGFwZUluZm8udGV4U2hhcGU7XG4gICAgdmFyIHNoYXBlID0gaW5wdXRJbmZvLnNoYXBlSW5mby5sb2dpY2FsU2hhcGU7XG4gICAgdmFyIHRleE5hbWUgPSBpbnB1dEluZm8ubmFtZTtcbiAgICB2YXIgZnVuY05hbWUgPSAnZ2V0JyArIHRleE5hbWUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyB0ZXhOYW1lLnNsaWNlKDEpO1xuICAgIHZhciB0ZXhOdW1SID0gdGV4U2hhcGVbMF07XG4gICAgdmFyIHRleE51bUMgPSB0ZXhTaGFwZVsxXTtcbiAgICB2YXIgc3RyaWRlMCA9IHNoYXBlWzFdICogc2hhcGVbMl07XG4gICAgdmFyIHN0cmlkZTEgPSBzaGFwZVsyXTtcbiAgICB2YXIgdGV4VHlwZSA9IGlucHV0SW5mby5zaGFwZUluZm8udGV4dHVyZVR5cGU7XG4gICAgaWYgKHRleFR5cGUgPT09IHRleF91dGlsXzEuVGV4dHVyZVR5cGUuREVGQVVMVCkge1xuICAgICAgICB2YXIgX2EgPSB1dGlsLnNxdWVlemVTaGFwZShzaGFwZSksIG5ld1NoYXBlID0gX2EubmV3U2hhcGUsIGtlcHREaW1zID0gX2Eua2VwdERpbXM7XG4gICAgICAgIHZhciBzcXVlZXplZFNoYXBlID0gbmV3U2hhcGU7XG4gICAgICAgIGlmIChzcXVlZXplZFNoYXBlLmxlbmd0aCA8IHNoYXBlLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIG5ld0lucHV0SW5mbyA9IHNxdWVlemVJbnB1dEluZm8oaW5wdXRJbmZvLCBzcXVlZXplZFNoYXBlKTtcbiAgICAgICAgICAgIHZhciBwYXJhbXMgPSBbJ3JvdycsICdjb2wnLCAnZGVwdGgnXTtcbiAgICAgICAgICAgIHJldHVybiBcIlxcbiAgICAgICAgXCIgKyBnZXRTYW1wbGVyRnJvbUluSW5mbyhuZXdJbnB1dEluZm8pICsgXCJcXG4gICAgICAgIGZsb2F0IFwiICsgZnVuY05hbWUgKyBcIihpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgpIHtcXG4gICAgICAgICAgcmV0dXJuIFwiICsgZnVuY05hbWUgKyBcIihcIiArIGdldFNxdWVlemVkUGFyYW1zKHBhcmFtcywga2VwdERpbXMpICsgXCIpO1xcbiAgICAgICAgfVxcbiAgICAgIFwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICh0ZXhOdW1DID09PSBzdHJpZGUwKSB7XG4gICAgICAgIGlmICh0ZXhUeXBlID09PSB0ZXhfdXRpbF8xLlRleHR1cmVUeXBlLkRFRkFVTFQpIHtcbiAgICAgICAgICAgIHJldHVybiBcIlxcbiAgICAgICAgZmxvYXQgXCIgKyBmdW5jTmFtZSArIFwiKGludCByb3csIGludCBjb2wsIGludCBkZXB0aCkge1xcbiAgICAgICAgICBpbnQgdGV4UiA9IHJvdztcXG4gICAgICAgICAgaW50IHRleEMgPSBjb2wgKiBcIiArIHN0cmlkZTEgKyBcIiArIGRlcHRoO1xcbiAgICAgICAgICB2ZWMyIHV2ID0gKHZlYzIodGV4QywgdGV4UikgKyBoYWxmQ1IpIC9cXG4gICAgICAgICAgICAgICAgICAgICB2ZWMyKFwiICsgdGV4TnVtQyArIFwiLjAsIFwiICsgdGV4TnVtUiArIFwiLjApO1xcbiAgICAgICAgICByZXR1cm4gc2FtcGxlKFwiICsgdGV4TmFtZSArIFwiLCB1dik7XFxuICAgICAgICB9XFxuICAgICAgXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGV4VHlwZSA9PT0gdGV4X3V0aWxfMS5UZXh0dXJlVHlwZS5SR0JBX0NPTE9SKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJcXG4gICAgICAgIGZsb2F0IFwiICsgZnVuY05hbWUgKyBcIihpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgpIHtcXG4gICAgICAgICAgdmVjMiB1diA9ICh2ZWMyKGNvbCwgcm93KSArIGhhbGZDUikgL1xcbiAgICAgICAgICAgICAgICAgICAgIHZlYzIoXCIgKyB0ZXhOdW1DICsgXCIuMCwgXCIgKyB0ZXhOdW1SICsgXCIuMCk7XFxuICAgICAgICAgIHJldHVybiBzYW1wbGVVVkFuZERlcHRoKFwiICsgdGV4TmFtZSArIFwiLCB1diwgZGVwdGgpO1xcbiAgICAgICAgfVxcbiAgICAgIFwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBUZXh0dXJlVHlwZSBcIiArIHRleFR5cGUgKyBcIi5cIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRleE51bUMgPT09IHN0cmlkZTEgJiYgdGV4VHlwZSA9PT0gdGV4X3V0aWxfMS5UZXh0dXJlVHlwZS5ERUZBVUxUKSB7XG4gICAgICAgIHJldHVybiBcIlxcbiAgICBmbG9hdCBcIiArIGZ1bmNOYW1lICsgXCIoaW50IHJvdywgaW50IGNvbCwgaW50IGRlcHRoKSB7XFxuICAgICAgaW50IHRleFIgPSByb3cgKiBcIiArIHNoYXBlWzFdICsgXCIgKyBjb2w7XFxuICAgICAgaW50IHRleEMgPSBkZXB0aDtcXG4gICAgICB2ZWMyIHV2ID0gKHZlYzIodGV4QywgdGV4UikgKyBoYWxmQ1IpIC8gdmVjMihcIiArIHRleE51bUMgKyBcIi4wLCBcIiArIHRleE51bVIgKyBcIi4wKTtcXG4gICAgICByZXR1cm4gc2FtcGxlKFwiICsgdGV4TmFtZSArIFwiLCB1dik7XFxuICAgIH1cXG4gIFwiO1xuICAgIH1cbiAgICBpZiAodGV4VHlwZSA9PT0gdGV4X3V0aWxfMS5UZXh0dXJlVHlwZS5ERUZBVUxUKSB7XG4gICAgICAgIHJldHVybiBcIlxcbiAgICAgIGZsb2F0IFwiICsgZnVuY05hbWUgKyBcIihpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgpIHtcXG4gICAgICAgIHZlYzIgdXYgPSBVVmZyb20zRChcXG4gICAgICAgICAgICBcIiArIHRleE51bVIgKyBcIiwgXCIgKyB0ZXhOdW1DICsgXCIsIFwiICsgc3RyaWRlMCArIFwiLCBcIiArIHN0cmlkZTEgKyBcIiwgcm93LCBjb2wsIGRlcHRoKTtcXG4gICAgICAgIHJldHVybiBzYW1wbGUoXCIgKyB0ZXhOYW1lICsgXCIsIHV2KTtcXG4gICAgICB9XFxuICBcIjtcbiAgICB9XG4gICAgZWxzZSBpZiAodGV4VHlwZSA9PT0gdGV4X3V0aWxfMS5UZXh0dXJlVHlwZS5SR0JBX0NPTE9SKSB7XG4gICAgICAgIHJldHVybiBcIlxcbiAgICAgIGZsb2F0IFwiICsgZnVuY05hbWUgKyBcIihpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgpIHtcXG4gICAgICAgIHZlYzIgdXYgPSBVVmZyb20yRChcIiArIHRleE51bVIgKyBcIiwgXCIgKyB0ZXhOdW1DICsgXCIsIFwiICsgc2hhcGVbMV0gKyBcIiwgcm93LCBjb2wpO1xcbiAgICAgICAgcmV0dXJuIHNhbXBsZVVWQW5kRGVwdGgoXCIgKyB0ZXhOYW1lICsgXCIsIHV2LCBkZXB0aCk7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gVGV4dHVyZVR5cGUgXCIgKyB0ZXhUeXBlICsgXCIuXCIpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldFNhbXBsZXI0RChpbnB1dEluZm8pIHtcbiAgICB2YXIgc2hhcGUgPSBpbnB1dEluZm8uc2hhcGVJbmZvLmxvZ2ljYWxTaGFwZTtcbiAgICB2YXIgdGV4U2hhcGUgPSBpbnB1dEluZm8uc2hhcGVJbmZvLnRleFNoYXBlO1xuICAgIHZhciB0ZXhOYW1lID0gaW5wdXRJbmZvLm5hbWU7XG4gICAgdmFyIGZ1bmNOYW1lID0gJ2dldCcgKyB0ZXhOYW1lLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgdGV4TmFtZS5zbGljZSgxKTtcbiAgICB2YXIgdGV4TnVtUiA9IHRleFNoYXBlWzBdO1xuICAgIHZhciB0ZXhOdW1DID0gdGV4U2hhcGVbMV07XG4gICAgdmFyIHN0cmlkZTIgPSBzaGFwZVszXTtcbiAgICB2YXIgc3RyaWRlMSA9IHNoYXBlWzJdICogc3RyaWRlMjtcbiAgICB2YXIgc3RyaWRlMCA9IHNoYXBlWzFdICogc3RyaWRlMTtcbiAgICB2YXIgX2EgPSB1dGlsLnNxdWVlemVTaGFwZShzaGFwZSksIG5ld1NoYXBlID0gX2EubmV3U2hhcGUsIGtlcHREaW1zID0gX2Eua2VwdERpbXM7XG4gICAgaWYgKG5ld1NoYXBlLmxlbmd0aCA8IHNoYXBlLmxlbmd0aCkge1xuICAgICAgICB2YXIgbmV3SW5wdXRJbmZvID0gc3F1ZWV6ZUlucHV0SW5mbyhpbnB1dEluZm8sIG5ld1NoYXBlKTtcbiAgICAgICAgdmFyIHBhcmFtcyA9IFsncm93JywgJ2NvbCcsICdkZXB0aCcsICdkZXB0aDInXTtcbiAgICAgICAgcmV0dXJuIFwiXFxuICAgICAgXCIgKyBnZXRTYW1wbGVyRnJvbUluSW5mbyhuZXdJbnB1dEluZm8pICsgXCJcXG4gICAgICBmbG9hdCBcIiArIGZ1bmNOYW1lICsgXCIoaW50IHJvdywgaW50IGNvbCwgaW50IGRlcHRoLCBpbnQgZGVwdGgyKSB7XFxuICAgICAgICByZXR1cm4gXCIgKyBmdW5jTmFtZSArIFwiKFwiICsgZ2V0U3F1ZWV6ZWRQYXJhbXMocGFyYW1zLCBrZXB0RGltcykgKyBcIik7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgaWYgKHRleE51bUMgPT09IHN0cmlkZTApIHtcbiAgICAgICAgcmV0dXJuIFwiXFxuICAgICAgZmxvYXQgXCIgKyBmdW5jTmFtZSArIFwiKGludCByb3csIGludCBjb2wsIGludCBkZXB0aCwgaW50IGRlcHRoMikge1xcbiAgICAgICAgaW50IHRleFIgPSByb3c7XFxuICAgICAgICBpbnQgdGV4QyA9IGNvbCAqIFwiICsgc3RyaWRlMSArIFwiICsgZGVwdGggKiBcIiArIHN0cmlkZTIgKyBcIiArIGRlcHRoMjtcXG4gICAgICAgIHZlYzIgdXYgPSAodmVjMih0ZXhDLCB0ZXhSKSArIGhhbGZDUikgL1xcbiAgICAgICAgICAgICAgICAgICB2ZWMyKFwiICsgdGV4TnVtQyArIFwiLjAsIFwiICsgdGV4TnVtUiArIFwiLjApO1xcbiAgICAgICAgcmV0dXJuIHNhbXBsZShcIiArIHRleE5hbWUgKyBcIiwgdXYpO1xcbiAgICAgIH1cXG4gICAgXCI7XG4gICAgfVxuICAgIGlmICh0ZXhOdW1DID09PSBzdHJpZGUyKSB7XG4gICAgICAgIHJldHVybiBcIlxcbiAgICAgIGZsb2F0IFwiICsgZnVuY05hbWUgKyBcIihpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgsIGludCBkZXB0aDIpIHtcXG4gICAgICAgIGludCB0ZXhSID0gcm93ICogXCIgKyBzaGFwZVsxXSAqIHNoYXBlWzJdICsgXCIgKyBjb2wgKiBcIiArIHNoYXBlWzJdICsgXCIgKyBkZXB0aDtcXG4gICAgICAgIGludCB0ZXhDID0gZGVwdGgyO1xcbiAgICAgICAgdmVjMiB1diA9ICh2ZWMyKHRleEMsIHRleFIpICsgaGFsZkNSKSAvXFxuICAgICAgICAgICAgICAgICAgdmVjMihcIiArIHRleE51bUMgKyBcIi4wLCBcIiArIHRleE51bVIgKyBcIi4wKTtcXG4gICAgICAgIHJldHVybiBzYW1wbGUoXCIgKyB0ZXhOYW1lICsgXCIsIHV2KTtcXG4gICAgICB9XFxuICAgIFwiO1xuICAgIH1cbiAgICByZXR1cm4gXCJcXG4gICAgZmxvYXQgXCIgKyBmdW5jTmFtZSArIFwiKGludCByb3csIGludCBjb2wsIGludCBkZXB0aCwgaW50IGRlcHRoMikge1xcbiAgICAgIHZlYzIgdXYgPSBVVmZyb200RChcIiArIHRleE51bVIgKyBcIiwgXCIgKyB0ZXhOdW1DICsgXCIsIFwiICsgc3RyaWRlMCArIFwiLCBcIiArIHN0cmlkZTEgKyBcIixcXG4gICAgICAgICAgXCIgKyBzdHJpZGUyICsgXCIsIHJvdywgY29sLCBkZXB0aCwgZGVwdGgyKTtcXG4gICAgICByZXR1cm4gc2FtcGxlKFwiICsgdGV4TmFtZSArIFwiLCB1dik7XFxuICAgIH1cXG4gIFwiO1xufVxuZnVuY3Rpb24gZ2V0U2FtcGxlckZsYXQoaW5wdXRJbmZvKSB7XG4gICAgdmFyIHRleE5hbWUgPSBpbnB1dEluZm8ubmFtZTtcbiAgICB2YXIgdGV4U2hhcGUgPSBpbnB1dEluZm8uc2hhcGVJbmZvLnRleFNoYXBlO1xuICAgIHZhciBmdW5jTmFtZSA9ICdnZXQnICsgdGV4TmFtZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHRleE5hbWUuc2xpY2UoMSkgKyAnRmxhdCc7XG4gICAgdmFyIHROdW1SID0gdGV4U2hhcGVbMF07XG4gICAgdmFyIHROdW1DID0gdGV4U2hhcGVbMV07XG4gICAgaWYgKHROdW1DID09PSAxICYmIHROdW1SID09PSAxKSB7XG4gICAgICAgIHJldHVybiBcIlxcbiAgICAgIGZsb2F0IFwiICsgZnVuY05hbWUgKyBcIihpbnQgaW5kZXgpIHtcXG4gICAgICAgIHJldHVybiBzYW1wbGUoXCIgKyB0ZXhOYW1lICsgXCIsIGhhbGZDUik7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgaWYgKHROdW1DID09PSAxKSB7XG4gICAgICAgIHJldHVybiBcIlxcbiAgICAgIGZsb2F0IFwiICsgZnVuY05hbWUgKyBcIihpbnQgaW5kZXgpIHtcXG4gICAgICAgIHZlYzIgdXYgPSB2ZWMyKDAuNSwgKGZsb2F0KGluZGV4KSArIDAuNSkgLyBcIiArIHROdW1SICsgXCIuMCk7XFxuICAgICAgICByZXR1cm4gc2FtcGxlKFwiICsgdGV4TmFtZSArIFwiLCB1dik7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgaWYgKHROdW1SID09PSAxKSB7XG4gICAgICAgIHJldHVybiBcIlxcbiAgICAgIGZsb2F0IFwiICsgZnVuY05hbWUgKyBcIihpbnQgaW5kZXgpIHtcXG4gICAgICAgIHZlYzIgdXYgPSB2ZWMyKChmbG9hdChpbmRleCkgKyAwLjUpIC8gXCIgKyB0TnVtQyArIFwiLjAsIDAuNSk7XFxuICAgICAgICByZXR1cm4gc2FtcGxlKFwiICsgdGV4TmFtZSArIFwiLCB1dik7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgcmV0dXJuIFwiXFxuICAgIGZsb2F0IFwiICsgZnVuY05hbWUgKyBcIihpbnQgaW5kZXgpIHtcXG4gICAgICB2ZWMyIHV2ID0gVVZmcm9tMUQoXCIgKyB0TnVtUiArIFwiLCBcIiArIHROdW1DICsgXCIsIGluZGV4KTtcXG4gICAgICByZXR1cm4gc2FtcGxlKFwiICsgdGV4TmFtZSArIFwiLCB1dik7XFxuICAgIH1cXG4gIFwiO1xufVxuZnVuY3Rpb24gZ2V0QnJvYWRjYXN0T3V0cHV0Q29vcmRzU2FtcGxlcihpbnB1dEluZm8sIG91dFNoYXBlSW5mbywgdGV4RnVuY1NuaXBwZXQsIGZ1bmNOYW1lKSB7XG4gICAgdmFyIGluUmFuayA9IGlucHV0SW5mby5zaGFwZUluZm8ubG9naWNhbFNoYXBlLmxlbmd0aDtcbiAgICB2YXIgb3V0UmFuayA9IG91dFNoYXBlSW5mby5sb2dpY2FsU2hhcGUubGVuZ3RoO1xuICAgIHZhciB0eXBlID0gJ2ludCc7XG4gICAgaWYgKG91dFJhbmsgPT09IDIpIHtcbiAgICAgICAgdHlwZSA9ICdpdmVjMic7XG4gICAgfVxuICAgIGVsc2UgaWYgKG91dFJhbmsgPT09IDMpIHtcbiAgICAgICAgdHlwZSA9ICdpdmVjMyc7XG4gICAgfVxuICAgIGVsc2UgaWYgKG91dFJhbmsgPT09IDQpIHtcbiAgICAgICAgdHlwZSA9ICdpdmVjNCc7XG4gICAgfVxuICAgIHZhciBicm9hZGNhc3REaW1zID0gYnJvYWRjYXN0X3V0aWwuZ2V0QnJvYWRjYXN0RGltcyhpbnB1dEluZm8uc2hhcGVJbmZvLmxvZ2ljYWxTaGFwZSwgb3V0U2hhcGVJbmZvLmxvZ2ljYWxTaGFwZSk7XG4gICAgdmFyIHJhbmtEaWZmID0gb3V0UmFuayAtIGluUmFuaztcbiAgICB2YXIgY29vcmRzU25pcHBldDtcbiAgICBpZiAoaW5SYW5rID09PSAwKSB7XG4gICAgICAgIGNvb3Jkc1NuaXBwZXQgPSAnJztcbiAgICB9XG4gICAgZWxzZSBpZiAob3V0UmFuayA8IDIgJiYgYnJvYWRjYXN0RGltcy5sZW5ndGggPj0gMSkge1xuICAgICAgICBjb29yZHNTbmlwcGV0ID0gJ2Nvb3JkcyA9IDA7JztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvb3Jkc1NuaXBwZXQgPVxuICAgICAgICAgICAgYnJvYWRjYXN0RGltcy5tYXAoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIFwiY29vcmRzW1wiICsgKGQgKyByYW5rRGlmZikgKyBcIl0gPSAwO1wiOyB9KS5qb2luKCdcXG4nKTtcbiAgICB9XG4gICAgdmFyIHVucGFja2VkQ29vcmRzU25pcHBldCA9ICcnO1xuICAgIGlmIChvdXRSYW5rIDwgMiAmJiBpblJhbmsgPiAwKSB7XG4gICAgICAgIHVucGFja2VkQ29vcmRzU25pcHBldCA9ICdjb29yZHMnO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdW5wYWNrZWRDb29yZHNTbmlwcGV0ID0gaW5wdXRJbmZvLnNoYXBlSW5mby5sb2dpY2FsU2hhcGVcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKHMsIGkpIHsgcmV0dXJuIFwiY29vcmRzW1wiICsgKGkgKyByYW5rRGlmZikgKyBcIl1cIjsgfSlcbiAgICAgICAgICAgIC5qb2luKCcsICcpO1xuICAgIH1cbiAgICByZXR1cm4gXCJcXG4gICAgZmxvYXQgXCIgKyBmdW5jTmFtZSArIFwiKCkge1xcbiAgICAgIFwiICsgdHlwZSArIFwiIGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgIFwiICsgY29vcmRzU25pcHBldCArIFwiXFxuICAgICAgcmV0dXJuIGdldFwiICsgdGV4RnVuY1NuaXBwZXQgKyBcIihcIiArIHVucGFja2VkQ29vcmRzU25pcHBldCArIFwiKTtcXG4gICAgfVxcbiAgXCI7XG59XG5mdW5jdGlvbiBnZXRTYW1wbGVyQXRPdXRwdXRDb29yZHMoaW5wdXRJbmZvLCBvdXRTaGFwZUluZm8sIHN1cHBvcnRzQnJvYWRjYXN0aW5nKSB7XG4gICAgdmFyIGluVGV4U2hhcGUgPSBpbnB1dEluZm8uc2hhcGVJbmZvLnRleFNoYXBlO1xuICAgIHZhciB0ZXhOYW1lID0gaW5wdXRJbmZvLm5hbWU7XG4gICAgdmFyIGlzUkdCQUNvbG9yVGV4dHVyZSA9IGlucHV0SW5mby5zaGFwZUluZm8udGV4dHVyZVR5cGUgPT09IHRleF91dGlsXzEuVGV4dHVyZVR5cGUuUkdCQV9DT0xPUjtcbiAgICB2YXIgdGV4RnVuY1NuaXBwZXQgPSB0ZXhOYW1lLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgdGV4TmFtZS5zbGljZSgxKTtcbiAgICB2YXIgZnVuY05hbWUgPSAnZ2V0JyArIHRleEZ1bmNTbmlwcGV0ICsgJ0F0T3V0Q29vcmRzJztcbiAgICB2YXIgYnJvYWRjYXN0RGltcyA9IGJyb2FkY2FzdF91dGlsLmdldEJyb2FkY2FzdERpbXMoaW5wdXRJbmZvLnNoYXBlSW5mby5sb2dpY2FsU2hhcGUsIG91dFNoYXBlSW5mby5sb2dpY2FsU2hhcGUpO1xuICAgIHZhciBpblJhbmsgPSBpbnB1dEluZm8uc2hhcGVJbmZvLmxvZ2ljYWxTaGFwZS5sZW5ndGg7XG4gICAgdmFyIG91dFJhbmsgPSBvdXRTaGFwZUluZm8ubG9naWNhbFNoYXBlLmxlbmd0aDtcbiAgICB2YXIgZG9Ccm9hZGNhc3QgPSBzdXBwb3J0c0Jyb2FkY2FzdGluZyAmJiAoKG91dFJhbmsgPiBpblJhbmspIHx8IGJyb2FkY2FzdERpbXMubGVuZ3RoID4gMCk7XG4gICAgdmFyIGJyb2FkY2FzdE92ZXJPdXRlciA9IGJyb2FkY2FzdF91dGlsLmJyb2FkY2FzdERpbXNBcmVPdXRlcihicm9hZGNhc3REaW1zKTtcbiAgICBpZiAoZG9Ccm9hZGNhc3QgJiYgIWJyb2FkY2FzdE92ZXJPdXRlcikge1xuICAgICAgICByZXR1cm4gZ2V0QnJvYWRjYXN0T3V0cHV0Q29vcmRzU2FtcGxlcihpbnB1dEluZm8sIG91dFNoYXBlSW5mbywgdGV4RnVuY1NuaXBwZXQsIGZ1bmNOYW1lKTtcbiAgICB9XG4gICAgdmFyIG91dFRleFNoYXBlID0gb3V0U2hhcGVJbmZvLnRleFNoYXBlO1xuICAgIGlmICh1dGlsLmFycmF5c0VxdWFsKGluVGV4U2hhcGUsIG91dFRleFNoYXBlKSAmJiAhaXNSR0JBQ29sb3JUZXh0dXJlKSB7XG4gICAgICAgIHJldHVybiBcIlxcbiAgICAgIGZsb2F0IFwiICsgZnVuY05hbWUgKyBcIigpIHtcXG4gICAgICAgIHJldHVybiBzYW1wbGUoXCIgKyB0ZXhOYW1lICsgXCIsIHJlc3VsdFVWKTtcXG4gICAgICB9XFxuICAgIFwiO1xuICAgIH1cbiAgICB2YXIgaW5UZXhFeHBhbmRlZFNoYXBlID0gaXNSR0JBQ29sb3JUZXh0dXJlID9cbiAgICAgICAgW2luVGV4U2hhcGVbMF0sIGluVGV4U2hhcGVbMV0gKiBpbnB1dEluZm8uc2hhcGVJbmZvLmxvZ2ljYWxTaGFwZVsyXV0gOlxuICAgICAgICBpblRleFNoYXBlO1xuICAgIHZhciBzYW1wbGVTbmlwcGV0ID0gXCJyZXR1cm4gc2FtcGxlKFwiICsgdGV4TmFtZSArIFwiLCB1dik7XCI7XG4gICAgdmFyIHJnYmFDb2xvclNuaXBwZXQgPSAnJztcbiAgICBpZiAoaXNSR0JBQ29sb3JUZXh0dXJlKSB7XG4gICAgICAgIHJnYmFDb2xvclNuaXBwZXQgPSBcIlxcbiAgICAgIGludCBjb2wgPSB0ZXhDIC8gXCIgKyBpbnB1dEluZm8uc2hhcGVJbmZvLmxvZ2ljYWxTaGFwZVsyXSArIFwiO1xcbiAgICAgIGludCB0ZXhEID0gdGV4QyAtIGNvbCAqIFwiICsgaW5wdXRJbmZvLnNoYXBlSW5mby5sb2dpY2FsU2hhcGVbMl0gKyBcIjtcXG4gICAgICB0ZXhDID0gY29sO1xcbiAgICBcIjtcbiAgICAgICAgc2FtcGxlU25pcHBldCA9IFwicmV0dXJuIHNhbXBsZVVWQW5kRGVwdGgoXCIgKyB0ZXhOYW1lICsgXCIsIHV2LCB0ZXhEKTtcIjtcbiAgICB9XG4gICAgdmFyIGluU2l6ZSA9IHV0aWwuc2l6ZUZyb21TaGFwZShpblRleEV4cGFuZGVkU2hhcGUpO1xuICAgIHZhciBicm9hZGNhc3RTbmlwcGV0ID0gJyc7XG4gICAgaWYgKGRvQnJvYWRjYXN0ICYmIGJyb2FkY2FzdE92ZXJPdXRlcikge1xuICAgICAgICBicm9hZGNhc3RTbmlwcGV0ID0gXCJcXG4gICAgICAgIGludCBtYWluUGFydCA9IGluZGV4IC8gXCIgKyBpblNpemUgKyBcIjtcXG4gICAgICAgIGluZGV4IC09IG1haW5QYXJ0ICogXCIgKyBpblNpemUgKyBcIjtcXG4gICAgICBcIjtcbiAgICB9XG4gICAgcmV0dXJuIFwiXFxuICAgIGZsb2F0IFwiICsgZnVuY05hbWUgKyBcIigpIHtcXG4gICAgICBpdmVjMiByZXNUZXhSQyA9IGl2ZWMyKHJlc3VsdFVWLnl4ICpcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIoXCIgKyBvdXRUZXhTaGFwZVswXSArIFwiLCBcIiArIG91dFRleFNoYXBlWzFdICsgXCIpKTtcXG4gICAgICBpbnQgaW5kZXggPSByZXNUZXhSQy54ICogXCIgKyBvdXRUZXhTaGFwZVsxXSArIFwiICsgcmVzVGV4UkMueTtcXG4gICAgICBcIiArIGJyb2FkY2FzdFNuaXBwZXQgKyBcIlxcbiAgICAgIGludCB0ZXhSID0gaW5kZXggLyBcIiArIGluVGV4RXhwYW5kZWRTaGFwZVsxXSArIFwiO1xcbiAgICAgIGludCB0ZXhDID0gaW5kZXggLSB0ZXhSICogXCIgKyBpblRleEV4cGFuZGVkU2hhcGVbMV0gKyBcIjtcXG5cXG4gICAgICBcIiArIHJnYmFDb2xvclNuaXBwZXQgKyBcIlxcblxcbiAgICAgIHZlYzIgdXYgPSAodmVjMih0ZXhDLCB0ZXhSKSArIGhhbGZDUikgL1xcbiAgICAgICAgICAgICAgICAgdmVjMihcIiArIGluVGV4U2hhcGVbMV0gKyBcIi4wLCBcIiArIGluVGV4U2hhcGVbMF0gKyBcIi4wKTtcXG5cXG4gICAgICBcIiArIHNhbXBsZVNuaXBwZXQgKyBcIlxcbiAgICB9XFxuICBcIjtcbn1cbmZ1bmN0aW9uIGdldENvb3Jkc0RhdGFUeXBlKHJhbmspIHtcbiAgICBpZiAocmFuayA9PT0gMSkge1xuICAgICAgICByZXR1cm4gJ2ludCc7XG4gICAgfVxuICAgIGVsc2UgaWYgKHJhbmsgPT09IDIpIHtcbiAgICAgICAgcmV0dXJuICdpdmVjMic7XG4gICAgfVxuICAgIGVsc2UgaWYgKHJhbmsgPT09IDMpIHtcbiAgICAgICAgcmV0dXJuICdpdmVjMyc7XG4gICAgfVxuICAgIGVsc2UgaWYgKHJhbmsgPT09IDQpIHtcbiAgICAgICAgcmV0dXJuICdpdmVjNCc7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBFcnJvcihcIkdQVSBmb3IgcmFuayBcIiArIHJhbmsgKyBcIiBpcyBub3QgeWV0IHN1cHBvcnRlZFwiKTtcbiAgICB9XG59XG5leHBvcnRzLmdldENvb3Jkc0RhdGFUeXBlID0gZ2V0Q29vcmRzRGF0YVR5cGU7XG5mdW5jdGlvbiBzcXVlZXplSW5wdXRJbmZvKGluSW5mbywgc3F1ZWV6ZWRTaGFwZSkge1xuICAgIHZhciBuZXdJbnB1dEluZm8gPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGluSW5mbykpO1xuICAgIG5ld0lucHV0SW5mby5zaGFwZUluZm8ubG9naWNhbFNoYXBlID0gc3F1ZWV6ZWRTaGFwZTtcbiAgICByZXR1cm4gbmV3SW5wdXRJbmZvO1xufVxuZnVuY3Rpb24gZ2V0U3F1ZWV6ZWRQYXJhbXMocGFyYW1zLCBrZXB0RGltcykge1xuICAgIHJldHVybiBrZXB0RGltcy5tYXAoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIHBhcmFtc1tkXTsgfSkuam9pbignLCAnKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNoYWRlcl9jb21waWxlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBzaGFkZXJfY29tcGlsZXJfMSA9IHJlcXVpcmUoXCIuL3NoYWRlcl9jb21waWxlclwiKTtcbnZhciBTbGljZVByb2dyYW0gPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNsaWNlUHJvZ3JhbShkZXN0U2l6ZSkge1xuICAgICAgICB0aGlzLnZhcmlhYmxlTmFtZXMgPSBbJ3NvdXJjZSddO1xuICAgICAgICB0aGlzLm91dHB1dFNoYXBlID0gZGVzdFNpemU7XG4gICAgICAgIHRoaXMucmFuayA9IGRlc3RTaXplLmxlbmd0aDtcbiAgICAgICAgdmFyIGR0eXBlID0gc2hhZGVyX2NvbXBpbGVyXzEuZ2V0Q29vcmRzRGF0YVR5cGUodGhpcy5yYW5rKTtcbiAgICAgICAgdmFyIHNvdXJjZUNvb3JkcyA9IGdldENvb3Jkcyh0aGlzLnJhbmspO1xuICAgICAgICB0aGlzLnVzZXJDb2RlID0gXCJcXG4gICAgICB1bmlmb3JtIFwiICsgZHR5cGUgKyBcIiBzdGFydDtcXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBcIiArIGR0eXBlICsgXCIgc291cmNlTG9jID0gc3RhcnQgKyBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIHNldE91dHB1dChnZXRTb3VyY2UoXCIgKyBzb3VyY2VDb29yZHMgKyBcIikpO1xcbiAgICAgIH1cXG4gICAgXCI7XG4gICAgfVxuICAgIFNsaWNlUHJvZ3JhbS5wcm90b3R5cGUuZ2V0Q3VzdG9tU2V0dXBGdW5jID0gZnVuY3Rpb24gKHN0YXJ0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChzdGFydC5sZW5ndGggIT09IHRoaXMucmFuaykge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJUaGUgcmFuayAoXCIgKyB0aGlzLnJhbmsgKyBcIikgb2YgdGhlIHByb2dyYW0gbXVzdCBtYXRjaCB0aGUgXCIgK1xuICAgICAgICAgICAgICAgIChcImxlbmd0aCBvZiBzdGFydCAoXCIgKyBzdGFydC5sZW5ndGggKyBcIilcIikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoZ3BncHUsIHdlYkdMUHJvZ3JhbSkge1xuICAgICAgICAgICAgaWYgKF90aGlzLnN0YXJ0TG9jID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5zdGFydExvYyA9IGdwZ3B1LmdldFVuaWZvcm1Mb2NhdGlvbk5vVGhyb3cod2ViR0xQcm9ncmFtLCAnc3RhcnQnKTtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuc3RhcnRMb2MgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKF90aGlzLnJhbmsgPT09IDEpIHtcbiAgICAgICAgICAgICAgICBncGdwdS5nbC51bmlmb3JtMWkoX3RoaXMuc3RhcnRMb2MsIHN0YXJ0WzBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKF90aGlzLnJhbmsgPT09IDIpIHtcbiAgICAgICAgICAgICAgICBncGdwdS5nbC51bmlmb3JtMmkoX3RoaXMuc3RhcnRMb2MsIHN0YXJ0WzBdLCBzdGFydFsxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChfdGhpcy5yYW5rID09PSAzKSB7XG4gICAgICAgICAgICAgICAgZ3BncHUuZ2wudW5pZm9ybTNpKF90aGlzLnN0YXJ0TG9jLCBzdGFydFswXSwgc3RhcnRbMV0sIHN0YXJ0WzJdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKF90aGlzLnJhbmsgPT09IDQpIHtcbiAgICAgICAgICAgICAgICBncGdwdS5nbC51bmlmb3JtNGkoX3RoaXMuc3RhcnRMb2MsIHN0YXJ0WzBdLCBzdGFydFsxXSwgc3RhcnRbMl0sIHN0YXJ0WzNdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiU2xpY2luZyBmb3IgcmFuayBcIiArIF90aGlzLnJhbmsgKyBcIiBpcyBub3QgeWV0IHN1cHBvcnRlZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9O1xuICAgIHJldHVybiBTbGljZVByb2dyYW07XG59KCkpO1xuZXhwb3J0cy5TbGljZVByb2dyYW0gPSBTbGljZVByb2dyYW07XG5mdW5jdGlvbiBnZXRDb29yZHMocmFuaykge1xuICAgIGlmIChyYW5rID09PSAxKSB7XG4gICAgICAgIHJldHVybiAnc291cmNlTG9jJztcbiAgICB9XG4gICAgZWxzZSBpZiAocmFuayA9PT0gMikge1xuICAgICAgICByZXR1cm4gJ3NvdXJjZUxvYy54LCBzb3VyY2VMb2MueSc7XG4gICAgfVxuICAgIGVsc2UgaWYgKHJhbmsgPT09IDMpIHtcbiAgICAgICAgcmV0dXJuICdzb3VyY2VMb2MueCwgc291cmNlTG9jLnksIHNvdXJjZUxvYy56JztcbiAgICB9XG4gICAgZWxzZSBpZiAocmFuayA9PT0gNCkge1xuICAgICAgICByZXR1cm4gJ3NvdXJjZUxvYy54LCBzb3VyY2VMb2MueSwgc291cmNlTG9jLnosIHNvdXJjZUxvYy53JztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IEVycm9yKFwiU2xpY2luZyBmb3IgcmFuayBcIiArIHJhbmsgKyBcIiBpcyBub3QgeWV0IHN1cHBvcnRlZFwiKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zbGljZV9ncHUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgVGV4dHVyZVR5cGU7XG4oZnVuY3Rpb24gKFRleHR1cmVUeXBlKSB7XG4gICAgVGV4dHVyZVR5cGVbVGV4dHVyZVR5cGVbXCJERUZBVUxUXCJdID0gMF0gPSBcIkRFRkFVTFRcIjtcbiAgICBUZXh0dXJlVHlwZVtUZXh0dXJlVHlwZVtcIlJHQkFfQ09MT1JcIl0gPSAxXSA9IFwiUkdCQV9DT0xPUlwiO1xufSkoVGV4dHVyZVR5cGUgPSBleHBvcnRzLlRleHR1cmVUeXBlIHx8IChleHBvcnRzLlRleHR1cmVUeXBlID0ge30pKTtcbmZ1bmN0aW9uIGdldFVucGFja2VkTWF0cml4VGV4dHVyZVNoYXBlV2lkdGhIZWlnaHQocm93cywgY29sdW1ucykge1xuICAgIHJldHVybiBbY29sdW1ucywgcm93c107XG59XG5leHBvcnRzLmdldFVucGFja2VkTWF0cml4VGV4dHVyZVNoYXBlV2lkdGhIZWlnaHQgPSBnZXRVbnBhY2tlZE1hdHJpeFRleHR1cmVTaGFwZVdpZHRoSGVpZ2h0O1xuZnVuY3Rpb24gZ2V0VW5wYWNrZWRBcnJheVNpemVGcm9tTWF0cml4U2l6ZShtYXRyaXhTaXplLCBjaGFubmVsc1BlclRleHR1cmUpIHtcbiAgICByZXR1cm4gbWF0cml4U2l6ZSAqIGNoYW5uZWxzUGVyVGV4dHVyZTtcbn1cbmV4cG9ydHMuZ2V0VW5wYWNrZWRBcnJheVNpemVGcm9tTWF0cml4U2l6ZSA9IGdldFVucGFja2VkQXJyYXlTaXplRnJvbU1hdHJpeFNpemU7XG5mdW5jdGlvbiBnZXRDb2xvck1hdHJpeFRleHR1cmVTaGFwZVdpZHRoSGVpZ2h0KHJvd3MsIGNvbHVtbnMpIHtcbiAgICByZXR1cm4gW2NvbHVtbnMgKiA0LCByb3dzXTtcbn1cbmV4cG9ydHMuZ2V0Q29sb3JNYXRyaXhUZXh0dXJlU2hhcGVXaWR0aEhlaWdodCA9IGdldENvbG9yTWF0cml4VGV4dHVyZVNoYXBlV2lkdGhIZWlnaHQ7XG5mdW5jdGlvbiBnZXRNYXRyaXhTaXplRnJvbVVucGFja2VkQXJyYXlTaXplKHVucGFja2VkU2l6ZSwgY2hhbm5lbHNQZXJUZXh0dXJlKSB7XG4gICAgaWYgKHVucGFja2VkU2l6ZSAlIGNoYW5uZWxzUGVyVGV4dHVyZSAhPT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bnBhY2tlZFNpemUgKFwiICsgdW5wYWNrZWRTaXplICsgXCIpIG11c3QgYmUgYSBtdWx0aXBsZSBvZiBcIiArXG4gICAgICAgICAgICAoXCJcIiArIGNoYW5uZWxzUGVyVGV4dHVyZSkpO1xuICAgIH1cbiAgICByZXR1cm4gdW5wYWNrZWRTaXplIC8gY2hhbm5lbHNQZXJUZXh0dXJlO1xufVxuZXhwb3J0cy5nZXRNYXRyaXhTaXplRnJvbVVucGFja2VkQXJyYXlTaXplID0gZ2V0TWF0cml4U2l6ZUZyb21VbnBhY2tlZEFycmF5U2l6ZTtcbmZ1bmN0aW9uIGVuY29kZU1hdHJpeFRvVW5wYWNrZWRBcnJheShtYXRyaXgsIHVucGFja2VkQXJyYXksIGNoYW5uZWxzUGVyVGV4dHVyZSkge1xuICAgIHZhciByZXF1aXJlZFNpemUgPSBnZXRVbnBhY2tlZEFycmF5U2l6ZUZyb21NYXRyaXhTaXplKG1hdHJpeC5sZW5ndGgsIGNoYW5uZWxzUGVyVGV4dHVyZSk7XG4gICAgaWYgKHVucGFja2VkQXJyYXkubGVuZ3RoIDwgcmVxdWlyZWRTaXplKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInVucGFja2VkQXJyYXkgbGVuZ3RoIChcIiArIHVucGFja2VkQXJyYXkubGVuZ3RoICsgXCIpIG11c3QgYmUgPj0gXCIgK1xuICAgICAgICAgICAgKFwiXCIgKyByZXF1aXJlZFNpemUpKTtcbiAgICB9XG4gICAgdmFyIGRzdCA9IDA7XG4gICAgZm9yICh2YXIgc3JjID0gMDsgc3JjIDwgbWF0cml4Lmxlbmd0aDsgKytzcmMpIHtcbiAgICAgICAgdW5wYWNrZWRBcnJheVtkc3RdID0gbWF0cml4W3NyY107XG4gICAgICAgIGRzdCArPSBjaGFubmVsc1BlclRleHR1cmU7XG4gICAgfVxufVxuZXhwb3J0cy5lbmNvZGVNYXRyaXhUb1VucGFja2VkQXJyYXkgPSBlbmNvZGVNYXRyaXhUb1VucGFja2VkQXJyYXk7XG5leHBvcnRzLkZMT0FUX01BWCA9IDIwMDAwO1xuZXhwb3J0cy5GTE9BVF9NSU4gPSAtZXhwb3J0cy5GTE9BVF9NQVg7XG52YXIgRkxPQVRfUkFOR0UgPSAoZXhwb3J0cy5GTE9BVF9NQVggLSBleHBvcnRzLkZMT0FUX01JTikgLyAyNTU7XG52YXIgRkxPQVRfREVMVEFTID0gWzEsIDEgLyAyNTUsIDEgLyAoMjU1ICogMjU1KSwgMSAvICgyNTUgKiAyNTUgKiAyNTUpXTtcbnZhciBGTE9BVF9QT1dFUlMgPSBbMSwgMjU1LCAyNTUgKiAyNTVdO1xuZXhwb3J0cy5CWVRFX05BTl9WQUxVRSA9IDA7XG5mdW5jdGlvbiBlbmNvZGVGbG9hdEFycmF5KGZsb2F0QXJyYXkpIHtcbiAgICB2YXIgdWludEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoZmxvYXRBcnJheS5sZW5ndGggKiA0KTtcbiAgICB2YXIgX2xvb3BfMSA9IGZ1bmN0aW9uIChpKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGZsb2F0QXJyYXlbaSAvIDRdO1xuICAgICAgICBpZiAoaXNOYU4odmFsdWUpKSB7XG4gICAgICAgICAgICB1aW50QXJyYXlbaV0gPSBleHBvcnRzLkJZVEVfTkFOX1ZBTFVFO1xuICAgICAgICAgICAgdWludEFycmF5W2kgKyAxXSA9IGV4cG9ydHMuQllURV9OQU5fVkFMVUU7XG4gICAgICAgICAgICB1aW50QXJyYXlbaSArIDJdID0gZXhwb3J0cy5CWVRFX05BTl9WQUxVRTtcbiAgICAgICAgICAgIHVpbnRBcnJheVtpICsgM10gPSBleHBvcnRzLkJZVEVfTkFOX1ZBTFVFO1xuICAgICAgICAgICAgcmV0dXJuIFwiY29udGludWVcIjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbm9ybWFsaXplZFZhbHVlID0gKHZhbHVlIC0gZXhwb3J0cy5GTE9BVF9NSU4pIC8gRkxPQVRfUkFOR0U7XG4gICAgICAgIHZhciBlbmMgPSBGTE9BVF9QT1dFUlMubWFwKGZ1bmN0aW9uIChwb3cpIHsgcmV0dXJuIHBvdyAqIG5vcm1hbGl6ZWRWYWx1ZTsgfSk7XG4gICAgICAgIHZhciBidWNrZXRzID0gZW5jLm1hcChmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIE1hdGguZmxvb3IoKHZhbHVlICUgMSkgKiAyNTUpOyB9KTtcbiAgICAgICAgdWludEFycmF5W2ldID0gTWF0aC5mbG9vcihub3JtYWxpemVkVmFsdWUpO1xuICAgICAgICB1aW50QXJyYXlbaSArIDFdID0gYnVja2V0c1swXTtcbiAgICAgICAgdWludEFycmF5W2kgKyAyXSA9IGJ1Y2tldHNbMV07XG4gICAgICAgIHVpbnRBcnJheVtpICsgM10gPSBidWNrZXRzWzJdO1xuICAgIH07XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB1aW50QXJyYXkubGVuZ3RoOyBpICs9IDQpIHtcbiAgICAgICAgX2xvb3BfMShpKTtcbiAgICB9XG4gICAgcmV0dXJuIHVpbnRBcnJheTtcbn1cbmV4cG9ydHMuZW5jb2RlRmxvYXRBcnJheSA9IGVuY29kZUZsb2F0QXJyYXk7XG5mdW5jdGlvbiBkZWNvZGVUb0Zsb2F0QXJyYXkodWludEFycmF5KSB7XG4gICAgdmFyIGZsb2F0QXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KHVpbnRBcnJheS5sZW5ndGggLyA0KTtcbiAgICB2YXIgX2xvb3BfMiA9IGZ1bmN0aW9uIChpKSB7XG4gICAgICAgIGlmICh1aW50QXJyYXlbaV0gPT09IGV4cG9ydHMuQllURV9OQU5fVkFMVUUgJiZcbiAgICAgICAgICAgIHVpbnRBcnJheVtpICsgMV0gPT09IGV4cG9ydHMuQllURV9OQU5fVkFMVUUgJiZcbiAgICAgICAgICAgIHVpbnRBcnJheVtpICsgMl0gPT09IGV4cG9ydHMuQllURV9OQU5fVkFMVUUgJiZcbiAgICAgICAgICAgIHVpbnRBcnJheVtpICsgM10gPT09IGV4cG9ydHMuQllURV9OQU5fVkFMVUUpIHtcbiAgICAgICAgICAgIGZsb2F0QXJyYXlbaSAvIDRdID0gTmFOO1xuICAgICAgICAgICAgcmV0dXJuIFwiY29udGludWVcIjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZG90ID0gMDtcbiAgICAgICAgRkxPQVRfREVMVEFTLmZvckVhY2goZnVuY3Rpb24gKGRlbHRhLCBqKSB7XG4gICAgICAgICAgICBkb3QgKz0gZGVsdGEgKiB1aW50QXJyYXlbaSArIGpdO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHZhbHVlID0gZG90ICogRkxPQVRfUkFOR0UgKyBleHBvcnRzLkZMT0FUX01JTjtcbiAgICAgICAgZmxvYXRBcnJheVtpIC8gNF0gPSB2YWx1ZTtcbiAgICB9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdWludEFycmF5Lmxlbmd0aDsgaSArPSA0KSB7XG4gICAgICAgIF9sb29wXzIoaSk7XG4gICAgfVxuICAgIHJldHVybiBmbG9hdEFycmF5O1xufVxuZXhwb3J0cy5kZWNvZGVUb0Zsb2F0QXJyYXkgPSBkZWNvZGVUb0Zsb2F0QXJyYXk7XG5mdW5jdGlvbiBkZWNvZGVNYXRyaXhGcm9tVW5wYWNrZWRBcnJheSh1bnBhY2tlZEFycmF5LCBtYXRyaXgsIGNoYW5uZWxzUGVyVGV4dHVyZSkge1xuICAgIHZhciByZXF1aXJlZFNpemUgPSBnZXRNYXRyaXhTaXplRnJvbVVucGFja2VkQXJyYXlTaXplKHVucGFja2VkQXJyYXkubGVuZ3RoLCBjaGFubmVsc1BlclRleHR1cmUpO1xuICAgIGlmIChtYXRyaXgubGVuZ3RoIDwgcmVxdWlyZWRTaXplKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIm1hdHJpeCBsZW5ndGggKFwiICsgbWF0cml4Lmxlbmd0aCArIFwiKSBtdXN0IGJlID49IFwiICsgcmVxdWlyZWRTaXplKTtcbiAgICB9XG4gICAgdmFyIGRzdCA9IDA7XG4gICAgZm9yICh2YXIgc3JjID0gMDsgc3JjIDwgdW5wYWNrZWRBcnJheS5sZW5ndGg7IHNyYyArPSBjaGFubmVsc1BlclRleHR1cmUpIHtcbiAgICAgICAgbWF0cml4W2RzdCsrXSA9IHVucGFja2VkQXJyYXlbc3JjXTtcbiAgICB9XG59XG5leHBvcnRzLmRlY29kZU1hdHJpeEZyb21VbnBhY2tlZEFycmF5ID0gZGVjb2RlTWF0cml4RnJvbVVucGFja2VkQXJyYXk7XG5mdW5jdGlvbiBkZWNvZGVNYXRyaXhGcm9tVW5wYWNrZWRDb2xvclJHQkFBcnJheSh1bnBhY2tlZEFycmF5LCBtYXRyaXgsIGNoYW5uZWxzKSB7XG4gICAgdmFyIHJlcXVpcmVkU2l6ZSA9IHVucGFja2VkQXJyYXkubGVuZ3RoICogY2hhbm5lbHMgLyA0O1xuICAgIGlmIChtYXRyaXgubGVuZ3RoIDwgcmVxdWlyZWRTaXplKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIm1hdHJpeCBsZW5ndGggKFwiICsgbWF0cml4Lmxlbmd0aCArIFwiKSBtdXN0IGJlID49IFwiICsgcmVxdWlyZWRTaXplKTtcbiAgICB9XG4gICAgdmFyIGRzdCA9IDA7XG4gICAgZm9yICh2YXIgc3JjID0gMDsgc3JjIDwgdW5wYWNrZWRBcnJheS5sZW5ndGg7IHNyYyArPSA0KSB7XG4gICAgICAgIGZvciAodmFyIGMgPSAwOyBjIDwgY2hhbm5lbHM7IGMrKykge1xuICAgICAgICAgICAgbWF0cml4W2RzdCsrXSA9IHVucGFja2VkQXJyYXlbc3JjICsgY107XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLmRlY29kZU1hdHJpeEZyb21VbnBhY2tlZENvbG9yUkdCQUFycmF5ID0gZGVjb2RlTWF0cml4RnJvbVVucGFja2VkQ29sb3JSR0JBQXJyYXk7XG5mdW5jdGlvbiBnZXRQYWNrZWRNYXRyaXhUZXh0dXJlU2hhcGVXaWR0aEhlaWdodChyb3dzLCBjb2x1bW5zKSB7XG4gICAgcmV0dXJuIFtNYXRoLmNlaWwoY29sdW1ucyAvIDIpLCBNYXRoLmNlaWwocm93cyAvIDIpXTtcbn1cbmV4cG9ydHMuZ2V0UGFja2VkTWF0cml4VGV4dHVyZVNoYXBlV2lkdGhIZWlnaHQgPSBnZXRQYWNrZWRNYXRyaXhUZXh0dXJlU2hhcGVXaWR0aEhlaWdodDtcbmZ1bmN0aW9uIGdldFBhY2tlZFJHQkFBcnJheVNpemVGcm9tTWF0cml4U2hhcGUocm93cywgY29sdW1ucykge1xuICAgIHZhciBfYSA9IGdldFBhY2tlZE1hdHJpeFRleHR1cmVTaGFwZVdpZHRoSGVpZ2h0KHJvd3MsIGNvbHVtbnMpLCB3ID0gX2FbMF0sIGggPSBfYVsxXTtcbiAgICByZXR1cm4gdyAqIGggKiA0O1xufVxuZXhwb3J0cy5nZXRQYWNrZWRSR0JBQXJyYXlTaXplRnJvbU1hdHJpeFNoYXBlID0gZ2V0UGFja2VkUkdCQUFycmF5U2l6ZUZyb21NYXRyaXhTaGFwZTtcbmZ1bmN0aW9uIGVuY29kZU1hdHJpeFRvUGFja2VkUkdCQShtYXRyaXgsIHJvd3MsIGNvbHVtbnMsIHBhY2tlZFJHQkEpIHtcbiAgICB2YXIgcmVxdWlyZWRTaXplID0gZ2V0UGFja2VkUkdCQUFycmF5U2l6ZUZyb21NYXRyaXhTaGFwZShyb3dzLCBjb2x1bW5zKTtcbiAgICBpZiAocGFja2VkUkdCQS5sZW5ndGggPCByZXF1aXJlZFNpemUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwicGFja2VkUkdCQSBsZW5ndGggKFwiICsgcGFja2VkUkdCQS5sZW5ndGggKyBcIikgbXVzdCBiZSA+PSBcIiArIHJlcXVpcmVkU2l6ZSk7XG4gICAgfVxuICAgIHZhciBfYSA9IGdldFBhY2tlZE1hdHJpeFRleHR1cmVTaGFwZVdpZHRoSGVpZ2h0KHJvd3MsIGNvbHVtbnMpLCB0ZXh0dXJlV2lkdGggPSBfYVswXSwgdGV4dHVyZUhlaWdodCA9IF9hWzFdO1xuICAgIHZhciBvZGRXaWR0aCA9IChjb2x1bW5zICUgMikgPT09IDE7XG4gICAgdmFyIG9kZEhlaWdodCA9IChyb3dzICUgMikgPT09IDE7XG4gICAgdmFyIHdpZHRoSW5GdWxsQmxvY2tzID0gTWF0aC5mbG9vcihjb2x1bW5zIC8gMik7XG4gICAgdmFyIGhlaWdodEluRnVsbEJsb2NrcyA9IE1hdGguZmxvb3Iocm93cyAvIDIpO1xuICAgIHtcbiAgICAgICAgdmFyIGRzdFN0cmlkZSA9IChvZGRXaWR0aCA/IDQgOiAwKTtcbiAgICAgICAgdmFyIG9uZVJvdyA9IGNvbHVtbnM7XG4gICAgICAgIHZhciBkc3QgPSAwO1xuICAgICAgICBmb3IgKHZhciBibG9ja1kgPSAwOyBibG9ja1kgPCBoZWlnaHRJbkZ1bGxCbG9ja3M7ICsrYmxvY2tZKSB7XG4gICAgICAgICAgICB2YXIgbWF0cml4U3JjUm93ID0gKGJsb2NrWSAqIDIgKiBjb2x1bW5zKTtcbiAgICAgICAgICAgIGZvciAodmFyIGJsb2NrWCA9IDA7IGJsb2NrWCA8IHdpZHRoSW5GdWxsQmxvY2tzOyArK2Jsb2NrWCkge1xuICAgICAgICAgICAgICAgIHZhciBtYXRyaXhTcmNDb2wgPSBibG9ja1ggKiAyO1xuICAgICAgICAgICAgICAgIHZhciBzcmMgPSBtYXRyaXhTcmNSb3cgKyBtYXRyaXhTcmNDb2w7XG4gICAgICAgICAgICAgICAgcGFja2VkUkdCQVtkc3RdID0gbWF0cml4W3NyY107XG4gICAgICAgICAgICAgICAgcGFja2VkUkdCQVtkc3QgKyAxXSA9IG1hdHJpeFtzcmMgKyAxXTtcbiAgICAgICAgICAgICAgICBwYWNrZWRSR0JBW2RzdCArIDJdID0gbWF0cml4W3NyYyArIG9uZVJvd107XG4gICAgICAgICAgICAgICAgcGFja2VkUkdCQVtkc3QgKyAzXSA9IG1hdHJpeFtzcmMgKyBvbmVSb3cgKyAxXTtcbiAgICAgICAgICAgICAgICBkc3QgKz0gNDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRzdCArPSBkc3RTdHJpZGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9kZFdpZHRoKSB7XG4gICAgICAgIHZhciBzcmMgPSBjb2x1bW5zIC0gMTtcbiAgICAgICAgdmFyIGRzdCA9ICh0ZXh0dXJlV2lkdGggLSAxKSAqIDQ7XG4gICAgICAgIHZhciBzcmNTdHJpZGUgPSAyICogY29sdW1ucztcbiAgICAgICAgdmFyIGRzdFN0cmlkZSA9IHRleHR1cmVXaWR0aCAqIDQ7XG4gICAgICAgIGZvciAodmFyIGJsb2NrWSA9IDA7IGJsb2NrWSA8IGhlaWdodEluRnVsbEJsb2NrczsgKytibG9ja1kpIHtcbiAgICAgICAgICAgIHBhY2tlZFJHQkFbZHN0XSA9IG1hdHJpeFtzcmNdO1xuICAgICAgICAgICAgcGFja2VkUkdCQVtkc3QgKyAyXSA9IG1hdHJpeFtzcmMgKyBjb2x1bW5zXTtcbiAgICAgICAgICAgIHNyYyArPSBzcmNTdHJpZGU7XG4gICAgICAgICAgICBkc3QgKz0gZHN0U3RyaWRlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChvZGRIZWlnaHQpIHtcbiAgICAgICAgdmFyIHNyYyA9IChyb3dzIC0gMSkgKiBjb2x1bW5zO1xuICAgICAgICB2YXIgZHN0ID0gKHRleHR1cmVIZWlnaHQgLSAxKSAqIHRleHR1cmVXaWR0aCAqIDQ7XG4gICAgICAgIGZvciAodmFyIGJsb2NrWCA9IDA7IGJsb2NrWCA8IHdpZHRoSW5GdWxsQmxvY2tzOyArK2Jsb2NrWCkge1xuICAgICAgICAgICAgcGFja2VkUkdCQVtkc3QrK10gPSBtYXRyaXhbc3JjKytdO1xuICAgICAgICAgICAgcGFja2VkUkdCQVtkc3QrK10gPSBtYXRyaXhbc3JjKytdO1xuICAgICAgICAgICAgZHN0ICs9IDI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9kZFdpZHRoICYmIG9kZEhlaWdodCkge1xuICAgICAgICBwYWNrZWRSR0JBW3BhY2tlZFJHQkEubGVuZ3RoIC0gNF0gPSBtYXRyaXhbbWF0cml4Lmxlbmd0aCAtIDFdO1xuICAgIH1cbiAgICByZXR1cm4gcGFja2VkUkdCQTtcbn1cbmV4cG9ydHMuZW5jb2RlTWF0cml4VG9QYWNrZWRSR0JBID0gZW5jb2RlTWF0cml4VG9QYWNrZWRSR0JBO1xuZnVuY3Rpb24gZGVjb2RlTWF0cml4RnJvbVBhY2tlZFJHQkEocGFja2VkUkdCQSwgcm93cywgY29sdW1ucywgbWF0cml4KSB7XG4gICAgdmFyIHJlcXVpcmVkU2l6ZSA9IHJvd3MgKiBjb2x1bW5zO1xuICAgIGlmIChyZXF1aXJlZFNpemUgPCBtYXRyaXgubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIm1hdHJpeCBsZW5ndGggKFwiICsgbWF0cml4Lmxlbmd0aCArIFwiKSBtdXN0IGJlID49IFwiICsgcmVxdWlyZWRTaXplKTtcbiAgICB9XG4gICAgdmFyIG9kZFdpZHRoID0gKGNvbHVtbnMgJSAyKSA9PT0gMTtcbiAgICB2YXIgb2RkSGVpZ2h0ID0gKHJvd3MgJSAyKSA9PT0gMTtcbiAgICB2YXIgd2lkdGhJbkZ1bGxCbG9ja3MgPSBNYXRoLmZsb29yKGNvbHVtbnMgLyAyKTtcbiAgICB2YXIgaGVpZ2h0SW5GdWxsQmxvY2tzID0gTWF0aC5mbG9vcihyb3dzIC8gMik7XG4gICAgdmFyIF9hID0gZ2V0UGFja2VkTWF0cml4VGV4dHVyZVNoYXBlV2lkdGhIZWlnaHQocm93cywgY29sdW1ucyksIHRleHR1cmVXaWR0aCA9IF9hWzBdLCB0ZXh0dXJlSGVpZ2h0ID0gX2FbMV07XG4gICAge1xuICAgICAgICB2YXIgc3JjU3RyaWRlID0gb2RkV2lkdGggPyA0IDogMDtcbiAgICAgICAgdmFyIGRzdFN0cmlkZSA9IGNvbHVtbnMgKyAob2RkV2lkdGggPyAxIDogMCk7XG4gICAgICAgIHZhciBzcmMgPSAwO1xuICAgICAgICB2YXIgZHN0Um93MSA9IDA7XG4gICAgICAgIHZhciBkc3RSb3cyID0gY29sdW1ucztcbiAgICAgICAgZm9yICh2YXIgYmxvY2tZID0gMDsgYmxvY2tZIDwgaGVpZ2h0SW5GdWxsQmxvY2tzOyArK2Jsb2NrWSkge1xuICAgICAgICAgICAgZm9yICh2YXIgYmxvY2tYID0gMDsgYmxvY2tYIDwgd2lkdGhJbkZ1bGxCbG9ja3M7ICsrYmxvY2tYKSB7XG4gICAgICAgICAgICAgICAgbWF0cml4W2RzdFJvdzErK10gPSBwYWNrZWRSR0JBW3NyYysrXTtcbiAgICAgICAgICAgICAgICBtYXRyaXhbZHN0Um93MSsrXSA9IHBhY2tlZFJHQkFbc3JjKytdO1xuICAgICAgICAgICAgICAgIG1hdHJpeFtkc3RSb3cyKytdID0gcGFja2VkUkdCQVtzcmMrK107XG4gICAgICAgICAgICAgICAgbWF0cml4W2RzdFJvdzIrK10gPSBwYWNrZWRSR0JBW3NyYysrXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNyYyArPSBzcmNTdHJpZGU7XG4gICAgICAgICAgICBkc3RSb3cxICs9IGRzdFN0cmlkZTtcbiAgICAgICAgICAgIGRzdFJvdzIgKz0gZHN0U3RyaWRlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChvZGRXaWR0aCkge1xuICAgICAgICB2YXIgc3JjID0gKHRleHR1cmVXaWR0aCAtIDEpICogNDtcbiAgICAgICAgdmFyIGRzdCA9IGNvbHVtbnMgLSAxO1xuICAgICAgICB2YXIgc3JjU3RyaWRlID0gdGV4dHVyZVdpZHRoICogNDtcbiAgICAgICAgdmFyIGRzdFN0cmlkZSA9IDIgKiBjb2x1bW5zO1xuICAgICAgICBmb3IgKHZhciBibG9ja1kgPSAwOyBibG9ja1kgPCBoZWlnaHRJbkZ1bGxCbG9ja3M7ICsrYmxvY2tZKSB7XG4gICAgICAgICAgICBtYXRyaXhbZHN0XSA9IHBhY2tlZFJHQkFbc3JjXTtcbiAgICAgICAgICAgIG1hdHJpeFtkc3QgKyBjb2x1bW5zXSA9IHBhY2tlZFJHQkFbc3JjICsgMl07XG4gICAgICAgICAgICBzcmMgKz0gc3JjU3RyaWRlO1xuICAgICAgICAgICAgZHN0ICs9IGRzdFN0cmlkZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAob2RkSGVpZ2h0KSB7XG4gICAgICAgIHZhciBzcmMgPSAodGV4dHVyZUhlaWdodCAtIDEpICogdGV4dHVyZVdpZHRoICogNDtcbiAgICAgICAgdmFyIGRzdCA9IChyb3dzIC0gMSkgKiBjb2x1bW5zO1xuICAgICAgICBmb3IgKHZhciBibG9ja1ggPSAwOyBibG9ja1ggPCB3aWR0aEluRnVsbEJsb2NrczsgKytibG9ja1gpIHtcbiAgICAgICAgICAgIG1hdHJpeFtkc3QrK10gPSBwYWNrZWRSR0JBW3NyYysrXTtcbiAgICAgICAgICAgIG1hdHJpeFtkc3QrK10gPSBwYWNrZWRSR0JBW3NyYysrXTtcbiAgICAgICAgICAgIHNyYyArPSAyO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChvZGRXaWR0aCAmJiBvZGRIZWlnaHQpIHtcbiAgICAgICAgbWF0cml4W21hdHJpeC5sZW5ndGggLSAxXSA9IHBhY2tlZFJHQkFbcGFja2VkUkdCQS5sZW5ndGggLSA0XTtcbiAgICB9XG4gICAgcmV0dXJuIG1hdHJpeDtcbn1cbmV4cG9ydHMuZGVjb2RlTWF0cml4RnJvbVBhY2tlZFJHQkEgPSBkZWNvZGVNYXRyaXhGcm9tUGFja2VkUkdCQTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRleF91dGlsLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIFRleHR1cmVNYW5hZ2VyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUZXh0dXJlTWFuYWdlcihncGdwdSkge1xuICAgICAgICB0aGlzLmdwZ3B1ID0gZ3BncHU7XG4gICAgICAgIHRoaXMubnVtVXNlZFRleHR1cmVzID0gMDtcbiAgICAgICAgdGhpcy5udW1GcmVlVGV4dHVyZXMgPSAwO1xuICAgICAgICB0aGlzLmZyZWVUZXh0dXJlcyA9IHt9O1xuICAgICAgICB0aGlzLmxvZ0VuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy51c2VkVGV4dHVyZUNvdW50ID0ge307XG4gICAgfVxuICAgIFRleHR1cmVNYW5hZ2VyLnByb3RvdHlwZS5hY3F1aXJlVGV4dHVyZSA9IGZ1bmN0aW9uIChzaGFwZVJDKSB7XG4gICAgICAgIHZhciBzaGFwZUtleSA9IGdldEtleUZyb21UZXh0dXJlU2hhcGUoc2hhcGVSQyk7XG4gICAgICAgIGlmICghKHNoYXBlS2V5IGluIHRoaXMuZnJlZVRleHR1cmVzKSkge1xuICAgICAgICAgICAgdGhpcy5mcmVlVGV4dHVyZXNbc2hhcGVLZXldID0gW107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEoc2hhcGVLZXkgaW4gdGhpcy51c2VkVGV4dHVyZUNvdW50KSkge1xuICAgICAgICAgICAgdGhpcy51c2VkVGV4dHVyZUNvdW50W3NoYXBlS2V5XSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51c2VkVGV4dHVyZUNvdW50W3NoYXBlS2V5XSsrO1xuICAgICAgICBpZiAodGhpcy5mcmVlVGV4dHVyZXNbc2hhcGVLZXldLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMubnVtRnJlZVRleHR1cmVzLS07XG4gICAgICAgICAgICB0aGlzLm51bVVzZWRUZXh0dXJlcysrO1xuICAgICAgICAgICAgdGhpcy5sb2coKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZyZWVUZXh0dXJlc1tzaGFwZUtleV0uc2hpZnQoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm51bVVzZWRUZXh0dXJlcysrO1xuICAgICAgICB0aGlzLmxvZygpO1xuICAgICAgICByZXR1cm4gdGhpcy5ncGdwdS5jcmVhdGVNYXRyaXhUZXh0dXJlKHNoYXBlUkNbMF0sIHNoYXBlUkNbMV0pO1xuICAgIH07XG4gICAgVGV4dHVyZU1hbmFnZXIucHJvdG90eXBlLnJlbGVhc2VUZXh0dXJlID0gZnVuY3Rpb24gKHRleHR1cmUsIHNoYXBlKSB7XG4gICAgICAgIHZhciBzaGFwZUtleSA9IGdldEtleUZyb21UZXh0dXJlU2hhcGUoc2hhcGUpO1xuICAgICAgICBpZiAoIShzaGFwZUtleSBpbiB0aGlzLmZyZWVUZXh0dXJlcykpIHtcbiAgICAgICAgICAgIHRoaXMuZnJlZVRleHR1cmVzW3NoYXBlS2V5XSA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZnJlZVRleHR1cmVzW3NoYXBlS2V5XS5wdXNoKHRleHR1cmUpO1xuICAgICAgICB0aGlzLm51bUZyZWVUZXh0dXJlcysrO1xuICAgICAgICB0aGlzLm51bVVzZWRUZXh0dXJlcy0tO1xuICAgICAgICB0aGlzLnVzZWRUZXh0dXJlQ291bnRbc2hhcGVLZXldLS07XG4gICAgICAgIHRoaXMubG9nKCk7XG4gICAgfTtcbiAgICBUZXh0dXJlTWFuYWdlci5wcm90b3R5cGUubG9nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMubG9nRW5hYmxlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0b3RhbCA9IHRoaXMubnVtRnJlZVRleHR1cmVzICsgdGhpcy5udW1Vc2VkVGV4dHVyZXM7XG4gICAgICAgIGNvbnNvbGUubG9nKCdGcmVlL1VzZWQnLCB0aGlzLm51bUZyZWVUZXh0dXJlcyArIFwiIC8gXCIgKyB0aGlzLm51bVVzZWRUZXh0dXJlcywgXCIoXCIgKyB0b3RhbCArIFwiKVwiKTtcbiAgICB9O1xuICAgIFRleHR1cmVNYW5hZ2VyLnByb3RvdHlwZS5nZXROdW1Vc2VkVGV4dHVyZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm51bVVzZWRUZXh0dXJlcztcbiAgICB9O1xuICAgIFRleHR1cmVNYW5hZ2VyLnByb3RvdHlwZS5nZXROdW1GcmVlVGV4dHVyZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm51bUZyZWVUZXh0dXJlcztcbiAgICB9O1xuICAgIFRleHR1cmVNYW5hZ2VyLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBmb3IgKHZhciBzaGFwZSBpbiB0aGlzLmZyZWVUZXh0dXJlcykge1xuICAgICAgICAgICAgaWYgKHRoaXMuZnJlZVRleHR1cmVzLmhhc093blByb3BlcnR5KHNoYXBlKSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5mcmVlVGV4dHVyZXNbc2hhcGVdLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ3BncHUuZGVsZXRlTWF0cml4VGV4dHVyZSh0aGlzLmZyZWVUZXh0dXJlc1tzaGFwZV1baV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFRleHR1cmVNYW5hZ2VyO1xufSgpKTtcbmV4cG9ydHMuVGV4dHVyZU1hbmFnZXIgPSBUZXh0dXJlTWFuYWdlcjtcbmZ1bmN0aW9uIGdldEtleUZyb21UZXh0dXJlU2hhcGUoc2hhcGVSb3dzQ29sKSB7XG4gICAgcmV0dXJuIHNoYXBlUm93c0NvbFswXSArIFwiX1wiICsgc2hhcGVSb3dzQ29sWzFdO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGV4dHVyZV9tYW5hZ2VyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHNoYWRlcl9jb21waWxlcl8xID0gcmVxdWlyZShcIi4vc2hhZGVyX2NvbXBpbGVyXCIpO1xudmFyIFRpbGVQcm9ncmFtID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUaWxlUHJvZ3JhbShhU2hhcGUsIHJlcHMpIHtcbiAgICAgICAgdGhpcy52YXJpYWJsZU5hbWVzID0gWydBJ107XG4gICAgICAgIHZhciBvdXRwdXRTaGFwZSA9IG5ldyBBcnJheShhU2hhcGUubGVuZ3RoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvdXRwdXRTaGFwZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgb3V0cHV0U2hhcGVbaV0gPSBhU2hhcGVbaV0gKiByZXBzW2ldO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3V0cHV0U2hhcGUgPSBvdXRwdXRTaGFwZTtcbiAgICAgICAgdGhpcy5yYW5rID0gb3V0cHV0U2hhcGUubGVuZ3RoO1xuICAgICAgICB2YXIgZHR5cGUgPSBzaGFkZXJfY29tcGlsZXJfMS5nZXRDb29yZHNEYXRhVHlwZSh0aGlzLnJhbmspO1xuICAgICAgICB2YXIgc291cmNlQ29vcmRzID0gZ2V0U291cmNlQ29vcmRzKGFTaGFwZSk7XG4gICAgICAgIHRoaXMudXNlckNvZGUgPSBcIlxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIFwiICsgZHR5cGUgKyBcIiByZXNSQyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgc2V0T3V0cHV0KGdldEEoXCIgKyBzb3VyY2VDb29yZHMgKyBcIikpO1xcbiAgICAgIH1cXG4gICAgXCI7XG4gICAgfVxuICAgIHJldHVybiBUaWxlUHJvZ3JhbTtcbn0oKSk7XG5leHBvcnRzLlRpbGVQcm9ncmFtID0gVGlsZVByb2dyYW07XG5mdW5jdGlvbiBnZXRTb3VyY2VDb29yZHMoYVNoYXBlKSB7XG4gICAgdmFyIHJhbmsgPSBhU2hhcGUubGVuZ3RoO1xuICAgIGlmIChyYW5rID4gNCkge1xuICAgICAgICB0aHJvdyBFcnJvcihcIlRpbGUgZm9yIHJhbmsgXCIgKyByYW5rICsgXCIgaXMgbm90IHlldCBzdXBwb3J0ZWRcIik7XG4gICAgfVxuICAgIGlmIChyYW5rID09PSAxKSB7XG4gICAgICAgIHJldHVybiBcImltb2QocmVzUkMsIFwiICsgYVNoYXBlWzBdICsgXCIpXCI7XG4gICAgfVxuICAgIHZhciBjdXJyZW50Q29vcmRzID0gWydyZXNSQy54JywgJ3Jlc1JDLnknLCAncmVzUkMueicsICdyZXNSQy53J107XG4gICAgdmFyIHNvdXJjZUNvb3JkcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYVNoYXBlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHNvdXJjZUNvb3Jkcy5wdXNoKFwiaW1vZChcIiArIGN1cnJlbnRDb29yZHNbaV0gKyBcIiwgXCIgKyBhU2hhcGVbaV0gKyBcIilcIik7XG4gICAgfVxuICAgIHJldHVybiBzb3VyY2VDb29yZHMuam9pbigpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGlsZV9ncHUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgc2hhZGVyX2NvbXBpbGVyXzEgPSByZXF1aXJlKFwiLi9zaGFkZXJfY29tcGlsZXJcIik7XG52YXIgVHJhbnNwb3NlUHJvZ3JhbSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVHJhbnNwb3NlUHJvZ3JhbShhU2hhcGUsIG5ld0RpbSkge1xuICAgICAgICB0aGlzLnZhcmlhYmxlTmFtZXMgPSBbJ0EnXTtcbiAgICAgICAgdmFyIG91dHB1dFNoYXBlID0gbmV3IEFycmF5KGFTaGFwZS5sZW5ndGgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG91dHB1dFNoYXBlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBvdXRwdXRTaGFwZVtpXSA9IGFTaGFwZVtuZXdEaW1baV1dO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3V0cHV0U2hhcGUgPSBvdXRwdXRTaGFwZTtcbiAgICAgICAgdGhpcy5yYW5rID0gb3V0cHV0U2hhcGUubGVuZ3RoO1xuICAgICAgICB2YXIgZHR5cGUgPSBzaGFkZXJfY29tcGlsZXJfMS5nZXRDb29yZHNEYXRhVHlwZSh0aGlzLnJhbmspO1xuICAgICAgICB2YXIgc3dpdGNoZWQgPSBnZXRTd2l0Y2hlZENvb3JkcyhuZXdEaW0pO1xuICAgICAgICB0aGlzLnVzZXJDb2RlID0gXCJcXG4gICAgdm9pZCBtYWluKCkge1xcbiAgICAgIFwiICsgZHR5cGUgKyBcIiByZXNSQyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgIHNldE91dHB1dChnZXRBKFwiICsgc3dpdGNoZWQgKyBcIikpO1xcbiAgICB9XFxuICAgIFwiO1xuICAgIH1cbiAgICByZXR1cm4gVHJhbnNwb3NlUHJvZ3JhbTtcbn0oKSk7XG5leHBvcnRzLlRyYW5zcG9zZVByb2dyYW0gPSBUcmFuc3Bvc2VQcm9ncmFtO1xuZnVuY3Rpb24gZ2V0U3dpdGNoZWRDb29yZHMobmV3RGltKSB7XG4gICAgdmFyIHJhbmsgPSBuZXdEaW0ubGVuZ3RoO1xuICAgIGlmIChyYW5rID4gNCkge1xuICAgICAgICB0aHJvdyBFcnJvcihcIlRyYW5zcG9zZSBmb3IgcmFuayBcIiArIHJhbmsgKyBcIiBpcyBub3QgeWV0IHN1cHBvcnRlZFwiKTtcbiAgICB9XG4gICAgdmFyIG9yaWdpbmFsT3JkZXIgPSBbJ3Jlc1JDLngnLCAncmVzUkMueScsICdyZXNSQy56JywgJ3Jlc1JDLncnXTtcbiAgICB2YXIgc3dpdGNoZWRDb29yZHMgPSBuZXcgQXJyYXkocmFuayk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZXdEaW0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc3dpdGNoZWRDb29yZHNbbmV3RGltW2ldXSA9IG9yaWdpbmFsT3JkZXJbaV07XG4gICAgfVxuICAgIHJldHVybiBzd2l0Y2hlZENvb3Jkcy5qb2luKCk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD10cmFuc3Bvc2VfZ3B1LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIFVuYXJ5T3BQcm9ncmFtID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBVbmFyeU9wUHJvZ3JhbShhU2hhcGUsIG9wU25pcHBldCkge1xuICAgICAgICB0aGlzLnZhcmlhYmxlTmFtZXMgPSBbJ0EnXTtcbiAgICAgICAgdGhpcy5vdXRwdXRTaGFwZSA9IGFTaGFwZTtcbiAgICAgICAgdGhpcy51c2VyQ29kZSA9IFwiXFxuICAgICAgZmxvYXQgdW5hcnlPcGVyYXRpb24oZmxvYXQgeCkge1xcbiAgICAgICAgXCIgKyBvcFNuaXBwZXQgKyBcIlxcbiAgICAgIH1cXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBmbG9hdCB4ID0gZ2V0QUF0T3V0Q29vcmRzKCk7XFxuICAgICAgICBmbG9hdCB5ID0gdW5hcnlPcGVyYXRpb24oeCk7XFxuXFxuICAgICAgICBzZXRPdXRwdXQoeSk7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgcmV0dXJuIFVuYXJ5T3BQcm9ncmFtO1xufSgpKTtcbmV4cG9ydHMuVW5hcnlPcFByb2dyYW0gPSBVbmFyeU9wUHJvZ3JhbTtcbmV4cG9ydHMuQ0hFQ0tfTkFOX1NOSVBQRVQgPSBcIlxcbiAgaWYgKGlzTmFOKHgpKSB7XFxuICAgIHJldHVybiB4O1xcbiAgfVxcblwiO1xuZXhwb3J0cy5BQlMgPSBcIlxcbiAgcmV0dXJuIGFicyh4KTtcXG5cIjtcbmV4cG9ydHMuUkVMVSA9IFwiXFxuICByZXR1cm4gKHggPCAwLjApID8gMC4wIDogeDtcXG5cIjtcbmV4cG9ydHMuRUxVID0gXCJcXG4gIHJldHVybiAoeCA+PSAwLjApID8geCA6IChleHAoeCkgLSAxLjApO1xcblwiO1xuZnVuY3Rpb24gTEVBS1lfUkVMVShhbHBoYSkge1xuICAgIHJldHVybiBcIlxcbiAgICByZXR1cm4gKHggPj0gMC4wKSA/IHggOiBcIiArIGFscGhhICsgXCIgKiB4O1xcbiAgXCI7XG59XG5leHBvcnRzLkxFQUtZX1JFTFUgPSBMRUFLWV9SRUxVO1xuZnVuY3Rpb24gU1RFUChhbHBoYSkge1xuICAgIGlmIChhbHBoYSA9PT0gdm9pZCAwKSB7IGFscGhhID0gMC4wOyB9XG4gICAgcmV0dXJuIFwiXFxuICAgIHJldHVybiAoeCA9PSB4KSA/ICh4ID4gMC4wID8gMS4wIDogZmxvYXQoXCIgKyBhbHBoYSArIFwiKSkgOiB4O1xcbiAgXCI7XG59XG5leHBvcnRzLlNURVAgPSBTVEVQO1xuZXhwb3J0cy5ORUcgPSBcIlxcbiAgcmV0dXJuIC14O1xcblwiO1xuZXhwb3J0cy5DRUlMID0gXCJcXG4gIHJldHVybiBjZWlsKHgpO1xcblwiO1xuZXhwb3J0cy5GTE9PUiA9IFwiXFxuICByZXR1cm4gZmxvb3IoeCk7XFxuXCI7XG5leHBvcnRzLkVYUCA9IFwiXFxuICByZXR1cm4gZXhwKHgpO1xcblwiO1xuZXhwb3J0cy5MT0cgPSBcIlxcbiAgcmV0dXJuIGxvZyh4KTtcXG5cIjtcbmV4cG9ydHMuU1FSVCA9IGV4cG9ydHMuQ0hFQ0tfTkFOX1NOSVBQRVQgKyBcIlxcbiAgcmV0dXJuIHNxcnQoeCk7XFxuXCI7XG5leHBvcnRzLlNJR01PSUQgPSBcIlxcbiAgcmV0dXJuIDEuMCAvICgxLjAgKyBleHAoLTEuMCAqIHgpKTtcXG5cIjtcbmV4cG9ydHMuU0lOID0gZXhwb3J0cy5DSEVDS19OQU5fU05JUFBFVCArIFwiXFxuICByZXR1cm4gc2luKHgpO1xcblwiO1xuZXhwb3J0cy5DT1MgPSBleHBvcnRzLkNIRUNLX05BTl9TTklQUEVUICsgXCJcXG4gIHJldHVybiBjb3MoeCk7XFxuXCI7XG5leHBvcnRzLlRBTiA9IFwiXFxuICByZXR1cm4gdGFuKHgpO1xcblwiO1xuZXhwb3J0cy5BU0lOID0gZXhwb3J0cy5DSEVDS19OQU5fU05JUFBFVCArIFwiXFxuICByZXR1cm4gYXNpbih4KTtcXG5cIjtcbmV4cG9ydHMuQUNPUyA9IGV4cG9ydHMuQ0hFQ0tfTkFOX1NOSVBQRVQgKyBcIlxcbiAgcmV0dXJuIGFjb3MoeCk7XFxuXCI7XG5leHBvcnRzLkFUQU4gPSBleHBvcnRzLkNIRUNLX05BTl9TTklQUEVUICsgXCJcXG4gIHJldHVybiBhdGFuKHgpO1xcblwiO1xuZXhwb3J0cy5TSU5IID0gXCJcXG4gIGZsb2F0IGUyeCA9IGV4cCh4KTtcXG4gIHJldHVybiAoZTJ4IC0gMS4wIC8gZTJ4KSAvIDIuMDtcXG5cIjtcbmV4cG9ydHMuQ09TSCA9IFwiXFxuICBmbG9hdCBlMnggPSBleHAoLXgpO1xcbiAgcmV0dXJuIChlMnggKyAxLjAgLyBlMngpIC8gMi4wO1xcblwiO1xuZXhwb3J0cy5UQU5IID0gXCJcXG4gIGZsb2F0IGUyeCA9IGV4cCgtMi4wICogYWJzKHgpKTtcXG4gIHJldHVybiBzaWduKHgpICogKDEuMCAtIGUyeCkgLyAoMS4wICsgZTJ4KTtcXG5cIjtcbmV4cG9ydHMuU1FVQVJFID0gXCJcXG4gIHJldHVybiB4ICogeDtcXG5cIjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVuYXJ5b3BfZ3B1LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIE1BWF9URVhUVVJFX1NJWkUgPSBudWxsO1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vLi4vdXRpbFwiKTtcbnZhciBlbnZpcm9ubWVudF8xID0gcmVxdWlyZShcIi4uLy4uL2Vudmlyb25tZW50XCIpO1xuZnVuY3Rpb24gY3JlYXRlV2ViR0xSZW5kZXJpbmdDb250ZXh0KGF0dHJpYnV0ZXMpIHtcbiAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgY2FudmFzLndpZHRoID0gMTtcbiAgICBjYW52YXMuaGVpZ2h0ID0gMTtcbiAgICByZXR1cm4gY3JlYXRlV2ViR0xSZW5kZXJpbmdDb250ZXh0RnJvbUNhbnZhcyhjYW52YXMsIGF0dHJpYnV0ZXMpO1xufVxuZXhwb3J0cy5jcmVhdGVXZWJHTFJlbmRlcmluZ0NvbnRleHQgPSBjcmVhdGVXZWJHTFJlbmRlcmluZ0NvbnRleHQ7XG5mdW5jdGlvbiBjcmVhdGVXZWJHTFJlbmRlcmluZ0NvbnRleHRGcm9tQ2FudmFzKGNhbnZhcywgYXR0cmlidXRlcykge1xuICAgIHZhciBnbDtcbiAgICB2YXIgd2ViZ2xWZXJzaW9uID0gZW52aXJvbm1lbnRfMS5FTlYuZ2V0KCdXRUJHTF9WRVJTSU9OJyk7XG4gICAgaWYgKHdlYmdsVmVyc2lvbiA9PT0gMikge1xuICAgICAgICBnbCA9IGNhbnZhcy5nZXRDb250ZXh0KCd3ZWJnbDInLCBhdHRyaWJ1dGVzKTtcbiAgICB9XG4gICAgZWxzZSBpZiAod2ViZ2xWZXJzaW9uID09PSAxKSB7XG4gICAgICAgIGdsID0gKGNhbnZhcy5nZXRDb250ZXh0KCd3ZWJnbCcsIGF0dHJpYnV0ZXMpIHx8XG4gICAgICAgICAgICBjYW52YXMuZ2V0Q29udGV4dCgnZXhwZXJpbWVudGFsLXdlYmdsJywgYXR0cmlidXRlcykpO1xuICAgIH1cbiAgICBpZiAod2ViZ2xWZXJzaW9uID09PSAwIHx8IGdsID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCBXZWJHTC4nKTtcbiAgICB9XG4gICAgcmV0dXJuIGdsO1xufVxuZXhwb3J0cy5jcmVhdGVXZWJHTFJlbmRlcmluZ0NvbnRleHRGcm9tQ2FudmFzID0gY3JlYXRlV2ViR0xSZW5kZXJpbmdDb250ZXh0RnJvbUNhbnZhcztcbmZ1bmN0aW9uIGNhbGxBbmRDaGVjayhnbCwgZnVuYykge1xuICAgIHZhciByZXR1cm5WYWx1ZSA9IGZ1bmMoKTtcbiAgICBjaGVja1dlYkdMRXJyb3IoZ2wpO1xuICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbn1cbmV4cG9ydHMuY2FsbEFuZENoZWNrID0gY2FsbEFuZENoZWNrO1xudmFyIHdlYkdMRGVidWdFcnJvckNoZWNraW5nRW5hYmxlZCA9IGZhbHNlO1xuZnVuY3Rpb24gZW5hYmxlRGVidWdXZWJHTEVycm9yQ2hlY2tpbmcoZW5hYmxlZCkge1xuICAgIHdlYkdMRGVidWdFcnJvckNoZWNraW5nRW5hYmxlZCA9IGVuYWJsZWQ7XG59XG5leHBvcnRzLmVuYWJsZURlYnVnV2ViR0xFcnJvckNoZWNraW5nID0gZW5hYmxlRGVidWdXZWJHTEVycm9yQ2hlY2tpbmc7XG5mdW5jdGlvbiBjaGVja1dlYkdMRXJyb3IoZ2wpIHtcbiAgICBpZiAod2ViR0xEZWJ1Z0Vycm9yQ2hlY2tpbmdFbmFibGVkKSB7XG4gICAgICAgIHZhciBlcnJvciA9IGdsLmdldEVycm9yKCk7XG4gICAgICAgIGlmIChlcnJvciAhPT0gZ2wuTk9fRVJST1IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignV2ViR0wgRXJyb3I6ICcgKyBnZXRXZWJHTEVycm9yTWVzc2FnZShnbCwgZXJyb3IpKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuY2hlY2tXZWJHTEVycm9yID0gY2hlY2tXZWJHTEVycm9yO1xuZnVuY3Rpb24gZ2V0V2ViR0xFcnJvck1lc3NhZ2UoZ2wsIHN0YXR1cykge1xuICAgIHN3aXRjaCAoc3RhdHVzKSB7XG4gICAgICAgIGNhc2UgZ2wuTk9fRVJST1I6XG4gICAgICAgICAgICByZXR1cm4gJ05PX0VSUk9SJztcbiAgICAgICAgY2FzZSBnbC5JTlZBTElEX0VOVU06XG4gICAgICAgICAgICByZXR1cm4gJ0lOVkFMSURfRU5VTSc7XG4gICAgICAgIGNhc2UgZ2wuSU5WQUxJRF9WQUxVRTpcbiAgICAgICAgICAgIHJldHVybiAnSU5WQUxJRF9WQUxVRSc7XG4gICAgICAgIGNhc2UgZ2wuSU5WQUxJRF9PUEVSQVRJT046XG4gICAgICAgICAgICByZXR1cm4gJ0lOVkFMSURfT1BFUkFUSU9OJztcbiAgICAgICAgY2FzZSBnbC5JTlZBTElEX0ZSQU1FQlVGRkVSX09QRVJBVElPTjpcbiAgICAgICAgICAgIHJldHVybiAnSU5WQUxJRF9GUkFNRUJVRkZFUl9PUEVSQVRJT04nO1xuICAgICAgICBjYXNlIGdsLk9VVF9PRl9NRU1PUlk6XG4gICAgICAgICAgICByZXR1cm4gJ09VVF9PRl9NRU1PUlknO1xuICAgICAgICBjYXNlIGdsLkNPTlRFWFRfTE9TVF9XRUJHTDpcbiAgICAgICAgICAgIHJldHVybiAnQ09OVEVYVF9MT1NUX1dFQkdMJztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBcIlVua25vd24gZXJyb3IgY29kZSBcIiArIHN0YXR1cztcbiAgICB9XG59XG5leHBvcnRzLmdldFdlYkdMRXJyb3JNZXNzYWdlID0gZ2V0V2ViR0xFcnJvck1lc3NhZ2U7XG5mdW5jdGlvbiBnZXRFeHRlbnNpb25PclRocm93KGdsLCBleHRlbnNpb25OYW1lKSB7XG4gICAgcmV0dXJuIHRocm93SWZOdWxsKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5nZXRFeHRlbnNpb24oZXh0ZW5zaW9uTmFtZSk7IH0sICdFeHRlbnNpb24gXCInICsgZXh0ZW5zaW9uTmFtZSArICdcIiBub3Qgc3VwcG9ydGVkIG9uIHRoaXMgYnJvd3Nlci4nKTtcbn1cbmV4cG9ydHMuZ2V0RXh0ZW5zaW9uT3JUaHJvdyA9IGdldEV4dGVuc2lvbk9yVGhyb3c7XG5mdW5jdGlvbiBjcmVhdGVWZXJ0ZXhTaGFkZXIoZ2wsIHZlcnRleFNoYWRlclNvdXJjZSkge1xuICAgIHZhciB2ZXJ0ZXhTaGFkZXIgPSB0aHJvd0lmTnVsbChnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuY3JlYXRlU2hhZGVyKGdsLlZFUlRFWF9TSEFERVIpOyB9LCAnVW5hYmxlIHRvIGNyZWF0ZSB2ZXJ0ZXggV2ViR0xTaGFkZXIuJyk7XG4gICAgY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5zaGFkZXJTb3VyY2UodmVydGV4U2hhZGVyLCB2ZXJ0ZXhTaGFkZXJTb3VyY2UpOyB9KTtcbiAgICBjYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmNvbXBpbGVTaGFkZXIodmVydGV4U2hhZGVyKTsgfSk7XG4gICAgaWYgKGdsLmdldFNoYWRlclBhcmFtZXRlcih2ZXJ0ZXhTaGFkZXIsIGdsLkNPTVBJTEVfU1RBVFVTKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgY29uc29sZS5sb2coZ2wuZ2V0U2hhZGVySW5mb0xvZyh2ZXJ0ZXhTaGFkZXIpKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gY29tcGlsZSB2ZXJ0ZXggc2hhZGVyLicpO1xuICAgIH1cbiAgICByZXR1cm4gdmVydGV4U2hhZGVyO1xufVxuZXhwb3J0cy5jcmVhdGVWZXJ0ZXhTaGFkZXIgPSBjcmVhdGVWZXJ0ZXhTaGFkZXI7XG5mdW5jdGlvbiBjcmVhdGVGcmFnbWVudFNoYWRlcihnbCwgZnJhZ21lbnRTaGFkZXJTb3VyY2UpIHtcbiAgICB2YXIgZnJhZ21lbnRTaGFkZXIgPSB0aHJvd0lmTnVsbChnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuY3JlYXRlU2hhZGVyKGdsLkZSQUdNRU5UX1NIQURFUik7IH0sICdVbmFibGUgdG8gY3JlYXRlIGZyYWdtZW50IFdlYkdMU2hhZGVyLicpO1xuICAgIGNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuc2hhZGVyU291cmNlKGZyYWdtZW50U2hhZGVyLCBmcmFnbWVudFNoYWRlclNvdXJjZSk7IH0pO1xuICAgIGNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuY29tcGlsZVNoYWRlcihmcmFnbWVudFNoYWRlcik7IH0pO1xuICAgIGlmIChnbC5nZXRTaGFkZXJQYXJhbWV0ZXIoZnJhZ21lbnRTaGFkZXIsIGdsLkNPTVBJTEVfU1RBVFVTKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgbG9nU2hhZGVyU291cmNlQW5kSW5mb0xvZyhmcmFnbWVudFNoYWRlclNvdXJjZSwgZ2wuZ2V0U2hhZGVySW5mb0xvZyhmcmFnbWVudFNoYWRlcikpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBjb21waWxlIGZyYWdtZW50IHNoYWRlci4nKTtcbiAgICB9XG4gICAgcmV0dXJuIGZyYWdtZW50U2hhZGVyO1xufVxuZXhwb3J0cy5jcmVhdGVGcmFnbWVudFNoYWRlciA9IGNyZWF0ZUZyYWdtZW50U2hhZGVyO1xudmFyIGxpbmVOdW1iZXJSZWdleCA9IC9FUlJPUjogWzAtOV0rOihbMC05XSspOi9nO1xuZnVuY3Rpb24gbG9nU2hhZGVyU291cmNlQW5kSW5mb0xvZyhzaGFkZXJTb3VyY2UsIHNoYWRlckluZm9Mb2cpIHtcbiAgICB2YXIgbGluZU51bWJlclJlZ2V4UmVzdWx0ID0gbGluZU51bWJlclJlZ2V4LmV4ZWMoc2hhZGVySW5mb0xvZyk7XG4gICAgaWYgKGxpbmVOdW1iZXJSZWdleFJlc3VsdCA9PSBudWxsKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiQ291bGRuJ3QgcGFyc2UgbGluZSBudW1iZXIgaW4gZXJyb3I6IFwiICsgc2hhZGVySW5mb0xvZyk7XG4gICAgICAgIGNvbnNvbGUubG9nKHNoYWRlclNvdXJjZSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGxpbmVOdW1iZXIgPSArbGluZU51bWJlclJlZ2V4UmVzdWx0WzFdO1xuICAgIHZhciBzaGFkZXJMaW5lcyA9IHNoYWRlclNvdXJjZS5zcGxpdCgnXFxuJyk7XG4gICAgdmFyIHBhZCA9IHNoYWRlckxpbmVzLmxlbmd0aC50b1N0cmluZygpLmxlbmd0aCArIDI7XG4gICAgdmFyIGxpbmVzV2l0aExpbmVOdW1iZXJzID0gc2hhZGVyTGluZXMubWFwKGZ1bmN0aW9uIChsaW5lLCBsaW5lTnVtYmVyKSB7XG4gICAgICAgIHJldHVybiB1dGlsLnJpZ2h0UGFkKChsaW5lTnVtYmVyICsgMSkudG9TdHJpbmcoKSwgcGFkKSArIGxpbmU7XG4gICAgfSk7XG4gICAgdmFyIG1heExpbmVMZW5ndGggPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZXNXaXRoTGluZU51bWJlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbWF4TGluZUxlbmd0aCA9IE1hdGgubWF4KGxpbmVzV2l0aExpbmVOdW1iZXJzW2ldLmxlbmd0aCwgbWF4TGluZUxlbmd0aCk7XG4gICAgfVxuICAgIHZhciBiZWZvcmVFcnJvckxpbmVzID0gbGluZXNXaXRoTGluZU51bWJlcnMuc2xpY2UoMCwgbGluZU51bWJlciAtIDEpO1xuICAgIHZhciBlcnJvckxpbmUgPSBsaW5lc1dpdGhMaW5lTnVtYmVycy5zbGljZShsaW5lTnVtYmVyIC0gMSwgbGluZU51bWJlcik7XG4gICAgdmFyIGFmdGVyRXJyb3JMaW5lcyA9IGxpbmVzV2l0aExpbmVOdW1iZXJzLnNsaWNlKGxpbmVOdW1iZXIpO1xuICAgIGNvbnNvbGUubG9nKGJlZm9yZUVycm9yTGluZXMuam9pbignXFxuJykpO1xuICAgIGNvbnNvbGUubG9nKHNoYWRlckluZm9Mb2cuc3BsaXQoJ1xcbicpWzBdKTtcbiAgICBjb25zb2xlLmxvZyhcIiVjIFwiICsgdXRpbC5yaWdodFBhZChlcnJvckxpbmVbMF0sIG1heExpbmVMZW5ndGgpLCAnYm9yZGVyOjFweCBzb2xpZCByZWQ7IGJhY2tncm91bmQtY29sb3I6I2UzZDJkMjsgY29sb3I6I2E2MTcxNycpO1xuICAgIGNvbnNvbGUubG9nKGFmdGVyRXJyb3JMaW5lcy5qb2luKCdcXG4nKSk7XG59XG5mdW5jdGlvbiBjcmVhdGVQcm9ncmFtKGdsKSB7XG4gICAgcmV0dXJuIHRocm93SWZOdWxsKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5jcmVhdGVQcm9ncmFtKCk7IH0sICdVbmFibGUgdG8gY3JlYXRlIFdlYkdMUHJvZ3JhbS4nKTtcbn1cbmV4cG9ydHMuY3JlYXRlUHJvZ3JhbSA9IGNyZWF0ZVByb2dyYW07XG5mdW5jdGlvbiBsaW5rUHJvZ3JhbShnbCwgcHJvZ3JhbSkge1xuICAgIGNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wubGlua1Byb2dyYW0ocHJvZ3JhbSk7IH0pO1xuICAgIGlmIChnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKHByb2dyYW0sIGdsLkxJTktfU1RBVFVTKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgY29uc29sZS5sb2coZ2wuZ2V0UHJvZ3JhbUluZm9Mb2cocHJvZ3JhbSkpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBsaW5rIHZlcnRleCBhbmQgZnJhZ21lbnQgc2hhZGVycy4nKTtcbiAgICB9XG59XG5leHBvcnRzLmxpbmtQcm9ncmFtID0gbGlua1Byb2dyYW07XG5mdW5jdGlvbiB2YWxpZGF0ZVByb2dyYW0oZ2wsIHByb2dyYW0pIHtcbiAgICBjYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLnZhbGlkYXRlUHJvZ3JhbShwcm9ncmFtKTsgfSk7XG4gICAgaWYgKGdsLmdldFByb2dyYW1QYXJhbWV0ZXIocHJvZ3JhbSwgZ2wuVkFMSURBVEVfU1RBVFVTKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgY29uc29sZS5sb2coZ2wuZ2V0UHJvZ3JhbUluZm9Mb2cocHJvZ3JhbSkpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NoYWRlciBwcm9ncmFtIHZhbGlkYXRpb24gZmFpbGVkLicpO1xuICAgIH1cbn1cbmV4cG9ydHMudmFsaWRhdGVQcm9ncmFtID0gdmFsaWRhdGVQcm9ncmFtO1xuZnVuY3Rpb24gY3JlYXRlU3RhdGljVmVydGV4QnVmZmVyKGdsLCBkYXRhKSB7XG4gICAgdmFyIGJ1ZmZlciA9IHRocm93SWZOdWxsKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5jcmVhdGVCdWZmZXIoKTsgfSwgJ1VuYWJsZSB0byBjcmVhdGUgV2ViR0xCdWZmZXInKTtcbiAgICBjYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBidWZmZXIpOyB9KTtcbiAgICBjYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCBkYXRhLCBnbC5TVEFUSUNfRFJBVyk7IH0pO1xuICAgIHJldHVybiBidWZmZXI7XG59XG5leHBvcnRzLmNyZWF0ZVN0YXRpY1ZlcnRleEJ1ZmZlciA9IGNyZWF0ZVN0YXRpY1ZlcnRleEJ1ZmZlcjtcbmZ1bmN0aW9uIGNyZWF0ZVN0YXRpY0luZGV4QnVmZmVyKGdsLCBkYXRhKSB7XG4gICAgdmFyIGJ1ZmZlciA9IHRocm93SWZOdWxsKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5jcmVhdGVCdWZmZXIoKTsgfSwgJ1VuYWJsZSB0byBjcmVhdGUgV2ViR0xCdWZmZXInKTtcbiAgICBjYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmJpbmRCdWZmZXIoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIGJ1ZmZlcik7IH0pO1xuICAgIGNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuYnVmZmVyRGF0YShnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgZGF0YSwgZ2wuU1RBVElDX0RSQVcpOyB9KTtcbiAgICByZXR1cm4gYnVmZmVyO1xufVxuZXhwb3J0cy5jcmVhdGVTdGF0aWNJbmRleEJ1ZmZlciA9IGNyZWF0ZVN0YXRpY0luZGV4QnVmZmVyO1xuZnVuY3Rpb24gcXVlcnlNYXhUZXh0dXJlU2l6ZShnbCkge1xuICAgIGlmIChNQVhfVEVYVFVSRV9TSVpFICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIE1BWF9URVhUVVJFX1NJWkU7XG4gICAgfVxuICAgIE1BWF9URVhUVVJFX1NJWkUgPVxuICAgICAgICBjYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmdldFBhcmFtZXRlcihnbC5NQVhfVEVYVFVSRV9TSVpFKTsgfSk7XG4gICAgcmV0dXJuIE1BWF9URVhUVVJFX1NJWkU7XG59XG5leHBvcnRzLnF1ZXJ5TWF4VGV4dHVyZVNpemUgPSBxdWVyeU1heFRleHR1cmVTaXplO1xuZnVuY3Rpb24gZ2V0Q2hhbm5lbHNQZXJUZXh0dXJlKCkge1xuICAgIGlmICghZW52aXJvbm1lbnRfMS5FTlYuZ2V0KCdXRUJHTF9GTE9BVF9URVhUVVJFX0VOQUJMRUQnKSkge1xuICAgICAgICByZXR1cm4gNDtcbiAgICB9XG4gICAgaWYgKGVudmlyb25tZW50XzEuRU5WLmdldCgnV0VCR0xfVkVSU0lPTicpID09PSAyKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICByZXR1cm4gNDtcbn1cbmV4cG9ydHMuZ2V0Q2hhbm5lbHNQZXJUZXh0dXJlID0gZ2V0Q2hhbm5lbHNQZXJUZXh0dXJlO1xuZnVuY3Rpb24gY3JlYXRlVGV4dHVyZShnbCkge1xuICAgIHJldHVybiB0aHJvd0lmTnVsbChnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuY3JlYXRlVGV4dHVyZSgpOyB9LCAnVW5hYmxlIHRvIGNyZWF0ZSBXZWJHTFRleHR1cmUuJyk7XG59XG5leHBvcnRzLmNyZWF0ZVRleHR1cmUgPSBjcmVhdGVUZXh0dXJlO1xuZnVuY3Rpb24gdmFsaWRhdGVUZXh0dXJlU2l6ZShnbCwgd2lkdGgsIGhlaWdodCkge1xuICAgIHZhciBtYXhUZXh0dXJlU2l6ZSA9IHF1ZXJ5TWF4VGV4dHVyZVNpemUoZ2wpO1xuICAgIGlmICgod2lkdGggPD0gMCkgfHwgKGhlaWdodCA8PSAwKSkge1xuICAgICAgICB2YXIgcmVxdWVzdGVkID0gXCJbXCIgKyB3aWR0aCArIFwieFwiICsgaGVpZ2h0ICsgXCJdXCI7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUmVxdWVzdGVkIHRleHR1cmUgc2l6ZSAnICsgcmVxdWVzdGVkICsgJyBpcyBpbnZhbGlkLicpO1xuICAgIH1cbiAgICBpZiAoKHdpZHRoID4gbWF4VGV4dHVyZVNpemUpIHx8IChoZWlnaHQgPiBtYXhUZXh0dXJlU2l6ZSkpIHtcbiAgICAgICAgdmFyIHJlcXVlc3RlZCA9IFwiW1wiICsgd2lkdGggKyBcInhcIiArIGhlaWdodCArIFwiXVwiO1xuICAgICAgICB2YXIgbWF4ID0gXCJbXCIgKyBtYXhUZXh0dXJlU2l6ZSArIFwieFwiICsgbWF4VGV4dHVyZVNpemUgKyBcIl1cIjtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZXF1ZXN0ZWQgdGV4dHVyZSBzaXplICcgKyByZXF1ZXN0ZWQgK1xuICAgICAgICAgICAgJyBncmVhdGVyIHRoYW4gV2ViR0wgbWF4aW11bSBvbiB0aGlzIGJyb3dzZXIgLyBHUFUgJyArIG1heCArICcuJyk7XG4gICAgfVxufVxuZXhwb3J0cy52YWxpZGF0ZVRleHR1cmVTaXplID0gdmFsaWRhdGVUZXh0dXJlU2l6ZTtcbmZ1bmN0aW9uIGNyZWF0ZUZyYW1lYnVmZmVyKGdsKSB7XG4gICAgcmV0dXJuIHRocm93SWZOdWxsKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5jcmVhdGVGcmFtZWJ1ZmZlcigpOyB9LCAnVW5hYmxlIHRvIGNyZWF0ZSBXZWJHTEZyYW1lYnVmZmVyLicpO1xufVxuZXhwb3J0cy5jcmVhdGVGcmFtZWJ1ZmZlciA9IGNyZWF0ZUZyYW1lYnVmZmVyO1xuZnVuY3Rpb24gYmluZFZlcnRleEJ1ZmZlclRvUHJvZ3JhbUF0dHJpYnV0ZShnbCwgcHJvZ3JhbSwgYXR0cmlidXRlLCBidWZmZXIsIGFycmF5RW50cmllc1Blckl0ZW0sIGl0ZW1TdHJpZGVJbkJ5dGVzLCBpdGVtT2Zmc2V0SW5CeXRlcywgYXR0cmliTG9jYXRpb25zKSB7XG4gICAgdmFyIGxvYyA9IC0xO1xuICAgIGlmICgoYXR0cmliTG9jYXRpb25zICE9IG51bGwpICYmIChhdHRyaWJ1dGUgaW4gYXR0cmliTG9jYXRpb25zKSkge1xuICAgICAgICBsb2MgPSBhdHRyaWJMb2NhdGlvbnNbYXR0cmlidXRlXTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGxvYyA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sIGF0dHJpYnV0ZSk7XG4gICAgfVxuICAgIGlmIChsb2MgPT09IC0xKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgYnVmZmVyKTsgfSk7XG4gICAgY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKGxvYywgYXJyYXlFbnRyaWVzUGVySXRlbSwgZ2wuRkxPQVQsIGZhbHNlLCBpdGVtU3RyaWRlSW5CeXRlcywgaXRlbU9mZnNldEluQnl0ZXMpOyB9KTtcbiAgICBjYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGxvYyk7IH0pO1xufVxuZXhwb3J0cy5iaW5kVmVydGV4QnVmZmVyVG9Qcm9ncmFtQXR0cmlidXRlID0gYmluZFZlcnRleEJ1ZmZlclRvUHJvZ3JhbUF0dHJpYnV0ZTtcbmZ1bmN0aW9uIGJpbmRUZXh0dXJlVW5pdChnbCwgdGV4dHVyZSwgdGV4dHVyZVVuaXQpIHtcbiAgICB2YWxpZGF0ZVRleHR1cmVVbml0KGdsLCB0ZXh0dXJlVW5pdCk7XG4gICAgY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwICsgdGV4dHVyZVVuaXQpOyB9KTtcbiAgICBjYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRleHR1cmUpOyB9KTtcbn1cbmV4cG9ydHMuYmluZFRleHR1cmVVbml0ID0gYmluZFRleHR1cmVVbml0O1xuZnVuY3Rpb24gdW5iaW5kVGV4dHVyZVVuaXQoZ2wsIHRleHR1cmVVbml0KSB7XG4gICAgdmFsaWRhdGVUZXh0dXJlVW5pdChnbCwgdGV4dHVyZVVuaXQpO1xuICAgIGNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCArIHRleHR1cmVVbml0KTsgfSk7XG4gICAgY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBudWxsKTsgfSk7XG59XG5leHBvcnRzLnVuYmluZFRleHR1cmVVbml0ID0gdW5iaW5kVGV4dHVyZVVuaXQ7XG5mdW5jdGlvbiBnZXRQcm9ncmFtVW5pZm9ybUxvY2F0aW9uT3JUaHJvdyhnbCwgcHJvZ3JhbSwgdW5pZm9ybU5hbWUpIHtcbiAgICByZXR1cm4gdGhyb3dJZk51bGwoZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCB1bmlmb3JtTmFtZSk7IH0sICd1bmlmb3JtIFwiJyArIHVuaWZvcm1OYW1lICsgJ1wiIG5vdCBwcmVzZW50IGluIHByb2dyYW0uJyk7XG59XG5leHBvcnRzLmdldFByb2dyYW1Vbmlmb3JtTG9jYXRpb25PclRocm93ID0gZ2V0UHJvZ3JhbVVuaWZvcm1Mb2NhdGlvbk9yVGhyb3c7XG5mdW5jdGlvbiBiaW5kVGV4dHVyZVRvUHJvZ3JhbVVuaWZvcm1TYW1wbGVyKGdsLCBwcm9ncmFtLCB0ZXh0dXJlLCB1bmlmb3JtU2FtcGxlckxvY2F0aW9uLCB0ZXh0dXJlVW5pdCkge1xuICAgIGNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gYmluZFRleHR1cmVVbml0KGdsLCB0ZXh0dXJlLCB0ZXh0dXJlVW5pdCk7IH0pO1xuICAgIGNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wudW5pZm9ybTFpKHVuaWZvcm1TYW1wbGVyTG9jYXRpb24sIHRleHR1cmVVbml0KTsgfSk7XG59XG5leHBvcnRzLmJpbmRUZXh0dXJlVG9Qcm9ncmFtVW5pZm9ybVNhbXBsZXIgPSBiaW5kVGV4dHVyZVRvUHJvZ3JhbVVuaWZvcm1TYW1wbGVyO1xuZnVuY3Rpb24gYmluZENhbnZhc1RvRnJhbWVidWZmZXIoZ2wpIHtcbiAgICBjYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgbnVsbCk7IH0pO1xuICAgIGNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wudmlld3BvcnQoMCwgMCwgZ2wuY2FudmFzLndpZHRoLCBnbC5jYW52YXMuaGVpZ2h0KTsgfSk7XG4gICAgY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5zY2lzc29yKDAsIDAsIGdsLmNhbnZhcy53aWR0aCwgZ2wuY2FudmFzLmhlaWdodCk7IH0pO1xufVxuZXhwb3J0cy5iaW5kQ2FudmFzVG9GcmFtZWJ1ZmZlciA9IGJpbmRDYW52YXNUb0ZyYW1lYnVmZmVyO1xuZnVuY3Rpb24gYmluZENvbG9yVGV4dHVyZVRvRnJhbWVidWZmZXIoZ2wsIHRleHR1cmUsIGZyYW1lYnVmZmVyKSB7XG4gICAgY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIGZyYW1lYnVmZmVyKTsgfSk7XG4gICAgY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChnbC5GUkFNRUJVRkZFUiwgZ2wuQ09MT1JfQVRUQUNITUVOVDAsIGdsLlRFWFRVUkVfMkQsIHRleHR1cmUsIDApOyB9KTtcbn1cbmV4cG9ydHMuYmluZENvbG9yVGV4dHVyZVRvRnJhbWVidWZmZXIgPSBiaW5kQ29sb3JUZXh0dXJlVG9GcmFtZWJ1ZmZlcjtcbmZ1bmN0aW9uIHVuYmluZENvbG9yVGV4dHVyZUZyb21GcmFtZWJ1ZmZlcihnbCwgZnJhbWVidWZmZXIpIHtcbiAgICBjYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgZnJhbWVidWZmZXIpOyB9KTtcbiAgICBjYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKGdsLkZSQU1FQlVGRkVSLCBnbC5DT0xPUl9BVFRBQ0hNRU5UMCwgZ2wuVEVYVFVSRV8yRCwgbnVsbCwgMCk7IH0pO1xufVxuZXhwb3J0cy51bmJpbmRDb2xvclRleHR1cmVGcm9tRnJhbWVidWZmZXIgPSB1bmJpbmRDb2xvclRleHR1cmVGcm9tRnJhbWVidWZmZXI7XG5mdW5jdGlvbiB2YWxpZGF0ZUZyYW1lYnVmZmVyKGdsKSB7XG4gICAgdmFyIHN0YXR1cyA9IGdsLmNoZWNrRnJhbWVidWZmZXJTdGF0dXMoZ2wuRlJBTUVCVUZGRVIpO1xuICAgIGlmIChzdGF0dXMgIT09IGdsLkZSQU1FQlVGRkVSX0NPTVBMRVRFKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXJyb3IgYmluZGluZyBmcmFtZWJ1ZmZlcjogJyArIGdldEZyYW1lYnVmZmVyRXJyb3JNZXNzYWdlKGdsLCBzdGF0dXMpKTtcbiAgICB9XG59XG5leHBvcnRzLnZhbGlkYXRlRnJhbWVidWZmZXIgPSB2YWxpZGF0ZUZyYW1lYnVmZmVyO1xuZnVuY3Rpb24gZ2V0RnJhbWVidWZmZXJFcnJvck1lc3NhZ2UoZ2wsIHN0YXR1cykge1xuICAgIHN3aXRjaCAoc3RhdHVzKSB7XG4gICAgICAgIGNhc2UgZ2wuRlJBTUVCVUZGRVJfSU5DT01QTEVURV9BVFRBQ0hNRU5UOlxuICAgICAgICAgICAgcmV0dXJuICdGUkFNRUJVRkZFUl9JTkNPTVBMRVRFX0FUVEFDSE1FTlQnO1xuICAgICAgICBjYXNlIGdsLkZSQU1FQlVGRkVSX0lOQ09NUExFVEVfTUlTU0lOR19BVFRBQ0hNRU5UOlxuICAgICAgICAgICAgcmV0dXJuICdGUkFNRUJVRkZFUl9JTkNPTVBMRVRFX01JU1NJTkdfQVRUQUNITUVOVCc7XG4gICAgICAgIGNhc2UgZ2wuRlJBTUVCVUZGRVJfSU5DT01QTEVURV9ESU1FTlNJT05TOlxuICAgICAgICAgICAgcmV0dXJuICdGUkFNRUJVRkZFUl9JTkNPTVBMRVRFX0RJTUVOU0lPTlMnO1xuICAgICAgICBjYXNlIGdsLkZSQU1FQlVGRkVSX1VOU1VQUE9SVEVEOlxuICAgICAgICAgICAgcmV0dXJuICdGUkFNRUJVRkZFUl9VTlNVUFBPUlRFRCc7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gXCJ1bmtub3duIGVycm9yIFwiICsgc3RhdHVzO1xuICAgIH1cbn1cbmV4cG9ydHMuZ2V0RnJhbWVidWZmZXJFcnJvck1lc3NhZ2UgPSBnZXRGcmFtZWJ1ZmZlckVycm9yTWVzc2FnZTtcbmZ1bmN0aW9uIHRocm93SWZOdWxsKGdsLCByZXR1cm5UT3JOdWxsLCBmYWlsdXJlTWVzc2FnZSkge1xuICAgIHZhciB0T3JOdWxsID0gY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiByZXR1cm5UT3JOdWxsKCk7IH0pO1xuICAgIGlmICh0T3JOdWxsID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGZhaWx1cmVNZXNzYWdlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRPck51bGw7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZVRleHR1cmVVbml0KGdsLCB0ZXh0dXJlVW5pdCkge1xuICAgIHZhciBtYXhUZXh0dXJlVW5pdCA9IGdsLk1BWF9DT01CSU5FRF9URVhUVVJFX0lNQUdFX1VOSVRTIC0gMTtcbiAgICB2YXIgZ2xUZXh0dXJlVW5pdCA9IHRleHR1cmVVbml0ICsgZ2wuVEVYVFVSRTA7XG4gICAgaWYgKGdsVGV4dHVyZVVuaXQgPCBnbC5URVhUVVJFMCB8fCBnbFRleHR1cmVVbml0ID4gbWF4VGV4dHVyZVVuaXQpIHtcbiAgICAgICAgdmFyIHRleHR1cmVVbml0UmFuZ2UgPSBcIltnbC5URVhUVVJFMCwgZ2wuVEVYVFVSRVwiICsgbWF4VGV4dHVyZVVuaXQgKyBcIl1cIjtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidGV4dHVyZVVuaXQgbXVzdCBiZSBpbiBcIiArIHRleHR1cmVVbml0UmFuZ2UgKyBcIi5cIik7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0VGV4dHVyZVNoYXBlRnJvbUxvZ2ljYWxTaGFwZShnbCwgbG9nU2hhcGUpIHtcbiAgICBpZiAobG9nU2hhcGUubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgIHZhciBzcXVlZXplUmVzdWx0ID0gdXRpbC5zcXVlZXplU2hhcGUobG9nU2hhcGUpO1xuICAgICAgICBsb2dTaGFwZSA9IHNxdWVlemVSZXN1bHQubmV3U2hhcGU7XG4gICAgfVxuICAgIHZhciBtYXhUZXhTaXplID0gcXVlcnlNYXhUZXh0dXJlU2l6ZShnbCk7XG4gICAgdmFyIHNpemUgPSB1dGlsLnNpemVGcm9tU2hhcGUobG9nU2hhcGUpO1xuICAgIGlmIChsb2dTaGFwZS5sZW5ndGggPD0gMSAmJiBzaXplIDw9IG1heFRleFNpemUpIHtcbiAgICAgICAgcmV0dXJuIFtzaXplLCAxXTtcbiAgICB9XG4gICAgZWxzZSBpZiAobG9nU2hhcGUubGVuZ3RoID09PSAyICYmIGxvZ1NoYXBlWzBdIDw9IG1heFRleFNpemUgJiZcbiAgICAgICAgbG9nU2hhcGVbMV0gPD0gbWF4VGV4U2l6ZSkge1xuICAgICAgICByZXR1cm4gbG9nU2hhcGU7XG4gICAgfVxuICAgIGVsc2UgaWYgKGxvZ1NoYXBlLmxlbmd0aCA9PT0gMyAmJiBsb2dTaGFwZVswXSA8PSBtYXhUZXhTaXplICYmXG4gICAgICAgIGxvZ1NoYXBlWzFdICogbG9nU2hhcGVbMl0gPD0gbWF4VGV4U2l6ZSkge1xuICAgICAgICByZXR1cm4gW2xvZ1NoYXBlWzBdLCBsb2dTaGFwZVsxXSAqIGxvZ1NoYXBlWzJdXTtcbiAgICB9XG4gICAgZWxzZSBpZiAobG9nU2hhcGUubGVuZ3RoID09PSA0ICYmIGxvZ1NoYXBlWzBdIDw9IG1heFRleFNpemUgJiZcbiAgICAgICAgbG9nU2hhcGVbMV0gKiBsb2dTaGFwZVsyXSAqIGxvZ1NoYXBlWzNdIDw9IG1heFRleFNpemUpIHtcbiAgICAgICAgcmV0dXJuIFtsb2dTaGFwZVswXSwgbG9nU2hhcGVbMV0gKiBsb2dTaGFwZVsyXSAqIGxvZ1NoYXBlWzNdXTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB1dGlsLnNpemVUb1NxdWFyaXNoU2hhcGUoc2l6ZSk7XG4gICAgfVxufVxuZXhwb3J0cy5nZXRUZXh0dXJlU2hhcGVGcm9tTG9naWNhbFNoYXBlID0gZ2V0VGV4dHVyZVNoYXBlRnJvbUxvZ2ljYWxTaGFwZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdlYmdsX3V0aWwuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZW52aXJvbm1lbnQgPSByZXF1aXJlKFwiLi9lbnZpcm9ubWVudFwiKTtcbnZhciBlbnZpcm9ubWVudF8xID0gcmVxdWlyZShcIi4vZW52aXJvbm1lbnRcIik7XG52YXIgbWF0aF9jcHVfMSA9IHJlcXVpcmUoXCIuL21hdGgvbWF0aF9jcHVcIik7XG52YXIgbWF0aF9ncHVfMSA9IHJlcXVpcmUoXCIuL21hdGgvbWF0aF9ncHVcIik7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG5leHBvcnRzLlRFU1RfRVBTSUxPTiA9IDFlLTI7XG5mdW5jdGlvbiBtZWFuKHZhbHVlcykge1xuICAgIHZhciBzdW0gPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHN1bSArPSB2YWx1ZXNbaV07XG4gICAgfVxuICAgIHJldHVybiBzdW0gLyB2YWx1ZXMubGVuZ3RoO1xufVxuZXhwb3J0cy5tZWFuID0gbWVhbjtcbmZ1bmN0aW9uIHN0YW5kYXJkRGV2aWF0aW9uKHZhbHVlcywgbWVhbikge1xuICAgIHZhciBzcXVhcmVEaWZmU3VtID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZGlmZiA9IHZhbHVlc1tpXSAtIG1lYW47XG4gICAgICAgIHNxdWFyZURpZmZTdW0gKz0gZGlmZiAqIGRpZmY7XG4gICAgfVxuICAgIHJldHVybiBNYXRoLnNxcnQoc3F1YXJlRGlmZlN1bSAvIHZhbHVlcy5sZW5ndGgpO1xufVxuZXhwb3J0cy5zdGFuZGFyZERldmlhdGlvbiA9IHN0YW5kYXJkRGV2aWF0aW9uO1xuZnVuY3Rpb24ga3VydG9zaXModmFsdWVzKSB7XG4gICAgdmFyIHZhbHVlc01lYW4gPSBtZWFuKHZhbHVlcyk7XG4gICAgdmFyIG4gPSB2YWx1ZXMubGVuZ3RoO1xuICAgIHZhciBzdW0yID0gMDtcbiAgICB2YXIgc3VtNCA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgdmFyIHYgPSB2YWx1ZXNbaV0gLSB2YWx1ZXNNZWFuO1xuICAgICAgICBzdW0yICs9IE1hdGgucG93KHYsIDIpO1xuICAgICAgICBzdW00ICs9IE1hdGgucG93KHYsIDQpO1xuICAgIH1cbiAgICByZXR1cm4gKDEgLyBuKSAqIHN1bTQgLyBNYXRoLnBvdygoMSAvIG4pICogc3VtMiwgMikgLSAzO1xufVxuZXhwb3J0cy5rdXJ0b3NpcyA9IGt1cnRvc2lzO1xuZnVuY3Rpb24gc2tld25lc3ModmFsdWVzKSB7XG4gICAgdmFyIHZhbHVlc01lYW4gPSBtZWFuKHZhbHVlcyk7XG4gICAgdmFyIG4gPSB2YWx1ZXMubGVuZ3RoO1xuICAgIHZhciBzdW0yID0gMDtcbiAgICB2YXIgc3VtMyA9IDA7XG4gICAgdmFyIGkgPSAtMTtcbiAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgICB2YXIgdiA9IHZhbHVlc1tpXSAtIHZhbHVlc01lYW47XG4gICAgICAgIHN1bTIgKz0gTWF0aC5wb3codiwgMik7XG4gICAgICAgIHN1bTMgKz0gTWF0aC5wb3codiwgMyk7XG4gICAgfVxuICAgIHJldHVybiAoMSAvIG4pICogc3VtMyAvIE1hdGgucG93KCgxIC8gKG4gLSAxKSkgKiBzdW0yLCAzIC8gMik7XG59XG5leHBvcnRzLnNrZXduZXNzID0gc2tld25lc3M7XG5mdW5jdGlvbiBqYXJxdWVCZXJhTm9ybWFsaXR5VGVzdCh2YWx1ZXMpIHtcbiAgICB2YXIgcyA9IHNrZXduZXNzKHZhbHVlcyk7XG4gICAgdmFyIGsgPSBrdXJ0b3Npcyh2YWx1ZXMpO1xuICAgIHZhciBqYiA9IHZhbHVlcy5sZW5ndGggKiAoKE1hdGgucG93KHMsIDIpIC8gNikgKyAoTWF0aC5wb3coaywgMikgLyAyNCkpO1xuICAgIHZhciBDSElfU1FVQVJFXzJERUcgPSA1Ljk5MTtcbiAgICBpZiAoamIgPiBDSElfU1FVQVJFXzJERUcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBwLXZhbHVlIGZvciBKQjogXCIgKyBqYik7XG4gICAgfVxufVxuZXhwb3J0cy5qYXJxdWVCZXJhTm9ybWFsaXR5VGVzdCA9IGphcnF1ZUJlcmFOb3JtYWxpdHlUZXN0O1xuZnVuY3Rpb24gZXhwZWN0QXJyYXlJbk1lYW5TdGRSYW5nZShhY3R1YWwsIGV4cGVjdGVkTWVhbiwgZXhwZWN0ZWRTdGREZXYsIGVwc2lsb24pIHtcbiAgICBpZiAoZXBzaWxvbiA9PT0gdm9pZCAwKSB7IGVwc2lsb24gPSBleHBvcnRzLlRFU1RfRVBTSUxPTjsgfVxuICAgIHZhciBhY3R1YWxNZWFuID0gbWVhbihhY3R1YWwpO1xuICAgIGV4cGVjdE51bWJlcnNDbG9zZShhY3R1YWxNZWFuLCBleHBlY3RlZE1lYW4sIGVwc2lsb24pO1xuICAgIGV4cGVjdE51bWJlcnNDbG9zZShzdGFuZGFyZERldmlhdGlvbihhY3R1YWwsIGFjdHVhbE1lYW4pLCBleHBlY3RlZFN0ZERldiwgZXBzaWxvbik7XG59XG5leHBvcnRzLmV4cGVjdEFycmF5SW5NZWFuU3RkUmFuZ2UgPSBleHBlY3RBcnJheUluTWVhblN0ZFJhbmdlO1xuZnVuY3Rpb24gZXhwZWN0QXJyYXlzQ2xvc2UoYWN0dWFsLCBleHBlY3RlZCwgZXBzaWxvbikge1xuICAgIGlmIChlcHNpbG9uID09PSB2b2lkIDApIHsgZXBzaWxvbiA9IGV4cG9ydHMuVEVTVF9FUFNJTE9OOyB9XG4gICAgdmFyIGFUeXBlID0gYWN0dWFsLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgdmFyIGJUeXBlID0gZXhwZWN0ZWQuY29uc3RydWN0b3IubmFtZTtcbiAgICBpZiAoYVR5cGUgIT09IGJUeXBlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFycmF5cyBhcmUgb2YgZGlmZmVyZW50IHR5cGUgXCIgKyBhVHlwZSArIFwiIHZzIFwiICsgYlR5cGUpO1xuICAgIH1cbiAgICBpZiAoYWN0dWFsLmxlbmd0aCAhPT0gZXhwZWN0ZWQubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1hdHJpY2VzIGhhdmUgZGlmZmVyZW50IGxlbmd0aHMgKFwiICsgYWN0dWFsLmxlbmd0aCArIFwiIHZzIFwiICtcbiAgICAgICAgICAgIChleHBlY3RlZC5sZW5ndGggKyBcIikuXCIpKTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleHBlY3RlZC5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgYSA9IGFjdHVhbFtpXTtcbiAgICAgICAgdmFyIGUgPSBleHBlY3RlZFtpXTtcbiAgICAgICAgaWYgKCFhcmVDbG9zZShhLCBlLCBlcHNpbG9uKSkge1xuICAgICAgICAgICAgdmFyIGFjdHVhbFN0ciA9IFwiYWN0dWFsW1wiICsgaSArIFwiXSA9PT0gXCIgKyBhO1xuICAgICAgICAgICAgdmFyIGV4cGVjdGVkU3RyID0gXCJleHBlY3RlZFtcIiArIGkgKyBcIl0gPT09IFwiICsgZTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQXJyYXlzIGRpZmZlcjogJyArIGFjdHVhbFN0ciArICcsICcgKyBleHBlY3RlZFN0cik7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLmV4cGVjdEFycmF5c0Nsb3NlID0gZXhwZWN0QXJyYXlzQ2xvc2U7XG5mdW5jdGlvbiBleHBlY3ROdW1iZXJzQ2xvc2UoYSwgZSwgZXBzaWxvbikge1xuICAgIGlmIChlcHNpbG9uID09PSB2b2lkIDApIHsgZXBzaWxvbiA9IGV4cG9ydHMuVEVTVF9FUFNJTE9OOyB9XG4gICAgaWYgKCFhcmVDbG9zZShhLCBlLCBlcHNpbG9uKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOdW1iZXJzIGRpZmZlcjogYWN0dWFsID09PSBcIiArIGEgKyBcIiwgZXhwZWN0ZWQgPT09IFwiICsgZSk7XG4gICAgfVxufVxuZXhwb3J0cy5leHBlY3ROdW1iZXJzQ2xvc2UgPSBleHBlY3ROdW1iZXJzQ2xvc2U7XG5mdW5jdGlvbiBhcmVDbG9zZShhLCBlLCBlcHNpbG9uKSB7XG4gICAgaWYgKGlzTmFOKGEpICYmIGlzTmFOKGUpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoaXNOYU4oYSkgfHwgaXNOYU4oZSkgfHwgTWF0aC5hYnMoYSAtIGUpID4gZXBzaWxvbikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gZXhwZWN0VmFsdWVzSW5SYW5nZShhY3R1YWwsIGxvdywgaGlnaCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWN0dWFsLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChhY3R1YWxbaV0gPCBsb3cgfHwgYWN0dWFsW2ldID4gaGlnaCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVmFsdWUgb3V0IG9mIHJhbmdlOlwiICsgYWN0dWFsW2ldICsgXCIgbG93OiBcIiArIGxvdyArIFwiLCBoaWdoOiBcIiArIGhpZ2gpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5leHBlY3RWYWx1ZXNJblJhbmdlID0gZXhwZWN0VmFsdWVzSW5SYW5nZTtcbmZ1bmN0aW9uIHJhbmRvbUFycmF5SW5SYW5nZShuLCBtaW5WYWx1ZSwgbWF4VmFsdWUpIHtcbiAgICB2YXIgdiA9IG5ldyBGbG9hdDMyQXJyYXkobik7XG4gICAgdmFyIHJhbmdlID0gbWF4VmFsdWUgLSBtaW5WYWx1ZTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgICB2W2ldID0gKE1hdGgucmFuZG9tKCkgKiByYW5nZSkgKyBtaW5WYWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHY7XG59XG5leHBvcnRzLnJhbmRvbUFycmF5SW5SYW5nZSA9IHJhbmRvbUFycmF5SW5SYW5nZTtcbmZ1bmN0aW9uIG1ha2VJZGVudGl0eShuKSB7XG4gICAgdmFyIGkgPSBuZXcgRmxvYXQzMkFycmF5KG4gKiBuKTtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IG47ICsraikge1xuICAgICAgICBpWyhqICogbikgKyBqXSA9IDE7XG4gICAgfVxuICAgIHJldHVybiBpO1xufVxuZXhwb3J0cy5tYWtlSWRlbnRpdHkgPSBtYWtlSWRlbnRpdHk7XG5mdW5jdGlvbiBjcHVNdWx0aXBseU1hdHJpeChhLCBhUm93LCBhQ29sLCBiLCBiUm93LCBiQ29sKSB7XG4gICAgdmFyIHJlc3VsdCA9IG5ldyBGbG9hdDMyQXJyYXkoYVJvdyAqIGJDb2wpO1xuICAgIGZvciAodmFyIHIgPSAwOyByIDwgYVJvdzsgKytyKSB7XG4gICAgICAgIHZhciBhT2Zmc2V0ID0gKHIgKiBhQ29sKTtcbiAgICAgICAgdmFyIGNPZmZzZXQgPSAociAqIGJDb2wpO1xuICAgICAgICBmb3IgKHZhciBjID0gMDsgYyA8IGJDb2w7ICsrYykge1xuICAgICAgICAgICAgdmFyIGQgPSAwO1xuICAgICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBhQ29sOyArK2spIHtcbiAgICAgICAgICAgICAgICBkICs9IGFbYU9mZnNldCArIGtdICogYlsoayAqIGJDb2wpICsgY107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHRbY09mZnNldCArIGNdID0gZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0cy5jcHVNdWx0aXBseU1hdHJpeCA9IGNwdU11bHRpcGx5TWF0cml4O1xuZnVuY3Rpb24gY3B1RG90UHJvZHVjdChhLCBiKSB7XG4gICAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NwdURvdFByb2R1Y3Q6IGluY29tcGF0aWJsZSB2ZWN0b3JzLicpO1xuICAgIH1cbiAgICB2YXIgZCA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGQgKz0gYVtpXSAqIGJbaV07XG4gICAgfVxuICAgIHJldHVybiBkO1xufVxuZXhwb3J0cy5jcHVEb3RQcm9kdWN0ID0gY3B1RG90UHJvZHVjdDtcbmZ1bmN0aW9uIGRlc2NyaWJlTWF0aENQVShuYW1lLCB0ZXN0cywgZmVhdHVyZXNMaXN0KSB7XG4gICAgdmFyIHRlc3ROYW1lQmFzZSA9ICdtYXRoX2NwdS4nICsgbmFtZTtcbiAgICBkZXNjcmliZVdpdGhGZWF0dXJlc0FuZEV4ZWN1dG9yKHRlc3ROYW1lQmFzZSwgdGVzdHMsIGZ1bmN0aW9uICh0ZXN0TmFtZSwgdGVzdHMsIGZlYXR1cmVzKSB7IHJldHVybiBleGVjdXRlTWF0aFRlc3RzKHRlc3ROYW1lLCB0ZXN0cywgZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IG1hdGhfY3B1XzEuTkRBcnJheU1hdGhDUFUoKTsgfSwgZmVhdHVyZXMpOyB9LCBmZWF0dXJlc0xpc3QpO1xufVxuZXhwb3J0cy5kZXNjcmliZU1hdGhDUFUgPSBkZXNjcmliZU1hdGhDUFU7XG5mdW5jdGlvbiBkZXNjcmliZU1hdGhHUFUobmFtZSwgdGVzdHMsIGZlYXR1cmVzTGlzdCkge1xuICAgIHZhciB0ZXN0TmFtZUJhc2UgPSAnbWF0aF9ncHUuJyArIG5hbWU7XG4gICAgZGVzY3JpYmVXaXRoRmVhdHVyZXNBbmRFeGVjdXRvcih0ZXN0TmFtZUJhc2UsIHRlc3RzLCBmdW5jdGlvbiAodGVzdE5hbWUsIHRlc3RzLCBmZWF0dXJlcykgeyByZXR1cm4gZXhlY3V0ZU1hdGhUZXN0cyh0ZXN0TmFtZSwgdGVzdHMsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBtYXRoX2dwdV8xLk5EQXJyYXlNYXRoR1BVKCk7IH0sIGZlYXR1cmVzKTsgfSwgZmVhdHVyZXNMaXN0KTtcbn1cbmV4cG9ydHMuZGVzY3JpYmVNYXRoR1BVID0gZGVzY3JpYmVNYXRoR1BVO1xuZnVuY3Rpb24gZGVzY3JpYmVDdXN0b20obmFtZSwgdGVzdHMsIGZlYXR1cmVzTGlzdCwgY3VzdG9tQmVmb3JlRWFjaCwgY3VzdG9tQWZ0ZXJFYWNoKSB7XG4gICAgZGVzY3JpYmVXaXRoRmVhdHVyZXNBbmRFeGVjdXRvcihuYW1lLCBbdGVzdHNdLCBmdW5jdGlvbiAodGVzdE5hbWUsIHRlc3RzLCBmZWF0dXJlcykgeyByZXR1cm4gZXhlY3V0ZVRlc3RzKHRlc3ROYW1lLCB0ZXN0cywgZmVhdHVyZXMsIGN1c3RvbUJlZm9yZUVhY2gsIGN1c3RvbUFmdGVyRWFjaCk7IH0sIGZlYXR1cmVzTGlzdCk7XG59XG5leHBvcnRzLmRlc2NyaWJlQ3VzdG9tID0gZGVzY3JpYmVDdXN0b207XG5mdW5jdGlvbiBkZXNjcmliZVdpdGhGZWF0dXJlc0FuZEV4ZWN1dG9yKHRlc3ROYW1lQmFzZSwgdGVzdHMsIGV4ZWN1dG9yLCBmZWF0dXJlc0xpc3QpIHtcbiAgICBpZiAoZmVhdHVyZXNMaXN0ICE9IG51bGwpIHtcbiAgICAgICAgZmVhdHVyZXNMaXN0LmZvckVhY2goZnVuY3Rpb24gKGZlYXR1cmVzKSB7XG4gICAgICAgICAgICB2YXIgdGVzdE5hbWUgPSB0ZXN0TmFtZUJhc2UgKyAnICcgKyBKU09OLnN0cmluZ2lmeShmZWF0dXJlcyk7XG4gICAgICAgICAgICBleGVjdXRvcih0ZXN0TmFtZSwgdGVzdHMsIGZlYXR1cmVzKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBleGVjdXRvcih0ZXN0TmFtZUJhc2UsIHRlc3RzKTtcbiAgICB9XG59XG52YXIgUFJPTUlTRV9JVCA9IGZ1bmN0aW9uIChuYW1lLCB0ZXN0RnVuYykge1xuICAgIGl0KG5hbWUsIGZ1bmN0aW9uIChkb25lKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB0ZXN0RnVuYygpO1xuICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgcmVzdWx0LnRoZW4oZG9uZSwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICBmYWlsKGUpO1xuICAgICAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9XG4gICAgfSk7XG59O1xuZnVuY3Rpb24gZXhlY3V0ZU1hdGhUZXN0cyh0ZXN0TmFtZSwgdGVzdHMsIG1hdGhGYWN0b3J5LCBmZWF0dXJlcykge1xuICAgIHZhciBtYXRoO1xuICAgIHZhciBjdXN0b21CZWZvcmVFYWNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBtYXRoID0gbWF0aEZhY3RvcnkoKTtcbiAgICAgICAgbWF0aC5zdGFydFNjb3BlKCk7XG4gICAgfTtcbiAgICB2YXIgY3VzdG9tQWZ0ZXJFYWNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBtYXRoLmVuZFNjb3BlKG51bGwpO1xuICAgICAgICBtYXRoLmRpc3Bvc2UoKTtcbiAgICB9O1xuICAgIHZhciBjdXN0b21JdCA9IGZ1bmN0aW9uIChuYW1lLCB0ZXN0RnVuYykge1xuICAgICAgICBQUk9NSVNFX0lUKG5hbWUsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRlc3RGdW5jKG1hdGgpOyB9KTtcbiAgICB9O1xuICAgIGV4ZWN1dGVUZXN0cyh0ZXN0TmFtZSwgdGVzdHMsIGZlYXR1cmVzLCBjdXN0b21CZWZvcmVFYWNoLCBjdXN0b21BZnRlckVhY2gsIGN1c3RvbUl0KTtcbn1cbmV4cG9ydHMuZXhlY3V0ZU1hdGhUZXN0cyA9IGV4ZWN1dGVNYXRoVGVzdHM7XG5mdW5jdGlvbiBleGVjdXRlVGVzdHModGVzdE5hbWUsIHRlc3RzLCBmZWF0dXJlcywgY3VzdG9tQmVmb3JlRWFjaCwgY3VzdG9tQWZ0ZXJFYWNoLCBjdXN0b21JdCkge1xuICAgIGlmIChjdXN0b21JdCA9PT0gdm9pZCAwKSB7IGN1c3RvbUl0ID0gUFJPTUlTRV9JVDsgfVxuICAgIGRlc2NyaWJlKHRlc3ROYW1lLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGJlZm9yZUVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGZlYXR1cmVzICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBlbnZpcm9ubWVudC5zZXRFbnZpcm9ubWVudChuZXcgZW52aXJvbm1lbnRfMS5FbnZpcm9ubWVudChmZWF0dXJlcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGN1c3RvbUJlZm9yZUVhY2ggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGN1c3RvbUJlZm9yZUVhY2goKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGFmdGVyRWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoY3VzdG9tQWZ0ZXJFYWNoICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjdXN0b21BZnRlckVhY2goKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmZWF0dXJlcyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZW52aXJvbm1lbnQuc2V0RW52aXJvbm1lbnQobmV3IGVudmlyb25tZW50XzEuRW52aXJvbm1lbnQoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0ZXN0cy5mb3JFYWNoKGZ1bmN0aW9uICh0ZXN0KSB7IHJldHVybiB0ZXN0KGN1c3RvbUl0KTsgfSk7XG4gICAgfSk7XG59XG5leHBvcnRzLmV4ZWN1dGVUZXN0cyA9IGV4ZWN1dGVUZXN0cztcbmZ1bmN0aW9uIGFzc2VydElzTmFuKHZhbCwgZHR5cGUpIHtcbiAgICBpZiAoIXV0aWwuaXNWYWxOYU4odmFsLCBkdHlwZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVmFsdWUgXCIgKyB2YWwgKyBcIiBkb2VzIG5vdCByZXByZXNlbnQgTmFOIGZvciBkdHlwZSBcIiArIGR0eXBlKTtcbiAgICB9XG59XG5leHBvcnRzLmFzc2VydElzTmFuID0gYXNzZXJ0SXNOYW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD10ZXN0X3V0aWwuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5mdW5jdGlvbiBzaHVmZmxlKGFycmF5KSB7XG4gICAgdmFyIGNvdW50ZXIgPSBhcnJheS5sZW5ndGg7XG4gICAgdmFyIHRlbXAgPSAwO1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgd2hpbGUgKGNvdW50ZXIgPiAwKSB7XG4gICAgICAgIGluZGV4ID0gKE1hdGgucmFuZG9tKCkgKiBjb3VudGVyKSB8IDA7XG4gICAgICAgIGNvdW50ZXItLTtcbiAgICAgICAgdGVtcCA9IGFycmF5W2NvdW50ZXJdO1xuICAgICAgICBhcnJheVtjb3VudGVyXSA9IGFycmF5W2luZGV4XTtcbiAgICAgICAgYXJyYXlbaW5kZXhdID0gdGVtcDtcbiAgICB9XG59XG5leHBvcnRzLnNodWZmbGUgPSBzaHVmZmxlO1xuZnVuY3Rpb24gY2xhbXAobWluLCB4LCBtYXgpIHtcbiAgICByZXR1cm4gTWF0aC5tYXgobWluLCBNYXRoLm1pbih4LCBtYXgpKTtcbn1cbmV4cG9ydHMuY2xhbXAgPSBjbGFtcDtcbmZ1bmN0aW9uIHJhbmRVbmlmb3JtKGEsIGIpIHtcbiAgICByZXR1cm4gTWF0aC5yYW5kb20oKSAqIChiIC0gYSkgKyBhO1xufVxuZXhwb3J0cy5yYW5kVW5pZm9ybSA9IHJhbmRVbmlmb3JtO1xuZnVuY3Rpb24gcmFuZEdhdXNzKG1lYW4sIHN0ZERldiwgdHJ1bmNhdGVkKSB7XG4gICAgaWYgKG1lYW4gPT09IHZvaWQgMCkgeyBtZWFuID0gMDsgfVxuICAgIGlmIChzdGREZXYgPT09IHZvaWQgMCkgeyBzdGREZXYgPSAxOyB9XG4gICAgaWYgKHRydW5jYXRlZCA9PT0gdm9pZCAwKSB7IHRydW5jYXRlZCA9IGZhbHNlOyB9XG4gICAgdmFyIHYxLCB2MiwgcztcbiAgICBkbyB7XG4gICAgICAgIHYxID0gMiAqIE1hdGgucmFuZG9tKCkgLSAxO1xuICAgICAgICB2MiA9IDIgKiBNYXRoLnJhbmRvbSgpIC0gMTtcbiAgICAgICAgcyA9IHYxICogdjEgKyB2MiAqIHYyO1xuICAgIH0gd2hpbGUgKHMgPiAxKTtcbiAgICB2YXIgcmVzdWx0ID0gTWF0aC5zcXJ0KC0yICogTWF0aC5sb2cocykgLyBzKSAqIHYxO1xuICAgIGlmICh0cnVuY2F0ZWQgJiYgTWF0aC5hYnMocmVzdWx0KSA+IDIpIHtcbiAgICAgICAgcmV0dXJuIHJhbmRHYXVzcyhtZWFuLCBzdGREZXYsIHRydWUpO1xuICAgIH1cbiAgICByZXR1cm4gbWVhbiArIHN0ZERldiAqIHJlc3VsdDtcbn1cbmV4cG9ydHMucmFuZEdhdXNzID0gcmFuZEdhdXNzO1xuZnVuY3Rpb24gZGlzdFNxdWFyZWQoYSwgYikge1xuICAgIHZhciByZXN1bHQgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZGlmZiA9IE51bWJlcihhW2ldKSAtIE51bWJlcihiW2ldKTtcbiAgICAgICAgcmVzdWx0ICs9IGRpZmYgKiBkaWZmO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0cy5kaXN0U3F1YXJlZCA9IGRpc3RTcXVhcmVkO1xuZnVuY3Rpb24gYXNzZXJ0KGV4cHIsIG1zZykge1xuICAgIGlmICghZXhwcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICB9XG59XG5leHBvcnRzLmFzc2VydCA9IGFzc2VydDtcbmZ1bmN0aW9uIGFzc2VydFNoYXBlc01hdGNoKHNoYXBlQSwgc2hhcGVCLCBlcnJvck1lc3NhZ2VQcmVmaXgpIHtcbiAgICBpZiAoZXJyb3JNZXNzYWdlUHJlZml4ID09PSB2b2lkIDApIHsgZXJyb3JNZXNzYWdlUHJlZml4ID0gJyc7IH1cbiAgICBhc3NlcnQoYXJyYXlzRXF1YWwoc2hhcGVBLCBzaGFwZUIpLCBlcnJvck1lc3NhZ2VQcmVmaXggKyAoXCJTaGFwZXMgXCIgKyBzaGFwZUEgKyBcIiBhbmQgXCIgKyBzaGFwZUIgKyBcIiBtdXN0IG1hdGNoXCIpKTtcbn1cbmV4cG9ydHMuYXNzZXJ0U2hhcGVzTWF0Y2ggPSBhc3NlcnRTaGFwZXNNYXRjaDtcbmZ1bmN0aW9uIGZsYXR0ZW4oYXJyLCByZXQpIHtcbiAgICBpZiAocmV0ID09PSB2b2lkIDApIHsgcmV0ID0gW107IH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBmbGF0dGVuKGFycltpXSwgcmV0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0LnB1c2goYXJyKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn1cbmV4cG9ydHMuZmxhdHRlbiA9IGZsYXR0ZW47XG5mdW5jdGlvbiBpbmZlclNoYXBlKGFycikge1xuICAgIHZhciBzaGFwZSA9IFtdO1xuICAgIHdoaWxlIChhcnIgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICBzaGFwZS5wdXNoKGFyci5sZW5ndGgpO1xuICAgICAgICBhcnIgPSBhcnJbMF07XG4gICAgfVxuICAgIHJldHVybiBzaGFwZTtcbn1cbmV4cG9ydHMuaW5mZXJTaGFwZSA9IGluZmVyU2hhcGU7XG5mdW5jdGlvbiBzaXplRnJvbVNoYXBlKHNoYXBlKSB7XG4gICAgaWYgKHNoYXBlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgdmFyIHNpemUgPSBzaGFwZVswXTtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IHNoYXBlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHNpemUgKj0gc2hhcGVbaV07XG4gICAgfVxuICAgIHJldHVybiBzaXplO1xufVxuZXhwb3J0cy5zaXplRnJvbVNoYXBlID0gc2l6ZUZyb21TaGFwZTtcbmZ1bmN0aW9uIGlzU2NhbGFyU2hhcGUoc2hhcGUpIHtcbiAgICByZXR1cm4gc2hhcGUubGVuZ3RoID09PSAwO1xufVxuZXhwb3J0cy5pc1NjYWxhclNoYXBlID0gaXNTY2FsYXJTaGFwZTtcbmZ1bmN0aW9uIGFycmF5c0VxdWFsKG4xLCBuMikge1xuICAgIGlmIChuMS5sZW5ndGggIT09IG4yLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKG4xW2ldICE9PSBuMltpXSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZXhwb3J0cy5hcnJheXNFcXVhbCA9IGFycmF5c0VxdWFsO1xuZnVuY3Rpb24gaXNJbnQoYSkge1xuICAgIHJldHVybiBhICUgMSA9PT0gMDtcbn1cbmV4cG9ydHMuaXNJbnQgPSBpc0ludDtcbmZ1bmN0aW9uIHRhbmgoeCkge1xuICAgIGlmIChNYXRoLnRhbmggIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gTWF0aC50YW5oKHgpO1xuICAgIH1cbiAgICBpZiAoeCA9PT0gSW5maW5pdHkpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIGVsc2UgaWYgKHggPT09IC1JbmZpbml0eSkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YXIgZTJ4ID0gTWF0aC5leHAoMiAqIHgpO1xuICAgICAgICByZXR1cm4gKGUyeCAtIDEpIC8gKGUyeCArIDEpO1xuICAgIH1cbn1cbmV4cG9ydHMudGFuaCA9IHRhbmg7XG5mdW5jdGlvbiBzaXplVG9TcXVhcmlzaFNoYXBlKHNpemUpIHtcbiAgICBmb3IgKHZhciBhID0gTWF0aC5mbG9vcihNYXRoLnNxcnQoc2l6ZSkpOyBhID4gMTsgLS1hKSB7XG4gICAgICAgIGlmIChzaXplICUgYSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIFthLCBzaXplIC8gYV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFsxLCBzaXplXTtcbn1cbmV4cG9ydHMuc2l6ZVRvU3F1YXJpc2hTaGFwZSA9IHNpemVUb1NxdWFyaXNoU2hhcGU7XG5mdW5jdGlvbiBjcmVhdGVTaHVmZmxlZEluZGljZXMobikge1xuICAgIHZhciBzaHVmZmxlZEluZGljZXMgPSBuZXcgVWludDMyQXJyYXkobik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgc2h1ZmZsZWRJbmRpY2VzW2ldID0gaTtcbiAgICB9XG4gICAgc2h1ZmZsZShzaHVmZmxlZEluZGljZXMpO1xuICAgIHJldHVybiBzaHVmZmxlZEluZGljZXM7XG59XG5leHBvcnRzLmNyZWF0ZVNodWZmbGVkSW5kaWNlcyA9IGNyZWF0ZVNodWZmbGVkSW5kaWNlcztcbmZ1bmN0aW9uIHJpZ2h0UGFkKGEsIHNpemUpIHtcbiAgICBpZiAoc2l6ZSA8PSBhLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gYTtcbiAgICB9XG4gICAgcmV0dXJuIGEgKyAnICcucmVwZWF0KHNpemUgLSBhLmxlbmd0aCk7XG59XG5leHBvcnRzLnJpZ2h0UGFkID0gcmlnaHRQYWQ7XG5mdW5jdGlvbiByZXBlYXRlZFRyeShjaGVja0ZuLCBkZWxheUZuLCBtYXhDb3VudGVyKSB7XG4gICAgaWYgKGRlbGF5Rm4gPT09IHZvaWQgMCkgeyBkZWxheUZuID0gZnVuY3Rpb24gKGNvdW50ZXIpIHsgcmV0dXJuIDA7IH07IH1cbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICB2YXIgdHJ5Q291bnQgPSAwO1xuICAgICAgICB2YXIgdHJ5Rm4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoY2hlY2tGbigpKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeUNvdW50Kys7XG4gICAgICAgICAgICB2YXIgbmV4dEJhY2tvZmYgPSBkZWxheUZuKHRyeUNvdW50KTtcbiAgICAgICAgICAgIGlmIChtYXhDb3VudGVyICE9IG51bGwgJiYgdHJ5Q291bnQgPj0gbWF4Q291bnRlcikge1xuICAgICAgICAgICAgICAgIHJlamVjdCgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldFRpbWVvdXQodHJ5Rm4sIG5leHRCYWNrb2ZmKTtcbiAgICAgICAgfTtcbiAgICAgICAgc2V0VGltZW91dCh0cnlGbiwgMCk7XG4gICAgfSk7XG59XG5leHBvcnRzLnJlcGVhdGVkVHJ5ID0gcmVwZWF0ZWRUcnk7XG5mdW5jdGlvbiBnZXRRdWVyeVBhcmFtcyhxdWVyeVN0cmluZykge1xuICAgIHZhciBwYXJhbXMgPSB7fTtcbiAgICBxdWVyeVN0cmluZy5yZXBsYWNlKC9bPyZdKFtePT8mXSspKD86PShbXiZdKikpPy9nLCBmdW5jdGlvbiAocykge1xuICAgICAgICB2YXIgdCA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdFtfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICBkZWNvZGVQYXJhbShwYXJhbXMsIHRbMF0sIHRbMV0pO1xuICAgICAgICByZXR1cm4gdC5qb2luKCc9Jyk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHBhcmFtcztcbn1cbmV4cG9ydHMuZ2V0UXVlcnlQYXJhbXMgPSBnZXRRdWVyeVBhcmFtcztcbmZ1bmN0aW9uIGRlY29kZVBhcmFtKHBhcmFtcywgbmFtZSwgdmFsdWUpIHtcbiAgICBwYXJhbXNbZGVjb2RlVVJJQ29tcG9uZW50KG5hbWUpXSA9IGRlY29kZVVSSUNvbXBvbmVudCh2YWx1ZSB8fCAnJyk7XG59XG5mdW5jdGlvbiBpbmZlckZyb21JbXBsaWNpdFNoYXBlKHNoYXBlLCBzaXplKSB7XG4gICAgdmFyIHNoYXBlUHJvZCA9IDE7XG4gICAgdmFyIGltcGxpY2l0SWR4ID0gLTE7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaGFwZS5sZW5ndGg7ICsraSkge1xuICAgICAgICBpZiAoc2hhcGVbaV0gPiAwKSB7XG4gICAgICAgICAgICBzaGFwZVByb2QgKj0gc2hhcGVbaV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc2hhcGVbaV0gPT09IC0xKSB7XG4gICAgICAgICAgICBpZiAoaW1wbGljaXRJZHggIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJTaGFwZXMgY2FuIG9ubHkgaGF2ZSAxIGltcGxpY2l0IHNpemUuIFwiICtcbiAgICAgICAgICAgICAgICAgICAgKFwiRm91bmQgLTEgYXQgZGltIFwiICsgaW1wbGljaXRJZHggKyBcIiBhbmQgZGltIFwiICsgaSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW1wbGljaXRJZHggPSBpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNoYXBlW2ldIDw9IDApIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwiU2hhcGVzIGNhbiBub3QgYmUgPD0gMC4gRm91bmQgXCIgKyBzaGFwZVtpXSArIFwiIGF0IGRpbSBcIiArIGkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChpbXBsaWNpdElkeCA9PT0gLTEpIHtcbiAgICAgICAgaWYgKHNpemUgPiAwICYmIHNpemUgIT09IHNoYXBlUHJvZCkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJTaXplIChcIiArIHNpemUgKyBcIikgbXVzdCBtYXRjaCB0aGUgcHJvZHVjdCBvZiBzaGFwZSBcIiArIHNoYXBlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2hhcGU7XG4gICAgfVxuICAgIGlmIChzaXplICUgc2hhcGVQcm9kICE9PSAwKSB7XG4gICAgICAgIHRocm93IEVycm9yKFwiVGhlIGltcGxpY2l0IHNoYXBlIGNhbid0IGJlIGEgZnJhY3Rpb25hbCBudW1iZXIuIFwiICtcbiAgICAgICAgICAgIChcIkdvdCBcIiArIHNpemUgKyBcIiAvIFwiICsgc2hhcGVQcm9kKSk7XG4gICAgfVxuICAgIHZhciBuZXdTaGFwZSA9IHNoYXBlLnNsaWNlKCk7XG4gICAgbmV3U2hhcGVbaW1wbGljaXRJZHhdID0gc2l6ZSAvIHNoYXBlUHJvZDtcbiAgICByZXR1cm4gbmV3U2hhcGU7XG59XG5leHBvcnRzLmluZmVyRnJvbUltcGxpY2l0U2hhcGUgPSBpbmZlckZyb21JbXBsaWNpdFNoYXBlO1xuZXhwb3J0cy5OQU5fSU5UMzIgPSAxIDw8IDMxO1xuZXhwb3J0cy5OQU5fQk9PTCA9IDI1NTtcbmV4cG9ydHMuTkFOX0ZMT0FUMzIgPSBOYU47XG5mdW5jdGlvbiBnZXROYU4oZHR5cGUpIHtcbiAgICBpZiAoZHR5cGUgPT09ICdmbG9hdDMyJykge1xuICAgICAgICByZXR1cm4gZXhwb3J0cy5OQU5fRkxPQVQzMjtcbiAgICB9XG4gICAgZWxzZSBpZiAoZHR5cGUgPT09ICdpbnQzMicpIHtcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuTkFOX0lOVDMyO1xuICAgIH1cbiAgICBlbHNlIGlmIChkdHlwZSA9PT0gJ2Jvb2wnKSB7XG4gICAgICAgIHJldHVybiBleHBvcnRzLk5BTl9CT09MO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBkdHlwZSBcIiArIGR0eXBlKTtcbiAgICB9XG59XG5leHBvcnRzLmdldE5hTiA9IGdldE5hTjtcbmZ1bmN0aW9uIGlzVmFsTmFOKHZhbCwgZHR5cGUpIHtcbiAgICBpZiAoZHR5cGUgPT09ICdmbG9hdDMyJykge1xuICAgICAgICByZXR1cm4gaXNOYU4odmFsKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZHR5cGUgPT09ICdpbnQzMicpIHtcbiAgICAgICAgcmV0dXJuIHZhbCA9PT0gZXhwb3J0cy5OQU5fSU5UMzI7XG4gICAgfVxuICAgIGVsc2UgaWYgKGR0eXBlID09PSAnYm9vbCcpIHtcbiAgICAgICAgcmV0dXJuIHZhbCA9PT0gZXhwb3J0cy5OQU5fQk9PTDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gZHR5cGUgXCIgKyBkdHlwZSk7XG4gICAgfVxufVxuZXhwb3J0cy5pc1ZhbE5hTiA9IGlzVmFsTmFOO1xuZnVuY3Rpb24gc3F1ZWV6ZVNoYXBlKHNoYXBlKSB7XG4gICAgdmFyIG5ld1NoYXBlID0gW107XG4gICAgdmFyIGtlcHREaW1zID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaGFwZS5sZW5ndGg7ICsraSkge1xuICAgICAgICBpZiAoc2hhcGVbaV0gPiAxKSB7XG4gICAgICAgICAgICBuZXdTaGFwZS5wdXNoKHNoYXBlW2ldKTtcbiAgICAgICAgICAgIGtlcHREaW1zLnB1c2goaSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgbmV3U2hhcGU6IG5ld1NoYXBlLCBrZXB0RGltczoga2VwdERpbXMgfTtcbn1cbmV4cG9ydHMuc3F1ZWV6ZVNoYXBlID0gc3F1ZWV6ZVNoYXBlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB2ZXJzaW9uID0gJzAuMy4xMSc7XG5leHBvcnRzLnZlcnNpb24gPSB2ZXJzaW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmVyc2lvbi5qcy5tYXAiLCIvLyBBIGxpYnJhcnkgb2Ygc2VlZGFibGUgUk5HcyBpbXBsZW1lbnRlZCBpbiBKYXZhc2NyaXB0LlxuLy9cbi8vIFVzYWdlOlxuLy9cbi8vIHZhciBzZWVkcmFuZG9tID0gcmVxdWlyZSgnc2VlZHJhbmRvbScpO1xuLy8gdmFyIHJhbmRvbSA9IHNlZWRyYW5kb20oMSk7IC8vIG9yIGFueSBzZWVkLlxuLy8gdmFyIHggPSByYW5kb20oKTsgICAgICAgLy8gMCA8PSB4IDwgMS4gIEV2ZXJ5IGJpdCBpcyByYW5kb20uXG4vLyB2YXIgeCA9IHJhbmRvbS5xdWljaygpOyAvLyAwIDw9IHggPCAxLiAgMzIgYml0cyBvZiByYW5kb21uZXNzLlxuXG4vLyBhbGVhLCBhIDUzLWJpdCBtdWx0aXBseS13aXRoLWNhcnJ5IGdlbmVyYXRvciBieSBKb2hhbm5lcyBCYWFnw7hlLlxuLy8gUGVyaW9kOiB+Ml4xMTZcbi8vIFJlcG9ydGVkIHRvIHBhc3MgYWxsIEJpZ0NydXNoIHRlc3RzLlxudmFyIGFsZWEgPSByZXF1aXJlKCcuL2xpYi9hbGVhJyk7XG5cbi8vIHhvcjEyOCwgYSBwdXJlIHhvci1zaGlmdCBnZW5lcmF0b3IgYnkgR2VvcmdlIE1hcnNhZ2xpYS5cbi8vIFBlcmlvZDogMl4xMjgtMS5cbi8vIFJlcG9ydGVkIHRvIGZhaWw6IE1hdHJpeFJhbmsgYW5kIExpbmVhckNvbXAuXG52YXIgeG9yMTI4ID0gcmVxdWlyZSgnLi9saWIveG9yMTI4Jyk7XG5cbi8vIHhvcndvdywgR2VvcmdlIE1hcnNhZ2xpYSdzIDE2MC1iaXQgeG9yLXNoaWZ0IGNvbWJpbmVkIHBsdXMgd2V5bC5cbi8vIFBlcmlvZDogMl4xOTItMl4zMlxuLy8gUmVwb3J0ZWQgdG8gZmFpbDogQ29sbGlzaW9uT3ZlciwgU2ltcFBva2VyLCBhbmQgTGluZWFyQ29tcC5cbnZhciB4b3J3b3cgPSByZXF1aXJlKCcuL2xpYi94b3J3b3cnKTtcblxuLy8geG9yc2hpZnQ3LCBieSBGcmFuw6dvaXMgUGFubmV0b24gYW5kIFBpZXJyZSBMJ2VjdXllciwgdGFrZXNcbi8vIGEgZGlmZmVyZW50IGFwcHJvYWNoOiBpdCBhZGRzIHJvYnVzdG5lc3MgYnkgYWxsb3dpbmcgbW9yZSBzaGlmdHNcbi8vIHRoYW4gTWFyc2FnbGlhJ3Mgb3JpZ2luYWwgdGhyZWUuICBJdCBpcyBhIDctc2hpZnQgZ2VuZXJhdG9yXG4vLyB3aXRoIDI1NiBiaXRzLCB0aGF0IHBhc3NlcyBCaWdDcnVzaCB3aXRoIG5vIHN5c3RtYXRpYyBmYWlsdXJlcy5cbi8vIFBlcmlvZCAyXjI1Ni0xLlxuLy8gTm8gc3lzdGVtYXRpYyBCaWdDcnVzaCBmYWlsdXJlcyByZXBvcnRlZC5cbnZhciB4b3JzaGlmdDcgPSByZXF1aXJlKCcuL2xpYi94b3JzaGlmdDcnKTtcblxuLy8geG9yNDA5NiwgYnkgUmljaGFyZCBCcmVudCwgaXMgYSA0MDk2LWJpdCB4b3Itc2hpZnQgd2l0aCBhXG4vLyB2ZXJ5IGxvbmcgcGVyaW9kIHRoYXQgYWxzbyBhZGRzIGEgV2V5bCBnZW5lcmF0b3IuIEl0IGFsc28gcGFzc2VzXG4vLyBCaWdDcnVzaCB3aXRoIG5vIHN5c3RlbWF0aWMgZmFpbHVyZXMuICBJdHMgbG9uZyBwZXJpb2QgbWF5XG4vLyBiZSB1c2VmdWwgaWYgeW91IGhhdmUgbWFueSBnZW5lcmF0b3JzIGFuZCBuZWVkIHRvIGF2b2lkXG4vLyBjb2xsaXNpb25zLlxuLy8gUGVyaW9kOiAyXjQxMjgtMl4zMi5cbi8vIE5vIHN5c3RlbWF0aWMgQmlnQ3J1c2ggZmFpbHVyZXMgcmVwb3J0ZWQuXG52YXIgeG9yNDA5NiA9IHJlcXVpcmUoJy4vbGliL3hvcjQwOTYnKTtcblxuLy8gVHljaGUtaSwgYnkgU2FtdWVsIE5ldmVzIGFuZCBGaWxpcGUgQXJhdWpvLCBpcyBhIGJpdC1zaGlmdGluZyByYW5kb21cbi8vIG51bWJlciBnZW5lcmF0b3IgZGVyaXZlZCBmcm9tIENoYUNoYSwgYSBtb2Rlcm4gc3RyZWFtIGNpcGhlci5cbi8vIGh0dHBzOi8vZWRlbi5kZWkudWMucHQvfnNuZXZlcy9wdWJzLzIwMTEtc25mYTIucGRmXG4vLyBQZXJpb2Q6IH4yXjEyN1xuLy8gTm8gc3lzdGVtYXRpYyBCaWdDcnVzaCBmYWlsdXJlcyByZXBvcnRlZC5cbnZhciB0eWNoZWkgPSByZXF1aXJlKCcuL2xpYi90eWNoZWknKTtcblxuLy8gVGhlIG9yaWdpbmFsIEFSQzQtYmFzZWQgcHJuZyBpbmNsdWRlZCBpbiB0aGlzIGxpYnJhcnkuXG4vLyBQZXJpb2Q6IH4yXjE2MDBcbnZhciBzciA9IHJlcXVpcmUoJy4vc2VlZHJhbmRvbScpO1xuXG5zci5hbGVhID0gYWxlYTtcbnNyLnhvcjEyOCA9IHhvcjEyODtcbnNyLnhvcndvdyA9IHhvcndvdztcbnNyLnhvcnNoaWZ0NyA9IHhvcnNoaWZ0NztcbnNyLnhvcjQwOTYgPSB4b3I0MDk2O1xuc3IudHljaGVpID0gdHljaGVpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHNyO1xuIiwiLy8gQSBwb3J0IG9mIGFuIGFsZ29yaXRobSBieSBKb2hhbm5lcyBCYWFnw7hlIDxiYWFnb2VAYmFhZ29lLmNvbT4sIDIwMTBcbi8vIGh0dHA6Ly9iYWFnb2UuY29tL2VuL1JhbmRvbU11c2luZ3MvamF2YXNjcmlwdC9cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ucXVpbmxhbi9iZXR0ZXItcmFuZG9tLW51bWJlcnMtZm9yLWphdmFzY3JpcHQtbWlycm9yXG4vLyBPcmlnaW5hbCB3b3JrIGlzIHVuZGVyIE1JVCBsaWNlbnNlIC1cblxuLy8gQ29weXJpZ2h0IChDKSAyMDEwIGJ5IEpvaGFubmVzIEJhYWfDuGUgPGJhYWdvZUBiYWFnb2Uub3JnPlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vIFxuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy8gXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuXG5cbihmdW5jdGlvbihnbG9iYWwsIG1vZHVsZSwgZGVmaW5lKSB7XG5cbmZ1bmN0aW9uIEFsZWEoc2VlZCkge1xuICB2YXIgbWUgPSB0aGlzLCBtYXNoID0gTWFzaCgpO1xuXG4gIG1lLm5leHQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdCA9IDIwOTE2MzkgKiBtZS5zMCArIG1lLmMgKiAyLjMyODMwNjQzNjUzODY5NjNlLTEwOyAvLyAyXi0zMlxuICAgIG1lLnMwID0gbWUuczE7XG4gICAgbWUuczEgPSBtZS5zMjtcbiAgICByZXR1cm4gbWUuczIgPSB0IC0gKG1lLmMgPSB0IHwgMCk7XG4gIH07XG5cbiAgLy8gQXBwbHkgdGhlIHNlZWRpbmcgYWxnb3JpdGhtIGZyb20gQmFhZ29lLlxuICBtZS5jID0gMTtcbiAgbWUuczAgPSBtYXNoKCcgJyk7XG4gIG1lLnMxID0gbWFzaCgnICcpO1xuICBtZS5zMiA9IG1hc2goJyAnKTtcbiAgbWUuczAgLT0gbWFzaChzZWVkKTtcbiAgaWYgKG1lLnMwIDwgMCkgeyBtZS5zMCArPSAxOyB9XG4gIG1lLnMxIC09IG1hc2goc2VlZCk7XG4gIGlmIChtZS5zMSA8IDApIHsgbWUuczEgKz0gMTsgfVxuICBtZS5zMiAtPSBtYXNoKHNlZWQpO1xuICBpZiAobWUuczIgPCAwKSB7IG1lLnMyICs9IDE7IH1cbiAgbWFzaCA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIGNvcHkoZiwgdCkge1xuICB0LmMgPSBmLmM7XG4gIHQuczAgPSBmLnMwO1xuICB0LnMxID0gZi5zMTtcbiAgdC5zMiA9IGYuczI7XG4gIHJldHVybiB0O1xufVxuXG5mdW5jdGlvbiBpbXBsKHNlZWQsIG9wdHMpIHtcbiAgdmFyIHhnID0gbmV3IEFsZWEoc2VlZCksXG4gICAgICBzdGF0ZSA9IG9wdHMgJiYgb3B0cy5zdGF0ZSxcbiAgICAgIHBybmcgPSB4Zy5uZXh0O1xuICBwcm5nLmludDMyID0gZnVuY3Rpb24oKSB7IHJldHVybiAoeGcubmV4dCgpICogMHgxMDAwMDAwMDApIHwgMDsgfVxuICBwcm5nLmRvdWJsZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBwcm5nKCkgKyAocHJuZygpICogMHgyMDAwMDAgfCAwKSAqIDEuMTEwMjIzMDI0NjI1MTU2NWUtMTY7IC8vIDJeLTUzXG4gIH07XG4gIHBybmcucXVpY2sgPSBwcm5nO1xuICBpZiAoc3RhdGUpIHtcbiAgICBpZiAodHlwZW9mKHN0YXRlKSA9PSAnb2JqZWN0JykgY29weShzdGF0ZSwgeGcpO1xuICAgIHBybmcuc3RhdGUgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGNvcHkoeGcsIHt9KTsgfVxuICB9XG4gIHJldHVybiBwcm5nO1xufVxuXG5mdW5jdGlvbiBNYXNoKCkge1xuICB2YXIgbiA9IDB4ZWZjODI0OWQ7XG5cbiAgdmFyIG1hc2ggPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgZGF0YSA9IGRhdGEudG9TdHJpbmcoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIG4gKz0gZGF0YS5jaGFyQ29kZUF0KGkpO1xuICAgICAgdmFyIGggPSAwLjAyNTE5NjAzMjgyNDE2OTM4ICogbjtcbiAgICAgIG4gPSBoID4+PiAwO1xuICAgICAgaCAtPSBuO1xuICAgICAgaCAqPSBuO1xuICAgICAgbiA9IGggPj4+IDA7XG4gICAgICBoIC09IG47XG4gICAgICBuICs9IGggKiAweDEwMDAwMDAwMDsgLy8gMl4zMlxuICAgIH1cbiAgICByZXR1cm4gKG4gPj4+IDApICogMi4zMjgzMDY0MzY1Mzg2OTYzZS0xMDsgLy8gMl4tMzJcbiAgfTtcblxuICByZXR1cm4gbWFzaDtcbn1cblxuXG5pZiAobW9kdWxlICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gaW1wbDtcbn0gZWxzZSBpZiAoZGVmaW5lICYmIGRlZmluZS5hbWQpIHtcbiAgZGVmaW5lKGZ1bmN0aW9uKCkgeyByZXR1cm4gaW1wbDsgfSk7XG59IGVsc2Uge1xuICB0aGlzLmFsZWEgPSBpbXBsO1xufVxuXG59KShcbiAgdGhpcyxcbiAgKHR5cGVvZiBtb2R1bGUpID09ICdvYmplY3QnICYmIG1vZHVsZSwgICAgLy8gcHJlc2VudCBpbiBub2RlLmpzXG4gICh0eXBlb2YgZGVmaW5lKSA9PSAnZnVuY3Rpb24nICYmIGRlZmluZSAgIC8vIHByZXNlbnQgd2l0aCBhbiBBTUQgbG9hZGVyXG4pO1xuXG5cbiIsIi8vIEEgSmF2YXNjcmlwdCBpbXBsZW1lbnRhaW9uIG9mIHRoZSBcIlR5Y2hlLWlcIiBwcm5nIGFsZ29yaXRobSBieVxuLy8gU2FtdWVsIE5ldmVzIGFuZCBGaWxpcGUgQXJhdWpvLlxuLy8gU2VlIGh0dHBzOi8vZWRlbi5kZWkudWMucHQvfnNuZXZlcy9wdWJzLzIwMTEtc25mYTIucGRmXG5cbihmdW5jdGlvbihnbG9iYWwsIG1vZHVsZSwgZGVmaW5lKSB7XG5cbmZ1bmN0aW9uIFhvckdlbihzZWVkKSB7XG4gIHZhciBtZSA9IHRoaXMsIHN0cnNlZWQgPSAnJztcblxuICAvLyBTZXQgdXAgZ2VuZXJhdG9yIGZ1bmN0aW9uLlxuICBtZS5uZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGIgPSBtZS5iLCBjID0gbWUuYywgZCA9IG1lLmQsIGEgPSBtZS5hO1xuICAgIGIgPSAoYiA8PCAyNSkgXiAoYiA+Pj4gNykgXiBjO1xuICAgIGMgPSAoYyAtIGQpIHwgMDtcbiAgICBkID0gKGQgPDwgMjQpIF4gKGQgPj4+IDgpIF4gYTtcbiAgICBhID0gKGEgLSBiKSB8IDA7XG4gICAgbWUuYiA9IGIgPSAoYiA8PCAyMCkgXiAoYiA+Pj4gMTIpIF4gYztcbiAgICBtZS5jID0gYyA9IChjIC0gZCkgfCAwO1xuICAgIG1lLmQgPSAoZCA8PCAxNikgXiAoYyA+Pj4gMTYpIF4gYTtcbiAgICByZXR1cm4gbWUuYSA9IChhIC0gYikgfCAwO1xuICB9O1xuXG4gIC8qIFRoZSBmb2xsb3dpbmcgaXMgbm9uLWludmVydGVkIHR5Y2hlLCB3aGljaCBoYXMgYmV0dGVyIGludGVybmFsXG4gICAqIGJpdCBkaWZmdXNpb24sIGJ1dCB3aGljaCBpcyBhYm91dCAyNSUgc2xvd2VyIHRoYW4gdHljaGUtaSBpbiBKUy5cbiAgbWUubmV4dCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBhID0gbWUuYSwgYiA9IG1lLmIsIGMgPSBtZS5jLCBkID0gbWUuZDtcbiAgICBhID0gKG1lLmEgKyBtZS5iIHwgMCkgPj4+IDA7XG4gICAgZCA9IG1lLmQgXiBhOyBkID0gZCA8PCAxNiBeIGQgPj4+IDE2O1xuICAgIGMgPSBtZS5jICsgZCB8IDA7XG4gICAgYiA9IG1lLmIgXiBjOyBiID0gYiA8PCAxMiBeIGQgPj4+IDIwO1xuICAgIG1lLmEgPSBhID0gYSArIGIgfCAwO1xuICAgIGQgPSBkIF4gYTsgbWUuZCA9IGQgPSBkIDw8IDggXiBkID4+PiAyNDtcbiAgICBtZS5jID0gYyA9IGMgKyBkIHwgMDtcbiAgICBiID0gYiBeIGM7XG4gICAgcmV0dXJuIG1lLmIgPSAoYiA8PCA3IF4gYiA+Pj4gMjUpO1xuICB9XG4gICovXG5cbiAgbWUuYSA9IDA7XG4gIG1lLmIgPSAwO1xuICBtZS5jID0gMjY1NDQzNTc2OSB8IDA7XG4gIG1lLmQgPSAxMzY3MTMwNTUxO1xuXG4gIGlmIChzZWVkID09PSBNYXRoLmZsb29yKHNlZWQpKSB7XG4gICAgLy8gSW50ZWdlciBzZWVkLlxuICAgIG1lLmEgPSAoc2VlZCAvIDB4MTAwMDAwMDAwKSB8IDA7XG4gICAgbWUuYiA9IHNlZWQgfCAwO1xuICB9IGVsc2Uge1xuICAgIC8vIFN0cmluZyBzZWVkLlxuICAgIHN0cnNlZWQgKz0gc2VlZDtcbiAgfVxuXG4gIC8vIE1peCBpbiBzdHJpbmcgc2VlZCwgdGhlbiBkaXNjYXJkIGFuIGluaXRpYWwgYmF0Y2ggb2YgNjQgdmFsdWVzLlxuICBmb3IgKHZhciBrID0gMDsgayA8IHN0cnNlZWQubGVuZ3RoICsgMjA7IGsrKykge1xuICAgIG1lLmIgXj0gc3Ryc2VlZC5jaGFyQ29kZUF0KGspIHwgMDtcbiAgICBtZS5uZXh0KCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY29weShmLCB0KSB7XG4gIHQuYSA9IGYuYTtcbiAgdC5iID0gZi5iO1xuICB0LmMgPSBmLmM7XG4gIHQuZCA9IGYuZDtcbiAgcmV0dXJuIHQ7XG59O1xuXG5mdW5jdGlvbiBpbXBsKHNlZWQsIG9wdHMpIHtcbiAgdmFyIHhnID0gbmV3IFhvckdlbihzZWVkKSxcbiAgICAgIHN0YXRlID0gb3B0cyAmJiBvcHRzLnN0YXRlLFxuICAgICAgcHJuZyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gKHhnLm5leHQoKSA+Pj4gMCkgLyAweDEwMDAwMDAwMDsgfTtcbiAgcHJuZy5kb3VibGUgPSBmdW5jdGlvbigpIHtcbiAgICBkbyB7XG4gICAgICB2YXIgdG9wID0geGcubmV4dCgpID4+PiAxMSxcbiAgICAgICAgICBib3QgPSAoeGcubmV4dCgpID4+PiAwKSAvIDB4MTAwMDAwMDAwLFxuICAgICAgICAgIHJlc3VsdCA9ICh0b3AgKyBib3QpIC8gKDEgPDwgMjEpO1xuICAgIH0gd2hpbGUgKHJlc3VsdCA9PT0gMCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbiAgcHJuZy5pbnQzMiA9IHhnLm5leHQ7XG4gIHBybmcucXVpY2sgPSBwcm5nO1xuICBpZiAoc3RhdGUpIHtcbiAgICBpZiAodHlwZW9mKHN0YXRlKSA9PSAnb2JqZWN0JykgY29weShzdGF0ZSwgeGcpO1xuICAgIHBybmcuc3RhdGUgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGNvcHkoeGcsIHt9KTsgfVxuICB9XG4gIHJldHVybiBwcm5nO1xufVxuXG5pZiAobW9kdWxlICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gaW1wbDtcbn0gZWxzZSBpZiAoZGVmaW5lICYmIGRlZmluZS5hbWQpIHtcbiAgZGVmaW5lKGZ1bmN0aW9uKCkgeyByZXR1cm4gaW1wbDsgfSk7XG59IGVsc2Uge1xuICB0aGlzLnR5Y2hlaSA9IGltcGw7XG59XG5cbn0pKFxuICB0aGlzLFxuICAodHlwZW9mIG1vZHVsZSkgPT0gJ29iamVjdCcgJiYgbW9kdWxlLCAgICAvLyBwcmVzZW50IGluIG5vZGUuanNcbiAgKHR5cGVvZiBkZWZpbmUpID09ICdmdW5jdGlvbicgJiYgZGVmaW5lICAgLy8gcHJlc2VudCB3aXRoIGFuIEFNRCBsb2FkZXJcbik7XG5cblxuIiwiLy8gQSBKYXZhc2NyaXB0IGltcGxlbWVudGFpb24gb2YgdGhlIFwieG9yMTI4XCIgcHJuZyBhbGdvcml0aG0gYnlcbi8vIEdlb3JnZSBNYXJzYWdsaWEuICBTZWUgaHR0cDovL3d3dy5qc3RhdHNvZnQub3JnL3YwOC9pMTQvcGFwZXJcblxuKGZ1bmN0aW9uKGdsb2JhbCwgbW9kdWxlLCBkZWZpbmUpIHtcblxuZnVuY3Rpb24gWG9yR2VuKHNlZWQpIHtcbiAgdmFyIG1lID0gdGhpcywgc3Ryc2VlZCA9ICcnO1xuXG4gIG1lLnggPSAwO1xuICBtZS55ID0gMDtcbiAgbWUueiA9IDA7XG4gIG1lLncgPSAwO1xuXG4gIC8vIFNldCB1cCBnZW5lcmF0b3IgZnVuY3Rpb24uXG4gIG1lLm5leHQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdCA9IG1lLnggXiAobWUueCA8PCAxMSk7XG4gICAgbWUueCA9IG1lLnk7XG4gICAgbWUueSA9IG1lLno7XG4gICAgbWUueiA9IG1lLnc7XG4gICAgcmV0dXJuIG1lLncgXj0gKG1lLncgPj4+IDE5KSBeIHQgXiAodCA+Pj4gOCk7XG4gIH07XG5cbiAgaWYgKHNlZWQgPT09IChzZWVkIHwgMCkpIHtcbiAgICAvLyBJbnRlZ2VyIHNlZWQuXG4gICAgbWUueCA9IHNlZWQ7XG4gIH0gZWxzZSB7XG4gICAgLy8gU3RyaW5nIHNlZWQuXG4gICAgc3Ryc2VlZCArPSBzZWVkO1xuICB9XG5cbiAgLy8gTWl4IGluIHN0cmluZyBzZWVkLCB0aGVuIGRpc2NhcmQgYW4gaW5pdGlhbCBiYXRjaCBvZiA2NCB2YWx1ZXMuXG4gIGZvciAodmFyIGsgPSAwOyBrIDwgc3Ryc2VlZC5sZW5ndGggKyA2NDsgaysrKSB7XG4gICAgbWUueCBePSBzdHJzZWVkLmNoYXJDb2RlQXQoaykgfCAwO1xuICAgIG1lLm5leHQoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjb3B5KGYsIHQpIHtcbiAgdC54ID0gZi54O1xuICB0LnkgPSBmLnk7XG4gIHQueiA9IGYuejtcbiAgdC53ID0gZi53O1xuICByZXR1cm4gdDtcbn1cblxuZnVuY3Rpb24gaW1wbChzZWVkLCBvcHRzKSB7XG4gIHZhciB4ZyA9IG5ldyBYb3JHZW4oc2VlZCksXG4gICAgICBzdGF0ZSA9IG9wdHMgJiYgb3B0cy5zdGF0ZSxcbiAgICAgIHBybmcgPSBmdW5jdGlvbigpIHsgcmV0dXJuICh4Zy5uZXh0KCkgPj4+IDApIC8gMHgxMDAwMDAwMDA7IH07XG4gIHBybmcuZG91YmxlID0gZnVuY3Rpb24oKSB7XG4gICAgZG8ge1xuICAgICAgdmFyIHRvcCA9IHhnLm5leHQoKSA+Pj4gMTEsXG4gICAgICAgICAgYm90ID0gKHhnLm5leHQoKSA+Pj4gMCkgLyAweDEwMDAwMDAwMCxcbiAgICAgICAgICByZXN1bHQgPSAodG9wICsgYm90KSAvICgxIDw8IDIxKTtcbiAgICB9IHdoaWxlIChyZXN1bHQgPT09IDApO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG4gIHBybmcuaW50MzIgPSB4Zy5uZXh0O1xuICBwcm5nLnF1aWNrID0gcHJuZztcbiAgaWYgKHN0YXRlKSB7XG4gICAgaWYgKHR5cGVvZihzdGF0ZSkgPT0gJ29iamVjdCcpIGNvcHkoc3RhdGUsIHhnKTtcbiAgICBwcm5nLnN0YXRlID0gZnVuY3Rpb24oKSB7IHJldHVybiBjb3B5KHhnLCB7fSk7IH1cbiAgfVxuICByZXR1cm4gcHJuZztcbn1cblxuaWYgKG1vZHVsZSAmJiBtb2R1bGUuZXhwb3J0cykge1xuICBtb2R1bGUuZXhwb3J0cyA9IGltcGw7XG59IGVsc2UgaWYgKGRlZmluZSAmJiBkZWZpbmUuYW1kKSB7XG4gIGRlZmluZShmdW5jdGlvbigpIHsgcmV0dXJuIGltcGw7IH0pO1xufSBlbHNlIHtcbiAgdGhpcy54b3IxMjggPSBpbXBsO1xufVxuXG59KShcbiAgdGhpcyxcbiAgKHR5cGVvZiBtb2R1bGUpID09ICdvYmplY3QnICYmIG1vZHVsZSwgICAgLy8gcHJlc2VudCBpbiBub2RlLmpzXG4gICh0eXBlb2YgZGVmaW5lKSA9PSAnZnVuY3Rpb24nICYmIGRlZmluZSAgIC8vIHByZXNlbnQgd2l0aCBhbiBBTUQgbG9hZGVyXG4pO1xuXG5cbiIsIi8vIEEgSmF2YXNjcmlwdCBpbXBsZW1lbnRhaW9uIG9mIFJpY2hhcmQgQnJlbnQncyBYb3JnZW5zIHhvcjQwOTYgYWxnb3JpdGhtLlxuLy9cbi8vIFRoaXMgZmFzdCBub24tY3J5cHRvZ3JhcGhpYyByYW5kb20gbnVtYmVyIGdlbmVyYXRvciBpcyBkZXNpZ25lZCBmb3Jcbi8vIHVzZSBpbiBNb250ZS1DYXJsbyBhbGdvcml0aG1zLiBJdCBjb21iaW5lcyBhIGxvbmctcGVyaW9kIHhvcnNoaWZ0XG4vLyBnZW5lcmF0b3Igd2l0aCBhIFdleWwgZ2VuZXJhdG9yLCBhbmQgaXQgcGFzc2VzIGFsbCBjb21tb24gYmF0dGVyaWVzXG4vLyBvZiBzdGFzdGljaWFsIHRlc3RzIGZvciByYW5kb21uZXNzIHdoaWxlIGNvbnN1bWluZyBvbmx5IGEgZmV3IG5hbm9zZWNvbmRzXG4vLyBmb3IgZWFjaCBwcm5nIGdlbmVyYXRlZC4gIEZvciBiYWNrZ3JvdW5kIG9uIHRoZSBnZW5lcmF0b3IsIHNlZSBCcmVudCdzXG4vLyBwYXBlcjogXCJTb21lIGxvbmctcGVyaW9kIHJhbmRvbSBudW1iZXIgZ2VuZXJhdG9ycyB1c2luZyBzaGlmdHMgYW5kIHhvcnMuXCJcbi8vIGh0dHA6Ly9hcnhpdi5vcmcvcGRmLzEwMDQuMzExNXYxLnBkZlxuLy9cbi8vIFVzYWdlOlxuLy9cbi8vIHZhciB4b3I0MDk2ID0gcmVxdWlyZSgneG9yNDA5NicpO1xuLy8gcmFuZG9tID0geG9yNDA5NigxKTsgICAgICAgICAgICAgICAgICAgICAgICAvLyBTZWVkIHdpdGggaW50MzIgb3Igc3RyaW5nLlxuLy8gYXNzZXJ0LmVxdWFsKHJhbmRvbSgpLCAwLjE1MjA0MzY0NTA1Mzg1NDcpOyAvLyAoMCwgMSkgcmFuZ2UsIDUzIGJpdHMuXG4vLyBhc3NlcnQuZXF1YWwocmFuZG9tLmludDMyKCksIDE4MDY1MzQ4OTcpOyAgIC8vIHNpZ25lZCBpbnQzMiwgMzIgYml0cy5cbi8vXG4vLyBGb3Igbm9uemVybyBudW1lcmljIGtleXMsIHRoaXMgaW1wZWxlbWVudGF0aW9uIHByb3ZpZGVzIGEgc2VxdWVuY2Vcbi8vIGlkZW50aWNhbCB0byB0aGF0IGJ5IEJyZW50J3MgeG9yZ2VucyAzIGltcGxlbWVudGFpb24gaW4gQy4gIFRoaXNcbi8vIGltcGxlbWVudGF0aW9uIGFsc28gcHJvdmlkZXMgZm9yIGluaXRhbGl6aW5nIHRoZSBnZW5lcmF0b3Igd2l0aFxuLy8gc3RyaW5nIHNlZWRzLCBvciBmb3Igc2F2aW5nIGFuZCByZXN0b3JpbmcgdGhlIHN0YXRlIG9mIHRoZSBnZW5lcmF0b3IuXG4vL1xuLy8gT24gQ2hyb21lLCB0aGlzIHBybmcgYmVuY2htYXJrcyBhYm91dCAyLjEgdGltZXMgc2xvd2VyIHRoYW5cbi8vIEphdmFzY3JpcHQncyBidWlsdC1pbiBNYXRoLnJhbmRvbSgpLlxuXG4oZnVuY3Rpb24oZ2xvYmFsLCBtb2R1bGUsIGRlZmluZSkge1xuXG5mdW5jdGlvbiBYb3JHZW4oc2VlZCkge1xuICB2YXIgbWUgPSB0aGlzO1xuXG4gIC8vIFNldCB1cCBnZW5lcmF0b3IgZnVuY3Rpb24uXG4gIG1lLm5leHQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdyA9IG1lLncsXG4gICAgICAgIFggPSBtZS5YLCBpID0gbWUuaSwgdCwgdjtcbiAgICAvLyBVcGRhdGUgV2V5bCBnZW5lcmF0b3IuXG4gICAgbWUudyA9IHcgPSAodyArIDB4NjFjODg2NDcpIHwgMDtcbiAgICAvLyBVcGRhdGUgeG9yIGdlbmVyYXRvci5cbiAgICB2ID0gWFsoaSArIDM0KSAmIDEyN107XG4gICAgdCA9IFhbaSA9ICgoaSArIDEpICYgMTI3KV07XG4gICAgdiBePSB2IDw8IDEzO1xuICAgIHQgXj0gdCA8PCAxNztcbiAgICB2IF49IHYgPj4+IDE1O1xuICAgIHQgXj0gdCA+Pj4gMTI7XG4gICAgLy8gVXBkYXRlIFhvciBnZW5lcmF0b3IgYXJyYXkgc3RhdGUuXG4gICAgdiA9IFhbaV0gPSB2IF4gdDtcbiAgICBtZS5pID0gaTtcbiAgICAvLyBSZXN1bHQgaXMgdGhlIGNvbWJpbmF0aW9uLlxuICAgIHJldHVybiAodiArICh3IF4gKHcgPj4+IDE2KSkpIHwgMDtcbiAgfTtcblxuICBmdW5jdGlvbiBpbml0KG1lLCBzZWVkKSB7XG4gICAgdmFyIHQsIHYsIGksIGosIHcsIFggPSBbXSwgbGltaXQgPSAxMjg7XG4gICAgaWYgKHNlZWQgPT09IChzZWVkIHwgMCkpIHtcbiAgICAgIC8vIE51bWVyaWMgc2VlZHMgaW5pdGlhbGl6ZSB2LCB3aGljaCBpcyB1c2VkIHRvIGdlbmVyYXRlcyBYLlxuICAgICAgdiA9IHNlZWQ7XG4gICAgICBzZWVkID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gU3RyaW5nIHNlZWRzIGFyZSBtaXhlZCBpbnRvIHYgYW5kIFggb25lIGNoYXJhY3RlciBhdCBhIHRpbWUuXG4gICAgICBzZWVkID0gc2VlZCArICdcXDAnO1xuICAgICAgdiA9IDA7XG4gICAgICBsaW1pdCA9IE1hdGgubWF4KGxpbWl0LCBzZWVkLmxlbmd0aCk7XG4gICAgfVxuICAgIC8vIEluaXRpYWxpemUgY2lyY3VsYXIgYXJyYXkgYW5kIHdleWwgdmFsdWUuXG4gICAgZm9yIChpID0gMCwgaiA9IC0zMjsgaiA8IGxpbWl0OyArK2opIHtcbiAgICAgIC8vIFB1dCB0aGUgdW5pY29kZSBjaGFyYWN0ZXJzIGludG8gdGhlIGFycmF5LCBhbmQgc2h1ZmZsZSB0aGVtLlxuICAgICAgaWYgKHNlZWQpIHYgXj0gc2VlZC5jaGFyQ29kZUF0KChqICsgMzIpICUgc2VlZC5sZW5ndGgpO1xuICAgICAgLy8gQWZ0ZXIgMzIgc2h1ZmZsZXMsIHRha2UgdiBhcyB0aGUgc3RhcnRpbmcgdyB2YWx1ZS5cbiAgICAgIGlmIChqID09PSAwKSB3ID0gdjtcbiAgICAgIHYgXj0gdiA8PCAxMDtcbiAgICAgIHYgXj0gdiA+Pj4gMTU7XG4gICAgICB2IF49IHYgPDwgNDtcbiAgICAgIHYgXj0gdiA+Pj4gMTM7XG4gICAgICBpZiAoaiA+PSAwKSB7XG4gICAgICAgIHcgPSAodyArIDB4NjFjODg2NDcpIHwgMDsgICAgIC8vIFdleWwuXG4gICAgICAgIHQgPSAoWFtqICYgMTI3XSBePSAodiArIHcpKTsgIC8vIENvbWJpbmUgeG9yIGFuZCB3ZXlsIHRvIGluaXQgYXJyYXkuXG4gICAgICAgIGkgPSAoMCA9PSB0KSA/IGkgKyAxIDogMDsgICAgIC8vIENvdW50IHplcm9lcy5cbiAgICAgIH1cbiAgICB9XG4gICAgLy8gV2UgaGF2ZSBkZXRlY3RlZCBhbGwgemVyb2VzOyBtYWtlIHRoZSBrZXkgbm9uemVyby5cbiAgICBpZiAoaSA+PSAxMjgpIHtcbiAgICAgIFhbKHNlZWQgJiYgc2VlZC5sZW5ndGggfHwgMCkgJiAxMjddID0gLTE7XG4gICAgfVxuICAgIC8vIFJ1biB0aGUgZ2VuZXJhdG9yIDUxMiB0aW1lcyB0byBmdXJ0aGVyIG1peCB0aGUgc3RhdGUgYmVmb3JlIHVzaW5nIGl0LlxuICAgIC8vIEZhY3RvcmluZyB0aGlzIGFzIGEgZnVuY3Rpb24gc2xvd3MgdGhlIG1haW4gZ2VuZXJhdG9yLCBzbyBpdCBpcyBqdXN0XG4gICAgLy8gdW5yb2xsZWQgaGVyZS4gIFRoZSB3ZXlsIGdlbmVyYXRvciBpcyBub3QgYWR2YW5jZWQgd2hpbGUgd2FybWluZyB1cC5cbiAgICBpID0gMTI3O1xuICAgIGZvciAoaiA9IDQgKiAxMjg7IGogPiAwOyAtLWopIHtcbiAgICAgIHYgPSBYWyhpICsgMzQpICYgMTI3XTtcbiAgICAgIHQgPSBYW2kgPSAoKGkgKyAxKSAmIDEyNyldO1xuICAgICAgdiBePSB2IDw8IDEzO1xuICAgICAgdCBePSB0IDw8IDE3O1xuICAgICAgdiBePSB2ID4+PiAxNTtcbiAgICAgIHQgXj0gdCA+Pj4gMTI7XG4gICAgICBYW2ldID0gdiBeIHQ7XG4gICAgfVxuICAgIC8vIFN0b3Jpbmcgc3RhdGUgYXMgb2JqZWN0IG1lbWJlcnMgaXMgZmFzdGVyIHRoYW4gdXNpbmcgY2xvc3VyZSB2YXJpYWJsZXMuXG4gICAgbWUudyA9IHc7XG4gICAgbWUuWCA9IFg7XG4gICAgbWUuaSA9IGk7XG4gIH1cblxuICBpbml0KG1lLCBzZWVkKTtcbn1cblxuZnVuY3Rpb24gY29weShmLCB0KSB7XG4gIHQuaSA9IGYuaTtcbiAgdC53ID0gZi53O1xuICB0LlggPSBmLlguc2xpY2UoKTtcbiAgcmV0dXJuIHQ7XG59O1xuXG5mdW5jdGlvbiBpbXBsKHNlZWQsIG9wdHMpIHtcbiAgaWYgKHNlZWQgPT0gbnVsbCkgc2VlZCA9ICsobmV3IERhdGUpO1xuICB2YXIgeGcgPSBuZXcgWG9yR2VuKHNlZWQpLFxuICAgICAgc3RhdGUgPSBvcHRzICYmIG9wdHMuc3RhdGUsXG4gICAgICBwcm5nID0gZnVuY3Rpb24oKSB7IHJldHVybiAoeGcubmV4dCgpID4+PiAwKSAvIDB4MTAwMDAwMDAwOyB9O1xuICBwcm5nLmRvdWJsZSA9IGZ1bmN0aW9uKCkge1xuICAgIGRvIHtcbiAgICAgIHZhciB0b3AgPSB4Zy5uZXh0KCkgPj4+IDExLFxuICAgICAgICAgIGJvdCA9ICh4Zy5uZXh0KCkgPj4+IDApIC8gMHgxMDAwMDAwMDAsXG4gICAgICAgICAgcmVzdWx0ID0gKHRvcCArIGJvdCkgLyAoMSA8PCAyMSk7XG4gICAgfSB3aGlsZSAocmVzdWx0ID09PSAwKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICBwcm5nLmludDMyID0geGcubmV4dDtcbiAgcHJuZy5xdWljayA9IHBybmc7XG4gIGlmIChzdGF0ZSkge1xuICAgIGlmIChzdGF0ZS5YKSBjb3B5KHN0YXRlLCB4Zyk7XG4gICAgcHJuZy5zdGF0ZSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gY29weSh4Zywge30pOyB9XG4gIH1cbiAgcmV0dXJuIHBybmc7XG59XG5cbmlmIChtb2R1bGUgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBpbXBsO1xufSBlbHNlIGlmIChkZWZpbmUgJiYgZGVmaW5lLmFtZCkge1xuICBkZWZpbmUoZnVuY3Rpb24oKSB7IHJldHVybiBpbXBsOyB9KTtcbn0gZWxzZSB7XG4gIHRoaXMueG9yNDA5NiA9IGltcGw7XG59XG5cbn0pKFxuICB0aGlzLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3aW5kb3cgb2JqZWN0IG9yIGdsb2JhbFxuICAodHlwZW9mIG1vZHVsZSkgPT0gJ29iamVjdCcgJiYgbW9kdWxlLCAgICAvLyBwcmVzZW50IGluIG5vZGUuanNcbiAgKHR5cGVvZiBkZWZpbmUpID09ICdmdW5jdGlvbicgJiYgZGVmaW5lICAgLy8gcHJlc2VudCB3aXRoIGFuIEFNRCBsb2FkZXJcbik7XG4iLCIvLyBBIEphdmFzY3JpcHQgaW1wbGVtZW50YWlvbiBvZiB0aGUgXCJ4b3JzaGlmdDdcIiBhbGdvcml0aG0gYnlcbi8vIEZyYW7Dp29pcyBQYW5uZXRvbiBhbmQgUGllcnJlIEwnZWN1eWVyOlxuLy8gXCJPbiB0aGUgWG9yZ3NoaWZ0IFJhbmRvbSBOdW1iZXIgR2VuZXJhdG9yc1wiXG4vLyBodHRwOi8vc2FsdWMuZW5nci51Y29ubi5lZHUvcmVmcy9jcnlwdG8vcm5nL3Bhbm5ldG9uMDVvbnRoZXhvcnNoaWZ0LnBkZlxuXG4oZnVuY3Rpb24oZ2xvYmFsLCBtb2R1bGUsIGRlZmluZSkge1xuXG5mdW5jdGlvbiBYb3JHZW4oc2VlZCkge1xuICB2YXIgbWUgPSB0aGlzO1xuXG4gIC8vIFNldCB1cCBnZW5lcmF0b3IgZnVuY3Rpb24uXG4gIG1lLm5leHQgPSBmdW5jdGlvbigpIHtcbiAgICAvLyBVcGRhdGUgeG9yIGdlbmVyYXRvci5cbiAgICB2YXIgWCA9IG1lLngsIGkgPSBtZS5pLCB0LCB2LCB3O1xuICAgIHQgPSBYW2ldOyB0IF49ICh0ID4+PiA3KTsgdiA9IHQgXiAodCA8PCAyNCk7XG4gICAgdCA9IFhbKGkgKyAxKSAmIDddOyB2IF49IHQgXiAodCA+Pj4gMTApO1xuICAgIHQgPSBYWyhpICsgMykgJiA3XTsgdiBePSB0IF4gKHQgPj4+IDMpO1xuICAgIHQgPSBYWyhpICsgNCkgJiA3XTsgdiBePSB0IF4gKHQgPDwgNyk7XG4gICAgdCA9IFhbKGkgKyA3KSAmIDddOyB0ID0gdCBeICh0IDw8IDEzKTsgdiBePSB0IF4gKHQgPDwgOSk7XG4gICAgWFtpXSA9IHY7XG4gICAgbWUuaSA9IChpICsgMSkgJiA3O1xuICAgIHJldHVybiB2O1xuICB9O1xuXG4gIGZ1bmN0aW9uIGluaXQobWUsIHNlZWQpIHtcbiAgICB2YXIgaiwgdywgWCA9IFtdO1xuXG4gICAgaWYgKHNlZWQgPT09IChzZWVkIHwgMCkpIHtcbiAgICAgIC8vIFNlZWQgc3RhdGUgYXJyYXkgdXNpbmcgYSAzMi1iaXQgaW50ZWdlci5cbiAgICAgIHcgPSBYWzBdID0gc2VlZDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gU2VlZCBzdGF0ZSB1c2luZyBhIHN0cmluZy5cbiAgICAgIHNlZWQgPSAnJyArIHNlZWQ7XG4gICAgICBmb3IgKGogPSAwOyBqIDwgc2VlZC5sZW5ndGg7ICsraikge1xuICAgICAgICBYW2ogJiA3XSA9IChYW2ogJiA3XSA8PCAxNSkgXlxuICAgICAgICAgICAgKHNlZWQuY2hhckNvZGVBdChqKSArIFhbKGogKyAxKSAmIDddIDw8IDEzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gRW5mb3JjZSBhbiBhcnJheSBsZW5ndGggb2YgOCwgbm90IGFsbCB6ZXJvZXMuXG4gICAgd2hpbGUgKFgubGVuZ3RoIDwgOCkgWC5wdXNoKDApO1xuICAgIGZvciAoaiA9IDA7IGogPCA4ICYmIFhbal0gPT09IDA7ICsraik7XG4gICAgaWYgKGogPT0gOCkgdyA9IFhbN10gPSAtMTsgZWxzZSB3ID0gWFtqXTtcblxuICAgIG1lLnggPSBYO1xuICAgIG1lLmkgPSAwO1xuXG4gICAgLy8gRGlzY2FyZCBhbiBpbml0aWFsIDI1NiB2YWx1ZXMuXG4gICAgZm9yIChqID0gMjU2OyBqID4gMDsgLS1qKSB7XG4gICAgICBtZS5uZXh0KCk7XG4gICAgfVxuICB9XG5cbiAgaW5pdChtZSwgc2VlZCk7XG59XG5cbmZ1bmN0aW9uIGNvcHkoZiwgdCkge1xuICB0LnggPSBmLnguc2xpY2UoKTtcbiAgdC5pID0gZi5pO1xuICByZXR1cm4gdDtcbn1cblxuZnVuY3Rpb24gaW1wbChzZWVkLCBvcHRzKSB7XG4gIGlmIChzZWVkID09IG51bGwpIHNlZWQgPSArKG5ldyBEYXRlKTtcbiAgdmFyIHhnID0gbmV3IFhvckdlbihzZWVkKSxcbiAgICAgIHN0YXRlID0gb3B0cyAmJiBvcHRzLnN0YXRlLFxuICAgICAgcHJuZyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gKHhnLm5leHQoKSA+Pj4gMCkgLyAweDEwMDAwMDAwMDsgfTtcbiAgcHJuZy5kb3VibGUgPSBmdW5jdGlvbigpIHtcbiAgICBkbyB7XG4gICAgICB2YXIgdG9wID0geGcubmV4dCgpID4+PiAxMSxcbiAgICAgICAgICBib3QgPSAoeGcubmV4dCgpID4+PiAwKSAvIDB4MTAwMDAwMDAwLFxuICAgICAgICAgIHJlc3VsdCA9ICh0b3AgKyBib3QpIC8gKDEgPDwgMjEpO1xuICAgIH0gd2hpbGUgKHJlc3VsdCA9PT0gMCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbiAgcHJuZy5pbnQzMiA9IHhnLm5leHQ7XG4gIHBybmcucXVpY2sgPSBwcm5nO1xuICBpZiAoc3RhdGUpIHtcbiAgICBpZiAoc3RhdGUueCkgY29weShzdGF0ZSwgeGcpO1xuICAgIHBybmcuc3RhdGUgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGNvcHkoeGcsIHt9KTsgfVxuICB9XG4gIHJldHVybiBwcm5nO1xufVxuXG5pZiAobW9kdWxlICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gaW1wbDtcbn0gZWxzZSBpZiAoZGVmaW5lICYmIGRlZmluZS5hbWQpIHtcbiAgZGVmaW5lKGZ1bmN0aW9uKCkgeyByZXR1cm4gaW1wbDsgfSk7XG59IGVsc2Uge1xuICB0aGlzLnhvcnNoaWZ0NyA9IGltcGw7XG59XG5cbn0pKFxuICB0aGlzLFxuICAodHlwZW9mIG1vZHVsZSkgPT0gJ29iamVjdCcgJiYgbW9kdWxlLCAgICAvLyBwcmVzZW50IGluIG5vZGUuanNcbiAgKHR5cGVvZiBkZWZpbmUpID09ICdmdW5jdGlvbicgJiYgZGVmaW5lICAgLy8gcHJlc2VudCB3aXRoIGFuIEFNRCBsb2FkZXJcbik7XG5cbiIsIi8vIEEgSmF2YXNjcmlwdCBpbXBsZW1lbnRhaW9uIG9mIHRoZSBcInhvcndvd1wiIHBybmcgYWxnb3JpdGhtIGJ5XG4vLyBHZW9yZ2UgTWFyc2FnbGlhLiAgU2VlIGh0dHA6Ly93d3cuanN0YXRzb2Z0Lm9yZy92MDgvaTE0L3BhcGVyXG5cbihmdW5jdGlvbihnbG9iYWwsIG1vZHVsZSwgZGVmaW5lKSB7XG5cbmZ1bmN0aW9uIFhvckdlbihzZWVkKSB7XG4gIHZhciBtZSA9IHRoaXMsIHN0cnNlZWQgPSAnJztcblxuICAvLyBTZXQgdXAgZ2VuZXJhdG9yIGZ1bmN0aW9uLlxuICBtZS5uZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHQgPSAobWUueCBeIChtZS54ID4+PiAyKSk7XG4gICAgbWUueCA9IG1lLnk7IG1lLnkgPSBtZS56OyBtZS56ID0gbWUudzsgbWUudyA9IG1lLnY7XG4gICAgcmV0dXJuIChtZS5kID0gKG1lLmQgKyAzNjI0MzcgfCAwKSkgK1xuICAgICAgIChtZS52ID0gKG1lLnYgXiAobWUudiA8PCA0KSkgXiAodCBeICh0IDw8IDEpKSkgfCAwO1xuICB9O1xuXG4gIG1lLnggPSAwO1xuICBtZS55ID0gMDtcbiAgbWUueiA9IDA7XG4gIG1lLncgPSAwO1xuICBtZS52ID0gMDtcblxuICBpZiAoc2VlZCA9PT0gKHNlZWQgfCAwKSkge1xuICAgIC8vIEludGVnZXIgc2VlZC5cbiAgICBtZS54ID0gc2VlZDtcbiAgfSBlbHNlIHtcbiAgICAvLyBTdHJpbmcgc2VlZC5cbiAgICBzdHJzZWVkICs9IHNlZWQ7XG4gIH1cblxuICAvLyBNaXggaW4gc3RyaW5nIHNlZWQsIHRoZW4gZGlzY2FyZCBhbiBpbml0aWFsIGJhdGNoIG9mIDY0IHZhbHVlcy5cbiAgZm9yICh2YXIgayA9IDA7IGsgPCBzdHJzZWVkLmxlbmd0aCArIDY0OyBrKyspIHtcbiAgICBtZS54IF49IHN0cnNlZWQuY2hhckNvZGVBdChrKSB8IDA7XG4gICAgaWYgKGsgPT0gc3Ryc2VlZC5sZW5ndGgpIHtcbiAgICAgIG1lLmQgPSBtZS54IDw8IDEwIF4gbWUueCA+Pj4gNDtcbiAgICB9XG4gICAgbWUubmV4dCgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNvcHkoZiwgdCkge1xuICB0LnggPSBmLng7XG4gIHQueSA9IGYueTtcbiAgdC56ID0gZi56O1xuICB0LncgPSBmLnc7XG4gIHQudiA9IGYudjtcbiAgdC5kID0gZi5kO1xuICByZXR1cm4gdDtcbn1cblxuZnVuY3Rpb24gaW1wbChzZWVkLCBvcHRzKSB7XG4gIHZhciB4ZyA9IG5ldyBYb3JHZW4oc2VlZCksXG4gICAgICBzdGF0ZSA9IG9wdHMgJiYgb3B0cy5zdGF0ZSxcbiAgICAgIHBybmcgPSBmdW5jdGlvbigpIHsgcmV0dXJuICh4Zy5uZXh0KCkgPj4+IDApIC8gMHgxMDAwMDAwMDA7IH07XG4gIHBybmcuZG91YmxlID0gZnVuY3Rpb24oKSB7XG4gICAgZG8ge1xuICAgICAgdmFyIHRvcCA9IHhnLm5leHQoKSA+Pj4gMTEsXG4gICAgICAgICAgYm90ID0gKHhnLm5leHQoKSA+Pj4gMCkgLyAweDEwMDAwMDAwMCxcbiAgICAgICAgICByZXN1bHQgPSAodG9wICsgYm90KSAvICgxIDw8IDIxKTtcbiAgICB9IHdoaWxlIChyZXN1bHQgPT09IDApO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG4gIHBybmcuaW50MzIgPSB4Zy5uZXh0O1xuICBwcm5nLnF1aWNrID0gcHJuZztcbiAgaWYgKHN0YXRlKSB7XG4gICAgaWYgKHR5cGVvZihzdGF0ZSkgPT0gJ29iamVjdCcpIGNvcHkoc3RhdGUsIHhnKTtcbiAgICBwcm5nLnN0YXRlID0gZnVuY3Rpb24oKSB7IHJldHVybiBjb3B5KHhnLCB7fSk7IH1cbiAgfVxuICByZXR1cm4gcHJuZztcbn1cblxuaWYgKG1vZHVsZSAmJiBtb2R1bGUuZXhwb3J0cykge1xuICBtb2R1bGUuZXhwb3J0cyA9IGltcGw7XG59IGVsc2UgaWYgKGRlZmluZSAmJiBkZWZpbmUuYW1kKSB7XG4gIGRlZmluZShmdW5jdGlvbigpIHsgcmV0dXJuIGltcGw7IH0pO1xufSBlbHNlIHtcbiAgdGhpcy54b3J3b3cgPSBpbXBsO1xufVxuXG59KShcbiAgdGhpcyxcbiAgKHR5cGVvZiBtb2R1bGUpID09ICdvYmplY3QnICYmIG1vZHVsZSwgICAgLy8gcHJlc2VudCBpbiBub2RlLmpzXG4gICh0eXBlb2YgZGVmaW5lKSA9PSAnZnVuY3Rpb24nICYmIGRlZmluZSAgIC8vIHByZXNlbnQgd2l0aCBhbiBBTUQgbG9hZGVyXG4pO1xuXG5cbiIsIi8qXG5Db3B5cmlnaHQgMjAxNCBEYXZpZCBCYXUuXG5cblBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZ1xuYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG5cIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbndpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbmRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0b1xucGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvXG50aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG5pbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbkVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULlxuSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTllcbkNMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsXG5UT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRVxuU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbiovXG5cbihmdW5jdGlvbiAocG9vbCwgbWF0aCkge1xuLy9cbi8vIFRoZSBmb2xsb3dpbmcgY29uc3RhbnRzIGFyZSByZWxhdGVkIHRvIElFRUUgNzU0IGxpbWl0cy5cbi8vXG52YXIgZ2xvYmFsID0gdGhpcyxcbiAgICB3aWR0aCA9IDI1NiwgICAgICAgIC8vIGVhY2ggUkM0IG91dHB1dCBpcyAwIDw9IHggPCAyNTZcbiAgICBjaHVua3MgPSA2LCAgICAgICAgIC8vIGF0IGxlYXN0IHNpeCBSQzQgb3V0cHV0cyBmb3IgZWFjaCBkb3VibGVcbiAgICBkaWdpdHMgPSA1MiwgICAgICAgIC8vIHRoZXJlIGFyZSA1MiBzaWduaWZpY2FudCBkaWdpdHMgaW4gYSBkb3VibGVcbiAgICBybmduYW1lID0gJ3JhbmRvbScsIC8vIHJuZ25hbWU6IG5hbWUgZm9yIE1hdGgucmFuZG9tIGFuZCBNYXRoLnNlZWRyYW5kb21cbiAgICBzdGFydGRlbm9tID0gbWF0aC5wb3cod2lkdGgsIGNodW5rcyksXG4gICAgc2lnbmlmaWNhbmNlID0gbWF0aC5wb3coMiwgZGlnaXRzKSxcbiAgICBvdmVyZmxvdyA9IHNpZ25pZmljYW5jZSAqIDIsXG4gICAgbWFzayA9IHdpZHRoIC0gMSxcbiAgICBub2RlY3J5cHRvOyAgICAgICAgIC8vIG5vZGUuanMgY3J5cHRvIG1vZHVsZSwgaW5pdGlhbGl6ZWQgYXQgdGhlIGJvdHRvbS5cblxuLy9cbi8vIHNlZWRyYW5kb20oKVxuLy8gVGhpcyBpcyB0aGUgc2VlZHJhbmRvbSBmdW5jdGlvbiBkZXNjcmliZWQgYWJvdmUuXG4vL1xuZnVuY3Rpb24gc2VlZHJhbmRvbShzZWVkLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICB2YXIga2V5ID0gW107XG4gIG9wdGlvbnMgPSAob3B0aW9ucyA9PSB0cnVlKSA/IHsgZW50cm9weTogdHJ1ZSB9IDogKG9wdGlvbnMgfHwge30pO1xuXG4gIC8vIEZsYXR0ZW4gdGhlIHNlZWQgc3RyaW5nIG9yIGJ1aWxkIG9uZSBmcm9tIGxvY2FsIGVudHJvcHkgaWYgbmVlZGVkLlxuICB2YXIgc2hvcnRzZWVkID0gbWl4a2V5KGZsYXR0ZW4oXG4gICAgb3B0aW9ucy5lbnRyb3B5ID8gW3NlZWQsIHRvc3RyaW5nKHBvb2wpXSA6XG4gICAgKHNlZWQgPT0gbnVsbCkgPyBhdXRvc2VlZCgpIDogc2VlZCwgMyksIGtleSk7XG5cbiAgLy8gVXNlIHRoZSBzZWVkIHRvIGluaXRpYWxpemUgYW4gQVJDNCBnZW5lcmF0b3IuXG4gIHZhciBhcmM0ID0gbmV3IEFSQzQoa2V5KTtcblxuICAvLyBUaGlzIGZ1bmN0aW9uIHJldHVybnMgYSByYW5kb20gZG91YmxlIGluIFswLCAxKSB0aGF0IGNvbnRhaW5zXG4gIC8vIHJhbmRvbW5lc3MgaW4gZXZlcnkgYml0IG9mIHRoZSBtYW50aXNzYSBvZiB0aGUgSUVFRSA3NTQgdmFsdWUuXG4gIHZhciBwcm5nID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG4gPSBhcmM0LmcoY2h1bmtzKSwgICAgICAgICAgICAgLy8gU3RhcnQgd2l0aCBhIG51bWVyYXRvciBuIDwgMiBeIDQ4XG4gICAgICAgIGQgPSBzdGFydGRlbm9tLCAgICAgICAgICAgICAgICAgLy8gICBhbmQgZGVub21pbmF0b3IgZCA9IDIgXiA0OC5cbiAgICAgICAgeCA9IDA7ICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgIGFuZCBubyAnZXh0cmEgbGFzdCBieXRlJy5cbiAgICB3aGlsZSAobiA8IHNpZ25pZmljYW5jZSkgeyAgICAgICAgICAvLyBGaWxsIHVwIGFsbCBzaWduaWZpY2FudCBkaWdpdHMgYnlcbiAgICAgIG4gPSAobiArIHgpICogd2lkdGg7ICAgICAgICAgICAgICAvLyAgIHNoaWZ0aW5nIG51bWVyYXRvciBhbmRcbiAgICAgIGQgKj0gd2lkdGg7ICAgICAgICAgICAgICAgICAgICAgICAvLyAgIGRlbm9taW5hdG9yIGFuZCBnZW5lcmF0aW5nIGFcbiAgICAgIHggPSBhcmM0LmcoMSk7ICAgICAgICAgICAgICAgICAgICAvLyAgIG5ldyBsZWFzdC1zaWduaWZpY2FudC1ieXRlLlxuICAgIH1cbiAgICB3aGlsZSAobiA+PSBvdmVyZmxvdykgeyAgICAgICAgICAgICAvLyBUbyBhdm9pZCByb3VuZGluZyB1cCwgYmVmb3JlIGFkZGluZ1xuICAgICAgbiAvPSAyOyAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgbGFzdCBieXRlLCBzaGlmdCBldmVyeXRoaW5nXG4gICAgICBkIC89IDI7ICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICByaWdodCB1c2luZyBpbnRlZ2VyIG1hdGggdW50aWxcbiAgICAgIHggPj4+PSAxOyAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgIHdlIGhhdmUgZXhhY3RseSB0aGUgZGVzaXJlZCBiaXRzLlxuICAgIH1cbiAgICByZXR1cm4gKG4gKyB4KSAvIGQ7ICAgICAgICAgICAgICAgICAvLyBGb3JtIHRoZSBudW1iZXIgd2l0aGluIFswLCAxKS5cbiAgfTtcblxuICBwcm5nLmludDMyID0gZnVuY3Rpb24oKSB7IHJldHVybiBhcmM0LmcoNCkgfCAwOyB9XG4gIHBybmcucXVpY2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGFyYzQuZyg0KSAvIDB4MTAwMDAwMDAwOyB9XG4gIHBybmcuZG91YmxlID0gcHJuZztcblxuICAvLyBNaXggdGhlIHJhbmRvbW5lc3MgaW50byBhY2N1bXVsYXRlZCBlbnRyb3B5LlxuICBtaXhrZXkodG9zdHJpbmcoYXJjNC5TKSwgcG9vbCk7XG5cbiAgLy8gQ2FsbGluZyBjb252ZW50aW9uOiB3aGF0IHRvIHJldHVybiBhcyBhIGZ1bmN0aW9uIG9mIHBybmcsIHNlZWQsIGlzX21hdGguXG4gIHJldHVybiAob3B0aW9ucy5wYXNzIHx8IGNhbGxiYWNrIHx8XG4gICAgICBmdW5jdGlvbihwcm5nLCBzZWVkLCBpc19tYXRoX2NhbGwsIHN0YXRlKSB7XG4gICAgICAgIGlmIChzdGF0ZSkge1xuICAgICAgICAgIC8vIExvYWQgdGhlIGFyYzQgc3RhdGUgZnJvbSB0aGUgZ2l2ZW4gc3RhdGUgaWYgaXQgaGFzIGFuIFMgYXJyYXkuXG4gICAgICAgICAgaWYgKHN0YXRlLlMpIHsgY29weShzdGF0ZSwgYXJjNCk7IH1cbiAgICAgICAgICAvLyBPbmx5IHByb3ZpZGUgdGhlIC5zdGF0ZSBtZXRob2QgaWYgcmVxdWVzdGVkIHZpYSBvcHRpb25zLnN0YXRlLlxuICAgICAgICAgIHBybmcuc3RhdGUgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGNvcHkoYXJjNCwge30pOyB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiBjYWxsZWQgYXMgYSBtZXRob2Qgb2YgTWF0aCAoTWF0aC5zZWVkcmFuZG9tKCkpLCBtdXRhdGVcbiAgICAgICAgLy8gTWF0aC5yYW5kb20gYmVjYXVzZSB0aGF0IGlzIGhvdyBzZWVkcmFuZG9tLmpzIGhhcyB3b3JrZWQgc2luY2UgdjEuMC5cbiAgICAgICAgaWYgKGlzX21hdGhfY2FsbCkgeyBtYXRoW3JuZ25hbWVdID0gcHJuZzsgcmV0dXJuIHNlZWQ7IH1cblxuICAgICAgICAvLyBPdGhlcndpc2UsIGl0IGlzIGEgbmV3ZXIgY2FsbGluZyBjb252ZW50aW9uLCBzbyByZXR1cm4gdGhlXG4gICAgICAgIC8vIHBybmcgZGlyZWN0bHkuXG4gICAgICAgIGVsc2UgcmV0dXJuIHBybmc7XG4gICAgICB9KShcbiAgcHJuZyxcbiAgc2hvcnRzZWVkLFxuICAnZ2xvYmFsJyBpbiBvcHRpb25zID8gb3B0aW9ucy5nbG9iYWwgOiAodGhpcyA9PSBtYXRoKSxcbiAgb3B0aW9ucy5zdGF0ZSk7XG59XG5tYXRoWydzZWVkJyArIHJuZ25hbWVdID0gc2VlZHJhbmRvbTtcblxuLy9cbi8vIEFSQzRcbi8vXG4vLyBBbiBBUkM0IGltcGxlbWVudGF0aW9uLiAgVGhlIGNvbnN0cnVjdG9yIHRha2VzIGEga2V5IGluIHRoZSBmb3JtIG9mXG4vLyBhbiBhcnJheSBvZiBhdCBtb3N0ICh3aWR0aCkgaW50ZWdlcnMgdGhhdCBzaG91bGQgYmUgMCA8PSB4IDwgKHdpZHRoKS5cbi8vXG4vLyBUaGUgZyhjb3VudCkgbWV0aG9kIHJldHVybnMgYSBwc2V1ZG9yYW5kb20gaW50ZWdlciB0aGF0IGNvbmNhdGVuYXRlc1xuLy8gdGhlIG5leHQgKGNvdW50KSBvdXRwdXRzIGZyb20gQVJDNC4gIEl0cyByZXR1cm4gdmFsdWUgaXMgYSBudW1iZXIgeFxuLy8gdGhhdCBpcyBpbiB0aGUgcmFuZ2UgMCA8PSB4IDwgKHdpZHRoIF4gY291bnQpLlxuLy9cbmZ1bmN0aW9uIEFSQzQoa2V5KSB7XG4gIHZhciB0LCBrZXlsZW4gPSBrZXkubGVuZ3RoLFxuICAgICAgbWUgPSB0aGlzLCBpID0gMCwgaiA9IG1lLmkgPSBtZS5qID0gMCwgcyA9IG1lLlMgPSBbXTtcblxuICAvLyBUaGUgZW1wdHkga2V5IFtdIGlzIHRyZWF0ZWQgYXMgWzBdLlxuICBpZiAoIWtleWxlbikgeyBrZXkgPSBba2V5bGVuKytdOyB9XG5cbiAgLy8gU2V0IHVwIFMgdXNpbmcgdGhlIHN0YW5kYXJkIGtleSBzY2hlZHVsaW5nIGFsZ29yaXRobS5cbiAgd2hpbGUgKGkgPCB3aWR0aCkge1xuICAgIHNbaV0gPSBpKys7XG4gIH1cbiAgZm9yIChpID0gMDsgaSA8IHdpZHRoOyBpKyspIHtcbiAgICBzW2ldID0gc1tqID0gbWFzayAmIChqICsga2V5W2kgJSBrZXlsZW5dICsgKHQgPSBzW2ldKSldO1xuICAgIHNbal0gPSB0O1xuICB9XG5cbiAgLy8gVGhlIFwiZ1wiIG1ldGhvZCByZXR1cm5zIHRoZSBuZXh0IChjb3VudCkgb3V0cHV0cyBhcyBvbmUgbnVtYmVyLlxuICAobWUuZyA9IGZ1bmN0aW9uKGNvdW50KSB7XG4gICAgLy8gVXNpbmcgaW5zdGFuY2UgbWVtYmVycyBpbnN0ZWFkIG9mIGNsb3N1cmUgc3RhdGUgbmVhcmx5IGRvdWJsZXMgc3BlZWQuXG4gICAgdmFyIHQsIHIgPSAwLFxuICAgICAgICBpID0gbWUuaSwgaiA9IG1lLmosIHMgPSBtZS5TO1xuICAgIHdoaWxlIChjb3VudC0tKSB7XG4gICAgICB0ID0gc1tpID0gbWFzayAmIChpICsgMSldO1xuICAgICAgciA9IHIgKiB3aWR0aCArIHNbbWFzayAmICgoc1tpXSA9IHNbaiA9IG1hc2sgJiAoaiArIHQpXSkgKyAoc1tqXSA9IHQpKV07XG4gICAgfVxuICAgIG1lLmkgPSBpOyBtZS5qID0gajtcbiAgICByZXR1cm4gcjtcbiAgICAvLyBGb3Igcm9idXN0IHVucHJlZGljdGFiaWxpdHksIHRoZSBmdW5jdGlvbiBjYWxsIGJlbG93IGF1dG9tYXRpY2FsbHlcbiAgICAvLyBkaXNjYXJkcyBhbiBpbml0aWFsIGJhdGNoIG9mIHZhbHVlcy4gIFRoaXMgaXMgY2FsbGVkIFJDNC1kcm9wWzI1Nl0uXG4gICAgLy8gU2VlIGh0dHA6Ly9nb29nbGUuY29tL3NlYXJjaD9xPXJzYStmbHVocmVyK3Jlc3BvbnNlJmJ0bklcbiAgfSkod2lkdGgpO1xufVxuXG4vL1xuLy8gY29weSgpXG4vLyBDb3BpZXMgaW50ZXJuYWwgc3RhdGUgb2YgQVJDNCB0byBvciBmcm9tIGEgcGxhaW4gb2JqZWN0LlxuLy9cbmZ1bmN0aW9uIGNvcHkoZiwgdCkge1xuICB0LmkgPSBmLmk7XG4gIHQuaiA9IGYuajtcbiAgdC5TID0gZi5TLnNsaWNlKCk7XG4gIHJldHVybiB0O1xufTtcblxuLy9cbi8vIGZsYXR0ZW4oKVxuLy8gQ29udmVydHMgYW4gb2JqZWN0IHRyZWUgdG8gbmVzdGVkIGFycmF5cyBvZiBzdHJpbmdzLlxuLy9cbmZ1bmN0aW9uIGZsYXR0ZW4ob2JqLCBkZXB0aCkge1xuICB2YXIgcmVzdWx0ID0gW10sIHR5cCA9ICh0eXBlb2Ygb2JqKSwgcHJvcDtcbiAgaWYgKGRlcHRoICYmIHR5cCA9PSAnb2JqZWN0Jykge1xuICAgIGZvciAocHJvcCBpbiBvYmopIHtcbiAgICAgIHRyeSB7IHJlc3VsdC5wdXNoKGZsYXR0ZW4ob2JqW3Byb3BdLCBkZXB0aCAtIDEpKTsgfSBjYXRjaCAoZSkge31cbiAgICB9XG4gIH1cbiAgcmV0dXJuIChyZXN1bHQubGVuZ3RoID8gcmVzdWx0IDogdHlwID09ICdzdHJpbmcnID8gb2JqIDogb2JqICsgJ1xcMCcpO1xufVxuXG4vL1xuLy8gbWl4a2V5KClcbi8vIE1peGVzIGEgc3RyaW5nIHNlZWQgaW50byBhIGtleSB0aGF0IGlzIGFuIGFycmF5IG9mIGludGVnZXJzLCBhbmRcbi8vIHJldHVybnMgYSBzaG9ydGVuZWQgc3RyaW5nIHNlZWQgdGhhdCBpcyBlcXVpdmFsZW50IHRvIHRoZSByZXN1bHQga2V5LlxuLy9cbmZ1bmN0aW9uIG1peGtleShzZWVkLCBrZXkpIHtcbiAgdmFyIHN0cmluZ3NlZWQgPSBzZWVkICsgJycsIHNtZWFyLCBqID0gMDtcbiAgd2hpbGUgKGogPCBzdHJpbmdzZWVkLmxlbmd0aCkge1xuICAgIGtleVttYXNrICYgal0gPVxuICAgICAgbWFzayAmICgoc21lYXIgXj0ga2V5W21hc2sgJiBqXSAqIDE5KSArIHN0cmluZ3NlZWQuY2hhckNvZGVBdChqKyspKTtcbiAgfVxuICByZXR1cm4gdG9zdHJpbmcoa2V5KTtcbn1cblxuLy9cbi8vIGF1dG9zZWVkKClcbi8vIFJldHVybnMgYW4gb2JqZWN0IGZvciBhdXRvc2VlZGluZywgdXNpbmcgd2luZG93LmNyeXB0byBhbmQgTm9kZSBjcnlwdG9cbi8vIG1vZHVsZSBpZiBhdmFpbGFibGUuXG4vL1xuZnVuY3Rpb24gYXV0b3NlZWQoKSB7XG4gIHRyeSB7XG4gICAgdmFyIG91dDtcbiAgICBpZiAobm9kZWNyeXB0byAmJiAob3V0ID0gbm9kZWNyeXB0by5yYW5kb21CeXRlcykpIHtcbiAgICAgIC8vIFRoZSB1c2Ugb2YgJ291dCcgdG8gcmVtZW1iZXIgcmFuZG9tQnl0ZXMgbWFrZXMgdGlnaHQgbWluaWZpZWQgY29kZS5cbiAgICAgIG91dCA9IG91dCh3aWR0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dCA9IG5ldyBVaW50OEFycmF5KHdpZHRoKTtcbiAgICAgIChnbG9iYWwuY3J5cHRvIHx8IGdsb2JhbC5tc0NyeXB0bykuZ2V0UmFuZG9tVmFsdWVzKG91dCk7XG4gICAgfVxuICAgIHJldHVybiB0b3N0cmluZyhvdXQpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdmFyIGJyb3dzZXIgPSBnbG9iYWwubmF2aWdhdG9yLFxuICAgICAgICBwbHVnaW5zID0gYnJvd3NlciAmJiBicm93c2VyLnBsdWdpbnM7XG4gICAgcmV0dXJuIFsrbmV3IERhdGUsIGdsb2JhbCwgcGx1Z2lucywgZ2xvYmFsLnNjcmVlbiwgdG9zdHJpbmcocG9vbCldO1xuICB9XG59XG5cbi8vXG4vLyB0b3N0cmluZygpXG4vLyBDb252ZXJ0cyBhbiBhcnJheSBvZiBjaGFyY29kZXMgdG8gYSBzdHJpbmdcbi8vXG5mdW5jdGlvbiB0b3N0cmluZyhhKSB7XG4gIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KDAsIGEpO1xufVxuXG4vL1xuLy8gV2hlbiBzZWVkcmFuZG9tLmpzIGlzIGxvYWRlZCwgd2UgaW1tZWRpYXRlbHkgbWl4IGEgZmV3IGJpdHNcbi8vIGZyb20gdGhlIGJ1aWx0LWluIFJORyBpbnRvIHRoZSBlbnRyb3B5IHBvb2wuICBCZWNhdXNlIHdlIGRvXG4vLyBub3Qgd2FudCB0byBpbnRlcmZlcmUgd2l0aCBkZXRlcm1pbmlzdGljIFBSTkcgc3RhdGUgbGF0ZXIsXG4vLyBzZWVkcmFuZG9tIHdpbGwgbm90IGNhbGwgbWF0aC5yYW5kb20gb24gaXRzIG93biBhZ2FpbiBhZnRlclxuLy8gaW5pdGlhbGl6YXRpb24uXG4vL1xubWl4a2V5KG1hdGgucmFuZG9tKCksIHBvb2wpO1xuXG4vL1xuLy8gTm9kZWpzIGFuZCBBTUQgc3VwcG9ydDogZXhwb3J0IHRoZSBpbXBsZW1lbnRhdGlvbiBhcyBhIG1vZHVsZSB1c2luZ1xuLy8gZWl0aGVyIGNvbnZlbnRpb24uXG4vL1xuaWYgKCh0eXBlb2YgbW9kdWxlKSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHNlZWRyYW5kb207XG4gIC8vIFdoZW4gaW4gbm9kZS5qcywgdHJ5IHVzaW5nIGNyeXB0byBwYWNrYWdlIGZvciBhdXRvc2VlZGluZy5cbiAgdHJ5IHtcbiAgICBub2RlY3J5cHRvID0gcmVxdWlyZSgnY3J5cHRvJyk7XG4gIH0gY2F0Y2ggKGV4KSB7fVxufSBlbHNlIGlmICgodHlwZW9mIGRlZmluZSkgPT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gIGRlZmluZShmdW5jdGlvbigpIHsgcmV0dXJuIHNlZWRyYW5kb207IH0pO1xufVxuXG4vLyBFbmQgYW5vbnltb3VzIHNjb3BlLCBhbmQgcGFzcyBpbml0aWFsIHZhbHVlcy5cbn0pKFxuICBbXSwgICAgIC8vIHBvb2w6IGVudHJvcHkgcG9vbCBzdGFydHMgZW1wdHlcbiAgTWF0aCAgICAvLyBtYXRoOiBwYWNrYWdlIGNvbnRhaW5pbmcgcmFuZG9tLCBwb3csIGFuZCBzZWVkcmFuZG9tXG4pO1xuIiwiIWZ1bmN0aW9uKGUsdCl7XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMmJlwib2JqZWN0XCI9PXR5cGVvZiBtb2R1bGU/bW9kdWxlLmV4cG9ydHM9dChyZXF1aXJlKFwidG9uZVwiKSk6XCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShbXCJ0b25lXCJdLHQpOlwib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzP2V4cG9ydHMuUGlhbm89dChyZXF1aXJlKFwidG9uZVwiKSk6ZS5QaWFubz10KGUudG9uZSl9KHRoaXMsZnVuY3Rpb24oZSl7cmV0dXJuIGZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQobyl7aWYobltvXSlyZXR1cm4gbltvXS5leHBvcnRzO3ZhciByPW5bb109e2k6byxsOiExLGV4cG9ydHM6e319O3JldHVybiBlW29dLmNhbGwoci5leHBvcnRzLHIsci5leHBvcnRzLHQpLHIubD0hMCxyLmV4cG9ydHN9dmFyIG49e307cmV0dXJuIHQubT1lLHQuYz1uLHQuaT1mdW5jdGlvbihlKXtyZXR1cm4gZX0sdC5kPWZ1bmN0aW9uKGUsbixvKXt0Lm8oZSxuKXx8T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsbix7Y29uZmlndXJhYmxlOiExLGVudW1lcmFibGU6ITAsZ2V0Om99KX0sdC5uPWZ1bmN0aW9uKGUpe3ZhciBuPWUmJmUuX19lc01vZHVsZT9mdW5jdGlvbigpe3JldHVybiBlLmRlZmF1bHR9OmZ1bmN0aW9uKCl7cmV0dXJuIGV9O3JldHVybiB0LmQobixcImFcIixuKSxufSx0Lm89ZnVuY3Rpb24oZSx0KXtyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsdCl9LHQucD1cIlwiLHQodC5zPTgpfShbZnVuY3Rpb24odCxuKXt0LmV4cG9ydHM9ZX0sZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBvPW4oMik7dC5kZWZhdWx0PXtnZXRSZWxlYXNlc1VybDpmdW5jdGlvbihlKXtyZXR1cm5cInJlbFwiKyhlLTIwKStcIi5tcDM/XCIrKDEwMCpNYXRoLnJhbmRvbSgpKS50b0ZpeGVkKDApfSxnZXRIYXJtb25pY3NVcmw6ZnVuY3Rpb24oZSl7cmV0dXJuXCJoYXJtTFwiKygwLG8ubWlkaVRvTm90ZSkoZSkucmVwbGFjZShcIiNcIixcInNcIikrXCIubXAzP1wiKygxMDAqTWF0aC5yYW5kb20oKSkudG9GaXhlZCgwKX0sZ2V0Tm90ZXNVcmw6ZnVuY3Rpb24oZSx0KXtyZXR1cm4oMCxvLm1pZGlUb05vdGUpKGUpLnJlcGxhY2UoXCIjXCIsXCJzXCIpK1widlwiK3QrXCIubXAzP1wiKygxMDAqTWF0aC5yYW5kb20oKSkudG9GaXhlZCgwKX19fSxmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gbyhlKXtyZXR1cm4oMCxzLkZyZXF1ZW5jeSkoZSkudG9NaWRpKCl9ZnVuY3Rpb24gcihlKXtyZXR1cm4oMCxzLkZyZXF1ZW5jeSkoZSxcIm1pZGlcIikudG9Ob3RlKCl9ZnVuY3Rpb24gaShlKXt2YXIgdD1lJTM7cmV0dXJuIDE9PT10P1tlLTEsYy5kZWZhdWx0LmludGVydmFsVG9GcmVxdWVuY3lSYXRpbygxKV06Mj09PXQ/W2UrMSxjLmRlZmF1bHQuaW50ZXJ2YWxUb0ZyZXF1ZW5jeVJhdGlvKC0xKV06W2UsMV19ZnVuY3Rpb24gdShlKXtyZXR1cm4gbmV3IHMuQnVmZmVyU291cmNlKGUpfWZ1bmN0aW9uIGEoZSx0KXtyZXR1cm4gTWF0aC5yYW5kb20oKSoodC1lKStlfU9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQucmFuZG9tQmV0d2Vlbj10Lm1pZGlUb0ZyZXF1ZW5jeVJhdGlvPXQuY3JlYXRlU291cmNlPXQubm90ZVRvTWlkaT10Lm1pZGlUb05vdGU9dm9pZCAwO3ZhciBzPW4oMCksYz1mdW5jdGlvbihlKXtyZXR1cm4gZSYmZS5fX2VzTW9kdWxlP2U6e2RlZmF1bHQ6ZX19KHMpO3QubWlkaVRvTm90ZT1yLHQubm90ZVRvTWlkaT1vLHQuY3JlYXRlU291cmNlPXUsdC5taWRpVG9GcmVxdWVuY3lSYXRpbz1pLHQucmFuZG9tQmV0d2Vlbj1hfSxmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gbyhlLHQpe2lmKCEoZSBpbnN0YW5jZW9mIHQpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9ZnVuY3Rpb24gcihlLHQpe2lmKCFlKXRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtyZXR1cm4hdHx8XCJvYmplY3RcIiE9dHlwZW9mIHQmJlwiZnVuY3Rpb25cIiE9dHlwZW9mIHQ/ZTp0fWZ1bmN0aW9uIGkoZSx0KXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiB0JiZudWxsIT09dCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIit0eXBlb2YgdCk7ZS5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZSh0JiZ0LnByb3RvdHlwZSx7Y29uc3RydWN0b3I6e3ZhbHVlOmUsZW51bWVyYWJsZTohMSx3cml0YWJsZTohMCxjb25maWd1cmFibGU6ITB9fSksdCYmKE9iamVjdC5zZXRQcm90b3R5cGVPZj9PYmplY3Quc2V0UHJvdG90eXBlT2YoZSx0KTplLl9fcHJvdG9fXz10KX1PYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgdT1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoZSx0KXtmb3IodmFyIG49MDtuPHQubGVuZ3RoO24rKyl7dmFyIG89dFtuXTtvLmVudW1lcmFibGU9by5lbnVtZXJhYmxlfHwhMSxvLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiBvJiYoby53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsby5rZXksbyl9fXJldHVybiBmdW5jdGlvbih0LG4sbyl7cmV0dXJuIG4mJmUodC5wcm90b3R5cGUsbiksbyYmZSh0LG8pLHR9fSgpLGE9bigwKSxzPWZ1bmN0aW9uKGUpe3JldHVybiBlJiZlLl9fZXNNb2R1bGU/ZTp7ZGVmYXVsdDplfX0oYSksYz1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KCl7dmFyIGU9YXJndW1lbnRzLmxlbmd0aD4wJiZ2b2lkIDAhPT1hcmd1bWVudHNbMF0/YXJndW1lbnRzWzBdOjA7byh0aGlzLHQpO3ZhciBuPXIodGhpcywodC5fX3Byb3RvX198fE9iamVjdC5nZXRQcm90b3R5cGVPZih0KSkuY2FsbCh0aGlzKSk7cmV0dXJuIG4uY3JlYXRlSW5zT3V0cygwLDEpLG4udm9sdW1lPWUsbn1yZXR1cm4gaSh0LGUpLHUodCxbe2tleTpcInZvbHVtZVwiLGdldDpmdW5jdGlvbigpe3JldHVybiBzLmRlZmF1bHQuZ2FpblRvRGIodGhpcy5vdXRwdXQuZ2Fpbi52YWx1ZSl9LHNldDpmdW5jdGlvbihlKXt0aGlzLm91dHB1dC5nYWluLnZhbHVlPXMuZGVmYXVsdC5kYlRvR2FpbihlKX19XSksdH0oYS5BdWRpb05vZGUpO3QuZGVmYXVsdD1jfSxmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gbyhlKXtyZXR1cm4gZSYmZS5fX2VzTW9kdWxlP2U6e2RlZmF1bHQ6ZX19ZnVuY3Rpb24gcihlLHQpe2lmKCEoZSBpbnN0YW5jZW9mIHQpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9ZnVuY3Rpb24gaShlLHQpe2lmKCFlKXRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtyZXR1cm4hdHx8XCJvYmplY3RcIiE9dHlwZW9mIHQmJlwiZnVuY3Rpb25cIiE9dHlwZW9mIHQ/ZTp0fWZ1bmN0aW9uIHUoZSx0KXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiB0JiZudWxsIT09dCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIit0eXBlb2YgdCk7ZS5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZSh0JiZ0LnByb3RvdHlwZSx7Y29uc3RydWN0b3I6e3ZhbHVlOmUsZW51bWVyYWJsZTohMSx3cml0YWJsZTohMCxjb25maWd1cmFibGU6ITB9fSksdCYmKE9iamVjdC5zZXRQcm90b3R5cGVPZj9PYmplY3Quc2V0UHJvdG90eXBlT2YoZSx0KTplLl9fcHJvdG9fXz10KX1PYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgYT1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoZSx0KXtmb3IodmFyIG49MDtuPHQubGVuZ3RoO24rKyl7dmFyIG89dFtuXTtvLmVudW1lcmFibGU9by5lbnVtZXJhYmxlfHwhMSxvLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiBvJiYoby53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsby5rZXksbyl9fXJldHVybiBmdW5jdGlvbih0LG4sbyl7cmV0dXJuIG4mJmUodC5wcm90b3R5cGUsbiksbyYmZSh0LG8pLHR9fSgpLHM9bigxKSxjPW8ocyksbD1uKDMpLGY9byhsKSxwPW4oMiksaD1uKDApLGQ9WzIxLDI0LDI3LDMwLDMzLDM2LDM5LDQyLDQ1LDQ4LDUxLDU0LDU3LDYwLDYzLDY2LDY5LDcyLDc1LDc4LDgxLDg0LDg3XSxfPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQoKXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06WzIxLDEwOF07cih0aGlzLHQpO3ZhciBuPWkodGhpcywodC5fX3Byb3RvX198fE9iamVjdC5nZXRQcm90b3R5cGVPZih0KSkuY2FsbCh0aGlzKSksbz1kLmZpbmRJbmRleChmdW5jdGlvbih0KXtyZXR1cm4gdD49ZVswXX0pLHU9ZC5maW5kSW5kZXgoZnVuY3Rpb24odCl7cmV0dXJuIHQ+PWVbMV19KTt1PS0xPT09dT91PWQubGVuZ3RoOnU7dmFyIGE9ZC5zbGljZShvLHUpO24uX3NhbXBsZXM9e307dmFyIHM9ITAsbD0hMSxmPXZvaWQgMDt0cnl7Zm9yKHZhciBwLGg9YVtTeW1ib2wuaXRlcmF0b3JdKCk7IShzPShwPWgubmV4dCgpKS5kb25lKTtzPSEwKXt2YXIgXz1wLnZhbHVlO24uX3NhbXBsZXNbX109Yy5kZWZhdWx0LmdldEhhcm1vbmljc1VybChfKX19Y2F0Y2goZSl7bD0hMCxmPWV9ZmluYWxseXt0cnl7IXMmJmgucmV0dXJuJiZoLnJldHVybigpfWZpbmFsbHl7aWYobCl0aHJvdyBmfX1yZXR1cm4gbn1yZXR1cm4gdSh0LGUpLGEodCxbe2tleTpcInN0YXJ0XCIsdmFsdWU6ZnVuY3Rpb24oZSx0LG4pe3RoaXMuX3NhbXBsZXIudHJpZ2dlckF0dGFjaygoMCxwLm1pZGlUb05vdGUpKGUpLHQsbiooMCxwLnJhbmRvbUJldHdlZW4pKC41LDEpKX19LHtrZXk6XCJsb2FkXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcztyZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24obixvKXt0Ll9zYW1wbGVyPW5ldyBoLlNhbXBsZXIodC5fc2FtcGxlcyxuLGUpLmNvbm5lY3QodC5vdXRwdXQpLHQuX3NhbXBsZXIucmVsZWFzZT0xfSl9fV0pLHR9KGYuZGVmYXVsdCk7dC5kZWZhdWx0PV99LGZ1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBvKGUpe3JldHVybiBlJiZlLl9fZXNNb2R1bGU/ZTp7ZGVmYXVsdDplfX1mdW5jdGlvbiByKGUsdCl7aWYoIShlIGluc3RhbmNlb2YgdCkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX1mdW5jdGlvbiBpKGUsdCl7aWYoIWUpdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO3JldHVybiF0fHxcIm9iamVjdFwiIT10eXBlb2YgdCYmXCJmdW5jdGlvblwiIT10eXBlb2YgdD9lOnR9ZnVuY3Rpb24gdShlLHQpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIHQmJm51bGwhPT10KXRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiK3R5cGVvZiB0KTtlLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKHQmJnQucHJvdG90eXBlLHtjb25zdHJ1Y3Rvcjp7dmFsdWU6ZSxlbnVtZXJhYmxlOiExLHdyaXRhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH19KSx0JiYoT2JqZWN0LnNldFByb3RvdHlwZU9mP09iamVjdC5zZXRQcm90b3R5cGVPZihlLHQpOmUuX19wcm90b19fPXQpfU9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuTm90ZXM9dm9pZCAwO3ZhciBhPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShlLHQpe3ZhciBuPVtdLG89ITAscj0hMSxpPXZvaWQgMDt0cnl7Zm9yKHZhciB1LGE9ZVtTeW1ib2wuaXRlcmF0b3JdKCk7IShvPSh1PWEubmV4dCgpKS5kb25lKSYmKG4ucHVzaCh1LnZhbHVlKSwhdHx8bi5sZW5ndGghPT10KTtvPSEwKTt9Y2F0Y2goZSl7cj0hMCxpPWV9ZmluYWxseXt0cnl7IW8mJmEucmV0dXJuJiZhLnJldHVybigpfWZpbmFsbHl7aWYocil0aHJvdyBpfX1yZXR1cm4gbn1yZXR1cm4gZnVuY3Rpb24odCxuKXtpZihBcnJheS5pc0FycmF5KHQpKXJldHVybiB0O2lmKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QodCkpcmV0dXJuIGUodCxuKTt0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZVwiKX19KCkscz1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoZSx0KXtmb3IodmFyIG49MDtuPHQubGVuZ3RoO24rKyl7dmFyIG89dFtuXTtvLmVudW1lcmFibGU9by5lbnVtZXJhYmxlfHwhMSxvLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiBvJiYoby53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsby5rZXksbyl9fXJldHVybiBmdW5jdGlvbih0LG4sbyl7cmV0dXJuIG4mJmUodC5wcm90b3R5cGUsbiksbyYmZSh0LG8pLHR9fSgpLGM9bigwKSxsPShvKGMpLG4oMSkpLGY9byhsKSxwPW4oMyksaD1vKHApLGQ9bigyKSxfPXsxOls4XSwyOls2LDEyXSwzOlsxLDgsMTVdLDQ6WzEsNSwxMCwxNV0sNTpbMSw0LDgsMTIsMTZdLDY6WzEsMyw3LDEwLDEzLDE2XSw3OlsxLDMsNiw5LDExLDEzLDE2XSw4OlsxLDMsNSw3LDksMTEsMTMsMTVdLDk6WzEsMyw1LDcsOSwxMSwxMywxNSwxNl0sMTA6WzEsMiwzLDUsNyw5LDExLDEzLDE1LDE2XSwxMTpbMSwyLDMsNSw3LDksMTEsMTMsMTQsMTUsMTZdLDEyOlsxLDIsMyw0LDUsNyw5LDExLDEzLDE0LDE1LDE2XSwxMzpbMSwyLDMsNCw1LDcsOSwxMSwxMiwxMywxNCwxNSwxNl0sMTQ6WzEsMiwzLDQsNSw2LDcsOSwxMSwxMiwxMywxNCwxNSwxNl0sMTU6WzEsMiwzLDQsNSw2LDcsOSwxMCwxMSwxMiwxMywxNCwxNSwxNl0sMTY6WzEsMiwzLDQsNSw2LDcsOCw5LDEwLDExLDEyLDEzLDE0LDE1LDE2XX0seT1bMjEsMjQsMjcsMzAsMzMsMzYsMzksNDIsNDUsNDgsNTEsNTQsNTcsNjAsNjMsNjYsNjksNzIsNzUsNzgsODEsODQsODcsOTAsOTMsOTYsOTksMTAyLDEwNSwxMDhdO3QuTm90ZXM9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCgpe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdP2FyZ3VtZW50c1swXTpbMjEsMTA4XSxuPWFyZ3VtZW50cy5sZW5ndGg+MSYmdm9pZCAwIT09YXJndW1lbnRzWzFdP2FyZ3VtZW50c1sxXToxO3IodGhpcyx0KTt2YXIgbz1pKHRoaXMsKHQuX19wcm90b19ffHxPYmplY3QuZ2V0UHJvdG90eXBlT2YodCkpLmNhbGwodGhpcykpLHU9eS5maW5kSW5kZXgoZnVuY3Rpb24odCl7cmV0dXJuIHQ+PWVbMF19KSxhPXkuZmluZEluZGV4KGZ1bmN0aW9uKHQpe3JldHVybiB0Pj1lWzFdfSk7YT0tMT09PWE/YT15Lmxlbmd0aDphKzE7dmFyIHM9eS5zbGljZSh1LGEpO3JldHVybiBvLl9zYW1wbGVycz1fW25dLnNsaWNlKCksby5fYWN0aXZlTm90ZXM9bmV3IE1hcCxvLl9zYW1wbGVycy5mb3JFYWNoKGZ1bmN0aW9uKGUsdCl7by5fc2FtcGxlcnNbdF09e30scy5mb3JFYWNoKGZ1bmN0aW9uKG4pe28uX3NhbXBsZXJzW3RdW25dPWYuZGVmYXVsdC5nZXROb3Rlc1VybChuLGUpfSl9KSxvfXJldHVybiB1KHQsZSkscyh0LFt7a2V5OlwiX2hhc05vdGVcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3JldHVybiB0aGlzLl9zYW1wbGVycy5oYXNPd25Qcm9wZXJ0eSh0KSYmdGhpcy5fc2FtcGxlcnNbdF0uaGFzKGUpfX0se2tleTpcIl9nZXROb3RlXCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdGhpcy5fc2FtcGxlcnNbdF0uZ2V0KGUpfX0se2tleTpcInN0b3BcIix2YWx1ZTpmdW5jdGlvbihlLHQsbil7dGhpcy5fYWN0aXZlTm90ZXMuaGFzKGUpJiYodGhpcy5fYWN0aXZlTm90ZXMuZ2V0KGUpLmZvckVhY2goZnVuY3Rpb24oZSl7ZS5zdG9wKHQrLjI1LC4yNSl9KSx0aGlzLl9hY3RpdmVOb3Rlcy5kZWxldGUoZSkpfX0se2tleTpcInN0YXJ0XCIsdmFsdWU6ZnVuY3Rpb24oZSx0LG4pe3ZhciBvPW4qKHRoaXMuX3NhbXBsZXJzLmxlbmd0aC0xKSxyPU1hdGgucm91bmQobyksaT1yLW8sdT0xLS41Kmkscz0oMCxkLm1pZGlUb0ZyZXF1ZW5jeVJhdGlvKShlKSxjPWEocywyKSxsPWNbMF0sZj1jWzFdO2lmKHRoaXMuX2hhc05vdGUobCxyKSl7dmFyIHA9KDAsZC5jcmVhdGVTb3VyY2UpKHRoaXMuX2dldE5vdGUobCxyKSk7cC5wbGF5YmFja1JhdGUudmFsdWU9ZixwLmNvbm5lY3QodGhpcy5vdXRwdXQpLHAuc3RhcnQodCwwLHZvaWQgMCx1LDApLHRoaXMuX2FjdGl2ZU5vdGVzLmhhcyhlKXx8dGhpcy5fYWN0aXZlTm90ZXMuc2V0KGUsW10pLHRoaXMuX2FjdGl2ZU5vdGVzLmdldChlKS5wdXNoKHApfX19LHtrZXk6XCJsb2FkXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcyxuPVtdO3JldHVybiB0aGlzLl9zYW1wbGVycy5mb3JFYWNoKGZ1bmN0aW9uKG8scil7dmFyIGk9bmV3IFByb21pc2UoZnVuY3Rpb24obil7dC5fc2FtcGxlcnNbcl09bmV3IGMuQnVmZmVycyhvLG4sZSl9KTtuLnB1c2goaSl9KSxQcm9taXNlLmFsbChuKX19XSksdH0oaC5kZWZhdWx0KX0sZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIG8oZSl7cmV0dXJuIGUmJmUuX19lc01vZHVsZT9lOntkZWZhdWx0OmV9fWZ1bmN0aW9uIHIoZSx0KXtpZighKGUgaW5zdGFuY2VvZiB0KSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpfWZ1bmN0aW9uIGkoZSx0KXtpZighZSl0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7cmV0dXJuIXR8fFwib2JqZWN0XCIhPXR5cGVvZiB0JiZcImZ1bmN0aW9uXCIhPXR5cGVvZiB0P2U6dH1mdW5jdGlvbiB1KGUsdCl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgdCYmbnVsbCE9PXQpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIrdHlwZW9mIHQpO2UucHJvdG90eXBlPU9iamVjdC5jcmVhdGUodCYmdC5wcm90b3R5cGUse2NvbnN0cnVjdG9yOnt2YWx1ZTplLGVudW1lcmFibGU6ITEsd3JpdGFibGU6ITAsY29uZmlndXJhYmxlOiEwfX0pLHQmJihPYmplY3Quc2V0UHJvdG90eXBlT2Y/T2JqZWN0LnNldFByb3RvdHlwZU9mKGUsdCk6ZS5fX3Byb3RvX189dCl9T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIGE9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGUsdCl7Zm9yKHZhciBuPTA7bjx0Lmxlbmd0aDtuKyspe3ZhciBvPXRbbl07by5lbnVtZXJhYmxlPW8uZW51bWVyYWJsZXx8ITEsby5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gbyYmKG8ud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLG8ua2V5LG8pfX1yZXR1cm4gZnVuY3Rpb24odCxuLG8pe3JldHVybiBuJiZlKHQucHJvdG90eXBlLG4pLG8mJmUodCxvKSx0fX0oKSxzPW4oMyksYz1vKHMpLGw9bigxKSxmPShvKGwpLG4oMikpLHA9bigwKSxoPShvKHApLGZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQoKXtyKHRoaXMsdCk7dmFyIGU9aSh0aGlzLCh0Ll9fcHJvdG9fX3x8T2JqZWN0LmdldFByb3RvdHlwZU9mKHQpKS5jYWxsKHRoaXMpKTtyZXR1cm4gZS5fZG93blRpbWU9MS8wLGUuX2N1cnJlbnRTb3VuZD1udWxsLGUuX2J1ZmZlcnM9bnVsbCxlfXJldHVybiB1KHQsZSksYSh0LFt7a2V5OlwibG9hZFwiLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciB0PXRoaXM7cmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKG4pe3QuX2J1ZmZlcnM9bmV3IHAuQnVmZmVycyh7dXA6XCJwZWRhbFUxLm1wM1wiLGRvd246XCJwZWRhbEQxLm1wM1wifSxuLGUpfSl9fSx7a2V5OlwiX3NxdWFzaFwiLHZhbHVlOmZ1bmN0aW9uKGUpe3RoaXMuX2N1cnJlbnRTb3VuZCYmdGhpcy5fY3VycmVudFNvdW5kLnN0b3AoZSwuMSksdGhpcy5fY3VycmVudFNvdW5kPW51bGx9fSx7a2V5OlwiX3BsYXlTYW1wbGVcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3RoaXMuX2N1cnJlbnRTb3VuZD0oMCxmLmNyZWF0ZVNvdXJjZSkodGhpcy5fYnVmZmVycy5nZXQodCkpLHRoaXMuX2N1cnJlbnRTb3VuZC5jb25uZWN0KHRoaXMub3V0cHV0KS5zdGFydChlLCgwLGYucmFuZG9tQmV0d2VlbikoMCwuMSksdm9pZCAwLC4yKigwLGYucmFuZG9tQmV0d2VlbikoLjUsMSksLjA1KX19LHtrZXk6XCJkb3duXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dGhpcy5fc3F1YXNoKGUpLHRoaXMuX2Rvd25UaW1lPWUsdGhpcy5fcGxheVNhbXBsZShlLFwiZG93blwiKX19LHtrZXk6XCJ1cFwiLHZhbHVlOmZ1bmN0aW9uKGUpe3RoaXMuX3NxdWFzaChlKSx0aGlzLl9kb3duVGltZT0xLzAsdGhpcy5fcGxheVNhbXBsZShlLFwidXBcIil9fSx7a2V5OlwiaXNEb3duXCIsdmFsdWU6ZnVuY3Rpb24oZSl7cmV0dXJuIGU+dGhpcy5fZG93blRpbWV9fV0pLHR9KGMuZGVmYXVsdCkpO3QuZGVmYXVsdD1ofSxmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gbyhlKXtyZXR1cm4gZSYmZS5fX2VzTW9kdWxlP2U6e2RlZmF1bHQ6ZX19ZnVuY3Rpb24gcihlLHQpe2lmKCEoZSBpbnN0YW5jZW9mIHQpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9ZnVuY3Rpb24gaShlLHQpe2lmKCFlKXRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtyZXR1cm4hdHx8XCJvYmplY3RcIiE9dHlwZW9mIHQmJlwiZnVuY3Rpb25cIiE9dHlwZW9mIHQ/ZTp0fWZ1bmN0aW9uIHUoZSx0KXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiB0JiZudWxsIT09dCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIit0eXBlb2YgdCk7ZS5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZSh0JiZ0LnByb3RvdHlwZSx7Y29uc3RydWN0b3I6e3ZhbHVlOmUsZW51bWVyYWJsZTohMSx3cml0YWJsZTohMCxjb25maWd1cmFibGU6ITB9fSksdCYmKE9iamVjdC5zZXRQcm90b3R5cGVPZj9PYmplY3Quc2V0UHJvdG90eXBlT2YoZSx0KTplLl9fcHJvdG9fXz10KX1PYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgYT1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoZSx0KXtmb3IodmFyIG49MDtuPHQubGVuZ3RoO24rKyl7dmFyIG89dFtuXTtvLmVudW1lcmFibGU9by5lbnVtZXJhYmxlfHwhMSxvLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiBvJiYoby53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsby5rZXksbyl9fXJldHVybiBmdW5jdGlvbih0LG4sbyl7cmV0dXJuIG4mJmUodC5wcm90b3R5cGUsbiksbyYmZSh0LG8pLHR9fSgpLHM9bigxKSxjPW8ocyksbD1uKDMpLGY9byhsKSxwPW4oMiksaD1uKDApLGQ9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdChlKXtyKHRoaXMsdCk7dmFyIG49aSh0aGlzLCh0Ll9fcHJvdG9fX3x8T2JqZWN0LmdldFByb3RvdHlwZU9mKHQpKS5jYWxsKHRoaXMpKTtuLl9idWZmZXJzPXt9O2Zvcih2YXIgbz1lWzBdO288PWVbMV07bysrKW4uX2J1ZmZlcnNbb109Yy5kZWZhdWx0LmdldFJlbGVhc2VzVXJsKG8pO3JldHVybiBufXJldHVybiB1KHQsZSksYSh0LFt7a2V5OlwibG9hZFwiLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciB0PXRoaXM7cmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKG4pe3QuX2J1ZmZlcnM9bmV3IGguQnVmZmVycyh0Ll9idWZmZXJzLG4sZSl9KX19LHtrZXk6XCJzdGFydFwiLHZhbHVlOmZ1bmN0aW9uKGUsdCxuKXtpZih0aGlzLl9idWZmZXJzLmhhcyhlKSl7dmFyIG89KDAscC5jcmVhdGVTb3VyY2UpKHRoaXMuX2J1ZmZlcnMuZ2V0KGUpKS5jb25uZWN0KHRoaXMub3V0cHV0KTtuKj0oMCxwLnJhbmRvbUJldHdlZW4pKC41LDEpLG8uc3RhcnQodCwwLHZvaWQgMCwuMDEqbiwwKX19fV0pLHR9KGYuZGVmYXVsdCk7dC5kZWZhdWx0PWR9LGZ1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBvKGUpe3JldHVybiBlJiZlLl9fZXNNb2R1bGU/ZTp7ZGVmYXVsdDplfX1mdW5jdGlvbiByKGUsdCl7aWYoIShlIGluc3RhbmNlb2YgdCkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX1mdW5jdGlvbiBpKGUsdCl7aWYoIWUpdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO3JldHVybiF0fHxcIm9iamVjdFwiIT10eXBlb2YgdCYmXCJmdW5jdGlvblwiIT10eXBlb2YgdD9lOnR9ZnVuY3Rpb24gdShlLHQpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIHQmJm51bGwhPT10KXRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiK3R5cGVvZiB0KTtlLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKHQmJnQucHJvdG90eXBlLHtjb25zdHJ1Y3Rvcjp7dmFsdWU6ZSxlbnVtZXJhYmxlOiExLHdyaXRhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH19KSx0JiYoT2JqZWN0LnNldFByb3RvdHlwZU9mP09iamVjdC5zZXRQcm90b3R5cGVPZihlLHQpOmUuX19wcm90b19fPXQpfU9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuUGlhbm89dm9pZCAwO3ZhciBhPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShlLHQpe2Zvcih2YXIgbj0wO248dC5sZW5ndGg7bisrKXt2YXIgbz10W25dO28uZW51bWVyYWJsZT1vLmVudW1lcmFibGV8fCExLG8uY29uZmlndXJhYmxlPSEwLFwidmFsdWVcImluIG8mJihvLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxvLmtleSxvKX19cmV0dXJuIGZ1bmN0aW9uKHQsbixvKXtyZXR1cm4gbiYmZSh0LnByb3RvdHlwZSxuKSxvJiZlKHQsbyksdH19KCkscz1uKDApLGM9byhzKSxsPW4oNiksZj1vKGwpLHA9big1KSxoPW4oNCksZD1vKGgpLF89big3KSx5PW8oXyksdj1uKDEpO28odiksdC5QaWFubz1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KCl7cih0aGlzLHQpO3ZhciBlPWMuZGVmYXVsdC5kZWZhdWx0cyhhcmd1bWVudHMsW1wicmFuZ2VcIixcInZlbG9jaXRpZXNcIl0se3ZlbG9jaXRpZXM6MSxyYW5nZTpbMjEsMTA4XSxyZWxlYXNlOiEwfSksbj1pKHRoaXMsKHQuX19wcm90b19ffHxPYmplY3QuZ2V0UHJvdG90eXBlT2YodCkpLmNhbGwodGhpcykpO3JldHVybiBuLmNyZWF0ZUluc091dHMoMCwxKSxuLl9sb2FkZWQ9ITEsbi5faGVsZE5vdGVzPW5ldyBNYXAsbi5fc3VzdGFpbmVkTm90ZXM9bmV3IE1hcCxuLl9ub3Rlcz1uZXcgcC5Ob3RlcyhlLnJhbmdlLGUudmVsb2NpdGllcykuY29ubmVjdChuLm91dHB1dCksbi5fcGVkYWw9KG5ldyBmLmRlZmF1bHQpLmNvbm5lY3Qobi5vdXRwdXQpLGUucmVsZWFzZSYmKG4uX2hhcm1vbmljcz1uZXcgZC5kZWZhdWx0KGUucmFuZ2UpLmNvbm5lY3Qobi5vdXRwdXQpLG4uX3JlbGVhc2U9bmV3IHkuZGVmYXVsdChlLnJhbmdlKS5jb25uZWN0KG4ub3V0cHV0KSksbn1yZXR1cm4gdSh0LGUpLGEodCxbe2tleTpcImxvYWRcIix2YWx1ZTpmdW5jdGlvbihlKXt2YXIgdD10aGlzLG49W3RoaXMuX25vdGVzLmxvYWQoZSksdGhpcy5fcGVkYWwubG9hZChlKV07cmV0dXJuIHRoaXMuX2hhcm1vbmljcyYmbi5wdXNoKHRoaXMuX2hhcm1vbmljcy5sb2FkKGUpKSx0aGlzLl9yZWxlYXNlJiZuLnB1c2godGhpcy5fcmVsZWFzZS5sb2FkKGUpKSxQcm9taXNlLmFsbChuKS50aGVuKGZ1bmN0aW9uKCl7dC5fbG9hZGVkPSEwfSl9fSx7a2V5OlwicGVkYWxEb3duXCIsdmFsdWU6ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMubG9hZGVkJiYoZT10aGlzLnRvU2Vjb25kcyhlKSx0aGlzLl9wZWRhbC5pc0Rvd24oZSl8fHRoaXMuX3BlZGFsLmRvd24oZSkpLHRoaXN9fSx7a2V5OlwicGVkYWxVcFwiLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciB0PXRoaXM7cmV0dXJuIHRoaXMubG9hZGVkJiYoZT10aGlzLnRvU2Vjb25kcyhlKSx0aGlzLl9wZWRhbC5pc0Rvd24oZSkmJih0aGlzLl9wZWRhbC51cChlKSx0aGlzLl9zdXN0YWluZWROb3Rlcy5mb3JFYWNoKGZ1bmN0aW9uKG4sbyl7dC5faGVsZE5vdGVzLmhhcyhvKXx8dC5fbm90ZXMuc3RvcChvLGUpfSksdGhpcy5fc3VzdGFpbmVkTm90ZXMuY2xlYXIoKSkpLHRoaXN9fSx7a2V5Olwia2V5RG93blwiLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciB0PWFyZ3VtZW50cy5sZW5ndGg+MSYmdm9pZCAwIT09YXJndW1lbnRzWzFdP2FyZ3VtZW50c1sxXTpjLmRlZmF1bHQubm93KCksbj1hcmd1bWVudHMubGVuZ3RoPjImJnZvaWQgMCE9PWFyZ3VtZW50c1syXT9hcmd1bWVudHNbMl06Ljg7cmV0dXJuIHRoaXMubG9hZGVkJiYodD10aGlzLnRvU2Vjb25kcyh0KSxjLmRlZmF1bHQuaXNTdHJpbmcoZSkmJihlPU1hdGgucm91bmQoKDAscy5GcmVxdWVuY3kpKGUpLnRvTWlkaSgpKSksdGhpcy5faGVsZE5vdGVzLmhhcyhlKXx8KHRoaXMuX2hlbGROb3Rlcy5zZXQoZSx7dGltZTp0LHZlbG9jaXR5Om59KSx0aGlzLl9ub3Rlcy5zdGFydChlLHQsbikpKSx0aGlzfX0se2tleTpcImtleVVwXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9YXJndW1lbnRzLmxlbmd0aD4xJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0/YXJndW1lbnRzWzFdOmMuZGVmYXVsdC5ub3coKSxuPWFyZ3VtZW50cy5sZW5ndGg+MiYmdm9pZCAwIT09YXJndW1lbnRzWzJdP2FyZ3VtZW50c1syXTouODtpZih0aGlzLmxvYWRlZCYmKHQ9dGhpcy50b1NlY29uZHModCksYy5kZWZhdWx0LmlzU3RyaW5nKGUpJiYoZT1NYXRoLnJvdW5kKCgwLHMuRnJlcXVlbmN5KShlKS50b01pZGkoKSkpLHRoaXMuX2hlbGROb3Rlcy5oYXMoZSkpKXt2YXIgbz10aGlzLl9oZWxkTm90ZXMuZ2V0KGUpO3RoaXMuX2hlbGROb3Rlcy5kZWxldGUoZSksdGhpcy5fcmVsZWFzZSYmdGhpcy5fcmVsZWFzZS5zdGFydChlLHQsbik7dmFyIHI9dC1vLnRpbWUsaT1vLnZlbG9jaXR5LHU9LjUvTWF0aC5tYXgociwuMSkraStuO3U9TWF0aC5wb3coTWF0aC5sb2coTWF0aC5tYXgodSwxKSksMikvMix0aGlzLl9wZWRhbC5pc0Rvd24odCk/dGhpcy5fc3VzdGFpbmVkTm90ZXMuaGFzKGUpfHx0aGlzLl9zdXN0YWluZWROb3Rlcy5zZXQoZSx0KToodGhpcy5fbm90ZXMuc3RvcChlLHQsbiksdGhpcy5faGFybW9uaWNzJiZ0aGlzLl9oYXJtb25pY3Muc3RhcnQoZSx0LHUpKX1yZXR1cm4gdGhpc319LHtrZXk6XCJzZXRWb2x1bWVcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3N3aXRjaChlKXtjYXNlXCJub3RlXCI6dGhpcy5fbm90ZXMudm9sdW1lPXQ7YnJlYWs7Y2FzZVwicGVkYWxcIjp0aGlzLl9wZWRhbC52b2x1bWU9dDticmVhaztjYXNlXCJyZWxlYXNlXCI6dGhpcy5fcmVsZWFzZSYmKHRoaXMuX3JlbGVhc2Uudm9sdW1lPXQpO2JyZWFrO2Nhc2VcImhhcm1vbmljc1wiOnRoaXMuX2hhcm1vbmljcyYmKHRoaXMuX2hhcm1vbmljcy52b2x1bWU9dCl9cmV0dXJuIHRoaXN9fSx7a2V5OlwibG9hZGVkXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2xvYWRlZH19XSksdH0ocy5BdWRpb05vZGUpfV0pfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1QaWFuby5qcy5tYXAiLCIoZnVuY3Rpb24ocm9vdCwgZmFjdG9yeSl7XG5cblx0Ly9VTURcblx0aWYgKCB0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCApIHtcblx0XHRkZWZpbmUoZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gZmFjdG9yeSgpO1xuXHRcdH0pO1xuXHR9IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIpIHtcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcbiBcdH0gZWxzZSB7XG5cdFx0cm9vdC5Ub25lID0gZmFjdG9yeSgpO1xuXHR9XG5cbn0odGhpcywgZnVuY3Rpb24oKXtcblxuXHRcInVzZSBzdHJpY3RcIjtcblx0XG5cdHZhciBUb25lO1xuXHQvL2NvbnN0cnVjdHMgdGhlIG1haW4gVG9uZSBvYmplY3Rcblx0ZnVuY3Rpb24gTWFpbihmdW5jKXtcblx0XHRUb25lID0gZnVuYygpO1xuXHR9XG5cdC8vaW52b2tlcyBlYWNoIG9mIHRoZSBtb2R1bGVzIHdpdGggdGhlIG1haW4gVG9uZSBvYmplY3QgYXMgdGhlIGFyZ3VtZW50XG5cdGZ1bmN0aW9uIE1vZHVsZShmdW5jKXtcblx0XHRmdW5jKFRvbmUpO1xuXHR9XHQvKipcblx0ICogIFRvbmUuanNcblx0ICogIEBhdXRob3IgWW90YW0gTWFublxuXHQgKiAgQGxpY2Vuc2UgaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVCBNSVQgTGljZW5zZVxuXHQgKiAgQGNvcHlyaWdodCAyMDE0LTIwMTcgWW90YW0gTWFublxuXHQgKi9cblx0TWFpbihmdW5jdGlvbiAoKSB7XG5cdCAgICBcblx0ICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQgICAgLy9cdFRPTkVcblx0ICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyAgVG9uZSBpcyB0aGUgYmFzZSBjbGFzcyBvZiBhbGwgb3RoZXIgY2xhc3Nlcy5cblx0XHQgKiAgQGNvbnN0cnVjdG9yXG5cdFx0ICovXG5cdCAgICB2YXIgVG9uZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgQG1lbWJlck9mIFRvbmUjXG5cdFx0ICogIEByZXR1cm5zIHtzdHJpbmd9IHJldHVybnMgdGhlIG5hbWUgb2YgdGhlIGNsYXNzIGFzIGEgc3RyaW5nXG5cdFx0ICovXG5cdCAgICBUb25lLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBmb3IgKHZhciBjbGFzc05hbWUgaW4gVG9uZSkge1xuXHQgICAgICAgICAgICB2YXIgaXNMZXR0ZXIgPSBjbGFzc05hbWVbMF0ubWF0Y2goL15bQS1aXSQvKTtcblx0ICAgICAgICAgICAgdmFyIHNhbWVDb25zdHJ1Y3RvciA9IFRvbmVbY2xhc3NOYW1lXSA9PT0gdGhpcy5jb25zdHJ1Y3Rvcjtcblx0ICAgICAgICAgICAgaWYgKFRvbmUuaXNGdW5jdGlvbihUb25lW2NsYXNzTmFtZV0pICYmIGlzTGV0dGVyICYmIHNhbWVDb25zdHJ1Y3Rvcikge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGNsYXNzTmFtZTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gJ1RvbmUnO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBAbWVtYmVyT2YgVG9uZSNcblx0XHQgKiAgZGlzY29ubmVjdCBhbmQgZGlzcG9zZVxuXHRcdCAqICBAcmV0dXJucyB7VG9uZX0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblx0ICAgIC8vXHRHRVQvU0VUXG5cdCAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblx0ICAgIC8qKlxuXHRcdCAqICBTZXQgdGhlIHBhcmFtZXRlcnMgYXQgb25jZS4gRWl0aGVyIHBhc3MgaW4gYW5cblx0XHQgKiAgb2JqZWN0IG1hcHBpbmcgcGFyYW1ldGVycyB0byB2YWx1ZXMsIG9yIHRvIHNldCBhXG5cdFx0ICogIHNpbmdsZSBwYXJhbWV0ZXIsIGJ5IHBhc3NpbmcgaW4gYSBzdHJpbmcgYW5kIHZhbHVlLlxuXHRcdCAqICBUaGUgbGFzdCBhcmd1bWVudCBpcyBhbiBvcHRpb25hbCByYW1wIHRpbWUgd2hpY2hcblx0XHQgKiAgd2lsbCByYW1wIGFueSBzaWduYWwgdmFsdWVzIHRvIHRoZWlyIGRlc3RpbmF0aW9uIHZhbHVlXG5cdFx0ICogIG92ZXIgdGhlIGR1cmF0aW9uIG9mIHRoZSByYW1wVGltZS5cblx0XHQgKiAgQHBhcmFtIHtPYmplY3R8c3RyaW5nfSBwYXJhbXNcblx0XHQgKiAgQHBhcmFtIHtudW1iZXI9fSB2YWx1ZVxuXHRcdCAqICBAcGFyYW0ge1RpbWU9fSByYW1wVGltZVxuXHRcdCAqICBAcmV0dXJucyB7VG9uZX0gdGhpc1xuXHRcdCAqICBAbWVtYmVyT2YgVG9uZSNcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAvL3NldCB2YWx1ZXMgdXNpbmcgYW4gb2JqZWN0XG5cdFx0ICogZmlsdGVyLnNldCh7XG5cdFx0ICogXHRcImZyZXF1ZW5jeVwiIDogMzAwLFxuXHRcdCAqIFx0XCJ0eXBlXCIgOiBoaWdocGFzc1xuXHRcdCAqIH0pO1xuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIGZpbHRlci5zZXQoXCJ0eXBlXCIsIFwiaGlnaHBhc3NcIik7XG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogLy9yYW1wIHRvIHRoZSB2YWx1ZSAyMjAgb3ZlciAzIHNlY29uZHMuXG5cdFx0ICogb3NjaWxsYXRvci5zZXQoe1xuXHRcdCAqIFx0XCJmcmVxdWVuY3lcIiA6IDIyMFxuXHRcdCAqIH0sIDMpO1xuXHRcdCAqL1xuXHQgICAgVG9uZS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKHBhcmFtcywgdmFsdWUsIHJhbXBUaW1lKSB7XG5cdCAgICAgICAgaWYgKFRvbmUuaXNPYmplY3QocGFyYW1zKSkge1xuXHQgICAgICAgICAgICByYW1wVGltZSA9IHZhbHVlO1xuXHQgICAgICAgIH0gZWxzZSBpZiAoVG9uZS5pc1N0cmluZyhwYXJhbXMpKSB7XG5cdCAgICAgICAgICAgIHZhciB0bXBPYmogPSB7fTtcblx0ICAgICAgICAgICAgdG1wT2JqW3BhcmFtc10gPSB2YWx1ZTtcblx0ICAgICAgICAgICAgcGFyYW1zID0gdG1wT2JqO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBwYXJhbUxvb3A6XG5cdCAgICAgICAgICAgIGZvciAodmFyIGF0dHIgaW4gcGFyYW1zKSB7XG5cdCAgICAgICAgICAgICAgICB2YWx1ZSA9IHBhcmFtc1thdHRyXTtcblx0ICAgICAgICAgICAgICAgIHZhciBwYXJlbnQgPSB0aGlzO1xuXHQgICAgICAgICAgICAgICAgaWYgKGF0dHIuaW5kZXhPZignLicpICE9PSAtMSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBhdHRyU3BsaXQgPSBhdHRyLnNwbGl0KCcuJyk7XG5cdCAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhdHRyU3BsaXQubGVuZ3RoIC0gMTsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudFthdHRyU3BsaXRbaV1dO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyZW50IGluc3RhbmNlb2YgVG9uZSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0clNwbGl0LnNwbGljZSgwLCBpICsgMSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5uZXJQYXJhbSA9IGF0dHJTcGxpdC5qb2luKCcuJyk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnQuc2V0KGlubmVyUGFyYW0sIHZhbHVlKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlIHBhcmFtTG9vcDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICBhdHRyID0gYXR0clNwbGl0W2F0dHJTcGxpdC5sZW5ndGggLSAxXTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIHZhciBwYXJhbSA9IHBhcmVudFthdHRyXTtcblx0ICAgICAgICAgICAgICAgIGlmIChUb25lLmlzVW5kZWYocGFyYW0pKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBpZiAoVG9uZS5TaWduYWwgJiYgcGFyYW0gaW5zdGFuY2VvZiBUb25lLlNpZ25hbCB8fCBUb25lLlBhcmFtICYmIHBhcmFtIGluc3RhbmNlb2YgVG9uZS5QYXJhbSkge1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbS52YWx1ZSAhPT0gdmFsdWUpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFRvbmUuaXNVbmRlZihyYW1wVGltZSkpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtLnZhbHVlID0gdmFsdWU7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbS5yYW1wVG8odmFsdWUsIHJhbXBUaW1lKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocGFyYW0gaW5zdGFuY2VvZiBBdWRpb1BhcmFtKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmFtLnZhbHVlICE9PSB2YWx1ZSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbS52YWx1ZSA9IHZhbHVlO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocGFyYW0gaW5zdGFuY2VvZiBUb25lKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcGFyYW0uc2V0KHZhbHVlKTtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocGFyYW0gIT09IHZhbHVlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcGFyZW50W2F0dHJdID0gdmFsdWU7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgR2V0IHRoZSBvYmplY3QncyBhdHRyaWJ1dGVzLiBHaXZlbiBubyBhcmd1bWVudHMgZ2V0XG5cdFx0ICogIHdpbGwgcmV0dXJuIGFsbCBhdmFpbGFibGUgb2JqZWN0IHByb3BlcnRpZXMgYW5kIHRoZWlyIGNvcnJlc3BvbmRpbmdcblx0XHQgKiAgdmFsdWVzLiBQYXNzIGluIGEgc2luZ2xlIGF0dHJpYnV0ZSB0byByZXRyaWV2ZSBvciBhbiBhcnJheVxuXHRcdCAqICBvZiBhdHRyaWJ1dGVzLiBUaGUgYXR0cmlidXRlIHN0cmluZ3MgY2FuIGFsc28gaW5jbHVkZSBhIFwiLlwiXG5cdFx0ICogIHRvIGFjY2VzcyBkZWVwZXIgcHJvcGVydGllcy5cblx0XHQgKiAgQG1lbWJlck9mIFRvbmUjXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogb3NjLmdldCgpO1xuXHRcdCAqIC8vcmV0dXJucyB7XCJ0eXBlXCIgOiBcInNpbmVcIiwgXCJmcmVxdWVuY3lcIiA6IDQ0MCwgLi4uZXRjfVxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIG9zYy5nZXQoXCJ0eXBlXCIpO1xuXHRcdCAqIC8vcmV0dXJucyB7IFwidHlwZVwiIDogXCJzaW5lXCJ9XG5cdFx0ICogQGV4YW1wbGVcblx0XHQgKiAvL3VzZSBkb3Qgbm90YXRpb24gdG8gYWNjZXNzIGRlZXAgcHJvcGVydGllc1xuXHRcdCAqIHN5bnRoLmdldChbXCJlbnZlbG9wZS5hdHRhY2tcIiwgXCJlbnZlbG9wZS5yZWxlYXNlXCJdKTtcblx0XHQgKiAvL3JldHVybnMge1wiZW52ZWxvcGVcIiA6IHtcImF0dGFja1wiIDogMC4yLCBcInJlbGVhc2VcIiA6IDAuNH19XG5cdFx0ICogIEBwYXJhbSB7QXJyYXk9fHN0cmluZ3x1bmRlZmluZWR9IHBhcmFtcyB0aGUgcGFyYW1ldGVycyB0byBnZXQsIG90aGVyd2lzZSB3aWxsIHJldHVyblxuXHRcdCAqICBcdFx0XHRcdFx0ICAgICAgICAgICAgICAgICAgYWxsIGF2YWlsYWJsZS5cblx0XHQgKiAgQHJldHVybnMge09iamVjdH1cblx0XHQgKi9cblx0ICAgIFRvbmUucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcblx0ICAgICAgICBpZiAoVG9uZS5pc1VuZGVmKHBhcmFtcykpIHtcblx0ICAgICAgICAgICAgcGFyYW1zID0gdGhpcy5fY29sbGVjdERlZmF1bHRzKHRoaXMuY29uc3RydWN0b3IpO1xuXHQgICAgICAgIH0gZWxzZSBpZiAoVG9uZS5pc1N0cmluZyhwYXJhbXMpKSB7XG5cdCAgICAgICAgICAgIHBhcmFtcyA9IFtwYXJhbXNdO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgcmV0ID0ge307XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJhbXMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgdmFyIGF0dHIgPSBwYXJhbXNbaV07XG5cdCAgICAgICAgICAgIHZhciBwYXJlbnQgPSB0aGlzO1xuXHQgICAgICAgICAgICB2YXIgc3ViUmV0ID0gcmV0O1xuXHQgICAgICAgICAgICBpZiAoYXR0ci5pbmRleE9mKCcuJykgIT09IC0xKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgYXR0clNwbGl0ID0gYXR0ci5zcGxpdCgnLicpO1xuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBhdHRyU3BsaXQubGVuZ3RoIC0gMTsgaisrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHN1YkF0dHIgPSBhdHRyU3BsaXRbal07XG5cdCAgICAgICAgICAgICAgICAgICAgc3ViUmV0W3N1YkF0dHJdID0gc3ViUmV0W3N1YkF0dHJdIHx8IHt9O1xuXHQgICAgICAgICAgICAgICAgICAgIHN1YlJldCA9IHN1YlJldFtzdWJBdHRyXTtcblx0ICAgICAgICAgICAgICAgICAgICBwYXJlbnQgPSBwYXJlbnRbc3ViQXR0cl07XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBhdHRyID0gYXR0clNwbGl0W2F0dHJTcGxpdC5sZW5ndGggLSAxXTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB2YXIgcGFyYW0gPSBwYXJlbnRbYXR0cl07XG5cdCAgICAgICAgICAgIGlmIChUb25lLmlzT2JqZWN0KHBhcmFtc1thdHRyXSkpIHtcblx0ICAgICAgICAgICAgICAgIHN1YlJldFthdHRyXSA9IHBhcmFtLmdldCgpO1xuXHQgICAgICAgICAgICB9IGVsc2UgaWYgKFRvbmUuU2lnbmFsICYmIHBhcmFtIGluc3RhbmNlb2YgVG9uZS5TaWduYWwpIHtcblx0ICAgICAgICAgICAgICAgIHN1YlJldFthdHRyXSA9IHBhcmFtLnZhbHVlO1xuXHQgICAgICAgICAgICB9IGVsc2UgaWYgKFRvbmUuUGFyYW0gJiYgcGFyYW0gaW5zdGFuY2VvZiBUb25lLlBhcmFtKSB7XG5cdCAgICAgICAgICAgICAgICBzdWJSZXRbYXR0cl0gPSBwYXJhbS52YWx1ZTtcblx0ICAgICAgICAgICAgfSBlbHNlIGlmIChwYXJhbSBpbnN0YW5jZW9mIEF1ZGlvUGFyYW0pIHtcblx0ICAgICAgICAgICAgICAgIHN1YlJldFthdHRyXSA9IHBhcmFtLnZhbHVlO1xuXHQgICAgICAgICAgICB9IGVsc2UgaWYgKHBhcmFtIGluc3RhbmNlb2YgVG9uZSkge1xuXHQgICAgICAgICAgICAgICAgc3ViUmV0W2F0dHJdID0gcGFyYW0uZ2V0KCk7XG5cdCAgICAgICAgICAgIH0gZWxzZSBpZiAoIVRvbmUuaXNGdW5jdGlvbihwYXJhbSkgJiYgIVRvbmUuaXNVbmRlZihwYXJhbSkpIHtcblx0ICAgICAgICAgICAgICAgIHN1YlJldFthdHRyXSA9IHBhcmFtO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiByZXQ7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIGNvbGxlY3QgYWxsIG9mIHRoZSBkZWZhdWx0IGF0dHJpYnV0ZXMgaW4gb25lXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICogIEBwYXJhbSB7ZnVuY3Rpb259IGNvbnN0ciB0aGUgY29uc3RydWN0b3IgdG8gZmluZCB0aGUgZGVmYXVsdHMgZnJvbVxuXHRcdCAqICBAcmV0dXJuIHtBcnJheX0gYWxsIG9mIHRoZSBhdHRyaWJ1dGVzIHdoaWNoIGJlbG9uZyB0byB0aGUgY2xhc3Ncblx0XHQgKi9cblx0ICAgIFRvbmUucHJvdG90eXBlLl9jb2xsZWN0RGVmYXVsdHMgPSBmdW5jdGlvbiAoY29uc3RyKSB7XG5cdCAgICAgICAgdmFyIHJldCA9IFtdO1xuXHQgICAgICAgIGlmICghVG9uZS5pc1VuZGVmKGNvbnN0ci5kZWZhdWx0cykpIHtcblx0ICAgICAgICAgICAgcmV0ID0gT2JqZWN0LmtleXMoY29uc3RyLmRlZmF1bHRzKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKCFUb25lLmlzVW5kZWYoY29uc3RyLl9zdXBlcikpIHtcblx0ICAgICAgICAgICAgdmFyIHN1cGVyRGVmcyA9IHRoaXMuX2NvbGxlY3REZWZhdWx0cyhjb25zdHIuX3N1cGVyKTtcblx0ICAgICAgICAgICAgLy9maWx0ZXIgb3V0IHJlcGVhdHNcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdXBlckRlZnMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIGlmIChyZXQuaW5kZXhPZihzdXBlckRlZnNbaV0pID09PSAtMSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldC5wdXNoKHN1cGVyRGVmc1tpXSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHJldDtcblx0ICAgIH07XG5cdCAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblx0ICAgIC8vXHRERUZBVUxUU1xuXHQgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdCAgICAvKipcblx0XHQgKiAgQG1lbWJlck9mIFRvbmVcblx0XHQgKiAgQHBhcmFtICB7QXJyYXl9ICB2YWx1ZXMgIFRoZSBhcmd1bWVudHMgYXJyYXlcblx0XHQgKiAgQHBhcmFtICB7QXJyYXl9ICBrZXlzICAgIFRoZSBuYW1lcyBvZiB0aGUgYXJndW1lbnRzXG5cdFx0ICogIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fSBjb25zdHIgVGhlIGNsYXNzIGNvbnN0cnVjdG9yXG5cdFx0ICogIEByZXR1cm4gIHtPYmplY3R9ICBBbiBvYmplY3QgY29tcG9zZWQgb2YgdGhlICBkZWZhdWx0cyBiZXR3ZWVuIHRoZSBjbGFzcycgZGVmYXVsdHNcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgIGFuZCB0aGUgcGFzc2VkIGluIGFyZ3VtZW50cy5cblx0XHQgKi9cblx0ICAgIFRvbmUuZGVmYXVsdHMgPSBmdW5jdGlvbiAodmFsdWVzLCBrZXlzLCBjb25zdHIpIHtcblx0ICAgICAgICB2YXIgb3B0aW9ucyA9IHt9O1xuXHQgICAgICAgIGlmICh2YWx1ZXMubGVuZ3RoID09PSAxICYmIFRvbmUuaXNPYmplY3QodmFsdWVzWzBdKSkge1xuXHQgICAgICAgICAgICBvcHRpb25zID0gdmFsdWVzWzBdO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgb3B0aW9uc1trZXlzW2ldXSA9IHZhbHVlc1tpXTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAoIVRvbmUuaXNVbmRlZihjb25zdHIuZGVmYXVsdHMpKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBUb25lLmRlZmF1bHRBcmcob3B0aW9ucywgY29uc3RyLmRlZmF1bHRzKTtcblx0ICAgICAgICB9IGVsc2UgaWYgKFRvbmUuaXNPYmplY3QoY29uc3RyKSkge1xuXHQgICAgICAgICAgICByZXR1cm4gVG9uZS5kZWZhdWx0QXJnKG9wdGlvbnMsIGNvbnN0cik7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnM7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBJZiB0aGUgYGdpdmVuYCBwYXJhbWV0ZXIgaXMgdW5kZWZpbmVkLCB1c2UgdGhlIGBmYWxsYmFja2AuXG5cdFx0ICogIElmIGJvdGggYGdpdmVuYCBhbmQgYGZhbGxiYWNrYCBhcmUgb2JqZWN0IGxpdGVyYWxzLCBpdCB3aWxsXG5cdFx0ICogIHJldHVybiBhIGRlZXAgY29weSB3aGljaCBpbmNsdWRlcyBhbGwgb2YgdGhlIHBhcmFtZXRlcnMgZnJvbSBib3RoXG5cdFx0ICogIG9iamVjdHMuIElmIGEgcGFyYW1ldGVyIGlzIHVuZGVmaW5lZCBpbiBnaXZlbiwgaXQgd2lsbCByZXR1cm5cblx0XHQgKiAgdGhlIGZhbGxiYWNrIHByb3BlcnR5LlxuXHRcdCAqICA8YnI+PGJyPlxuXHRcdCAqICBXQVJOSU5HOiBpZiBvYmplY3QgaXMgc2VsZiByZWZlcmVudGlhbCwgaXQgd2lsbCBnbyBpbnRvIGFuIGFuXG5cdFx0ICogIGluZmluaXRlIHJlY3Vyc2l2ZSBsb29wLlxuXHRcdCAqICBAbWVtYmVyT2YgVG9uZVxuXHRcdCAqICBAcGFyYW0gIHsqfSBnaXZlblxuXHRcdCAqICBAcGFyYW0gIHsqfSBmYWxsYmFja1xuXHRcdCAqICBAcmV0dXJuIHsqfVxuXHRcdCAqL1xuXHQgICAgVG9uZS5kZWZhdWx0QXJnID0gZnVuY3Rpb24gKGdpdmVuLCBmYWxsYmFjaykge1xuXHQgICAgICAgIGlmIChUb25lLmlzT2JqZWN0KGdpdmVuKSAmJiBUb25lLmlzT2JqZWN0KGZhbGxiYWNrKSkge1xuXHQgICAgICAgICAgICB2YXIgcmV0ID0ge307XG5cdCAgICAgICAgICAgIC8vbWFrZSBhIGRlZXAgY29weSBvZiB0aGUgZ2l2ZW4gb2JqZWN0XG5cdCAgICAgICAgICAgIGZvciAodmFyIGdpdmVuUHJvcCBpbiBnaXZlbikge1xuXHQgICAgICAgICAgICAgICAgcmV0W2dpdmVuUHJvcF0gPSBUb25lLmRlZmF1bHRBcmcoZmFsbGJhY2tbZ2l2ZW5Qcm9wXSwgZ2l2ZW5bZ2l2ZW5Qcm9wXSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZm9yICh2YXIgZmFsbGJhY2tQcm9wIGluIGZhbGxiYWNrKSB7XG5cdCAgICAgICAgICAgICAgICByZXRbZmFsbGJhY2tQcm9wXSA9IFRvbmUuZGVmYXVsdEFyZyhnaXZlbltmYWxsYmFja1Byb3BdLCBmYWxsYmFja1tmYWxsYmFja1Byb3BdKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gcmV0O1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIHJldHVybiBUb25lLmlzVW5kZWYoZ2l2ZW4pID8gZmFsbGJhY2sgOiBnaXZlbjtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdCAgICAvL1x0Q09OTkVDVElPTlNcblx0ICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQgICAgLyoqXG5cdFx0ICogIGNvbm5lY3QgdG9nZXRoZXIgYWxsIG9mIHRoZSBhcmd1bWVudHMgaW4gc2VyaWVzXG5cdFx0ICogIEBwYXJhbSB7Li4uQXVkaW9QYXJhbXxUb25lfEF1ZGlvTm9kZX0gbm9kZXNcblx0XHQgKiAgQHJldHVybnMge1RvbmV9XG5cdFx0ICogIEBtZW1iZXJPZiBUb25lXG5cdFx0ICogIEBzdGF0aWNcblx0XHQgKi9cblx0ICAgIFRvbmUuY29ubmVjdFNlcmllcyA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgY3VycmVudFVuaXQgPSBhcmd1bWVudHNbMF07XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgdmFyIHRvVW5pdCA9IGFyZ3VtZW50c1tpXTtcblx0ICAgICAgICAgICAgY3VycmVudFVuaXQuY29ubmVjdCh0b1VuaXQpO1xuXHQgICAgICAgICAgICBjdXJyZW50VW5pdCA9IHRvVW5pdDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIFRvbmU7XG5cdCAgICB9O1xuXHQgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdCAgICAvLyBUWVBFIENIRUNLSU5HXG5cdCAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblx0ICAgIC8qKlxuXHRcdCAqICB0ZXN0IGlmIHRoZSBhcmcgaXMgdW5kZWZpbmVkXG5cdFx0ICogIEBwYXJhbSB7Kn0gYXJnIHRoZSBhcmd1bWVudCB0byB0ZXN0XG5cdFx0ICogIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIHRoZSBhcmcgaXMgdW5kZWZpbmVkXG5cdFx0ICogIEBzdGF0aWNcblx0XHQgKiAgQG1lbWJlck9mIFRvbmVcblx0XHQgKi9cblx0ICAgIFRvbmUuaXNVbmRlZiA9IGZ1bmN0aW9uICh2YWwpIHtcblx0ICAgICAgICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ3VuZGVmaW5lZCc7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIHRlc3QgaWYgdGhlIGFyZyBpcyBhIGZ1bmN0aW9uXG5cdFx0ICogIEBwYXJhbSB7Kn0gYXJnIHRoZSBhcmd1bWVudCB0byB0ZXN0XG5cdFx0ICogIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIHRoZSBhcmcgaXMgYSBmdW5jdGlvblxuXHRcdCAqICBAc3RhdGljXG5cdFx0ICogIEBtZW1iZXJPZiBUb25lXG5cdFx0ICovXG5cdCAgICBUb25lLmlzRnVuY3Rpb24gPSBmdW5jdGlvbiAodmFsKSB7XG5cdCAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbic7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFRlc3QgaWYgdGhlIGFyZ3VtZW50IGlzIGEgbnVtYmVyLlxuXHRcdCAqICBAcGFyYW0geyp9IGFyZyB0aGUgYXJndW1lbnQgdG8gdGVzdFxuXHRcdCAqICBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgYXJnIGlzIGEgbnVtYmVyXG5cdFx0ICogIEBzdGF0aWNcblx0XHQgKiAgQG1lbWJlck9mIFRvbmVcblx0XHQgKi9cblx0ICAgIFRvbmUuaXNOdW1iZXIgPSBmdW5jdGlvbiAoYXJnKSB7XG5cdCAgICAgICAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBUZXN0IGlmIHRoZSBnaXZlbiBhcmd1bWVudCBpcyBhbiBvYmplY3QgbGl0ZXJhbCAoaS5lLiBge31gKTtcblx0XHQgKiAgQHBhcmFtIHsqfSBhcmcgdGhlIGFyZ3VtZW50IHRvIHRlc3Rcblx0XHQgKiAgQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgdGhlIGFyZyBpcyBhbiBvYmplY3QgbGl0ZXJhbC5cblx0XHQgKiAgQHN0YXRpY1xuXHRcdCAqICBAbWVtYmVyT2YgVG9uZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5pc09iamVjdCA9IGZ1bmN0aW9uIChhcmcpIHtcblx0ICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGFyZykgPT09ICdbb2JqZWN0IE9iamVjdF0nICYmIGFyZy5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0O1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBUZXN0IGlmIHRoZSBhcmd1bWVudCBpcyBhIGJvb2xlYW4uXG5cdFx0ICogIEBwYXJhbSB7Kn0gYXJnIHRoZSBhcmd1bWVudCB0byB0ZXN0XG5cdFx0ICogIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIHRoZSBhcmcgaXMgYSBib29sZWFuXG5cdFx0ICogIEBzdGF0aWNcblx0XHQgKiAgQG1lbWJlck9mIFRvbmVcblx0XHQgKi9cblx0ICAgIFRvbmUuaXNCb29sZWFuID0gZnVuY3Rpb24gKGFyZykge1xuXHQgICAgICAgIHJldHVybiB0eXBlb2YgYXJnID09PSAnYm9vbGVhbic7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFRlc3QgaWYgdGhlIGFyZ3VtZW50IGlzIGFuIEFycmF5XG5cdFx0ICogIEBwYXJhbSB7Kn0gYXJnIHRoZSBhcmd1bWVudCB0byB0ZXN0XG5cdFx0ICogIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIHRoZSBhcmcgaXMgYW4gYXJyYXlcblx0XHQgKiAgQHN0YXRpY1xuXHRcdCAqICBAbWVtYmVyT2YgVG9uZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5pc0FycmF5ID0gZnVuY3Rpb24gKGFyZykge1xuXHQgICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KGFyZyk7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFRlc3QgaWYgdGhlIGFyZ3VtZW50IGlzIGEgc3RyaW5nLlxuXHRcdCAqICBAcGFyYW0geyp9IGFyZyB0aGUgYXJndW1lbnQgdG8gdGVzdFxuXHRcdCAqICBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgYXJnIGlzIGEgc3RyaW5nXG5cdFx0ICogIEBzdGF0aWNcblx0XHQgKiAgQG1lbWJlck9mIFRvbmVcblx0XHQgKi9cblx0ICAgIFRvbmUuaXNTdHJpbmcgPSBmdW5jdGlvbiAoYXJnKSB7XG5cdCAgICAgICAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBUZXN0IGlmIHRoZSBhcmd1bWVudCBpcyBpbiB0aGUgZm9ybSBvZiBhIG5vdGUgaW4gc2NpZW50aWZpYyBwaXRjaCBub3RhdGlvbi5cblx0XHQgKiAgZS5nLiBcIkM0XCJcblx0XHQgKiAgQHBhcmFtIHsqfSBhcmcgdGhlIGFyZ3VtZW50IHRvIHRlc3Rcblx0XHQgKiAgQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgdGhlIGFyZyBpcyBhIHN0cmluZ1xuXHRcdCAqICBAc3RhdGljXG5cdFx0ICogIEBtZW1iZXJPZiBUb25lXG5cdFx0ICovXG5cdCAgICBUb25lLmlzTm90ZSA9IGZ1bmN0aW9uIChhcmcpIHtcblx0ICAgICAgICByZXR1cm4gVG9uZS5pc1N0cmluZyhhcmcpICYmIC9eKFthLWddezF9KD86YnwjfHh8YmIpPykoLT9bMC05XSspL2kudGVzdChhcmcpO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBBbiBlbXB0eSBmdW5jdGlvbi5cblx0XHQgKiAgQHN0YXRpY1xuXHRcdCAqL1xuXHQgICAgVG9uZS5ub09wID0gZnVuY3Rpb24gKCkge1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBNYWtlIHRoZSBwcm9wZXJ0eSBub3Qgd3JpdGFibGUuIEludGVybmFsIHVzZSBvbmx5LlxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqICBAcGFyYW0gIHtzdHJpbmd9ICBwcm9wZXJ0eSAgdGhlIHByb3BlcnR5IHRvIG1ha2Ugbm90IHdyaXRhYmxlXG5cdFx0ICovXG5cdCAgICBUb25lLnByb3RvdHlwZS5fcmVhZE9ubHkgPSBmdW5jdGlvbiAocHJvcGVydHkpIHtcblx0ICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwcm9wZXJ0eSkpIHtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wZXJ0eS5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fcmVhZE9ubHkocHJvcGVydHlbaV0pO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIHByb3BlcnR5LCB7XG5cdCAgICAgICAgICAgICAgICB3cml0YWJsZTogZmFsc2UsXG5cdCAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgTWFrZSBhbiBhdHRyaWJ1dGUgd3JpdGVhYmxlLiBJbnRlcmFsIHVzZSBvbmx5LlxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqICBAcGFyYW0gIHtzdHJpbmd9ICBwcm9wZXJ0eSAgdGhlIHByb3BlcnR5IHRvIG1ha2Ugd3JpdGFibGVcblx0XHQgKi9cblx0ICAgIFRvbmUucHJvdG90eXBlLl93cml0YWJsZSA9IGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xuXHQgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHByb3BlcnR5KSkge1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BlcnR5Lmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl93cml0YWJsZShwcm9wZXJ0eVtpXSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgcHJvcGVydHksIHsgd3JpdGFibGU6IHRydWUgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqIFBvc3NpYmxlIHBsYXkgc3RhdGVzLlxuXHRcdCAqIEBlbnVtIHtzdHJpbmd9XG5cdFx0ICovXG5cdCAgICBUb25lLlN0YXRlID0ge1xuXHQgICAgICAgIFN0YXJ0ZWQ6ICdzdGFydGVkJyxcblx0ICAgICAgICBTdG9wcGVkOiAnc3RvcHBlZCcsXG5cdCAgICAgICAgUGF1c2VkOiAncGF1c2VkJ1xuXHQgICAgfTtcblx0ICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQgICAgLy8gQ09OVkVSU0lPTlNcblx0ICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQgICAgLyoqXG5cdFx0ICogIEVxdWFsIHBvd2VyIGdhaW4gc2NhbGUuIEdvb2QgZm9yIGNyb3NzLWZhZGluZy5cblx0XHQgKiAgQHBhcmFtICB7Tm9ybWFsUmFuZ2V9IHBlcmNlbnQgKDAtMSlcblx0XHQgKiAgQHJldHVybiB7TnVtYmVyfSAgICAgICAgIG91dHB1dCBnYWluICgwLTEpXG5cdFx0ICogIEBzdGF0aWNcblx0XHQgKiAgQG1lbWJlck9mIFRvbmVcblx0XHQgKi9cblx0ICAgIFRvbmUuZXF1YWxQb3dlclNjYWxlID0gZnVuY3Rpb24gKHBlcmNlbnQpIHtcblx0ICAgICAgICB2YXIgcGlGYWN0b3IgPSAwLjUgKiBNYXRoLlBJO1xuXHQgICAgICAgIHJldHVybiBNYXRoLnNpbihwZXJjZW50ICogcGlGYWN0b3IpO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBDb252ZXJ0IGRlY2liZWxzIGludG8gZ2Fpbi5cblx0XHQgKiAgQHBhcmFtICB7RGVjaWJlbHN9IGRiXG5cdFx0ICogIEByZXR1cm4ge051bWJlcn1cblx0XHQgKiAgQHN0YXRpY1xuXHRcdCAqICBAbWVtYmVyT2YgVG9uZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5kYlRvR2FpbiA9IGZ1bmN0aW9uIChkYikge1xuXHQgICAgICAgIHJldHVybiBNYXRoLnBvdygyLCBkYiAvIDYpO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBDb252ZXJ0IGdhaW4gdG8gZGVjaWJlbHMuXG5cdFx0ICogIEBwYXJhbSAge051bWJlcn0gZ2FpbiAoMC0xKVxuXHRcdCAqICBAcmV0dXJuIHtEZWNpYmVsc31cblx0XHQgKiAgQHN0YXRpY1xuXHRcdCAqICBAbWVtYmVyT2YgVG9uZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5nYWluVG9EYiA9IGZ1bmN0aW9uIChnYWluKSB7XG5cdCAgICAgICAgcmV0dXJuIDIwICogKE1hdGgubG9nKGdhaW4pIC8gTWF0aC5MTjEwKTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgQ29udmVydCBhbiBpbnRlcnZhbCAoaW4gc2VtaXRvbmVzKSB0byBhIGZyZXF1ZW5jeSByYXRpby5cblx0XHQgKiAgQHBhcmFtICB7SW50ZXJ2YWx9IGludGVydmFsIHRoZSBudW1iZXIgb2Ygc2VtaXRvbmVzIGFib3ZlIHRoZSBiYXNlIG5vdGVcblx0XHQgKiAgQHJldHVybiB7bnVtYmVyfSAgICAgICAgICB0aGUgZnJlcXVlbmN5IHJhdGlvXG5cdFx0ICogIEBzdGF0aWNcblx0XHQgKiAgQG1lbWJlck9mIFRvbmVcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiB0b25lLmludGVydmFsVG9GcmVxdWVuY3lSYXRpbygwKTsgLy8gMVxuXHRcdCAqIHRvbmUuaW50ZXJ2YWxUb0ZyZXF1ZW5jeVJhdGlvKDEyKTsgLy8gMlxuXHRcdCAqIHRvbmUuaW50ZXJ2YWxUb0ZyZXF1ZW5jeVJhdGlvKC0xMik7IC8vIDAuNVxuXHRcdCAqL1xuXHQgICAgVG9uZS5pbnRlcnZhbFRvRnJlcXVlbmN5UmF0aW8gPSBmdW5jdGlvbiAoaW50ZXJ2YWwpIHtcblx0ICAgICAgICByZXR1cm4gTWF0aC5wb3coMiwgaW50ZXJ2YWwgLyAxMik7XG5cdCAgICB9O1xuXHQgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdCAgICAvL1x0VElNSU5HXG5cdCAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblx0ICAgIC8qKlxuXHRcdCAqICBSZXR1cm4gdGhlIGN1cnJlbnQgdGltZSBvZiB0aGUgQXVkaW9Db250ZXh0IGNsb2NrLlxuXHRcdCAqICBAcmV0dXJuIHtOdW1iZXJ9IHRoZSBjdXJyZW50VGltZSBmcm9tIHRoZSBBdWRpb0NvbnRleHRcblx0XHQgKiAgQG1lbWJlck9mIFRvbmUjXG5cdFx0ICovXG5cdCAgICBUb25lLnByb3RvdHlwZS5ub3cgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgcmV0dXJuIFRvbmUuY29udGV4dC5ub3coKTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgUmV0dXJuIHRoZSBjdXJyZW50IHRpbWUgb2YgdGhlIEF1ZGlvQ29udGV4dCBjbG9jay5cblx0XHQgKiAgQHJldHVybiB7TnVtYmVyfSB0aGUgY3VycmVudFRpbWUgZnJvbSB0aGUgQXVkaW9Db250ZXh0XG5cdFx0ICogIEBzdGF0aWNcblx0XHQgKiAgQG1lbWJlck9mIFRvbmVcblx0XHQgKi9cblx0ICAgIFRvbmUubm93ID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHJldHVybiBUb25lLmNvbnRleHQubm93KCk7XG5cdCAgICB9O1xuXHQgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdCAgICAvL1x0SU5IRVJJVEFOQ0Vcblx0ICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQgICAgLyoqXG5cdFx0ICogIGhhdmUgYSBjaGlsZCBpbmhlcml0IGFsbCBvZiBUb25lJ3MgKG9yIGEgcGFyZW50J3MpIHByb3RvdHlwZVxuXHRcdCAqICB0byBpbmhlcml0IHRoZSBwYXJlbnQncyBwcm9wZXJ0aWVzLCBtYWtlIHN1cmUgdG8gY2FsbFxuXHRcdCAqICBQYXJlbnQuY2FsbCh0aGlzKSBpbiB0aGUgY2hpbGQncyBjb25zdHJ1Y3RvclxuXHRcdCAqXG5cdFx0ICogIGJhc2VkIG9uIGNsb3N1cmUgbGlicmFyeSdzIGluaGVyaXQgZnVuY3Rpb25cblx0XHQgKlxuXHRcdCAqICBAbWVtYmVyT2YgVG9uZVxuXHRcdCAqICBAc3RhdGljXG5cdFx0ICogIEBwYXJhbSAge2Z1bmN0aW9ufSBcdGNoaWxkXG5cdFx0ICogIEBwYXJhbSAge2Z1bmN0aW9uPX0gcGFyZW50IChvcHRpb25hbCkgcGFyZW50IHRvIGluaGVyaXQgZnJvbVxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiBubyBwYXJlbnQgaXMgc3VwcGxpZWQsIHRoZSBjaGlsZFxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWxsIGluaGVyaXQgZnJvbSBUb25lXG5cdFx0ICovXG5cdCAgICBUb25lLmV4dGVuZCA9IGZ1bmN0aW9uIChjaGlsZCwgcGFyZW50KSB7XG5cdCAgICAgICAgaWYgKFRvbmUuaXNVbmRlZihwYXJlbnQpKSB7XG5cdCAgICAgICAgICAgIHBhcmVudCA9IFRvbmU7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIFRlbXBDb25zdHJ1Y3RvcigpIHtcblx0ICAgICAgICB9XG5cdCAgICAgICAgVGVtcENvbnN0cnVjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7XG5cdCAgICAgICAgY2hpbGQucHJvdG90eXBlID0gbmV3IFRlbXBDb25zdHJ1Y3RvcigpO1xuXHQgICAgICAgIC8qKiBAb3ZlcnJpZGUgKi9cblx0ICAgICAgICBjaGlsZC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjaGlsZDtcblx0ICAgICAgICBjaGlsZC5fc3VwZXIgPSBwYXJlbnQ7XG5cdCAgICB9O1xuXHQgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdCAgICAvL1x0Q09OVEVYVFxuXHQgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdCAgICAvKipcblx0XHQgKiAgVGhlIHByaXZhdGUgYXVkaW8gY29udGV4dCBzaGFyZWQgYnkgYWxsIFRvbmUgTm9kZXMuXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICogIEB0eXBlIHtUb25lLkNvbnRleHR9XG5cdFx0ICovXG5cdCAgICB2YXIgYXVkaW9Db250ZXh0ID0gbnVsbDtcblx0ICAgIC8qKlxuXHRcdCAqICBBIHN0YXRpYyBwb2ludGVyIHRvIHRoZSBhdWRpbyBjb250ZXh0IGFjY2Vzc2libGUgYXMgVG9uZS5jb250ZXh0LlxuXHRcdCAqICBAdHlwZSB7VG9uZS5Db250ZXh0fVxuXHRcdCAqICBAbmFtZSBjb250ZXh0XG5cdFx0ICogIEBtZW1iZXJPZiBUb25lXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZSwgJ2NvbnRleHQnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBhdWRpb0NvbnRleHQ7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChjb250ZXh0KSB7XG5cdCAgICAgICAgICAgIGlmIChUb25lLkNvbnRleHQgJiYgY29udGV4dCBpbnN0YW5jZW9mIFRvbmUuQ29udGV4dCkge1xuXHQgICAgICAgICAgICAgICAgYXVkaW9Db250ZXh0ID0gY29udGV4dDtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIGF1ZGlvQ29udGV4dCA9IG5ldyBUb25lLkNvbnRleHQoY29udGV4dCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgLy9pbml0aWFsaXplIHRoZSBuZXcgYXVkaW8gY29udGV4dFxuXHQgICAgICAgICAgICBUb25lLkNvbnRleHQuZW1pdCgnaW5pdCcsIGF1ZGlvQ29udGV4dCk7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgVGhlIEF1ZGlvQ29udGV4dFxuXHRcdCAqICBAdHlwZSB7VG9uZS5Db250ZXh0fVxuXHRcdCAqICBAbmFtZSBjb250ZXh0XG5cdFx0ICogIEBtZW1iZXJPZiBUb25lI1xuXHRcdCAqICBAcmVhZE9ubHlcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLnByb3RvdHlwZSwgJ2NvbnRleHQnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBUb25lLmNvbnRleHQ7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgVG9uZSBhdXRvbWF0aWNhbGx5IGNyZWF0ZXMgYSBjb250ZXh0IG9uIGluaXQsIGJ1dCBpZiB5b3UgYXJlIHdvcmtpbmdcblx0XHQgKiAgd2l0aCBvdGhlciBsaWJyYXJpZXMgd2hpY2ggYWxzbyBjcmVhdGUgYW4gQXVkaW9Db250ZXh0LCBpdCBjYW4gYmVcblx0XHQgKiAgdXNlZnVsIHRvIHNldCB5b3VyIG93bi4gSWYgeW91IGFyZSBnb2luZyB0byBzZXQgeW91ciBvd24gY29udGV4dCxcblx0XHQgKiAgYmUgc3VyZSB0byBkbyBpdCBhdCB0aGUgc3RhcnQgb2YgeW91ciBjb2RlLCBiZWZvcmUgY3JlYXRpbmcgYW55IG9iamVjdHMuXG5cdFx0ICogIEBzdGF0aWNcblx0XHQgKiAgQHBhcmFtIHtBdWRpb0NvbnRleHR9IGN0eCBUaGUgbmV3IGF1ZGlvIGNvbnRleHQgdG8gc2V0XG5cdFx0ICovXG5cdCAgICBUb25lLnNldENvbnRleHQgPSBmdW5jdGlvbiAoY3R4KSB7XG5cdCAgICAgICAgVG9uZS5jb250ZXh0ID0gY3R4O1xuXHQgICAgfTtcblx0ICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQgICAgLy9cdEFUVFJJQlVURVNcblx0ICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQgICAgLyoqXG5cdFx0ICogIFRoZSBudW1iZXIgb2Ygc2Vjb25kcyBvZiAxIHByb2Nlc3NpbmcgYmxvY2sgKDEyOCBzYW1wbGVzKVxuXHRcdCAqICBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqICBAbmFtZSBibG9ja1RpbWVcblx0XHQgKiAgQG1lbWJlck9mIFRvbmVcblx0XHQgKiAgQHN0YXRpY1xuXHRcdCAqICBAcmVhZE9ubHlcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLnByb3RvdHlwZSwgJ2Jsb2NrVGltZScsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIDEyOCAvIHRoaXMuY29udGV4dC5zYW1wbGVSYXRlO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIFRoZSBkdXJhdGlvbiBpbiBzZWNvbmRzIG9mIG9uZSBzYW1wbGUuXG5cdFx0ICogIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogIEBuYW1lIHNhbXBsZVRpbWVcblx0XHQgKiAgQG1lbWJlck9mIFRvbmVcblx0XHQgKiAgQHN0YXRpY1xuXHRcdCAqICBAcmVhZE9ubHlcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLnByb3RvdHlwZSwgJ3NhbXBsZVRpbWUnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiAxIC8gdGhpcy5jb250ZXh0LnNhbXBsZVJhdGU7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgV2hldGhlciBvciBub3QgYWxsIHRoZSB0ZWNobm9sb2dpZXMgdGhhdCBUb25lLmpzIHJlbGllcyBvbiBhcmUgc3VwcG9ydGVkIGJ5IHRoZSBjdXJyZW50IGJyb3dzZXIuXG5cdFx0ICogIEB0eXBlIHtCb29sZWFufVxuXHRcdCAqICBAbmFtZSBzdXBwb3J0ZWRcblx0XHQgKiAgQG1lbWJlck9mIFRvbmVcblx0XHQgKiAgQHJlYWRPbmx5XG5cdFx0ICogIEBzdGF0aWNcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLCAnc3VwcG9ydGVkJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgaGFzQXVkaW9Db250ZXh0ID0gd2luZG93Lmhhc093blByb3BlcnR5KCdBdWRpb0NvbnRleHQnKSB8fCB3aW5kb3cuaGFzT3duUHJvcGVydHkoJ3dlYmtpdEF1ZGlvQ29udGV4dCcpO1xuXHQgICAgICAgICAgICB2YXIgaGFzUHJvbWlzZXMgPSB3aW5kb3cuaGFzT3duUHJvcGVydHkoJ1Byb21pc2UnKTtcblx0ICAgICAgICAgICAgdmFyIGhhc1dvcmtlcnMgPSB3aW5kb3cuaGFzT3duUHJvcGVydHkoJ1dvcmtlcicpO1xuXHQgICAgICAgICAgICByZXR1cm4gaGFzQXVkaW9Db250ZXh0ICYmIGhhc1Byb21pc2VzICYmIGhhc1dvcmtlcnM7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgQm9vbGVhbiB2YWx1ZSBpZiB0aGUgYXVkaW8gY29udGV4dCBoYXMgYmVlbiBpbml0aWFsaXplZC5cblx0XHQgKiAgQHR5cGUge0Jvb2xlYW59XG5cdFx0ICogIEBtZW1iZXJPZiBUb25lXG5cdFx0ICogIEBzdGF0aWNcblx0XHQgKiAgQG5hbWUgaW5pdGlhbGl6ZWRcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLCAnaW5pdGlhbGl6ZWQnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBhdWRpb0NvbnRleHQgIT09IG51bGw7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgR2V0IHRoZSBjb250ZXh0IHdoZW4gaXQgYmVjb21lcyBhdmFpbGFibGVcblx0XHQgKiAgQHBhcmFtICB7RnVuY3Rpb259ICByZXNvbHZlICBDYWxsYmFjayB3aGVuIHRoZSBjb250ZXh0IGlzIGluaXRpYWxpemVkXG5cdFx0ICogIEByZXR1cm4gIHtUb25lfVxuXHRcdCAqL1xuXHQgICAgVG9uZS5nZXRDb250ZXh0ID0gZnVuY3Rpb24gKHJlc29sdmUpIHtcblx0ICAgICAgICBpZiAoVG9uZS5pbml0aWFsaXplZCkge1xuXHQgICAgICAgICAgICByZXNvbHZlKFRvbmUuY29udGV4dCk7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgdmFyIHJlc0NhbGxiYWNrID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgcmVzb2x2ZShUb25lLmNvbnRleHQpO1xuXHQgICAgICAgICAgICAgICAgVG9uZS5Db250ZXh0Lm9mZignaW5pdCcsIHJlc0NhbGxiYWNrKTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgVG9uZS5Db250ZXh0Lm9uKCdpbml0JywgcmVzQ2FsbGJhY2spO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gVG9uZTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiBUaGUgdmVyc2lvbiBudW1iZXJcblx0XHQgKiBAdHlwZSB7U3RyaW5nfVxuXHRcdCAqIEBzdGF0aWNcblx0XHQgKi9cblx0ICAgIFRvbmUudmVyc2lvbiA9ICdyMTEnO1xuXHQgICAgLy8gYWxsb3cgb3B0aW9uYWwgc2lsZW5jaW5nIG9mIHRoaXMgbG9nXG5cdCAgICBpZiAoIXdpbmRvdy5UT05FX1NJTEVOQ0VfVkVSU0lPTl9MT0dHSU5HKSB7XG5cdCAgICAgICAgY29uc29sZS5sb2coJyVjICogVG9uZS5qcyAnICsgVG9uZS52ZXJzaW9uICsgJyAqICcsICdiYWNrZ3JvdW5kOiAjMDAwOyBjb2xvcjogI2ZmZicpO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIFRvbmU7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyBUb25lLkVtaXR0ZXIgZ2l2ZXMgY2xhc3NlcyB3aGljaCBleHRlbmQgaXRcblx0XHQgKiAgICAgICAgIHRoZSBhYmlsaXR5IHRvIGxpc3RlbiBmb3IgYW5kIGVtaXQgZXZlbnRzLiBcblx0XHQgKiAgICAgICAgIEluc3BpcmF0aW9uIGFuZCByZWZlcmVuY2UgZnJvbSBKZXJvbWUgRXRpZW5uZSdzIFtNaWNyb0V2ZW50XShodHRwczovL2dpdGh1Yi5jb20vamVyb21lZXRpZW5uZS9taWNyb2V2ZW50LmpzKS5cblx0XHQgKiAgICAgICAgIE1JVCAoYykgMjAxMSBKZXJvbWUgRXRpZW5uZS5cblx0XHQgKiAgICAgICAgIFxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZX1cblx0XHQgKi9cblx0ICAgIFRvbmUuRW1pdHRlciA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLmNhbGwodGhpcyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgQ29udGFpbnMgYWxsIG9mIHRoZSBldmVudHMuXG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqICBAdHlwZSAge09iamVjdH1cblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuRW1pdHRlcik7XG5cdCAgICAvKipcblx0XHQgKiAgQmluZCBhIGNhbGxiYWNrIHRvIGEgc3BlY2lmaWMgZXZlbnQuXG5cdFx0ICogIEBwYXJhbSAge1N0cmluZ30gICAgZXZlbnQgICAgIFRoZSBuYW1lIG9mIHRoZSBldmVudCB0byBsaXN0ZW4gZm9yLlxuXHRcdCAqICBAcGFyYW0gIHtGdW5jdGlvbn0gIGNhbGxiYWNrICBUaGUgY2FsbGJhY2sgdG8gaW52b2tlIHdoZW4gdGhlXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50IGlzIGVtaXR0ZWRcblx0XHQgKiAgQHJldHVybiAge1RvbmUuRW1pdHRlcn0gICAgdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5FbWl0dGVyLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIChldmVudCwgY2FsbGJhY2spIHtcblx0ICAgICAgICAvL3NwbGl0IHRoZSBldmVudFxuXHQgICAgICAgIHZhciBldmVudHMgPSBldmVudC5zcGxpdCgvXFxXKy8pO1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXZlbnRzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgIHZhciBldmVudE5hbWUgPSBldmVudHNbaV07XG5cdCAgICAgICAgICAgIGlmICghdGhpcy5fZXZlbnRzLmhhc093blByb3BlcnR5KGV2ZW50TmFtZSkpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX2V2ZW50c1tldmVudE5hbWVdID0gW107XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdGhpcy5fZXZlbnRzW2V2ZW50TmFtZV0ucHVzaChjYWxsYmFjayk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBSZW1vdmUgdGhlIGV2ZW50IGxpc3RlbmVyLlxuXHRcdCAqICBAcGFyYW0gIHtTdHJpbmd9ICAgIGV2ZW50ICAgICBUaGUgZXZlbnQgdG8gc3RvcCBsaXN0ZW5pbmcgdG8uXG5cdFx0ICogIEBwYXJhbSAge0Z1bmN0aW9uPX0gIGNhbGxiYWNrICBUaGUgY2FsbGJhY2sgd2hpY2ggd2FzIGJvdW5kIHRvIFxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgZXZlbnQgd2l0aCBUb25lLkVtaXR0ZXIub24uXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElmIG5vIGNhbGxiYWNrIGlzIGdpdmVuLCBhbGwgY2FsbGJhY2tzXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50cyBhcmUgcmVtb3ZlZC5cblx0XHQgKiAgQHJldHVybiAge1RvbmUuRW1pdHRlcn0gICAgdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5FbWl0dGVyLnByb3RvdHlwZS5vZmYgPSBmdW5jdGlvbiAoZXZlbnQsIGNhbGxiYWNrKSB7XG5cdCAgICAgICAgdmFyIGV2ZW50cyA9IGV2ZW50LnNwbGl0KC9cXFcrLyk7XG5cdCAgICAgICAgZm9yICh2YXIgZXYgPSAwOyBldiA8IGV2ZW50cy5sZW5ndGg7IGV2KyspIHtcblx0ICAgICAgICAgICAgZXZlbnQgPSBldmVudHNbZXZdO1xuXHQgICAgICAgICAgICBpZiAodGhpcy5fZXZlbnRzLmhhc093blByb3BlcnR5KGV2ZW50KSkge1xuXHQgICAgICAgICAgICAgICAgaWYgKFRvbmUuaXNVbmRlZihjYWxsYmFjaykpIHtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLl9ldmVudHNbZXZlbnRdID0gW107XG5cdCAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBldmVudExpc3QgPSB0aGlzLl9ldmVudHNbZXZlbnRdO1xuXHQgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXZlbnRMaXN0Lmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChldmVudExpc3RbaV0gPT09IGNhbGxiYWNrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudExpc3Quc3BsaWNlKGksIDEpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBJbnZva2UgYWxsIG9mIHRoZSBjYWxsYmFja3MgYm91bmQgdG8gdGhlIGV2ZW50XG5cdFx0ICogIHdpdGggYW55IGFyZ3VtZW50cyBwYXNzZWQgaW4uIFxuXHRcdCAqICBAcGFyYW0gIHtTdHJpbmd9ICBldmVudCAgVGhlIG5hbWUgb2YgdGhlIGV2ZW50LlxuXHRcdCAqICBAcGFyYW0geyp9IGFyZ3MuLi4gVGhlIGFyZ3VtZW50cyB0byBwYXNzIHRvIHRoZSBmdW5jdGlvbnMgbGlzdGVuaW5nLlxuXHRcdCAqICBAcmV0dXJuICB7VG9uZS5FbWl0dGVyfSAgdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5FbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdCAgICAgICAgaWYgKHRoaXMuX2V2ZW50cykge1xuXHQgICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LmFwcGx5KG51bGwsIGFyZ3VtZW50cykuc2xpY2UoMSk7XG5cdCAgICAgICAgICAgIGlmICh0aGlzLl9ldmVudHMuaGFzT3duUHJvcGVydHkoZXZlbnQpKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgZXZlbnRMaXN0ID0gdGhpcy5fZXZlbnRzW2V2ZW50XTtcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBldmVudExpc3QubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICBldmVudExpc3RbaV0uYXBwbHkodGhpcywgYXJncyk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIEFkZCBFbWl0dGVyIGZ1bmN0aW9ucyAob24vb2ZmL2VtaXQpIHRvIHRoZSBvYmplY3Rcblx0XHQgKiAgQHBhcmFtICB7T2JqZWN0fEZ1bmN0aW9ufSAgb2JqZWN0ICBUaGUgb2JqZWN0IG9yIGNsYXNzIHRvIGV4dGVuZC5cblx0XHQgKiAgQHJldHVybnMge1RvbmUuRW1pdHRlcn1cblx0XHQgKi9cblx0ICAgIFRvbmUuRW1pdHRlci5taXhpbiA9IGZ1bmN0aW9uIChvYmplY3QpIHtcblx0ICAgICAgICB2YXIgZnVuY3Rpb25zID0gW1xuXHQgICAgICAgICAgICAnb24nLFxuXHQgICAgICAgICAgICAnb2ZmJyxcblx0ICAgICAgICAgICAgJ2VtaXQnXG5cdCAgICAgICAgXTtcblx0ICAgICAgICBvYmplY3QuX2V2ZW50cyA9IHt9O1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZnVuY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgIHZhciBmdW5jID0gZnVuY3Rpb25zW2ldO1xuXHQgICAgICAgICAgICB2YXIgZW1pdHRlckZ1bmMgPSBUb25lLkVtaXR0ZXIucHJvdG90eXBlW2Z1bmNdO1xuXHQgICAgICAgICAgICBvYmplY3RbZnVuY10gPSBlbWl0dGVyRnVuYztcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIFRvbmUuRW1pdHRlcjtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgQ2xlYW4gdXBcblx0XHQgKiAgQHJldHVybiAge1RvbmUuRW1pdHRlcn0gIHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuRW1pdHRlci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgdGhpcy5fZXZlbnRzID0gbnVsbDtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVG9uZS5FbWl0dGVyO1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgQSBUaW1lbGluZSBjbGFzcyBmb3Igc2NoZWR1bGluZyBhbmQgbWFpbnRhaW5pbmcgc3RhdGVcblx0XHQgKiAgICAgICAgIGFsb25nIGEgdGltZWxpbmUuIEFsbCBldmVudHMgbXVzdCBoYXZlIGEgXCJ0aW1lXCIgcHJvcGVydHkuIFxuXHRcdCAqICAgICAgICAgSW50ZXJuYWxseSwgZXZlbnRzIGFyZSBzdG9yZWQgaW4gdGltZSBvcmRlciBmb3IgZmFzdCBcblx0XHQgKiAgICAgICAgIHJldHJpZXZhbC5cblx0XHQgKiAgQGV4dGVuZHMge1RvbmV9XG5cdFx0ICogIEBwYXJhbSB7UG9zaXRpdmV9IFttZW1vcnk9SW5maW5pdHldIFRoZSBudW1iZXIgb2YgcHJldmlvdXMgZXZlbnRzIHRoYXQgYXJlIHJldGFpbmVkLlxuXHRcdCAqL1xuXHQgICAgVG9uZS5UaW1lbGluZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgb3B0aW9ucyA9IFRvbmUuZGVmYXVsdHMoYXJndW1lbnRzLCBbJ21lbW9yeSddLCBUb25lLlRpbWVsaW5lKTtcblx0ICAgICAgICBUb25lLmNhbGwodGhpcyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGFycmF5IG9mIHNjaGVkdWxlZCB0aW1lbGluZSBldmVudHNcblx0XHRcdCAqICBAdHlwZSAge0FycmF5fVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl90aW1lbGluZSA9IFtdO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIEFuIGFycmF5IG9mIGl0ZW1zIHRvIHJlbW92ZSBmcm9tIHRoZSBsaXN0LiBcblx0XHRcdCAqICBAdHlwZSB7QXJyYXl9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX3RvUmVtb3ZlID0gW107XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgRmxhZyBpZiB0aGUgdGltZWxpbmUgaXMgbWlkIGl0ZXJhdGlvblxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKiAgQHR5cGUge0Jvb2xlYW59XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9pdGVyYXRpbmcgPSBmYWxzZTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgbWVtb3J5IG9mIHRoZSB0aW1lbGluZSwgaS5lLlxuXHRcdFx0ICogIGhvdyBtYW55IGV2ZW50cyBpbiB0aGUgcGFzdCBpdCB3aWxsIHJldGFpblxuXHRcdFx0ICogIEB0eXBlIHtQb3NpdGl2ZX1cblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMubWVtb3J5ID0gb3B0aW9ucy5tZW1vcnk7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5UaW1lbGluZSk7XG5cdCAgICAvKipcblx0XHQgKiAgdGhlIGRlZmF1bHQgcGFyYW1ldGVyc1xuXHRcdCAqICBAc3RhdGljXG5cdFx0ICogIEBjb25zdFxuXHRcdCAqL1xuXHQgICAgVG9uZS5UaW1lbGluZS5kZWZhdWx0cyA9IHsgJ21lbW9yeSc6IEluZmluaXR5IH07XG5cdCAgICAvKipcblx0XHQgKiAgVGhlIG51bWJlciBvZiBpdGVtcyBpbiB0aGUgdGltZWxpbmUuXG5cdFx0ICogIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogIEBtZW1iZXJPZiBUb25lLlRpbWVsaW5lI1xuXHRcdCAqICBAbmFtZSBsZW5ndGhcblx0XHQgKiAgQHJlYWRPbmx5XG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5UaW1lbGluZS5wcm90b3R5cGUsICdsZW5ndGgnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl90aW1lbGluZS5sZW5ndGg7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgSW5zZXJ0IGFuIGV2ZW50IG9iamVjdCBvbnRvIHRoZSB0aW1lbGluZS4gRXZlbnRzIG11c3QgaGF2ZSBhIFwidGltZVwiIGF0dHJpYnV0ZS5cblx0XHQgKiAgQHBhcmFtICB7T2JqZWN0fSAgZXZlbnQgIFRoZSBldmVudCBvYmplY3QgdG8gaW5zZXJ0IGludG8gdGhlIFxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZWxpbmUuIFxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5UaW1lbGluZX0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5UaW1lbGluZS5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdCAgICAgICAgLy90aGUgZXZlbnQgbmVlZHMgdG8gaGF2ZSBhIHRpbWUgYXR0cmlidXRlXG5cdCAgICAgICAgaWYgKFRvbmUuaXNVbmRlZihldmVudC50aW1lKSkge1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RvbmUuVGltZWxpbmU6IGV2ZW50cyBtdXN0IGhhdmUgYSB0aW1lIGF0dHJpYnV0ZScpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAodGhpcy5fdGltZWxpbmUubGVuZ3RoKSB7XG5cdCAgICAgICAgICAgIHZhciBpbmRleCA9IHRoaXMuX3NlYXJjaChldmVudC50aW1lKTtcblx0ICAgICAgICAgICAgdGhpcy5fdGltZWxpbmUuc3BsaWNlKGluZGV4ICsgMSwgMCwgZXZlbnQpO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3RpbWVsaW5lLnB1c2goZXZlbnQpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICAvL2lmIHRoZSBsZW5ndGggaXMgbW9yZSB0aGFuIHRoZSBtZW1vcnksIHJlbW92ZSB0aGUgcHJldmlvdXMgb25lc1xuXHQgICAgICAgIGlmICh0aGlzLmxlbmd0aCA+IHRoaXMubWVtb3J5KSB7XG5cdCAgICAgICAgICAgIHZhciBkaWZmID0gdGhpcy5sZW5ndGggLSB0aGlzLm1lbW9yeTtcblx0ICAgICAgICAgICAgdGhpcy5fdGltZWxpbmUuc3BsaWNlKDAsIGRpZmYpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgUmVtb3ZlIGFuIGV2ZW50IGZyb20gdGhlIHRpbWVsaW5lLlxuXHRcdCAqICBAcGFyYW0gIHtPYmplY3R9ICBldmVudCAgVGhlIGV2ZW50IG9iamVjdCB0byByZW1vdmUgZnJvbSB0aGUgbGlzdC5cblx0XHQgKiAgQHJldHVybnMge1RvbmUuVGltZWxpbmV9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuVGltZWxpbmUucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChldmVudCkge1xuXHQgICAgICAgIGlmICh0aGlzLl9pdGVyYXRpbmcpIHtcblx0ICAgICAgICAgICAgdGhpcy5fdG9SZW1vdmUucHVzaChldmVudCk7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5fdGltZWxpbmUuaW5kZXhPZihldmVudCk7XG5cdCAgICAgICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX3RpbWVsaW5lLnNwbGljZShpbmRleCwgMSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIEdldCB0aGUgbmVhcmVzdCBldmVudCB3aG9zZSB0aW1lIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgZ2l2ZW4gdGltZS5cblx0XHQgKiAgQHBhcmFtICB7TnVtYmVyfSAgdGltZSAgVGhlIHRpbWUgdG8gcXVlcnkuXG5cdFx0ICogIEBwYXJhbSAge1N0cmluZ30gIGNvbXBhcml0b3IgV2hpY2ggdmFsdWUgaW4gdGhlIG9iamVjdCB0byBjb21wYXJlXG5cdFx0ICogIEByZXR1cm5zIHtPYmplY3R9IFRoZSBldmVudCBvYmplY3Qgc2V0IGFmdGVyIHRoYXQgdGltZS5cblx0XHQgKi9cblx0ICAgIFRvbmUuVGltZWxpbmUucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uICh0aW1lLCBjb21wYXJpdG9yKSB7XG5cdCAgICAgICAgY29tcGFyaXRvciA9IFRvbmUuZGVmYXVsdEFyZyhjb21wYXJpdG9yLCAndGltZScpO1xuXHQgICAgICAgIHZhciBpbmRleCA9IHRoaXMuX3NlYXJjaCh0aW1lLCBjb21wYXJpdG9yKTtcblx0ICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl90aW1lbGluZVtpbmRleF07XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgcmV0dXJuIG51bGw7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBSZXR1cm4gdGhlIGZpcnN0IGV2ZW50IGluIHRoZSB0aW1lbGluZSB3aXRob3V0IHJlbW92aW5nIGl0XG5cdFx0ICogIEByZXR1cm5zIHtPYmplY3R9IFRoZSBmaXJzdCBldmVudCBvYmplY3Rcblx0XHQgKi9cblx0ICAgIFRvbmUuVGltZWxpbmUucHJvdG90eXBlLnBlZWsgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuX3RpbWVsaW5lWzBdO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBSZXR1cm4gdGhlIGZpcnN0IGV2ZW50IGluIHRoZSB0aW1lbGluZSBhbmQgcmVtb3ZlIGl0XG5cdFx0ICogIEByZXR1cm5zIHtPYmplY3R9IFRoZSBmaXJzdCBldmVudCBvYmplY3Rcblx0XHQgKi9cblx0ICAgIFRvbmUuVGltZWxpbmUucHJvdG90eXBlLnNoaWZ0ID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHJldHVybiB0aGlzLl90aW1lbGluZS5zaGlmdCgpO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBHZXQgdGhlIGV2ZW50IHdoaWNoIGlzIHNjaGVkdWxlZCBhZnRlciB0aGUgZ2l2ZW4gdGltZS5cblx0XHQgKiAgQHBhcmFtICB7TnVtYmVyfSAgdGltZSAgVGhlIHRpbWUgdG8gcXVlcnkuXG5cdFx0ICogIEBwYXJhbSAge1N0cmluZ30gIGNvbXBhcml0b3IgV2hpY2ggdmFsdWUgaW4gdGhlIG9iamVjdCB0byBjb21wYXJlXG5cdFx0ICogIEByZXR1cm5zIHtPYmplY3R9IFRoZSBldmVudCBvYmplY3QgYWZ0ZXIgdGhlIGdpdmVuIHRpbWVcblx0XHQgKi9cblx0ICAgIFRvbmUuVGltZWxpbmUucHJvdG90eXBlLmdldEFmdGVyID0gZnVuY3Rpb24gKHRpbWUsIGNvbXBhcml0b3IpIHtcblx0ICAgICAgICBjb21wYXJpdG9yID0gVG9uZS5kZWZhdWx0QXJnKGNvbXBhcml0b3IsICd0aW1lJyk7XG5cdCAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5fc2VhcmNoKHRpbWUsIGNvbXBhcml0b3IpO1xuXHQgICAgICAgIGlmIChpbmRleCArIDEgPCB0aGlzLl90aW1lbGluZS5sZW5ndGgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RpbWVsaW5lW2luZGV4ICsgMV07XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgcmV0dXJuIG51bGw7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBHZXQgdGhlIGV2ZW50IGJlZm9yZSB0aGUgZXZlbnQgYXQgdGhlIGdpdmVuIHRpbWUuXG5cdFx0ICogIEBwYXJhbSAge051bWJlcn0gIHRpbWUgIFRoZSB0aW1lIHRvIHF1ZXJ5LlxuXHRcdCAqICBAcGFyYW0gIHtTdHJpbmd9ICBjb21wYXJpdG9yIFdoaWNoIHZhbHVlIGluIHRoZSBvYmplY3QgdG8gY29tcGFyZVxuXHRcdCAqICBAcmV0dXJucyB7T2JqZWN0fSBUaGUgZXZlbnQgb2JqZWN0IGJlZm9yZSB0aGUgZ2l2ZW4gdGltZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5UaW1lbGluZS5wcm90b3R5cGUuZ2V0QmVmb3JlID0gZnVuY3Rpb24gKHRpbWUsIGNvbXBhcml0b3IpIHtcblx0ICAgICAgICBjb21wYXJpdG9yID0gVG9uZS5kZWZhdWx0QXJnKGNvbXBhcml0b3IsICd0aW1lJyk7XG5cdCAgICAgICAgdmFyIGxlbiA9IHRoaXMuX3RpbWVsaW5lLmxlbmd0aDtcblx0ICAgICAgICAvL2lmIGl0J3MgYWZ0ZXIgdGhlIGxhc3QgaXRlbSwgcmV0dXJuIHRoZSBsYXN0IGl0ZW1cblx0ICAgICAgICBpZiAobGVuID4gMCAmJiB0aGlzLl90aW1lbGluZVtsZW4gLSAxXVtjb21wYXJpdG9yXSA8IHRpbWUpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RpbWVsaW5lW2xlbiAtIDFdO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgaW5kZXggPSB0aGlzLl9zZWFyY2godGltZSwgY29tcGFyaXRvcik7XG5cdCAgICAgICAgaWYgKGluZGV4IC0gMSA+PSAwKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl90aW1lbGluZVtpbmRleCAtIDFdO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIHJldHVybiBudWxsO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgQ2FuY2VsIGV2ZW50cyBhZnRlciB0aGUgZ2l2ZW4gdGltZVxuXHRcdCAqICBAcGFyYW0gIHtOdW1iZXJ9ICB0aW1lICBUaGUgdGltZSB0byBxdWVyeS5cblx0XHQgKiAgQHJldHVybnMge1RvbmUuVGltZWxpbmV9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuVGltZWxpbmUucHJvdG90eXBlLmNhbmNlbCA9IGZ1bmN0aW9uIChhZnRlcikge1xuXHQgICAgICAgIGlmICh0aGlzLl90aW1lbGluZS5sZW5ndGggPiAxKSB7XG5cdCAgICAgICAgICAgIHZhciBpbmRleCA9IHRoaXMuX3NlYXJjaChhZnRlcik7XG5cdCAgICAgICAgICAgIGlmIChpbmRleCA+PSAwKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5fdGltZWxpbmVbaW5kZXhdLnRpbWUgPT09IGFmdGVyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgLy9nZXQgdGhlIGZpcnN0IGl0ZW0gd2l0aCB0aGF0IHRpbWVcblx0ICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gaW5kZXg7IGkgPj0gMDsgaS0tKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl90aW1lbGluZVtpXS50aW1lID09PSBhZnRlcikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGltZWxpbmUgPSB0aGlzLl90aW1lbGluZS5zbGljZSgwLCBpbmRleCk7XG5cdCAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuX3RpbWVsaW5lID0gdGhpcy5fdGltZWxpbmUuc2xpY2UoMCwgaW5kZXggKyAxKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX3RpbWVsaW5lID0gW107XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX3RpbWVsaW5lLmxlbmd0aCA9PT0gMSkge1xuXHQgICAgICAgICAgICAvL3RoZSBmaXJzdCBpdGVtJ3MgdGltZVxuXHQgICAgICAgICAgICBpZiAodGhpcy5fdGltZWxpbmVbMF0udGltZSA+PSBhZnRlcikge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fdGltZWxpbmUgPSBbXTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgQ2FuY2VsIGV2ZW50cyBiZWZvcmUgb3IgZXF1YWwgdG8gdGhlIGdpdmVuIHRpbWUuXG5cdFx0ICogIEBwYXJhbSAge051bWJlcn0gIHRpbWUgIFRoZSB0aW1lIHRvIGNhbmNlbCBiZWZvcmUuXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLlRpbWVsaW5lfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLlRpbWVsaW5lLnByb3RvdHlwZS5jYW5jZWxCZWZvcmUgPSBmdW5jdGlvbiAodGltZSkge1xuXHQgICAgICAgIGlmICh0aGlzLl90aW1lbGluZS5sZW5ndGgpIHtcblx0ICAgICAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5fc2VhcmNoKHRpbWUpO1xuXHQgICAgICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fdGltZWxpbmUgPSB0aGlzLl90aW1lbGluZS5zbGljZShpbmRleCArIDEpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqIFJldHVybnMgdGhlIHByZXZpb3VzIGV2ZW50IGlmIHRoZXJlIGlzIG9uZS4gbnVsbCBvdGhlcndpc2Vcblx0XHQgKiBAcGFyYW0gIHtPYmplY3R9IGV2ZW50IFRoZSBldmVudCB0byBmaW5kIHRoZSBwcmV2aW91cyBvbmUgb2Zcblx0XHQgKiBAcmV0dXJuIHtPYmplY3R9ICAgICAgIFRoZSBldmVudCByaWdodCBiZWZvcmUgdGhlIGdpdmVuIGV2ZW50XG5cdFx0ICovXG5cdCAgICBUb25lLlRpbWVsaW5lLnByb3RvdHlwZS5wcmV2aW91c0V2ZW50ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdCAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5fdGltZWxpbmUuaW5kZXhPZihldmVudCk7XG5cdCAgICAgICAgaWYgKGluZGV4ID4gMCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fdGltZWxpbmVbaW5kZXggLSAxXTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICByZXR1cm4gbnVsbDtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIERvZXMgYSBiaW5hcnkgc2VyYWNoIG9uIHRoZSB0aW1lbGluZSBhcnJheSBhbmQgcmV0dXJucyB0aGUgXG5cdFx0ICogIG5lYXJlc3QgZXZlbnQgaW5kZXggd2hvc2UgdGltZSBpcyBhZnRlciBvciBlcXVhbCB0byB0aGUgZ2l2ZW4gdGltZS5cblx0XHQgKiAgSWYgYSB0aW1lIGlzIHNlYXJjaGVkIGJlZm9yZSB0aGUgZmlyc3QgaW5kZXggaW4gdGhlIHRpbWVsaW5lLCAtMSBpcyByZXR1cm5lZC5cblx0XHQgKiAgSWYgdGhlIHRpbWUgaXMgYWZ0ZXIgdGhlIGVuZCwgdGhlIGluZGV4IG9mIHRoZSBsYXN0IGl0ZW0gaXMgcmV0dXJuZWQuXG5cdFx0ICogIEBwYXJhbSAge051bWJlcn0gIHRpbWUgIFxuXHRcdCAqICBAcGFyYW0gIHtTdHJpbmd9ICBjb21wYXJpdG9yIFdoaWNoIHZhbHVlIGluIHRoZSBvYmplY3QgdG8gY29tcGFyZVxuXHRcdCAqICBAcmV0dXJuICB7TnVtYmVyfSB0aGUgaW5kZXggaW4gdGhlIHRpbWVsaW5lIGFycmF5IFxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5UaW1lbGluZS5wcm90b3R5cGUuX3NlYXJjaCA9IGZ1bmN0aW9uICh0aW1lLCBjb21wYXJpdG9yKSB7XG5cdCAgICAgICAgY29tcGFyaXRvciA9IFRvbmUuZGVmYXVsdEFyZyhjb21wYXJpdG9yLCAndGltZScpO1xuXHQgICAgICAgIHZhciBiZWdpbm5pbmcgPSAwO1xuXHQgICAgICAgIHZhciBsZW4gPSB0aGlzLl90aW1lbGluZS5sZW5ndGg7XG5cdCAgICAgICAgdmFyIGVuZCA9IGxlbjtcblx0ICAgICAgICBpZiAobGVuID4gMCAmJiB0aGlzLl90aW1lbGluZVtsZW4gLSAxXVtjb21wYXJpdG9yXSA8PSB0aW1lKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBsZW4gLSAxO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB3aGlsZSAoYmVnaW5uaW5nIDwgZW5kKSB7XG5cdCAgICAgICAgICAgIC8vIGNhbGN1bGF0ZSB0aGUgbWlkcG9pbnQgZm9yIHJvdWdobHkgZXF1YWwgcGFydGl0aW9uXG5cdCAgICAgICAgICAgIHZhciBtaWRQb2ludCA9IE1hdGguZmxvb3IoYmVnaW5uaW5nICsgKGVuZCAtIGJlZ2lubmluZykgLyAyKTtcblx0ICAgICAgICAgICAgdmFyIGV2ZW50ID0gdGhpcy5fdGltZWxpbmVbbWlkUG9pbnRdO1xuXHQgICAgICAgICAgICB2YXIgbmV4dEV2ZW50ID0gdGhpcy5fdGltZWxpbmVbbWlkUG9pbnQgKyAxXTtcblx0ICAgICAgICAgICAgaWYgKGV2ZW50W2NvbXBhcml0b3JdID09PSB0aW1lKSB7XG5cdCAgICAgICAgICAgICAgICAvL2Nob29zZSB0aGUgbGFzdCBvbmUgdGhhdCBoYXMgdGhlIHNhbWUgdGltZVxuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IG1pZFBvaW50OyBpIDwgdGhpcy5fdGltZWxpbmUubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgdGVzdEV2ZW50ID0gdGhpcy5fdGltZWxpbmVbaV07XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHRlc3RFdmVudFtjb21wYXJpdG9yXSA9PT0gdGltZSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBtaWRQb2ludCA9IGk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIG1pZFBvaW50O1xuXHQgICAgICAgICAgICB9IGVsc2UgaWYgKGV2ZW50W2NvbXBhcml0b3JdIDwgdGltZSAmJiBuZXh0RXZlbnRbY29tcGFyaXRvcl0gPiB0aW1lKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gbWlkUG9pbnQ7XG5cdCAgICAgICAgICAgIH0gZWxzZSBpZiAoZXZlbnRbY29tcGFyaXRvcl0gPiB0aW1lKSB7XG5cdCAgICAgICAgICAgICAgICAvL3NlYXJjaCBsb3dlclxuXHQgICAgICAgICAgICAgICAgZW5kID0gbWlkUG9pbnQ7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAvL3NlYXJjaCB1cHBlclxuXHQgICAgICAgICAgICAgICAgYmVnaW5uaW5nID0gbWlkUG9pbnQgKyAxO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiAtMTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgSW50ZXJuYWwgaXRlcmF0b3IuIEFwcGxpZXMgZXh0cmEgc2FmZXR5IGNoZWNrcyBmb3IgXG5cdFx0ICogIHJlbW92aW5nIGl0ZW1zIGZyb20gdGhlIGFycmF5LiBcblx0XHQgKiAgQHBhcmFtICB7RnVuY3Rpb259ICBjYWxsYmFjayBcblx0XHQgKiAgQHBhcmFtICB7TnVtYmVyPX0gICAgbG93ZXJCb3VuZCAgICAgXG5cdFx0ICogIEBwYXJhbSAge051bWJlcj19ICAgIHVwcGVyQm91bmQgICAgXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLlRpbWVsaW5lLnByb3RvdHlwZS5faXRlcmF0ZSA9IGZ1bmN0aW9uIChjYWxsYmFjaywgbG93ZXJCb3VuZCwgdXBwZXJCb3VuZCkge1xuXHQgICAgICAgIHRoaXMuX2l0ZXJhdGluZyA9IHRydWU7XG5cdCAgICAgICAgbG93ZXJCb3VuZCA9IFRvbmUuZGVmYXVsdEFyZyhsb3dlckJvdW5kLCAwKTtcblx0ICAgICAgICB1cHBlckJvdW5kID0gVG9uZS5kZWZhdWx0QXJnKHVwcGVyQm91bmQsIHRoaXMuX3RpbWVsaW5lLmxlbmd0aCAtIDEpO1xuXHQgICAgICAgIGZvciAodmFyIGkgPSBsb3dlckJvdW5kOyBpIDw9IHVwcGVyQm91bmQ7IGkrKykge1xuXHQgICAgICAgICAgICBjYWxsYmFjay5jYWxsKHRoaXMsIHRoaXMuX3RpbWVsaW5lW2ldKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdGhpcy5faXRlcmF0aW5nID0gZmFsc2U7XG5cdCAgICAgICAgaWYgKHRoaXMuX3RvUmVtb3ZlLmxlbmd0aCA+IDApIHtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLl90b1JlbW92ZS5sZW5ndGg7IGorKykge1xuXHQgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5fdGltZWxpbmUuaW5kZXhPZih0aGlzLl90b1JlbW92ZVtqXSk7XG5cdCAgICAgICAgICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGltZWxpbmUuc3BsaWNlKGluZGV4LCAxKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB0aGlzLl90b1JlbW92ZSA9IFtdO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgSXRlcmF0ZSBvdmVyIGV2ZXJ5dGhpbmcgaW4gdGhlIGFycmF5XG5cdFx0ICogIEBwYXJhbSAge0Z1bmN0aW9ufSAgY2FsbGJhY2sgVGhlIGNhbGxiYWNrIHRvIGludm9rZSB3aXRoIGV2ZXJ5IGl0ZW1cblx0XHQgKiAgQHJldHVybnMge1RvbmUuVGltZWxpbmV9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuVGltZWxpbmUucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcblx0ICAgICAgICB0aGlzLl9pdGVyYXRlKGNhbGxiYWNrKTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgSXRlcmF0ZSBvdmVyIGV2ZXJ5dGhpbmcgaW4gdGhlIGFycmF5IGF0IG9yIGJlZm9yZSB0aGUgZ2l2ZW4gdGltZS5cblx0XHQgKiAgQHBhcmFtICB7TnVtYmVyfSAgdGltZSBUaGUgdGltZSB0byBjaGVjayBpZiBpdGVtcyBhcmUgYmVmb3JlXG5cdFx0ICogIEBwYXJhbSAge0Z1bmN0aW9ufSAgY2FsbGJhY2sgVGhlIGNhbGxiYWNrIHRvIGludm9rZSB3aXRoIGV2ZXJ5IGl0ZW1cblx0XHQgKiAgQHJldHVybnMge1RvbmUuVGltZWxpbmV9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuVGltZWxpbmUucHJvdG90eXBlLmZvckVhY2hCZWZvcmUgPSBmdW5jdGlvbiAodGltZSwgY2FsbGJhY2spIHtcblx0ICAgICAgICAvL2l0ZXJhdGUgb3ZlciB0aGUgaXRlbXMgaW4gcmV2ZXJzZSBzbyB0aGF0IHJlbW92aW5nIGFuIGl0ZW0gZG9lc24ndCBicmVhayB0aGluZ3Ncblx0ICAgICAgICB2YXIgdXBwZXJCb3VuZCA9IHRoaXMuX3NlYXJjaCh0aW1lKTtcblx0ICAgICAgICBpZiAodXBwZXJCb3VuZCAhPT0gLTEpIHtcblx0ICAgICAgICAgICAgdGhpcy5faXRlcmF0ZShjYWxsYmFjaywgMCwgdXBwZXJCb3VuZCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBJdGVyYXRlIG92ZXIgZXZlcnl0aGluZyBpbiB0aGUgYXJyYXkgYWZ0ZXIgdGhlIGdpdmVuIHRpbWUuXG5cdFx0ICogIEBwYXJhbSAge051bWJlcn0gIHRpbWUgVGhlIHRpbWUgdG8gY2hlY2sgaWYgaXRlbXMgYXJlIGJlZm9yZVxuXHRcdCAqICBAcGFyYW0gIHtGdW5jdGlvbn0gIGNhbGxiYWNrIFRoZSBjYWxsYmFjayB0byBpbnZva2Ugd2l0aCBldmVyeSBpdGVtXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLlRpbWVsaW5lfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLlRpbWVsaW5lLnByb3RvdHlwZS5mb3JFYWNoQWZ0ZXIgPSBmdW5jdGlvbiAodGltZSwgY2FsbGJhY2spIHtcblx0ICAgICAgICAvL2l0ZXJhdGUgb3ZlciB0aGUgaXRlbXMgaW4gcmV2ZXJzZSBzbyB0aGF0IHJlbW92aW5nIGFuIGl0ZW0gZG9lc24ndCBicmVhayB0aGluZ3Ncblx0ICAgICAgICB2YXIgbG93ZXJCb3VuZCA9IHRoaXMuX3NlYXJjaCh0aW1lKTtcblx0ICAgICAgICB0aGlzLl9pdGVyYXRlKGNhbGxiYWNrLCBsb3dlckJvdW5kICsgMSk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIEl0ZXJhdGUgb3ZlciBldmVyeXRoaW5nIGluIHRoZSBhcnJheSBhdCBvciBhZnRlciB0aGUgZ2l2ZW4gdGltZS4gU2ltaWxhciB0byBcblx0XHQgKiAgZm9yRWFjaEFmdGVyLCBidXQgaW5jbHVkZXMgdGhlIGl0ZW0ocykgYXQgdGhlIGdpdmVuIHRpbWUuXG5cdFx0ICogIEBwYXJhbSAge051bWJlcn0gIHRpbWUgVGhlIHRpbWUgdG8gY2hlY2sgaWYgaXRlbXMgYXJlIGJlZm9yZVxuXHRcdCAqICBAcGFyYW0gIHtGdW5jdGlvbn0gIGNhbGxiYWNrIFRoZSBjYWxsYmFjayB0byBpbnZva2Ugd2l0aCBldmVyeSBpdGVtXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLlRpbWVsaW5lfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLlRpbWVsaW5lLnByb3RvdHlwZS5mb3JFYWNoRnJvbSA9IGZ1bmN0aW9uICh0aW1lLCBjYWxsYmFjaykge1xuXHQgICAgICAgIC8vaXRlcmF0ZSBvdmVyIHRoZSBpdGVtcyBpbiByZXZlcnNlIHNvIHRoYXQgcmVtb3ZpbmcgYW4gaXRlbSBkb2Vzbid0IGJyZWFrIHRoaW5nc1xuXHQgICAgICAgIHZhciBsb3dlckJvdW5kID0gdGhpcy5fc2VhcmNoKHRpbWUpO1xuXHQgICAgICAgIC8vd29yayBiYWNrd2FyZHMgdW50aWwgdGhlIGV2ZW50IHRpbWUgaXMgbGVzcyB0aGFuIHRpbWVcblx0ICAgICAgICB3aGlsZSAobG93ZXJCb3VuZCA+PSAwICYmIHRoaXMuX3RpbWVsaW5lW2xvd2VyQm91bmRdLnRpbWUgPj0gdGltZSkge1xuXHQgICAgICAgICAgICBsb3dlckJvdW5kLS07XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHRoaXMuX2l0ZXJhdGUoY2FsbGJhY2ssIGxvd2VyQm91bmQgKyAxKTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgSXRlcmF0ZSBvdmVyIGV2ZXJ5dGhpbmcgaW4gdGhlIGFycmF5IGF0IHRoZSBnaXZlbiB0aW1lXG5cdFx0ICogIEBwYXJhbSAge051bWJlcn0gIHRpbWUgVGhlIHRpbWUgdG8gY2hlY2sgaWYgaXRlbXMgYXJlIGJlZm9yZVxuXHRcdCAqICBAcGFyYW0gIHtGdW5jdGlvbn0gIGNhbGxiYWNrIFRoZSBjYWxsYmFjayB0byBpbnZva2Ugd2l0aCBldmVyeSBpdGVtXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLlRpbWVsaW5lfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLlRpbWVsaW5lLnByb3RvdHlwZS5mb3JFYWNoQXRUaW1lID0gZnVuY3Rpb24gKHRpbWUsIGNhbGxiYWNrKSB7XG5cdCAgICAgICAgLy9pdGVyYXRlIG92ZXIgdGhlIGl0ZW1zIGluIHJldmVyc2Ugc28gdGhhdCByZW1vdmluZyBhbiBpdGVtIGRvZXNuJ3QgYnJlYWsgdGhpbmdzXG5cdCAgICAgICAgdmFyIHVwcGVyQm91bmQgPSB0aGlzLl9zZWFyY2godGltZSk7XG5cdCAgICAgICAgaWYgKHVwcGVyQm91bmQgIT09IC0xKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2l0ZXJhdGUoZnVuY3Rpb24gKGV2ZW50KSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoZXZlbnQudGltZSA9PT0gdGltZSkge1xuXHQgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwodGhpcywgZXZlbnQpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9LCAwLCB1cHBlckJvdW5kKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIENsZWFuIHVwLlxuXHRcdCAqICBAcmV0dXJuICB7VG9uZS5UaW1lbGluZX0gIHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuVGltZWxpbmUucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuX3RpbWVsaW5lID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl90b1JlbW92ZSA9IG51bGw7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuVGltZWxpbmU7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIC8qKlxuXHRcdCAqICBzaGltXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBpZiAoIXdpbmRvdy5oYXNPd25Qcm9wZXJ0eSgnQXVkaW9Db250ZXh0JykgJiYgd2luZG93Lmhhc093blByb3BlcnR5KCd3ZWJraXRBdWRpb0NvbnRleHQnKSkge1xuXHQgICAgICAgIHdpbmRvdy5BdWRpb0NvbnRleHQgPSB3aW5kb3cud2Via2l0QXVkaW9Db250ZXh0O1xuXHQgICAgfVxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyBXcmFwcGVyIGFyb3VuZCB0aGUgbmF0aXZlIEF1ZGlvQ29udGV4dC5cblx0XHQgKiAgQGV4dGVuZHMge1RvbmUuRW1pdHRlcn1cblx0XHQgKiAgQHBhcmFtIHtBdWRpb0NvbnRleHQ9fSBjb250ZXh0IG9wdGlvbmFsbHkgcGFzcyBpbiBhIGNvbnRleHRcblx0XHQgKi9cblx0ICAgIFRvbmUuQ29udGV4dCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLkVtaXR0ZXIuY2FsbCh0aGlzKTtcblx0ICAgICAgICB2YXIgb3B0aW9ucyA9IFRvbmUuZGVmYXVsdHMoYXJndW1lbnRzLCBbJ2NvbnRleHQnXSwgVG9uZS5Db250ZXh0KTtcblx0ICAgICAgICBpZiAoIW9wdGlvbnMuY29udGV4dCkge1xuXHQgICAgICAgICAgICBvcHRpb25zLmNvbnRleHQgPSBuZXcgd2luZG93LkF1ZGlvQ29udGV4dCgpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB0aGlzLl9jb250ZXh0ID0gb3B0aW9ucy5jb250ZXh0O1xuXHQgICAgICAgIC8vIGV4dGVuZCBhbGwgb2YgdGhlIG1ldGhvZHNcblx0ICAgICAgICBmb3IgKHZhciBwcm9wIGluIHRoaXMuX2NvbnRleHQpIHtcblx0ICAgICAgICAgICAgdGhpcy5fZGVmaW5lUHJvcGVydHkodGhpcy5fY29udGV4dCwgcHJvcCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBkZWZhdWx0IGxhdGVuY3kgaGludFxuXHRcdFx0ICogIEB0eXBlICB7U3RyaW5nfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9sYXRlbmN5SGludCA9IG9wdGlvbnMubGF0ZW5jeUhpbnQ7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgQW4gb2JqZWN0IGNvbnRhaW5pbmcgYWxsIG9mIHRoZSBjb25zdGFudHMgQXVkaW9CdWZmZXJTb3VyY2VOb2Rlc1xuXHRcdFx0ICogIEB0eXBlICB7T2JqZWN0fVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9jb25zdGFudHMgPSB7fTtcblx0ICAgICAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQgICAgICAgIC8vIFdPUktFUlxuXHQgICAgICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGFtb3VudCBvZiB0aW1lIGV2ZW50cyBhcmUgc2NoZWR1bGVkXG5cdFx0XHQgKiAgaW50byB0aGUgZnV0dXJlXG5cdFx0XHQgKiAgQHR5cGUgIHtOdW1iZXJ9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMubG9va0FoZWFkID0gb3B0aW9ucy5sb29rQWhlYWQ7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgQSByZWZlcmVuY2UgdG8gdGhlIGFjdHVhbCBjb21wdXRlZCB1cGRhdGUgaW50ZXJ2YWxcblx0XHRcdCAqICBAdHlwZSAge051bWJlcn1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fY29tcHV0ZWRVcGRhdGVJbnRlcnZhbCA9IDA7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgQSByZWxpYWJsZSBjYWxsYmFjayBtZXRob2Rcblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICogIEB0eXBlICB7VGlja2VyfVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fdGlja2VyID0gbmV3IFRpY2tlcih0aGlzLmVtaXQuYmluZCh0aGlzLCAndGljaycpLCBvcHRpb25zLmNsb2NrU291cmNlLCBvcHRpb25zLnVwZGF0ZUludGVydmFsKTtcblx0ICAgICAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQgICAgICAgIC8vIFRJTUVPVVRTXG5cdCAgICAgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblx0ICAgICAgICAvKipcblx0XHRcdCAqICBBbGwgb2YgdGhlIHNldFRpbWVvdXQgZXZlbnRzLlxuXHRcdFx0ICogIEB0eXBlICB7VG9uZS5UaW1lbGluZX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fdGltZW91dHMgPSBuZXcgVG9uZS5UaW1lbGluZSgpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSB0aW1lb3V0IGlkIGNvdW50ZXJcblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICogIEB0eXBlIHtOdW1iZXJ9XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl90aW1lb3V0SWRzID0gMDtcblx0ICAgICAgICB0aGlzLm9uKCd0aWNrJywgdGhpcy5fdGltZW91dExvb3AuYmluZCh0aGlzKSk7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5Db250ZXh0LCBUb25lLkVtaXR0ZXIpO1xuXHQgICAgVG9uZS5FbWl0dGVyLm1peGluKFRvbmUuQ29udGV4dCk7XG5cdCAgICAvKipcblx0XHQgKiBkZWZhdWx0c1xuXHRcdCAqIEBzdGF0aWNcblx0XHQgKiBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqL1xuXHQgICAgVG9uZS5Db250ZXh0LmRlZmF1bHRzID0ge1xuXHQgICAgICAgICdjbG9ja1NvdXJjZSc6ICd3b3JrZXInLFxuXHQgICAgICAgICdsYXRlbmN5SGludCc6ICdpbnRlcmFjdGl2ZScsXG5cdCAgICAgICAgJ2xvb2tBaGVhZCc6IDAuMSxcblx0ICAgICAgICAndXBkYXRlSW50ZXJ2YWwnOiAwLjAzXG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIERlZmluZSBhIHByb3BlcnR5IG9uIHRoaXMgVG9uZS5Db250ZXh0LiBcblx0XHQgKiAgVGhpcyBpcyB1c2VkIHRvIGV4dGVuZCB0aGUgbmF0aXZlIEF1ZGlvQ29udGV4dFxuXHRcdCAqICBAcGFyYW0gIHtBdWRpb0NvbnRleHR9ICBjb250ZXh0XG5cdFx0ICogIEBwYXJhbSAge1N0cmluZ30gIHByb3AgXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLkNvbnRleHQucHJvdG90eXBlLl9kZWZpbmVQcm9wZXJ0eSA9IGZ1bmN0aW9uIChjb250ZXh0LCBwcm9wKSB7XG5cdCAgICAgICAgaWYgKFRvbmUuaXNVbmRlZih0aGlzW3Byb3BdKSkge1xuXHQgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgcHJvcCwge1xuXHQgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250ZXh0W3Byb3BdID09PSAnZnVuY3Rpb24nKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0W3Byb3BdLmJpbmQoY29udGV4dCk7XG5cdCAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHRbcHJvcF07XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGNvbnRleHRbcHJvcF0gPSB2YWw7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgVGhlIGN1cnJlbnQgYXVkaW8gY29udGV4dCB0aW1lXG5cdFx0ICogIEByZXR1cm4gIHtOdW1iZXJ9XG5cdFx0ICovXG5cdCAgICBUb25lLkNvbnRleHQucHJvdG90eXBlLm5vdyA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy5fY29udGV4dC5jdXJyZW50VGltZSArIHRoaXMubG9va0FoZWFkO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBHZW5lcmF0ZSBhIGxvb3BlZCBidWZmZXIgYXQgc29tZSBjb25zdGFudCB2YWx1ZS5cblx0XHQgKiAgQHBhcmFtICB7TnVtYmVyfSAgdmFsXG5cdFx0ICogIEByZXR1cm4gIHtCdWZmZXJTb3VyY2VOb2RlfVxuXHRcdCAqL1xuXHQgICAgVG9uZS5Db250ZXh0LnByb3RvdHlwZS5nZXRDb25zdGFudCA9IGZ1bmN0aW9uICh2YWwpIHtcblx0ICAgICAgICBpZiAodGhpcy5fY29uc3RhbnRzW3ZhbF0pIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnN0YW50c1t2YWxdO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIHZhciBidWZmZXIgPSB0aGlzLl9jb250ZXh0LmNyZWF0ZUJ1ZmZlcigxLCAxMjgsIHRoaXMuX2NvbnRleHQuc2FtcGxlUmF0ZSk7XG5cdCAgICAgICAgICAgIHZhciBhcnIgPSBidWZmZXIuZ2V0Q2hhbm5lbERhdGEoMCk7XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICBhcnJbaV0gPSB2YWw7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdmFyIGNvbnN0YW50ID0gdGhpcy5fY29udGV4dC5jcmVhdGVCdWZmZXJTb3VyY2UoKTtcblx0ICAgICAgICAgICAgY29uc3RhbnQuY2hhbm5lbENvdW50ID0gMTtcblx0ICAgICAgICAgICAgY29uc3RhbnQuY2hhbm5lbENvdW50TW9kZSA9ICdleHBsaWNpdCc7XG5cdCAgICAgICAgICAgIGNvbnN0YW50LmJ1ZmZlciA9IGJ1ZmZlcjtcblx0ICAgICAgICAgICAgY29uc3RhbnQubG9vcCA9IHRydWU7XG5cdCAgICAgICAgICAgIGNvbnN0YW50LnN0YXJ0KDApO1xuXHQgICAgICAgICAgICB0aGlzLl9jb25zdGFudHNbdmFsXSA9IGNvbnN0YW50O1xuXHQgICAgICAgICAgICByZXR1cm4gY29uc3RhbnQ7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgcHJpdmF0ZSBsb29wIHdoaWNoIGtlZXBzIHRyYWNrIG9mIHRoZSBjb250ZXh0IHNjaGVkdWxlZCB0aW1lb3V0c1xuXHRcdCAqICBJcyBpbnZva2VkIGZyb20gdGhlIGNsb2NrIHNvdXJjZVxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5Db250ZXh0LnByb3RvdHlwZS5fdGltZW91dExvb3AgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIG5vdyA9IHRoaXMubm93KCk7XG5cdCAgICAgICAgd2hpbGUgKHRoaXMuX3RpbWVvdXRzICYmIHRoaXMuX3RpbWVvdXRzLmxlbmd0aCAmJiB0aGlzLl90aW1lb3V0cy5wZWVrKCkudGltZSA8PSBub3cpIHtcblx0ICAgICAgICAgICAgdGhpcy5fdGltZW91dHMuc2hpZnQoKS5jYWxsYmFjaygpO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgQSBzZXRUaW1lb3V0IHdoaWNoIGlzIGdhdXJlbnRlZWQgYnkgdGhlIGNsb2NrIHNvdXJjZS4gXG5cdFx0ICogIEFsc28gcnVucyBpbiB0aGUgb2ZmbGluZSBjb250ZXh0LlxuXHRcdCAqICBAcGFyYW0gIHtGdW5jdGlvbn0gIGZuICAgICAgIFRoZSBjYWxsYmFjayB0byBpbnZva2Vcblx0XHQgKiAgQHBhcmFtICB7U2Vjb25kc30gICAgdGltZW91dCAgVGhlIHRpbWVvdXQgaW4gc2Vjb25kc1xuXHRcdCAqICBAcmV0dXJucyB7TnVtYmVyfSBJRCB0byB1c2Ugd2hlbiBpbnZva2luZyBUb25lLkNvbnRleHQuY2xlYXJUaW1lb3V0XG5cdFx0ICovXG5cdCAgICBUb25lLkNvbnRleHQucHJvdG90eXBlLnNldFRpbWVvdXQgPSBmdW5jdGlvbiAoZm4sIHRpbWVvdXQpIHtcblx0ICAgICAgICB0aGlzLl90aW1lb3V0SWRzKys7XG5cdCAgICAgICAgdmFyIG5vdyA9IHRoaXMubm93KCk7XG5cdCAgICAgICAgdGhpcy5fdGltZW91dHMuYWRkKHtcblx0ICAgICAgICAgICAgY2FsbGJhY2s6IGZuLFxuXHQgICAgICAgICAgICB0aW1lOiBub3cgKyB0aW1lb3V0LFxuXHQgICAgICAgICAgICBpZDogdGhpcy5fdGltZW91dElkc1xuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIHJldHVybiB0aGlzLl90aW1lb3V0SWRzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBDbGVhcnMgYSBwcmV2aW91c2x5IHNjaGVkdWxlZCB0aW1lb3V0IHdpdGggVG9uZS5jb250ZXh0LnNldFRpbWVvdXRcblx0XHQgKiAgQHBhcmFtICB7TnVtYmVyfSAgaWQgIFRoZSBJRCByZXR1cm5lZCBmcm9tIHNldFRpbWVvdXRcblx0XHQgKiAgQHJldHVybiAge1RvbmUuQ29udGV4dH0gIHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuQ29udGV4dC5wcm90b3R5cGUuY2xlYXJUaW1lb3V0ID0gZnVuY3Rpb24gKGlkKSB7XG5cdCAgICAgICAgdGhpcy5fdGltZW91dHMuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnQpIHtcblx0ICAgICAgICAgICAgaWYgKGV2ZW50LmlkID09PSBpZCkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5yZW1vdmUoZXZlbnQpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIEhvdyBvZnRlbiB0aGUgV2ViIFdvcmtlciBjYWxsYmFjayBpcyBpbnZva2VkLlxuXHRcdCAqICBUaGlzIG51bWJlciBjb3JyZXNwb25kcyB0byBob3cgcmVzcG9uc2l2ZSB0aGUgc2NoZWR1bGluZ1xuXHRcdCAqICBjYW4gYmUuIENvbnRleHQudXBkYXRlSW50ZXJ2YWwgKyBDb250ZXh0Lmxvb2tBaGVhZCBnaXZlcyB5b3UgdGhlXG5cdFx0ICogIHRvdGFsIGxhdGVuY3kgYmV0d2VlbiBzY2hlZHVsaW5nIGFuIGV2ZW50IGFuZCBoZWFyaW5nIGl0LlxuXHRcdCAqICBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqICBAbWVtYmVyT2YgVG9uZS5Db250ZXh0I1xuXHRcdCAqICBAbmFtZSB1cGRhdGVJbnRlcnZhbFxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuQ29udGV4dC5wcm90b3R5cGUsICd1cGRhdGVJbnRlcnZhbCcsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RpY2tlci51cGRhdGVJbnRlcnZhbDtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKGludGVydmFsKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3RpY2tlci51cGRhdGVJbnRlcnZhbCA9IGludGVydmFsO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIFdoYXQgdGhlIHNvdXJjZSBvZiB0aGUgY2xvY2sgaXMsIGVpdGhlciBcIndvcmtlclwiIChXZWIgV29ya2VyIFtkZWZhdWx0XSksIFxuXHRcdCAqICBcInRpbWVvdXRcIiAoc2V0VGltZW91dCksIG9yIFwib2ZmbGluZVwiIChub25lKS4gXG5cdFx0ICogIEB0eXBlIHtTdHJpbmd9XG5cdFx0ICogIEBtZW1iZXJPZiBUb25lLkNvbnRleHQjXG5cdFx0ICogIEBuYW1lIGNsb2NrU291cmNlXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5Db250ZXh0LnByb3RvdHlwZSwgJ2Nsb2NrU291cmNlJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fdGlja2VyLnR5cGU7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uICh0eXBlKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3RpY2tlci50eXBlID0gdHlwZTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgdHlwZSBvZiBwbGF5YmFjaywgd2hpY2ggYWZmZWN0cyB0cmFkZW9mZnMgYmV0d2VlbiBhdWRpbyBcblx0XHQgKiAgb3V0cHV0IGxhdGVuY3kgYW5kIHJlc3BvbnNpdmVuZXNzLiBcblx0XHQgKiAgXG5cdFx0ICogIEluIGFkZGl0aW9uIHRvIHNldHRpbmcgdGhlIHZhbHVlIGluIHNlY29uZHMsIHRoZSBsYXRlbmN5SGludCBhbHNvXG5cdFx0ICogIGFjY2VwdHMgdGhlIHN0cmluZ3MgXCJpbnRlcmFjdGl2ZVwiIChwcmlvcml0aXplcyBsb3cgbGF0ZW5jeSksIFxuXHRcdCAqICBcInBsYXliYWNrXCIgKHByaW9yaXRpemVzIHN1c3RhaW5lZCBwbGF5YmFjayksIFwiYmFsYW5jZWRcIiAoYmFsYW5jZXNcblx0XHQgKiAgbGF0ZW5jeSBhbmQgcGVyZm9ybWFuY2UpLCBhbmQgXCJmYXN0ZXN0XCIgKGxvd2VzdCBsYXRlbmN5LCBtaWdodCBnbGl0Y2ggbW9yZSBvZnRlbikuIFxuXHRcdCAqICBAdHlwZSB7U3RyaW5nfFNlY29uZHN9XG5cdFx0ICogIEBtZW1iZXJPZiBUb25lLkNvbnRleHQjXG5cdFx0ICogIEBuYW1lIGxhdGVuY3lIaW50XG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogLy9zZXQgdGhlIGxvb2tBaGVhZCB0byAwLjMgc2Vjb25kc1xuXHRcdCAqIFRvbmUuY29udGV4dC5sYXRlbmN5SGludCA9IDAuMztcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkNvbnRleHQucHJvdG90eXBlLCAnbGF0ZW5jeUhpbnQnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9sYXRlbmN5SGludDtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKGhpbnQpIHtcblx0ICAgICAgICAgICAgdmFyIGxvb2tBaGVhZCA9IGhpbnQ7XG5cdCAgICAgICAgICAgIHRoaXMuX2xhdGVuY3lIaW50ID0gaGludDtcblx0ICAgICAgICAgICAgaWYgKFRvbmUuaXNTdHJpbmcoaGludCkpIHtcblx0ICAgICAgICAgICAgICAgIHN3aXRjaCAoaGludCkge1xuXHQgICAgICAgICAgICAgICAgY2FzZSAnaW50ZXJhY3RpdmUnOlxuXHQgICAgICAgICAgICAgICAgICAgIGxvb2tBaGVhZCA9IDAuMTtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb250ZXh0LmxhdGVuY3lIaW50ID0gaGludDtcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgICAgIGNhc2UgJ3BsYXliYWNrJzpcblx0ICAgICAgICAgICAgICAgICAgICBsb29rQWhlYWQgPSAwLjg7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29udGV4dC5sYXRlbmN5SGludCA9IGhpbnQ7XG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgICAgICBjYXNlICdiYWxhbmNlZCc6XG5cdCAgICAgICAgICAgICAgICAgICAgbG9va0FoZWFkID0gMC4yNTtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb250ZXh0LmxhdGVuY3lIaW50ID0gaGludDtcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgICAgIGNhc2UgJ2Zhc3Rlc3QnOlxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRleHQubGF0ZW5jeUhpbnQgPSAnaW50ZXJhY3RpdmUnO1xuXHQgICAgICAgICAgICAgICAgICAgIGxvb2tBaGVhZCA9IDAuMDE7XG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdGhpcy5sb29rQWhlYWQgPSBsb29rQWhlYWQ7XG5cdCAgICAgICAgICAgIHRoaXMudXBkYXRlSW50ZXJ2YWwgPSBsb29rQWhlYWQgLyAzO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIENsZWFuIHVwXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLkNvbnRleHR9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuQ29udGV4dC5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLkNvbnRleHQuZW1pdCgnY2xvc2UnLCB0aGlzKTtcblx0ICAgICAgICBUb25lLkVtaXR0ZXIucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLl90aWNrZXIuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX3RpY2tlciA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fdGltZW91dHMuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX3RpbWVvdXRzID0gbnVsbDtcblx0ICAgICAgICBmb3IgKHZhciBjb24gaW4gdGhpcy5fY29uc3RhbnRzKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2NvbnN0YW50c1tjb25dLmRpc2Nvbm5lY3QoKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdGhpcy5fY29uc3RhbnRzID0gbnVsbDtcblx0ICAgICAgICB0aGlzLmNsb3NlKCk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogQGNsYXNzIEEgY2xhc3Mgd2hpY2ggcHJvdmlkZXMgYSByZWxpYWJsZSBjYWxsYmFjayB1c2luZyBlaXRoZXJcblx0XHQgKiAgICAgICAgYSBXZWIgV29ya2VyLCBvciBpZiB0aGF0IGlzbid0IHN1cHBvcnRlZCwgZmFsbHMgYmFjayB0byBzZXRUaW1lb3V0LlxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICB2YXIgVGlja2VyID0gZnVuY3Rpb24gKGNhbGxiYWNrLCB0eXBlLCB1cGRhdGVJbnRlcnZhbCkge1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogRWl0aGVyIFwid29ya2VyXCIgb3IgXCJ0aW1lb3V0XCJcblx0XHRcdCAqIEB0eXBlIHtTdHJpbmd9XG5cdFx0XHQgKiBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fdHlwZSA9IHR5cGU7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiBUaGUgdXBkYXRlIGludGVydmFsIG9mIHRoZSB3b3JrZXJcblx0XHRcdCAqIEBwcml2YXRlXG5cdFx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fdXBkYXRlSW50ZXJ2YWwgPSB1cGRhdGVJbnRlcnZhbDtcblx0ICAgICAgICAvKipcblx0XHRcdCAqIFRoZSBjYWxsYmFjayB0byBpbnZva2UgYXQgcmVndWxhciBpbnRlcnZhbHNcblx0XHRcdCAqIEB0eXBlIHtGdW5jdGlvbn1cblx0XHRcdCAqIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9jYWxsYmFjayA9IFRvbmUuZGVmYXVsdEFyZyhjYWxsYmFjaywgVG9uZS5ub09wKTtcblx0ICAgICAgICAvL2NyZWF0ZSB0aGUgY2xvY2sgc291cmNlIGZvciB0aGUgZmlyc3QgdGltZVxuXHQgICAgICAgIHRoaXMuX2NyZWF0ZUNsb2NrKCk7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogVGhlIHBvc3NpYmxlIHRpY2tlciB0eXBlc1xuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICogQHR5cGUge09iamVjdH1cblx0XHQgKi9cblx0ICAgIFRpY2tlci5UeXBlID0ge1xuXHQgICAgICAgIFdvcmtlcjogJ3dvcmtlcicsXG5cdCAgICAgICAgVGltZW91dDogJ3RpbWVvdXQnLFxuXHQgICAgICAgIE9mZmxpbmU6ICdvZmZsaW5lJ1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBHZW5lcmF0ZSBhIHdlYiB3b3JrZXJcblx0XHQgKiAgQHJldHVybiAge1dlYldvcmtlcn1cblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRpY2tlci5wcm90b3R5cGUuX2NyZWF0ZVdvcmtlciA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAvL1VSTCBTaGltXG5cdCAgICAgICAgd2luZG93LlVSTCA9IHdpbmRvdy5VUkwgfHwgd2luZG93LndlYmtpdFVSTDtcblx0ICAgICAgICB2YXIgYmxvYiA9IG5ldyBCbG9iKFsvL3RoZSBpbml0aWFsIHRpbWVvdXQgdGltZVxuXHQgICAgICAgICAgICAndmFyIHRpbWVvdXRUaW1lID0gJyArICh0aGlzLl91cGRhdGVJbnRlcnZhbCAqIDEwMDApLnRvRml4ZWQoMSkgKyAnOycgKyAvL29ubWVzc2FnZSBjYWxsYmFja1xuXHQgICAgICAgICAgICAnc2VsZi5vbm1lc3NhZ2UgPSBmdW5jdGlvbihtc2cpeycgKyAnXFx0dGltZW91dFRpbWUgPSBwYXJzZUludChtc2cuZGF0YSk7JyArICd9OycgKyAvL3RoZSB0aWNrIGZ1bmN0aW9uIHdoaWNoIHBvc3RzIGEgbWVzc2FnZVxuXHQgICAgICAgICAgICAvL2FuZCBzY2hlZHVsZXMgYSBuZXcgdGlja1xuXHQgICAgICAgICAgICAnZnVuY3Rpb24gdGljaygpeycgKyAnXFx0c2V0VGltZW91dCh0aWNrLCB0aW1lb3V0VGltZSk7JyArICdcXHRzZWxmLnBvc3RNZXNzYWdlKFxcJ3RpY2tcXCcpOycgKyAnfScgKyAvL2NhbGwgdGljayBpbml0aWFsbHlcblx0ICAgICAgICAgICAgJ3RpY2soKTsnXSk7XG5cdCAgICAgICAgdmFyIGJsb2JVcmwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuXHQgICAgICAgIHZhciB3b3JrZXIgPSBuZXcgV29ya2VyKGJsb2JVcmwpO1xuXHQgICAgICAgIHdvcmtlci5vbm1lc3NhZ2UgPSB0aGlzLl9jYWxsYmFjay5iaW5kKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuX3dvcmtlciA9IHdvcmtlcjtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiBDcmVhdGUgYSB0aW1lb3V0IGxvb3Bcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVGlja2VyLnByb3RvdHlwZS5fY3JlYXRlVGltZW91dCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB0aGlzLl90aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2NyZWF0ZVRpbWVvdXQoKTtcblx0ICAgICAgICAgICAgdGhpcy5fY2FsbGJhY2soKTtcblx0ICAgICAgICB9LmJpbmQodGhpcyksIHRoaXMuX3VwZGF0ZUludGVydmFsICogMTAwMCk7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogQ3JlYXRlIHRoZSBjbG9jayBzb3VyY2UuXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRpY2tlci5wcm90b3R5cGUuX2NyZWF0ZUNsb2NrID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIGlmICh0aGlzLl90eXBlID09PSBUaWNrZXIuVHlwZS5Xb3JrZXIpIHtcblx0ICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX2NyZWF0ZVdvcmtlcigpO1xuXHQgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG5cdCAgICAgICAgICAgICAgICAvLyB3b3JrZXJzIG5vdCBzdXBwb3J0ZWQsIGZhbGxiYWNrIHRvIHRpbWVvdXRcblx0ICAgICAgICAgICAgICAgIHRoaXMuX3R5cGUgPSBUaWNrZXIuVHlwZS5UaW1lb3V0O1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fY3JlYXRlQ2xvY2soKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0gZWxzZSBpZiAodGhpcy5fdHlwZSA9PT0gVGlja2VyLlR5cGUuVGltZW91dCkge1xuXHQgICAgICAgICAgICB0aGlzLl9jcmVhdGVUaW1lb3V0KCk7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqIEBtZW1iZXJPZiBUaWNrZXIjXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKiBAbmFtZSB1cGRhdGVJbnRlcnZhbFxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVGlja2VyLnByb3RvdHlwZSwgJ3VwZGF0ZUludGVydmFsJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fdXBkYXRlSW50ZXJ2YWw7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChpbnRlcnZhbCkge1xuXHQgICAgICAgICAgICB0aGlzLl91cGRhdGVJbnRlcnZhbCA9IE1hdGgubWF4KGludGVydmFsLCAxMjggLyA0NDEwMCk7XG5cdCAgICAgICAgICAgIGlmICh0aGlzLl90eXBlID09PSBUaWNrZXIuVHlwZS5Xb3JrZXIpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX3dvcmtlci5wb3N0TWVzc2FnZShNYXRoLm1heChpbnRlcnZhbCAqIDEwMDAsIDEpKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogVGhlIHR5cGUgb2YgdGhlIHRpY2tlciwgZWl0aGVyIGEgd29ya2VyIG9yIGEgdGltZW91dFxuXHRcdCAqIEBtZW1iZXJPZiBUaWNrZXIjXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKiBAbmFtZSB0eXBlXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUaWNrZXIucHJvdG90eXBlLCAndHlwZScsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3R5cGU7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uICh0eXBlKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2Rpc3Bvc2VDbG9jaygpO1xuXHQgICAgICAgICAgICB0aGlzLl90eXBlID0gdHlwZTtcblx0ICAgICAgICAgICAgdGhpcy5fY3JlYXRlQ2xvY2soKTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqIENsZWFuIHVwIHRoZSBjdXJyZW50IGNsb2NrIHNvdXJjZVxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUaWNrZXIucHJvdG90eXBlLl9kaXNwb3NlQ2xvY2sgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgaWYgKHRoaXMuX3RpbWVvdXQpIHtcblx0ICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVvdXQpO1xuXHQgICAgICAgICAgICB0aGlzLl90aW1lb3V0ID0gbnVsbDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKHRoaXMuX3dvcmtlcikge1xuXHQgICAgICAgICAgICB0aGlzLl93b3JrZXIudGVybWluYXRlKCk7XG5cdCAgICAgICAgICAgIHRoaXMuX3dvcmtlci5vbm1lc3NhZ2UgPSBudWxsO1xuXHQgICAgICAgICAgICB0aGlzLl93b3JrZXIgPSBudWxsO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiBDbGVhbiB1cFxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUaWNrZXIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdGhpcy5fZGlzcG9zZUNsb2NrKCk7XG5cdCAgICAgICAgdGhpcy5fY2FsbGJhY2sgPSBudWxsO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBTaGltIGFsbCBjb25uZWN0L2Rpc2Nvbm5lY3QgYW5kIHNvbWUgZGVwcmVjYXRlZCBtZXRob2RzIHdoaWNoIGFyZSBzdGlsbCBpblxuXHRcdCAqICBzb21lIG9sZGVyIGltcGxlbWVudGF0aW9ucy5cblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuZ2V0Q29udGV4dChmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIG5hdGl2ZUNvbm5lY3QgPSBBdWRpb05vZGUucHJvdG90eXBlLmNvbm5lY3Q7XG5cdCAgICAgICAgdmFyIG5hdGl2ZURpc2Nvbm5lY3QgPSBBdWRpb05vZGUucHJvdG90eXBlLmRpc2Nvbm5lY3Q7XG5cdCAgICAgICAgLy9yZXBsYWNlIHRoZSBvbGQgY29ubmVjdCBtZXRob2Rcblx0ICAgICAgICBmdW5jdGlvbiB0b25lQ29ubmVjdChCLCBvdXROdW0sIGluTnVtKSB7XG5cdCAgICAgICAgICAgIGlmIChCLmlucHV0KSB7XG5cdCAgICAgICAgICAgICAgICBpbk51bSA9IFRvbmUuZGVmYXVsdEFyZyhpbk51bSwgMCk7XG5cdCAgICAgICAgICAgICAgICBpZiAoVG9uZS5pc0FycmF5KEIuaW5wdXQpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0KEIuaW5wdXRbaW5OdW1dKTtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0KEIuaW5wdXQsIG91dE51bSwgaW5OdW0pO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoQiBpbnN0YW5jZW9mIEF1ZGlvTm9kZSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBuYXRpdmVDb25uZWN0LmNhbGwodGhpcywgQiwgb3V0TnVtLCBpbk51bSk7XG5cdCAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbmF0aXZlQ29ubmVjdC5jYWxsKHRoaXMsIEIsIG91dE51bSk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZXJyb3IgY29ubmVjdGluZyB0byBub2RlOiAnICsgQiArICdcXG4nICsgZSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgLy9yZXBsYWNlIHRoZSBvbGQgZGlzY29ubmVjdCBtZXRob2Rcblx0ICAgICAgICBmdW5jdGlvbiB0b25lRGlzY29ubmVjdChCLCBvdXROdW0sIGluTnVtKSB7XG5cdCAgICAgICAgICAgIGlmIChCICYmIEIuaW5wdXQgJiYgVG9uZS5pc0FycmF5KEIuaW5wdXQpKSB7XG5cdCAgICAgICAgICAgICAgICBpbk51bSA9IFRvbmUuZGVmYXVsdEFyZyhpbk51bSwgMCk7XG5cdCAgICAgICAgICAgICAgICB0aGlzLmRpc2Nvbm5lY3QoQi5pbnB1dFtpbk51bV0sIG91dE51bSwgMCk7XG5cdCAgICAgICAgICAgIH0gZWxzZSBpZiAoQiAmJiBCLmlucHV0KSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLmRpc2Nvbm5lY3QoQi5pbnB1dCwgb3V0TnVtLCBpbk51bSk7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgICAgIG5hdGl2ZURpc2Nvbm5lY3QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0ICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcblx0ICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Vycm9yIGRpc2Nvbm5lY3Rpbmcgbm9kZTogJyArIEIgKyAnXFxuJyArIGUpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmIChBdWRpb05vZGUucHJvdG90eXBlLmNvbm5lY3QgIT09IHRvbmVDb25uZWN0KSB7XG5cdCAgICAgICAgICAgIEF1ZGlvTm9kZS5wcm90b3R5cGUuY29ubmVjdCA9IHRvbmVDb25uZWN0O1xuXHQgICAgICAgICAgICBBdWRpb05vZGUucHJvdG90eXBlLmRpc2Nvbm5lY3QgPSB0b25lRGlzY29ubmVjdDtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8vIHNldCB0aGUgYXVkaW8gY29udGV4dCBpbml0aWFsbHlcblx0ICAgIGlmIChUb25lLnN1cHBvcnRlZCkge1xuXHQgICAgICAgIFRvbmUuY29udGV4dCA9IG5ldyBUb25lLkNvbnRleHQoKTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgICAgY29uc29sZS53YXJuKCdUaGlzIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCBUb25lLmpzJyk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gVG9uZS5Db250ZXh0O1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzIFRvbmUuQXVkaW9Ob2RlIGlzIGEgYmFzZSBjbGFzcyBmb3IgY2xhc3NlcyB3aGljaCBwcm9jZXNzIGF1ZGlvLlxuXHRcdCAqICAgICAgICAgQXVkaW9Ob2RlcyBoYXZlIGlucHV0cyBhbmQgb3V0cHV0cy5cblx0XHQgKiAgQHBhcmFtXHR7QXVkaW9Db250ZXh0PX0gY29udGV4dFx0VGhlIGF1ZGlvIGNvbnRleHQgdG8gdXNlIHdpdGggdGhlIGNsYXNzXG5cdFx0ICogIEBleHRlbmRzIHtUb25lfVxuXHRcdCAqL1xuXHQgICAgVG9uZS5BdWRpb05vZGUgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIC8vdXNlIHRoZSBkZWZhdWx0IGNvbnRleHQgaWYgb25lIGlzIG5vdCBwYXNzZWQgaW5cblx0ICAgICAgICB2YXIgb3B0aW9ucyA9IFRvbmUuZGVmYXVsdHMoYXJndW1lbnRzLCBbJ2NvbnRleHQnXSwgeyAnY29udGV4dCc6IFRvbmUuY29udGV4dCB9KTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqIFRoZSBBdWRpb0NvbnRleHQgb2YgdGhpcyBpbnN0YW5jZVxuXHRcdFx0ICogQHByaXZhdGVcblx0XHRcdCAqIEB0eXBlIHtBdWRpb0NvbnRleHR9XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9jb250ZXh0ID0gb3B0aW9ucy5jb250ZXh0O1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuQXVkaW9Ob2RlKTtcblx0ICAgIC8qKlxuXHRcdCAqIEdldCB0aGUgYXVkaW8gY29udGV4dCBiZWxvbmdpbmcgdG8gdGhpcyBpbnN0YW5jZS5cblx0XHQgKiBAdHlwZSB7QXVkaW9Ob2RlfVxuXHRcdCAqIEBtZW1iZXJPZiBUb25lLkF1ZGlvTm9kZSNcblx0XHQgKiBAbmFtZSBjb250ZXh0XG5cdFx0ICogQHJlYWRPbmx5XG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5BdWRpb05vZGUucHJvdG90eXBlLCAnY29udGV4dCcsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRleHQ7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgQ3JlYXRlIGlucHV0IGFuZCBvdXRwdXRzIGZvciB0aGlzIG9iamVjdC5cblx0XHQgKiAgQHBhcmFtICB7TnVtYmVyfSAgW2lucHV0PTBdICAgVGhlIG51bWJlciBvZiBpbnB1dHNcblx0XHQgKiAgQHBhcmFtICB7TnVtYmVyfSAgW291dHB1dHM9MF0gIFRoZSBudW1iZXIgb2Ygb3V0cHV0c1xuXHRcdCAqICBAcmV0dXJuICB7VG9uZS5BdWRpb05vZGV9ICB0aGlzXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLkF1ZGlvTm9kZS5wcm90b3R5cGUuY3JlYXRlSW5zT3V0cyA9IGZ1bmN0aW9uIChpbnB1dHMsIG91dHB1dHMpIHtcblx0ICAgICAgICBpZiAoaW5wdXRzID09PSAxKSB7XG5cdCAgICAgICAgICAgIHRoaXMuaW5wdXQgPSB0aGlzLmNvbnRleHQuY3JlYXRlR2FpbigpO1xuXHQgICAgICAgIH0gZWxzZSBpZiAoaW5wdXRzID4gMSkge1xuXHQgICAgICAgICAgICB0aGlzLmlucHV0ID0gbmV3IEFycmF5KGlucHV0cyk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmIChvdXRwdXRzID09PSAxKSB7XG5cdCAgICAgICAgICAgIHRoaXMub3V0cHV0ID0gdGhpcy5jb250ZXh0LmNyZWF0ZUdhaW4oKTtcblx0ICAgICAgICB9IGVsc2UgaWYgKG91dHB1dHMgPiAxKSB7XG5cdCAgICAgICAgICAgIHRoaXMub3V0cHV0ID0gbmV3IEFycmF5KG91dHB1dHMpO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgVGhlIG51bWJlciBvZiBpbnB1dHMgZmVlZGluZyBpbnRvIHRoZSBBdWRpb05vZGUuXG5cdFx0ICogIEZvciBzb3VyY2Ugbm9kZXMsIHRoaXMgd2lsbCBiZSAwLlxuXHRcdCAqICBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqICBAbmFtZSBudW1iZXJPZklucHV0c1xuXHRcdCAqICBAcmVhZE9ubHlcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkF1ZGlvTm9kZS5wcm90b3R5cGUsICdudW1iZXJPZklucHV0cycsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgaWYgKHRoaXMuaW5wdXQpIHtcblx0ICAgICAgICAgICAgICAgIGlmIChUb25lLmlzQXJyYXkodGhpcy5pbnB1dCkpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pbnB1dC5sZW5ndGg7XG5cdCAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiAxO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIDA7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgbnVtYmVyIG9mIG91dHB1dHMgY29taW5nIG91dCBvZiB0aGUgQXVkaW9Ob2RlLlxuXHRcdCAqICBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqICBAbmFtZSBudW1iZXJPZk91dHB1dHNcblx0XHQgKiAgQHJlYWRPbmx5XG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5BdWRpb05vZGUucHJvdG90eXBlLCAnbnVtYmVyT2ZPdXRwdXRzJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICBpZiAodGhpcy5vdXRwdXQpIHtcblx0ICAgICAgICAgICAgICAgIGlmIChUb25lLmlzQXJyYXkodGhpcy5vdXRwdXQpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub3V0cHV0Lmxlbmd0aDtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDE7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gMDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIGNvbm5lY3QgdGhlIG91dHB1dCBvZiBhIFRvbmVOb2RlIHRvIGFuIEF1ZGlvUGFyYW0sIEF1ZGlvTm9kZSwgb3IgVG9uZU5vZGVcblx0XHQgKiAgQHBhcmFtICB7VG9uZSB8IEF1ZGlvUGFyYW0gfCBBdWRpb05vZGV9IHVuaXRcblx0XHQgKiAgQHBhcmFtIHtudW1iZXJ9IFtvdXRwdXROdW09MF0gb3B0aW9uYWxseSB3aGljaCBvdXRwdXQgdG8gY29ubmVjdCBmcm9tXG5cdFx0ICogIEBwYXJhbSB7bnVtYmVyfSBbaW5wdXROdW09MF0gb3B0aW9uYWxseSB3aGljaCBpbnB1dCB0byBjb25uZWN0IHRvXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLkF1ZGlvTm9kZX0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5BdWRpb05vZGUucHJvdG90eXBlLmNvbm5lY3QgPSBmdW5jdGlvbiAodW5pdCwgb3V0cHV0TnVtLCBpbnB1dE51bSkge1xuXHQgICAgICAgIGlmIChUb25lLmlzQXJyYXkodGhpcy5vdXRwdXQpKSB7XG5cdCAgICAgICAgICAgIG91dHB1dE51bSA9IFRvbmUuZGVmYXVsdEFyZyhvdXRwdXROdW0sIDApO1xuXHQgICAgICAgICAgICB0aGlzLm91dHB1dFtvdXRwdXROdW1dLmNvbm5lY3QodW5pdCwgMCwgaW5wdXROdW0pO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIHRoaXMub3V0cHV0LmNvbm5lY3QodW5pdCwgb3V0cHV0TnVtLCBpbnB1dE51bSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBkaXNjb25uZWN0IHRoZSBvdXRwdXRcblx0XHQgKiAgQHBhcmFtIHtOdW1iZXJ8QXVkaW9Ob2RlfSBvdXRwdXQgRWl0aGVyIHRoZSBvdXRwdXQgaW5kZXggdG8gZGlzY29ubmVjdFxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiB0aGUgb3V0cHV0IGlzIGFuIGFycmF5LCBvciB0aGVcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSB0byBkaXNjb25uZWN0IGZyb20uXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLkF1ZGlvTm9kZX0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5BdWRpb05vZGUucHJvdG90eXBlLmRpc2Nvbm5lY3QgPSBmdW5jdGlvbiAoZGVzdGluYXRpb24sIG91dHB1dE51bSwgaW5wdXROdW0pIHtcblx0ICAgICAgICBpZiAoVG9uZS5pc0FycmF5KHRoaXMub3V0cHV0KSkge1xuXHQgICAgICAgICAgICBpZiAoVG9uZS5pc051bWJlcihkZXN0aW5hdGlvbikpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMub3V0cHV0W2Rlc3RpbmF0aW9uXS5kaXNjb25uZWN0KCk7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICBvdXRwdXROdW0gPSBUb25lLmRlZmF1bHRBcmcob3V0cHV0TnVtLCAwKTtcblx0ICAgICAgICAgICAgICAgIHRoaXMub3V0cHV0W291dHB1dE51bV0uZGlzY29ubmVjdChkZXN0aW5hdGlvbiwgMCwgaW5wdXROdW0pO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgdGhpcy5vdXRwdXQuZGlzY29ubmVjdC5hcHBseSh0aGlzLm91dHB1dCwgYXJndW1lbnRzKTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIENvbm5lY3QgdGhlIG91dHB1dCBvZiB0aGlzIG5vZGUgdG8gdGhlIHJlc3Qgb2YgdGhlIG5vZGVzIGluIHNlcmllcy5cblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgLy9jb25uZWN0IGEgbm9kZSB0byBhbiBlZmZlY3QsIHBhblZvbCBhbmQgdGhlbiB0byB0aGUgbWFzdGVyIG91dHB1dFxuXHRcdCAqICBub2RlLmNoYWluKGVmZmVjdCwgcGFuVm9sLCBUb25lLk1hc3Rlcik7XG5cdFx0ICogIEBwYXJhbSB7Li4uQXVkaW9QYXJhbXxUb25lfEF1ZGlvTm9kZX0gbm9kZXNcblx0XHQgKiAgQHJldHVybnMge1RvbmUuQXVkaW9Ob2RlfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkF1ZGlvTm9kZS5wcm90b3R5cGUuY2hhaW4gPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIGN1cnJlbnRVbml0ID0gdGhpcztcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICB2YXIgdG9Vbml0ID0gYXJndW1lbnRzW2ldO1xuXHQgICAgICAgICAgICBjdXJyZW50VW5pdC5jb25uZWN0KHRvVW5pdCk7XG5cdCAgICAgICAgICAgIGN1cnJlbnRVbml0ID0gdG9Vbml0O1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgY29ubmVjdCB0aGUgb3V0cHV0IG9mIHRoaXMgbm9kZSB0byB0aGUgcmVzdCBvZiB0aGUgbm9kZXMgaW4gcGFyYWxsZWwuXG5cdFx0ICogIEBwYXJhbSB7Li4uQXVkaW9QYXJhbXxUb25lfEF1ZGlvTm9kZX0gbm9kZXNcblx0XHQgKiAgQHJldHVybnMge1RvbmUuQXVkaW9Ob2RlfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkF1ZGlvTm9kZS5wcm90b3R5cGUuZmFuID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgIHRoaXMuY29ubmVjdChhcmd1bWVudHNbaV0pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICBpZiAod2luZG93LkF1ZGlvTm9kZSkge1xuXHQgICAgICAgIC8vZ2l2ZSBuYXRpdmUgbm9kZXMgY2hhaW4gYW5kIGZhbiBtZXRob2RzXG5cdCAgICAgICAgQXVkaW9Ob2RlLnByb3RvdHlwZS5jaGFpbiA9IFRvbmUuQXVkaW9Ob2RlLnByb3RvdHlwZS5jaGFpbjtcblx0ICAgICAgICBBdWRpb05vZGUucHJvdG90eXBlLmZhbiA9IFRvbmUuQXVkaW9Ob2RlLnByb3RvdHlwZS5mYW47XG5cdCAgICB9XG5cdCAgICAvKipcblx0XHQgKiBEaXNwb3NlIGFuZCBkaXNjb25uZWN0XG5cdFx0ICogQHJldHVybiB7VG9uZS5BdWRpb05vZGV9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuQXVkaW9Ob2RlLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIGlmICghVG9uZS5pc1VuZGVmKHRoaXMuaW5wdXQpKSB7XG5cdCAgICAgICAgICAgIGlmICh0aGlzLmlucHV0IGluc3RhbmNlb2YgQXVkaW9Ob2RlKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLmlucHV0LmRpc2Nvbm5lY3QoKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB0aGlzLmlucHV0ID0gbnVsbDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKCFUb25lLmlzVW5kZWYodGhpcy5vdXRwdXQpKSB7XG5cdCAgICAgICAgICAgIGlmICh0aGlzLm91dHB1dCBpbnN0YW5jZW9mIEF1ZGlvTm9kZSkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5vdXRwdXQuZGlzY29ubmVjdCgpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHRoaXMub3V0cHV0ID0gbnVsbDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdGhpcy5fY29udGV4dCA9IG51bGw7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuQXVkaW9Ob2RlO1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgIEJhc2UgY2xhc3MgZm9yIGFsbCBTaWduYWxzLiBVc2VkIEludGVybmFsbHkuXG5cdFx0ICpcblx0XHQgKiAgQGNvbnN0cnVjdG9yXG5cdFx0ICogIEBleHRlbmRzIHtUb25lfVxuXHRcdCAqL1xuXHQgICAgVG9uZS5TaWduYWxCYXNlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuQXVkaW9Ob2RlLmNhbGwodGhpcyk7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5TaWduYWxCYXNlLCBUb25lLkF1ZGlvTm9kZSk7XG5cdCAgICAvKipcblx0XHQgKiAgV2hlbiBzaWduYWxzIGNvbm5lY3QgdG8gb3RoZXIgc2lnbmFscyBvciBBdWRpb1BhcmFtcyxcblx0XHQgKiAgdGhleSB0YWtlIG92ZXIgdGhlIG91dHB1dCB2YWx1ZSBvZiB0aGF0IHNpZ25hbCBvciBBdWRpb1BhcmFtLlxuXHRcdCAqICBGb3IgYWxsIG90aGVyIG5vZGVzLCB0aGUgYmVoYXZpb3IgaXMgdGhlIHNhbWUgYXMgYSBkZWZhdWx0IDxjb2RlPmNvbm5lY3Q8L2NvZGU+LlxuXHRcdCAqXG5cdFx0ICogIEBvdmVycmlkZVxuXHRcdCAqICBAcGFyYW0ge0F1ZGlvUGFyYW18QXVkaW9Ob2RlfFRvbmUuU2lnbmFsfFRvbmV9IG5vZGVcblx0XHQgKiAgQHBhcmFtIHtudW1iZXJ9IFtvdXRwdXROdW1iZXI9MF0gVGhlIG91dHB1dCBudW1iZXIgdG8gY29ubmVjdCBmcm9tLlxuXHRcdCAqICBAcGFyYW0ge251bWJlcn0gW2lucHV0TnVtYmVyPTBdIFRoZSBpbnB1dCBudW1iZXIgdG8gY29ubmVjdCB0by5cblx0XHQgKiAgQHJldHVybnMge1RvbmUuU2lnbmFsQmFzZX0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5TaWduYWxCYXNlLnByb3RvdHlwZS5jb25uZWN0ID0gZnVuY3Rpb24gKG5vZGUsIG91dHB1dE51bWJlciwgaW5wdXROdW1iZXIpIHtcblx0ICAgICAgICAvL3plcm8gaXQgb3V0IHNvIHRoYXQgdGhlIHNpZ25hbCBjYW4gaGF2ZSBmdWxsIGNvbnRyb2xcblx0ICAgICAgICBpZiAoVG9uZS5TaWduYWwgJiYgVG9uZS5TaWduYWwgPT09IG5vZGUuY29uc3RydWN0b3IgfHwgVG9uZS5QYXJhbSAmJiBUb25lLlBhcmFtID09PSBub2RlLmNvbnN0cnVjdG9yIHx8IFRvbmUuVGltZWxpbmVTaWduYWwgJiYgVG9uZS5UaW1lbGluZVNpZ25hbCA9PT0gbm9kZS5jb25zdHJ1Y3Rvcikge1xuXHQgICAgICAgICAgICAvL2NhbmNlbCBjaGFuZ2VzXG5cdCAgICAgICAgICAgIG5vZGUuX3BhcmFtLmNhbmNlbFNjaGVkdWxlZFZhbHVlcygwKTtcblx0ICAgICAgICAgICAgLy9yZXNldCB0aGUgdmFsdWVcblx0ICAgICAgICAgICAgbm9kZS5fcGFyYW0udmFsdWUgPSAwO1xuXHQgICAgICAgICAgICAvL21hcmsgdGhlIHZhbHVlIGFzIG92ZXJyaWRkZW5cblx0ICAgICAgICAgICAgbm9kZS5vdmVycmlkZGVuID0gdHJ1ZTtcblx0ICAgICAgICB9IGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBBdWRpb1BhcmFtKSB7XG5cdCAgICAgICAgICAgIG5vZGUuY2FuY2VsU2NoZWR1bGVkVmFsdWVzKDApO1xuXHQgICAgICAgICAgICBub2RlLnZhbHVlID0gMDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgVG9uZS5BdWRpb05vZGUucHJvdG90eXBlLmNvbm5lY3QuY2FsbCh0aGlzLCBub2RlLCBvdXRwdXROdW1iZXIsIGlucHV0TnVtYmVyKTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVG9uZS5TaWduYWxCYXNlO1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgV3JhcHMgdGhlIG5hdGl2ZSBXZWIgQXVkaW8gQVBJIFxuXHRcdCAqICAgICAgICAgW1dhdmVTaGFwZXJOb2RlXShodHRwOi8vd2ViYXVkaW8uZ2l0aHViLmlvL3dlYi1hdWRpby1hcGkvI3RoZS13YXZlc2hhcGVybm9kZS1pbnRlcmZhY2UpLlxuXHRcdCAqXG5cdFx0ICogIEBleHRlbmRzIHtUb25lLlNpZ25hbEJhc2V9XG5cdFx0ICogIEBjb25zdHJ1Y3RvclxuXHRcdCAqICBAcGFyYW0ge2Z1bmN0aW9ufEFycmF5fE51bWJlcn0gbWFwcGluZyBUaGUgZnVuY3Rpb24gdXNlZCB0byBkZWZpbmUgdGhlIHZhbHVlcy4gXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgbWFwcGluZyBmdW5jdGlvbiBzaG91bGQgdGFrZSB0d28gYXJndW1lbnRzOiBcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSBmaXJzdCBpcyB0aGUgdmFsdWUgYXQgdGhlIGN1cnJlbnQgcG9zaXRpb24gXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmQgdGhlIHNlY29uZCBpcyB0aGUgYXJyYXkgcG9zaXRpb24uIFxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSWYgdGhlIGFyZ3VtZW50IGlzIGFuIGFycmF5LCB0aGF0IGFycmF5IHdpbGwgYmVcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldCBhcyB0aGUgd2F2ZSBzaGFwaW5nIGZ1bmN0aW9uLiBUaGUgaW5wdXRcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpZ25hbCBpcyBhbiBBdWRpb1JhbmdlIFstMSwgMV0gdmFsdWUgYW5kIHRoZSBvdXRwdXRcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpZ25hbCBjYW4gdGFrZSBvbiBhbnkgbnVtZXJpY2FsIHZhbHVlcy4gXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcblx0XHQgKiAgQHBhcmFtIHtOdW1iZXJ9IFtidWZmZXJMZW49MTAyNF0gVGhlIGxlbmd0aCBvZiB0aGUgV2F2ZVNoYXBlck5vZGUgYnVmZmVyLlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIHZhciB0aW1lc1R3byA9IG5ldyBUb25lLldhdmVTaGFwZXIoZnVuY3Rpb24odmFsKXtcblx0XHQgKiBcdHJldHVybiB2YWwgKiAyO1xuXHRcdCAqIH0sIDIwNDgpO1xuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIC8vYSB3YXZlc2hhcGVyIGNhbiBhbHNvIGJlIGNvbnN0cnVjdGVkIHdpdGggYW4gYXJyYXkgb2YgdmFsdWVzXG5cdFx0ICogdmFyIGludmVydCA9IG5ldyBUb25lLldhdmVTaGFwZXIoWzEsIC0xXSk7XG5cdFx0ICovXG5cdCAgICBUb25lLldhdmVTaGFwZXIgPSBmdW5jdGlvbiAobWFwcGluZywgYnVmZmVyTGVuKSB7XG5cdCAgICAgICAgVG9uZS5TaWduYWxCYXNlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgdGhlIHdhdmVzaGFwZXJcblx0XHRcdCAqICBAdHlwZSB7V2F2ZVNoYXBlck5vZGV9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX3NoYXBlciA9IHRoaXMuaW5wdXQgPSB0aGlzLm91dHB1dCA9IHRoaXMuY29udGV4dC5jcmVhdGVXYXZlU2hhcGVyKCk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgdGhlIHdhdmVzaGFwZXJzIGN1cnZlXG5cdFx0XHQgKiAgQHR5cGUge0Zsb2F0MzJBcnJheX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fY3VydmUgPSBudWxsO1xuXHQgICAgICAgIGlmIChBcnJheS5pc0FycmF5KG1hcHBpbmcpKSB7XG5cdCAgICAgICAgICAgIHRoaXMuY3VydmUgPSBtYXBwaW5nO1xuXHQgICAgICAgIH0gZWxzZSBpZiAoaXNGaW5pdGUobWFwcGluZykgfHwgVG9uZS5pc1VuZGVmKG1hcHBpbmcpKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2N1cnZlID0gbmV3IEZsb2F0MzJBcnJheShUb25lLmRlZmF1bHRBcmcobWFwcGluZywgMTAyNCkpO1xuXHQgICAgICAgIH0gZWxzZSBpZiAoVG9uZS5pc0Z1bmN0aW9uKG1hcHBpbmcpKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2N1cnZlID0gbmV3IEZsb2F0MzJBcnJheShUb25lLmRlZmF1bHRBcmcoYnVmZmVyTGVuLCAxMDI0KSk7XG5cdCAgICAgICAgICAgIHRoaXMuc2V0TWFwKG1hcHBpbmcpO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLldhdmVTaGFwZXIsIFRvbmUuU2lnbmFsQmFzZSk7XG5cdCAgICAvKipcblx0XHQgKiAgVXNlcyBhIG1hcHBpbmcgZnVuY3Rpb24gdG8gc2V0IHRoZSB2YWx1ZSBvZiB0aGUgY3VydmUuIFxuXHRcdCAqICBAcGFyYW0ge2Z1bmN0aW9ufSBtYXBwaW5nIFRoZSBmdW5jdGlvbiB1c2VkIHRvIGRlZmluZSB0aGUgdmFsdWVzLiBcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgbWFwcGluZyBmdW5jdGlvbiB0YWtlIHR3byBhcmd1bWVudHM6IFxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSBmaXJzdCBpcyB0aGUgdmFsdWUgYXQgdGhlIGN1cnJlbnQgcG9zaXRpb24gXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpY2ggZ29lcyBmcm9tIC0xIHRvIDEgb3ZlciB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgaW4gdGhlIGN1cnZlIGFycmF5LiBUaGUgc2Vjb25kIGFyZ3VtZW50IGlzIHRoZSBhcnJheSBwb3NpdGlvbi4gXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLldhdmVTaGFwZXJ9IHRoaXNcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAvL21hcCB0aGUgaW5wdXQgc2lnbmFsIGZyb20gWy0xLCAxXSB0byBbMCwgMTBdXG5cdFx0ICogc2hhcGVyLnNldE1hcChmdW5jdGlvbih2YWwsIGluZGV4KXtcblx0XHQgKiBcdHJldHVybiAodmFsICsgMSkgKiA1O1xuXHRcdCAqIH0pXG5cdFx0ICovXG5cdCAgICBUb25lLldhdmVTaGFwZXIucHJvdG90eXBlLnNldE1hcCA9IGZ1bmN0aW9uIChtYXBwaW5nKSB7XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuX2N1cnZlLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdCAgICAgICAgICAgIHZhciBub3JtYWxpemVkID0gaSAvIChsZW4gLSAxKSAqIDIgLSAxO1xuXHQgICAgICAgICAgICB0aGlzLl9jdXJ2ZVtpXSA9IG1hcHBpbmcobm9ybWFsaXplZCwgaSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHRoaXMuX3NoYXBlci5jdXJ2ZSA9IHRoaXMuX2N1cnZlO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqIFRoZSBhcnJheSB0byBzZXQgYXMgdGhlIHdhdmVzaGFwZXIgY3VydmUuIEZvciBsaW5lYXIgY3VydmVzXG5cdFx0ICogYXJyYXkgbGVuZ3RoIGRvZXMgbm90IG1ha2UgbXVjaCBkaWZmZXJlbmNlLCBidXQgZm9yIGNvbXBsZXggY3VydmVzXG5cdFx0ICogbG9uZ2VyIGFycmF5cyB3aWxsIHByb3ZpZGUgc21vb3RoZXIgaW50ZXJwb2xhdGlvbi4gXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuV2F2ZVNoYXBlciNcblx0XHQgKiBAdHlwZSB7QXJyYXl9XG5cdFx0ICogQG5hbWUgY3VydmVcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLldhdmVTaGFwZXIucHJvdG90eXBlLCAnY3VydmUnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9zaGFwZXIuY3VydmU7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChtYXBwaW5nKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2N1cnZlID0gbmV3IEZsb2F0MzJBcnJheShtYXBwaW5nKTtcblx0ICAgICAgICAgICAgdGhpcy5fc2hhcGVyLmN1cnZlID0gdGhpcy5fY3VydmU7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiBTcGVjaWZpZXMgd2hhdCB0eXBlIG9mIG92ZXJzYW1wbGluZyAoaWYgYW55KSBzaG91bGQgYmUgdXNlZCB3aGVuIFxuXHRcdCAqIGFwcGx5aW5nIHRoZSBzaGFwaW5nIGN1cnZlLiBDYW4gZWl0aGVyIGJlIFwibm9uZVwiLCBcIjJ4XCIgb3IgXCI0eFwiLiBcblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5XYXZlU2hhcGVyI1xuXHRcdCAqIEB0eXBlIHtzdHJpbmd9XG5cdFx0ICogQG5hbWUgb3ZlcnNhbXBsZVxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuV2F2ZVNoYXBlci5wcm90b3R5cGUsICdvdmVyc2FtcGxlJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fc2hhcGVyLm92ZXJzYW1wbGU7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChvdmVyc2FtcGxpbmcpIHtcblx0ICAgICAgICAgICAgaWYgKFtcblx0ICAgICAgICAgICAgICAgICAgICAnbm9uZScsXG5cdCAgICAgICAgICAgICAgICAgICAgJzJ4Jyxcblx0ICAgICAgICAgICAgICAgICAgICAnNHgnXG5cdCAgICAgICAgICAgICAgICBdLmluZGV4T2Yob3ZlcnNhbXBsaW5nKSAhPT0gLTEpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX3NoYXBlci5vdmVyc2FtcGxlID0gb3ZlcnNhbXBsaW5nO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RvbmUuV2F2ZVNoYXBlcjogb3ZlcnNhbXBsaW5nIG11c3QgYmUgZWl0aGVyIFxcJ25vbmVcXCcsIFxcJzJ4XFwnLCBvciBcXCc0eFxcJycpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgQ2xlYW4gdXAuXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLldhdmVTaGFwZXJ9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuV2F2ZVNoYXBlci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLlNpZ25hbEJhc2UucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLl9zaGFwZXIuZGlzY29ubmVjdCgpO1xuXHQgICAgICAgIHRoaXMuX3NoYXBlciA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fY3VydmUgPSBudWxsO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLldhdmVTaGFwZXI7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgVG9uZS5UaW1lQmFzZSBpcyBhIGZsZXhpYmxlIGVuY29kaW5nIG9mIHRpbWVcblx0XHQgKiAgICAgICAgIHdoaWNoIGNhbiBiZSBldmFsdWF0ZWQgdG8gYW5kIGZyb20gYSBzdHJpbmcuXG5cdFx0ICogICAgICAgICBQYXJzaW5nIGNvZGUgbW9kaWZpZWQgZnJvbSBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL3RhcGRpZ2l0L1xuXHRcdCAqICAgICAgICAgQ29weXJpZ2h0IDIwMTEgMjAxMiBBcml5YSBIaWRheWF0LCBOZXcgQlNEIExpY2Vuc2Vcblx0XHQgKiAgQGV4dGVuZHMge1RvbmV9XG5cdFx0ICogIEBwYXJhbSAge1RpbWV9ICB2YWwgICAgVGhlIHRpbWUgdmFsdWUgYXMgYSBudW1iZXIgb3Igc3RyaW5nXG5cdFx0ICogIEBwYXJhbSAge1N0cmluZz19ICB1bml0cyAgVW5pdCB2YWx1ZXNcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiBUb25lLlRpbWVCYXNlKDQsIFwiblwiKVxuXHRcdCAqIFRvbmUuVGltZUJhc2UoMiwgXCJ0XCIpXG5cdFx0ICogVG9uZS5UaW1lQmFzZShcIjJ0XCIpLmFkZChcIjFtXCIpXG5cdFx0ICogVG9uZS5UaW1lQmFzZShcIjJ0ICsgMW1cIik7XG5cdFx0ICovXG5cdCAgICBUb25lLlRpbWVCYXNlID0gZnVuY3Rpb24gKHZhbCwgdW5pdHMpIHtcblx0ICAgICAgICAvL2FsbG93cyBpdCB0byBiZSBjb25zdHJ1Y3RlZCB3aXRoIG9yIHdpdGhvdXQgJ25ldydcblx0ICAgICAgICBpZiAodGhpcyBpbnN0YW5jZW9mIFRvbmUuVGltZUJhc2UpIHtcblx0ICAgICAgICAgICAgLyoqXG5cdFx0XHRcdCAqICBBbnkgZXhwcmVzc2lvbnMgcGFyc2VkIGZyb20gdGhlIFRpbWVcblx0XHRcdFx0ICogIEB0eXBlICB7QXJyYXl9XG5cdFx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0XHQgKi9cblx0ICAgICAgICAgICAgdGhpcy5fZXhwciA9IHRoaXMuX25vT3A7XG5cdCAgICAgICAgICAgIGlmICh2YWwgaW5zdGFuY2VvZiBUb25lLlRpbWVCYXNlKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLmNvcHkodmFsKTtcblx0ICAgICAgICAgICAgfSBlbHNlIGlmICghVG9uZS5pc1VuZGVmKHVuaXRzKSB8fCBUb25lLmlzTnVtYmVyKHZhbCkpIHtcblx0ICAgICAgICAgICAgICAgIC8vZGVmYXVsdCB1bml0c1xuXHQgICAgICAgICAgICAgICAgdW5pdHMgPSBUb25lLmRlZmF1bHRBcmcodW5pdHMsIHRoaXMuX2RlZmF1bHRVbml0cyk7XG5cdCAgICAgICAgICAgICAgICB2YXIgbWV0aG9kID0gdGhpcy5fcHJpbWFyeUV4cHJlc3Npb25zW3VuaXRzXS5tZXRob2Q7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9leHByID0gbWV0aG9kLmJpbmQodGhpcywgdmFsKTtcblx0ICAgICAgICAgICAgfSBlbHNlIGlmIChUb25lLmlzU3RyaW5nKHZhbCkpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuc2V0KHZhbCk7XG5cdCAgICAgICAgICAgIH0gZWxzZSBpZiAoVG9uZS5pc1VuZGVmKHZhbCkpIHtcblx0ICAgICAgICAgICAgICAgIC8vZGVmYXVsdCBleHByZXNzaW9uXG5cdCAgICAgICAgICAgICAgICB0aGlzLl9leHByID0gdGhpcy5fZGVmYXVsdEV4cHIoKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIHJldHVybiBuZXcgVG9uZS5UaW1lQmFzZSh2YWwsIHVuaXRzKTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5UaW1lQmFzZSk7XG5cdCAgICAvKipcblx0XHQgKiAgUmVwYWxjZSB0aGUgY3VycmVudCB0aW1lIHZhbHVlIHdpdGggdGhlIHZhbHVlXG5cdFx0ICogIGdpdmVuIGJ5IHRoZSBleHByZXNzaW9uIHN0cmluZy5cblx0XHQgKiAgQHBhcmFtICB7U3RyaW5nfSAgZXhwclN0cmluZ1xuXHRcdCAqICBAcmV0dXJuIHtUb25lLlRpbWVCYXNlfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLlRpbWVCYXNlLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAoZXhwclN0cmluZykge1xuXHQgICAgICAgIHRoaXMuX2V4cHIgPSB0aGlzLl9wYXJzZUV4cHJTdHJpbmcoZXhwclN0cmluZyk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFJldHVybiBhIGNsb25lIG9mIHRoZSBUaW1lQmFzZSBvYmplY3QuXG5cdFx0ICogIEByZXR1cm4gIHtUb25lLlRpbWVCYXNlfSBUaGUgbmV3IGNsb25lZCBUb25lLlRpbWVCYXNlXG5cdFx0ICovXG5cdCAgICBUb25lLlRpbWVCYXNlLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgaW5zdGFuY2UgPSBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpO1xuXHQgICAgICAgIGluc3RhbmNlLmNvcHkodGhpcyk7XG5cdCAgICAgICAgcmV0dXJuIGluc3RhbmNlO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBDb3BpZXMgdGhlIHZhbHVlIG9mIHRpbWUgdG8gdGhpcyBUaW1lXG5cdFx0ICogIEBwYXJhbSB7VG9uZS5UaW1lQmFzZX0gdGltZVxuXHRcdCAqICBAcmV0dXJuICB7VGltZUJhc2V9XG5cdFx0ICovXG5cdCAgICBUb25lLlRpbWVCYXNlLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKHRpbWUpIHtcblx0ICAgICAgICB2YXIgdmFsID0gdGltZS5fZXhwcigpO1xuXHQgICAgICAgIHJldHVybiB0aGlzLnNldCh2YWwpO1xuXHQgICAgfTtcblx0ICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQgICAgLy9cdEFCU1RSQUNUIFNZTlRBWCBUUkVFIFBBUlNFUlxuXHQgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdCAgICAvKipcblx0XHQgKiAgQWxsIHRoZSBwcmltYXJ5IGV4cHJlc3Npb25zLlxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqICBAdHlwZSAge09iamVjdH1cblx0XHQgKi9cblx0ICAgIFRvbmUuVGltZUJhc2UucHJvdG90eXBlLl9wcmltYXJ5RXhwcmVzc2lvbnMgPSB7XG5cdCAgICAgICAgJ24nOiB7XG5cdCAgICAgICAgICAgIHJlZ2V4cDogL14oXFxkKyluL2ksXG5cdCAgICAgICAgICAgIG1ldGhvZDogZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgICAgICAgICB2YWx1ZSA9IHBhcnNlSW50KHZhbHVlKTtcblx0ICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gMSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9iZWF0c1RvVW5pdHModGhpcy5fdGltZVNpZ25hdHVyZSgpKTtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2JlYXRzVG9Vbml0cyg0IC8gdmFsdWUpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblx0ICAgICAgICAndCc6IHtcblx0ICAgICAgICAgICAgcmVnZXhwOiAvXihcXGQrKXQvaSxcblx0ICAgICAgICAgICAgbWV0aG9kOiBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgICAgICAgICAgIHZhbHVlID0gcGFyc2VJbnQodmFsdWUpO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2JlYXRzVG9Vbml0cyg4IC8gKHBhcnNlSW50KHZhbHVlKSAqIDMpKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0sXG5cdCAgICAgICAgJ20nOiB7XG5cdCAgICAgICAgICAgIHJlZ2V4cDogL14oXFxkKyltL2ksXG5cdCAgICAgICAgICAgIG1ldGhvZDogZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fYmVhdHNUb1VuaXRzKHBhcnNlSW50KHZhbHVlKSAqIHRoaXMuX3RpbWVTaWduYXR1cmUoKSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9LFxuXHQgICAgICAgICdpJzoge1xuXHQgICAgICAgICAgICByZWdleHA6IC9eKFxcZCspaS9pLFxuXHQgICAgICAgICAgICBtZXRob2Q6IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RpY2tzVG9Vbml0cyhwYXJzZUludCh2YWx1ZSkpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblx0ICAgICAgICAnaHonOiB7XG5cdCAgICAgICAgICAgIHJlZ2V4cDogL14oXFxkKyg/OlxcLlxcZCspPyloei9pLFxuXHQgICAgICAgICAgICBtZXRob2Q6IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ZyZXF1ZW5jeVRvVW5pdHMocGFyc2VGbG9hdCh2YWx1ZSkpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblx0ICAgICAgICAndHInOiB7XG5cdCAgICAgICAgICAgIHJlZ2V4cDogL14oXFxkKyg/OlxcLlxcZCspPyk6KFxcZCsoPzpcXC5cXGQrKT8pOj8oXFxkKyg/OlxcLlxcZCspPyk/Lyxcblx0ICAgICAgICAgICAgbWV0aG9kOiBmdW5jdGlvbiAobSwgcSwgcykge1xuXHQgICAgICAgICAgICAgICAgdmFyIHRvdGFsID0gMDtcblx0ICAgICAgICAgICAgICAgIGlmIChtICYmIG0gIT09ICcwJykge1xuXHQgICAgICAgICAgICAgICAgICAgIHRvdGFsICs9IHRoaXMuX2JlYXRzVG9Vbml0cyh0aGlzLl90aW1lU2lnbmF0dXJlKCkgKiBwYXJzZUZsb2F0KG0pKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGlmIChxICYmIHEgIT09ICcwJykge1xuXHQgICAgICAgICAgICAgICAgICAgIHRvdGFsICs9IHRoaXMuX2JlYXRzVG9Vbml0cyhwYXJzZUZsb2F0KHEpKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGlmIChzICYmIHMgIT09ICcwJykge1xuXHQgICAgICAgICAgICAgICAgICAgIHRvdGFsICs9IHRoaXMuX2JlYXRzVG9Vbml0cyhwYXJzZUZsb2F0KHMpIC8gNCk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdG90YWw7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9LFxuXHQgICAgICAgICdzJzoge1xuXHQgICAgICAgICAgICByZWdleHA6IC9eKFxcZCsoPzpcXC5cXGQrKT9zKS8sXG5cdCAgICAgICAgICAgIG1ldGhvZDogZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fc2Vjb25kc1RvVW5pdHMocGFyc2VGbG9hdCh2YWx1ZSkpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblx0ICAgICAgICAnc2FtcGxlcyc6IHtcblx0ICAgICAgICAgICAgcmVnZXhwOiAvXihcXGQrKXNhbXBsZXMvLFxuXHQgICAgICAgICAgICBtZXRob2Q6IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KHZhbHVlKSAvIHRoaXMuY29udGV4dC5zYW1wbGVSYXRlO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblx0ICAgICAgICAnZGVmYXVsdCc6IHtcblx0ICAgICAgICAgICAgcmVnZXhwOiAvXihcXGQrKD86XFwuXFxkKyk/KS8sXG5cdCAgICAgICAgICAgIG1ldGhvZDogZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcHJpbWFyeUV4cHJlc3Npb25zW3RoaXMuX2RlZmF1bHRVbml0c10ubWV0aG9kLmNhbGwodGhpcywgdmFsdWUpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBBbGwgdGhlIGJpbmFyeSBleHByZXNzaW9ucyB0aGF0IFRpbWVCYXNlIGNhbiBhY2NlcHQuXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICogIEB0eXBlICB7T2JqZWN0fVxuXHRcdCAqL1xuXHQgICAgVG9uZS5UaW1lQmFzZS5wcm90b3R5cGUuX2JpbmFyeUV4cHJlc3Npb25zID0ge1xuXHQgICAgICAgICcrJzoge1xuXHQgICAgICAgICAgICByZWdleHA6IC9eXFwrLyxcblx0ICAgICAgICAgICAgcHJlY2VkZW5jZTogMixcblx0ICAgICAgICAgICAgbWV0aG9kOiBmdW5jdGlvbiAobGgsIHJoKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gbGgoKSArIHJoKCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9LFxuXHQgICAgICAgICctJzoge1xuXHQgICAgICAgICAgICByZWdleHA6IC9eXFwtLyxcblx0ICAgICAgICAgICAgcHJlY2VkZW5jZTogMixcblx0ICAgICAgICAgICAgbWV0aG9kOiBmdW5jdGlvbiAobGgsIHJoKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gbGgoKSAtIHJoKCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9LFxuXHQgICAgICAgICcqJzoge1xuXHQgICAgICAgICAgICByZWdleHA6IC9eXFwqLyxcblx0ICAgICAgICAgICAgcHJlY2VkZW5jZTogMSxcblx0ICAgICAgICAgICAgbWV0aG9kOiBmdW5jdGlvbiAobGgsIHJoKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gbGgoKSAqIHJoKCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9LFxuXHQgICAgICAgICcvJzoge1xuXHQgICAgICAgICAgICByZWdleHA6IC9eXFwvLyxcblx0ICAgICAgICAgICAgcHJlY2VkZW5jZTogMSxcblx0ICAgICAgICAgICAgbWV0aG9kOiBmdW5jdGlvbiAobGgsIHJoKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gbGgoKSAvIHJoKCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIEFsbCB0aGUgdW5hcnkgZXhwcmVzc2lvbnMuXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICogIEB0eXBlICB7T2JqZWN0fVxuXHRcdCAqL1xuXHQgICAgVG9uZS5UaW1lQmFzZS5wcm90b3R5cGUuX3VuYXJ5RXhwcmVzc2lvbnMgPSB7XG5cdCAgICAgICAgJ25lZyc6IHtcblx0ICAgICAgICAgICAgcmVnZXhwOiAvXlxcLS8sXG5cdCAgICAgICAgICAgIG1ldGhvZDogZnVuY3Rpb24gKGxoKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gLWxoKCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFN5bnRhY3RpYyBnbHVlIHdoaWNoIGhvbGRzIGV4cHJlc3Npb25zIHRvZ2V0aGVyXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICogIEB0eXBlICB7T2JqZWN0fVxuXHRcdCAqL1xuXHQgICAgVG9uZS5UaW1lQmFzZS5wcm90b3R5cGUuX3N5bnRheEdsdWUgPSB7XG5cdCAgICAgICAgJygnOiB7IHJlZ2V4cDogL15cXCgvIH0sXG5cdCAgICAgICAgJyknOiB7IHJlZ2V4cDogL15cXCkvIH1cblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgdG9rZW5pemUgdGhlIGV4cHJlc3Npb24gYmFzZWQgb24gdGhlIEV4cHJlc3Npb25zIG9iamVjdFxuXHRcdCAqICBAcGFyYW0gICB7c3RyaW5nfSBleHByIFxuXHRcdCAqICBAcmV0dXJuICB7T2JqZWN0fSAgICAgIHJldHVybnMgdHdvIG1ldGhvZHMgb24gdGhlIHRva2VuaXplZCBsaXN0LCBuZXh0IGFuZCBwZWVrXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLlRpbWVCYXNlLnByb3RvdHlwZS5fdG9rZW5pemUgPSBmdW5jdGlvbiAoZXhwcikge1xuXHQgICAgICAgIHZhciBwb3NpdGlvbiA9IC0xO1xuXHQgICAgICAgIHZhciB0b2tlbnMgPSBbXTtcblx0ICAgICAgICB3aGlsZSAoZXhwci5sZW5ndGggPiAwKSB7XG5cdCAgICAgICAgICAgIGV4cHIgPSBleHByLnRyaW0oKTtcblx0ICAgICAgICAgICAgdmFyIHRva2VuID0gZ2V0TmV4dFRva2VuKGV4cHIsIHRoaXMpO1xuXHQgICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG5cdCAgICAgICAgICAgIGV4cHIgPSBleHByLnN1YnN0cih0b2tlbi52YWx1ZS5sZW5ndGgpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiBnZXROZXh0VG9rZW4oZXhwciwgY29udGV4dCkge1xuXHQgICAgICAgICAgICB2YXIgZXhwcmVzc2lvbnMgPSBbXG5cdCAgICAgICAgICAgICAgICAnX2JpbmFyeUV4cHJlc3Npb25zJyxcblx0ICAgICAgICAgICAgICAgICdfdW5hcnlFeHByZXNzaW9ucycsXG5cdCAgICAgICAgICAgICAgICAnX3ByaW1hcnlFeHByZXNzaW9ucycsXG5cdCAgICAgICAgICAgICAgICAnX3N5bnRheEdsdWUnXG5cdCAgICAgICAgICAgIF07XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXhwcmVzc2lvbnMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIHZhciBncm91cCA9IGNvbnRleHRbZXhwcmVzc2lvbnNbaV1dO1xuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgb3BOYW1lIGluIGdyb3VwKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIG9wID0gZ3JvdXBbb3BOYW1lXTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgcmVnID0gb3AucmVnZXhwO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBtYXRjaCA9IGV4cHIubWF0Y2gocmVnKTtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2ggIT09IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZDogb3AubWV0aG9kLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJlY2VkZW5jZTogb3AucHJlY2VkZW5jZSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZ2V4cDogb3AucmVnZXhwLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG1hdGNoWzBdXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignVG9uZS5UaW1lQmFzZTogVW5leHBlY3RlZCB0b2tlbiAnICsgZXhwcik7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbnNbKytwb3NpdGlvbl07XG5cdCAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgIHBlZWs6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbnNbcG9zaXRpb24gKyAxXTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH07XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIEdpdmVuIGEgdG9rZW4sIGZpbmQgdGhlIHZhbHVlIHdpdGhpbiB0aGUgZ3JvdXBOYW1lXG5cdFx0ICogIEBwYXJhbSB7T2JqZWN0fSB0b2tlblxuXHRcdCAqICBAcGFyYW0ge1N0cmluZ30gZ3JvdXBOYW1lXG5cdFx0ICogIEBwYXJhbSB7TnVtYmVyfSBwcmVjZWRlbmNlXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLlRpbWVCYXNlLnByb3RvdHlwZS5fbWF0Y2hHcm91cCA9IGZ1bmN0aW9uICh0b2tlbiwgZ3JvdXAsIHByZWMpIHtcblx0ICAgICAgICB2YXIgcmV0ID0gZmFsc2U7XG5cdCAgICAgICAgaWYgKCFUb25lLmlzVW5kZWYodG9rZW4pKSB7XG5cdCAgICAgICAgICAgIGZvciAodmFyIG9wTmFtZSBpbiBncm91cCkge1xuXHQgICAgICAgICAgICAgICAgdmFyIG9wID0gZ3JvdXBbb3BOYW1lXTtcblx0ICAgICAgICAgICAgICAgIGlmIChvcC5yZWdleHAudGVzdCh0b2tlbi52YWx1ZSkpIHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoIVRvbmUuaXNVbmRlZihwcmVjKSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3AucHJlY2VkZW5jZSA9PT0gcHJlYykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9wO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9wO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gcmV0O1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBNYXRjaCBhIGJpbmFyeSBleHByZXNzaW9uIGdpdmVuIHRoZSB0b2tlbiBhbmQgdGhlIHByZWNlZGVuY2Vcblx0XHQgKiAgQHBhcmFtIHtMZXhlcn0gbGV4ZXJcblx0XHQgKiAgQHBhcmFtIHtOdW1iZXJ9IHByZWNlZGVuY2Vcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuVGltZUJhc2UucHJvdG90eXBlLl9wYXJzZUJpbmFyeSA9IGZ1bmN0aW9uIChsZXhlciwgcHJlY2VkZW5jZSkge1xuXHQgICAgICAgIGlmIChUb25lLmlzVW5kZWYocHJlY2VkZW5jZSkpIHtcblx0ICAgICAgICAgICAgcHJlY2VkZW5jZSA9IDI7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBleHByO1xuXHQgICAgICAgIGlmIChwcmVjZWRlbmNlIDwgMCkge1xuXHQgICAgICAgICAgICBleHByID0gdGhpcy5fcGFyc2VVbmFyeShsZXhlcik7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgZXhwciA9IHRoaXMuX3BhcnNlQmluYXJ5KGxleGVyLCBwcmVjZWRlbmNlIC0gMSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciB0b2tlbiA9IGxleGVyLnBlZWsoKTtcblx0ICAgICAgICB3aGlsZSAodG9rZW4gJiYgdGhpcy5fbWF0Y2hHcm91cCh0b2tlbiwgdGhpcy5fYmluYXJ5RXhwcmVzc2lvbnMsIHByZWNlZGVuY2UpKSB7XG5cdCAgICAgICAgICAgIHRva2VuID0gbGV4ZXIubmV4dCgpO1xuXHQgICAgICAgICAgICBleHByID0gdG9rZW4ubWV0aG9kLmJpbmQodGhpcywgZXhwciwgdGhpcy5fcGFyc2VCaW5hcnkobGV4ZXIsIHByZWNlZGVuY2UgLSAxKSk7XG5cdCAgICAgICAgICAgIHRva2VuID0gbGV4ZXIucGVlaygpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gZXhwcjtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgTWF0Y2ggYSB1bmFyeSBleHByZXNzaW9uLlxuXHRcdCAqICBAcGFyYW0ge0xleGVyfSBsZXhlclxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5UaW1lQmFzZS5wcm90b3R5cGUuX3BhcnNlVW5hcnkgPSBmdW5jdGlvbiAobGV4ZXIpIHtcblx0ICAgICAgICB2YXIgdG9rZW4sIGV4cHI7XG5cdCAgICAgICAgdG9rZW4gPSBsZXhlci5wZWVrKCk7XG5cdCAgICAgICAgdmFyIG9wID0gdGhpcy5fbWF0Y2hHcm91cCh0b2tlbiwgdGhpcy5fdW5hcnlFeHByZXNzaW9ucyk7XG5cdCAgICAgICAgaWYgKG9wKSB7XG5cdCAgICAgICAgICAgIHRva2VuID0gbGV4ZXIubmV4dCgpO1xuXHQgICAgICAgICAgICBleHByID0gdGhpcy5fcGFyc2VVbmFyeShsZXhlcik7XG5cdCAgICAgICAgICAgIHJldHVybiBvcC5tZXRob2QuYmluZCh0aGlzLCBleHByKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuX3BhcnNlUHJpbWFyeShsZXhlcik7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIE1hdGNoIGEgcHJpbWFyeSBleHByZXNzaW9uIChhIHZhbHVlKS5cblx0XHQgKiAgQHBhcmFtIHtMZXhlcn0gbGV4ZXJcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuVGltZUJhc2UucHJvdG90eXBlLl9wYXJzZVByaW1hcnkgPSBmdW5jdGlvbiAobGV4ZXIpIHtcblx0ICAgICAgICB2YXIgdG9rZW4sIGV4cHI7XG5cdCAgICAgICAgdG9rZW4gPSBsZXhlci5wZWVrKCk7XG5cdCAgICAgICAgaWYgKFRvbmUuaXNVbmRlZih0b2tlbikpIHtcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdUb25lLlRpbWVCYXNlOiBVbmV4cGVjdGVkIGVuZCBvZiBleHByZXNzaW9uJyk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmICh0aGlzLl9tYXRjaEdyb3VwKHRva2VuLCB0aGlzLl9wcmltYXJ5RXhwcmVzc2lvbnMpKSB7XG5cdCAgICAgICAgICAgIHRva2VuID0gbGV4ZXIubmV4dCgpO1xuXHQgICAgICAgICAgICB2YXIgbWF0Y2hpbmcgPSB0b2tlbi52YWx1ZS5tYXRjaCh0b2tlbi5yZWdleHApO1xuXHQgICAgICAgICAgICByZXR1cm4gdG9rZW4ubWV0aG9kLmJpbmQodGhpcywgbWF0Y2hpbmdbMV0sIG1hdGNoaW5nWzJdLCBtYXRjaGluZ1szXSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmICh0b2tlbiAmJiB0b2tlbi52YWx1ZSA9PT0gJygnKSB7XG5cdCAgICAgICAgICAgIGxleGVyLm5leHQoKTtcblx0ICAgICAgICAgICAgZXhwciA9IHRoaXMuX3BhcnNlQmluYXJ5KGxleGVyKTtcblx0ICAgICAgICAgICAgdG9rZW4gPSBsZXhlci5uZXh0KCk7XG5cdCAgICAgICAgICAgIGlmICghKHRva2VuICYmIHRva2VuLnZhbHVlID09PSAnKScpKSB7XG5cdCAgICAgICAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ0V4cGVjdGVkICknKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gZXhwcjtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdUb25lLlRpbWVCYXNlOiBDYW5ub3QgcHJvY2VzcyB0b2tlbiAnICsgdG9rZW4udmFsdWUpO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBSZWN1cnNpdmVseSBwYXJzZSB0aGUgc3RyaW5nIGV4cHJlc3Npb24gaW50byBhIHN5bnRheCB0cmVlLlxuXHRcdCAqICBAcGFyYW0gICB7c3RyaW5nfSBleHByIFxuXHRcdCAqICBAcmV0dXJuICB7RnVuY3Rpb259IHRoZSBib3VuZCBtZXRob2QgdG8gYmUgZXZhbHVhdGVkIGxhdGVyXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLlRpbWVCYXNlLnByb3RvdHlwZS5fcGFyc2VFeHByU3RyaW5nID0gZnVuY3Rpb24gKGV4cHJTdHJpbmcpIHtcblx0ICAgICAgICBpZiAoIVRvbmUuaXNTdHJpbmcoZXhwclN0cmluZykpIHtcblx0ICAgICAgICAgICAgZXhwclN0cmluZyA9IGV4cHJTdHJpbmcudG9TdHJpbmcoKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIGxleGVyID0gdGhpcy5fdG9rZW5pemUoZXhwclN0cmluZyk7XG5cdCAgICAgICAgdmFyIHRyZWUgPSB0aGlzLl9wYXJzZUJpbmFyeShsZXhlcik7XG5cdCAgICAgICAgcmV0dXJuIHRyZWU7XG5cdCAgICB9O1xuXHQgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdCAgICAvL1x0REVGQVVMVFNcblx0ICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQgICAgLyoqXG5cdFx0ICogIFRoZSBpbml0aWFsIGV4cHJlc3Npb24gdmFsdWVcblx0XHQgKiAgQHJldHVybiAge051bWJlcn0gIFRoZSBpbml0aWFsIHZhbHVlIDBcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuVGltZUJhc2UucHJvdG90eXBlLl9ub09wID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHJldHVybiAwO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgZGVmYXVsdCBleHByZXNzaW9uIHZhbHVlIGlmIG5vIGFyZ3VtZW50cyBhcmUgZ2l2ZW5cblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuVGltZUJhc2UucHJvdG90eXBlLl9kZWZhdWx0RXhwciA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy5fbm9PcDtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgVGhlIGRlZmF1bHQgdW5pdHMgaWYgbm9uZSBhcmUgZ2l2ZW4uXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLlRpbWVCYXNlLnByb3RvdHlwZS5fZGVmYXVsdFVuaXRzID0gJ3MnO1xuXHQgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdCAgICAvL1x0VU5JVCBDT05WRVJTSU9OU1xuXHQgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdCAgICAvKipcblx0XHQgKiAgUmV0dXJucyB0aGUgdmFsdWUgb2YgYSBmcmVxdWVuY3kgaW4gdGhlIGN1cnJlbnQgdW5pdHNcblx0XHQgKiAgQHBhcmFtIHtGcmVxdWVuY3l9IGZyZXFcblx0XHQgKiAgQHJldHVybiAge051bWJlcn1cblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuVGltZUJhc2UucHJvdG90eXBlLl9mcmVxdWVuY3lUb1VuaXRzID0gZnVuY3Rpb24gKGZyZXEpIHtcblx0ICAgICAgICByZXR1cm4gMSAvIGZyZXE7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFJldHVybiB0aGUgdmFsdWUgb2YgdGhlIGJlYXRzIGluIHRoZSBjdXJyZW50IHVuaXRzXG5cdFx0ICogIEBwYXJhbSB7TnVtYmVyfSBiZWF0c1xuXHRcdCAqICBAcmV0dXJuICB7TnVtYmVyfVxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5UaW1lQmFzZS5wcm90b3R5cGUuX2JlYXRzVG9Vbml0cyA9IGZ1bmN0aW9uIChiZWF0cykge1xuXHQgICAgICAgIHJldHVybiA2MCAvIFRvbmUuVHJhbnNwb3J0LmJwbS52YWx1ZSAqIGJlYXRzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBSZXR1cm5zIHRoZSB2YWx1ZSBvZiBhIHNlY29uZCBpbiB0aGUgY3VycmVudCB1bml0c1xuXHRcdCAqICBAcGFyYW0ge1NlY29uZHN9IHNlY29uZHNcblx0XHQgKiAgQHJldHVybiAge051bWJlcn1cblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuVGltZUJhc2UucHJvdG90eXBlLl9zZWNvbmRzVG9Vbml0cyA9IGZ1bmN0aW9uIChzZWNvbmRzKSB7XG5cdCAgICAgICAgcmV0dXJuIHNlY29uZHM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFJldHVybnMgdGhlIHZhbHVlIG9mIGEgdGljayBpbiB0aGUgY3VycmVudCB0aW1lIHVuaXRzXG5cdFx0ICogIEBwYXJhbSB7VGlja3N9IHRpY2tzXG5cdFx0ICogIEByZXR1cm4gIHtOdW1iZXJ9XG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLlRpbWVCYXNlLnByb3RvdHlwZS5fdGlja3NUb1VuaXRzID0gZnVuY3Rpb24gKHRpY2tzKSB7XG5cdCAgICAgICAgcmV0dXJuIHRpY2tzICogKHRoaXMuX2JlYXRzVG9Vbml0cygxKSAvIFRvbmUuVHJhbnNwb3J0LlBQUSk7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFJldHVybiB0aGUgdGltZSBzaWduYXR1cmUuXG5cdFx0ICogIEByZXR1cm4gIHtOdW1iZXJ9XG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLlRpbWVCYXNlLnByb3RvdHlwZS5fdGltZVNpZ25hdHVyZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICByZXR1cm4gVG9uZS5UcmFuc3BvcnQudGltZVNpZ25hdHVyZTtcblx0ICAgIH07XG5cdCAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblx0ICAgIC8vXHRFWFBSRVNTSU9OU1xuXHQgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdCAgICAvKipcblx0XHQgKiAgUHVzaCBhbiBleHByZXNzaW9uIG9udG8gdGhlIGV4cHJlc3Npb24gbGlzdFxuXHRcdCAqICBAcGFyYW0gIHtUaW1lfSAgdmFsXG5cdFx0ICogIEBwYXJhbSAge1N0cmluZ30gIHR5cGVcblx0XHQgKiAgQHBhcmFtICB7U3RyaW5nfSAgdW5pdHNcblx0XHQgKiAgQHJldHVybiAge1RvbmUuVGltZUJhc2V9IFxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5UaW1lQmFzZS5wcm90b3R5cGUuX3B1c2hFeHByID0gZnVuY3Rpb24gKHZhbCwgbmFtZSwgdW5pdHMpIHtcblx0ICAgICAgICAvL2NyZWF0ZSB0aGUgZXhwcmVzc2lvblxuXHQgICAgICAgIGlmICghKHZhbCBpbnN0YW5jZW9mIFRvbmUuVGltZUJhc2UpKSB7XG5cdCAgICAgICAgICAgIHZhbCA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKHZhbCwgdW5pdHMpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB0aGlzLl9leHByID0gdGhpcy5fYmluYXJ5RXhwcmVzc2lvbnNbbmFtZV0ubWV0aG9kLmJpbmQodGhpcywgdGhpcy5fZXhwciwgdmFsLl9leHByKTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgQWRkIHRvIHRoZSBjdXJyZW50IHZhbHVlLlxuXHRcdCAqICBAcGFyYW0gIHtUaW1lfSAgdmFsICAgIFRoZSB2YWx1ZSB0byBhZGRcblx0XHQgKiAgQHBhcmFtICB7U3RyaW5nPX0gIHVuaXRzICBPcHRpb25hbCB1bml0cyB0byB1c2Ugd2l0aCB0aGUgdmFsdWUuXG5cdFx0ICogIEByZXR1cm4gIHtUb25lLlRpbWVCYXNlfSAgdGhpc1xuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIFRvbmUuVGltZUJhc2UoXCIybVwiKS5hZGQoXCIxbVwiKTsgLy9cIjNtXCJcblx0XHQgKi9cblx0ICAgIFRvbmUuVGltZUJhc2UucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uICh2YWwsIHVuaXRzKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuX3B1c2hFeHByKHZhbCwgJysnLCB1bml0cyk7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFN1YnRyYWN0IHRoZSB2YWx1ZSBmcm9tIHRoZSBjdXJyZW50IHRpbWUuXG5cdFx0ICogIEBwYXJhbSAge1RpbWV9ICB2YWwgICAgVGhlIHZhbHVlIHRvIHN1YnRyYWN0XG5cdFx0ICogIEBwYXJhbSAge1N0cmluZz19ICB1bml0cyAgT3B0aW9uYWwgdW5pdHMgdG8gdXNlIHdpdGggdGhlIHZhbHVlLlxuXHRcdCAqICBAcmV0dXJuICB7VG9uZS5UaW1lQmFzZX0gIHRoaXNcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiBUb25lLlRpbWVCYXNlKFwiMm1cIikuc3ViKFwiMW1cIik7IC8vXCIxbVwiXG5cdFx0ICovXG5cdCAgICBUb25lLlRpbWVCYXNlLnByb3RvdHlwZS5zdWIgPSBmdW5jdGlvbiAodmFsLCB1bml0cykge1xuXHQgICAgICAgIHJldHVybiB0aGlzLl9wdXNoRXhwcih2YWwsICctJywgdW5pdHMpO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBNdWx0aXBseSB0aGUgY3VycmVudCB2YWx1ZSBieSB0aGUgZ2l2ZW4gdGltZS5cblx0XHQgKiAgQHBhcmFtICB7VGltZX0gIHZhbCAgICBUaGUgdmFsdWUgdG8gbXVsdGlwbHlcblx0XHQgKiAgQHBhcmFtICB7U3RyaW5nPX0gIHVuaXRzICBPcHRpb25hbCB1bml0cyB0byB1c2Ugd2l0aCB0aGUgdmFsdWUuXG5cdFx0ICogIEByZXR1cm4gIHtUb25lLlRpbWVCYXNlfSAgdGhpc1xuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIFRvbmUuVGltZUJhc2UoXCIybVwiKS5tdWx0KFwiMlwiKTsgLy9cIjRtXCJcblx0XHQgKi9cblx0ICAgIFRvbmUuVGltZUJhc2UucHJvdG90eXBlLm11bHQgPSBmdW5jdGlvbiAodmFsLCB1bml0cykge1xuXHQgICAgICAgIHJldHVybiB0aGlzLl9wdXNoRXhwcih2YWwsICcqJywgdW5pdHMpO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBEaXZpZGUgdGhlIGN1cnJlbnQgdmFsdWUgYnkgdGhlIGdpdmVuIHRpbWUuXG5cdFx0ICogIEBwYXJhbSAge1RpbWV9ICB2YWwgICAgVGhlIHZhbHVlIHRvIGRpdmlkZSBieVxuXHRcdCAqICBAcGFyYW0gIHtTdHJpbmc9fSAgdW5pdHMgIE9wdGlvbmFsIHVuaXRzIHRvIHVzZSB3aXRoIHRoZSB2YWx1ZS5cblx0XHQgKiAgQHJldHVybiAge1RvbmUuVGltZUJhc2V9ICB0aGlzXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogVG9uZS5UaW1lQmFzZShcIjJtXCIpLmRpdigyKTsgLy9cIjFtXCJcblx0XHQgKi9cblx0ICAgIFRvbmUuVGltZUJhc2UucHJvdG90eXBlLmRpdiA9IGZ1bmN0aW9uICh2YWwsIHVuaXRzKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuX3B1c2hFeHByKHZhbCwgJy8nLCB1bml0cyk7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIEV2YWx1YXRlIHRoZSB0aW1lIHZhbHVlLiBSZXR1cm5zIHRoZSB0aW1lXG5cdFx0ICogIGluIHNlY29uZHMuXG5cdFx0ICogIEByZXR1cm4gIHtTZWNvbmRzfSBcblx0XHQgKi9cblx0ICAgIFRvbmUuVGltZUJhc2UucHJvdG90eXBlLnZhbHVlT2YgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuX2V4cHIoKTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgQ2xlYW4gdXBcblx0XHQgKiAgQHJldHVybiB7VG9uZS5UaW1lQmFzZX0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5UaW1lQmFzZS5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB0aGlzLl9leHByID0gbnVsbDtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVG9uZS5UaW1lQmFzZTtcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyBUb25lLlRpbWUgaXMgYSBwcmltaXRpdmUgdHlwZSBmb3IgZW5jb2RpbmcgVGltZSB2YWx1ZXMuIFxuXHRcdCAqICAgICAgICAgRXZlbnR1YWxseSBhbGwgdGltZSB2YWx1ZXMgYXJlIGV2YWx1YXRlZCB0byBzZWNvbmRzXG5cdFx0ICogICAgICAgICB1c2luZyB0aGUgYGV2YWxgIG1ldGhvZC4gVG9uZS5UaW1lIGNhbiBiZSBjb25zdHJ1Y3RlZFxuXHRcdCAqICAgICAgICAgd2l0aCBvciB3aXRob3V0IHRoZSBgbmV3YCBrZXl3b3JkLiBUb25lLlRpbWUgY2FuIGJlIHBhc3NlZFxuXHRcdCAqICAgICAgICAgaW50byB0aGUgcGFyYW1ldGVyIG9mIGFueSBtZXRob2Qgd2hpY2ggdGFrZXMgdGltZSBhcyBhbiBhcmd1bWVudC4gXG5cdFx0ICogIEBjb25zdHJ1Y3RvclxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZS5UaW1lQmFzZX1cblx0XHQgKiAgQHBhcmFtICB7U3RyaW5nfE51bWJlcn0gIHZhbCAgICBUaGUgdGltZSB2YWx1ZS5cblx0XHQgKiAgQHBhcmFtICB7U3RyaW5nPX0gIHVuaXRzICBUaGUgdW5pdHMgb2YgdGhlIHZhbHVlLlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIHZhciB0ID0gVG9uZS5UaW1lKFwiNG5cIik7Ly9lbmNvZGVzIGEgcXVhcnRlciBub3RlXG5cdFx0ICogdC5tdWx0KDQpOyAvLyBtdWx0aXBseSB0aGF0IHZhbHVlIGJ5IDRcblx0XHQgKiB0LnRvTm90YXRpb24oKTsgLy9yZXR1cm5zIFwiMW1cIlxuXHRcdCAqL1xuXHQgICAgVG9uZS5UaW1lID0gZnVuY3Rpb24gKHZhbCwgdW5pdHMpIHtcblx0ICAgICAgICBpZiAodGhpcyBpbnN0YW5jZW9mIFRvbmUuVGltZSkge1xuXHQgICAgICAgICAgICAvKipcblx0XHRcdFx0ICogIElmIHRoZSBjdXJyZW50IGNsb2NrIHRpbWUgc2hvdWxkXG5cdFx0XHRcdCAqICBiZSBhZGRlZCB0byB0aGUgb3V0cHV0XG5cdFx0XHRcdCAqICBAdHlwZSAge0Jvb2xlYW59XG5cdFx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0XHQgKi9cblx0ICAgICAgICAgICAgdGhpcy5fcGx1c05vdyA9IGZhbHNlO1xuXHQgICAgICAgICAgICBUb25lLlRpbWVCYXNlLmNhbGwodGhpcywgdmFsLCB1bml0cyk7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgcmV0dXJuIG5ldyBUb25lLlRpbWUodmFsLCB1bml0cyk7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuVGltZSwgVG9uZS5UaW1lQmFzZSk7XG5cdCAgICAvL2Nsb25lIHRoZSBleHByZXNzaW9ucyBzbyB0aGF0IFxuXHQgICAgLy93ZSBjYW4gYWRkIG1vcmUgd2l0aG91dCBtb2RpZnlpbmcgdGhlIG9yaWdpbmFsXG5cdCAgICBUb25lLlRpbWUucHJvdG90eXBlLl91bmFyeUV4cHJlc3Npb25zID0gT2JqZWN0LmNyZWF0ZShUb25lLlRpbWVCYXNlLnByb3RvdHlwZS5fdW5hcnlFeHByZXNzaW9ucyk7XG5cdCAgICAvKlxuXHRcdCAqICBBZGRzIGFuIGFkZGl0aW9uYWwgdW5hcnkgZXhwcmVzc2lvblxuXHRcdCAqICB3aGljaCBxdWFudGl6ZXMgdmFsdWVzIHRvIHRoZSBuZXh0IHN1YmRpdmlzaW9uXG5cdFx0ICogIEB0eXBlIHtPYmplY3R9XG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLlRpbWUucHJvdG90eXBlLl91bmFyeUV4cHJlc3Npb25zLnF1YW50aXplID0ge1xuXHQgICAgICAgIHJlZ2V4cDogL15ALyxcblx0ICAgICAgICBtZXRob2Q6IGZ1bmN0aW9uIChyaCkge1xuXHQgICAgICAgICAgICByZXR1cm4gVG9uZS5UcmFuc3BvcnQubmV4dFN1YmRpdmlzaW9uKHJoKCkpO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICAvKlxuXHRcdCAqICBBZGRzIGFuIGFkZGl0aW9uYWwgdW5hcnkgZXhwcmVzc2lvblxuXHRcdCAqICB3aGljaCBhZGRzIHRoZSBjdXJyZW50IGNsb2NrIHRpbWUuXG5cdFx0ICogIEB0eXBlIHtPYmplY3R9XG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLlRpbWUucHJvdG90eXBlLl91bmFyeUV4cHJlc3Npb25zLm5vdyA9IHtcblx0ICAgICAgICByZWdleHA6IC9eXFwrLyxcblx0ICAgICAgICBtZXRob2Q6IGZ1bmN0aW9uIChsaCkge1xuXHQgICAgICAgICAgICB0aGlzLl9wbHVzTm93ID0gdHJ1ZTtcblx0ICAgICAgICAgICAgcmV0dXJuIGxoKCk7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBRdWFudGl6ZSB0aGUgdGltZSBieSB0aGUgZ2l2ZW4gc3ViZGl2aXNpb24uIE9wdGlvbmFsbHkgYWRkIGFcblx0XHQgKiAgcGVyY2VudGFnZSB3aGljaCB3aWxsIG1vdmUgdGhlIHRpbWUgdmFsdWUgdG93YXJkcyB0aGUgaWRlYWxcblx0XHQgKiAgcXVhbnRpemVkIHZhbHVlIGJ5IHRoYXQgcGVyY2VudGFnZS4gXG5cdFx0ICogIEBwYXJhbSAge051bWJlcnxUaW1lfSAgdmFsICAgIFRoZSBzdWJkaXZpc2lvbiB0byBxdWFudGl6ZSB0b1xuXHRcdCAqICBAcGFyYW0gIHtOb3JtYWxSYW5nZX0gIFtwZXJjZW50PTFdICBNb3ZlIHRoZSB0aW1lIHZhbHVlXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvd2FyZHMgdGhlIHF1YW50aXplZCB2YWx1ZSBieVxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhIHBlcmNlbnRhZ2UuXG5cdFx0ICogIEByZXR1cm4gIHtUb25lLlRpbWV9ICB0aGlzXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogVG9uZS5UaW1lKDIxKS5xdWFudGl6ZSgyKSAvL3JldHVybnMgMjJcblx0XHQgKiBUb25lLlRpbWUoMC42KS5xdWFudGl6ZShcIjRuXCIsIDAuNSkgLy9yZXR1cm5zIDAuNTVcblx0XHQgKi9cblx0ICAgIFRvbmUuVGltZS5wcm90b3R5cGUucXVhbnRpemUgPSBmdW5jdGlvbiAoc3ViZGl2LCBwZXJjZW50KSB7XG5cdCAgICAgICAgcGVyY2VudCA9IFRvbmUuZGVmYXVsdEFyZyhwZXJjZW50LCAxKTtcblx0ICAgICAgICB0aGlzLl9leHByID0gZnVuY3Rpb24gKGV4cHIsIHN1YmRpdmlzaW9uLCBwZXJjZW50KSB7XG5cdCAgICAgICAgICAgIGV4cHIgPSBleHByKCk7XG5cdCAgICAgICAgICAgIHN1YmRpdmlzaW9uID0gc3ViZGl2aXNpb24udG9TZWNvbmRzKCk7XG5cdCAgICAgICAgICAgIHZhciBtdWx0aXBsZSA9IE1hdGgucm91bmQoZXhwciAvIHN1YmRpdmlzaW9uKTtcblx0ICAgICAgICAgICAgdmFyIGlkZWFsID0gbXVsdGlwbGUgKiBzdWJkaXZpc2lvbjtcblx0ICAgICAgICAgICAgdmFyIGRpZmYgPSBpZGVhbCAtIGV4cHI7XG5cdCAgICAgICAgICAgIHJldHVybiBleHByICsgZGlmZiAqIHBlcmNlbnQ7XG5cdCAgICAgICAgfS5iaW5kKHRoaXMsIHRoaXMuX2V4cHIsIG5ldyB0aGlzLmNvbnN0cnVjdG9yKHN1YmRpdiksIHBlcmNlbnQpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBBZGRzIHRoZSBjbG9jayB0aW1lIHRvIHRoZSB0aW1lIGV4cHJlc3Npb24gYXQgdGhlIFxuXHRcdCAqICBtb21lbnQgb2YgZXZhbHVhdGlvbi4gXG5cdFx0ICogIEByZXR1cm4gIHtUb25lLlRpbWV9ICB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLlRpbWUucHJvdG90eXBlLmFkZE5vdyA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB0aGlzLl9wbHVzTm93ID0gdHJ1ZTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgT3ZlcnJpZGUgdGhlIGRlZmF1bHQgdmFsdWUgcmV0dXJuIHdoZW4gbm8gYXJndW1lbnRzIGFyZSBwYXNzZWQgaW4uXG5cdFx0ICogIFRoZSBkZWZhdWx0IHZhbHVlIGlzICdub3cnXG5cdFx0ICogIEBvdmVycmlkZVxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5UaW1lLnByb3RvdHlwZS5fZGVmYXVsdEV4cHIgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdGhpcy5fcGx1c05vdyA9IHRydWU7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuX25vT3A7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIENvcGllcyB0aGUgdmFsdWUgb2YgdGltZSB0byB0aGlzIFRpbWVcblx0XHQgKiAgQHBhcmFtIHtUb25lLlRpbWV9IHRpbWVcblx0XHQgKiAgQHJldHVybiAge1RpbWV9XG5cdFx0ICovXG5cdCAgICBUb25lLlRpbWUucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAodGltZSkge1xuXHQgICAgICAgIFRvbmUuVGltZUJhc2UucHJvdG90eXBlLmNvcHkuY2FsbCh0aGlzLCB0aW1lKTtcblx0ICAgICAgICB0aGlzLl9wbHVzTm93ID0gdGltZS5fcGx1c05vdztcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvL0NPTlZFUlNJT05TLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblx0ICAgIC8qKlxuXHRcdCAqICBDb252ZXJ0IGEgVGltZSB0byBOb3RhdGlvbi4gVmFsdWVzIHdpbGwgYmUgdGhyZXNob2xkZWQgdG8gdGhlIG5lYXJlc3QgMTI4dGggbm90ZS4gXG5cdFx0ICogIEByZXR1cm4ge05vdGF0aW9ufSBcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAvL2lmIHRoZSBUcmFuc3BvcnQgaXMgYXQgMTIwYnBtOlxuXHRcdCAqIFRvbmUuVGltZSgyKS50b05vdGF0aW9uKCk7Ly9yZXR1cm5zIFwiMW1cIlxuXHRcdCAqL1xuXHQgICAgVG9uZS5UaW1lLnByb3RvdHlwZS50b05vdGF0aW9uID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciB0aW1lID0gdGhpcy50b1NlY29uZHMoKTtcblx0ICAgICAgICB2YXIgdGVzdE5vdGF0aW9ucyA9IFtcblx0ICAgICAgICAgICAgJzFtJyxcblx0ICAgICAgICAgICAgJzJuJyxcblx0ICAgICAgICAgICAgJzRuJyxcblx0ICAgICAgICAgICAgJzhuJyxcblx0ICAgICAgICAgICAgJzE2bicsXG5cdCAgICAgICAgICAgICczMm4nLFxuXHQgICAgICAgICAgICAnNjRuJyxcblx0ICAgICAgICAgICAgJzEyOG4nXG5cdCAgICAgICAgXTtcblx0ICAgICAgICB2YXIgcmV0Tm90YXRpb24gPSB0aGlzLl90b05vdGF0aW9uSGVscGVyKHRpbWUsIHRlc3ROb3RhdGlvbnMpO1xuXHQgICAgICAgIC8vdHJ5IHRoZSBzYW1lIHRoaW5nIGJ1dCB3aXRoIHRyaXBlbGV0c1xuXHQgICAgICAgIHZhciB0ZXN0VHJpcGxldE5vdGF0aW9ucyA9IFtcblx0ICAgICAgICAgICAgJzFtJyxcblx0ICAgICAgICAgICAgJzJuJyxcblx0ICAgICAgICAgICAgJzJ0Jyxcblx0ICAgICAgICAgICAgJzRuJyxcblx0ICAgICAgICAgICAgJzR0Jyxcblx0ICAgICAgICAgICAgJzhuJyxcblx0ICAgICAgICAgICAgJzh0Jyxcblx0ICAgICAgICAgICAgJzE2bicsXG5cdCAgICAgICAgICAgICcxNnQnLFxuXHQgICAgICAgICAgICAnMzJuJyxcblx0ICAgICAgICAgICAgJzMydCcsXG5cdCAgICAgICAgICAgICc2NG4nLFxuXHQgICAgICAgICAgICAnNjR0Jyxcblx0ICAgICAgICAgICAgJzEyOG4nXG5cdCAgICAgICAgXTtcblx0ICAgICAgICB2YXIgcmV0VHJpcGxldE5vdGF0aW9uID0gdGhpcy5fdG9Ob3RhdGlvbkhlbHBlcih0aW1lLCB0ZXN0VHJpcGxldE5vdGF0aW9ucyk7XG5cdCAgICAgICAgLy9jaG9vc2UgdGhlIHNpbXBsZXIgZXhwcmVzc2lvbiBvZiB0aGUgdHdvXG5cdCAgICAgICAgaWYgKHJldFRyaXBsZXROb3RhdGlvbi5zcGxpdCgnKycpLmxlbmd0aCA8IHJldE5vdGF0aW9uLnNwbGl0KCcrJykubGVuZ3RoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiByZXRUcmlwbGV0Tm90YXRpb247XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHJldE5vdGF0aW9uO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgSGVscGVyIG1ldGhvZCBmb3IgVG9uZS50b05vdGF0aW9uXG5cdFx0ICogIEBwYXJhbSB7TnVtYmVyfSB1bml0cyBcblx0XHQgKiAgQHBhcmFtIHtBcnJheX0gdGVzdE5vdGF0aW9uc1xuXHRcdCAqICBAcmV0dXJuIHtTdHJpbmd9XG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLlRpbWUucHJvdG90eXBlLl90b05vdGF0aW9uSGVscGVyID0gZnVuY3Rpb24gKHVuaXRzLCB0ZXN0Tm90YXRpb25zKSB7XG5cdCAgICAgICAgLy90aGUgdGhyZXNob2xkIGlzIHRoZSBsYXN0IHZhbHVlIGluIHRoZSBhcnJheVxuXHQgICAgICAgIHZhciB0aHJlc2hvbGQgPSB0aGlzLl9ub3RhdGlvblRvVW5pdHModGVzdE5vdGF0aW9uc1t0ZXN0Tm90YXRpb25zLmxlbmd0aCAtIDFdKTtcblx0ICAgICAgICB2YXIgcmV0Tm90YXRpb24gPSAnJztcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRlc3ROb3RhdGlvbnMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgdmFyIG5vdGF0aW9uVGltZSA9IHRoaXMuX25vdGF0aW9uVG9Vbml0cyh0ZXN0Tm90YXRpb25zW2ldKTtcblx0ICAgICAgICAgICAgLy9hY2NvdW50IGZvciBmbG9hdGluZyBwb2ludCBlcnJvcnMgKGkuZS4gcm91bmQgdXAgaWYgdGhlIHZhbHVlIGlzIDAuOTk5OTk5KVxuXHQgICAgICAgICAgICB2YXIgbXVsdGlwbGUgPSB1bml0cyAvIG5vdGF0aW9uVGltZTtcblx0ICAgICAgICAgICAgdmFyIGZsb2F0aW5nUG9pbnRFcnJvciA9IDAuMDAwMDAxO1xuXHQgICAgICAgICAgICBpZiAoMSAtIG11bHRpcGxlICUgMSA8IGZsb2F0aW5nUG9pbnRFcnJvcikge1xuXHQgICAgICAgICAgICAgICAgbXVsdGlwbGUgKz0gZmxvYXRpbmdQb2ludEVycm9yO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIG11bHRpcGxlID0gTWF0aC5mbG9vcihtdWx0aXBsZSk7XG5cdCAgICAgICAgICAgIGlmIChtdWx0aXBsZSA+IDApIHtcblx0ICAgICAgICAgICAgICAgIGlmIChtdWx0aXBsZSA9PT0gMSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldE5vdGF0aW9uICs9IHRlc3ROb3RhdGlvbnNbaV07XG5cdCAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldE5vdGF0aW9uICs9IG11bHRpcGxlLnRvU3RyaW5nKCkgKyAnKicgKyB0ZXN0Tm90YXRpb25zW2ldO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgdW5pdHMgLT0gbXVsdGlwbGUgKiBub3RhdGlvblRpbWU7XG5cdCAgICAgICAgICAgICAgICBpZiAodW5pdHMgPCB0aHJlc2hvbGQpIHtcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0Tm90YXRpb24gKz0gJyArICc7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKHJldE5vdGF0aW9uID09PSAnJykge1xuXHQgICAgICAgICAgICByZXROb3RhdGlvbiA9ICcwJztcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHJldE5vdGF0aW9uO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBDb252ZXJ0IGEgbm90YXRpb24gdmFsdWUgdG8gdGhlIGN1cnJlbnQgdW5pdHNcblx0XHQgKiAgQHBhcmFtICB7Tm90YXRpb259ICBub3RhdGlvbiBcblx0XHQgKiAgQHJldHVybiAge051bWJlcn0gXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLlRpbWUucHJvdG90eXBlLl9ub3RhdGlvblRvVW5pdHMgPSBmdW5jdGlvbiAobm90YXRpb24pIHtcblx0ICAgICAgICB2YXIgcHJpbWFyeUV4cHJzID0gdGhpcy5fcHJpbWFyeUV4cHJlc3Npb25zO1xuXHQgICAgICAgIHZhciBub3RhdGlvbkV4cHJzID0gW1xuXHQgICAgICAgICAgICBwcmltYXJ5RXhwcnMubixcblx0ICAgICAgICAgICAgcHJpbWFyeUV4cHJzLnQsXG5cdCAgICAgICAgICAgIHByaW1hcnlFeHBycy5tXG5cdCAgICAgICAgXTtcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vdGF0aW9uRXhwcnMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgdmFyIGV4cHIgPSBub3RhdGlvbkV4cHJzW2ldO1xuXHQgICAgICAgICAgICB2YXIgbWF0Y2ggPSBub3RhdGlvbi5tYXRjaChleHByLnJlZ2V4cCk7XG5cdCAgICAgICAgICAgIGlmIChtYXRjaCkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGV4cHIubWV0aG9kLmNhbGwodGhpcywgbWF0Y2hbMV0pO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBSZXR1cm4gdGhlIHRpbWUgZW5jb2RlZCBhcyBCYXJzOkJlYXRzOlNpeHRlZW50aHMuXG5cdFx0ICogIEByZXR1cm4gIHtCYXJzQmVhdHNTaXh0ZWVudGhzfVxuXHRcdCAqL1xuXHQgICAgVG9uZS5UaW1lLnByb3RvdHlwZS50b0JhcnNCZWF0c1NpeHRlZW50aHMgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIHF1YXJ0ZXJUaW1lID0gdGhpcy5fYmVhdHNUb1VuaXRzKDEpO1xuXHQgICAgICAgIHZhciBxdWFydGVycyA9IHRoaXMudG9TZWNvbmRzKCkgLyBxdWFydGVyVGltZTtcblx0ICAgICAgICB2YXIgbWVhc3VyZXMgPSBNYXRoLmZsb29yKHF1YXJ0ZXJzIC8gdGhpcy5fdGltZVNpZ25hdHVyZSgpKTtcblx0ICAgICAgICB2YXIgc2l4dGVlbnRocyA9IHF1YXJ0ZXJzICUgMSAqIDQ7XG5cdCAgICAgICAgcXVhcnRlcnMgPSBNYXRoLmZsb29yKHF1YXJ0ZXJzKSAlIHRoaXMuX3RpbWVTaWduYXR1cmUoKTtcblx0ICAgICAgICBzaXh0ZWVudGhzID0gc2l4dGVlbnRocy50b1N0cmluZygpO1xuXHQgICAgICAgIGlmIChzaXh0ZWVudGhzLmxlbmd0aCA+IDMpIHtcblx0ICAgICAgICAgICAgLy8gdGhlIGFkZGl0aW9uYWwgcGFyc2VGbG9hdCByZW1vdmVzIGluc2lnbmlmaWNhbnQgdHJhaWxpbmcgemVyb2VzXG5cdCAgICAgICAgICAgIHNpeHRlZW50aHMgPSBwYXJzZUZsb2F0KHBhcnNlRmxvYXQoc2l4dGVlbnRocykudG9GaXhlZCgzKSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBwcm9ncmVzcyA9IFtcblx0ICAgICAgICAgICAgbWVhc3VyZXMsXG5cdCAgICAgICAgICAgIHF1YXJ0ZXJzLFxuXHQgICAgICAgICAgICBzaXh0ZWVudGhzXG5cdCAgICAgICAgXTtcblx0ICAgICAgICByZXR1cm4gcHJvZ3Jlc3Muam9pbignOicpO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBSZXR1cm4gdGhlIHRpbWUgaW4gdGlja3MuXG5cdFx0ICogIEByZXR1cm4gIHtUaWNrc31cblx0XHQgKi9cblx0ICAgIFRvbmUuVGltZS5wcm90b3R5cGUudG9UaWNrcyA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgcXVhcnRlclRpbWUgPSB0aGlzLl9iZWF0c1RvVW5pdHMoMSk7XG5cdCAgICAgICAgdmFyIHF1YXJ0ZXJzID0gdGhpcy52YWx1ZU9mKCkgLyBxdWFydGVyVGltZTtcblx0ICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihxdWFydGVycyAqIFRvbmUuVHJhbnNwb3J0LlBQUSk7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFJldHVybiB0aGUgdGltZSBpbiBzYW1wbGVzXG5cdFx0ICogIEByZXR1cm4gIHtTYW1wbGVzfSAgXG5cdFx0ICovXG5cdCAgICBUb25lLlRpbWUucHJvdG90eXBlLnRvU2FtcGxlcyA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy50b1NlY29uZHMoKSAqIHRoaXMuY29udGV4dC5zYW1wbGVSYXRlO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBSZXR1cm4gdGhlIHRpbWUgYXMgYSBmcmVxdWVuY3kgdmFsdWVcblx0XHQgKiAgQHJldHVybiAge0ZyZXF1ZW5jeX0gXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogVG9uZS5UaW1lKDIpLnRvRnJlcXVlbmN5KCk7IC8vMC41XG5cdFx0ICovXG5cdCAgICBUb25lLlRpbWUucHJvdG90eXBlLnRvRnJlcXVlbmN5ID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHJldHVybiAxIC8gdGhpcy50b1NlY29uZHMoKTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgUmV0dXJuIHRoZSB0aW1lIGluIHNlY29uZHMuXG5cdFx0ICogIEByZXR1cm4gIHtTZWNvbmRzfSBcblx0XHQgKi9cblx0ICAgIFRvbmUuVGltZS5wcm90b3R5cGUudG9TZWNvbmRzID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHJldHVybiB0aGlzLnZhbHVlT2YoKTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgUmV0dXJuIHRoZSB0aW1lIGluIG1pbGxpc2Vjb25kcy5cblx0XHQgKiAgQHJldHVybiAge01pbGxpc2Vjb25kc30gXG5cdFx0ICovXG5cdCAgICBUb25lLlRpbWUucHJvdG90eXBlLnRvTWlsbGlzZWNvbmRzID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHJldHVybiB0aGlzLnRvU2Vjb25kcygpICogMTAwMDtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgUmV0dXJuIHRoZSB0aW1lIGluIHNlY29uZHMuXG5cdFx0ICogIEByZXR1cm4gIHtTZWNvbmRzfSBcblx0XHQgKi9cblx0ICAgIFRvbmUuVGltZS5wcm90b3R5cGUudmFsdWVPZiA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgdmFsID0gdGhpcy5fZXhwcigpO1xuXHQgICAgICAgIHJldHVybiB2YWwgKyAodGhpcy5fcGx1c05vdyA/IHRoaXMubm93KCkgOiAwKTtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVG9uZS5UaW1lO1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzIFRvbmUuRnJlcXVlbmN5IGlzIGEgcHJpbWl0aXZlIHR5cGUgZm9yIGVuY29kaW5nIEZyZXF1ZW5jeSB2YWx1ZXMuXG5cdFx0ICogICAgICAgICBFdmVudHVhbGx5IGFsbCB0aW1lIHZhbHVlcyBhcmUgZXZhbHVhdGVkIHRvIGhlcnR6XG5cdFx0ICogICAgICAgICB1c2luZyB0aGUgYGV2YWxgIG1ldGhvZC5cblx0XHQgKiAgQGNvbnN0cnVjdG9yXG5cdFx0ICogIEBleHRlbmRzIHtUb25lLlRpbWVCYXNlfVxuXHRcdCAqICBAcGFyYW0gIHtTdHJpbmd8TnVtYmVyfSAgdmFsICAgIFRoZSB0aW1lIHZhbHVlLlxuXHRcdCAqICBAcGFyYW0gIHtTdHJpbmc9fSAgdW5pdHMgIFRoZSB1bml0cyBvZiB0aGUgdmFsdWUuXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogVG9uZS5GcmVxdWVuY3koXCJDM1wiKSAvLyAyNjFcblx0XHQgKiBUb25lLkZyZXF1ZW5jeSgzOCwgXCJtaWRpXCIpIC8vXG5cdFx0ICogVG9uZS5GcmVxdWVuY3koXCJDM1wiKS50cmFuc3Bvc2UoNCk7XG5cdFx0ICovXG5cdCAgICBUb25lLkZyZXF1ZW5jeSA9IGZ1bmN0aW9uICh2YWwsIHVuaXRzKSB7XG5cdCAgICAgICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBUb25lLkZyZXF1ZW5jeSkge1xuXHQgICAgICAgICAgICBUb25lLlRpbWVCYXNlLmNhbGwodGhpcywgdmFsLCB1bml0cyk7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgcmV0dXJuIG5ldyBUb25lLkZyZXF1ZW5jeSh2YWwsIHVuaXRzKTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5GcmVxdWVuY3ksIFRvbmUuVGltZUJhc2UpO1xuXHQgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdCAgICAvL1x0QVVHTUVOVCBCQVNFIEVYUFJFU1NJT05TXG5cdCAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblx0ICAgIC8vY2xvbmUgdGhlIGV4cHJlc3Npb25zIHNvIHRoYXRcblx0ICAgIC8vd2UgY2FuIGFkZCBtb3JlIHdpdGhvdXQgbW9kaWZ5aW5nIHRoZSBvcmlnaW5hbFxuXHQgICAgVG9uZS5GcmVxdWVuY3kucHJvdG90eXBlLl9wcmltYXJ5RXhwcmVzc2lvbnMgPSBPYmplY3QuY3JlYXRlKFRvbmUuVGltZUJhc2UucHJvdG90eXBlLl9wcmltYXJ5RXhwcmVzc2lvbnMpO1xuXHQgICAgLypcblx0XHQgKiAgbWlkaSB0eXBlIHByaW1hcnkgZXhwcmVzc2lvblxuXHRcdCAqICBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5GcmVxdWVuY3kucHJvdG90eXBlLl9wcmltYXJ5RXhwcmVzc2lvbnMubWlkaSA9IHtcblx0ICAgICAgICByZWdleHA6IC9eKFxcZCsoPzpcXC5cXGQrKT9taWRpKS8sXG5cdCAgICAgICAgbWV0aG9kOiBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMubWlkaVRvRnJlcXVlbmN5KHZhbHVlKTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgLypcblx0XHQgKiAgbm90ZSB0eXBlIHByaW1hcnkgZXhwcmVzc2lvblxuXHRcdCAqICBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5GcmVxdWVuY3kucHJvdG90eXBlLl9wcmltYXJ5RXhwcmVzc2lvbnMubm90ZSA9IHtcblx0ICAgICAgICByZWdleHA6IC9eKFthLWddezF9KD86YnwjfHh8YmIpPykoLT9bMC05XSspL2ksXG5cdCAgICAgICAgbWV0aG9kOiBmdW5jdGlvbiAocGl0Y2gsIG9jdGF2ZSkge1xuXHQgICAgICAgICAgICB2YXIgaW5kZXggPSBub3RlVG9TY2FsZUluZGV4W3BpdGNoLnRvTG93ZXJDYXNlKCldO1xuXHQgICAgICAgICAgICB2YXIgbm90ZU51bWJlciA9IGluZGV4ICsgKHBhcnNlSW50KG9jdGF2ZSkgKyAxKSAqIDEyO1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5taWRpVG9GcmVxdWVuY3kobm90ZU51bWJlcik7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIC8qXG5cdFx0ICogIEJlYXRzQmFyc1NpeHRlZW50aHMgdHlwZSBwcmltYXJ5IGV4cHJlc3Npb25cblx0XHQgKiAgQHR5cGUge09iamVjdH1cblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuRnJlcXVlbmN5LnByb3RvdHlwZS5fcHJpbWFyeUV4cHJlc3Npb25zLnRyID0ge1xuXHQgICAgICAgIHJlZ2V4cDogL14oXFxkKyg/OlxcLlxcZCspPyk6KFxcZCsoPzpcXC5cXGQrKT8pOj8oXFxkKyg/OlxcLlxcZCspPyk/Lyxcblx0ICAgICAgICBtZXRob2Q6IGZ1bmN0aW9uIChtLCBxLCBzKSB7XG5cdCAgICAgICAgICAgIHZhciB0b3RhbCA9IDE7XG5cdCAgICAgICAgICAgIGlmIChtICYmIG0gIT09ICcwJykge1xuXHQgICAgICAgICAgICAgICAgdG90YWwgKj0gdGhpcy5fYmVhdHNUb1VuaXRzKHRoaXMuX3RpbWVTaWduYXR1cmUoKSAqIHBhcnNlRmxvYXQobSkpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGlmIChxICYmIHEgIT09ICcwJykge1xuXHQgICAgICAgICAgICAgICAgdG90YWwgKj0gdGhpcy5fYmVhdHNUb1VuaXRzKHBhcnNlRmxvYXQocSkpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGlmIChzICYmIHMgIT09ICcwJykge1xuXHQgICAgICAgICAgICAgICAgdG90YWwgKj0gdGhpcy5fYmVhdHNUb1VuaXRzKHBhcnNlRmxvYXQocykgLyA0KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gdG90YWw7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQgICAgLy9cdEVYUFJFU1NJT05TXG5cdCAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblx0ICAgIC8qKlxuXHRcdCAqICBUcmFuc3Bvc2VzIHRoZSBmcmVxdWVuY3kgYnkgdGhlIGdpdmVuIG51bWJlciBvZiBzZW1pdG9uZXMuXG5cdFx0ICogIEBwYXJhbSAge0ludGVydmFsfSAgaW50ZXJ2YWxcblx0XHQgKiAgQHJldHVybiAge1RvbmUuRnJlcXVlbmN5fSB0aGlzXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogVG9uZS5GcmVxdWVuY3koXCJBNFwiKS50cmFuc3Bvc2UoMyk7IC8vXCJDNVwiXG5cdFx0ICovXG5cdCAgICBUb25lLkZyZXF1ZW5jeS5wcm90b3R5cGUudHJhbnNwb3NlID0gZnVuY3Rpb24gKGludGVydmFsKSB7XG5cdCAgICAgICAgdGhpcy5fZXhwciA9IGZ1bmN0aW9uIChleHByLCBpbnRlcnZhbCkge1xuXHQgICAgICAgICAgICB2YXIgdmFsID0gZXhwcigpO1xuXHQgICAgICAgICAgICByZXR1cm4gdmFsICogVG9uZS5pbnRlcnZhbFRvRnJlcXVlbmN5UmF0aW8oaW50ZXJ2YWwpO1xuXHQgICAgICAgIH0uYmluZCh0aGlzLCB0aGlzLl9leHByLCBpbnRlcnZhbCk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFRha2VzIGFuIGFycmF5IG9mIHNlbWl0b25lIGludGVydmFscyBhbmQgcmV0dXJuc1xuXHRcdCAqICBhbiBhcnJheSBvZiBmcmVxdWVuY2llcyB0cmFuc3Bvc2VkIGJ5IHRob3NlIGludGVydmFscy5cblx0XHQgKiAgQHBhcmFtICB7QXJyYXl9ICBpbnRlcnZhbHNcblx0XHQgKiAgQHJldHVybiAge1RvbmUuRnJlcXVlbmN5fSB0aGlzXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogVG9uZS5GcmVxdWVuY3koXCJBNFwiKS5oYXJtb25pemUoWzAsIDMsIDddKTsgLy9bXCJBNFwiLCBcIkM1XCIsIFwiRTVcIl1cblx0XHQgKi9cblx0ICAgIFRvbmUuRnJlcXVlbmN5LnByb3RvdHlwZS5oYXJtb25pemUgPSBmdW5jdGlvbiAoaW50ZXJ2YWxzKSB7XG5cdCAgICAgICAgdGhpcy5fZXhwciA9IGZ1bmN0aW9uIChleHByLCBpbnRlcnZhbHMpIHtcblx0ICAgICAgICAgICAgdmFyIHZhbCA9IGV4cHIoKTtcblx0ICAgICAgICAgICAgdmFyIHJldCA9IFtdO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGludGVydmFscy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgcmV0W2ldID0gdmFsICogVG9uZS5pbnRlcnZhbFRvRnJlcXVlbmN5UmF0aW8oaW50ZXJ2YWxzW2ldKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gcmV0O1xuXHQgICAgICAgIH0uYmluZCh0aGlzLCB0aGlzLl9leHByLCBpbnRlcnZhbHMpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQgICAgLy9cdFVOSVQgQ09OVkVSU0lPTlNcblx0ICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQgICAgLyoqXG5cdFx0ICogIFJldHVybiB0aGUgdmFsdWUgb2YgdGhlIGZyZXF1ZW5jeSBhcyBhIE1JREkgbm90ZVxuXHRcdCAqICBAcmV0dXJuICB7TUlESX1cblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiBUb25lLkZyZXF1ZW5jeShcIkM0XCIpLnRvTWlkaSgpOyAvLzYwXG5cdFx0ICovXG5cdCAgICBUb25lLkZyZXF1ZW5jeS5wcm90b3R5cGUudG9NaWRpID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHJldHVybiB0aGlzLmZyZXF1ZW5jeVRvTWlkaSh0aGlzLnZhbHVlT2YoKSk7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFJldHVybiB0aGUgdmFsdWUgb2YgdGhlIGZyZXF1ZW5jeSBpbiBTY2llbnRpZmljIFBpdGNoIE5vdGF0aW9uXG5cdFx0ICogIEByZXR1cm4gIHtOb3RlfVxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIFRvbmUuRnJlcXVlbmN5KDY5LCBcIm1pZGlcIikudG9Ob3RlKCk7IC8vXCJBNFwiXG5cdFx0ICovXG5cdCAgICBUb25lLkZyZXF1ZW5jeS5wcm90b3R5cGUudG9Ob3RlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBmcmVxID0gdGhpcy52YWx1ZU9mKCk7XG5cdCAgICAgICAgdmFyIGxvZyA9IE1hdGgubG9nKGZyZXEgLyBUb25lLkZyZXF1ZW5jeS5BNCkgLyBNYXRoLkxOMjtcblx0ICAgICAgICB2YXIgbm90ZU51bWJlciA9IE1hdGgucm91bmQoMTIgKiBsb2cpICsgNTc7XG5cdCAgICAgICAgdmFyIG9jdGF2ZSA9IE1hdGguZmxvb3Iobm90ZU51bWJlciAvIDEyKTtcblx0ICAgICAgICBpZiAob2N0YXZlIDwgMCkge1xuXHQgICAgICAgICAgICBub3RlTnVtYmVyICs9IC0xMiAqIG9jdGF2ZTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIG5vdGVOYW1lID0gc2NhbGVJbmRleFRvTm90ZVtub3RlTnVtYmVyICUgMTJdO1xuXHQgICAgICAgIHJldHVybiBub3RlTmFtZSArIG9jdGF2ZS50b1N0cmluZygpO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBSZXR1cm4gdGhlIGR1cmF0aW9uIG9mIG9uZSBjeWNsZSBpbiBzZWNvbmRzLlxuXHRcdCAqICBAcmV0dXJuICB7U2Vjb25kc31cblx0XHQgKi9cblx0ICAgIFRvbmUuRnJlcXVlbmN5LnByb3RvdHlwZS50b1NlY29uZHMgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgcmV0dXJuIDEgLyB0aGlzLnZhbHVlT2YoKTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgUmV0dXJuIHRoZSB2YWx1ZSBpbiBIZXJ0elxuXHRcdCAqICBAcmV0dXJuICB7RnJlcXVlbmN5fVxuXHRcdCAqL1xuXHQgICAgVG9uZS5GcmVxdWVuY3kucHJvdG90eXBlLnRvRnJlcXVlbmN5ID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHJldHVybiB0aGlzLnZhbHVlT2YoKTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgUmV0dXJuIHRoZSBkdXJhdGlvbiBvZiBvbmUgY3ljbGUgaW4gdGlja3Ncblx0XHQgKiAgQHJldHVybiAge1RpY2tzfVxuXHRcdCAqL1xuXHQgICAgVG9uZS5GcmVxdWVuY3kucHJvdG90eXBlLnRvVGlja3MgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIHF1YXJ0ZXJUaW1lID0gdGhpcy5fYmVhdHNUb1VuaXRzKDEpO1xuXHQgICAgICAgIHZhciBxdWFydGVycyA9IHRoaXMudmFsdWVPZigpIC8gcXVhcnRlclRpbWU7XG5cdCAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IocXVhcnRlcnMgKiBUb25lLlRyYW5zcG9ydC5QUFEpO1xuXHQgICAgfTtcblx0ICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQgICAgLy9cdFVOSVQgQ09OVkVSU0lPTlMgSEVMUEVSU1xuXHQgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdCAgICAvKipcblx0XHQgKiAgUmV0dXJucyB0aGUgdmFsdWUgb2YgYSBmcmVxdWVuY3kgaW4gdGhlIGN1cnJlbnQgdW5pdHNcblx0XHQgKiAgQHBhcmFtIHtGcmVxdWVuY3l9IGZyZXFcblx0XHQgKiAgQHJldHVybiAge051bWJlcn1cblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuRnJlcXVlbmN5LnByb3RvdHlwZS5fZnJlcXVlbmN5VG9Vbml0cyA9IGZ1bmN0aW9uIChmcmVxKSB7XG5cdCAgICAgICAgcmV0dXJuIGZyZXE7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFJldHVybnMgdGhlIHZhbHVlIG9mIGEgdGljayBpbiB0aGUgY3VycmVudCB0aW1lIHVuaXRzXG5cdFx0ICogIEBwYXJhbSB7VGlja3N9IHRpY2tzXG5cdFx0ICogIEByZXR1cm4gIHtOdW1iZXJ9XG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLkZyZXF1ZW5jeS5wcm90b3R5cGUuX3RpY2tzVG9Vbml0cyA9IGZ1bmN0aW9uICh0aWNrcykge1xuXHQgICAgICAgIHJldHVybiAxIC8gKHRpY2tzICogNjAgLyAoVG9uZS5UcmFuc3BvcnQuYnBtLnZhbHVlICogVG9uZS5UcmFuc3BvcnQuUFBRKSk7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFJldHVybiB0aGUgdmFsdWUgb2YgdGhlIGJlYXRzIGluIHRoZSBjdXJyZW50IHVuaXRzXG5cdFx0ICogIEBwYXJhbSB7TnVtYmVyfSBiZWF0c1xuXHRcdCAqICBAcmV0dXJuICB7TnVtYmVyfVxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5GcmVxdWVuY3kucHJvdG90eXBlLl9iZWF0c1RvVW5pdHMgPSBmdW5jdGlvbiAoYmVhdHMpIHtcblx0ICAgICAgICByZXR1cm4gMSAvIFRvbmUuVGltZUJhc2UucHJvdG90eXBlLl9iZWF0c1RvVW5pdHMuY2FsbCh0aGlzLCBiZWF0cyk7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFJldHVybnMgdGhlIHZhbHVlIG9mIGEgc2Vjb25kIGluIHRoZSBjdXJyZW50IHVuaXRzXG5cdFx0ICogIEBwYXJhbSB7U2Vjb25kc30gc2Vjb25kc1xuXHRcdCAqICBAcmV0dXJuICB7TnVtYmVyfVxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5GcmVxdWVuY3kucHJvdG90eXBlLl9zZWNvbmRzVG9Vbml0cyA9IGZ1bmN0aW9uIChzZWNvbmRzKSB7XG5cdCAgICAgICAgcmV0dXJuIDEgLyBzZWNvbmRzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgZGVmYXVsdCB1bml0cyBpZiBub25lIGFyZSBnaXZlbi5cblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuRnJlcXVlbmN5LnByb3RvdHlwZS5fZGVmYXVsdFVuaXRzID0gJ2h6Jztcblx0ICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQgICAgLy9cdEZSRVFVRU5DWSBDT05WRVJTSU9OU1xuXHQgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdCAgICAvKipcblx0XHQgKiAgTm90ZSB0byBzY2FsZSBpbmRleFxuXHRcdCAqICBAdHlwZSAge09iamVjdH1cblx0XHQgKi9cblx0ICAgIHZhciBub3RlVG9TY2FsZUluZGV4ID0ge1xuXHQgICAgICAgICdjYmInOiAtMixcblx0ICAgICAgICAnY2InOiAtMSxcblx0ICAgICAgICAnYyc6IDAsXG5cdCAgICAgICAgJ2MjJzogMSxcblx0ICAgICAgICAnY3gnOiAyLFxuXHQgICAgICAgICdkYmInOiAwLFxuXHQgICAgICAgICdkYic6IDEsXG5cdCAgICAgICAgJ2QnOiAyLFxuXHQgICAgICAgICdkIyc6IDMsXG5cdCAgICAgICAgJ2R4JzogNCxcblx0ICAgICAgICAnZWJiJzogMixcblx0ICAgICAgICAnZWInOiAzLFxuXHQgICAgICAgICdlJzogNCxcblx0ICAgICAgICAnZSMnOiA1LFxuXHQgICAgICAgICdleCc6IDYsXG5cdCAgICAgICAgJ2ZiYic6IDMsXG5cdCAgICAgICAgJ2ZiJzogNCxcblx0ICAgICAgICAnZic6IDUsXG5cdCAgICAgICAgJ2YjJzogNixcblx0ICAgICAgICAnZngnOiA3LFxuXHQgICAgICAgICdnYmInOiA1LFxuXHQgICAgICAgICdnYic6IDYsXG5cdCAgICAgICAgJ2cnOiA3LFxuXHQgICAgICAgICdnIyc6IDgsXG5cdCAgICAgICAgJ2d4JzogOSxcblx0ICAgICAgICAnYWJiJzogNyxcblx0ICAgICAgICAnYWInOiA4LFxuXHQgICAgICAgICdhJzogOSxcblx0ICAgICAgICAnYSMnOiAxMCxcblx0ICAgICAgICAnYXgnOiAxMSxcblx0ICAgICAgICAnYmJiJzogOSxcblx0ICAgICAgICAnYmInOiAxMCxcblx0ICAgICAgICAnYic6IDExLFxuXHQgICAgICAgICdiIyc6IDEyLFxuXHQgICAgICAgICdieCc6IDEzXG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIHNjYWxlIGluZGV4IHRvIG5vdGUgKHNoYXJwcylcblx0XHQgKiAgQHR5cGUgIHtBcnJheX1cblx0XHQgKi9cblx0ICAgIHZhciBzY2FsZUluZGV4VG9Ob3RlID0gW1xuXHQgICAgICAgICdDJyxcblx0ICAgICAgICAnQyMnLFxuXHQgICAgICAgICdEJyxcblx0ICAgICAgICAnRCMnLFxuXHQgICAgICAgICdFJyxcblx0ICAgICAgICAnRicsXG5cdCAgICAgICAgJ0YjJyxcblx0ICAgICAgICAnRycsXG5cdCAgICAgICAgJ0cjJyxcblx0ICAgICAgICAnQScsXG5cdCAgICAgICAgJ0EjJyxcblx0ICAgICAgICAnQidcblx0ICAgIF07XG5cdCAgICAvKipcblx0XHQgKiAgVGhlIFtjb25jZXJ0IHBpdGNoXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Db25jZXJ0X3BpdGNoKVxuXHRcdCAqICBBNCdzIHZhbHVlcyBpbiBIZXJ0ei5cblx0XHQgKiAgQHR5cGUge0ZyZXF1ZW5jeX1cblx0XHQgKiAgQHN0YXRpY1xuXHRcdCAqL1xuXHQgICAgVG9uZS5GcmVxdWVuY3kuQTQgPSA0NDA7XG5cdCAgICAvKipcblx0XHQgKiAgQ29udmVydCBhIE1JREkgbm90ZSB0byBmcmVxdWVuY3kgdmFsdWUuXG5cdFx0ICogIEBwYXJhbSAge01JREl9IG1pZGkgVGhlIG1pZGkgbnVtYmVyIHRvIGNvbnZlcnQuXG5cdFx0ICogIEByZXR1cm4ge0ZyZXF1ZW5jeX0gdGhlIGNvcnJlc3BvbmRpbmcgZnJlcXVlbmN5IHZhbHVlXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogdG9uZS5taWRpVG9GcmVxdWVuY3koNjkpOyAvLyByZXR1cm5zIDQ0MFxuXHRcdCAqL1xuXHQgICAgVG9uZS5GcmVxdWVuY3kucHJvdG90eXBlLm1pZGlUb0ZyZXF1ZW5jeSA9IGZ1bmN0aW9uIChtaWRpKSB7XG5cdCAgICAgICAgcmV0dXJuIFRvbmUuRnJlcXVlbmN5LkE0ICogTWF0aC5wb3coMiwgKG1pZGkgLSA2OSkgLyAxMik7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIENvbnZlcnQgYSBmcmVxdWVuY3kgdmFsdWUgdG8gYSBNSURJIG5vdGUuXG5cdFx0ICogIEBwYXJhbSB7RnJlcXVlbmN5fSBmcmVxdWVuY3kgVGhlIHZhbHVlIHRvIGZyZXF1ZW5jeSB2YWx1ZSB0byBjb252ZXJ0LlxuXHRcdCAqICBAcmV0dXJucyAge01JREl9XG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogdG9uZS5taWRpVG9GcmVxdWVuY3koNDQwKTsgLy8gcmV0dXJucyA2OVxuXHRcdCAqL1xuXHQgICAgVG9uZS5GcmVxdWVuY3kucHJvdG90eXBlLmZyZXF1ZW5jeVRvTWlkaSA9IGZ1bmN0aW9uIChmcmVxdWVuY3kpIHtcblx0ICAgICAgICByZXR1cm4gNjkgKyBNYXRoLnJvdW5kKDEyICogTWF0aC5sb2coZnJlcXVlbmN5IC8gVG9uZS5GcmVxdWVuY3kuQTQpIC8gTWF0aC5MTjIpO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLkZyZXF1ZW5jeTtcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyBUb25lLlRyYW5zcG9ydFRpbWUgaXMgYSB0aGUgdGltZSBhbG9uZyB0aGUgVHJhbnNwb3J0J3Ncblx0XHQgKiAgICAgICAgIHRpbWVsaW5lLiBJdCBpcyBzaW1pbGFyIHRvIFRvbmUuVGltZSwgYnV0IGluc3RlYWQgb2YgZXZhbHVhdGluZ1xuXHRcdCAqICAgICAgICAgYWdhaW5zdCB0aGUgQXVkaW9Db250ZXh0J3MgY2xvY2ssIGl0IGlzIGV2YWx1YXRlZCBhZ2FpbnN0XG5cdFx0ICogICAgICAgICB0aGUgVHJhbnNwb3J0J3MgcG9zaXRpb24uIFNlZSBbVHJhbnNwb3J0VGltZSB3aWtpXShodHRwczovL2dpdGh1Yi5jb20vVG9uZWpzL1RvbmUuanMvd2lraS9UcmFuc3BvcnRUaW1lKS5cblx0XHQgKiAgQGNvbnN0cnVjdG9yXG5cdFx0ICogIEBwYXJhbSAge1RpbWV9ICB2YWwgICAgVGhlIHRpbWUgdmFsdWUgYXMgYSBudW1iZXIgb3Igc3RyaW5nXG5cdFx0ICogIEBwYXJhbSAge1N0cmluZz19ICB1bml0cyAgVW5pdCB2YWx1ZXNcblx0XHQgKiAgQGV4dGVuZHMge1RvbmUuVGltZX1cblx0XHQgKi9cblx0ICAgIFRvbmUuVHJhbnNwb3J0VGltZSA9IGZ1bmN0aW9uICh2YWwsIHVuaXRzKSB7XG5cdCAgICAgICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBUb25lLlRyYW5zcG9ydFRpbWUpIHtcblx0ICAgICAgICAgICAgVG9uZS5UaW1lLmNhbGwodGhpcywgdmFsLCB1bml0cyk7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgcmV0dXJuIG5ldyBUb25lLlRyYW5zcG9ydFRpbWUodmFsLCB1bml0cyk7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuVHJhbnNwb3J0VGltZSwgVG9uZS5UaW1lKTtcblx0ICAgIC8vY2xvbmUgdGhlIGV4cHJlc3Npb25zIHNvIHRoYXQgXG5cdCAgICAvL3dlIGNhbiBhZGQgbW9yZSB3aXRob3V0IG1vZGlmeWluZyB0aGUgb3JpZ2luYWxcblx0ICAgIFRvbmUuVHJhbnNwb3J0VGltZS5wcm90b3R5cGUuX3VuYXJ5RXhwcmVzc2lvbnMgPSBPYmplY3QuY3JlYXRlKFRvbmUuVGltZS5wcm90b3R5cGUuX3VuYXJ5RXhwcmVzc2lvbnMpO1xuXHQgICAgLyoqXG5cdFx0ICogIEFkZHMgYW4gYWRkaXRpb25hbCB1bmFyeSBleHByZXNzaW9uXG5cdFx0ICogIHdoaWNoIHF1YW50aXplcyB2YWx1ZXMgdG8gdGhlIG5leHQgc3ViZGl2aXNpb25cblx0XHQgKiAgQHR5cGUge09iamVjdH1cblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuVHJhbnNwb3J0VGltZS5wcm90b3R5cGUuX3VuYXJ5RXhwcmVzc2lvbnMucXVhbnRpemUgPSB7XG5cdCAgICAgICAgcmVnZXhwOiAvXkAvLFxuXHQgICAgICAgIG1ldGhvZDogZnVuY3Rpb24gKHJoKSB7XG5cdCAgICAgICAgICAgIHZhciBzdWJkaXZpc2lvbiA9IHRoaXMuX3NlY29uZHNUb1RpY2tzKHJoKCkpO1xuXHQgICAgICAgICAgICB2YXIgbXVsdGlwbGUgPSBNYXRoLmNlaWwoVG9uZS5UcmFuc3BvcnQudGlja3MgLyBzdWJkaXZpc2lvbik7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl90aWNrc1RvVW5pdHMobXVsdGlwbGUgKiBzdWJkaXZpc2lvbik7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBDb252ZXJ0IHNlY29uZHMgaW50byB0aWNrc1xuXHRcdCAqICBAcGFyYW0ge1NlY29uZHN9IHNlY29uZHNcblx0XHQgKiAgQHJldHVybiAge1RpY2tzfVxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5UcmFuc3BvcnRUaW1lLnByb3RvdHlwZS5fc2Vjb25kc1RvVGlja3MgPSBmdW5jdGlvbiAoc2Vjb25kcykge1xuXHQgICAgICAgIHZhciBxdWFydGVyVGltZSA9IHRoaXMuX2JlYXRzVG9Vbml0cygxKTtcblx0ICAgICAgICB2YXIgcXVhcnRlcnMgPSBzZWNvbmRzIC8gcXVhcnRlclRpbWU7XG5cdCAgICAgICAgcmV0dXJuIE1hdGgucm91bmQocXVhcnRlcnMgKiBUb25lLlRyYW5zcG9ydC5QUFEpO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBFdmFsdWF0ZSB0aGUgdGltZSBleHByZXNzaW9uLiBSZXR1cm5zIHZhbHVlcyBpbiB0aWNrc1xuXHRcdCAqICBAcmV0dXJuIHtUaWNrc31cblx0XHQgKi9cblx0ICAgIFRvbmUuVHJhbnNwb3J0VGltZS5wcm90b3R5cGUudmFsdWVPZiA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgdmFsID0gdGhpcy5fc2Vjb25kc1RvVGlja3ModGhpcy5fZXhwcigpKTtcblx0ICAgICAgICByZXR1cm4gdmFsICsgKHRoaXMuX3BsdXNOb3cgPyBUb25lLlRyYW5zcG9ydC50aWNrcyA6IDApO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBSZXR1cm4gdGhlIHRpbWUgaW4gdGlja3MuXG5cdFx0ICogIEByZXR1cm4gIHtUaWNrc31cblx0XHQgKi9cblx0ICAgIFRvbmUuVHJhbnNwb3J0VGltZS5wcm90b3R5cGUudG9UaWNrcyA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy52YWx1ZU9mKCk7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFJldHVybiB0aGUgdGltZSBpbiBzZWNvbmRzLlxuXHRcdCAqICBAcmV0dXJuICB7U2Vjb25kc31cblx0XHQgKi9cblx0ICAgIFRvbmUuVHJhbnNwb3J0VGltZS5wcm90b3R5cGUudG9TZWNvbmRzID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciB2YWwgPSB0aGlzLl9leHByKCk7XG5cdCAgICAgICAgcmV0dXJuIHZhbCArICh0aGlzLl9wbHVzTm93ID8gVG9uZS5UcmFuc3BvcnQuc2Vjb25kcyA6IDApO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBSZXR1cm4gdGhlIHRpbWUgYXMgYSBmcmVxdWVuY3kgdmFsdWVcblx0XHQgKiAgQHJldHVybiAge0ZyZXF1ZW5jeX0gXG5cdFx0ICovXG5cdCAgICBUb25lLlRyYW5zcG9ydFRpbWUucHJvdG90eXBlLnRvRnJlcXVlbmN5ID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHJldHVybiAxIC8gdGhpcy50b1NlY29uZHMoKTtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVG9uZS5UcmFuc3BvcnRUaW1lO1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblx0ICAgIC8vXHRUWVBFU1xuXHQgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdCAgICAvKipcblx0XHQgKiBVbml0cyB3aGljaCBhIHZhbHVlIGNhbiB0YWtlIG9uLlxuXHRcdCAqIEBlbnVtIHtTdHJpbmd9XG5cdFx0ICovXG5cdCAgICBUb25lLlR5cGUgPSB7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgRGVmYXVsdCB1bml0c1xuXHRcdFx0ICogIEB0eXBlZGVmIHtEZWZhdWx0fVxuXHRcdFx0ICovXG5cdCAgICAgICAgRGVmYXVsdDogJ251bWJlcicsXG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGltZSBjYW4gYmUgZGVzY3JpYmVkIGluIGEgbnVtYmVyIG9mIHdheXMuIFJlYWQgbW9yZSBbVGltZV0oaHR0cHM6Ly9naXRodWIuY29tL1RvbmVqcy9Ub25lLmpzL3dpa2kvVGltZSkuXG5cdFx0XHQgKlxuXHRcdFx0ICogICogTnVtYmVycywgd2hpY2ggd2lsbCBiZSB0YWtlbiBsaXRlcmFsbHkgYXMgdGhlIHRpbWUgKGluIHNlY29uZHMpLlxuXHRcdFx0ICogICogTm90YXRpb24sIChcIjRuXCIsIFwiOHRcIikgZGVzY3JpYmVzIHRpbWUgaW4gQlBNIGFuZCB0aW1lIHNpZ25hdHVyZSByZWxhdGl2ZSB2YWx1ZXMuXG5cdFx0XHQgKiAgKiBUcmFuc3BvcnRUaW1lLCAoXCI0OjM6MlwiKSB3aWxsIGFsc28gcHJvdmlkZSB0ZW1wbyBhbmQgdGltZSBzaWduYXR1cmUgcmVsYXRpdmUgdGltZXNcblx0XHRcdCAqICBpbiB0aGUgZm9ybSBCQVJTOlFVQVJURVJTOlNJWFRFRU5USFMuXG5cdFx0XHQgKiAgKiBGcmVxdWVuY3ksIChcIjhoelwiKSBpcyBjb252ZXJ0ZWQgdG8gdGhlIGxlbmd0aCBvZiB0aGUgY3ljbGUgaW4gc2Vjb25kcy5cblx0XHRcdCAqICAqIE5vdy1SZWxhdGl2ZSwgKFwiKzFcIikgcHJlZml4IGFueSBvZiB0aGUgYWJvdmUgd2l0aCBcIitcIiBhbmQgaXQgd2lsbCBiZSBpbnRlcnByZXRlZCBhc1xuXHRcdFx0ICogIFwidGhlIGN1cnJlbnQgdGltZSBwbHVzIHdoYXRldmVyIGV4cHJlc3Npb24gZm9sbG93c1wiLlxuXHRcdFx0ICogICogRXhwcmVzc2lvbnMsIChcIjM6MCArIDIgLSAoMW0gLyA3KVwiKSBhbnkgb2YgdGhlIGFib3ZlIGNhbiBhbHNvIGJlIGNvbWJpbmVkXG5cdFx0XHQgKiAgaW50byBhIG1hdGhlbWF0aWNhbCBleHByZXNzaW9uIHdoaWNoIHdpbGwgYmUgZXZhbHVhdGVkIHRvIGNvbXB1dGUgdGhlIGRlc2lyZWQgdGltZS5cblx0XHRcdCAqICAqIE5vIEFyZ3VtZW50LCBmb3IgbWV0aG9kcyB3aGljaCBhY2NlcHQgdGltZSwgbm8gYXJndW1lbnQgd2lsbCBiZSBpbnRlcnByZXRlZCBhc1xuXHRcdFx0ICogIFwibm93XCIgKGkuZS4gdGhlIGN1cnJlbnRUaW1lKS5cblx0XHRcdCAqXG5cdFx0XHQgKiAgQHR5cGVkZWYge1RpbWV9XG5cdFx0XHQgKi9cblx0ICAgICAgICBUaW1lOiAndGltZScsXG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgRnJlcXVlbmN5IGNhbiBiZSBkZXNjcmliZWQgc2ltaWxhciB0byB0aW1lLCBleGNlcHQgdWx0aW1hdGVseSB0aGVcblx0XHRcdCAqICB2YWx1ZXMgYXJlIGNvbnZlcnRlZCB0byBmcmVxdWVuY3kgaW5zdGVhZCBvZiBzZWNvbmRzLiBBIG51bWJlclxuXHRcdFx0ICogIGlzIHRha2VuIGxpdGVyYWxseSBhcyB0aGUgdmFsdWUgaW4gaGVydHouIEFkZGl0aW9uYWxseSBhbnkgb2YgdGhlXG5cdFx0XHQgKiAgVGltZSBlbmNvZGluZ3MgY2FuIGJlIHVzZWQuIE5vdGUgbmFtZXMgaW4gdGhlIGZvcm1cblx0XHRcdCAqICBvZiBOT1RFIE9DVEFWRSAoaS5lLiBDNCkgYXJlIGFsc28gYWNjZXB0ZWQgYW5kIGNvbnZlcnRlZCB0byB0aGVpclxuXHRcdFx0ICogIGZyZXF1ZW5jeSB2YWx1ZS5cblx0XHRcdCAqICBAdHlwZWRlZiB7RnJlcXVlbmN5fVxuXHRcdFx0ICovXG5cdCAgICAgICAgRnJlcXVlbmN5OiAnZnJlcXVlbmN5Jyxcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUcmFuc3BvcnRUaW1lIGRlc2NyaWJlcyBhIHBvc2l0aW9uIGFsb25nIHRoZSBUcmFuc3BvcnQncyB0aW1lbGluZS4gSXQgaXNcblx0XHRcdCAqICBzaW1pbGFyIHRvIFRpbWUgaW4gdGhhdCBpdCB1c2VzIGFsbCB0aGUgc2FtZSBlbmNvZGluZ3MsIGJ1dCBUcmFuc3BvcnRUaW1lIHNwZWNpZmljYWxseVxuXHRcdFx0ICogIHBlcnRhaW5zIHRvIHRoZSBUcmFuc3BvcnQncyB0aW1lbGluZSwgd2hpY2ggaXMgc3RhcnRhYmxlLCBzdG9wcGFibGUsIGxvb3BhYmxlLCBhbmQgc2Vla2FibGUuXG5cdFx0XHQgKiAgW1JlYWQgbW9yZV0oaHR0cHM6Ly9naXRodWIuY29tL1RvbmVqcy9Ub25lLmpzL3dpa2kvVHJhbnNwb3J0VGltZSlcblx0XHRcdCAqICBAdHlwZWRlZiB7VHJhbnNwb3J0VGltZX1cblx0XHRcdCAqL1xuXHQgICAgICAgIFRyYW5zcG9ydFRpbWU6ICd0cmFuc3BvcnRUaW1lJyxcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaWNrcyBhcmUgdGhlIGJhc2ljIHN1YnVuaXQgb2YgdGhlIFRyYW5zcG9ydC4gVGhleSBhcmVcblx0XHRcdCAqICB0aGUgc21hbGxlc3QgdW5pdCBvZiB0aW1lIHRoYXQgdGhlIFRyYW5zcG9ydCBzdXBwb3J0cy5cblx0XHRcdCAqICBAdHlwZWRlZiB7VGlja3N9XG5cdFx0XHQgKi9cblx0ICAgICAgICBUaWNrczogJ3RpY2tzJyxcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBOb3JtYWwgdmFsdWVzIGFyZSB3aXRoaW4gdGhlIHJhbmdlIFswLCAxXS5cblx0XHRcdCAqICBAdHlwZWRlZiB7Tm9ybWFsUmFuZ2V9XG5cdFx0XHQgKi9cblx0ICAgICAgICBOb3JtYWxSYW5nZTogJ25vcm1hbFJhbmdlJyxcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBBdWRpb1JhbmdlIHZhbHVlcyBhcmUgYmV0d2VlbiBbLTEsIDFdLlxuXHRcdFx0ICogIEB0eXBlZGVmIHtBdWRpb1JhbmdlfVxuXHRcdFx0ICovXG5cdCAgICAgICAgQXVkaW9SYW5nZTogJ2F1ZGlvUmFuZ2UnLFxuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIERlY2liZWxzIGFyZSBhIGxvZ2FyaXRobWljIHVuaXQgb2YgbWVhc3VyZW1lbnQgd2hpY2ggaXMgdXNlZnVsIGZvciB2b2x1bWVcblx0XHRcdCAqICBiZWNhdXNlIG9mIHRoZSBsb2dhcml0aG1pYyB3YXkgdGhhdCB3ZSBwZXJjZWl2ZSBsb3VkbmVzcy4gMCBkZWNpYmVsc1xuXHRcdFx0ICogIG1lYW5zIG5vIGNoYW5nZSBpbiB2b2x1bWUuIC0xMGRiIGlzIGFwcHJveGltYXRlbHkgaGFsZiBhcyBsb3VkIGFuZCAxMGRiXG5cdFx0XHQgKiAgaXMgdHdpY2UgaXMgbG91ZC5cblx0XHRcdCAqICBAdHlwZWRlZiB7RGVjaWJlbHN9XG5cdFx0XHQgKi9cblx0ICAgICAgICBEZWNpYmVsczogJ2RiJyxcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBIYWxmLXN0ZXAgbm90ZSBpbmNyZW1lbnRzLCBpLmUuIDEyIGlzIGFuIG9jdGF2ZSBhYm92ZSB0aGUgcm9vdC4gYW5kIDEgaXMgYSBoYWxmLXN0ZXAgdXAuXG5cdFx0XHQgKiAgQHR5cGVkZWYge0ludGVydmFsfVxuXHRcdFx0ICovXG5cdCAgICAgICAgSW50ZXJ2YWw6ICdpbnRlcnZhbCcsXG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgQmVhdHMgcGVyIG1pbnV0ZS5cblx0XHRcdCAqICBAdHlwZWRlZiB7QlBNfVxuXHRcdFx0ICovXG5cdCAgICAgICAgQlBNOiAnYnBtJyxcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgdmFsdWUgbXVzdCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMC5cblx0XHRcdCAqICBAdHlwZWRlZiB7UG9zaXRpdmV9XG5cdFx0XHQgKi9cblx0ICAgICAgICBQb3NpdGl2ZTogJ3Bvc2l0aXZlJyxcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBHYWluIGlzIHRoZSByYXRpbyBiZXR3ZWVuIGlucHV0IGFuZCBvdXRwdXQgb2YgYSBzaWduYWwuXG5cdFx0XHQgKiAgQSBnYWluIG9mIDAgaXMgdGhlIHNhbWUgYXMgc2lsZW5jaW5nIHRoZSBzaWduYWwuIEEgZ2FpbiBvZlxuXHRcdFx0ICogIDEsIGNhdXNlcyBubyBjaGFuZ2UgdG8gdGhlIGluY29taW5nIHNpZ25hbC5cblx0XHRcdCAqICBAdHlwZWRlZiB7R2Fpbn1cblx0XHRcdCAqL1xuXHQgICAgICAgIEdhaW46ICdnYWluJyxcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBBIGNlbnQgaXMgYSBodW5kcmVkdGggb2YgYSBzZW1pdG9uZS5cblx0XHRcdCAqICBAdHlwZWRlZiB7Q2VudHN9XG5cdFx0XHQgKi9cblx0ICAgICAgICBDZW50czogJ2NlbnRzJyxcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBBbmdsZSBiZXR3ZWVuIDAgYW5kIDM2MC5cblx0XHRcdCAqICBAdHlwZWRlZiB7RGVncmVlc31cblx0XHRcdCAqL1xuXHQgICAgICAgIERlZ3JlZXM6ICdkZWdyZWVzJyxcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBBIG51bWJlciByZXByZXNlbnRpbmcgYSBtaWRpIG5vdGUuXG5cdFx0XHQgKiAgQHR5cGVkZWYge01JREl9XG5cdFx0XHQgKi9cblx0ICAgICAgICBNSURJOiAnbWlkaScsXG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgQSBjb2xvbi1zZXBhcmF0ZWQgcmVwcmVzZW50YXRpb24gb2YgdGltZSBpbiB0aGUgZm9ybSBvZlxuXHRcdFx0ICogIEJhcnM6QmVhdHM6U2l4dGVlbnRocy5cblx0XHRcdCAqICBAdHlwZWRlZiB7QmFyc0JlYXRzU2l4dGVlbnRoc31cblx0XHRcdCAqL1xuXHQgICAgICAgIEJhcnNCZWF0c1NpeHRlZW50aHM6ICdiYXJzQmVhdHNTaXh0ZWVudGhzJyxcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBTYW1wbGluZyBpcyB0aGUgcmVkdWN0aW9uIG9mIGEgY29udGludW91cyBzaWduYWwgdG8gYSBkaXNjcmV0ZSBzaWduYWwuXG5cdFx0XHQgKiAgQXVkaW8gaXMgdHlwaWNhbGx5IHNhbXBsZWQgNDQxMDAgdGltZXMgcGVyIHNlY29uZC5cblx0XHRcdCAqICBAdHlwZWRlZiB7U2FtcGxlc31cblx0XHRcdCAqL1xuXHQgICAgICAgIFNhbXBsZXM6ICdzYW1wbGVzJyxcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBIZXJ0eiBhcmUgYSBmcmVxdWVuY3kgcmVwcmVzZW50YXRpb24gZGVmaW5lZCBhcyBvbmUgY3ljbGUgcGVyIHNlY29uZC5cblx0XHRcdCAqICBAdHlwZWRlZiB7SGVydHp9XG5cdFx0XHQgKi9cblx0ICAgICAgICBIZXJ0ejogJ2hlcnR6Jyxcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBBIGZyZXF1ZW5jeSByZXByZXNlbnRlZCBieSBhIGxldHRlciBuYW1lLFxuXHRcdFx0ICogIGFjY2lkZW50YWwgYW5kIG9jdGF2ZS4gVGhpcyBzeXN0ZW0gaXMga25vd24gYXNcblx0XHRcdCAqICBbU2NpZW50aWZpYyBQaXRjaCBOb3RhdGlvbl0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU2NpZW50aWZpY19waXRjaF9ub3RhdGlvbikuXG5cdFx0XHQgKiAgQHR5cGVkZWYge05vdGV9XG5cdFx0XHQgKi9cblx0ICAgICAgICBOb3RlOiAnbm90ZScsXG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgT25lIG1pbGxpc2Vjb25kIGlzIGEgdGhvdXNhbmR0aCBvZiBhIHNlY29uZC5cblx0XHRcdCAqICBAdHlwZWRlZiB7TWlsbGlzZWNvbmRzfVxuXHRcdFx0ICovXG5cdCAgICAgICAgTWlsbGlzZWNvbmRzOiAnbWlsbGlzZWNvbmRzJyxcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBTZWNvbmRzIGFyZSB0aGUgdGltZSB1bml0IG9mIHRoZSBBdWRpb0NvbnRleHQuIEluIHRoZSBlbmQsXG5cdFx0XHQgKiAgYWxsIHZhbHVlcyBuZWVkIHRvIGJlIGV2YWx1YXRlZCB0byBzZWNvbmRzLlxuXHRcdFx0ICogIEB0eXBlZGVmIHtTZWNvbmRzfVxuXHRcdFx0ICovXG5cdCAgICAgICAgU2Vjb25kczogJ3NlY29uZHMnLFxuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIEEgc3RyaW5nIHJlcHJlc2VudGluZyBhIGR1cmF0aW9uIHJlbGF0aXZlIHRvIGEgbWVhc3VyZS5cblx0XHRcdCAqICAqIFwiNG5cIiA9IHF1YXJ0ZXIgbm90ZVxuXHRcdFx0ICogICogXCIybVwiID0gdHdvIG1lYXN1cmVzXG5cdFx0XHQgKiAgKiBcIjh0XCIgPSBlaWdodGgtbm90ZSB0cmlwbGV0XG5cdFx0XHQgKiAgQHR5cGVkZWYge05vdGF0aW9ufVxuXHRcdFx0ICovXG5cdCAgICAgICAgTm90YXRpb246ICdub3RhdGlvbidcblx0ICAgIH07XG5cdCAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblx0ICAgIC8vIEFVR01FTlQgVE9ORSdzIFBST1RPVFlQRVxuXHQgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdCAgICAvKipcblx0XHQgKiAgQ29udmVydCBUaW1lIGludG8gc2Vjb25kcy5cblx0XHQgKlxuXHRcdCAqICBVbmxpa2UgdGhlIG1ldGhvZCB3aGljaCBpdCBvdmVycmlkZXMsIHRoaXMgdGFrZXMgaW50byBhY2NvdW50XG5cdFx0ICogIHRyYW5zcG9ydHRpbWUgYW5kIG11c2ljYWwgbm90YXRpb24uXG5cdFx0ICpcblx0XHQgKiAgVGltZSA6IDEuNDBcblx0XHQgKiAgTm90YXRpb246IDRuIG9yIDFtIG9yIDJ0XG5cdFx0ICogIE5vdyBSZWxhdGl2ZTogKzNuXG5cdFx0ICogIE1hdGg6IDNuKzE2biBvciBldmVuIGNvbXBsaWNhdGVkIGV4cHJlc3Npb25zICgoM24qMikvNiArIDEpXG5cdFx0ICpcblx0XHQgKiAgQHBhcmFtICB7VGltZX0gdGltZVxuXHRcdCAqICBAcmV0dXJuIHtTZWNvbmRzfVxuXHRcdCAqL1xuXHQgICAgVG9uZS5wcm90b3R5cGUudG9TZWNvbmRzID0gZnVuY3Rpb24gKHRpbWUpIHtcblx0ICAgICAgICBpZiAoVG9uZS5pc051bWJlcih0aW1lKSkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGltZTtcblx0ICAgICAgICB9IGVsc2UgaWYgKFRvbmUuaXNVbmRlZih0aW1lKSkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5ub3coKTtcblx0ICAgICAgICB9IGVsc2UgaWYgKFRvbmUuaXNTdHJpbmcodGltZSkpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIG5ldyBUb25lLlRpbWUodGltZSkudG9TZWNvbmRzKCk7XG5cdCAgICAgICAgfSBlbHNlIGlmICh0aW1lIGluc3RhbmNlb2YgVG9uZS5UaW1lQmFzZSkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGltZS50b1NlY29uZHMoKTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIENvbnZlcnQgYSBmcmVxdWVuY3kgcmVwcmVzZW50YXRpb24gaW50byBhIG51bWJlci5cblx0XHQgKiAgQHBhcmFtICB7RnJlcXVlbmN5fSBmcmVxXG5cdFx0ICogIEByZXR1cm4ge0hlcnR6fSAgICAgIHRoZSBmcmVxdWVuY3kgaW4gaGVydHpcblx0XHQgKi9cblx0ICAgIFRvbmUucHJvdG90eXBlLnRvRnJlcXVlbmN5ID0gZnVuY3Rpb24gKGZyZXEpIHtcblx0ICAgICAgICBpZiAoVG9uZS5pc051bWJlcihmcmVxKSkge1xuXHQgICAgICAgICAgICByZXR1cm4gZnJlcTtcblx0ICAgICAgICB9IGVsc2UgaWYgKFRvbmUuaXNTdHJpbmcoZnJlcSkgfHwgVG9uZS5pc1VuZGVmKGZyZXEpKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBuZXcgVG9uZS5GcmVxdWVuY3koZnJlcSkudmFsdWVPZigpO1xuXHQgICAgICAgIH0gZWxzZSBpZiAoZnJlcSBpbnN0YW5jZW9mIFRvbmUuVGltZUJhc2UpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGZyZXEudG9GcmVxdWVuY3koKTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIENvbnZlcnQgYSB0aW1lIHJlcHJlc2VudGF0aW9uIGludG8gdGlja3MuXG5cdFx0ICogIEBwYXJhbSAge1RpbWV9IHRpbWVcblx0XHQgKiAgQHJldHVybiB7VGlja3N9ICB0aGUgdGltZSBpbiB0aWNrc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5wcm90b3R5cGUudG9UaWNrcyA9IGZ1bmN0aW9uICh0aW1lKSB7XG5cdCAgICAgICAgaWYgKFRvbmUuaXNOdW1iZXIodGltZSkgfHwgVG9uZS5pc1N0cmluZyh0aW1lKSkge1xuXHQgICAgICAgICAgICByZXR1cm4gbmV3IFRvbmUuVHJhbnNwb3J0VGltZSh0aW1lKS50b1RpY2tzKCk7XG5cdCAgICAgICAgfSBlbHNlIGlmIChUb25lLmlzVW5kZWYodGltZSkpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIFRvbmUuVHJhbnNwb3J0LnRpY2tzO1xuXHQgICAgICAgIH0gZWxzZSBpZiAodGltZSBpbnN0YW5jZW9mIFRvbmUuVGltZUJhc2UpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRpbWUudG9UaWNrcygpO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICByZXR1cm4gVG9uZTtcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgXG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzIFRvbmUuUGFyYW0gd3JhcHMgdGhlIG5hdGl2ZSBXZWIgQXVkaW8ncyBBdWRpb1BhcmFtIHRvIHByb3ZpZGVcblx0XHQgKiAgICAgICAgIGFkZGl0aW9uYWwgdW5pdCBjb252ZXJzaW9uIGZ1bmN0aW9uYWxpdHkuIEl0IGFsc29cblx0XHQgKiAgICAgICAgIHNlcnZlcyBhcyBhIGJhc2UtY2xhc3MgZm9yIGNsYXNzZXMgd2hpY2ggaGF2ZSBhIHNpbmdsZSxcblx0XHQgKiAgICAgICAgIGF1dG9tYXRhYmxlIHBhcmFtZXRlci5cblx0XHQgKiAgQGV4dGVuZHMge1RvbmUuQXVkaW9Ob2RlfVxuXHRcdCAqICBAcGFyYW0gIHtBdWRpb1BhcmFtfSAgcGFyYW0gIFRoZSBwYXJhbWV0ZXIgdG8gd3JhcC5cblx0XHQgKiAgQHBhcmFtICB7VG9uZS5UeXBlfSB1bml0cyBUaGUgdW5pdHMgb2YgdGhlIGF1ZGlvIHBhcmFtLlxuXHRcdCAqICBAcGFyYW0gIHtCb29sZWFufSBjb252ZXJ0IElmIHRoZSBwYXJhbSBzaG91bGQgYmUgY29udmVydGVkLlxuXHRcdCAqL1xuXHQgICAgVG9uZS5QYXJhbSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgb3B0aW9ucyA9IFRvbmUuZGVmYXVsdHMoYXJndW1lbnRzLCBbXG5cdCAgICAgICAgICAgICdwYXJhbScsXG5cdCAgICAgICAgICAgICd1bml0cycsXG5cdCAgICAgICAgICAgICdjb252ZXJ0J1xuXHQgICAgICAgIF0sIFRvbmUuUGFyYW0pO1xuXHQgICAgICAgIFRvbmUuQXVkaW9Ob2RlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIG5hdGl2ZSBwYXJhbWV0ZXIgdG8gY29udHJvbFxuXHRcdFx0ICogIEB0eXBlICB7QXVkaW9QYXJhbX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fcGFyYW0gPSB0aGlzLmlucHV0ID0gb3B0aW9ucy5wYXJhbTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgdW5pdHMgb2YgdGhlIHBhcmFtZXRlclxuXHRcdFx0ICogIEB0eXBlIHtUb25lLlR5cGV9XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLnVuaXRzID0gb3B0aW9ucy51bml0cztcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBJZiB0aGUgdmFsdWUgc2hvdWxkIGJlIGNvbnZlcnRlZCBvciBub3Rcblx0XHRcdCAqICBAdHlwZSB7Qm9vbGVhbn1cblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuY29udmVydCA9IG9wdGlvbnMuY29udmVydDtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUcnVlIGlmIHRoZSBzaWduYWwgdmFsdWUgaXMgYmVpbmcgb3ZlcnJpZGRlbiBieVxuXHRcdFx0ICogIGEgY29ubmVjdGVkIHNpZ25hbC5cblx0XHRcdCAqICBAcmVhZE9ubHlcblx0XHRcdCAqICBAdHlwZSAge2Jvb2xlYW59XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMub3ZlcnJpZGRlbiA9IGZhbHNlO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIElmIHRoZXJlIGlzIGFuIExGTywgdGhpcyBpcyB3aGVyZSBpdCBpcyBoZWxkLlxuXHRcdFx0ICogIEB0eXBlICB7VG9uZS5MRk99XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2xmbyA9IG51bGw7XG5cdCAgICAgICAgaWYgKFRvbmUuaXNPYmplY3Qob3B0aW9ucy5sZm8pKSB7XG5cdCAgICAgICAgICAgIHRoaXMudmFsdWUgPSBvcHRpb25zLmxmbztcblx0ICAgICAgICB9IGVsc2UgaWYgKCFUb25lLmlzVW5kZWYob3B0aW9ucy52YWx1ZSkpIHtcblx0ICAgICAgICAgICAgdGhpcy52YWx1ZSA9IG9wdGlvbnMudmFsdWU7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuUGFyYW0sIFRvbmUuQXVkaW9Ob2RlKTtcblx0ICAgIC8qKlxuXHRcdCAqICBEZWZhdWx0c1xuXHRcdCAqICBAdHlwZSAge09iamVjdH1cblx0XHQgKiAgQGNvbnN0XG5cdFx0ICovXG5cdCAgICBUb25lLlBhcmFtLmRlZmF1bHRzID0ge1xuXHQgICAgICAgICd1bml0cyc6IFRvbmUuVHlwZS5EZWZhdWx0LFxuXHQgICAgICAgICdjb252ZXJ0JzogdHJ1ZSxcblx0ICAgICAgICAncGFyYW0nOiB1bmRlZmluZWRcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiBUaGUgY3VycmVudCB2YWx1ZSBvZiB0aGUgcGFyYW1ldGVyLlxuXHRcdCAqIEBtZW1iZXJPZiBUb25lLlBhcmFtI1xuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogQG5hbWUgdmFsdWVcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLlBhcmFtLnByb3RvdHlwZSwgJ3ZhbHVlJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fdG9Vbml0cyh0aGlzLl9wYXJhbS52YWx1ZSk7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICAgICAgICBpZiAoVG9uZS5pc09iamVjdCh2YWx1ZSkpIHtcblx0ICAgICAgICAgICAgICAgIC8vdGhyb3cgYW4gZXJyb3IgaWYgdGhlIExGTyBuZWVkcyB0byBiZSBpbmNsdWRlZFxuXHQgICAgICAgICAgICAgICAgaWYgKFRvbmUuaXNVbmRlZihUb25lLkxGTykpIHtcblx0ICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0luY2x1ZGUgXFwnVG9uZS5MRk9cXCcgdG8gdXNlIGFuIExGTyBhcyBhIFBhcmFtIHZhbHVlLicpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgLy9yZW1vdmUgdGhlIG9sZCBvbmVcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLl9sZm8pIHtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLl9sZm8uZGlzcG9zZSgpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgdGhpcy5fbGZvID0gbmV3IFRvbmUuTEZPKHZhbHVlKS5zdGFydCgpO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fbGZvLmNvbm5lY3QodGhpcy5pbnB1dCk7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgY29udmVydGVkVmFsID0gdGhpcy5fZnJvbVVuaXRzKHZhbHVlKTtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX3BhcmFtLmNhbmNlbFNjaGVkdWxlZFZhbHVlcygwKTtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX3BhcmFtLnZhbHVlID0gY29udmVydGVkVmFsO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgQ29udmVydCB0aGUgZ2l2ZW4gdmFsdWUgZnJvbSB0aGUgdHlwZSBzcGVjaWZpZWQgYnkgVG9uZS5QYXJhbS51bml0c1xuXHRcdCAqICBpbnRvIHRoZSBkZXN0aW5hdGlvbiB2YWx1ZSAoc3VjaCBhcyBHYWluIG9yIEZyZXF1ZW5jeSkuXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICogIEBwYXJhbSAgeyp9IHZhbCB0aGUgdmFsdWUgdG8gY29udmVydFxuXHRcdCAqICBAcmV0dXJuIHtudW1iZXJ9ICAgICB0aGUgbnVtYmVyIHdoaWNoIHRoZSB2YWx1ZSBzaG91bGQgYmUgc2V0IHRvXG5cdFx0ICovXG5cdCAgICBUb25lLlBhcmFtLnByb3RvdHlwZS5fZnJvbVVuaXRzID0gZnVuY3Rpb24gKHZhbCkge1xuXHQgICAgICAgIGlmICh0aGlzLmNvbnZlcnQgfHwgVG9uZS5pc1VuZGVmKHRoaXMuY29udmVydCkpIHtcblx0ICAgICAgICAgICAgc3dpdGNoICh0aGlzLnVuaXRzKSB7XG5cdCAgICAgICAgICAgIGNhc2UgVG9uZS5UeXBlLlRpbWU6XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50b1NlY29uZHModmFsKTtcblx0ICAgICAgICAgICAgY2FzZSBUb25lLlR5cGUuRnJlcXVlbmN5OlxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9GcmVxdWVuY3kodmFsKTtcblx0ICAgICAgICAgICAgY2FzZSBUb25lLlR5cGUuRGVjaWJlbHM6XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gVG9uZS5kYlRvR2Fpbih2YWwpO1xuXHQgICAgICAgICAgICBjYXNlIFRvbmUuVHlwZS5Ob3JtYWxSYW5nZTpcblx0ICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLm1pbihNYXRoLm1heCh2YWwsIDApLCAxKTtcblx0ICAgICAgICAgICAgY2FzZSBUb25lLlR5cGUuQXVkaW9SYW5nZTpcblx0ICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLm1pbihNYXRoLm1heCh2YWwsIC0xKSwgMSk7XG5cdCAgICAgICAgICAgIGNhc2UgVG9uZS5UeXBlLlBvc2l0aXZlOlxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIE1hdGgubWF4KHZhbCwgMCk7XG5cdCAgICAgICAgICAgIGRlZmF1bHQ6XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdmFsO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHZhbDtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogQ29udmVydCB0aGUgcGFyYW1ldGVycyB2YWx1ZSBpbnRvIHRoZSB1bml0cyBzcGVjaWZpZWQgYnkgVG9uZS5QYXJhbS51bml0cy5cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqIEBwYXJhbSAge251bWJlcn0gdmFsIHRoZSB2YWx1ZSB0byBjb252ZXJ0XG5cdFx0ICogQHJldHVybiB7bnVtYmVyfVxuXHRcdCAqL1xuXHQgICAgVG9uZS5QYXJhbS5wcm90b3R5cGUuX3RvVW5pdHMgPSBmdW5jdGlvbiAodmFsKSB7XG5cdCAgICAgICAgaWYgKHRoaXMuY29udmVydCB8fCBUb25lLmlzVW5kZWYodGhpcy5jb252ZXJ0KSkge1xuXHQgICAgICAgICAgICBzd2l0Y2ggKHRoaXMudW5pdHMpIHtcblx0ICAgICAgICAgICAgY2FzZSBUb25lLlR5cGUuRGVjaWJlbHM6XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gVG9uZS5nYWluVG9EYih2YWwpO1xuXHQgICAgICAgICAgICBkZWZhdWx0OlxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHZhbDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIHJldHVybiB2YWw7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICB0aGUgbWluaW11bSBvdXRwdXQgdmFsdWVcblx0XHQgKiAgQHR5cGUge051bWJlcn1cblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuUGFyYW0ucHJvdG90eXBlLl9taW5PdXRwdXQgPSAwLjAwMDAxO1xuXHQgICAgLyoqXG5cdFx0ICogIFNjaGVkdWxlcyBhIHBhcmFtZXRlciB2YWx1ZSBjaGFuZ2UgYXQgdGhlIGdpdmVuIHRpbWUuXG5cdFx0ICogIEBwYXJhbSB7Kn1cdHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQgdGhlIHNpZ25hbC5cblx0XHQgKiAgQHBhcmFtIHtUaW1lfSAgdGltZSBUaGUgdGltZSB3aGVuIHRoZSBjaGFuZ2Ugc2hvdWxkIG9jY3VyLlxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5QYXJhbX0gdGhpc1xuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIC8vc2V0IHRoZSBmcmVxdWVuY3kgdG8gXCJHNFwiIGluIGV4YWN0bHkgMSBzZWNvbmQgZnJvbSBub3cuXG5cdFx0ICogZnJlcS5zZXRWYWx1ZUF0VGltZShcIkc0XCIsIFwiKzFcIik7XG5cdFx0ICovXG5cdCAgICBUb25lLlBhcmFtLnByb3RvdHlwZS5zZXRWYWx1ZUF0VGltZSA9IGZ1bmN0aW9uICh2YWx1ZSwgdGltZSkge1xuXHQgICAgICAgIHRoaXMuX3BhcmFtLnNldFZhbHVlQXRUaW1lKHRoaXMuX2Zyb21Vbml0cyh2YWx1ZSksIHRoaXMudG9TZWNvbmRzKHRpbWUpKTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgQ3JlYXRlcyBhIHNjaGVkdWxlIHBvaW50IHdpdGggdGhlIGN1cnJlbnQgdmFsdWUgYXQgdGhlIGN1cnJlbnQgdGltZS5cblx0XHQgKiAgVGhpcyBpcyB1c2VmdWwgZm9yIGNyZWF0aW5nIGFuIGF1dG9tYXRpb24gYW5jaG9yIHBvaW50IGluIG9yZGVyIHRvXG5cdFx0ICogIHNjaGVkdWxlIGNoYW5nZXMgZnJvbSB0aGUgY3VycmVudCB2YWx1ZS5cblx0XHQgKlxuXHRcdCAqICBAcGFyYW0ge251bWJlcj19IG5vdyAoT3B0aW9uYWxseSkgcGFzcyB0aGUgbm93IHZhbHVlIGluLlxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5QYXJhbX0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5QYXJhbS5wcm90b3R5cGUuc2V0UmFtcFBvaW50ID0gZnVuY3Rpb24gKG5vdykge1xuXHQgICAgICAgIG5vdyA9IFRvbmUuZGVmYXVsdEFyZyhub3csIHRoaXMubm93KCkpO1xuXHQgICAgICAgIHZhciBjdXJyZW50VmFsID0gdGhpcy5fcGFyYW0udmFsdWU7XG5cdCAgICAgICAgLy8gZXhwb25lbnRpYWxSYW1wVG9WYWx1ZUF0IGNhbm5vdCBldmVyIHJhbXAgZnJvbSBvciB0byAwXG5cdCAgICAgICAgLy8gTW9yZSBpbmZvOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xMTI1NjAwI2MyXG5cdCAgICAgICAgaWYgKGN1cnJlbnRWYWwgPT09IDApIHtcblx0ICAgICAgICAgICAgY3VycmVudFZhbCA9IHRoaXMuX21pbk91dHB1dDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdGhpcy5fcGFyYW0uc2V0VmFsdWVBdFRpbWUoY3VycmVudFZhbCwgbm93KTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgU2NoZWR1bGVzIGEgbGluZWFyIGNvbnRpbnVvdXMgY2hhbmdlIGluIHBhcmFtZXRlciB2YWx1ZSBmcm9tIHRoZVxuXHRcdCAqICBwcmV2aW91cyBzY2hlZHVsZWQgcGFyYW1ldGVyIHZhbHVlIHRvIHRoZSBnaXZlbiB2YWx1ZS5cblx0XHQgKlxuXHRcdCAqICBAcGFyYW0gIHtudW1iZXJ9IHZhbHVlXG5cdFx0ICogIEBwYXJhbSAge1RpbWV9IGVuZFRpbWVcblx0XHQgKiAgQHJldHVybnMge1RvbmUuUGFyYW19IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuUGFyYW0ucHJvdG90eXBlLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lID0gZnVuY3Rpb24gKHZhbHVlLCBlbmRUaW1lKSB7XG5cdCAgICAgICAgdmFsdWUgPSB0aGlzLl9mcm9tVW5pdHModmFsdWUpO1xuXHQgICAgICAgIHRoaXMuX3BhcmFtLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKHZhbHVlLCB0aGlzLnRvU2Vjb25kcyhlbmRUaW1lKSk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFNjaGVkdWxlcyBhbiBleHBvbmVudGlhbCBjb250aW51b3VzIGNoYW5nZSBpbiBwYXJhbWV0ZXIgdmFsdWUgZnJvbVxuXHRcdCAqICB0aGUgcHJldmlvdXMgc2NoZWR1bGVkIHBhcmFtZXRlciB2YWx1ZSB0byB0aGUgZ2l2ZW4gdmFsdWUuXG5cdFx0ICpcblx0XHQgKiAgQHBhcmFtICB7bnVtYmVyfSB2YWx1ZVxuXHRcdCAqICBAcGFyYW0gIHtUaW1lfSBlbmRUaW1lXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLlBhcmFtfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLlBhcmFtLnByb3RvdHlwZS5leHBvbmVudGlhbFJhbXBUb1ZhbHVlQXRUaW1lID0gZnVuY3Rpb24gKHZhbHVlLCBlbmRUaW1lKSB7XG5cdCAgICAgICAgdmFsdWUgPSB0aGlzLl9mcm9tVW5pdHModmFsdWUpO1xuXHQgICAgICAgIHZhbHVlID0gTWF0aC5tYXgodGhpcy5fbWluT3V0cHV0LCB2YWx1ZSk7XG5cdCAgICAgICAgdGhpcy5fcGFyYW0uZXhwb25lbnRpYWxSYW1wVG9WYWx1ZUF0VGltZSh2YWx1ZSwgdGhpcy50b1NlY29uZHMoZW5kVGltZSkpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBTY2hlZHVsZXMgYW4gZXhwb25lbnRpYWwgY29udGludW91cyBjaGFuZ2UgaW4gcGFyYW1ldGVyIHZhbHVlIGZyb21cblx0XHQgKiAgdGhlIGN1cnJlbnQgdGltZSBhbmQgY3VycmVudCB2YWx1ZSB0byB0aGUgZ2l2ZW4gdmFsdWUgb3ZlciB0aGVcblx0XHQgKiAgZHVyYXRpb24gb2YgdGhlIHJhbXBUaW1lLlxuXHRcdCAqXG5cdFx0ICogIEBwYXJhbSAge251bWJlcn0gdmFsdWUgICBUaGUgdmFsdWUgdG8gcmFtcCB0by5cblx0XHQgKiAgQHBhcmFtICB7VGltZX0gcmFtcFRpbWUgdGhlIHRpbWUgdGhhdCBpdCB0YWtlcyB0aGVcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSB0byByYW1wIGZyb20gaXQncyBjdXJyZW50IHZhbHVlXG5cdFx0ICogIEBwYXJhbSB7VGltZX1cdFtzdGFydFRpbWU9bm93XSBcdFdoZW4gdGhlIHJhbXAgc2hvdWxkIHN0YXJ0LlxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5QYXJhbX0gdGhpc1xuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIC8vZXhwb25lbnRpYWxseSByYW1wIHRvIHRoZSB2YWx1ZSAyIG92ZXIgNCBzZWNvbmRzLlxuXHRcdCAqIHNpZ25hbC5leHBvbmVudGlhbFJhbXBUb1ZhbHVlKDIsIDQpO1xuXHRcdCAqL1xuXHQgICAgVG9uZS5QYXJhbS5wcm90b3R5cGUuZXhwb25lbnRpYWxSYW1wVG9WYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSwgcmFtcFRpbWUsIHN0YXJ0VGltZSkge1xuXHQgICAgICAgIHN0YXJ0VGltZSA9IHRoaXMudG9TZWNvbmRzKHN0YXJ0VGltZSk7XG5cdCAgICAgICAgdGhpcy5zZXRSYW1wUG9pbnQoc3RhcnRUaW1lKTtcblx0ICAgICAgICB0aGlzLmV4cG9uZW50aWFsUmFtcFRvVmFsdWVBdFRpbWUodmFsdWUsIHN0YXJ0VGltZSArIHRoaXMudG9TZWNvbmRzKHJhbXBUaW1lKSk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFNjaGVkdWxlcyBhbiBsaW5lYXIgY29udGludW91cyBjaGFuZ2UgaW4gcGFyYW1ldGVyIHZhbHVlIGZyb21cblx0XHQgKiAgdGhlIGN1cnJlbnQgdGltZSBhbmQgY3VycmVudCB2YWx1ZSB0byB0aGUgZ2l2ZW4gdmFsdWUgb3ZlciB0aGVcblx0XHQgKiAgZHVyYXRpb24gb2YgdGhlIHJhbXBUaW1lLlxuXHRcdCAqXG5cdFx0ICogIEBwYXJhbSAge251bWJlcn0gdmFsdWUgICBUaGUgdmFsdWUgdG8gcmFtcCB0by5cblx0XHQgKiAgQHBhcmFtICB7VGltZX0gcmFtcFRpbWUgdGhlIHRpbWUgdGhhdCBpdCB0YWtlcyB0aGVcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSB0byByYW1wIGZyb20gaXQncyBjdXJyZW50IHZhbHVlXG5cdFx0ICogIEBwYXJhbSB7VGltZX1cdFtzdGFydFRpbWU9bm93XSBcdFdoZW4gdGhlIHJhbXAgc2hvdWxkIHN0YXJ0LlxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5QYXJhbX0gdGhpc1xuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIC8vbGluZWFybHkgcmFtcCB0byB0aGUgdmFsdWUgNCBvdmVyIDMgc2Vjb25kcy5cblx0XHQgKiBzaWduYWwubGluZWFyUmFtcFRvVmFsdWUoNCwgMyk7XG5cdFx0ICovXG5cdCAgICBUb25lLlBhcmFtLnByb3RvdHlwZS5saW5lYXJSYW1wVG9WYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSwgcmFtcFRpbWUsIHN0YXJ0VGltZSkge1xuXHQgICAgICAgIHN0YXJ0VGltZSA9IHRoaXMudG9TZWNvbmRzKHN0YXJ0VGltZSk7XG5cdCAgICAgICAgdGhpcy5zZXRSYW1wUG9pbnQoc3RhcnRUaW1lKTtcblx0ICAgICAgICB0aGlzLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKHZhbHVlLCBzdGFydFRpbWUgKyB0aGlzLnRvU2Vjb25kcyhyYW1wVGltZSkpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBTdGFydCBleHBvbmVudGlhbGx5IGFwcHJvYWNoaW5nIHRoZSB0YXJnZXQgdmFsdWUgYXQgdGhlIGdpdmVuIHRpbWUgd2l0aFxuXHRcdCAqICBhIHJhdGUgaGF2aW5nIHRoZSBnaXZlbiB0aW1lIGNvbnN0YW50LlxuXHRcdCAqICBAcGFyYW0ge251bWJlcn0gdmFsdWVcblx0XHQgKiAgQHBhcmFtIHtUaW1lfSBzdGFydFRpbWVcblx0XHQgKiAgQHBhcmFtIHtudW1iZXJ9IHRpbWVDb25zdGFudFxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5QYXJhbX0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5QYXJhbS5wcm90b3R5cGUuc2V0VGFyZ2V0QXRUaW1lID0gZnVuY3Rpb24gKHZhbHVlLCBzdGFydFRpbWUsIHRpbWVDb25zdGFudCkge1xuXHQgICAgICAgIHZhbHVlID0gdGhpcy5fZnJvbVVuaXRzKHZhbHVlKTtcblx0ICAgICAgICAvLyBUaGUgdmFsdWUgd2lsbCBuZXZlciBiZSBhYmxlIHRvIGFwcHJvYWNoIHdpdGhvdXQgdGltZUNvbnN0YW50ID4gMC5cblx0ICAgICAgICAvLyBodHRwOi8vd3d3LnczLm9yZy9UUi93ZWJhdWRpby8jZGZuLXNldFRhcmdldEF0VGltZSwgd2hlcmUgdGhlIGVxdWF0aW9uXG5cdCAgICAgICAgLy8gaXMgZGVzY3JpYmVkLiAwIHJlc3VsdHMgaW4gYSBkaXZpc2lvbiBieSAwLlxuXHQgICAgICAgIHZhbHVlID0gTWF0aC5tYXgodGhpcy5fbWluT3V0cHV0LCB2YWx1ZSk7XG5cdCAgICAgICAgdGltZUNvbnN0YW50ID0gTWF0aC5tYXgodGhpcy5fbWluT3V0cHV0LCB0aW1lQ29uc3RhbnQpO1xuXHQgICAgICAgIHRoaXMuX3BhcmFtLnNldFRhcmdldEF0VGltZSh2YWx1ZSwgdGhpcy50b1NlY29uZHMoc3RhcnRUaW1lKSwgdGltZUNvbnN0YW50KTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgU2V0cyBhbiBhcnJheSBvZiBhcmJpdHJhcnkgcGFyYW1ldGVyIHZhbHVlcyBzdGFydGluZyBhdCB0aGUgZ2l2ZW4gdGltZVxuXHRcdCAqICBmb3IgdGhlIGdpdmVuIGR1cmF0aW9uLlxuXHRcdCAqXG5cdFx0ICogIEBwYXJhbSB7QXJyYXl9IHZhbHVlc1xuXHRcdCAqICBAcGFyYW0ge1RpbWV9IHN0YXJ0VGltZVxuXHRcdCAqICBAcGFyYW0ge1RpbWV9IGR1cmF0aW9uXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLlBhcmFtfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLlBhcmFtLnByb3RvdHlwZS5zZXRWYWx1ZUN1cnZlQXRUaW1lID0gZnVuY3Rpb24gKHZhbHVlcywgc3RhcnRUaW1lLCBkdXJhdGlvbikge1xuXHQgICAgICAgIGR1cmF0aW9uID0gdGhpcy50b1NlY29uZHMoZHVyYXRpb24pO1xuXHQgICAgICAgIHN0YXJ0VGltZSA9IHRoaXMudG9TZWNvbmRzKHN0YXJ0VGltZSk7XG5cdCAgICAgICAgdGhpcy5zZXRWYWx1ZUF0VGltZSh2YWx1ZXNbMF0sIHN0YXJ0VGltZSk7XG5cdCAgICAgICAgdmFyIHNlZ1RpbWUgPSBkdXJhdGlvbiAvICh2YWx1ZXMubGVuZ3RoIC0gMSk7XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgdGhpcy5fcGFyYW0ubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUodGhpcy5fZnJvbVVuaXRzKHZhbHVlc1tpXSksIHN0YXJ0VGltZSArIGkgKiBzZWdUaW1lKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIENhbmNlbHMgYWxsIHNjaGVkdWxlZCBwYXJhbWV0ZXIgY2hhbmdlcyB3aXRoIHRpbWVzIGdyZWF0ZXIgdGhhbiBvclxuXHRcdCAqICBlcXVhbCB0byBzdGFydFRpbWUuXG5cdFx0ICpcblx0XHQgKiAgQHBhcmFtICB7VGltZX0gc3RhcnRUaW1lXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLlBhcmFtfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLlBhcmFtLnByb3RvdHlwZS5jYW5jZWxTY2hlZHVsZWRWYWx1ZXMgPSBmdW5jdGlvbiAoc3RhcnRUaW1lKSB7XG5cdCAgICAgICAgdGhpcy5fcGFyYW0uY2FuY2VsU2NoZWR1bGVkVmFsdWVzKHRoaXMudG9TZWNvbmRzKHN0YXJ0VGltZSkpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBSYW1wcyB0byB0aGUgZ2l2ZW4gdmFsdWUgb3ZlciB0aGUgZHVyYXRpb24gb2YgdGhlIHJhbXBUaW1lLlxuXHRcdCAqICBBdXRvbWF0aWNhbGx5IHNlbGVjdHMgdGhlIGJlc3QgcmFtcCB0eXBlIChleHBvbmVudGlhbCBvciBsaW5lYXIpXG5cdFx0ICogIGRlcGVuZGluZyBvbiB0aGUgYHVuaXRzYCBvZiB0aGUgc2lnbmFsXG5cdFx0ICpcblx0XHQgKiAgQHBhcmFtICB7bnVtYmVyfSB2YWx1ZVxuXHRcdCAqICBAcGFyYW0gIHtUaW1lfSByYW1wVGltZSBcdFRoZSB0aW1lIHRoYXQgaXQgdGFrZXMgdGhlXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSB0byByYW1wIGZyb20gaXQncyBjdXJyZW50IHZhbHVlXG5cdFx0ICogIEBwYXJhbSB7VGltZX1cdFtzdGFydFRpbWU9bm93XSBcdFdoZW4gdGhlIHJhbXAgc2hvdWxkIHN0YXJ0LlxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5QYXJhbX0gdGhpc1xuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIC8vcmFtcCB0byB0aGUgdmFsdWUgZWl0aGVyIGxpbmVhcmx5IG9yIGV4cG9uZW50aWFsbHlcblx0XHQgKiAvL2RlcGVuZGluZyBvbiB0aGUgXCJ1bml0c1wiIHZhbHVlIG9mIHRoZSBzaWduYWxcblx0XHQgKiBzaWduYWwucmFtcFRvKDAsIDEwKTtcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAvL3NjaGVkdWxlIGl0IHRvIHJhbXAgc3RhcnRpbmcgYXQgYSBzcGVjaWZpYyB0aW1lXG5cdFx0ICogc2lnbmFsLnJhbXBUbygwLCAxMCwgNSlcblx0XHQgKi9cblx0ICAgIFRvbmUuUGFyYW0ucHJvdG90eXBlLnJhbXBUbyA9IGZ1bmN0aW9uICh2YWx1ZSwgcmFtcFRpbWUsIHN0YXJ0VGltZSkge1xuXHQgICAgICAgIHJhbXBUaW1lID0gVG9uZS5kZWZhdWx0QXJnKHJhbXBUaW1lLCAwKTtcblx0ICAgICAgICBpZiAodGhpcy51bml0cyA9PT0gVG9uZS5UeXBlLkZyZXF1ZW5jeSB8fCB0aGlzLnVuaXRzID09PSBUb25lLlR5cGUuQlBNIHx8IHRoaXMudW5pdHMgPT09IFRvbmUuVHlwZS5EZWNpYmVscykge1xuXHQgICAgICAgICAgICB0aGlzLmV4cG9uZW50aWFsUmFtcFRvVmFsdWUodmFsdWUsIHJhbXBUaW1lLCBzdGFydFRpbWUpO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIHRoaXMubGluZWFyUmFtcFRvVmFsdWUodmFsdWUsIHJhbXBUaW1lLCBzdGFydFRpbWUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgVGhlIExGTyBjcmVhdGVkIGJ5IHRoZSBzaWduYWwgaW5zdGFuY2UuIElmIG5vbmVcblx0XHQgKiAgd2FzIGNyZWF0ZWQsIHRoaXMgaXMgbnVsbC5cblx0XHQgKiAgQHR5cGUge1RvbmUuTEZPfVxuXHRcdCAqICBAcmVhZE9ubHlcblx0XHQgKiAgQG1lbWJlck9mIFRvbmUuUGFyYW0jXG5cdFx0ICogIEBuYW1lIGxmb1xuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuUGFyYW0ucHJvdG90eXBlLCAnbGZvJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fbGZvO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIENsZWFuIHVwXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLlBhcmFtfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLlBhcmFtLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuQXVkaW9Ob2RlLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgdGhpcy5fcGFyYW0gPSBudWxsO1xuXHQgICAgICAgIGlmICh0aGlzLl9sZm8pIHtcblx0ICAgICAgICAgICAgdGhpcy5fbGZvLmRpc3Bvc2UoKTtcblx0ICAgICAgICAgICAgdGhpcy5fbGZvID0gbnVsbDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuUGFyYW07XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIGNyZWF0ZUdhaW4gc2hpbVxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgaWYgKHdpbmRvdy5HYWluTm9kZSAmJiAhQXVkaW9Db250ZXh0LnByb3RvdHlwZS5jcmVhdGVHYWluKSB7XG5cdCAgICAgICAgQXVkaW9Db250ZXh0LnByb3RvdHlwZS5jcmVhdGVHYWluID0gQXVkaW9Db250ZXh0LnByb3RvdHlwZS5jcmVhdGVHYWluTm9kZTtcblx0ICAgIH1cblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgQSB0aGluIHdyYXBwZXIgYXJvdW5kIHRoZSBOYXRpdmUgV2ViIEF1ZGlvIEdhaW5Ob2RlLlxuXHRcdCAqICAgICAgICAgVGhlIEdhaW5Ob2RlIGlzIGEgYmFzaWMgYnVpbGRpbmcgYmxvY2sgb2YgdGhlIFdlYiBBdWRpb1xuXHRcdCAqICAgICAgICAgQVBJIGFuZCBpcyB1c2VmdWwgZm9yIHJvdXRpbmcgYXVkaW8gYW5kIGFkanVzdGluZyBnYWlucy5cblx0XHQgKiAgQGV4dGVuZHMge1RvbmV9XG5cdFx0ICogIEBwYXJhbSAge051bWJlcj19ICBnYWluICBUaGUgaW5pdGlhbCBnYWluIG9mIHRoZSBHYWluTm9kZVxuXHRcdCAqICBAcGFyYW0ge1RvbmUuVHlwZT19IHVuaXRzIFRoZSB1bml0cyBvZiB0aGUgZ2FpbiBwYXJhbWV0ZXIuXG5cdFx0ICovXG5cdCAgICBUb25lLkdhaW4gPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIG9wdGlvbnMgPSBUb25lLmRlZmF1bHRzKGFyZ3VtZW50cywgW1xuXHQgICAgICAgICAgICAnZ2FpbicsXG5cdCAgICAgICAgICAgICd1bml0cydcblx0ICAgICAgICBdLCBUb25lLkdhaW4pO1xuXHQgICAgICAgIFRvbmUuQXVkaW9Ob2RlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIEdhaW5Ob2RlXG5cdFx0XHQgKiAgQHR5cGUgIHtHYWluTm9kZX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5pbnB1dCA9IHRoaXMub3V0cHV0ID0gdGhpcy5fZ2Fpbk5vZGUgPSB0aGlzLmNvbnRleHQuY3JlYXRlR2FpbigpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBnYWluIHBhcmFtZXRlciBvZiB0aGUgZ2FpbiBub2RlLlxuXHRcdFx0ICogIEB0eXBlIHtHYWlufVxuXHRcdFx0ICogIEBzaWduYWxcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuZ2FpbiA9IG5ldyBUb25lLlBhcmFtKHtcblx0ICAgICAgICAgICAgJ3BhcmFtJzogdGhpcy5fZ2Fpbk5vZGUuZ2Fpbixcblx0ICAgICAgICAgICAgJ3VuaXRzJzogb3B0aW9ucy51bml0cyxcblx0ICAgICAgICAgICAgJ3ZhbHVlJzogb3B0aW9ucy5nYWluLFxuXHQgICAgICAgICAgICAnY29udmVydCc6IG9wdGlvbnMuY29udmVydFxuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIHRoaXMuX3JlYWRPbmx5KCdnYWluJyk7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5HYWluLCBUb25lLkF1ZGlvTm9kZSk7XG5cdCAgICAvKipcblx0XHQgKiAgVGhlIGRlZmF1bHRzXG5cdFx0ICogIEBjb25zdFxuXHRcdCAqICBAdHlwZSAge09iamVjdH1cblx0XHQgKi9cblx0ICAgIFRvbmUuR2Fpbi5kZWZhdWx0cyA9IHtcblx0ICAgICAgICAnZ2Fpbic6IDEsXG5cdCAgICAgICAgJ2NvbnZlcnQnOiB0cnVlXG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIENsZWFuIHVwLlxuXHRcdCAqICBAcmV0dXJuICB7VG9uZS5HYWlufSAgdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5HYWluLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuQXVkaW9Ob2RlLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgdGhpcy5fZ2Fpbk5vZGUuZGlzY29ubmVjdCgpO1xuXHQgICAgICAgIHRoaXMuX2dhaW5Ob2RlID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl93cml0YWJsZSgnZ2FpbicpO1xuXHQgICAgICAgIHRoaXMuZ2Fpbi5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5nYWluID0gbnVsbDtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVG9uZS5HYWluO1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgIEEgc2lnbmFsIGlzIGFuIGF1ZGlvLXJhdGUgdmFsdWUuIFRvbmUuU2lnbmFsIGlzIGEgY29yZSBjb21wb25lbnQgb2YgdGhlIGxpYnJhcnkuXG5cdFx0ICogICAgICAgICAgVW5saWtlIGEgbnVtYmVyLCBTaWduYWxzIGNhbiBiZSBzY2hlZHVsZWQgd2l0aCBzYW1wbGUtbGV2ZWwgYWNjdXJhY3kuIFRvbmUuU2lnbmFsXG5cdFx0ICogICAgICAgICAgaGFzIGFsbCBvZiB0aGUgbWV0aG9kcyBhdmFpbGFibGUgdG8gbmF0aXZlIFdlYiBBdWRpbyBcblx0XHQgKiAgICAgICAgICBbQXVkaW9QYXJhbV0oaHR0cDovL3dlYmF1ZGlvLmdpdGh1Yi5pby93ZWItYXVkaW8tYXBpLyN0aGUtYXVkaW9wYXJhbS1pbnRlcmZhY2UpXG5cdFx0ICogICAgICAgICAgYXMgd2VsbCBhcyBhZGRpdGlvbmFsIGNvbnZlbmllbmNlcy4gUmVhZCBtb3JlIGFib3V0IHdvcmtpbmcgd2l0aCBzaWduYWxzIFxuXHRcdCAqICAgICAgICAgIFtoZXJlXShodHRwczovL2dpdGh1Yi5jb20vVG9uZWpzL1RvbmUuanMvd2lraS9TaWduYWxzKS5cblx0XHQgKlxuXHRcdCAqICBAY29uc3RydWN0b3Jcblx0XHQgKiAgQGV4dGVuZHMge1RvbmUuUGFyYW19XG5cdFx0ICogIEBwYXJhbSB7TnVtYmVyfEF1ZGlvUGFyYW19IFt2YWx1ZV0gSW5pdGlhbCB2YWx1ZSBvZiB0aGUgc2lnbmFsLiBJZiBhbiBBdWRpb1BhcmFtXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXMgcGFzc2VkIGluLCB0aGF0IHBhcmFtZXRlciB3aWxsIGJlIHdyYXBwZWRcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmQgY29udHJvbGxlZCBieSB0aGUgU2lnbmFsLiBcblx0XHQgKiAgQHBhcmFtIHtzdHJpbmd9IFt1bml0cz1OdW1iZXJdIHVuaXQgVGhlIHVuaXRzIHRoZSBzaWduYWwgaXMgaW4uIFxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIHZhciBzaWduYWwgPSBuZXcgVG9uZS5TaWduYWwoMTApO1xuXHRcdCAqL1xuXHQgICAgVG9uZS5TaWduYWwgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIG9wdGlvbnMgPSBUb25lLmRlZmF1bHRzKGFyZ3VtZW50cywgW1xuXHQgICAgICAgICAgICAndmFsdWUnLFxuXHQgICAgICAgICAgICAndW5pdHMnXG5cdCAgICAgICAgXSwgVG9uZS5TaWduYWwpO1xuXHQgICAgICAgIHZhciBnYWluTm9kZSA9IFRvbmUuY29udGV4dC5jcmVhdGVHYWluKCk7XG5cdCAgICAgICAgb3B0aW9ucy5wYXJhbSA9IGdhaW5Ob2RlLmdhaW47XG5cdCAgICAgICAgVG9uZS5QYXJhbS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogVGhlIG5vZGUgd2hlcmUgdGhlIGNvbnN0YW50IHNpZ25hbCB2YWx1ZSBpcyBzY2FsZWQuXG5cdFx0XHQgKiBAdHlwZSB7R2Fpbk5vZGV9XG5cdFx0XHQgKiBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5vdXRwdXQgPSBnYWluTm9kZTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqIFRoZSBub2RlIHdoZXJlIHRoZSB2YWx1ZSBpcyBzZXQuXG5cdFx0XHQgKiBAdHlwZSB7VG9uZS5QYXJhbX1cblx0XHRcdCAqIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmlucHV0ID0gdGhpcy5fcGFyYW0gPSB0aGlzLm91dHB1dC5nYWluO1xuXHQgICAgICAgIC8vY29ubmVjdCB0aGUgY29uc3Qgb3V0cHV0IHRvIHRoZSBub2RlIG91dHB1dFxuXHQgICAgICAgIHRoaXMuY29udGV4dC5nZXRDb25zdGFudCgxKS5jb25uZWN0KHRoaXMub3V0cHV0KTtcblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLlNpZ25hbCwgVG9uZS5QYXJhbSk7XG5cdCAgICAvKipcblx0XHQgKiAgVGhlIGRlZmF1bHQgdmFsdWVzXG5cdFx0ICogIEB0eXBlICB7T2JqZWN0fVxuXHRcdCAqICBAc3RhdGljXG5cdFx0ICogIEBjb25zdFxuXHRcdCAqL1xuXHQgICAgVG9uZS5TaWduYWwuZGVmYXVsdHMgPSB7XG5cdCAgICAgICAgJ3ZhbHVlJzogMCxcblx0ICAgICAgICAndW5pdHMnOiBUb25lLlR5cGUuRGVmYXVsdCxcblx0ICAgICAgICAnY29udmVydCc6IHRydWVcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgV2hlbiBzaWduYWxzIGNvbm5lY3QgdG8gb3RoZXIgc2lnbmFscyBvciBBdWRpb1BhcmFtcywgXG5cdFx0ICogIHRoZXkgdGFrZSBvdmVyIHRoZSBvdXRwdXQgdmFsdWUgb2YgdGhhdCBzaWduYWwgb3IgQXVkaW9QYXJhbS4gXG5cdFx0ICogIEZvciBhbGwgb3RoZXIgbm9kZXMsIHRoZSBiZWhhdmlvciBpcyB0aGUgc2FtZSBhcyBhIGRlZmF1bHQgPGNvZGU+Y29ubmVjdDwvY29kZT4uIFxuXHRcdCAqXG5cdFx0ICogIEBvdmVycmlkZVxuXHRcdCAqICBAcGFyYW0ge0F1ZGlvUGFyYW18QXVkaW9Ob2RlfFRvbmUuU2lnbmFsfFRvbmV9IG5vZGUgXG5cdFx0ICogIEBwYXJhbSB7bnVtYmVyfSBbb3V0cHV0TnVtYmVyPTBdIFRoZSBvdXRwdXQgbnVtYmVyIHRvIGNvbm5lY3QgZnJvbS5cblx0XHQgKiAgQHBhcmFtIHtudW1iZXJ9IFtpbnB1dE51bWJlcj0wXSBUaGUgaW5wdXQgbnVtYmVyIHRvIGNvbm5lY3QgdG8uXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLlNpZ25hbEJhc2V9IHRoaXNcblx0XHQgKiAgQG1ldGhvZFxuXHRcdCAqL1xuXHQgICAgVG9uZS5TaWduYWwucHJvdG90eXBlLmNvbm5lY3QgPSBUb25lLlNpZ25hbEJhc2UucHJvdG90eXBlLmNvbm5lY3Q7XG5cdCAgICAvKipcblx0XHQgKiAgZGlzcG9zZSBhbmQgZGlzY29ubmVjdFxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5TaWduYWx9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuU2lnbmFsLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuUGFyYW0ucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVG9uZS5TaWduYWw7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyBBIHNpZ25hbCB3aGljaCBhZGRzIHRoZSBtZXRob2QgZ2V0VmFsdWVBdFRpbWUuIFxuXHRcdCAqICAgICAgICAgQ29kZSBhbmQgaW5zcGlyYXRpb24gZnJvbSBodHRwczovL2dpdGh1Yi5jb20vanNhbnRlbGwvd2ViLWF1ZGlvLWF1dG9tYXRpb24tdGltZWxpbmVcblx0XHQgKiAgQGV4dGVuZHMge1RvbmUuU2lnbmFsfVxuXHRcdCAqICBAcGFyYW0ge051bWJlcj19IHZhbHVlIFRoZSBpbml0aWFsIHZhbHVlIG9mIHRoZSBzaWduYWxcblx0XHQgKiAgQHBhcmFtIHtTdHJpbmc9fSB1bml0cyBUaGUgY29udmVyc2lvbiB1bml0cyBvZiB0aGUgc2lnbmFsLlxuXHRcdCAqL1xuXHQgICAgVG9uZS5UaW1lbGluZVNpZ25hbCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgb3B0aW9ucyA9IFRvbmUuZGVmYXVsdHMoYXJndW1lbnRzLCBbXG5cdCAgICAgICAgICAgICd2YWx1ZScsXG5cdCAgICAgICAgICAgICd1bml0cydcblx0ICAgICAgICBdLCBUb25lLlNpZ25hbCk7XG5cdCAgICAgICAgVG9uZS5TaWduYWwuY2FsbCh0aGlzLCBvcHRpb25zKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgc2NoZWR1bGVkIGV2ZW50c1xuXHRcdFx0ICogIEB0eXBlIHtUb25lLlRpbWVsaW5lfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9ldmVudHMgPSBuZXcgVG9uZS5UaW1lbGluZSgxMDApO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBpbml0aWFsIHNjaGVkdWxlZCB2YWx1ZVxuXHRcdFx0ICogIEB0eXBlIHtOdW1iZXJ9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2luaXRpYWwgPSB0aGlzLl9mcm9tVW5pdHModGhpcy5fcGFyYW0udmFsdWUpO1xuXHQgICAgICAgIHRoaXMudmFsdWUgPSBvcHRpb25zLnZhbHVlO1xuXHQgICAgICAgIC8vZGVsZXRlIHRoZSBpbnB1dCBub2RlIHNvIHRoYXQgbm90aGluZyBjYW4gb3ZlcndyaXRlIHRoZSBzaWduYWwgdmFsdWVcblx0ICAgICAgICBkZWxldGUgdGhpcy5pbnB1dDtcblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLlRpbWVsaW5lU2lnbmFsLCBUb25lLlNpZ25hbCk7XG5cdCAgICAvKipcblx0XHQgKiAgVGhlIGV2ZW50IHR5cGVzIG9mIGEgc2NoZWR1bGFibGUgc2lnbmFsLlxuXHRcdCAqICBAZW51bSB7U3RyaW5nfVxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5UaW1lbGluZVNpZ25hbC5UeXBlID0ge1xuXHQgICAgICAgIExpbmVhcjogJ2xpbmVhcicsXG5cdCAgICAgICAgRXhwb25lbnRpYWw6ICdleHBvbmVudGlhbCcsXG5cdCAgICAgICAgVGFyZ2V0OiAndGFyZ2V0Jyxcblx0ICAgICAgICBTZXQ6ICdzZXQnXG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogVGhlIGN1cnJlbnQgdmFsdWUgb2YgdGhlIHNpZ25hbC4gXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuVGltZWxpbmVTaWduYWwjXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKiBAbmFtZSB2YWx1ZVxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuVGltZWxpbmVTaWduYWwucHJvdG90eXBlLCAndmFsdWUnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciBub3cgPSB0aGlzLm5vdygpO1xuXHQgICAgICAgICAgICB2YXIgdmFsID0gdGhpcy5nZXRWYWx1ZUF0VGltZShub3cpO1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fdG9Vbml0cyh2YWwpO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgICAgICAgaWYgKHRoaXMuX2V2ZW50cykge1xuXHQgICAgICAgICAgICAgICAgdmFyIGNvbnZlcnRlZFZhbCA9IHRoaXMuX2Zyb21Vbml0cyh2YWx1ZSk7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9pbml0aWFsID0gY29udmVydGVkVmFsO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5jYW5jZWxTY2hlZHVsZWRWYWx1ZXMoKTtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX3BhcmFtLnZhbHVlID0gY29udmVydGVkVmFsO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblx0ICAgIC8vXHRTQ0hFRFVMSU5HXG5cdCAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblx0ICAgIC8qKlxuXHRcdCAqICBTY2hlZHVsZXMgYSBwYXJhbWV0ZXIgdmFsdWUgY2hhbmdlIGF0IHRoZSBnaXZlbiB0aW1lLlxuXHRcdCAqICBAcGFyYW0geyp9XHR2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0IHRoZSBzaWduYWwuXG5cdFx0ICogIEBwYXJhbSB7VGltZX0gIHRpbWUgVGhlIHRpbWUgd2hlbiB0aGUgY2hhbmdlIHNob3VsZCBvY2N1ci5cblx0XHQgKiAgQHJldHVybnMge1RvbmUuVGltZWxpbmVTaWduYWx9IHRoaXNcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAvL3NldCB0aGUgZnJlcXVlbmN5IHRvIFwiRzRcIiBpbiBleGFjdGx5IDEgc2Vjb25kIGZyb20gbm93LiBcblx0XHQgKiBmcmVxLnNldFZhbHVlQXRUaW1lKFwiRzRcIiwgXCIrMVwiKTtcblx0XHQgKi9cblx0ICAgIFRvbmUuVGltZWxpbmVTaWduYWwucHJvdG90eXBlLnNldFZhbHVlQXRUaW1lID0gZnVuY3Rpb24gKHZhbHVlLCBzdGFydFRpbWUpIHtcblx0ICAgICAgICB2YWx1ZSA9IHRoaXMuX2Zyb21Vbml0cyh2YWx1ZSk7XG5cdCAgICAgICAgc3RhcnRUaW1lID0gdGhpcy50b1NlY29uZHMoc3RhcnRUaW1lKTtcblx0ICAgICAgICB0aGlzLl9ldmVudHMuYWRkKHtcblx0ICAgICAgICAgICAgJ3R5cGUnOiBUb25lLlRpbWVsaW5lU2lnbmFsLlR5cGUuU2V0LFxuXHQgICAgICAgICAgICAndmFsdWUnOiB2YWx1ZSxcblx0ICAgICAgICAgICAgJ3RpbWUnOiBzdGFydFRpbWVcblx0ICAgICAgICB9KTtcblx0ICAgICAgICAvL2ludm9rZSB0aGUgb3JpZ2luYWwgZXZlbnRcblx0ICAgICAgICB0aGlzLl9wYXJhbS5zZXRWYWx1ZUF0VGltZSh2YWx1ZSwgc3RhcnRUaW1lKTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgU2NoZWR1bGVzIGEgbGluZWFyIGNvbnRpbnVvdXMgY2hhbmdlIGluIHBhcmFtZXRlciB2YWx1ZSBmcm9tIHRoZSBcblx0XHQgKiAgcHJldmlvdXMgc2NoZWR1bGVkIHBhcmFtZXRlciB2YWx1ZSB0byB0aGUgZ2l2ZW4gdmFsdWUuXG5cdFx0ICogIFxuXHRcdCAqICBAcGFyYW0gIHtudW1iZXJ9IHZhbHVlICAgXG5cdFx0ICogIEBwYXJhbSAge1RpbWV9IGVuZFRpbWUgXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLlRpbWVsaW5lU2lnbmFsfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLlRpbWVsaW5lU2lnbmFsLnByb3RvdHlwZS5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZSA9IGZ1bmN0aW9uICh2YWx1ZSwgZW5kVGltZSkge1xuXHQgICAgICAgIHZhbHVlID0gdGhpcy5fZnJvbVVuaXRzKHZhbHVlKTtcblx0ICAgICAgICBlbmRUaW1lID0gdGhpcy50b1NlY29uZHMoZW5kVGltZSk7XG5cdCAgICAgICAgdGhpcy5fZXZlbnRzLmFkZCh7XG5cdCAgICAgICAgICAgICd0eXBlJzogVG9uZS5UaW1lbGluZVNpZ25hbC5UeXBlLkxpbmVhcixcblx0ICAgICAgICAgICAgJ3ZhbHVlJzogdmFsdWUsXG5cdCAgICAgICAgICAgICd0aW1lJzogZW5kVGltZVxuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIHRoaXMuX3BhcmFtLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKHZhbHVlLCBlbmRUaW1lKTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgU2NoZWR1bGVzIGFuIGV4cG9uZW50aWFsIGNvbnRpbnVvdXMgY2hhbmdlIGluIHBhcmFtZXRlciB2YWx1ZSBmcm9tIFxuXHRcdCAqICB0aGUgcHJldmlvdXMgc2NoZWR1bGVkIHBhcmFtZXRlciB2YWx1ZSB0byB0aGUgZ2l2ZW4gdmFsdWUuXG5cdFx0ICogIFxuXHRcdCAqICBAcGFyYW0gIHtudW1iZXJ9IHZhbHVlICAgXG5cdFx0ICogIEBwYXJhbSAge1RpbWV9IGVuZFRpbWUgXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLlRpbWVsaW5lU2lnbmFsfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLlRpbWVsaW5lU2lnbmFsLnByb3RvdHlwZS5leHBvbmVudGlhbFJhbXBUb1ZhbHVlQXRUaW1lID0gZnVuY3Rpb24gKHZhbHVlLCBlbmRUaW1lKSB7XG5cdCAgICAgICAgLy9nZXQgdGhlIHByZXZpb3VzIGV2ZW50IGFuZCBtYWtlIHN1cmUgaXQncyBub3Qgc3RhcnRpbmcgZnJvbSAwXG5cdCAgICAgICAgZW5kVGltZSA9IHRoaXMudG9TZWNvbmRzKGVuZFRpbWUpO1xuXHQgICAgICAgIHZhciBiZWZvcmVFdmVudCA9IHRoaXMuX3NlYXJjaEJlZm9yZShlbmRUaW1lKTtcblx0ICAgICAgICBpZiAoYmVmb3JlRXZlbnQgJiYgYmVmb3JlRXZlbnQudmFsdWUgPT09IDApIHtcblx0ICAgICAgICAgICAgLy9yZXNjaGVkdWxlIHRoYXQgZXZlbnRcblx0ICAgICAgICAgICAgdGhpcy5zZXRWYWx1ZUF0VGltZSh0aGlzLl9taW5PdXRwdXQsIGJlZm9yZUV2ZW50LnRpbWUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YWx1ZSA9IHRoaXMuX2Zyb21Vbml0cyh2YWx1ZSk7XG5cdCAgICAgICAgdmFyIHNldFZhbHVlID0gTWF0aC5tYXgodmFsdWUsIHRoaXMuX21pbk91dHB1dCk7XG5cdCAgICAgICAgdGhpcy5fZXZlbnRzLmFkZCh7XG5cdCAgICAgICAgICAgICd0eXBlJzogVG9uZS5UaW1lbGluZVNpZ25hbC5UeXBlLkV4cG9uZW50aWFsLFxuXHQgICAgICAgICAgICAndmFsdWUnOiBzZXRWYWx1ZSxcblx0ICAgICAgICAgICAgJ3RpbWUnOiBlbmRUaW1lXG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgLy9pZiB0aGUgcmFtcGVkIHRvIHZhbHVlIGlzIDAsIG1ha2UgaXQgZ28gdG8gdGhlIG1pbiBvdXRwdXQsIGFuZCB0aGVuIHNldCB0byAwLlxuXHQgICAgICAgIGlmICh2YWx1ZSA8IHRoaXMuX21pbk91dHB1dCkge1xuXHQgICAgICAgICAgICB0aGlzLl9wYXJhbS5leHBvbmVudGlhbFJhbXBUb1ZhbHVlQXRUaW1lKHRoaXMuX21pbk91dHB1dCwgZW5kVGltZSAtIHRoaXMuc2FtcGxlVGltZSk7XG5cdCAgICAgICAgICAgIHRoaXMuc2V0VmFsdWVBdFRpbWUoMCwgZW5kVGltZSk7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgdGhpcy5fcGFyYW0uZXhwb25lbnRpYWxSYW1wVG9WYWx1ZUF0VGltZSh2YWx1ZSwgZW5kVGltZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBTdGFydCBleHBvbmVudGlhbGx5IGFwcHJvYWNoaW5nIHRoZSB0YXJnZXQgdmFsdWUgYXQgdGhlIGdpdmVuIHRpbWUgd2l0aFxuXHRcdCAqICBhIHJhdGUgaGF2aW5nIHRoZSBnaXZlbiB0aW1lIGNvbnN0YW50LlxuXHRcdCAqICBAcGFyYW0ge251bWJlcn0gdmFsdWUgICAgICAgIFxuXHRcdCAqICBAcGFyYW0ge1RpbWV9IHN0YXJ0VGltZSAgICBcblx0XHQgKiAgQHBhcmFtIHtudW1iZXJ9IHRpbWVDb25zdGFudCBcblx0XHQgKiAgQHJldHVybnMge1RvbmUuVGltZWxpbmVTaWduYWx9IHRoaXMgXG5cdFx0ICovXG5cdCAgICBUb25lLlRpbWVsaW5lU2lnbmFsLnByb3RvdHlwZS5zZXRUYXJnZXRBdFRpbWUgPSBmdW5jdGlvbiAodmFsdWUsIHN0YXJ0VGltZSwgdGltZUNvbnN0YW50KSB7XG5cdCAgICAgICAgdmFsdWUgPSB0aGlzLl9mcm9tVW5pdHModmFsdWUpO1xuXHQgICAgICAgIHZhbHVlID0gTWF0aC5tYXgodGhpcy5fbWluT3V0cHV0LCB2YWx1ZSk7XG5cdCAgICAgICAgdGltZUNvbnN0YW50ID0gTWF0aC5tYXgodGhpcy5fbWluT3V0cHV0LCB0aW1lQ29uc3RhbnQpO1xuXHQgICAgICAgIHN0YXJ0VGltZSA9IHRoaXMudG9TZWNvbmRzKHN0YXJ0VGltZSk7XG5cdCAgICAgICAgdGhpcy5fZXZlbnRzLmFkZCh7XG5cdCAgICAgICAgICAgICd0eXBlJzogVG9uZS5UaW1lbGluZVNpZ25hbC5UeXBlLlRhcmdldCxcblx0ICAgICAgICAgICAgJ3ZhbHVlJzogdmFsdWUsXG5cdCAgICAgICAgICAgICd0aW1lJzogc3RhcnRUaW1lLFxuXHQgICAgICAgICAgICAnY29uc3RhbnQnOiB0aW1lQ29uc3RhbnRcblx0ICAgICAgICB9KTtcblx0ICAgICAgICB0aGlzLl9wYXJhbS5zZXRUYXJnZXRBdFRpbWUodmFsdWUsIHN0YXJ0VGltZSwgdGltZUNvbnN0YW50KTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgU2V0IGFuIGFycmF5IG9mIGFyYml0cmFyeSB2YWx1ZXMgc3RhcnRpbmcgYXQgdGhlIGdpdmVuIHRpbWUgZm9yIHRoZSBnaXZlbiBkdXJhdGlvbi5cblx0XHQgKiAgQHBhcmFtIHtGbG9hdDMyQXJyYXl9IHZhbHVlcyAgICAgICAgXG5cdFx0ICogIEBwYXJhbSB7VGltZX0gc3RhcnRUaW1lICAgIFxuXHRcdCAqICBAcGFyYW0ge1RpbWV9IGR1cmF0aW9uXG5cdFx0ICogIEBwYXJhbSB7Tm9ybWFsUmFuZ2V9IFtzY2FsaW5nPTFdIElmIHRoZSB2YWx1ZXMgaW4gdGhlIGN1cnZlIHNob3VsZCBiZSBzY2FsZWQgYnkgc29tZSB2YWx1ZVxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5UaW1lbGluZVNpZ25hbH0gdGhpcyBcblx0XHQgKi9cblx0ICAgIFRvbmUuVGltZWxpbmVTaWduYWwucHJvdG90eXBlLnNldFZhbHVlQ3VydmVBdFRpbWUgPSBmdW5jdGlvbiAodmFsdWVzLCBzdGFydFRpbWUsIGR1cmF0aW9uLCBzY2FsaW5nKSB7XG5cdCAgICAgICAgc2NhbGluZyA9IFRvbmUuZGVmYXVsdEFyZyhzY2FsaW5nLCAxKTtcblx0ICAgICAgICBkdXJhdGlvbiA9IHRoaXMudG9TZWNvbmRzKGR1cmF0aW9uKTtcblx0ICAgICAgICBzdGFydFRpbWUgPSB0aGlzLnRvU2Vjb25kcyhzdGFydFRpbWUpO1xuXHQgICAgICAgIHZhciBzZWdUaW1lID0gZHVyYXRpb24gLyAodmFsdWVzLmxlbmd0aCAtIDEpO1xuXHQgICAgICAgIHRoaXMuc2V0VmFsdWVBdFRpbWUodmFsdWVzWzBdICogc2NhbGluZywgc3RhcnRUaW1lKTtcblx0ICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IHZhbHVlcy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICB0aGlzLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKHZhbHVlc1tpXSAqIHNjYWxpbmcsIHN0YXJ0VGltZSArIGkgKiBzZWdUaW1lKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIENhbmNlbHMgYWxsIHNjaGVkdWxlZCBwYXJhbWV0ZXIgY2hhbmdlcyB3aXRoIHRpbWVzIGdyZWF0ZXIgdGhhbiBvciBcblx0XHQgKiAgZXF1YWwgdG8gc3RhcnRUaW1lLlxuXHRcdCAqICBcblx0XHQgKiAgQHBhcmFtICB7VGltZX0gc3RhcnRUaW1lXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLlRpbWVsaW5lU2lnbmFsfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLlRpbWVsaW5lU2lnbmFsLnByb3RvdHlwZS5jYW5jZWxTY2hlZHVsZWRWYWx1ZXMgPSBmdW5jdGlvbiAoYWZ0ZXIpIHtcblx0ICAgICAgICBhZnRlciA9IHRoaXMudG9TZWNvbmRzKGFmdGVyKTtcblx0ICAgICAgICB0aGlzLl9ldmVudHMuY2FuY2VsKGFmdGVyKTtcblx0ICAgICAgICB0aGlzLl9wYXJhbS5jYW5jZWxTY2hlZHVsZWRWYWx1ZXMoYWZ0ZXIpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBTZXRzIHRoZSBjb21wdXRlZCB2YWx1ZSBhdCB0aGUgZ2l2ZW4gdGltZS4gVGhpcyBwcm92aWRlc1xuXHRcdCAqICBhIHBvaW50IGZyb20gd2hpY2ggYSBsaW5lYXIgb3IgZXhwb25lbnRpYWwgY3VydmVcblx0XHQgKiAgY2FuIGJlIHNjaGVkdWxlZCBhZnRlci4gV2lsbCBjYW5jZWwgZXZlbnRzIGFmdGVyIFxuXHRcdCAqICB0aGUgZ2l2ZW4gdGltZSBhbmQgc2hvcnRlbiB0aGUgY3VycmVudGx5IHNjaGVkdWxlZFxuXHRcdCAqICBsaW5lYXIgb3IgZXhwb25lbnRpYWwgcmFtcCBzbyB0aGF0IGl0IGVuZHMgYXQgYHRpbWVgIC5cblx0XHQgKiAgVGhpcyBpcyB0byBhdm9pZCBkaXNjb250aW51aXRpZXMgYW5kIGNsaWNrcyBpbiBlbnZlbG9wZXMuIFxuXHRcdCAqICBAcGFyYW0ge1RpbWV9IHRpbWUgV2hlbiB0byBzZXQgdGhlIHJhbXAgcG9pbnRcblx0XHQgKiAgQHJldHVybnMge1RvbmUuVGltZWxpbmVTaWduYWx9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuVGltZWxpbmVTaWduYWwucHJvdG90eXBlLnNldFJhbXBQb2ludCA9IGZ1bmN0aW9uICh0aW1lKSB7XG5cdCAgICAgICAgdGltZSA9IHRoaXMudG9TZWNvbmRzKHRpbWUpO1xuXHQgICAgICAgIC8vZ2V0IHRoZSB2YWx1ZSBhdCB0aGUgZ2l2ZW4gdGltZVxuXHQgICAgICAgIHZhciB2YWwgPSB0aGlzLl90b1VuaXRzKHRoaXMuZ2V0VmFsdWVBdFRpbWUodGltZSkpO1xuXHQgICAgICAgIC8vaWYgdGhlcmUgaXMgYW4gZXZlbnQgYXQgdGhlIGdpdmVuIHRpbWVcblx0ICAgICAgICAvL2FuZCB0aGF0IGV2ZW4gaXMgbm90IGEgXCJzZXRcIlxuXHQgICAgICAgIHZhciBiZWZvcmUgPSB0aGlzLl9zZWFyY2hCZWZvcmUodGltZSk7XG5cdCAgICAgICAgaWYgKGJlZm9yZSAmJiBiZWZvcmUudGltZSA9PT0gdGltZSkge1xuXHQgICAgICAgICAgICAvL3JlbW92ZSBldmVyeXRoaW5nIGFmdGVyXG5cdCAgICAgICAgICAgIHRoaXMuY2FuY2VsU2NoZWR1bGVkVmFsdWVzKHRpbWUgKyB0aGlzLnNhbXBsZVRpbWUpO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIC8vcmVzY2hlZHVsZSB0aGUgbmV4dCBldmVudCB0byBlbmQgYXQgdGhlIGdpdmVuIHRpbWVcblx0ICAgICAgICAgICAgdmFyIGFmdGVyID0gdGhpcy5fc2VhcmNoQWZ0ZXIodGltZSk7XG5cdCAgICAgICAgICAgIGlmIChhZnRlcikge1xuXHQgICAgICAgICAgICAgICAgLy9jYW5jZWwgdGhlIG5leHQgZXZlbnQocylcblx0ICAgICAgICAgICAgICAgIHRoaXMuY2FuY2VsU2NoZWR1bGVkVmFsdWVzKHRpbWUpO1xuXHQgICAgICAgICAgICAgICAgaWYgKGFmdGVyLnR5cGUgPT09IFRvbmUuVGltZWxpbmVTaWduYWwuVHlwZS5MaW5lYXIpIHtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKHZhbCwgdGltZSk7XG5cdCAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGFmdGVyLnR5cGUgPT09IFRvbmUuVGltZWxpbmVTaWduYWwuVHlwZS5FeHBvbmVudGlhbCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuZXhwb25lbnRpYWxSYW1wVG9WYWx1ZUF0VGltZSh2YWwsIHRpbWUpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHRoaXMuc2V0VmFsdWVBdFRpbWUodmFsLCB0aW1lKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIERvIGEgbGluZWFyIHJhbXAgdG8gdGhlIGdpdmVuIHZhbHVlIGJldHdlZW4gdGhlIHN0YXJ0IGFuZCBmaW5pc2ggdGltZXMuXG5cdFx0ICogIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcmFtcCB0by5cblx0XHQgKiAgQHBhcmFtIHtUaW1lfSBzdGFydCBUaGUgYmVnaW5uaW5nIGFuY2hvciBwb2ludCB0byBkbyB0aGUgbGluZWFyIHJhbXBcblx0XHQgKiAgQHBhcmFtIHtUaW1lfSBmaW5pc2ggVGhlIGVuZGluZyBhbmNob3IgcG9pbnQgYnkgd2hpY2ggdGhlIHZhbHVlIG9mXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgIHRoZSBzaWduYWwgd2lsbCBlcXVhbCB0aGUgZ2l2ZW4gdmFsdWUuXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLlRpbWVsaW5lU2lnbmFsfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLlRpbWVsaW5lU2lnbmFsLnByb3RvdHlwZS5saW5lYXJSYW1wVG9WYWx1ZUJldHdlZW4gPSBmdW5jdGlvbiAodmFsdWUsIHN0YXJ0LCBmaW5pc2gpIHtcblx0ICAgICAgICB0aGlzLnNldFJhbXBQb2ludChzdGFydCk7XG5cdCAgICAgICAgdGhpcy5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZSh2YWx1ZSwgZmluaXNoKTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgRG8gYSBleHBvbmVudGlhbCByYW1wIHRvIHRoZSBnaXZlbiB2YWx1ZSBiZXR3ZWVuIHRoZSBzdGFydCBhbmQgZmluaXNoIHRpbWVzLlxuXHRcdCAqICBAcGFyYW0ge051bWJlcn0gdmFsdWUgVGhlIHZhbHVlIHRvIHJhbXAgdG8uXG5cdFx0ICogIEBwYXJhbSB7VGltZX0gc3RhcnQgVGhlIGJlZ2lubmluZyBhbmNob3IgcG9pbnQgdG8gZG8gdGhlIGV4cG9uZW50aWFsIHJhbXBcblx0XHQgKiAgQHBhcmFtIHtUaW1lfSBmaW5pc2ggVGhlIGVuZGluZyBhbmNob3IgcG9pbnQgYnkgd2hpY2ggdGhlIHZhbHVlIG9mXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgIHRoZSBzaWduYWwgd2lsbCBlcXVhbCB0aGUgZ2l2ZW4gdmFsdWUuXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLlRpbWVsaW5lU2lnbmFsfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLlRpbWVsaW5lU2lnbmFsLnByb3RvdHlwZS5leHBvbmVudGlhbFJhbXBUb1ZhbHVlQmV0d2VlbiA9IGZ1bmN0aW9uICh2YWx1ZSwgc3RhcnQsIGZpbmlzaCkge1xuXHQgICAgICAgIHRoaXMuc2V0UmFtcFBvaW50KHN0YXJ0KTtcblx0ICAgICAgICB0aGlzLmV4cG9uZW50aWFsUmFtcFRvVmFsdWVBdFRpbWUodmFsdWUsIGZpbmlzaCk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdCAgICAvL1x0R0VUVElORyBTQ0hFRFVMRUQgVkFMVUVTXG5cdCAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblx0ICAgIC8qKlxuXHRcdCAqICBSZXR1cm5zIHRoZSB2YWx1ZSBiZWZvcmUgb3IgZXF1YWwgdG8gdGhlIGdpdmVuIHRpbWVcblx0XHQgKiAgQHBhcmFtICB7TnVtYmVyfSAgdGltZSAgVGhlIHRpbWUgdG8gcXVlcnlcblx0XHQgKiAgQHJldHVybiAge09iamVjdH0gIFRoZSBldmVudCBhdCBvciBiZWZvcmUgdGhlIGdpdmVuIHRpbWUuXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLlRpbWVsaW5lU2lnbmFsLnByb3RvdHlwZS5fc2VhcmNoQmVmb3JlID0gZnVuY3Rpb24gKHRpbWUpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy5fZXZlbnRzLmdldCh0aW1lKTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgVGhlIGV2ZW50IGFmdGVyIHRoZSBnaXZlbiB0aW1lXG5cdFx0ICogIEBwYXJhbSAge051bWJlcn0gIHRpbWUgIFRoZSB0aW1lIHRvIHF1ZXJ5LlxuXHRcdCAqICBAcmV0dXJuICB7T2JqZWN0fSAgVGhlIG5leHQgZXZlbnQgYWZ0ZXIgdGhlIGdpdmVuIHRpbWVcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuVGltZWxpbmVTaWduYWwucHJvdG90eXBlLl9zZWFyY2hBZnRlciA9IGZ1bmN0aW9uICh0aW1lKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuX2V2ZW50cy5nZXRBZnRlcih0aW1lKTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgR2V0IHRoZSBzY2hlZHVsZWQgdmFsdWUgYXQgdGhlIGdpdmVuIHRpbWUuIFRoaXMgd2lsbFxuXHRcdCAqICByZXR1cm4gdGhlIHVuY29udmVydGVkIChyYXcpIHZhbHVlLlxuXHRcdCAqICBAcGFyYW0gIHtOdW1iZXJ9ICB0aW1lICBUaGUgdGltZSBpbiBzZWNvbmRzLlxuXHRcdCAqICBAcmV0dXJuICB7TnVtYmVyfSAgVGhlIHNjaGVkdWxlZCB2YWx1ZSBhdCB0aGUgZ2l2ZW4gdGltZS5cblx0XHQgKi9cblx0ICAgIFRvbmUuVGltZWxpbmVTaWduYWwucHJvdG90eXBlLmdldFZhbHVlQXRUaW1lID0gZnVuY3Rpb24gKHRpbWUpIHtcblx0ICAgICAgICB0aW1lID0gdGhpcy50b1NlY29uZHModGltZSk7XG5cdCAgICAgICAgdmFyIGFmdGVyID0gdGhpcy5fc2VhcmNoQWZ0ZXIodGltZSk7XG5cdCAgICAgICAgdmFyIGJlZm9yZSA9IHRoaXMuX3NlYXJjaEJlZm9yZSh0aW1lKTtcblx0ICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLl9pbml0aWFsO1xuXHQgICAgICAgIC8vaWYgaXQgd2FzIHNldCBieVxuXHQgICAgICAgIGlmIChiZWZvcmUgPT09IG51bGwpIHtcblx0ICAgICAgICAgICAgdmFsdWUgPSB0aGlzLl9pbml0aWFsO1xuXHQgICAgICAgIH0gZWxzZSBpZiAoYmVmb3JlLnR5cGUgPT09IFRvbmUuVGltZWxpbmVTaWduYWwuVHlwZS5UYXJnZXQpIHtcblx0ICAgICAgICAgICAgdmFyIHByZXZpb3VzID0gdGhpcy5fZXZlbnRzLmdldEJlZm9yZShiZWZvcmUudGltZSk7XG5cdCAgICAgICAgICAgIHZhciBwcmV2aW91VmFsO1xuXHQgICAgICAgICAgICBpZiAocHJldmlvdXMgPT09IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgIHByZXZpb3VWYWwgPSB0aGlzLl9pbml0aWFsO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgcHJldmlvdVZhbCA9IHByZXZpb3VzLnZhbHVlO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHZhbHVlID0gdGhpcy5fZXhwb25lbnRpYWxBcHByb2FjaChiZWZvcmUudGltZSwgcHJldmlvdVZhbCwgYmVmb3JlLnZhbHVlLCBiZWZvcmUuY29uc3RhbnQsIHRpbWUpO1xuXHQgICAgICAgIH0gZWxzZSBpZiAoYWZ0ZXIgPT09IG51bGwpIHtcblx0ICAgICAgICAgICAgdmFsdWUgPSBiZWZvcmUudmFsdWU7XG5cdCAgICAgICAgfSBlbHNlIGlmIChhZnRlci50eXBlID09PSBUb25lLlRpbWVsaW5lU2lnbmFsLlR5cGUuTGluZWFyKSB7XG5cdCAgICAgICAgICAgIHZhbHVlID0gdGhpcy5fbGluZWFySW50ZXJwb2xhdGUoYmVmb3JlLnRpbWUsIGJlZm9yZS52YWx1ZSwgYWZ0ZXIudGltZSwgYWZ0ZXIudmFsdWUsIHRpbWUpO1xuXHQgICAgICAgIH0gZWxzZSBpZiAoYWZ0ZXIudHlwZSA9PT0gVG9uZS5UaW1lbGluZVNpZ25hbC5UeXBlLkV4cG9uZW50aWFsKSB7XG5cdCAgICAgICAgICAgIHZhbHVlID0gdGhpcy5fZXhwb25lbnRpYWxJbnRlcnBvbGF0ZShiZWZvcmUudGltZSwgYmVmb3JlLnZhbHVlLCBhZnRlci50aW1lLCBhZnRlci52YWx1ZSwgdGltZSk7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgdmFsdWUgPSBiZWZvcmUudmFsdWU7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB2YWx1ZTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgV2hlbiBzaWduYWxzIGNvbm5lY3QgdG8gb3RoZXIgc2lnbmFscyBvciBBdWRpb1BhcmFtcywgXG5cdFx0ICogIHRoZXkgdGFrZSBvdmVyIHRoZSBvdXRwdXQgdmFsdWUgb2YgdGhhdCBzaWduYWwgb3IgQXVkaW9QYXJhbS4gXG5cdFx0ICogIEZvciBhbGwgb3RoZXIgbm9kZXMsIHRoZSBiZWhhdmlvciBpcyB0aGUgc2FtZSBhcyBhIGRlZmF1bHQgPGNvZGU+Y29ubmVjdDwvY29kZT4uIFxuXHRcdCAqXG5cdFx0ICogIEBvdmVycmlkZVxuXHRcdCAqICBAcGFyYW0ge0F1ZGlvUGFyYW18QXVkaW9Ob2RlfFRvbmUuU2lnbmFsfFRvbmV9IG5vZGUgXG5cdFx0ICogIEBwYXJhbSB7bnVtYmVyfSBbb3V0cHV0TnVtYmVyPTBdIFRoZSBvdXRwdXQgbnVtYmVyIHRvIGNvbm5lY3QgZnJvbS5cblx0XHQgKiAgQHBhcmFtIHtudW1iZXJ9IFtpbnB1dE51bWJlcj0wXSBUaGUgaW5wdXQgbnVtYmVyIHRvIGNvbm5lY3QgdG8uXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLlRpbWVsaW5lU2lnbmFsfSB0aGlzXG5cdFx0ICogIEBtZXRob2Rcblx0XHQgKi9cblx0ICAgIFRvbmUuVGltZWxpbmVTaWduYWwucHJvdG90eXBlLmNvbm5lY3QgPSBUb25lLlNpZ25hbEJhc2UucHJvdG90eXBlLmNvbm5lY3Q7XG5cdCAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblx0ICAgIC8vXHRBVVRPTUFUSU9OIENVUlZFIENBTENVTEFUSU9OU1xuXHQgICAgLy9cdE1JVCBMaWNlbnNlLCBjb3B5cmlnaHQgKGMpIDIwMTQgSm9yZGFuIFNhbnRlbGxcblx0ICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQgICAgLyoqXG5cdFx0ICogIENhbGN1bGF0ZXMgdGhlIHRoZSB2YWx1ZSBhbG9uZyB0aGUgY3VydmUgcHJvZHVjZWQgYnkgc2V0VGFyZ2V0QXRUaW1lXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLlRpbWVsaW5lU2lnbmFsLnByb3RvdHlwZS5fZXhwb25lbnRpYWxBcHByb2FjaCA9IGZ1bmN0aW9uICh0MCwgdjAsIHYxLCB0aW1lQ29uc3RhbnQsIHQpIHtcblx0ICAgICAgICByZXR1cm4gdjEgKyAodjAgLSB2MSkgKiBNYXRoLmV4cCgtKHQgLSB0MCkgLyB0aW1lQ29uc3RhbnQpO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBDYWxjdWxhdGVzIHRoZSB0aGUgdmFsdWUgYWxvbmcgdGhlIGN1cnZlIHByb2R1Y2VkIGJ5IGxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLlRpbWVsaW5lU2lnbmFsLnByb3RvdHlwZS5fbGluZWFySW50ZXJwb2xhdGUgPSBmdW5jdGlvbiAodDAsIHYwLCB0MSwgdjEsIHQpIHtcblx0ICAgICAgICByZXR1cm4gdjAgKyAodjEgLSB2MCkgKiAoKHQgLSB0MCkgLyAodDEgLSB0MCkpO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBDYWxjdWxhdGVzIHRoZSB0aGUgdmFsdWUgYWxvbmcgdGhlIGN1cnZlIHByb2R1Y2VkIGJ5IGV4cG9uZW50aWFsUmFtcFRvVmFsdWVBdFRpbWVcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuVGltZWxpbmVTaWduYWwucHJvdG90eXBlLl9leHBvbmVudGlhbEludGVycG9sYXRlID0gZnVuY3Rpb24gKHQwLCB2MCwgdDEsIHYxLCB0KSB7XG5cdCAgICAgICAgdjAgPSBNYXRoLm1heCh0aGlzLl9taW5PdXRwdXQsIHYwKTtcblx0ICAgICAgICByZXR1cm4gdjAgKiBNYXRoLnBvdyh2MSAvIHYwLCAodCAtIHQwKSAvICh0MSAtIHQwKSk7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIENsZWFuIHVwLlxuXHRcdCAqICBAcmV0dXJuIHtUb25lLlRpbWVsaW5lU2lnbmFsfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLlRpbWVsaW5lU2lnbmFsLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuU2lnbmFsLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgdGhpcy5fZXZlbnRzLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9ldmVudHMgPSBudWxsO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLlRpbWVsaW5lU2lnbmFsO1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgUG93IGFwcGxpZXMgYW4gZXhwb25lbnQgdG8gdGhlIGluY29taW5nIHNpZ25hbC4gVGhlIGluY29taW5nIHNpZ25hbFxuXHRcdCAqICAgICAgICAgbXVzdCBiZSBBdWRpb1JhbmdlLlxuXHRcdCAqXG5cdFx0ICogIEBleHRlbmRzIHtUb25lLlNpZ25hbEJhc2V9XG5cdFx0ICogIEBjb25zdHJ1Y3RvclxuXHRcdCAqICBAcGFyYW0ge1Bvc2l0aXZlfSBleHAgVGhlIGV4cG9uZW50IHRvIGFwcGx5IHRvIHRoZSBpbmNvbWluZyBzaWduYWwsIG11c3QgYmUgYXQgbGVhc3QgMi4gXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogdmFyIHBvdyA9IG5ldyBUb25lLlBvdygyKTtcblx0XHQgKiB2YXIgc2lnID0gbmV3IFRvbmUuU2lnbmFsKDAuNSkuY29ubmVjdChwb3cpO1xuXHRcdCAqIC8vb3V0cHV0IG9mIHBvdyBpcyAwLjI1LiBcblx0XHQgKi9cblx0ICAgIFRvbmUuUG93ID0gZnVuY3Rpb24gKGV4cCkge1xuXHQgICAgICAgIFRvbmUuU2lnbmFsQmFzZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogdGhlIGV4cG9uZW50XG5cdFx0XHQgKiBAcHJpdmF0ZVxuXHRcdFx0ICogQHR5cGUge251bWJlcn1cblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2V4cCA9IFRvbmUuZGVmYXVsdEFyZyhleHAsIDEpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIEB0eXBlIHtXYXZlU2hhcGVyTm9kZX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fZXhwU2NhbGVyID0gdGhpcy5pbnB1dCA9IHRoaXMub3V0cHV0ID0gbmV3IFRvbmUuV2F2ZVNoYXBlcih0aGlzLl9leHBGdW5jKHRoaXMuX2V4cCksIDgxOTIpO1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuUG93LCBUb25lLlNpZ25hbEJhc2UpO1xuXHQgICAgLyoqXG5cdFx0ICogVGhlIHZhbHVlIG9mIHRoZSBleHBvbmVudC5cblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5Qb3cjXG5cdFx0ICogQHR5cGUge251bWJlcn1cblx0XHQgKiBAbmFtZSB2YWx1ZVxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuUG93LnByb3RvdHlwZSwgJ3ZhbHVlJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fZXhwO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAoZXhwKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2V4cCA9IGV4cDtcblx0ICAgICAgICAgICAgdGhpcy5fZXhwU2NhbGVyLnNldE1hcCh0aGlzLl9leHBGdW5jKHRoaXMuX2V4cCkpO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIHRoZSBmdW5jdGlvbiB3aGljaCBtYXBzIHRoZSB3YXZlc2hhcGVyXG5cdFx0ICogIEBwYXJhbSAgIHtudW1iZXJ9IGV4cFxuXHRcdCAqICBAcmV0dXJuIHtmdW5jdGlvbn1cblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuUG93LnByb3RvdHlwZS5fZXhwRnVuYyA9IGZ1bmN0aW9uIChleHApIHtcblx0ICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHZhbCkge1xuXHQgICAgICAgICAgICByZXR1cm4gTWF0aC5wb3coTWF0aC5hYnModmFsKSwgZXhwKTtcblx0ICAgICAgICB9O1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBDbGVhbiB1cC5cblx0XHQgKiAgQHJldHVybnMge1RvbmUuUG93fSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLlBvdy5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLlNpZ25hbEJhc2UucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLl9leHBTY2FsZXIuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX2V4cFNjYWxlciA9IG51bGw7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuUG93O1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgIFRvbmUuRW52ZWxvcGUgaXMgYW4gW0FEU1JdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1N5bnRoZXNpemVyI0FEU1JfZW52ZWxvcGUpXG5cdFx0ICogICAgICAgICAgZW52ZWxvcGUgZ2VuZXJhdG9yLiBUb25lLkVudmVsb3BlIG91dHB1dHMgYSBzaWduYWwgd2hpY2hcblx0XHQgKiAgICAgICAgICBjYW4gYmUgY29ubmVjdGVkIHRvIGFuIEF1ZGlvUGFyYW0gb3IgVG9uZS5TaWduYWwuXG5cdFx0ICogICAgICAgICAgPGltZyBzcmM9XCJodHRwczovL3VwbG9hZC53aWtpbWVkaWEub3JnL3dpa2lwZWRpYS9jb21tb25zL2UvZWEvQURTUl9wYXJhbWV0ZXIuc3ZnXCI+XG5cdFx0ICpcblx0XHQgKiAgQGNvbnN0cnVjdG9yXG5cdFx0ICogIEBleHRlbmRzIHtUb25lLkF1ZGlvTm9kZX1cblx0XHQgKiAgQHBhcmFtIHtUaW1lfSBbYXR0YWNrXSBUaGUgYW1vdW50IG9mIHRpbWUgaXQgdGFrZXMgZm9yIHRoZSBlbnZlbG9wZSB0byBnbyBmcm9tXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgMCB0byBpdCdzIG1heGltdW0gdmFsdWUuXG5cdFx0ICogIEBwYXJhbSB7VGltZX0gW2RlY2F5XVx0VGhlIHBlcmlvZCBvZiB0aW1lIGFmdGVyIHRoZSBhdHRhY2sgdGhhdCBpdCB0YWtlcyBmb3IgdGhlIGVudmVsb3BlXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgIFx0dG8gZmFsbCB0byB0aGUgc3VzdGFpbiB2YWx1ZS5cblx0XHQgKiAgQHBhcmFtIHtOb3JtYWxSYW5nZX0gW3N1c3RhaW5dXHRUaGUgcGVyY2VudCBvZiB0aGUgbWF4aW11bSB2YWx1ZSB0aGF0IHRoZSBlbnZlbG9wZSByZXN0cyBhdCB1bnRpbFxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcdHRoZSByZWxlYXNlIGlzIHRyaWdnZXJlZC5cblx0XHQgKiAgQHBhcmFtIHtUaW1lfSBbcmVsZWFzZV1cdFRoZSBhbW91bnQgb2YgdGltZSBhZnRlciB0aGUgcmVsZWFzZSBpcyB0cmlnZ2VyZWQgaXQgdGFrZXMgdG8gcmVhY2ggMC5cblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAvL2FuIGFtcGxpdHVkZSBlbnZlbG9wZVxuXHRcdCAqIHZhciBnYWluTm9kZSA9IFRvbmUuY29udGV4dC5jcmVhdGVHYWluKCk7XG5cdFx0ICogdmFyIGVudiA9IG5ldyBUb25lLkVudmVsb3BlKHtcblx0XHQgKiBcdFwiYXR0YWNrXCIgOiAwLjEsXG5cdFx0ICogXHRcImRlY2F5XCIgOiAwLjIsXG5cdFx0ICogXHRcInN1c3RhaW5cIiA6IDEsXG5cdFx0ICogXHRcInJlbGVhc2VcIiA6IDAuOCxcblx0XHQgKiB9KTtcblx0XHQgKiBlbnYuY29ubmVjdChnYWluTm9kZS5nYWluKTtcblx0XHQgKi9cblx0ICAgIFRvbmUuRW52ZWxvcGUgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgLy9nZXQgYWxsIG9mIHRoZSBkZWZhdWx0c1xuXHQgICAgICAgIHZhciBvcHRpb25zID0gVG9uZS5kZWZhdWx0cyhhcmd1bWVudHMsIFtcblx0ICAgICAgICAgICAgJ2F0dGFjaycsXG5cdCAgICAgICAgICAgICdkZWNheScsXG5cdCAgICAgICAgICAgICdzdXN0YWluJyxcblx0ICAgICAgICAgICAgJ3JlbGVhc2UnXG5cdCAgICAgICAgXSwgVG9uZS5FbnZlbG9wZSk7XG5cdCAgICAgICAgVG9uZS5BdWRpb05vZGUuY2FsbCh0aGlzKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBXaGVuIHRyaWdnZXJBdHRhY2sgaXMgY2FsbGVkLCB0aGUgYXR0YWNrIHRpbWUgaXMgdGhlIGFtb3VudCBvZlxuXHRcdFx0ICogIHRpbWUgaXQgdGFrZXMgZm9yIHRoZSBlbnZlbG9wZSB0byByZWFjaCBpdCdzIG1heGltdW0gdmFsdWUuXG5cdFx0XHQgKiAgQHR5cGUge1RpbWV9XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmF0dGFjayA9IG9wdGlvbnMuYXR0YWNrO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIEFmdGVyIHRoZSBhdHRhY2sgcG9ydGlvbiBvZiB0aGUgZW52ZWxvcGUsIHRoZSB2YWx1ZSB3aWxsIGZhbGxcblx0XHRcdCAqICBvdmVyIHRoZSBkdXJhdGlvbiBvZiB0aGUgZGVjYXkgdGltZSB0byBpdCdzIHN1c3RhaW4gdmFsdWUuXG5cdFx0XHQgKiAgQHR5cGUge1RpbWV9XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmRlY2F5ID0gb3B0aW9ucy5kZWNheTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqIFx0VGhlIHN1c3RhaW4gdmFsdWUgaXMgdGhlIHZhbHVlXG5cdFx0XHQgKiBcdHdoaWNoIHRoZSBlbnZlbG9wZSByZXN0cyBhdCBhZnRlciB0cmlnZ2VyQXR0YWNrIGlzXG5cdFx0XHQgKiBcdGNhbGxlZCwgYnV0IGJlZm9yZSB0cmlnZ2VyUmVsZWFzZSBpcyBpbnZva2VkLlxuXHRcdFx0ICogIEB0eXBlIHtOb3JtYWxSYW5nZX1cblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuc3VzdGFpbiA9IG9wdGlvbnMuc3VzdGFpbjtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBBZnRlciB0cmlnZ2VyUmVsZWFzZSBpcyBjYWxsZWQsIHRoZSBlbnZlbG9wZSdzXG5cdFx0XHQgKiAgdmFsdWUgd2lsbCBmYWxsIHRvIGl0J3MgbWltaW51bSB2YWx1ZSBvdmVyIHRoZVxuXHRcdFx0ICogIGR1cmF0aW9uIG9mIHRoZSByZWxlYXNlIHRpbWUuXG5cdFx0XHQgKiAgQHR5cGUge1RpbWV9XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLnJlbGVhc2UgPSBvcHRpb25zLnJlbGVhc2U7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgdGhlIG5leHQgdGltZSB0aGUgZW52ZWxvcGUgaXMgYXQgc3RhbmRieVxuXHRcdFx0ICogIEB0eXBlIHtudW1iZXJ9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2F0dGFja0N1cnZlID0gJ2xpbmVhcic7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgdGhlIG5leHQgdGltZSB0aGUgZW52ZWxvcGUgaXMgYXQgc3RhbmRieVxuXHRcdFx0ICogIEB0eXBlIHtudW1iZXJ9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX3JlbGVhc2VDdXJ2ZSA9ICdleHBvbmVudGlhbCc7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgdGhlIHNpZ25hbFxuXHRcdFx0ICogIEB0eXBlIHtUb25lLlRpbWVsaW5lU2lnbmFsfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9zaWcgPSB0aGlzLm91dHB1dCA9IG5ldyBUb25lLlRpbWVsaW5lU2lnbmFsKCk7XG5cdCAgICAgICAgdGhpcy5fc2lnLnNldFZhbHVlQXRUaW1lKDAsIDApO1xuXHQgICAgICAgIC8vc2V0IHRoZSBhdHRhY2tDdXJ2ZSBpbml0aWFsbHlcblx0ICAgICAgICB0aGlzLmF0dGFja0N1cnZlID0gb3B0aW9ucy5hdHRhY2tDdXJ2ZTtcblx0ICAgICAgICB0aGlzLnJlbGVhc2VDdXJ2ZSA9IG9wdGlvbnMucmVsZWFzZUN1cnZlO1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuRW52ZWxvcGUsIFRvbmUuQXVkaW9Ob2RlKTtcblx0ICAgIC8qKlxuXHRcdCAqICB0aGUgZGVmYXVsdCBwYXJhbWV0ZXJzXG5cdFx0ICogIEBzdGF0aWNcblx0XHQgKiAgQGNvbnN0XG5cdFx0ICovXG5cdCAgICBUb25lLkVudmVsb3BlLmRlZmF1bHRzID0ge1xuXHQgICAgICAgICdhdHRhY2snOiAwLjAxLFxuXHQgICAgICAgICdkZWNheSc6IDAuMSxcblx0ICAgICAgICAnc3VzdGFpbic6IDAuNSxcblx0ICAgICAgICAncmVsZWFzZSc6IDEsXG5cdCAgICAgICAgJ2F0dGFja0N1cnZlJzogJ2xpbmVhcicsXG5cdCAgICAgICAgJ3JlbGVhc2VDdXJ2ZSc6ICdleHBvbmVudGlhbCdcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiBSZWFkIHRoZSBjdXJyZW50IHZhbHVlIG9mIHRoZSBlbnZlbG9wZS4gVXNlZnVsIGZvclxuXHRcdCAqIHN5bmNyb25pemluZyB2aXN1YWwgb3V0cHV0IHRvIHRoZSBlbnZlbG9wZS5cblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5FbnZlbG9wZSNcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqIEBuYW1lIHZhbHVlXG5cdFx0ICogQHJlYWRPbmx5XG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5FbnZlbG9wZS5wcm90b3R5cGUsICd2YWx1ZScsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VmFsdWVBdFRpbWUodGhpcy5ub3coKSk7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiBUaGUgc2hhcGUgb2YgdGhlIGF0dGFjay5cblx0XHQgKiBDYW4gYmUgYW55IG9mIHRoZXNlIHN0cmluZ3M6XG5cdFx0ICogPHVsPlxuXHRcdCAqICAgPGxpPmxpbmVhcjwvbGk+XG5cdFx0ICogICA8bGk+ZXhwb25lbnRpYWw8L2xpPlxuXHRcdCAqICAgPGxpPnNpbmU8L2xpPlxuXHRcdCAqICAgPGxpPmNvc2luZTwvbGk+XG5cdFx0ICogICA8bGk+Ym91bmNlPC9saT5cblx0XHQgKiAgIDxsaT5yaXBwbGU8L2xpPlxuXHRcdCAqICAgPGxpPnN0ZXA8L2xpPlxuXHRcdCAqIDwvdWw+XG5cdFx0ICogQ2FuIGFsc28gYmUgYW4gYXJyYXkgd2hpY2ggZGVzY3JpYmVzIHRoZSBjdXJ2ZS4gVmFsdWVzXG5cdFx0ICogaW4gdGhlIGFycmF5IGFyZSBldmVubHkgc3ViZGl2aWRlZCBhbmQgbGluZWFybHlcblx0XHQgKiBpbnRlcnBvbGF0ZWQgb3ZlciB0aGUgZHVyYXRpb24gb2YgdGhlIGF0dGFjay5cblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5FbnZlbG9wZSNcblx0XHQgKiBAdHlwZSB7U3RyaW5nfEFycmF5fVxuXHRcdCAqIEBuYW1lIGF0dGFja0N1cnZlXG5cdFx0ICogQGV4YW1wbGVcblx0XHQgKiBlbnYuYXR0YWNrQ3VydmUgPSBcImxpbmVhclwiO1xuXHRcdCAqIEBleGFtcGxlXG5cdFx0ICogLy9jYW4gYWxzbyBiZSBhbiBhcnJheVxuXHRcdCAqIGVudi5hdHRhY2tDdXJ2ZSA9IFswLCAwLjIsIDAuMywgMC40LCAxXVxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuRW52ZWxvcGUucHJvdG90eXBlLCAnYXR0YWNrQ3VydmUnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIGlmIChUb25lLmlzU3RyaW5nKHRoaXMuX2F0dGFja0N1cnZlKSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2F0dGFja0N1cnZlO1xuXHQgICAgICAgICAgICB9IGVsc2UgaWYgKFRvbmUuaXNBcnJheSh0aGlzLl9hdHRhY2tDdXJ2ZSkpIHtcblx0ICAgICAgICAgICAgICAgIC8vbG9vayB1cCB0aGUgbmFtZSBpbiB0aGUgY3VydmVzIGFycmF5XG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciB0eXBlIGluIFRvbmUuRW52ZWxvcGUuVHlwZSkge1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChUb25lLkVudmVsb3BlLlR5cGVbdHlwZV0uSW4gPT09IHRoaXMuX2F0dGFja0N1cnZlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0eXBlO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIC8vb3RoZXJ3aXNlIGp1c3QgcmV0dXJuIHRoZSBhcnJheVxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2F0dGFja0N1cnZlO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChjdXJ2ZSkge1xuXHQgICAgICAgICAgICAvL2NoZWNrIGlmIGl0J3MgYSB2YWxpZCB0eXBlXG5cdCAgICAgICAgICAgIGlmIChUb25lLkVudmVsb3BlLlR5cGUuaGFzT3duUHJvcGVydHkoY3VydmUpKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgY3VydmVEZWYgPSBUb25lLkVudmVsb3BlLlR5cGVbY3VydmVdO1xuXHQgICAgICAgICAgICAgICAgaWYgKFRvbmUuaXNPYmplY3QoY3VydmVEZWYpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5fYXR0YWNrQ3VydmUgPSBjdXJ2ZURlZi5Jbjtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5fYXR0YWNrQ3VydmUgPSBjdXJ2ZURlZjtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSBlbHNlIGlmIChUb25lLmlzQXJyYXkoY3VydmUpKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9hdHRhY2tDdXJ2ZSA9IGN1cnZlO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUb25lLkVudmVsb3BlOiBpbnZhbGlkIGN1cnZlOiAnICsgY3VydmUpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiBUaGUgc2hhcGUgb2YgdGhlIHJlbGVhc2UuIFNlZSB0aGUgYXR0YWNrIGN1cnZlIHR5cGVzLlxuXHRcdCAqIEBtZW1iZXJPZiBUb25lLkVudmVsb3BlI1xuXHRcdCAqIEB0eXBlIHtTdHJpbmd8QXJyYXl9XG5cdFx0ICogQG5hbWUgcmVsZWFzZUN1cnZlXG5cdFx0ICogQGV4YW1wbGVcblx0XHQgKiBlbnYucmVsZWFzZUN1cnZlID0gXCJsaW5lYXJcIjtcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkVudmVsb3BlLnByb3RvdHlwZSwgJ3JlbGVhc2VDdXJ2ZScsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgaWYgKFRvbmUuaXNTdHJpbmcodGhpcy5fcmVsZWFzZUN1cnZlKSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JlbGVhc2VDdXJ2ZTtcblx0ICAgICAgICAgICAgfSBlbHNlIGlmIChUb25lLmlzQXJyYXkodGhpcy5fcmVsZWFzZUN1cnZlKSkge1xuXHQgICAgICAgICAgICAgICAgLy9sb29rIHVwIHRoZSBuYW1lIGluIHRoZSBjdXJ2ZXMgYXJyYXlcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIHR5cGUgaW4gVG9uZS5FbnZlbG9wZS5UeXBlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKFRvbmUuRW52ZWxvcGUuVHlwZVt0eXBlXS5PdXQgPT09IHRoaXMuX3JlbGVhc2VDdXJ2ZSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHlwZTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAvL290aGVyd2lzZSBqdXN0IHJldHVybiB0aGUgYXJyYXlcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZWxlYXNlQ3VydmU7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKGN1cnZlKSB7XG5cdCAgICAgICAgICAgIC8vY2hlY2sgaWYgaXQncyBhIHZhbGlkIHR5cGVcblx0ICAgICAgICAgICAgaWYgKFRvbmUuRW52ZWxvcGUuVHlwZS5oYXNPd25Qcm9wZXJ0eShjdXJ2ZSkpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBjdXJ2ZURlZiA9IFRvbmUuRW52ZWxvcGUuVHlwZVtjdXJ2ZV07XG5cdCAgICAgICAgICAgICAgICBpZiAoVG9uZS5pc09iamVjdChjdXJ2ZURlZikpIHtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZWxlYXNlQ3VydmUgPSBjdXJ2ZURlZi5PdXQ7XG5cdCAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlbGVhc2VDdXJ2ZSA9IGN1cnZlRGVmO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9IGVsc2UgaWYgKFRvbmUuaXNBcnJheShjdXJ2ZSkpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX3JlbGVhc2VDdXJ2ZSA9IGN1cnZlO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUb25lLkVudmVsb3BlOiBpbnZhbGlkIGN1cnZlOiAnICsgY3VydmUpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgVHJpZ2dlciB0aGUgYXR0YWNrL2RlY2F5IHBvcnRpb24gb2YgdGhlIEFEU1IgZW52ZWxvcGUuXG5cdFx0ICogIEBwYXJhbSAge1RpbWV9IFt0aW1lPW5vd10gV2hlbiB0aGUgYXR0YWNrIHNob3VsZCBzdGFydC5cblx0XHQgKiAgQHBhcmFtIHtOb3JtYWxSYW5nZX0gW3ZlbG9jaXR5PTFdIFRoZSB2ZWxvY2l0eSBvZiB0aGUgZW52ZWxvcGUgc2NhbGVzIHRoZSB2YWxlcy5cblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBudW1iZXIgYmV0d2VlbiAwLTFcblx0XHQgKiAgQHJldHVybnMge1RvbmUuRW52ZWxvcGV9IHRoaXNcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgLy90cmlnZ2VyIHRoZSBhdHRhY2sgMC41IHNlY29uZHMgZnJvbSBub3cgd2l0aCBhIHZlbG9jaXR5IG9mIDAuMlxuXHRcdCAqICBlbnYudHJpZ2dlckF0dGFjayhcIiswLjVcIiwgMC4yKTtcblx0XHQgKi9cblx0ICAgIFRvbmUuRW52ZWxvcGUucHJvdG90eXBlLnRyaWdnZXJBdHRhY2sgPSBmdW5jdGlvbiAodGltZSwgdmVsb2NpdHkpIHtcblx0ICAgICAgICB0aW1lID0gdGhpcy50b1NlY29uZHModGltZSk7XG5cdCAgICAgICAgdmFyIG9yaWdpbmFsQXR0YWNrID0gdGhpcy50b1NlY29uZHModGhpcy5hdHRhY2spO1xuXHQgICAgICAgIHZhciBhdHRhY2sgPSBvcmlnaW5hbEF0dGFjaztcblx0ICAgICAgICB2YXIgZGVjYXkgPSB0aGlzLnRvU2Vjb25kcyh0aGlzLmRlY2F5KTtcblx0ICAgICAgICB2ZWxvY2l0eSA9IFRvbmUuZGVmYXVsdEFyZyh2ZWxvY2l0eSwgMSk7XG5cdCAgICAgICAgLy9jaGVjayBpZiBpdCdzIG5vdCBhIGNvbXBsZXRlIGF0dGFja1xuXHQgICAgICAgIHZhciBjdXJyZW50VmFsdWUgPSB0aGlzLmdldFZhbHVlQXRUaW1lKHRpbWUpO1xuXHQgICAgICAgIGlmIChjdXJyZW50VmFsdWUgPiAwKSB7XG5cdCAgICAgICAgICAgIC8vc3VidHJhY3QgdGhlIGN1cnJlbnQgdmFsdWUgZnJvbSB0aGUgYXR0YWNrIHRpbWVcblx0ICAgICAgICAgICAgdmFyIGF0dGFja1JhdGUgPSAxIC8gYXR0YWNrO1xuXHQgICAgICAgICAgICB2YXIgcmVtYWluaW5nRGlzdGFuY2UgPSAxIC0gY3VycmVudFZhbHVlO1xuXHQgICAgICAgICAgICAvL3RoZSBhdHRhY2sgaXMgbm93IHRoZSByZW1haW5pbmcgdGltZVxuXHQgICAgICAgICAgICBhdHRhY2sgPSByZW1haW5pbmdEaXN0YW5jZSAvIGF0dGFja1JhdGU7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8vYXR0YWNrXG5cdCAgICAgICAgaWYgKHRoaXMuX2F0dGFja0N1cnZlID09PSAnbGluZWFyJykge1xuXHQgICAgICAgICAgICB0aGlzLl9zaWcubGluZWFyUmFtcFRvVmFsdWUodmVsb2NpdHksIGF0dGFjaywgdGltZSk7XG5cdCAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9hdHRhY2tDdXJ2ZSA9PT0gJ2V4cG9uZW50aWFsJykge1xuXHQgICAgICAgICAgICB0aGlzLl9zaWcuZXhwb25lbnRpYWxSYW1wVG9WYWx1ZSh2ZWxvY2l0eSwgYXR0YWNrLCB0aW1lKTtcblx0ICAgICAgICB9IGVsc2UgaWYgKGF0dGFjayA+IDApIHtcblx0ICAgICAgICAgICAgdGhpcy5fc2lnLnNldFJhbXBQb2ludCh0aW1lKTtcblx0ICAgICAgICAgICAgdmFyIGN1cnZlID0gdGhpcy5fYXR0YWNrQ3VydmU7XG5cdCAgICAgICAgICAgIC8vdGFrZSBvbmx5IGEgcG9ydGlvbiBvZiB0aGUgY3VydmVcblx0ICAgICAgICAgICAgaWYgKGF0dGFjayA8IG9yaWdpbmFsQXR0YWNrKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgcGVyY2VudENvbXBsZXRlID0gMSAtIGF0dGFjayAvIG9yaWdpbmFsQXR0YWNrO1xuXHQgICAgICAgICAgICAgICAgdmFyIHNsaWNlSW5kZXggPSBNYXRoLmZsb29yKHBlcmNlbnRDb21wbGV0ZSAqIHRoaXMuX2F0dGFja0N1cnZlLmxlbmd0aCk7XG5cdCAgICAgICAgICAgICAgICBjdXJ2ZSA9IHRoaXMuX2F0dGFja0N1cnZlLnNsaWNlKHNsaWNlSW5kZXgpO1xuXHQgICAgICAgICAgICAgICAgLy90aGUgZmlyc3QgaW5kZXggaXMgdGhlIGN1cnJlbnQgdmFsdWVcblx0ICAgICAgICAgICAgICAgIGN1cnZlWzBdID0gY3VycmVudFZhbHVlO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHRoaXMuX3NpZy5zZXRWYWx1ZUN1cnZlQXRUaW1lKGN1cnZlLCB0aW1lLCBhdHRhY2ssIHZlbG9jaXR5KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgLy9kZWNheVxuXHQgICAgICAgIHRoaXMuX3NpZy5leHBvbmVudGlhbFJhbXBUb1ZhbHVlKHZlbG9jaXR5ICogdGhpcy5zdXN0YWluLCBkZWNheSwgYXR0YWNrICsgdGltZSk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFRyaWdnZXJzIHRoZSByZWxlYXNlIG9mIHRoZSBlbnZlbG9wZS5cblx0XHQgKiAgQHBhcmFtICB7VGltZX0gW3RpbWU9bm93XSBXaGVuIHRoZSByZWxlYXNlIHBvcnRpb24gb2YgdGhlIGVudmVsb3BlIHNob3VsZCBzdGFydC5cblx0XHQgKiAgQHJldHVybnMge1RvbmUuRW52ZWxvcGV9IHRoaXNcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgLy90cmlnZ2VyIHJlbGVhc2UgaW1tZWRpYXRlbHlcblx0XHQgKiAgZW52LnRyaWdnZXJSZWxlYXNlKCk7XG5cdFx0ICovXG5cdCAgICBUb25lLkVudmVsb3BlLnByb3RvdHlwZS50cmlnZ2VyUmVsZWFzZSA9IGZ1bmN0aW9uICh0aW1lKSB7XG5cdCAgICAgICAgdGltZSA9IHRoaXMudG9TZWNvbmRzKHRpbWUpO1xuXHQgICAgICAgIHZhciBjdXJyZW50VmFsdWUgPSB0aGlzLmdldFZhbHVlQXRUaW1lKHRpbWUpO1xuXHQgICAgICAgIGlmIChjdXJyZW50VmFsdWUgPiAwKSB7XG5cdCAgICAgICAgICAgIHZhciByZWxlYXNlID0gdGhpcy50b1NlY29uZHModGhpcy5yZWxlYXNlKTtcblx0ICAgICAgICAgICAgaWYgKHRoaXMuX3JlbGVhc2VDdXJ2ZSA9PT0gJ2xpbmVhcicpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX3NpZy5saW5lYXJSYW1wVG9WYWx1ZSgwLCByZWxlYXNlLCB0aW1lKTtcblx0ICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9yZWxlYXNlQ3VydmUgPT09ICdleHBvbmVudGlhbCcpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX3NpZy5leHBvbmVudGlhbFJhbXBUb1ZhbHVlKDAsIHJlbGVhc2UsIHRpbWUpO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgdmFyIGN1cnZlID0gdGhpcy5fcmVsZWFzZUN1cnZlO1xuXHQgICAgICAgICAgICAgICAgaWYgKFRvbmUuaXNBcnJheShjdXJ2ZSkpIHtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLl9zaWcuc2V0UmFtcFBvaW50KHRpbWUpO1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuX3NpZy5zZXRWYWx1ZUN1cnZlQXRUaW1lKGN1cnZlLCB0aW1lLCByZWxlYXNlLCBjdXJyZW50VmFsdWUpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBHZXQgdGhlIHNjaGVkdWxlZCB2YWx1ZSBhdCB0aGUgZ2l2ZW4gdGltZS4gVGhpcyB3aWxsXG5cdFx0ICogIHJldHVybiB0aGUgdW5jb252ZXJ0ZWQgKHJhdykgdmFsdWUuXG5cdFx0ICogIEBwYXJhbSAge051bWJlcn0gIHRpbWUgIFRoZSB0aW1lIGluIHNlY29uZHMuXG5cdFx0ICogIEByZXR1cm4gIHtOdW1iZXJ9ICBUaGUgc2NoZWR1bGVkIHZhbHVlIGF0IHRoZSBnaXZlbiB0aW1lLlxuXHRcdCAqL1xuXHQgICAgVG9uZS5FbnZlbG9wZS5wcm90b3R5cGUuZ2V0VmFsdWVBdFRpbWUgPSBmdW5jdGlvbiAodGltZSkge1xuXHQgICAgICAgIHJldHVybiB0aGlzLl9zaWcuZ2V0VmFsdWVBdFRpbWUodGltZSk7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIHRyaWdnZXJBdHRhY2tSZWxlYXNlIGlzIHNob3J0aGFuZCBmb3IgdHJpZ2dlckF0dGFjaywgdGhlbiB3YWl0aW5nXG5cdFx0ICogIHNvbWUgZHVyYXRpb24sIHRoZW4gdHJpZ2dlclJlbGVhc2UuXG5cdFx0ICogIEBwYXJhbSB7VGltZX0gZHVyYXRpb24gVGhlIGR1cmF0aW9uIG9mIHRoZSBzdXN0YWluLlxuXHRcdCAqICBAcGFyYW0ge1RpbWV9IFt0aW1lPW5vd10gV2hlbiB0aGUgYXR0YWNrIHNob3VsZCBiZSB0cmlnZ2VyZWQuXG5cdFx0ICogIEBwYXJhbSB7bnVtYmVyfSBbdmVsb2NpdHk9MV0gVGhlIHZlbG9jaXR5IG9mIHRoZSBlbnZlbG9wZS5cblx0XHQgKiAgQHJldHVybnMge1RvbmUuRW52ZWxvcGV9IHRoaXNcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAvL3RyaWdnZXIgdGhlIGF0dGFjayBhbmQgdGhlbiB0aGUgcmVsZWFzZSBhZnRlciAwLjYgc2Vjb25kcy5cblx0XHQgKiBlbnYudHJpZ2dlckF0dGFja1JlbGVhc2UoMC42KTtcblx0XHQgKi9cblx0ICAgIFRvbmUuRW52ZWxvcGUucHJvdG90eXBlLnRyaWdnZXJBdHRhY2tSZWxlYXNlID0gZnVuY3Rpb24gKGR1cmF0aW9uLCB0aW1lLCB2ZWxvY2l0eSkge1xuXHQgICAgICAgIHRpbWUgPSB0aGlzLnRvU2Vjb25kcyh0aW1lKTtcblx0ICAgICAgICB0aGlzLnRyaWdnZXJBdHRhY2sodGltZSwgdmVsb2NpdHkpO1xuXHQgICAgICAgIHRoaXMudHJpZ2dlclJlbGVhc2UodGltZSArIHRoaXMudG9TZWNvbmRzKGR1cmF0aW9uKSk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIENhbmNlbHMgYWxsIHNjaGVkdWxlZCBlbnZlbG9wZSBjaGFuZ2VzIGFmdGVyIHRoZSBnaXZlbiB0aW1lLlxuXHRcdCAqICBAcGFyYW0gIHtUaW1lfSBhZnRlclxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5FbnZlbG9wZX0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5FbnZlbG9wZS5wcm90b3R5cGUuY2FuY2VsID0gZnVuY3Rpb24gKGFmdGVyKSB7XG5cdCAgICAgICAgdGhpcy5fc2lnLmNhbmNlbFNjaGVkdWxlZFZhbHVlcyhhZnRlcik7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIEJvcnJvd3MgdGhlIGNvbm5lY3QgbWV0aG9kIGZyb20gVG9uZS5TaWduYWwuXG5cdFx0ICogIEBmdW5jdGlvblxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5FbnZlbG9wZS5wcm90b3R5cGUuY29ubmVjdCA9IFRvbmUuU2lnbmFsLnByb3RvdHlwZS5jb25uZWN0O1xuXHQgICAgLyoqXG5cdCBcdCAqICBHZW5lcmF0ZSBzb21lIGNvbXBsZXggZW52ZWxvcGUgY3VydmVzLlxuXHQgXHQgKi9cblx0ICAgIChmdW5jdGlvbiBfY3JlYXRlQ3VydmVzKCkge1xuXHQgICAgICAgIHZhciBjdXJ2ZUxlbiA9IDEyODtcblx0ICAgICAgICB2YXIgaSwgaztcblx0ICAgICAgICAvL2Nvc2luZSBjdXJ2ZVxuXHQgICAgICAgIHZhciBjb3NpbmVDdXJ2ZSA9IFtdO1xuXHQgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjdXJ2ZUxlbjsgaSsrKSB7XG5cdCAgICAgICAgICAgIGNvc2luZUN1cnZlW2ldID0gTWF0aC5zaW4oaSAvIChjdXJ2ZUxlbiAtIDEpICogKE1hdGguUEkgLyAyKSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8vcmlwcGxlIGN1cnZlXG5cdCAgICAgICAgdmFyIHJpcHBsZUN1cnZlID0gW107XG5cdCAgICAgICAgdmFyIHJpcHBsZUN1cnZlRnJlcSA9IDYuNDtcblx0ICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY3VydmVMZW4gLSAxOyBpKyspIHtcblx0ICAgICAgICAgICAgayA9IGkgLyAoY3VydmVMZW4gLSAxKTtcblx0ICAgICAgICAgICAgdmFyIHNpbmVXYXZlID0gTWF0aC5zaW4oayAqIChNYXRoLlBJICogMikgKiByaXBwbGVDdXJ2ZUZyZXEgLSBNYXRoLlBJIC8gMikgKyAxO1xuXHQgICAgICAgICAgICByaXBwbGVDdXJ2ZVtpXSA9IHNpbmVXYXZlIC8gMTAgKyBrICogMC44Mztcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmlwcGxlQ3VydmVbY3VydmVMZW4gLSAxXSA9IDE7XG5cdCAgICAgICAgLy9zdGFpcnMgY3VydmVcblx0ICAgICAgICB2YXIgc3RhaXJzQ3VydmUgPSBbXTtcblx0ICAgICAgICB2YXIgc3RlcHMgPSA1O1xuXHQgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjdXJ2ZUxlbjsgaSsrKSB7XG5cdCAgICAgICAgICAgIHN0YWlyc0N1cnZlW2ldID0gTWF0aC5jZWlsKGkgLyAoY3VydmVMZW4gLSAxKSAqIHN0ZXBzKSAvIHN0ZXBzO1xuXHQgICAgICAgIH1cblx0ICAgICAgICAvL2luLW91dCBlYXNpbmcgY3VydmVcblx0ICAgICAgICB2YXIgc2luZUN1cnZlID0gW107XG5cdCAgICAgICAgZm9yIChpID0gMDsgaSA8IGN1cnZlTGVuOyBpKyspIHtcblx0ICAgICAgICAgICAgayA9IGkgLyAoY3VydmVMZW4gLSAxKTtcblx0ICAgICAgICAgICAgc2luZUN1cnZlW2ldID0gMC41ICogKDEgLSBNYXRoLmNvcyhNYXRoLlBJICogaykpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICAvL2EgYm91bmNlIGN1cnZlXG5cdCAgICAgICAgdmFyIGJvdW5jZUN1cnZlID0gW107XG5cdCAgICAgICAgZm9yIChpID0gMDsgaSA8IGN1cnZlTGVuOyBpKyspIHtcblx0ICAgICAgICAgICAgayA9IGkgLyAoY3VydmVMZW4gLSAxKTtcblx0ICAgICAgICAgICAgdmFyIGZyZXEgPSBNYXRoLnBvdyhrLCAzKSAqIDQgKyAwLjI7XG5cdCAgICAgICAgICAgIHZhciB2YWwgPSBNYXRoLmNvcyhmcmVxICogTWF0aC5QSSAqIDIgKiBrKTtcblx0ICAgICAgICAgICAgYm91bmNlQ3VydmVbaV0gPSBNYXRoLmFicyh2YWwgKiAoMSAtIGspKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgSW52ZXJ0IGEgdmFsdWUgY3VydmUgdG8gbWFrZSBpdCB3b3JrIGZvciB0aGUgcmVsZWFzZVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICBmdW5jdGlvbiBpbnZlcnRDdXJ2ZShjdXJ2ZSkge1xuXHQgICAgICAgICAgICB2YXIgb3V0ID0gbmV3IEFycmF5KGN1cnZlLmxlbmd0aCk7XG5cdCAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgY3VydmUubGVuZ3RoOyBqKyspIHtcblx0ICAgICAgICAgICAgICAgIG91dFtqXSA9IDEgLSBjdXJ2ZVtqXTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gb3V0O1xuXHQgICAgICAgIH1cblx0ICAgICAgICAvKipcblx0XHRcdCAqICByZXZlcnNlIHRoZSBjdXJ2ZVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICBmdW5jdGlvbiByZXZlcnNlQ3VydmUoY3VydmUpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGN1cnZlLnNsaWNlKDApLnJldmVyc2UoKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgYXR0YWNrIGFuZCByZWxlYXNlIGN1cnZlIGFycmF5c1xuXHRcdFx0ICogIEB0eXBlICB7T2JqZWN0fVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICBUb25lLkVudmVsb3BlLlR5cGUgPSB7XG5cdCAgICAgICAgICAgICdsaW5lYXInOiAnbGluZWFyJyxcblx0ICAgICAgICAgICAgJ2V4cG9uZW50aWFsJzogJ2V4cG9uZW50aWFsJyxcblx0ICAgICAgICAgICAgJ2JvdW5jZSc6IHtcblx0ICAgICAgICAgICAgICAgIEluOiBpbnZlcnRDdXJ2ZShib3VuY2VDdXJ2ZSksXG5cdCAgICAgICAgICAgICAgICBPdXQ6IGJvdW5jZUN1cnZlXG5cdCAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgICdjb3NpbmUnOiB7XG5cdCAgICAgICAgICAgICAgICBJbjogY29zaW5lQ3VydmUsXG5cdCAgICAgICAgICAgICAgICBPdXQ6IHJldmVyc2VDdXJ2ZShjb3NpbmVDdXJ2ZSlcblx0ICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgJ3N0ZXAnOiB7XG5cdCAgICAgICAgICAgICAgICBJbjogc3RhaXJzQ3VydmUsXG5cdCAgICAgICAgICAgICAgICBPdXQ6IGludmVydEN1cnZlKHN0YWlyc0N1cnZlKVxuXHQgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICAncmlwcGxlJzoge1xuXHQgICAgICAgICAgICAgICAgSW46IHJpcHBsZUN1cnZlLFxuXHQgICAgICAgICAgICAgICAgT3V0OiBpbnZlcnRDdXJ2ZShyaXBwbGVDdXJ2ZSlcblx0ICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgJ3NpbmUnOiB7XG5cdCAgICAgICAgICAgICAgICBJbjogc2luZUN1cnZlLFxuXHQgICAgICAgICAgICAgICAgT3V0OiBpbnZlcnRDdXJ2ZShzaW5lQ3VydmUpXG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9O1xuXHQgICAgfSgpKTtcblx0ICAgIC8qKlxuXHRcdCAqICBEaXNjb25uZWN0IGFuZCBkaXNwb3NlLlxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5FbnZlbG9wZX0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5FbnZlbG9wZS5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLkF1ZGlvTm9kZS5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuX3NpZy5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fc2lnID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9hdHRhY2tDdXJ2ZSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fcmVsZWFzZUN1cnZlID0gbnVsbDtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVG9uZS5FbnZlbG9wZTtcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgXG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzICBUb25lLkFtcGxpdHVkZUVudmVsb3BlIGlzIGEgVG9uZS5FbnZlbG9wZSBjb25uZWN0ZWQgdG8gYSBnYWluIG5vZGUuXG5cdFx0ICogICAgICAgICAgVW5saWtlIFRvbmUuRW52ZWxvcGUsIHdoaWNoIG91dHB1dHMgdGhlIGVudmVsb3BlJ3MgdmFsdWUsIFRvbmUuQW1wbGl0dWRlRW52ZWxvcGUgYWNjZXB0c1xuXHRcdCAqICAgICAgICAgIGFuIGF1ZGlvIHNpZ25hbCBhcyB0aGUgaW5wdXQgYW5kIHdpbGwgYXBwbHkgdGhlIGVudmVsb3BlIHRvIHRoZSBhbXBsaXR1ZGVcblx0XHQgKiAgICAgICAgICBvZiB0aGUgc2lnbmFsLiBSZWFkIG1vcmUgYWJvdXQgQURTUiBFbnZlbG9wZXMgb24gW1dpa2lwZWRpYV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU3ludGhlc2l6ZXIjQURTUl9lbnZlbG9wZSkuXG5cdFx0ICpcblx0XHQgKiAgQGNvbnN0cnVjdG9yXG5cdFx0ICogIEBleHRlbmRzIHtUb25lLkVudmVsb3BlfVxuXHRcdCAqICBAcGFyYW0ge1RpbWV8T2JqZWN0fSBbYXR0YWNrXSBUaGUgYW1vdW50IG9mIHRpbWUgaXQgdGFrZXMgZm9yIHRoZSBlbnZlbG9wZSB0byBnbyBmcm9tXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMCB0byBpdCdzIG1heGltdW0gdmFsdWUuXG5cdFx0ICogIEBwYXJhbSB7VGltZX0gW2RlY2F5XVx0VGhlIHBlcmlvZCBvZiB0aW1lIGFmdGVyIHRoZSBhdHRhY2sgdGhhdCBpdCB0YWtlcyBmb3IgdGhlIGVudmVsb3BlXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgIFx0dG8gZmFsbCB0byB0aGUgc3VzdGFpbiB2YWx1ZS5cblx0XHQgKiAgQHBhcmFtIHtOb3JtYWxSYW5nZX0gW3N1c3RhaW5dXHRUaGUgcGVyY2VudCBvZiB0aGUgbWF4aW11bSB2YWx1ZSB0aGF0IHRoZSBlbnZlbG9wZSByZXN0cyBhdCB1bnRpbFxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcdHRoZSByZWxlYXNlIGlzIHRyaWdnZXJlZC5cblx0XHQgKiAgQHBhcmFtIHtUaW1lfSBbcmVsZWFzZV1cdFRoZSBhbW91bnQgb2YgdGltZSBhZnRlciB0aGUgcmVsZWFzZSBpcyB0cmlnZ2VyZWQgaXQgdGFrZXMgdG8gcmVhY2ggMC5cblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiB2YXIgYW1wRW52ID0gbmV3IFRvbmUuQW1wbGl0dWRlRW52ZWxvcGUoe1xuXHRcdCAqIFx0XCJhdHRhY2tcIjogMC4xLFxuXHRcdCAqIFx0XCJkZWNheVwiOiAwLjIsXG5cdFx0ICogXHRcInN1c3RhaW5cIjogMS4wLFxuXHRcdCAqIFx0XCJyZWxlYXNlXCI6IDAuOFxuXHRcdCAqIH0pLnRvTWFzdGVyKCk7XG5cdFx0ICogLy9jcmVhdGUgYW4gb3NjaWxsYXRvciBhbmQgY29ubmVjdCBpdFxuXHRcdCAqIHZhciBvc2MgPSBuZXcgVG9uZS5Pc2NpbGxhdG9yKCkuY29ubmVjdChhbXBFbnYpLnN0YXJ0KCk7XG5cdFx0ICogLy90cmlnZ2VyIHRoZSBlbnZlbG9wZXMgYXR0YWNrIGFuZCByZWxlYXNlIFwiOHRcIiBhcGFydFxuXHRcdCAqIGFtcEVudi50cmlnZ2VyQXR0YWNrUmVsZWFzZShcIjh0XCIpO1xuXHRcdCAqL1xuXHQgICAgVG9uZS5BbXBsaXR1ZGVFbnZlbG9wZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLkVudmVsb3BlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgdGhlIGlucHV0IG5vZGVcblx0XHRcdCAqICBAdHlwZSB7R2Fpbk5vZGV9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuaW5wdXQgPSB0aGlzLm91dHB1dCA9IG5ldyBUb25lLkdhaW4oKTtcblx0ICAgICAgICB0aGlzLl9zaWcuY29ubmVjdCh0aGlzLm91dHB1dC5nYWluKTtcblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLkFtcGxpdHVkZUVudmVsb3BlLCBUb25lLkVudmVsb3BlKTtcblx0ICAgIC8qKlxuXHRcdCAqICBDbGVhbiB1cFxuXHRcdCAqICBAcmV0dXJuICB7VG9uZS5BbXBsaXR1ZGVFbnZlbG9wZX0gIHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuQW1wbGl0dWRlRW52ZWxvcGUucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5FbnZlbG9wZS5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLkFtcGxpdHVkZUVudmVsb3BlO1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBBbmFseXNlck5vZGUuZ2V0RmxvYXRUaW1lRG9tYWluRGF0YSBwb2x5ZmlsbFxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgaWYgKHdpbmRvdy5BbmFseXNlck5vZGUgJiYgIUFuYWx5c2VyTm9kZS5wcm90b3R5cGUuZ2V0RmxvYXRUaW1lRG9tYWluRGF0YSkge1xuXHQgICAgICAgIC8vcmVmZXJlbmNlZCBodHRwczovL2dpdGh1Yi5jb20vbW9oYXlvbmFvL2dldC1mbG9hdC10aW1lLWRvbWFpbi1kYXRhXG5cdCAgICAgICAgQW5hbHlzZXJOb2RlLnByb3RvdHlwZS5nZXRGbG9hdFRpbWVEb21haW5EYXRhID0gZnVuY3Rpb24gKGFycmF5KSB7XG5cdCAgICAgICAgICAgIHZhciB1aW50OCA9IG5ldyBVaW50OEFycmF5KGFycmF5Lmxlbmd0aCk7XG5cdCAgICAgICAgICAgIHRoaXMuZ2V0Qnl0ZVRpbWVEb21haW5EYXRhKHVpbnQ4KTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB1aW50OC5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgYXJyYXlbaV0gPSAodWludDhbaV0gLSAxMjgpIC8gMTI4O1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfTtcblx0ICAgIH1cblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgIFdyYXBwZXIgYXJvdW5kIHRoZSBuYXRpdmUgV2ViIEF1ZGlvJ3Ncblx0XHQgKiAgICAgICAgICBbQW5hbHlzZXJOb2RlXShodHRwOi8vd2ViYXVkaW8uZ2l0aHViLmlvL3dlYi1hdWRpby1hcGkvI2lkbC1kZWYtQW5hbHlzZXJOb2RlKS5cblx0XHQgKiAgICAgICAgICBFeHRyYWN0cyBGRlQgb3IgV2F2ZWZvcm0gZGF0YSBmcm9tIHRoZSBpbmNvbWluZyBzaWduYWwuXG5cdFx0ICogIEBleHRlbmRzIHtUb25lLkF1ZGlvTm9kZX1cblx0XHQgKiAgQHBhcmFtIHtTdHJpbmc9fSB0eXBlIFRoZSByZXR1cm4gdHlwZSBvZiB0aGUgYW5hbHlzaXMsIGVpdGhlciBcImZmdFwiLCBvciBcIndhdmVmb3JtXCIuXG5cdFx0ICogIEBwYXJhbSB7TnVtYmVyPX0gc2l6ZSBUaGUgc2l6ZSBvZiB0aGUgRkZULiBWYWx1ZSBtdXN0IGJlIGEgcG93ZXIgb2Zcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgdHdvIGluIHRoZSByYW5nZSAzMiB0byAzMjc2OC5cblx0XHQgKi9cblx0ICAgIFRvbmUuQW5hbHlzZXIgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIG9wdGlvbnMgPSBUb25lLmRlZmF1bHRzKGFyZ3VtZW50cywgW1xuXHQgICAgICAgICAgICAndHlwZScsXG5cdCAgICAgICAgICAgICdzaXplJ1xuXHQgICAgICAgIF0sIFRvbmUuQW5hbHlzZXIpO1xuXHQgICAgICAgIFRvbmUuQXVkaW9Ob2RlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGFuYWx5c2VyIG5vZGUuXG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqICBAdHlwZSB7QW5hbHlzZXJOb2RlfVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fYW5hbHlzZXIgPSB0aGlzLmlucHV0ID0gdGhpcy5vdXRwdXQgPSB0aGlzLmNvbnRleHQuY3JlYXRlQW5hbHlzZXIoKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgYW5hbHlzaXMgdHlwZVxuXHRcdFx0ICogIEB0eXBlIHtTdHJpbmd9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX3R5cGUgPSBvcHRpb25zLnR5cGU7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGJ1ZmZlciB0aGF0IHRoZSBGRlQgZGF0YSBpcyB3cml0dGVuIHRvXG5cdFx0XHQgKiAgQHR5cGUge1R5cGVkQXJyYXl9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2J1ZmZlciA9IG51bGw7XG5cdCAgICAgICAgLy9zZXQgdGhlIHZhbHVlcyBpbml0aWFsbHlcblx0ICAgICAgICB0aGlzLnNpemUgPSBvcHRpb25zLnNpemU7XG5cdCAgICAgICAgdGhpcy50eXBlID0gb3B0aW9ucy50eXBlO1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuQW5hbHlzZXIsIFRvbmUuQXVkaW9Ob2RlKTtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgZGVmYXVsdCB2YWx1ZXMuXG5cdFx0ICogIEB0eXBlIHtPYmplY3R9XG5cdFx0ICogIEBjb25zdFxuXHRcdCAqL1xuXHQgICAgVG9uZS5BbmFseXNlci5kZWZhdWx0cyA9IHtcblx0ICAgICAgICAnc2l6ZSc6IDEwMjQsXG5cdCAgICAgICAgJ3R5cGUnOiAnZmZ0Jyxcblx0ICAgICAgICAnc21vb3RoaW5nJzogMC44XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFBvc3NpYmxlIHJldHVybiB0eXBlcyBvZiBUb25lLkFuYWx5c2VyLmFuYWx5c2UoKVxuXHRcdCAqICBAZW51bSB7U3RyaW5nfVxuXHRcdCAqL1xuXHQgICAgVG9uZS5BbmFseXNlci5UeXBlID0ge1xuXHQgICAgICAgIFdhdmVmb3JtOiAnd2F2ZWZvcm0nLFxuXHQgICAgICAgIEZGVDogJ2ZmdCdcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgUnVuIHRoZSBhbmFseXNpcyBnaXZlbiB0aGUgY3VycmVudCBzZXR0aW5ncyBhbmQgcmV0dXJuIHRoZVxuXHRcdCAqICByZXN1bHQgYXMgYSBUeXBlZEFycmF5LlxuXHRcdCAqICBAcmV0dXJucyB7VHlwZWRBcnJheX1cblx0XHQgKi9cblx0ICAgIFRvbmUuQW5hbHlzZXIucHJvdG90eXBlLmFuYWx5c2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgaWYgKHRoaXMuX3R5cGUgPT09IFRvbmUuQW5hbHlzZXIuVHlwZS5GRlQpIHtcblx0ICAgICAgICAgICAgdGhpcy5fYW5hbHlzZXIuZ2V0RmxvYXRGcmVxdWVuY3lEYXRhKHRoaXMuX2J1ZmZlcik7XG5cdCAgICAgICAgfSBlbHNlIGlmICh0aGlzLl90eXBlID09PSBUb25lLkFuYWx5c2VyLlR5cGUuV2F2ZWZvcm0pIHtcblx0ICAgICAgICAgICAgdGhpcy5fYW5hbHlzZXIuZ2V0RmxvYXRUaW1lRG9tYWluRGF0YSh0aGlzLl9idWZmZXIpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gdGhpcy5fYnVmZmVyO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgc2l6ZSBvZiBhbmFseXNpcy4gVGhpcyBtdXN0IGJlIGEgcG93ZXIgb2YgdHdvIGluIHRoZSByYW5nZSAzMiB0byAzMjc2OC5cblx0XHQgKiAgQG1lbWJlck9mIFRvbmUuQW5hbHlzZXIjXG5cdFx0ICogIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogIEBuYW1lIHNpemVcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkFuYWx5c2VyLnByb3RvdHlwZSwgJ3NpemUnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9hbmFseXNlci5mcmVxdWVuY3lCaW5Db3VudDtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKHNpemUpIHtcblx0ICAgICAgICAgICAgdGhpcy5fYW5hbHlzZXIuZmZ0U2l6ZSA9IHNpemUgKiAyO1xuXHQgICAgICAgICAgICB0aGlzLl9idWZmZXIgPSBuZXcgRmxvYXQzMkFycmF5KHNpemUpO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIFRoZSBhbmFseXNpcyBmdW5jdGlvbiByZXR1cm5lZCBieSBUb25lLkFuYWx5c2VyLmFuYWx5c2UoKSwgZWl0aGVyIFwiZmZ0XCIgb3IgXCJ3YXZlZm9ybVwiLlxuXHRcdCAqICBAbWVtYmVyT2YgVG9uZS5BbmFseXNlciNcblx0XHQgKiAgQHR5cGUge1N0cmluZ31cblx0XHQgKiAgQG5hbWUgdHlwZVxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuQW5hbHlzZXIucHJvdG90eXBlLCAndHlwZScsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3R5cGU7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uICh0eXBlKSB7XG5cdCAgICAgICAgICAgIGlmICh0eXBlICE9PSBUb25lLkFuYWx5c2VyLlR5cGUuV2F2ZWZvcm0gJiYgdHlwZSAhPT0gVG9uZS5BbmFseXNlci5UeXBlLkZGVCkge1xuXHQgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVG9uZS5BbmFseXNlcjogaW52YWxpZCB0eXBlOiAnICsgdHlwZSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdGhpcy5fdHlwZSA9IHR5cGU7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgMCByZXByZXNlbnRzIG5vIHRpbWUgYXZlcmFnaW5nIHdpdGggdGhlIGxhc3QgYW5hbHlzaXMgZnJhbWUuXG5cdFx0ICogIEBtZW1iZXJPZiBUb25lLkFuYWx5c2VyI1xuXHRcdCAqICBAdHlwZSB7Tm9ybWFsUmFuZ2V9XG5cdFx0ICogIEBuYW1lIHNtb290aGluZ1xuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuQW5hbHlzZXIucHJvdG90eXBlLCAnc21vb3RoaW5nJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fYW5hbHlzZXIuc21vb3RoaW5nVGltZUNvbnN0YW50O1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2FuYWx5c2VyLnNtb290aGluZ1RpbWVDb25zdGFudCA9IHZhbDtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBDbGVhbiB1cC5cblx0XHQgKiAgQHJldHVybiAge1RvbmUuQW5hbHlzZXJ9ICB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkFuYWx5c2VyLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuQXVkaW9Ob2RlLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgdGhpcy5fYW5hbHlzZXIuZGlzY29ubmVjdCgpO1xuXHQgICAgICAgIHRoaXMuX2FuYWx5c2VyID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9idWZmZXIgPSBudWxsO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLkFuYWx5c2VyO1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgVG9uZS5Db21wcmVzc29yIGlzIGEgdGhpbiB3cmFwcGVyIGFyb3VuZCB0aGUgV2ViIEF1ZGlvXG5cdFx0ICogICAgICAgICBbRHluYW1pY3NDb21wcmVzc29yTm9kZV0oaHR0cDovL3dlYmF1ZGlvLmdpdGh1Yi5pby93ZWItYXVkaW8tYXBpLyN0aGUtZHluYW1pY3Njb21wcmVzc29ybm9kZS1pbnRlcmZhY2UpLlxuXHRcdCAqICAgICAgICAgQ29tcHJlc3Npb24gcmVkdWNlcyB0aGUgdm9sdW1lIG9mIGxvdWQgc291bmRzIG9yIGFtcGxpZmllcyBxdWlldCBzb3VuZHNcblx0XHQgKiAgICAgICAgIGJ5IG5hcnJvd2luZyBvciBcImNvbXByZXNzaW5nXCIgYW4gYXVkaW8gc2lnbmFsJ3MgZHluYW1pYyByYW5nZS5cblx0XHQgKiAgICAgICAgIFJlYWQgbW9yZSBvbiBbV2lraXBlZGlhXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9EeW5hbWljX3JhbmdlX2NvbXByZXNzaW9uKS5cblx0XHQgKlxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZS5BdWRpb05vZGV9XG5cdFx0ICogIEBjb25zdHJ1Y3RvclxuXHRcdCAqICBAcGFyYW0ge0RlY2liZWxzfE9iamVjdH0gW3RocmVzaG9sZF0gVGhlIHZhbHVlIGFib3ZlIHdoaWNoIHRoZSBjb21wcmVzc2lvbiBzdGFydHMgdG8gYmUgYXBwbGllZC5cblx0XHQgKiAgQHBhcmFtIHtQb3NpdGl2ZX0gW3JhdGlvXSBUaGUgZ2FpbiByZWR1Y3Rpb24gcmF0aW8uXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogdmFyIGNvbXAgPSBuZXcgVG9uZS5Db21wcmVzc29yKC0zMCwgMyk7XG5cdFx0ICovXG5cdCAgICBUb25lLkNvbXByZXNzb3IgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIG9wdGlvbnMgPSBUb25lLmRlZmF1bHRzKGFyZ3VtZW50cywgW1xuXHQgICAgICAgICAgICAndGhyZXNob2xkJyxcblx0ICAgICAgICAgICAgJ3JhdGlvJ1xuXHQgICAgICAgIF0sIFRvbmUuQ29tcHJlc3Nvcik7XG5cdCAgICAgICAgVG9uZS5BdWRpb05vZGUuY2FsbCh0aGlzKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICB0aGUgY29tcHJlc3NvciBub2RlXG5cdFx0XHQgKiAgQHR5cGUge0R5bmFtaWNzQ29tcHJlc3Nvck5vZGV9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2NvbXByZXNzb3IgPSB0aGlzLmlucHV0ID0gdGhpcy5vdXRwdXQgPSB0aGlzLmNvbnRleHQuY3JlYXRlRHluYW1pY3NDb21wcmVzc29yKCk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgdGhlIHRocmVzaG9sZCB2YXVlXG5cdFx0XHQgKiAgQHR5cGUge0RlY2liZWxzfVxuXHRcdFx0ICogIEBzaWduYWxcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMudGhyZXNob2xkID0gbmV3IFRvbmUuUGFyYW0oe1xuXHQgICAgICAgICAgICAncGFyYW0nOiB0aGlzLl9jb21wcmVzc29yLnRocmVzaG9sZCxcblx0ICAgICAgICAgICAgJ3VuaXRzJzogVG9uZS5UeXBlLkRlY2liZWxzLFxuXHQgICAgICAgICAgICAnY29udmVydCc6IGZhbHNlXG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGF0dGFjayBwYXJhbWV0ZXJcblx0XHRcdCAqICBAdHlwZSB7VGltZX1cblx0XHRcdCAqICBAc2lnbmFsXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmF0dGFjayA9IG5ldyBUb25lLlBhcmFtKHRoaXMuX2NvbXByZXNzb3IuYXR0YWNrLCBUb25lLlR5cGUuVGltZSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIHJlbGVhc2UgcGFyYW1ldGVyXG5cdFx0XHQgKiAgQHR5cGUge1RpbWV9XG5cdFx0XHQgKiAgQHNpZ25hbFxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5yZWxlYXNlID0gbmV3IFRvbmUuUGFyYW0odGhpcy5fY29tcHJlc3Nvci5yZWxlYXNlLCBUb25lLlR5cGUuVGltZSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGtuZWUgcGFyYW1ldGVyXG5cdFx0XHQgKiAgQHR5cGUge0RlY2liZWxzfVxuXHRcdFx0ICogIEBzaWduYWxcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMua25lZSA9IG5ldyBUb25lLlBhcmFtKHtcblx0ICAgICAgICAgICAgJ3BhcmFtJzogdGhpcy5fY29tcHJlc3Nvci5rbmVlLFxuXHQgICAgICAgICAgICAndW5pdHMnOiBUb25lLlR5cGUuRGVjaWJlbHMsXG5cdCAgICAgICAgICAgICdjb252ZXJ0JzogZmFsc2Vcblx0ICAgICAgICB9KTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgcmF0aW8gdmFsdWVcblx0XHRcdCAqICBAdHlwZSB7TnVtYmVyfVxuXHRcdFx0ICogIEBzaWduYWxcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMucmF0aW8gPSBuZXcgVG9uZS5QYXJhbSh7XG5cdCAgICAgICAgICAgICdwYXJhbSc6IHRoaXMuX2NvbXByZXNzb3IucmF0aW8sXG5cdCAgICAgICAgICAgICdjb252ZXJ0JzogZmFsc2Vcblx0ICAgICAgICB9KTtcblx0ICAgICAgICAvL3NldCB0aGUgZGVmYXVsdHNcblx0ICAgICAgICB0aGlzLl9yZWFkT25seShbXG5cdCAgICAgICAgICAgICdrbmVlJyxcblx0ICAgICAgICAgICAgJ3JlbGVhc2UnLFxuXHQgICAgICAgICAgICAnYXR0YWNrJyxcblx0ICAgICAgICAgICAgJ3JhdGlvJyxcblx0ICAgICAgICAgICAgJ3RocmVzaG9sZCdcblx0ICAgICAgICBdKTtcblx0ICAgICAgICB0aGlzLnNldChvcHRpb25zKTtcblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLkNvbXByZXNzb3IsIFRvbmUuQXVkaW9Ob2RlKTtcblx0ICAgIC8qKlxuXHRcdCAqICBAc3RhdGljXG5cdFx0ICogIEBjb25zdFxuXHRcdCAqICBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqL1xuXHQgICAgVG9uZS5Db21wcmVzc29yLmRlZmF1bHRzID0ge1xuXHQgICAgICAgICdyYXRpbyc6IDEyLFxuXHQgICAgICAgICd0aHJlc2hvbGQnOiAtMjQsXG5cdCAgICAgICAgJ3JlbGVhc2UnOiAwLjI1LFxuXHQgICAgICAgICdhdHRhY2snOiAwLjAwMyxcblx0ICAgICAgICAna25lZSc6IDMwXG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIGNsZWFuIHVwXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLkNvbXByZXNzb3J9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuQ29tcHJlc3Nvci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLkF1ZGlvTm9kZS5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuX3dyaXRhYmxlKFtcblx0ICAgICAgICAgICAgJ2tuZWUnLFxuXHQgICAgICAgICAgICAncmVsZWFzZScsXG5cdCAgICAgICAgICAgICdhdHRhY2snLFxuXHQgICAgICAgICAgICAncmF0aW8nLFxuXHQgICAgICAgICAgICAndGhyZXNob2xkJ1xuXHQgICAgICAgIF0pO1xuXHQgICAgICAgIHRoaXMuX2NvbXByZXNzb3IuZGlzY29ubmVjdCgpO1xuXHQgICAgICAgIHRoaXMuX2NvbXByZXNzb3IgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuYXR0YWNrLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLmF0dGFjayA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5yZWxlYXNlLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLnJlbGVhc2UgPSBudWxsO1xuXHQgICAgICAgIHRoaXMudGhyZXNob2xkLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLnRocmVzaG9sZCA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5yYXRpby5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5yYXRpbyA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5rbmVlLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLmtuZWUgPSBudWxsO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLkNvbXByZXNzb3I7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyBBZGQgYSBzaWduYWwgYW5kIGEgbnVtYmVyIG9yIHR3byBzaWduYWxzLiBXaGVuIG5vIHZhbHVlIGlzXG5cdFx0ICogICAgICAgICBwYXNzZWQgaW50byB0aGUgY29uc3RydWN0b3IsIFRvbmUuQWRkIHdpbGwgc3VtIDxjb2RlPmlucHV0WzBdPC9jb2RlPlxuXHRcdCAqICAgICAgICAgYW5kIDxjb2RlPmlucHV0WzFdPC9jb2RlPi4gSWYgYSB2YWx1ZSBpcyBwYXNzZWQgaW50byB0aGUgY29uc3RydWN0b3IsIFxuXHRcdCAqICAgICAgICAgdGhlIGl0IHdpbGwgYmUgYWRkZWQgdG8gdGhlIGlucHV0LlxuXHRcdCAqICBcblx0XHQgKiAgQGNvbnN0cnVjdG9yXG5cdFx0ICogIEBleHRlbmRzIHtUb25lLlNpZ25hbH1cblx0XHQgKiAgQHBhcmFtIHtudW1iZXI9fSB2YWx1ZSBJZiBubyB2YWx1ZSBpcyBwcm92aWRlZCwgVG9uZS5BZGQgd2lsbCBzdW0gdGhlIGZpcnN0XG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgYW5kIHNlY29uZCBpbnB1dHMuIFxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIHZhciBzaWduYWwgPSBuZXcgVG9uZS5TaWduYWwoMik7XG5cdFx0ICogdmFyIGFkZCA9IG5ldyBUb25lLkFkZCgyKTtcblx0XHQgKiBzaWduYWwuY29ubmVjdChhZGQpO1xuXHRcdCAqIC8vdGhlIG91dHB1dCBvZiBhZGQgZXF1YWxzIDRcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAvL2lmIGNvbnN0cnVjdGVkIHdpdGggbm8gYXJndW1lbnRzXG5cdFx0ICogLy9pdCB3aWxsIGFkZCB0aGUgZmlyc3QgYW5kIHNlY29uZCBpbnB1dHNcblx0XHQgKiB2YXIgYWRkID0gbmV3IFRvbmUuQWRkKCk7XG5cdFx0ICogdmFyIHNpZzAgPSBuZXcgVG9uZS5TaWduYWwoMykuY29ubmVjdChhZGQsIDAsIDApO1xuXHRcdCAqIHZhciBzaWcxID0gbmV3IFRvbmUuU2lnbmFsKDQpLmNvbm5lY3QoYWRkLCAwLCAxKTtcblx0XHQgKiAvL3RoZSBvdXRwdXQgb2YgYWRkIGVxdWFscyA3LiBcblx0XHQgKi9cblx0ICAgIFRvbmUuQWRkID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgVG9uZS5TaWduYWwuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLmNyZWF0ZUluc091dHMoMiwgMCk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgdGhlIHN1bW1pbmcgbm9kZVxuXHRcdFx0ICogIEB0eXBlIHtHYWluTm9kZX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fc3VtID0gdGhpcy5pbnB1dFswXSA9IHRoaXMuaW5wdXRbMV0gPSB0aGlzLm91dHB1dCA9IG5ldyBUb25lLkdhaW4oKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICogIEB0eXBlIHtUb25lLlNpZ25hbH1cblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX3BhcmFtID0gdGhpcy5pbnB1dFsxXSA9IG5ldyBUb25lLlNpZ25hbCh2YWx1ZSk7XG5cdCAgICAgICAgdGhpcy5fcGFyYW0uY29ubmVjdCh0aGlzLl9zdW0pO1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuQWRkLCBUb25lLlNpZ25hbCk7XG5cdCAgICAvKipcblx0XHQgKiAgQ2xlYW4gdXAuXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLkFkZH0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5BZGQucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5TaWduYWwucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLl9zdW0uZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX3N1bSA9IG51bGw7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuQWRkO1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgIE11bHRpcGx5IHR3byBpbmNvbWluZyBzaWduYWxzLiBPciwgaWYgYSBudW1iZXIgaXMgZ2l2ZW4gaW4gdGhlIGNvbnN0cnVjdG9yLCBcblx0XHQgKiAgICAgICAgICBtdWx0aXBsaWVzIHRoZSBpbmNvbWluZyBzaWduYWwgYnkgdGhhdCB2YWx1ZS4gXG5cdFx0ICpcblx0XHQgKiAgQGNvbnN0cnVjdG9yXG5cdFx0ICogIEBleHRlbmRzIHtUb25lLlNpZ25hbH1cblx0XHQgKiAgQHBhcmFtIHtudW1iZXI9fSB2YWx1ZSBDb25zdGFudCB2YWx1ZSB0byBtdWx0aXBsZS4gSWYgbm8gdmFsdWUgaXMgcHJvdmlkZWQsXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgaXQgd2lsbCByZXR1cm4gdGhlIHByb2R1Y3Qgb2YgdGhlIGZpcnN0IGFuZCBzZWNvbmQgaW5wdXRzXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogdmFyIG11bHQgPSBuZXcgVG9uZS5NdWx0aXBseSgpO1xuXHRcdCAqIHZhciBzaWdBID0gbmV3IFRvbmUuU2lnbmFsKDMpO1xuXHRcdCAqIHZhciBzaWdCID0gbmV3IFRvbmUuU2lnbmFsKDQpO1xuXHRcdCAqIHNpZ0EuY29ubmVjdChtdWx0LCAwLCAwKTtcblx0XHQgKiBzaWdCLmNvbm5lY3QobXVsdCwgMCwgMSk7XG5cdFx0ICogLy9vdXRwdXQgb2YgbXVsdCBpcyAxMi5cblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiB2YXIgbXVsdCA9IG5ldyBUb25lLk11bHRpcGx5KDEwKTtcblx0XHQgKiB2YXIgc2lnID0gbmV3IFRvbmUuU2lnbmFsKDIpLmNvbm5lY3QobXVsdCk7XG5cdFx0ICogLy90aGUgb3V0cHV0IG9mIG11bHQgaXMgMjAuIFxuXHRcdCAqL1xuXHQgICAgVG9uZS5NdWx0aXBseSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICAgIFRvbmUuU2lnbmFsLmNhbGwodGhpcyk7XG5cdCAgICAgICAgdGhpcy5jcmVhdGVJbnNPdXRzKDIsIDApO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHRoZSBpbnB1dCBub2RlIGlzIHRoZSBzYW1lIGFzIHRoZSBvdXRwdXQgbm9kZVxuXHRcdFx0ICogIGl0IGlzIGFsc28gdGhlIEdhaW5Ob2RlIHdoaWNoIGhhbmRsZXMgdGhlIHNjYWxpbmcgb2YgaW5jb21pbmcgc2lnbmFsXG5cdFx0XHQgKiAgXG5cdFx0XHQgKiAgQHR5cGUge0dhaW5Ob2RlfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9tdWx0ID0gdGhpcy5pbnB1dFswXSA9IHRoaXMub3V0cHV0ID0gbmV3IFRvbmUuR2FpbigpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHRoZSBzY2FsaW5nIHBhcmFtZXRlclxuXHRcdFx0ICogIEB0eXBlIHtBdWRpb1BhcmFtfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9wYXJhbSA9IHRoaXMuaW5wdXRbMV0gPSB0aGlzLm91dHB1dC5nYWluO1xuXHQgICAgICAgIHRoaXMuX3BhcmFtLnZhbHVlID0gVG9uZS5kZWZhdWx0QXJnKHZhbHVlLCAwKTtcblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLk11bHRpcGx5LCBUb25lLlNpZ25hbCk7XG5cdCAgICAvKipcblx0XHQgKiAgY2xlYW4gdXBcblx0XHQgKiAgQHJldHVybnMge1RvbmUuTXVsdGlwbHl9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuTXVsdGlwbHkucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5TaWduYWwucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLl9tdWx0LmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9tdWx0ID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9wYXJhbSA9IG51bGw7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuTXVsdGlwbHk7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyBOZWdhdGUgdGhlIGluY29taW5nIHNpZ25hbC4gaS5lLiBhbiBpbnB1dCBzaWduYWwgb2YgMTAgd2lsbCBvdXRwdXQgLTEwXG5cdFx0ICpcblx0XHQgKiAgQGNvbnN0cnVjdG9yXG5cdFx0ICogIEBleHRlbmRzIHtUb25lLlNpZ25hbEJhc2V9XG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogdmFyIG5lZyA9IG5ldyBUb25lLk5lZ2F0ZSgpO1xuXHRcdCAqIHZhciBzaWcgPSBuZXcgVG9uZS5TaWduYWwoLTIpLmNvbm5lY3QobmVnKTtcblx0XHQgKiAvL291dHB1dCBvZiBuZWcgaXMgcG9zaXRpdmUgMi4gXG5cdFx0ICovXG5cdCAgICBUb25lLk5lZ2F0ZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLlNpZ25hbEJhc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBuZWdhdGlvbiBpcyBkb25lIGJ5IG11bHRpcGx5aW5nIGJ5IC0xXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuTXVsdGlwbHl9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX211bHRpcGx5ID0gdGhpcy5pbnB1dCA9IHRoaXMub3V0cHV0ID0gbmV3IFRvbmUuTXVsdGlwbHkoLTEpO1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuTmVnYXRlLCBUb25lLlNpZ25hbEJhc2UpO1xuXHQgICAgLyoqXG5cdFx0ICogIGNsZWFuIHVwXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLk5lZ2F0ZX0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5OZWdhdGUucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5TaWduYWxCYXNlLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgdGhpcy5fbXVsdGlwbHkuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX211bHRpcGx5ID0gbnVsbDtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVG9uZS5OZWdhdGU7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyBTdWJ0cmFjdCB0aGUgc2lnbmFsIGNvbm5lY3RlZCB0byA8Y29kZT5pbnB1dFsxXTwvY29kZT4gZnJvbSB0aGUgc2lnbmFsIGNvbm5lY3RlZCBcblx0XHQgKiAgICAgICAgIHRvIDxjb2RlPmlucHV0WzBdPC9jb2RlPi4gSWYgYW4gYXJndW1lbnQgaXMgcHJvdmlkZWQgaW4gdGhlIGNvbnN0cnVjdG9yLCB0aGUgXG5cdFx0ICogICAgICAgICBzaWduYWxzIDxjb2RlPi52YWx1ZTwvY29kZT4gd2lsbCBiZSBzdWJ0cmFjdGVkIGZyb20gdGhlIGluY29taW5nIHNpZ25hbC5cblx0XHQgKlxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZS5TaWduYWx9XG5cdFx0ICogIEBjb25zdHJ1Y3RvclxuXHRcdCAqICBAcGFyYW0ge251bWJlcj19IHZhbHVlIFRoZSB2YWx1ZSB0byBzdWJ0cmFjdCBmcm9tIHRoZSBpbmNvbWluZyBzaWduYWwuIElmIHRoZSB2YWx1ZVxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgICAgIGlzIG9taXR0ZWQsIGl0IHdpbGwgc3VidHJhY3QgdGhlIHNlY29uZCBzaWduYWwgZnJvbSB0aGUgZmlyc3QuXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogdmFyIHN1YiA9IG5ldyBUb25lLlN1YnRyYWN0KDEpO1xuXHRcdCAqIHZhciBzaWcgPSBuZXcgVG9uZS5TaWduYWwoNCkuY29ubmVjdChzdWIpO1xuXHRcdCAqIC8vdGhlIG91dHB1dCBvZiBzdWIgaXMgMy4gXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogdmFyIHN1YiA9IG5ldyBUb25lLlN1YnRyYWN0KCk7XG5cdFx0ICogdmFyIHNpZ0EgPSBuZXcgVG9uZS5TaWduYWwoMTApO1xuXHRcdCAqIHZhciBzaWdCID0gbmV3IFRvbmUuU2lnbmFsKDIuNSk7XG5cdFx0ICogc2lnQS5jb25uZWN0KHN1YiwgMCwgMCk7XG5cdFx0ICogc2lnQi5jb25uZWN0KHN1YiwgMCwgMSk7XG5cdFx0ICogLy9vdXRwdXQgb2Ygc3ViIGlzIDcuNVxuXHRcdCAqL1xuXHQgICAgVG9uZS5TdWJ0cmFjdCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICAgIFRvbmUuU2lnbmFsLmNhbGwodGhpcyk7XG5cdCAgICAgICAgdGhpcy5jcmVhdGVJbnNPdXRzKDIsIDApO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHRoZSBzdW1taW5nIG5vZGVcblx0XHRcdCAqICBAdHlwZSB7R2Fpbk5vZGV9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX3N1bSA9IHRoaXMuaW5wdXRbMF0gPSB0aGlzLm91dHB1dCA9IG5ldyBUb25lLkdhaW4oKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBuZWdhdGUgdGhlIGlucHV0IG9mIHRoZSBzZWNvbmQgaW5wdXQgYmVmb3JlIGNvbm5lY3RpbmcgaXRcblx0XHRcdCAqICB0byB0aGUgc3VtbWluZyBub2RlLlxuXHRcdFx0ICogIEB0eXBlIHtUb25lLk5lZ2F0ZX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fbmVnID0gbmV3IFRvbmUuTmVnYXRlKCk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgdGhlIG5vZGUgd2hlcmUgdGhlIHZhbHVlIGlzIHNldFxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuU2lnbmFsfVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fcGFyYW0gPSB0aGlzLmlucHV0WzFdID0gbmV3IFRvbmUuU2lnbmFsKHZhbHVlKTtcblx0ICAgICAgICB0aGlzLl9wYXJhbS5jaGFpbih0aGlzLl9uZWcsIHRoaXMuX3N1bSk7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5TdWJ0cmFjdCwgVG9uZS5TaWduYWwpO1xuXHQgICAgLyoqXG5cdFx0ICogIENsZWFuIHVwLlxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5TaWduYWxCYXNlfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLlN1YnRyYWN0LnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuU2lnbmFsLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgdGhpcy5fbmVnLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9uZWcgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX3N1bS5kaXNjb25uZWN0KCk7XG5cdCAgICAgICAgdGhpcy5fc3VtID0gbnVsbDtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVG9uZS5TdWJ0cmFjdDtcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgXG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzICBHcmVhdGVyVGhhblplcm8gb3V0cHV0cyAxIHdoZW4gdGhlIGlucHV0IGlzIHN0cmljdGx5IGdyZWF0ZXIgdGhhbiB6ZXJvXG5cdFx0ICogIFxuXHRcdCAqICBAY29uc3RydWN0b3Jcblx0XHQgKiAgQGV4dGVuZHMge1RvbmUuU2lnbmFsQmFzZX1cblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiB2YXIgZ3QwID0gbmV3IFRvbmUuR3JlYXRlclRoYW5aZXJvKCk7XG5cdFx0ICogdmFyIHNpZyA9IG5ldyBUb25lLlNpZ25hbCgwLjAxKS5jb25uZWN0KGd0MCk7XG5cdFx0ICogLy90aGUgb3V0cHV0IG9mIGd0MCBpcyAxLiBcblx0XHQgKiBzaWcudmFsdWUgPSAwO1xuXHRcdCAqIC8vdGhlIG91dHB1dCBvZiBndDAgaXMgMC4gXG5cdFx0ICovXG5cdCAgICBUb25lLkdyZWF0ZXJUaGFuWmVybyA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLlNpZ25hbEJhc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5XYXZlU2hhcGVyfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl90aHJlc2ggPSB0aGlzLm91dHB1dCA9IG5ldyBUb25lLldhdmVTaGFwZXIoZnVuY3Rpb24gKHZhbCkge1xuXHQgICAgICAgICAgICBpZiAodmFsIDw9IDApIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiAwO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIDE7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9LCAxMjcpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHNjYWxlIHRoZSBmaXJzdCB0aHJlc2hvbGRlZCBzaWduYWwgYnkgYSBsYXJnZSB2YWx1ZS5cblx0XHRcdCAqICB0aGlzIHdpbGwgaGVscCB3aXRoIHZhbHVlcyB3aGljaCBhcmUgdmVyeSBjbG9zZSB0byAwXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuTXVsdGlwbHl9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX3NjYWxlID0gdGhpcy5pbnB1dCA9IG5ldyBUb25lLk11bHRpcGx5KDEwMDAwKTtcblx0ICAgICAgICAvL2Nvbm5lY3Rpb25zXG5cdCAgICAgICAgdGhpcy5fc2NhbGUuY29ubmVjdCh0aGlzLl90aHJlc2gpO1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuR3JlYXRlclRoYW5aZXJvLCBUb25lLlNpZ25hbEJhc2UpO1xuXHQgICAgLyoqXG5cdFx0ICogIGRpc3Bvc2UgbWV0aG9kXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLkdyZWF0ZXJUaGFuWmVyb30gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5HcmVhdGVyVGhhblplcm8ucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5TaWduYWxCYXNlLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgdGhpcy5fc2NhbGUuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX3NjYWxlID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl90aHJlc2guZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX3RocmVzaCA9IG51bGw7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuR3JlYXRlclRoYW5aZXJvO1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgIE91dHB1dCAxIGlmIHRoZSBzaWduYWwgaXMgZ3JlYXRlciB0aGFuIHRoZSB2YWx1ZSwgb3RoZXJ3aXNlIG91dHB1dHMgMC5cblx0XHQgKiAgICAgICAgICBjYW4gY29tcGFyZSB0d28gc2lnbmFscyBvciBhIHNpZ25hbCBhbmQgYSBudW1iZXIuIFxuXHRcdCAqICBcblx0XHQgKiAgQGNvbnN0cnVjdG9yXG5cdFx0ICogIEBleHRlbmRzIHtUb25lLlNpZ25hbH1cblx0XHQgKiAgQHBhcmFtIHtudW1iZXJ9IFt2YWx1ZT0wXSB0aGUgdmFsdWUgdG8gY29tcGFyZSB0byB0aGUgaW5jb21pbmcgc2lnbmFsXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogdmFyIGd0ID0gbmV3IFRvbmUuR3JlYXRlclRoYW4oMik7XG5cdFx0ICogdmFyIHNpZyA9IG5ldyBUb25lLlNpZ25hbCg0KS5jb25uZWN0KGd0KTtcblx0XHQgKiAvL291dHB1dCBvZiBndCBpcyBlcXVhbCAxLiBcblx0XHQgKi9cblx0ICAgIFRvbmUuR3JlYXRlclRoYW4gPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgICBUb25lLlNpZ25hbC5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuY3JlYXRlSW5zT3V0cygyLCAwKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBzdWJ0cmFjdCB0aGUgYW1vdW50IGZyb20gdGhlIGluY29taW5nIHNpZ25hbFxuXHRcdFx0ICogIEB0eXBlIHtUb25lLlN1YnRyYWN0fVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9wYXJhbSA9IHRoaXMuaW5wdXRbMF0gPSBuZXcgVG9uZS5TdWJ0cmFjdCh2YWx1ZSk7XG5cdCAgICAgICAgdGhpcy5pbnB1dFsxXSA9IHRoaXMuX3BhcmFtLmlucHV0WzFdO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIGNvbXBhcmUgdGhhdCBhbW91bnQgdG8gemVyb1xuXHRcdFx0ICogIEB0eXBlIHtUb25lLkdyZWF0ZXJUaGFuWmVyb31cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fZ3R6ID0gdGhpcy5vdXRwdXQgPSBuZXcgVG9uZS5HcmVhdGVyVGhhblplcm8oKTtcblx0ICAgICAgICAvL2Nvbm5lY3Rcblx0ICAgICAgICB0aGlzLl9wYXJhbS5jb25uZWN0KHRoaXMuX2d0eik7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5HcmVhdGVyVGhhbiwgVG9uZS5TaWduYWwpO1xuXHQgICAgLyoqXG5cdFx0ICogIGRpc3Bvc2UgbWV0aG9kXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLkdyZWF0ZXJUaGFufSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkdyZWF0ZXJUaGFuLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuU2lnbmFsLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgdGhpcy5fZ3R6LmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9ndHogPSBudWxsO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLkdyZWF0ZXJUaGFuO1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgUmV0dXJuIHRoZSBhYnNvbHV0ZSB2YWx1ZSBvZiBhbiBpbmNvbWluZyBzaWduYWwuIFxuXHRcdCAqICBcblx0XHQgKiAgQGNvbnN0cnVjdG9yXG5cdFx0ICogIEBleHRlbmRzIHtUb25lLlNpZ25hbEJhc2V9XG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogdmFyIHNpZ25hbCA9IG5ldyBUb25lLlNpZ25hbCgtMSk7XG5cdFx0ICogdmFyIGFicyA9IG5ldyBUb25lLkFicygpO1xuXHRcdCAqIHNpZ25hbC5jb25uZWN0KGFicyk7XG5cdFx0ICogLy90aGUgb3V0cHV0IG9mIGFicyBpcyAxLiBcblx0XHQgKi9cblx0ICAgIFRvbmUuQWJzID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuU2lnbmFsQmFzZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIEB0eXBlIHtUb25lLkxlc3NUaGFufVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9hYnMgPSB0aGlzLmlucHV0ID0gdGhpcy5vdXRwdXQgPSBuZXcgVG9uZS5XYXZlU2hhcGVyKGZ1bmN0aW9uICh2YWwpIHtcblx0ICAgICAgICAgICAgaWYgKHZhbCA9PT0gMCkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIDA7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5hYnModmFsKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0sIDEyNyk7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5BYnMsIFRvbmUuU2lnbmFsQmFzZSk7XG5cdCAgICAvKipcblx0XHQgKiAgZGlzcG9zZSBtZXRob2Rcblx0XHQgKiAgQHJldHVybnMge1RvbmUuQWJzfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkFicy5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLlNpZ25hbEJhc2UucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLl9hYnMuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX2FicyA9IG51bGw7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuQWJzO1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgU2lnbmFsLXJhdGUgbW9kdWxvIG9wZXJhdG9yLiBPbmx5IHdvcmtzIGluIEF1ZGlvUmFuZ2UgWy0xLCAxXSBhbmQgZm9yIG1vZHVsdXNcblx0XHQgKiAgICAgICAgIHZhbHVlcyBpbiB0aGUgTm9ybWFsUmFuZ2UuIFxuXHRcdCAqXG5cdFx0ICogIEBjb25zdHJ1Y3RvclxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZS5TaWduYWxCYXNlfVxuXHRcdCAqICBAcGFyYW0ge05vcm1hbFJhbmdlfSBtb2R1bHVzIFRoZSBtb2R1bHVzIHRvIGFwcGx5LlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIHZhciBtb2QgPSBuZXcgVG9uZS5Nb2R1bG8oMC4yKVxuXHRcdCAqIHZhciBzaWcgPSBuZXcgVG9uZS5TaWduYWwoMC41KS5jb25uZWN0KG1vZCk7XG5cdFx0ICogLy9tb2Qgb3V0cHV0cyAwLjFcblx0XHQgKi9cblx0ICAgIFRvbmUuTW9kdWxvID0gZnVuY3Rpb24gKG1vZHVsdXMpIHtcblx0ICAgICAgICBUb25lLlNpZ25hbEJhc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLmNyZWF0ZUluc091dHMoMSwgMCk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgQSB3YXZlc2hhcGVyIGdldHMgdGhlIGludGVnZXIgbXVsdGlwbGUgb2YgXG5cdFx0XHQgKiAgdGhlIGlucHV0IHNpZ25hbCBhbmQgdGhlIG1vZHVsdXMuXG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5XYXZlU2hhcGVyfVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fc2hhcGVyID0gbmV3IFRvbmUuV2F2ZVNoYXBlcihNYXRoLnBvdygyLCAxNikpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHRoZSBpbnRlZ2VyIG11bHRpcGxlIGlzIG11bHRpcGxpZWQgYnkgdGhlIG1vZHVsdXNcblx0XHRcdCAqICBAdHlwZSAge1RvbmUuTXVsdGlwbHl9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX211bHRpcGx5ID0gbmV3IFRvbmUuTXVsdGlwbHkoKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBhbmQgc3VidHJhY3RlZCBmcm9tIHRoZSBpbnB1dCBzaWduYWxcblx0XHRcdCAqICBAdHlwZSAge1RvbmUuU3VidHJhY3R9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX3N1YnRyYWN0ID0gdGhpcy5vdXRwdXQgPSBuZXcgVG9uZS5TdWJ0cmFjdCgpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHRoZSBtb2R1bHVzIHNpZ25hbFxuXHRcdFx0ICogIEB0eXBlICB7VG9uZS5TaWduYWx9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX21vZFNpZ25hbCA9IG5ldyBUb25lLlNpZ25hbChtb2R1bHVzKTtcblx0ICAgICAgICAvL2Nvbm5lY3Rpb25zXG5cdCAgICAgICAgdGhpcy5pbnB1dC5mYW4odGhpcy5fc2hhcGVyLCB0aGlzLl9zdWJ0cmFjdCk7XG5cdCAgICAgICAgdGhpcy5fbW9kU2lnbmFsLmNvbm5lY3QodGhpcy5fbXVsdGlwbHksIDAsIDApO1xuXHQgICAgICAgIHRoaXMuX3NoYXBlci5jb25uZWN0KHRoaXMuX211bHRpcGx5LCAwLCAxKTtcblx0ICAgICAgICB0aGlzLl9tdWx0aXBseS5jb25uZWN0KHRoaXMuX3N1YnRyYWN0LCAwLCAxKTtcblx0ICAgICAgICB0aGlzLl9zZXRXYXZlU2hhcGVyKG1vZHVsdXMpO1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuTW9kdWxvLCBUb25lLlNpZ25hbEJhc2UpO1xuXHQgICAgLyoqXG5cdFx0ICogIEBwYXJhbSAge251bWJlcn0gIG1vZCAgdGhlIG1vZHVsdXMgdG8gYXBwbHlcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuTW9kdWxvLnByb3RvdHlwZS5fc2V0V2F2ZVNoYXBlciA9IGZ1bmN0aW9uIChtb2QpIHtcblx0ICAgICAgICB0aGlzLl9zaGFwZXIuc2V0TWFwKGZ1bmN0aW9uICh2YWwpIHtcblx0ICAgICAgICAgICAgdmFyIG11bHRpcGxlID0gTWF0aC5mbG9vcigodmFsICsgMC4wMDAxKSAvIG1vZCk7XG5cdCAgICAgICAgICAgIHJldHVybiBtdWx0aXBsZTtcblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiBUaGUgbW9kdWx1cyB2YWx1ZS5cblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5Nb2R1bG8jXG5cdFx0ICogQHR5cGUge05vcm1hbFJhbmdlfVxuXHRcdCAqIEBuYW1lIHZhbHVlXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5Nb2R1bG8ucHJvdG90eXBlLCAndmFsdWUnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9tb2RTaWduYWwudmFsdWU7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChtb2QpIHtcblx0ICAgICAgICAgICAgdGhpcy5fbW9kU2lnbmFsLnZhbHVlID0gbW9kO1xuXHQgICAgICAgICAgICB0aGlzLl9zZXRXYXZlU2hhcGVyKG1vZCk7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiBjbGVhbiB1cFxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5Nb2R1bG99IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuTW9kdWxvLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuU2lnbmFsQmFzZS5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuX3NoYXBlci5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fc2hhcGVyID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9tdWx0aXBseS5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fbXVsdGlwbHkgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX3N1YnRyYWN0LmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9zdWJ0cmFjdCA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fbW9kU2lnbmFsLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9tb2RTaWduYWwgPSBudWxsO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLk1vZHVsbztcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgXG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzIEF1ZGlvVG9HYWluIGNvbnZlcnRzIGFuIGlucHV0IGluIEF1ZGlvUmFuZ2UgWy0xLDFdIHRvIE5vcm1hbFJhbmdlIFswLDFdLiBcblx0XHQgKiAgICAgICAgIFNlZSBUb25lLkdhaW5Ub0F1ZGlvLlxuXHRcdCAqXG5cdFx0ICogIEBleHRlbmRzIHtUb25lLlNpZ25hbEJhc2V9XG5cdFx0ICogIEBjb25zdHJ1Y3RvclxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICB2YXIgYTJnID0gbmV3IFRvbmUuQXVkaW9Ub0dhaW4oKTtcblx0XHQgKi9cblx0ICAgIFRvbmUuQXVkaW9Ub0dhaW4gPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5TaWduYWxCYXNlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgQHR5cGUge1dhdmVTaGFwZXJOb2RlfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9ub3JtID0gdGhpcy5pbnB1dCA9IHRoaXMub3V0cHV0ID0gbmV3IFRvbmUuV2F2ZVNoYXBlcihmdW5jdGlvbiAoeCkge1xuXHQgICAgICAgICAgICByZXR1cm4gKHggKyAxKSAvIDI7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5BdWRpb1RvR2FpbiwgVG9uZS5TaWduYWxCYXNlKTtcblx0ICAgIC8qKlxuXHRcdCAqICBjbGVhbiB1cFxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5BdWRpb1RvR2Fpbn0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5BdWRpb1RvR2Fpbi5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLlNpZ25hbEJhc2UucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLl9ub3JtLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9ub3JtID0gbnVsbDtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVG9uZS5BdWRpb1RvR2Fpbjtcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgXG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzIEV2YWx1YXRlIGFuIGV4cHJlc3Npb24gYXQgYXVkaW8gcmF0ZS4gPGJyPjxicj5cblx0XHQgKiAgICAgICAgIFBhcnNpbmcgY29kZSBtb2RpZmllZCBmcm9tIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvdGFwZGlnaXQvXG5cdFx0ICogICAgICAgICBDb3B5cmlnaHQgMjAxMSAyMDEyIEFyaXlhIEhpZGF5YXQsIE5ldyBCU0QgTGljZW5zZVxuXHRcdCAqXG5cdFx0ICogIEBleHRlbmRzIHtUb25lLlNpZ25hbEJhc2V9XG5cdFx0ICogIEBjb25zdHJ1Y3RvclxuXHRcdCAqICBAcGFyYW0ge3N0cmluZ30gZXhwciB0aGUgZXhwcmVzc2lvbiB0byBnZW5lcmF0ZVxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIC8vYWRkcyB0aGUgc2lnbmFscyBmcm9tIGlucHV0WzBdIGFuZCBpbnB1dFsxXS5cblx0XHQgKiB2YXIgZXhwciA9IG5ldyBUb25lLkV4cHIoXCIkMCArICQxXCIpO1xuXHRcdCAqL1xuXHQgICAgVG9uZS5FeHByID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuU2lnbmFsQmFzZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHZhciBleHByID0gdGhpcy5fcmVwbGFjZW1lbnRzKEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykpO1xuXHQgICAgICAgIHZhciBpbnB1dENvdW50ID0gdGhpcy5fcGFyc2VJbnB1dHMoZXhwcik7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgaG9sZCBvbnRvIGFsbCBvZiB0aGUgbm9kZXMgZm9yIGRpc3Bvc2FsXG5cdFx0XHQgKiAgQHR5cGUge0FycmF5fVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9ub2RlcyA9IFtdO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBpbnB1dHMuIFRoZSBsZW5ndGggaXMgZGV0ZXJtaW5lZCBieSB0aGUgZXhwcmVzc2lvbi4gXG5cdFx0XHQgKiAgQHR5cGUge0FycmF5fVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5pbnB1dCA9IG5ldyBBcnJheShpbnB1dENvdW50KTtcblx0ICAgICAgICAvL2NyZWF0ZSBhIGdhaW4gZm9yIGVhY2ggaW5wdXRcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlucHV0Q291bnQ7IGkrKykge1xuXHQgICAgICAgICAgICB0aGlzLmlucHV0W2ldID0gdGhpcy5jb250ZXh0LmNyZWF0ZUdhaW4oKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgLy9wYXJzZSB0aGUgc3ludGF4IHRyZWVcblx0ICAgICAgICB2YXIgdHJlZSA9IHRoaXMuX3BhcnNlVHJlZShleHByKTtcblx0ICAgICAgICAvL2V2YWx1YXRlIHRoZSByZXN1bHRzXG5cdCAgICAgICAgdmFyIHJlc3VsdDtcblx0ICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICByZXN1bHQgPSB0aGlzLl9ldmFsKHRyZWUpO1xuXHQgICAgICAgIH0gY2F0Y2ggKGUpIHtcblx0ICAgICAgICAgICAgdGhpcy5fZGlzcG9zZU5vZGVzKCk7XG5cdCAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVG9uZS5FeHByOiBDb3VsZCBldmFsdWF0ZSBleHByZXNzaW9uOiAnICsgZXhwcik7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBvdXRwdXQgbm9kZSBpcyB0aGUgcmVzdWx0IG9mIHRoZSBleHByZXNzaW9uXG5cdFx0XHQgKiAgQHR5cGUge1RvbmV9XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLm91dHB1dCA9IHJlc3VsdDtcblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLkV4cHIsIFRvbmUuU2lnbmFsQmFzZSk7XG5cdCAgICAvL3NvbWUgaGVscGVycyB0byBjdXQgZG93biB0aGUgYW1vdW50IG9mIGNvZGVcblx0ICAgIGZ1bmN0aW9uIGFwcGx5QmluYXJ5KENvbnN0cnVjdG9yLCBhcmdzLCBzZWxmKSB7XG5cdCAgICAgICAgdmFyIG9wID0gbmV3IENvbnN0cnVjdG9yKCk7XG5cdCAgICAgICAgc2VsZi5fZXZhbChhcmdzWzBdKS5jb25uZWN0KG9wLCAwLCAwKTtcblx0ICAgICAgICBzZWxmLl9ldmFsKGFyZ3NbMV0pLmNvbm5lY3Qob3AsIDAsIDEpO1xuXHQgICAgICAgIHJldHVybiBvcDtcblx0ICAgIH1cblx0ICAgIGZ1bmN0aW9uIGFwcGx5VW5hcnkoQ29uc3RydWN0b3IsIGFyZ3MsIHNlbGYpIHtcblx0ICAgICAgICB2YXIgb3AgPSBuZXcgQ29uc3RydWN0b3IoKTtcblx0ICAgICAgICBzZWxmLl9ldmFsKGFyZ3NbMF0pLmNvbm5lY3Qob3AsIDAsIDApO1xuXHQgICAgICAgIHJldHVybiBvcDtcblx0ICAgIH1cblx0ICAgIGZ1bmN0aW9uIGdldE51bWJlcihhcmcpIHtcblx0ICAgICAgICByZXR1cm4gYXJnID8gcGFyc2VGbG9hdChhcmcpIDogdW5kZWZpbmVkO1xuXHQgICAgfVxuXHQgICAgZnVuY3Rpb24gbGl0ZXJhbE51bWJlcihhcmcpIHtcblx0ICAgICAgICByZXR1cm4gYXJnICYmIGFyZy5hcmdzID8gcGFyc2VGbG9hdChhcmcuYXJncykgOiB1bmRlZmluZWQ7XG5cdCAgICB9XG5cdCAgICAvKlxuXHRcdCAqICB0aGUgRXhwcmVzc2lvbnMgdGhhdCBUb25lLkV4cHIgY2FuIHBhcnNlLlxuXHRcdCAqXG5cdFx0ICogIGVhY2ggZXhwcmVzc2lvbiBiZWxvbmdzIHRvIGEgZ3JvdXAgYW5kIGNvbnRhaW5zIGEgcmVnZXhwIFxuXHRcdCAqICBmb3Igc2VsZWN0aW5nIHRoZSBvcGVyYXRvciBhcyB3ZWxsIGFzIHRoYXQgb3BlcmF0b3JzIG1ldGhvZFxuXHRcdCAqICBcblx0XHQgKiAgQHR5cGUge09iamVjdH1cblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuRXhwci5fRXhwcmVzc2lvbnMgPSB7XG5cdCAgICAgICAgLy92YWx1ZXNcblx0ICAgICAgICAndmFsdWUnOiB7XG5cdCAgICAgICAgICAgICdzaWduYWwnOiB7XG5cdCAgICAgICAgICAgICAgICByZWdleHA6IC9eXFxkK1xcLlxcZCt8XlxcZCsvLFxuXHQgICAgICAgICAgICAgICAgbWV0aG9kOiBmdW5jdGlvbiAoYXJnKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHNpZyA9IG5ldyBUb25lLlNpZ25hbChnZXROdW1iZXIoYXJnKSk7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNpZztcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgJ2lucHV0Jzoge1xuXHQgICAgICAgICAgICAgICAgcmVnZXhwOiAvXlxcJFxcZC8sXG5cdCAgICAgICAgICAgICAgICBtZXRob2Q6IGZ1bmN0aW9uIChhcmcsIHNlbGYpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5pbnB1dFtnZXROdW1iZXIoYXJnLnN1YnN0cigxKSldO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblx0ICAgICAgICAvL3N5bnRhY3RpYyBnbHVlXG5cdCAgICAgICAgJ2dsdWUnOiB7XG5cdCAgICAgICAgICAgICcoJzogeyByZWdleHA6IC9eXFwoLyB9LFxuXHQgICAgICAgICAgICAnKSc6IHsgcmVnZXhwOiAvXlxcKS8gfSxcblx0ICAgICAgICAgICAgJywnOiB7IHJlZ2V4cDogL14sLyB9XG5cdCAgICAgICAgfSxcblx0ICAgICAgICAvL2Z1bmN0aW9uc1xuXHQgICAgICAgICdmdW5jJzoge1xuXHQgICAgICAgICAgICAnYWJzJzoge1xuXHQgICAgICAgICAgICAgICAgcmVnZXhwOiAvXmFicy8sXG5cdCAgICAgICAgICAgICAgICBtZXRob2Q6IGFwcGx5VW5hcnkuYmluZCh0aGlzLCBUb25lLkFicylcblx0ICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgJ21vZCc6IHtcblx0ICAgICAgICAgICAgICAgIHJlZ2V4cDogL15tb2QvLFxuXHQgICAgICAgICAgICAgICAgbWV0aG9kOiBmdW5jdGlvbiAoYXJncywgc2VsZikge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBtb2R1bHVzID0gbGl0ZXJhbE51bWJlcihhcmdzWzFdKTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgb3AgPSBuZXcgVG9uZS5Nb2R1bG8obW9kdWx1cyk7XG5cdCAgICAgICAgICAgICAgICAgICAgc2VsZi5fZXZhbChhcmdzWzBdKS5jb25uZWN0KG9wKTtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3A7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgICdwb3cnOiB7XG5cdCAgICAgICAgICAgICAgICByZWdleHA6IC9ecG93Lyxcblx0ICAgICAgICAgICAgICAgIG1ldGhvZDogZnVuY3Rpb24gKGFyZ3MsIHNlbGYpIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZXhwID0gbGl0ZXJhbE51bWJlcihhcmdzWzFdKTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgb3AgPSBuZXcgVG9uZS5Qb3coZXhwKTtcblx0ICAgICAgICAgICAgICAgICAgICBzZWxmLl9ldmFsKGFyZ3NbMF0pLmNvbm5lY3Qob3ApO1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBvcDtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgJ2EyZyc6IHtcblx0ICAgICAgICAgICAgICAgIHJlZ2V4cDogL15hMmcvLFxuXHQgICAgICAgICAgICAgICAgbWV0aG9kOiBmdW5jdGlvbiAoYXJncywgc2VsZikge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBvcCA9IG5ldyBUb25lLkF1ZGlvVG9HYWluKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgc2VsZi5fZXZhbChhcmdzWzBdKS5jb25uZWN0KG9wKTtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3A7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9LFxuXHQgICAgICAgIC8vYmluYXJ5IGV4cHJlc3Npb25zXG5cdCAgICAgICAgJ2JpbmFyeSc6IHtcblx0ICAgICAgICAgICAgJysnOiB7XG5cdCAgICAgICAgICAgICAgICByZWdleHA6IC9eXFwrLyxcblx0ICAgICAgICAgICAgICAgIHByZWNlZGVuY2U6IDEsXG5cdCAgICAgICAgICAgICAgICBtZXRob2Q6IGFwcGx5QmluYXJ5LmJpbmQodGhpcywgVG9uZS5BZGQpXG5cdCAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgICctJzoge1xuXHQgICAgICAgICAgICAgICAgcmVnZXhwOiAvXlxcLS8sXG5cdCAgICAgICAgICAgICAgICBwcmVjZWRlbmNlOiAxLFxuXHQgICAgICAgICAgICAgICAgbWV0aG9kOiBmdW5jdGlvbiAoYXJncywgc2VsZikge1xuXHQgICAgICAgICAgICAgICAgICAgIC8vYm90aCB1bmFyeSBhbmQgYmluYXJ5IG9wXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGFyZ3MubGVuZ3RoID09PSAxKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhcHBseVVuYXJ5KFRvbmUuTmVnYXRlLCBhcmdzLCBzZWxmKTtcblx0ICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXBwbHlCaW5hcnkoVG9uZS5TdWJ0cmFjdCwgYXJncywgc2VsZik7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICAnKic6IHtcblx0ICAgICAgICAgICAgICAgIHJlZ2V4cDogL15cXCovLFxuXHQgICAgICAgICAgICAgICAgcHJlY2VkZW5jZTogMCxcblx0ICAgICAgICAgICAgICAgIG1ldGhvZDogYXBwbHlCaW5hcnkuYmluZCh0aGlzLCBUb25lLk11bHRpcGx5KVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblx0ICAgICAgICAvL3VuYXJ5IGV4cHJlc3Npb25zXG5cdCAgICAgICAgJ3VuYXJ5Jzoge1xuXHQgICAgICAgICAgICAnLSc6IHtcblx0ICAgICAgICAgICAgICAgIHJlZ2V4cDogL15cXC0vLFxuXHQgICAgICAgICAgICAgICAgbWV0aG9kOiBhcHBseVVuYXJ5LmJpbmQodGhpcywgVG9uZS5OZWdhdGUpXG5cdCAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgICchJzoge1xuXHQgICAgICAgICAgICAgICAgcmVnZXhwOiAvXlxcIS8sXG5cdCAgICAgICAgICAgICAgICBtZXRob2Q6IGFwcGx5VW5hcnkuYmluZCh0aGlzLCBUb25lLk5PVClcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgQHBhcmFtICAge3N0cmluZ30gZXhwciB0aGUgZXhwcmVzc2lvbiBzdHJpbmdcblx0XHQgKiAgQHJldHVybiAge251bWJlcn0gICAgICB0aGUgaW5wdXQgY291bnRcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuRXhwci5wcm90b3R5cGUuX3BhcnNlSW5wdXRzID0gZnVuY3Rpb24gKGV4cHIpIHtcblx0ICAgICAgICB2YXIgaW5wdXRBcnJheSA9IGV4cHIubWF0Y2goL1xcJFxcZC9nKTtcblx0ICAgICAgICB2YXIgaW5wdXRNYXggPSAwO1xuXHQgICAgICAgIGlmIChpbnB1dEFycmF5ICE9PSBudWxsKSB7XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5wdXRBcnJheS5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgdmFyIGlucHV0TnVtID0gcGFyc2VJbnQoaW5wdXRBcnJheVtpXS5zdWJzdHIoMSkpICsgMTtcblx0ICAgICAgICAgICAgICAgIGlucHV0TWF4ID0gTWF0aC5tYXgoaW5wdXRNYXgsIGlucHV0TnVtKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gaW5wdXRNYXg7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIEBwYXJhbSAgIHtBcnJheX0gYXJncyBcdGFuIGFycmF5IG9mIGFyZ3VtZW50c1xuXHRcdCAqICBAcmV0dXJuICB7c3RyaW5nfSB0aGUgcmVzdWx0cyBvZiB0aGUgcmVwbGFjZW1lbnRzIGJlaW5nIHJlcGxhY2VkXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLkV4cHIucHJvdG90eXBlLl9yZXBsYWNlbWVudHMgPSBmdW5jdGlvbiAoYXJncykge1xuXHQgICAgICAgIHZhciBleHByID0gYXJncy5zaGlmdCgpO1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICBleHByID0gZXhwci5yZXBsYWNlKC9cXCUvaSwgYXJnc1tpXSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBleHByO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICB0b2tlbml6ZSB0aGUgZXhwcmVzc2lvbiBiYXNlZCBvbiB0aGUgRXhwcmVzc2lvbnMgb2JqZWN0XG5cdFx0ICogIEBwYXJhbSAgIHtzdHJpbmd9IGV4cHIgXG5cdFx0ICogIEByZXR1cm4gIHtPYmplY3R9ICAgICAgcmV0dXJucyB0d28gbWV0aG9kcyBvbiB0aGUgdG9rZW5pemVkIGxpc3QsIG5leHQgYW5kIHBlZWtcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuRXhwci5wcm90b3R5cGUuX3Rva2VuaXplID0gZnVuY3Rpb24gKGV4cHIpIHtcblx0ICAgICAgICB2YXIgcG9zaXRpb24gPSAtMTtcblx0ICAgICAgICB2YXIgdG9rZW5zID0gW107XG5cdCAgICAgICAgd2hpbGUgKGV4cHIubGVuZ3RoID4gMCkge1xuXHQgICAgICAgICAgICBleHByID0gZXhwci50cmltKCk7XG5cdCAgICAgICAgICAgIHZhciB0b2tlbiA9IGdldE5leHRUb2tlbihleHByKTtcblx0ICAgICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuXHQgICAgICAgICAgICBleHByID0gZXhwci5zdWJzdHIodG9rZW4udmFsdWUubGVuZ3RoKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZnVuY3Rpb24gZ2V0TmV4dFRva2VuKGV4cHIpIHtcblx0ICAgICAgICAgICAgZm9yICh2YXIgdHlwZSBpbiBUb25lLkV4cHIuX0V4cHJlc3Npb25zKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgZ3JvdXAgPSBUb25lLkV4cHIuX0V4cHJlc3Npb25zW3R5cGVdO1xuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgb3BOYW1lIGluIGdyb3VwKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIG9wID0gZ3JvdXBbb3BOYW1lXTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgcmVnID0gb3AucmVnZXhwO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBtYXRjaCA9IGV4cHIubWF0Y2gocmVnKTtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2ggIT09IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IHR5cGUsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbWF0Y2hbMF0sXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IG9wLm1ldGhvZFxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ1RvbmUuRXhwcjogVW5leHBlY3RlZCB0b2tlbiAnICsgZXhwcik7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbnNbKytwb3NpdGlvbl07XG5cdCAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgIHBlZWs6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbnNbcG9zaXRpb24gKyAxXTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH07XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIHJlY3Vyc2l2ZWx5IHBhcnNlIHRoZSBzdHJpbmcgZXhwcmVzc2lvbiBpbnRvIGEgc3ludGF4IHRyZWVcblx0XHQgKiAgXG5cdFx0ICogIEBwYXJhbSAgIHtzdHJpbmd9IGV4cHIgXG5cdFx0ICogIEByZXR1cm4gIHtPYmplY3R9XG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLkV4cHIucHJvdG90eXBlLl9wYXJzZVRyZWUgPSBmdW5jdGlvbiAoZXhwcikge1xuXHQgICAgICAgIHZhciBsZXhlciA9IHRoaXMuX3Rva2VuaXplKGV4cHIpO1xuXHQgICAgICAgIHZhciBpc1VuZGVmID0gVG9uZS5pc1VuZGVmLmJpbmQodGhpcyk7XG5cdCAgICAgICAgZnVuY3Rpb24gbWF0Y2hTeW50YXgodG9rZW4sIHN5bikge1xuXHQgICAgICAgICAgICByZXR1cm4gIWlzVW5kZWYodG9rZW4pICYmIHRva2VuLnR5cGUgPT09ICdnbHVlJyAmJiB0b2tlbi52YWx1ZSA9PT0gc3luO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiBtYXRjaEdyb3VwKHRva2VuLCBncm91cE5hbWUsIHByZWMpIHtcblx0ICAgICAgICAgICAgdmFyIHJldCA9IGZhbHNlO1xuXHQgICAgICAgICAgICB2YXIgZ3JvdXAgPSBUb25lLkV4cHIuX0V4cHJlc3Npb25zW2dyb3VwTmFtZV07XG5cdCAgICAgICAgICAgIGlmICghaXNVbmRlZih0b2tlbikpIHtcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIG9wTmFtZSBpbiBncm91cCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBvcCA9IGdyb3VwW29wTmFtZV07XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKG9wLnJlZ2V4cC50ZXN0KHRva2VuLnZhbHVlKSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzVW5kZWYocHJlYykpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcC5wcmVjZWRlbmNlID09PSBwcmVjKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gcmV0O1xuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiBwYXJzZUV4cHJlc3Npb24ocHJlY2VkZW5jZSkge1xuXHQgICAgICAgICAgICBpZiAoaXNVbmRlZihwcmVjZWRlbmNlKSkge1xuXHQgICAgICAgICAgICAgICAgcHJlY2VkZW5jZSA9IDU7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdmFyIGV4cHI7XG5cdCAgICAgICAgICAgIGlmIChwcmVjZWRlbmNlIDwgMCkge1xuXHQgICAgICAgICAgICAgICAgZXhwciA9IHBhcnNlVW5hcnkoKTtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIGV4cHIgPSBwYXJzZUV4cHJlc3Npb24ocHJlY2VkZW5jZSAtIDEpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHZhciB0b2tlbiA9IGxleGVyLnBlZWsoKTtcblx0ICAgICAgICAgICAgd2hpbGUgKG1hdGNoR3JvdXAodG9rZW4sICdiaW5hcnknLCBwcmVjZWRlbmNlKSkge1xuXHQgICAgICAgICAgICAgICAgdG9rZW4gPSBsZXhlci5uZXh0KCk7XG5cdCAgICAgICAgICAgICAgICBleHByID0ge1xuXHQgICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yOiB0b2tlbi52YWx1ZSxcblx0ICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IHRva2VuLm1ldGhvZCxcblx0ICAgICAgICAgICAgICAgICAgICBhcmdzOiBbXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGV4cHIsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlRXhwcmVzc2lvbihwcmVjZWRlbmNlIC0gMSlcblx0ICAgICAgICAgICAgICAgICAgICBdXG5cdCAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICAgICAgdG9rZW4gPSBsZXhlci5wZWVrKCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIGV4cHI7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIHBhcnNlVW5hcnkoKSB7XG5cdCAgICAgICAgICAgIHZhciB0b2tlbiwgZXhwcjtcblx0ICAgICAgICAgICAgdG9rZW4gPSBsZXhlci5wZWVrKCk7XG5cdCAgICAgICAgICAgIGlmIChtYXRjaEdyb3VwKHRva2VuLCAndW5hcnknKSkge1xuXHQgICAgICAgICAgICAgICAgdG9rZW4gPSBsZXhlci5uZXh0KCk7XG5cdCAgICAgICAgICAgICAgICBleHByID0gcGFyc2VVbmFyeSgpO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgICAgICAgICBvcGVyYXRvcjogdG9rZW4udmFsdWUsXG5cdCAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiB0b2tlbi5tZXRob2QsXG5cdCAgICAgICAgICAgICAgICAgICAgYXJnczogW2V4cHJdXG5cdCAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiBwYXJzZVByaW1hcnkoKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZnVuY3Rpb24gcGFyc2VQcmltYXJ5KCkge1xuXHQgICAgICAgICAgICB2YXIgdG9rZW4sIGV4cHI7XG5cdCAgICAgICAgICAgIHRva2VuID0gbGV4ZXIucGVlaygpO1xuXHQgICAgICAgICAgICBpZiAoaXNVbmRlZih0b2tlbikpIHtcblx0ICAgICAgICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignVG9uZS5FeHByOiBVbmV4cGVjdGVkIHRlcm1pbmF0aW9uIG9mIGV4cHJlc3Npb24nKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBpZiAodG9rZW4udHlwZSA9PT0gJ2Z1bmMnKSB7XG5cdCAgICAgICAgICAgICAgICB0b2tlbiA9IGxleGVyLm5leHQoKTtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUZ1bmN0aW9uQ2FsbCh0b2tlbik7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09ICd2YWx1ZScpIHtcblx0ICAgICAgICAgICAgICAgIHRva2VuID0gbGV4ZXIubmV4dCgpO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IHRva2VuLm1ldGhvZCxcblx0ICAgICAgICAgICAgICAgICAgICBhcmdzOiB0b2tlbi52YWx1ZVxuXHQgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBpZiAobWF0Y2hTeW50YXgodG9rZW4sICcoJykpIHtcblx0ICAgICAgICAgICAgICAgIGxleGVyLm5leHQoKTtcblx0ICAgICAgICAgICAgICAgIGV4cHIgPSBwYXJzZUV4cHJlc3Npb24oKTtcblx0ICAgICAgICAgICAgICAgIHRva2VuID0gbGV4ZXIubmV4dCgpO1xuXHQgICAgICAgICAgICAgICAgaWYgKCFtYXRjaFN5bnRheCh0b2tlbiwgJyknKSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignRXhwZWN0ZWQgKScpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGV4cHI7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdUb25lLkV4cHI6IFBhcnNlIGVycm9yLCBjYW5ub3QgcHJvY2VzcyB0b2tlbiAnICsgdG9rZW4udmFsdWUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiBwYXJzZUZ1bmN0aW9uQ2FsbChmdW5jKSB7XG5cdCAgICAgICAgICAgIHZhciB0b2tlbiwgYXJncyA9IFtdO1xuXHQgICAgICAgICAgICB0b2tlbiA9IGxleGVyLm5leHQoKTtcblx0ICAgICAgICAgICAgaWYgKCFtYXRjaFN5bnRheCh0b2tlbiwgJygnKSkge1xuXHQgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdUb25lLkV4cHI6IEV4cGVjdGVkICggaW4gYSBmdW5jdGlvbiBjYWxsIFwiJyArIGZ1bmMudmFsdWUgKyAnXCInKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB0b2tlbiA9IGxleGVyLnBlZWsoKTtcblx0ICAgICAgICAgICAgaWYgKCFtYXRjaFN5bnRheCh0b2tlbiwgJyknKSkge1xuXHQgICAgICAgICAgICAgICAgYXJncyA9IHBhcnNlQXJndW1lbnRMaXN0KCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdG9rZW4gPSBsZXhlci5uZXh0KCk7XG5cdCAgICAgICAgICAgIGlmICghbWF0Y2hTeW50YXgodG9rZW4sICcpJykpIHtcblx0ICAgICAgICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignVG9uZS5FeHByOiBFeHBlY3RlZCApIGluIGEgZnVuY3Rpb24gY2FsbCBcIicgKyBmdW5jLnZhbHVlICsgJ1wiJyk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgICAgIG1ldGhvZDogZnVuYy5tZXRob2QsXG5cdCAgICAgICAgICAgICAgICBhcmdzOiBhcmdzLFxuXHQgICAgICAgICAgICAgICAgbmFtZTogbmFtZVxuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiBwYXJzZUFyZ3VtZW50TGlzdCgpIHtcblx0ICAgICAgICAgICAgdmFyIHRva2VuLCBleHByLCBhcmdzID0gW107XG5cdCAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG5cdCAgICAgICAgICAgICAgICBleHByID0gcGFyc2VFeHByZXNzaW9uKCk7XG5cdCAgICAgICAgICAgICAgICBpZiAoaXNVbmRlZihleHByKSkge1xuXHQgICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gbWF5YmUgdGhyb3cgZXhjZXB0aW9uP1xuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgYXJncy5wdXNoKGV4cHIpO1xuXHQgICAgICAgICAgICAgICAgdG9rZW4gPSBsZXhlci5wZWVrKCk7XG5cdCAgICAgICAgICAgICAgICBpZiAoIW1hdGNoU3ludGF4KHRva2VuLCAnLCcpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBsZXhlci5uZXh0KCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIGFyZ3M7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBwYXJzZUV4cHJlc3Npb24oKTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgcmVjdXJzaXZlbHkgZXZhbHVhdGUgdGhlIGV4cHJlc3Npb24gdHJlZVxuXHRcdCAqICBAcGFyYW0gICB7T2JqZWN0fSB0cmVlIFxuXHRcdCAqICBAcmV0dXJuICB7QXVkaW9Ob2RlfSAgICAgIHRoZSByZXN1bHRpbmcgYXVkaW8gbm9kZSBmcm9tIHRoZSBleHByZXNzaW9uXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLkV4cHIucHJvdG90eXBlLl9ldmFsID0gZnVuY3Rpb24gKHRyZWUpIHtcblx0ICAgICAgICBpZiAoIVRvbmUuaXNVbmRlZih0cmVlKSkge1xuXHQgICAgICAgICAgICB2YXIgbm9kZSA9IHRyZWUubWV0aG9kKHRyZWUuYXJncywgdGhpcyk7XG5cdCAgICAgICAgICAgIHRoaXMuX25vZGVzLnB1c2gobm9kZSk7XG5cdCAgICAgICAgICAgIHJldHVybiBub2RlO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgZGlzcG9zZSBhbGwgdGhlIG5vZGVzXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLkV4cHIucHJvdG90eXBlLl9kaXNwb3NlTm9kZXMgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9ub2Rlcy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMuX25vZGVzW2ldO1xuXHQgICAgICAgICAgICBpZiAoVG9uZS5pc0Z1bmN0aW9uKG5vZGUuZGlzcG9zZSkpIHtcblx0ICAgICAgICAgICAgICAgIG5vZGUuZGlzcG9zZSgpO1xuXHQgICAgICAgICAgICB9IGVsc2UgaWYgKFRvbmUuaXNGdW5jdGlvbihub2RlLmRpc2Nvbm5lY3QpKSB7XG5cdCAgICAgICAgICAgICAgICBub2RlLmRpc2Nvbm5lY3QoKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBub2RlID0gbnVsbDtcblx0ICAgICAgICAgICAgdGhpcy5fbm9kZXNbaV0gPSBudWxsO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB0aGlzLl9ub2RlcyA9IG51bGw7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIGNsZWFuIHVwXG5cdFx0ICovXG5cdCAgICBUb25lLkV4cHIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5TaWduYWxCYXNlLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgdGhpcy5fZGlzcG9zZU5vZGVzKCk7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuRXhwcjtcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgXG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzIENvbnZlcnQgYW4gaW5jb21pbmcgc2lnbmFsIGJldHdlZW4gMCwgMSB0byBhbiBlcXVhbCBwb3dlciBnYWluIHNjYWxlLlxuXHRcdCAqXG5cdFx0ICogIEBleHRlbmRzIHtUb25lLlNpZ25hbEJhc2V9XG5cdFx0ICogIEBjb25zdHJ1Y3RvclxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIHZhciBlcVBvd0dhaW4gPSBuZXcgVG9uZS5FcXVhbFBvd2VyR2FpbigpO1xuXHRcdCAqL1xuXHQgICAgVG9uZS5FcXVhbFBvd2VyR2FpbiA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLlNpZ25hbEJhc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5XYXZlU2hhcGVyfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9lcVBvd2VyID0gdGhpcy5pbnB1dCA9IHRoaXMub3V0cHV0ID0gbmV3IFRvbmUuV2F2ZVNoYXBlcihmdW5jdGlvbiAodmFsKSB7XG5cdCAgICAgICAgICAgIGlmIChNYXRoLmFicyh2YWwpIDwgMC4wMDEpIHtcblx0ICAgICAgICAgICAgICAgIC8vc2hvdWxkIG91dHB1dCAwIHdoZW4gaW5wdXQgaXMgMFxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIDA7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gVG9uZS5lcXVhbFBvd2VyU2NhbGUodmFsKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0uYmluZCh0aGlzKSwgNDA5Nik7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5FcXVhbFBvd2VyR2FpbiwgVG9uZS5TaWduYWxCYXNlKTtcblx0ICAgIC8qKlxuXHRcdCAqICBjbGVhbiB1cFxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5FcXVhbFBvd2VyR2Fpbn0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5FcXVhbFBvd2VyR2Fpbi5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLlNpZ25hbEJhc2UucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLl9lcVBvd2VyLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9lcVBvd2VyID0gbnVsbDtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVG9uZS5FcXVhbFBvd2VyR2Fpbjtcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgXG5cdCAgICAvKipcblx0XHQgKiBAY2xhc3MgIFRvbmUuQ3Jvc3NmYWRlIHByb3ZpZGVzIGVxdWFsIHBvd2VyIGZhZGluZyBiZXR3ZWVuIHR3byBpbnB1dHMuXG5cdFx0ICogICAgICAgICBNb3JlIG9uIGNyb3NzZmFkaW5nIHRlY2huaXF1ZSBbaGVyZV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRmFkZV8oYXVkaW9fZW5naW5lZXJpbmcpI0Nyb3NzZmFkaW5nKS5cblx0XHQgKlxuXHRcdCAqIEBjb25zdHJ1Y3RvclxuXHRcdCAqIEBleHRlbmRzIHtUb25lLkF1ZGlvTm9kZX1cblx0XHQgKiBAcGFyYW0ge05vcm1hbFJhbmdlfSBbaW5pdGlhbEZhZGU9MC41XVxuXHRcdCAqIEBleGFtcGxlXG5cdFx0ICogdmFyIGNyb3NzRmFkZSA9IG5ldyBUb25lLkNyb3NzRmFkZSgwLjUpO1xuXHRcdCAqIC8vY29ubmVjdCBlZmZlY3QgQSB0byBjcm9zc2ZhZGUgZnJvbVxuXHRcdCAqIC8vZWZmZWN0IG91dHB1dCAwIHRvIGNyb3NzZmFkZSBpbnB1dCAwXG5cdFx0ICogZWZmZWN0QS5jb25uZWN0KGNyb3NzRmFkZSwgMCwgMCk7XG5cdFx0ICogLy9jb25uZWN0IGVmZmVjdCBCIHRvIGNyb3NzZmFkZSBmcm9tXG5cdFx0ICogLy9lZmZlY3Qgb3V0cHV0IDAgdG8gY3Jvc3NmYWRlIGlucHV0IDFcblx0XHQgKiBlZmZlY3RCLmNvbm5lY3QoY3Jvc3NGYWRlLCAwLCAxKTtcblx0XHQgKiBjcm9zc0ZhZGUuZmFkZS52YWx1ZSA9IDA7XG5cdFx0ICogLy8gXiBvbmx5IGVmZmVjdEEgaXMgb3V0cHV0XG5cdFx0ICogY3Jvc3NGYWRlLmZhZGUudmFsdWUgPSAxO1xuXHRcdCAqIC8vIF4gb25seSBlZmZlY3RCIGlzIG91dHB1dFxuXHRcdCAqIGNyb3NzRmFkZS5mYWRlLnZhbHVlID0gMC41O1xuXHRcdCAqIC8vIF4gdGhlIHR3byBzaWduYWxzIGFyZSBtaXhlZCBlcXVhbGx5LlxuXHRcdCAqL1xuXHQgICAgVG9uZS5Dcm9zc0ZhZGUgPSBmdW5jdGlvbiAoaW5pdGlhbEZhZGUpIHtcblx0ICAgICAgICBUb25lLkF1ZGlvTm9kZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuY3JlYXRlSW5zT3V0cygyLCAxKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBBbGlhcyBmb3IgPGNvZGU+aW5wdXRbMF08L2NvZGU+LlxuXHRcdFx0ICogIEB0eXBlIHtUb25lLkdhaW59XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmEgPSB0aGlzLmlucHV0WzBdID0gbmV3IFRvbmUuR2FpbigpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIEFsaWFzIGZvciA8Y29kZT5pbnB1dFsxXTwvY29kZT4uXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuR2Fpbn1cblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuYiA9IHRoaXMuaW5wdXRbMV0gPSBuZXcgVG9uZS5HYWluKCk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiBcdFRoZSBtaXggYmV0d2VlbiB0aGUgdHdvIGlucHV0cy4gQSBmYWRlIHZhbHVlIG9mIDBcblx0XHRcdCAqIFx0d2lsbCBvdXRwdXQgMTAwJSA8Y29kZT5pbnB1dFswXTwvY29kZT4gYW5kXG5cdFx0XHQgKiBcdGEgdmFsdWUgb2YgMSB3aWxsIG91dHB1dCAxMDAlIDxjb2RlPmlucHV0WzFdPC9jb2RlPi5cblx0XHRcdCAqICBAdHlwZSB7Tm9ybWFsUmFuZ2V9XG5cdFx0XHQgKiAgQHNpZ25hbFxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5mYWRlID0gbmV3IFRvbmUuU2lnbmFsKFRvbmUuZGVmYXVsdEFyZyhpbml0aWFsRmFkZSwgMC41KSwgVG9uZS5UeXBlLk5vcm1hbFJhbmdlKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBlcXVhbCBwb3dlciBnYWluIGNyb3NzIGZhZGVcblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICogIEB0eXBlIHtUb25lLkVxdWFsUG93ZXJHYWlufVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fZXF1YWxQb3dlckEgPSBuZXcgVG9uZS5FcXVhbFBvd2VyR2FpbigpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIGVxdWFsIHBvd2VyIGdhaW4gY3Jvc3MgZmFkZVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuRXF1YWxQb3dlckdhaW59XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9lcXVhbFBvd2VyQiA9IG5ldyBUb25lLkVxdWFsUG93ZXJHYWluKCk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgaW52ZXJ0IHRoZSBpbmNvbWluZyBzaWduYWxcblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICogIEB0eXBlIHtUb25lfVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5faW52ZXJ0ID0gbmV3IFRvbmUuRXhwcignMSAtICQwJyk7XG5cdCAgICAgICAgLy9jb25uZWN0aW9uc1xuXHQgICAgICAgIHRoaXMuYS5jb25uZWN0KHRoaXMub3V0cHV0KTtcblx0ICAgICAgICB0aGlzLmIuY29ubmVjdCh0aGlzLm91dHB1dCk7XG5cdCAgICAgICAgdGhpcy5mYWRlLmNoYWluKHRoaXMuX2VxdWFsUG93ZXJCLCB0aGlzLmIuZ2Fpbik7XG5cdCAgICAgICAgdGhpcy5mYWRlLmNoYWluKHRoaXMuX2ludmVydCwgdGhpcy5fZXF1YWxQb3dlckEsIHRoaXMuYS5nYWluKTtcblx0ICAgICAgICB0aGlzLl9yZWFkT25seSgnZmFkZScpO1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuQ3Jvc3NGYWRlLCBUb25lLkF1ZGlvTm9kZSk7XG5cdCAgICAvKipcblx0XHQgKiAgY2xlYW4gdXBcblx0XHQgKiAgQHJldHVybnMge1RvbmUuQ3Jvc3NGYWRlfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkNyb3NzRmFkZS5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLkF1ZGlvTm9kZS5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuX3dyaXRhYmxlKCdmYWRlJyk7XG5cdCAgICAgICAgdGhpcy5fZXF1YWxQb3dlckEuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX2VxdWFsUG93ZXJBID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9lcXVhbFBvd2VyQi5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fZXF1YWxQb3dlckIgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuZmFkZS5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5mYWRlID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9pbnZlcnQuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX2ludmVydCA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5hLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLmEgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuYi5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5iID0gbnVsbDtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVG9uZS5Dcm9zc0ZhZGU7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyAgVG9uZS5GaWx0ZXIgaXMgYSBmaWx0ZXIgd2hpY2ggYWxsb3dzIGZvciBhbGwgb2YgdGhlIHNhbWUgbmF0aXZlIG1ldGhvZHNcblx0XHQgKiAgICAgICAgICBhcyB0aGUgW0JpcXVhZEZpbHRlck5vZGVdKGh0dHA6Ly93ZWJhdWRpby5naXRodWIuaW8vd2ViLWF1ZGlvLWFwaS8jdGhlLWJpcXVhZGZpbHRlcm5vZGUtaW50ZXJmYWNlKS5cblx0XHQgKiAgICAgICAgICBUb25lLkZpbHRlciBoYXMgdGhlIGFkZGVkIGFiaWxpdHkgdG8gc2V0IHRoZSBmaWx0ZXIgcm9sbG9mZiBhdCAtMTJcblx0XHQgKiAgICAgICAgICAoZGVmYXVsdCksIC0yNCBhbmQgLTQ4LlxuXHRcdCAqXG5cdFx0ICogIEBjb25zdHJ1Y3RvclxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZS5BdWRpb05vZGV9XG5cdFx0ICogIEBwYXJhbSB7RnJlcXVlbmN5fE9iamVjdH0gW2ZyZXF1ZW5jeV0gVGhlIGN1dG9mZiBmcmVxdWVuY3kgb2YgdGhlIGZpbHRlci5cblx0XHQgKiAgQHBhcmFtIHtzdHJpbmc9fSB0eXBlIFRoZSB0eXBlIG9mIGZpbHRlci5cblx0XHQgKiAgQHBhcmFtIHtudW1iZXI9fSByb2xsb2ZmIFRoZSBkcm9wIGluIGRlY2liZWxzIHBlciBvY3RhdmUgYWZ0ZXIgdGhlIGN1dG9mZiBmcmVxdWVuY3kuXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgMyBjaG9pY2VzOiAtMTIsIC0yNCwgYW5kIC00OFxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICB2YXIgZmlsdGVyID0gbmV3IFRvbmUuRmlsdGVyKDIwMCwgXCJoaWdocGFzc1wiKTtcblx0XHQgKi9cblx0ICAgIFRvbmUuRmlsdGVyID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBvcHRpb25zID0gVG9uZS5kZWZhdWx0cyhhcmd1bWVudHMsIFtcblx0ICAgICAgICAgICAgJ2ZyZXF1ZW5jeScsXG5cdCAgICAgICAgICAgICd0eXBlJyxcblx0ICAgICAgICAgICAgJ3JvbGxvZmYnXG5cdCAgICAgICAgXSwgVG9uZS5GaWx0ZXIpO1xuXHQgICAgICAgIFRvbmUuQXVkaW9Ob2RlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgdGhpcy5jcmVhdGVJbnNPdXRzKDEsIDEpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHRoZSBmaWx0ZXIocylcblx0XHRcdCAqICBAdHlwZSB7QXJyYXl9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2ZpbHRlcnMgPSBbXTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgY3V0b2ZmIGZyZXF1ZW5jeSBvZiB0aGUgZmlsdGVyLlxuXHRcdFx0ICogIEB0eXBlIHtGcmVxdWVuY3l9XG5cdFx0XHQgKiAgQHNpZ25hbFxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5mcmVxdWVuY3kgPSBuZXcgVG9uZS5TaWduYWwob3B0aW9ucy5mcmVxdWVuY3ksIFRvbmUuVHlwZS5GcmVxdWVuY3kpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBkZXR1bmUgcGFyYW1ldGVyXG5cdFx0XHQgKiAgQHR5cGUge0NlbnRzfVxuXHRcdFx0ICogIEBzaWduYWxcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuZGV0dW5lID0gbmV3IFRvbmUuU2lnbmFsKDAsIFRvbmUuVHlwZS5DZW50cyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGdhaW4gb2YgdGhlIGZpbHRlciwgb25seSB1c2VkIGluIGNlcnRhaW4gZmlsdGVyIHR5cGVzXG5cdFx0XHQgKiAgQHR5cGUge051bWJlcn1cblx0XHRcdCAqICBAc2lnbmFsXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmdhaW4gPSBuZXcgVG9uZS5TaWduYWwoe1xuXHQgICAgICAgICAgICAndmFsdWUnOiBvcHRpb25zLmdhaW4sXG5cdCAgICAgICAgICAgICdjb252ZXJ0JzogZmFsc2Vcblx0ICAgICAgICB9KTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgUSBvciBRdWFsaXR5IG9mIHRoZSBmaWx0ZXJcblx0XHRcdCAqICBAdHlwZSB7UG9zaXRpdmV9XG5cdFx0XHQgKiAgQHNpZ25hbFxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5RID0gbmV3IFRvbmUuU2lnbmFsKG9wdGlvbnMuUSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgdGhlIHR5cGUgb2YgdGhlIGZpbHRlclxuXHRcdFx0ICogIEB0eXBlIHtzdHJpbmd9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX3R5cGUgPSBvcHRpb25zLnR5cGU7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgdGhlIHJvbGxvZmYgdmFsdWUgb2YgdGhlIGZpbHRlclxuXHRcdFx0ICogIEB0eXBlIHtudW1iZXJ9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX3JvbGxvZmYgPSBvcHRpb25zLnJvbGxvZmY7XG5cdCAgICAgICAgLy9zZXQgdGhlIHJvbGxvZmY7XG5cdCAgICAgICAgdGhpcy5yb2xsb2ZmID0gb3B0aW9ucy5yb2xsb2ZmO1xuXHQgICAgICAgIHRoaXMuX3JlYWRPbmx5KFtcblx0ICAgICAgICAgICAgJ2RldHVuZScsXG5cdCAgICAgICAgICAgICdmcmVxdWVuY3knLFxuXHQgICAgICAgICAgICAnZ2FpbicsXG5cdCAgICAgICAgICAgICdRJ1xuXHQgICAgICAgIF0pO1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuRmlsdGVyLCBUb25lLkF1ZGlvTm9kZSk7XG5cdCAgICAvKipcblx0XHQgKiAgdGhlIGRlZmF1bHQgcGFyYW1ldGVyc1xuXHRcdCAqXG5cdFx0ICogIEBzdGF0aWNcblx0XHQgKiAgQHR5cGUge09iamVjdH1cblx0XHQgKi9cblx0ICAgIFRvbmUuRmlsdGVyLmRlZmF1bHRzID0ge1xuXHQgICAgICAgICd0eXBlJzogJ2xvd3Bhc3MnLFxuXHQgICAgICAgICdmcmVxdWVuY3knOiAzNTAsXG5cdCAgICAgICAgJ3JvbGxvZmYnOiAtMTIsXG5cdCAgICAgICAgJ1EnOiAxLFxuXHQgICAgICAgICdnYWluJzogMFxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqIFRoZSB0eXBlIG9mIHRoZSBmaWx0ZXIuIFR5cGVzOiBcImxvd3Bhc3NcIiwgXCJoaWdocGFzc1wiLFxuXHRcdCAqIFwiYmFuZHBhc3NcIiwgXCJsb3dzaGVsZlwiLCBcImhpZ2hzaGVsZlwiLCBcIm5vdGNoXCIsIFwiYWxscGFzc1wiLCBvciBcInBlYWtpbmdcIi5cblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5GaWx0ZXIjXG5cdFx0ICogQHR5cGUge3N0cmluZ31cblx0XHQgKiBAbmFtZSB0eXBlXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5GaWx0ZXIucHJvdG90eXBlLCAndHlwZScsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3R5cGU7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uICh0eXBlKSB7XG5cdCAgICAgICAgICAgIHZhciB0eXBlcyA9IFtcblx0ICAgICAgICAgICAgICAgICdsb3dwYXNzJyxcblx0ICAgICAgICAgICAgICAgICdoaWdocGFzcycsXG5cdCAgICAgICAgICAgICAgICAnYmFuZHBhc3MnLFxuXHQgICAgICAgICAgICAgICAgJ2xvd3NoZWxmJyxcblx0ICAgICAgICAgICAgICAgICdoaWdoc2hlbGYnLFxuXHQgICAgICAgICAgICAgICAgJ25vdGNoJyxcblx0ICAgICAgICAgICAgICAgICdhbGxwYXNzJyxcblx0ICAgICAgICAgICAgICAgICdwZWFraW5nJ1xuXHQgICAgICAgICAgICBdO1xuXHQgICAgICAgICAgICBpZiAodHlwZXMuaW5kZXhPZih0eXBlKSA9PT0gLTEpIHtcblx0ICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RvbmUuRmlsdGVyOiBpbnZhbGlkIHR5cGUgJyArIHR5cGUpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHRoaXMuX3R5cGUgPSB0eXBlO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2ZpbHRlcnMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX2ZpbHRlcnNbaV0udHlwZSA9IHR5cGU7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqIFRoZSByb2xsb2ZmIG9mIHRoZSBmaWx0ZXIgd2hpY2ggaXMgdGhlIGRyb3AgaW4gZGJcblx0XHQgKiBwZXIgb2N0YXZlLiBJbXBsZW1lbnRlZCBpbnRlcm5hbGx5IGJ5IGNhc2NhZGluZyBmaWx0ZXJzLlxuXHRcdCAqIE9ubHkgYWNjZXB0cyB0aGUgdmFsdWVzIC0xMiwgLTI0LCAtNDggYW5kIC05Ni5cblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5GaWx0ZXIjXG5cdFx0ICogQHR5cGUge251bWJlcn1cblx0XHQgKiBAbmFtZSByb2xsb2ZmXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5GaWx0ZXIucHJvdG90eXBlLCAncm9sbG9mZicsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JvbGxvZmY7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChyb2xsb2ZmKSB7XG5cdCAgICAgICAgICAgIHJvbGxvZmYgPSBwYXJzZUludChyb2xsb2ZmLCAxMCk7XG5cdCAgICAgICAgICAgIHZhciBwb3NzaWJpbGl0aWVzID0gW1xuXHQgICAgICAgICAgICAgICAgLTEyLFxuXHQgICAgICAgICAgICAgICAgLTI0LFxuXHQgICAgICAgICAgICAgICAgLTQ4LFxuXHQgICAgICAgICAgICAgICAgLTk2XG5cdCAgICAgICAgICAgIF07XG5cdCAgICAgICAgICAgIHZhciBjYXNjYWRpbmdDb3VudCA9IHBvc3NpYmlsaXRpZXMuaW5kZXhPZihyb2xsb2ZmKTtcblx0ICAgICAgICAgICAgLy9jaGVjayB0aGUgcm9sbG9mZiBpcyB2YWxpZFxuXHQgICAgICAgICAgICBpZiAoY2FzY2FkaW5nQ291bnQgPT09IC0xKSB7XG5cdCAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVG9uZS5GaWx0ZXI6IHJvbGxvZmYgY2FuIG9ubHkgYmUgLTEyLCAtMjQsIC00OCBvciAtOTYnKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBjYXNjYWRpbmdDb3VudCArPSAxO1xuXHQgICAgICAgICAgICB0aGlzLl9yb2xsb2ZmID0gcm9sbG9mZjtcblx0ICAgICAgICAgICAgLy9maXJzdCBkaXNjb25uZWN0IHRoZSBmaWx0ZXJzIGFuZCB0aHJvdyB0aGVtIGF3YXlcblx0ICAgICAgICAgICAgdGhpcy5pbnB1dC5kaXNjb25uZWN0KCk7XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fZmlsdGVycy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fZmlsdGVyc1tpXS5kaXNjb25uZWN0KCk7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9maWx0ZXJzW2ldID0gbnVsbDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB0aGlzLl9maWx0ZXJzID0gbmV3IEFycmF5KGNhc2NhZGluZ0NvdW50KTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgY291bnQgPSAwOyBjb3VudCA8IGNhc2NhZGluZ0NvdW50OyBjb3VudCsrKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgZmlsdGVyID0gdGhpcy5jb250ZXh0LmNyZWF0ZUJpcXVhZEZpbHRlcigpO1xuXHQgICAgICAgICAgICAgICAgZmlsdGVyLnR5cGUgPSB0aGlzLl90eXBlO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5mcmVxdWVuY3kuY29ubmVjdChmaWx0ZXIuZnJlcXVlbmN5KTtcblx0ICAgICAgICAgICAgICAgIHRoaXMuZGV0dW5lLmNvbm5lY3QoZmlsdGVyLmRldHVuZSk7XG5cdCAgICAgICAgICAgICAgICB0aGlzLlEuY29ubmVjdChmaWx0ZXIuUSk7XG5cdCAgICAgICAgICAgICAgICB0aGlzLmdhaW4uY29ubmVjdChmaWx0ZXIuZ2Fpbik7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9maWx0ZXJzW2NvdW50XSA9IGZpbHRlcjtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAvL2Nvbm5lY3QgdGhlbSB1cFxuXHQgICAgICAgICAgICB2YXIgY29ubmVjdGlvbkNoYWluID0gW3RoaXMuaW5wdXRdLmNvbmNhdCh0aGlzLl9maWx0ZXJzKS5jb25jYXQoW3RoaXMub3V0cHV0XSk7XG5cdCAgICAgICAgICAgIFRvbmUuY29ubmVjdFNlcmllcy5hcHBseShUb25lLCBjb25uZWN0aW9uQ2hhaW4pO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIENsZWFuIHVwLlxuXHRcdCAqICBAcmV0dXJuIHtUb25lLkZpbHRlcn0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5GaWx0ZXIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5BdWRpb05vZGUucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2ZpbHRlcnMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgdGhpcy5fZmlsdGVyc1tpXS5kaXNjb25uZWN0KCk7XG5cdCAgICAgICAgICAgIHRoaXMuX2ZpbHRlcnNbaV0gPSBudWxsO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB0aGlzLl9maWx0ZXJzID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl93cml0YWJsZShbXG5cdCAgICAgICAgICAgICdkZXR1bmUnLFxuXHQgICAgICAgICAgICAnZnJlcXVlbmN5Jyxcblx0ICAgICAgICAgICAgJ2dhaW4nLFxuXHQgICAgICAgICAgICAnUSdcblx0ICAgICAgICBdKTtcblx0ICAgICAgICB0aGlzLmZyZXF1ZW5jeS5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5RLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLmZyZXF1ZW5jeSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5RID0gbnVsbDtcblx0ICAgICAgICB0aGlzLmRldHVuZS5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5kZXR1bmUgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuZ2Fpbi5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5nYWluID0gbnVsbDtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVG9uZS5GaWx0ZXI7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyBTcGxpdCB0aGUgaW5jb21pbmcgc2lnbmFsIGludG8gdGhyZWUgYmFuZHMgKGxvdywgbWlkLCBoaWdoKVxuXHRcdCAqICAgICAgICAgd2l0aCB0d28gY3Jvc3NvdmVyIGZyZXF1ZW5jeSBjb250cm9scy5cblx0XHQgKlxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZS5BdWRpb05vZGV9XG5cdFx0ICogIEBjb25zdHJ1Y3RvclxuXHRcdCAqICBAcGFyYW0ge0ZyZXF1ZW5jeXxPYmplY3R9IFtsb3dGcmVxdWVuY3ldIHRoZSBsb3cvbWlkIGNyb3Nzb3ZlciBmcmVxdWVuY3lcblx0XHQgKiAgQHBhcmFtIHtGcmVxdWVuY3l9IFtoaWdoRnJlcXVlbmN5XSB0aGUgbWlkL2hpZ2ggY3Jvc3NvdmVyIGZyZXF1ZW5jeVxuXHRcdCAqL1xuXHQgICAgVG9uZS5NdWx0aWJhbmRTcGxpdCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgb3B0aW9ucyA9IFRvbmUuZGVmYXVsdHMoYXJndW1lbnRzLCBbXG5cdCAgICAgICAgICAgICdsb3dGcmVxdWVuY3knLFxuXHQgICAgICAgICAgICAnaGlnaEZyZXF1ZW5jeSdcblx0ICAgICAgICBdLCBUb25lLk11bHRpYmFuZFNwbGl0KTtcblx0ICAgICAgICBUb25lLkF1ZGlvTm9kZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHRoZSBpbnB1dFxuXHRcdFx0ICogIEB0eXBlIHtUb25lLkdhaW59XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuaW5wdXQgPSBuZXcgVG9uZS5HYWluKCk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgdGhlIG91dHB1dHNcblx0XHRcdCAqICBAdHlwZSB7QXJyYXl9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMub3V0cHV0ID0gbmV3IEFycmF5KDMpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBsb3cgYmFuZC4gQWxpYXMgZm9yIDxjb2RlPm91dHB1dFswXTwvY29kZT5cblx0XHRcdCAqICBAdHlwZSB7VG9uZS5GaWx0ZXJ9XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmxvdyA9IHRoaXMub3V0cHV0WzBdID0gbmV3IFRvbmUuRmlsdGVyKDAsICdsb3dwYXNzJyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgdGhlIGxvd2VyIGZpbHRlciBvZiB0aGUgbWlkIGJhbmRcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5GaWx0ZXJ9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2xvd01pZEZpbHRlciA9IG5ldyBUb25lLkZpbHRlcigwLCAnaGlnaHBhc3MnKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgbWlkIGJhbmQgb3V0cHV0LiBBbGlhcyBmb3IgPGNvZGU+b3V0cHV0WzFdPC9jb2RlPlxuXHRcdFx0ICogIEB0eXBlIHtUb25lLkZpbHRlcn1cblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMubWlkID0gdGhpcy5vdXRwdXRbMV0gPSBuZXcgVG9uZS5GaWx0ZXIoMCwgJ2xvd3Bhc3MnKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgaGlnaCBiYW5kIG91dHB1dC4gQWxpYXMgZm9yIDxjb2RlPm91dHB1dFsyXTwvY29kZT5cblx0XHRcdCAqICBAdHlwZSB7VG9uZS5GaWx0ZXJ9XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmhpZ2ggPSB0aGlzLm91dHB1dFsyXSA9IG5ldyBUb25lLkZpbHRlcigwLCAnaGlnaHBhc3MnKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgbG93L21pZCBjcm9zc292ZXIgZnJlcXVlbmN5LlxuXHRcdFx0ICogIEB0eXBlIHtGcmVxdWVuY3l9XG5cdFx0XHQgKiAgQHNpZ25hbFxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5sb3dGcmVxdWVuY3kgPSBuZXcgVG9uZS5TaWduYWwob3B0aW9ucy5sb3dGcmVxdWVuY3ksIFRvbmUuVHlwZS5GcmVxdWVuY3kpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBtaWQvaGlnaCBjcm9zc292ZXIgZnJlcXVlbmN5LlxuXHRcdFx0ICogIEB0eXBlIHtGcmVxdWVuY3l9XG5cdFx0XHQgKiAgQHNpZ25hbFxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5oaWdoRnJlcXVlbmN5ID0gbmV3IFRvbmUuU2lnbmFsKG9wdGlvbnMuaGlnaEZyZXF1ZW5jeSwgVG9uZS5UeXBlLkZyZXF1ZW5jeSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIHF1YWxpdHkgb2YgYWxsIHRoZSBmaWx0ZXJzXG5cdFx0XHQgKiAgQHR5cGUge051bWJlcn1cblx0XHRcdCAqICBAc2lnbmFsXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLlEgPSBuZXcgVG9uZS5TaWduYWwob3B0aW9ucy5RKTtcblx0ICAgICAgICB0aGlzLmlucHV0LmZhbih0aGlzLmxvdywgdGhpcy5oaWdoKTtcblx0ICAgICAgICB0aGlzLmlucHV0LmNoYWluKHRoaXMuX2xvd01pZEZpbHRlciwgdGhpcy5taWQpO1xuXHQgICAgICAgIC8vdGhlIGZyZXF1ZW5jeSBjb250cm9sIHNpZ25hbFxuXHQgICAgICAgIHRoaXMubG93RnJlcXVlbmN5LmNvbm5lY3QodGhpcy5sb3cuZnJlcXVlbmN5KTtcblx0ICAgICAgICB0aGlzLmxvd0ZyZXF1ZW5jeS5jb25uZWN0KHRoaXMuX2xvd01pZEZpbHRlci5mcmVxdWVuY3kpO1xuXHQgICAgICAgIHRoaXMuaGlnaEZyZXF1ZW5jeS5jb25uZWN0KHRoaXMubWlkLmZyZXF1ZW5jeSk7XG5cdCAgICAgICAgdGhpcy5oaWdoRnJlcXVlbmN5LmNvbm5lY3QodGhpcy5oaWdoLmZyZXF1ZW5jeSk7XG5cdCAgICAgICAgLy90aGUgUSB2YWx1ZVxuXHQgICAgICAgIHRoaXMuUS5jb25uZWN0KHRoaXMubG93LlEpO1xuXHQgICAgICAgIHRoaXMuUS5jb25uZWN0KHRoaXMuX2xvd01pZEZpbHRlci5RKTtcblx0ICAgICAgICB0aGlzLlEuY29ubmVjdCh0aGlzLm1pZC5RKTtcblx0ICAgICAgICB0aGlzLlEuY29ubmVjdCh0aGlzLmhpZ2guUSk7XG5cdCAgICAgICAgdGhpcy5fcmVhZE9ubHkoW1xuXHQgICAgICAgICAgICAnaGlnaCcsXG5cdCAgICAgICAgICAgICdtaWQnLFxuXHQgICAgICAgICAgICAnbG93Jyxcblx0ICAgICAgICAgICAgJ2hpZ2hGcmVxdWVuY3knLFxuXHQgICAgICAgICAgICAnbG93RnJlcXVlbmN5J1xuXHQgICAgICAgIF0pO1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuTXVsdGliYW5kU3BsaXQsIFRvbmUuQXVkaW9Ob2RlKTtcblx0ICAgIC8qKlxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqICBAc3RhdGljXG5cdFx0ICogIEB0eXBlIHtPYmplY3R9XG5cdFx0ICovXG5cdCAgICBUb25lLk11bHRpYmFuZFNwbGl0LmRlZmF1bHRzID0ge1xuXHQgICAgICAgICdsb3dGcmVxdWVuY3knOiA0MDAsXG5cdCAgICAgICAgJ2hpZ2hGcmVxdWVuY3knOiAyNTAwLFxuXHQgICAgICAgICdRJzogMVxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBDbGVhbiB1cC5cblx0XHQgKiAgQHJldHVybnMge1RvbmUuTXVsdGliYW5kU3BsaXR9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuTXVsdGliYW5kU3BsaXQucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5BdWRpb05vZGUucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLl93cml0YWJsZShbXG5cdCAgICAgICAgICAgICdoaWdoJyxcblx0ICAgICAgICAgICAgJ21pZCcsXG5cdCAgICAgICAgICAgICdsb3cnLFxuXHQgICAgICAgICAgICAnaGlnaEZyZXF1ZW5jeScsXG5cdCAgICAgICAgICAgICdsb3dGcmVxdWVuY3knXG5cdCAgICAgICAgXSk7XG5cdCAgICAgICAgdGhpcy5sb3cuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMubG93ID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9sb3dNaWRGaWx0ZXIuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX2xvd01pZEZpbHRlciA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5taWQuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMubWlkID0gbnVsbDtcblx0ICAgICAgICB0aGlzLmhpZ2guZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuaGlnaCA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5sb3dGcmVxdWVuY3kuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMubG93RnJlcXVlbmN5ID0gbnVsbDtcblx0ICAgICAgICB0aGlzLmhpZ2hGcmVxdWVuY3kuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuaGlnaEZyZXF1ZW5jeSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5RLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLlEgPSBudWxsO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLk11bHRpYmFuZFNwbGl0O1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgVG9uZS5FUTMgaXMgYSB0aHJlZSBiYW5kIEVRIHdpdGggY29udHJvbCBvdmVyIGxvdywgbWlkLCBhbmQgaGlnaCBnYWluIGFzXG5cdFx0ICogICAgICAgICB3ZWxsIGFzIHRoZSBsb3cgYW5kIGhpZ2ggY3Jvc3NvdmVyIGZyZXF1ZW5jaWVzLlxuXHRcdCAqXG5cdFx0ICogIEBjb25zdHJ1Y3RvclxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZS5BdWRpb05vZGV9XG5cdFx0ICpcblx0XHQgKiAgQHBhcmFtIHtEZWNpYmVsc3xPYmplY3R9IFtsb3dMZXZlbF0gVGhlIGdhaW4gYXBwbGllZCB0byB0aGUgbG93cy5cblx0XHQgKiAgQHBhcmFtIHtEZWNpYmVsc30gW21pZExldmVsXSBUaGUgZ2FpbiBhcHBsaWVkIHRvIHRoZSBtaWQuXG5cdFx0ICogIEBwYXJhbSB7RGVjaWJlbHN9IFtoaWdoTGV2ZWxdIFRoZSBnYWluIGFwcGxpZWQgdG8gdGhlIGhpZ2guXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogdmFyIGVxID0gbmV3IFRvbmUuRVEzKC0xMCwgMywgLTIwKTtcblx0XHQgKi9cblx0ICAgIFRvbmUuRVEzID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBvcHRpb25zID0gVG9uZS5kZWZhdWx0cyhhcmd1bWVudHMsIFtcblx0ICAgICAgICAgICAgJ2xvdycsXG5cdCAgICAgICAgICAgICdtaWQnLFxuXHQgICAgICAgICAgICAnaGlnaCdcblx0ICAgICAgICBdLCBUb25lLkVRMyk7XG5cdCAgICAgICAgVG9uZS5BdWRpb05vZGUuY2FsbCh0aGlzKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICB0aGUgb3V0cHV0IG5vZGVcblx0XHRcdCAqICBAdHlwZSB7R2Fpbk5vZGV9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMub3V0cHV0ID0gbmV3IFRvbmUuR2FpbigpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHRoZSBtdWx0aWJhbmQgc3BsaXRcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5NdWx0aWJhbmRTcGxpdH1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fbXVsdGliYW5kU3BsaXQgPSB0aGlzLmlucHV0ID0gbmV3IFRvbmUuTXVsdGliYW5kU3BsaXQoe1xuXHQgICAgICAgICAgICAnbG93RnJlcXVlbmN5Jzogb3B0aW9ucy5sb3dGcmVxdWVuY3ksXG5cdCAgICAgICAgICAgICdoaWdoRnJlcXVlbmN5Jzogb3B0aW9ucy5oaWdoRnJlcXVlbmN5XG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGdhaW4gZm9yIHRoZSBsb3dlciBzaWduYWxzXG5cdFx0XHQgKiAgQHR5cGUgIHtUb25lLkdhaW59XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2xvd0dhaW4gPSBuZXcgVG9uZS5HYWluKG9wdGlvbnMubG93LCBUb25lLlR5cGUuRGVjaWJlbHMpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBnYWluIGZvciB0aGUgbWlkIHNpZ25hbHNcblx0XHRcdCAqICBAdHlwZSAge1RvbmUuR2Fpbn1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fbWlkR2FpbiA9IG5ldyBUb25lLkdhaW4ob3B0aW9ucy5taWQsIFRvbmUuVHlwZS5EZWNpYmVscyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiBUaGUgZ2FpbiBpbiBkZWNpYmVscyBvZiB0aGUgaGlnaCBwYXJ0XG5cdFx0XHQgKiBAdHlwZSB7VG9uZS5HYWlufVxuXHRcdFx0ICogQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2hpZ2hHYWluID0gbmV3IFRvbmUuR2FpbihvcHRpb25zLmhpZ2gsIFRvbmUuVHlwZS5EZWNpYmVscyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiBUaGUgZ2FpbiBpbiBkZWNpYmVscyBvZiB0aGUgbG93IHBhcnRcblx0XHRcdCAqIEB0eXBlIHtEZWNpYmVsc31cblx0XHRcdCAqIEBzaWduYWxcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMubG93ID0gdGhpcy5fbG93R2Fpbi5nYWluO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogVGhlIGdhaW4gaW4gZGVjaWJlbHMgb2YgdGhlIG1pZCBwYXJ0XG5cdFx0XHQgKiBAdHlwZSB7RGVjaWJlbHN9XG5cdFx0XHQgKiBAc2lnbmFsXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLm1pZCA9IHRoaXMuX21pZEdhaW4uZ2Fpbjtcblx0ICAgICAgICAvKipcblx0XHRcdCAqIFRoZSBnYWluIGluIGRlY2liZWxzIG9mIHRoZSBoaWdoIHBhcnRcblx0XHRcdCAqIEB0eXBlIHtEZWNpYmVsc31cblx0XHRcdCAqIEBzaWduYWxcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuaGlnaCA9IHRoaXMuX2hpZ2hHYWluLmdhaW47XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIFEgdmFsdWUgZm9yIGFsbCBvZiB0aGUgZmlsdGVycy5cblx0XHRcdCAqICBAdHlwZSB7UG9zaXRpdmV9XG5cdFx0XHQgKiAgQHNpZ25hbFxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5RID0gdGhpcy5fbXVsdGliYW5kU3BsaXQuUTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgbG93L21pZCBjcm9zc292ZXIgZnJlcXVlbmN5LlxuXHRcdFx0ICogIEB0eXBlIHtGcmVxdWVuY3l9XG5cdFx0XHQgKiAgQHNpZ25hbFxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5sb3dGcmVxdWVuY3kgPSB0aGlzLl9tdWx0aWJhbmRTcGxpdC5sb3dGcmVxdWVuY3k7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIG1pZC9oaWdoIGNyb3Nzb3ZlciBmcmVxdWVuY3kuXG5cdFx0XHQgKiAgQHR5cGUge0ZyZXF1ZW5jeX1cblx0XHRcdCAqICBAc2lnbmFsXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmhpZ2hGcmVxdWVuY3kgPSB0aGlzLl9tdWx0aWJhbmRTcGxpdC5oaWdoRnJlcXVlbmN5O1xuXHQgICAgICAgIC8vdGhlIGZyZXF1ZW5jeSBiYW5kc1xuXHQgICAgICAgIHRoaXMuX211bHRpYmFuZFNwbGl0Lmxvdy5jaGFpbih0aGlzLl9sb3dHYWluLCB0aGlzLm91dHB1dCk7XG5cdCAgICAgICAgdGhpcy5fbXVsdGliYW5kU3BsaXQubWlkLmNoYWluKHRoaXMuX21pZEdhaW4sIHRoaXMub3V0cHV0KTtcblx0ICAgICAgICB0aGlzLl9tdWx0aWJhbmRTcGxpdC5oaWdoLmNoYWluKHRoaXMuX2hpZ2hHYWluLCB0aGlzLm91dHB1dCk7XG5cdCAgICAgICAgdGhpcy5fcmVhZE9ubHkoW1xuXHQgICAgICAgICAgICAnbG93Jyxcblx0ICAgICAgICAgICAgJ21pZCcsXG5cdCAgICAgICAgICAgICdoaWdoJyxcblx0ICAgICAgICAgICAgJ2xvd0ZyZXF1ZW5jeScsXG5cdCAgICAgICAgICAgICdoaWdoRnJlcXVlbmN5J1xuXHQgICAgICAgIF0pO1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuRVEzLCBUb25lLkF1ZGlvTm9kZSk7XG5cdCAgICAvKipcblx0XHQgKiAgdGhlIGRlZmF1bHQgdmFsdWVzXG5cdFx0ICovXG5cdCAgICBUb25lLkVRMy5kZWZhdWx0cyA9IHtcblx0ICAgICAgICAnbG93JzogMCxcblx0ICAgICAgICAnbWlkJzogMCxcblx0ICAgICAgICAnaGlnaCc6IDAsXG5cdCAgICAgICAgJ2xvd0ZyZXF1ZW5jeSc6IDQwMCxcblx0ICAgICAgICAnaGlnaEZyZXF1ZW5jeSc6IDI1MDBcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgY2xlYW4gdXBcblx0XHQgKiAgQHJldHVybnMge1RvbmUuRVEzfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkVRMy5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLkF1ZGlvTm9kZS5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuX3dyaXRhYmxlKFtcblx0ICAgICAgICAgICAgJ2xvdycsXG5cdCAgICAgICAgICAgICdtaWQnLFxuXHQgICAgICAgICAgICAnaGlnaCcsXG5cdCAgICAgICAgICAgICdsb3dGcmVxdWVuY3knLFxuXHQgICAgICAgICAgICAnaGlnaEZyZXF1ZW5jeSdcblx0ICAgICAgICBdKTtcblx0ICAgICAgICB0aGlzLl9tdWx0aWJhbmRTcGxpdC5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fbXVsdGliYW5kU3BsaXQgPSBudWxsO1xuXHQgICAgICAgIHRoaXMubG93RnJlcXVlbmN5ID0gbnVsbDtcblx0ICAgICAgICB0aGlzLmhpZ2hGcmVxdWVuY3kgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX2xvd0dhaW4uZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX2xvd0dhaW4gPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX21pZEdhaW4uZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX21pZEdhaW4gPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX2hpZ2hHYWluLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9oaWdoR2FpbiA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5sb3cgPSBudWxsO1xuXHQgICAgICAgIHRoaXMubWlkID0gbnVsbDtcblx0ICAgICAgICB0aGlzLmhpZ2ggPSBudWxsO1xuXHQgICAgICAgIHRoaXMuUSA9IG51bGw7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuRVEzO1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgIFBlcmZvcm1zIGEgbGluZWFyIHNjYWxpbmcgb24gYW4gaW5wdXQgc2lnbmFsLlxuXHRcdCAqICAgICAgICAgIFNjYWxlcyBhIE5vcm1hbFJhbmdlIGlucHV0IHRvIGJldHdlZW5cblx0XHQgKiAgICAgICAgICBvdXRwdXRNaW4gYW5kIG91dHB1dE1heC5cblx0XHQgKlxuXHRcdCAqICBAY29uc3RydWN0b3Jcblx0XHQgKiAgQGV4dGVuZHMge1RvbmUuU2lnbmFsQmFzZX1cblx0XHQgKiAgQHBhcmFtIHtudW1iZXJ9IFtvdXRwdXRNaW49MF0gVGhlIG91dHB1dCB2YWx1ZSB3aGVuIHRoZSBpbnB1dCBpcyAwLiBcblx0XHQgKiAgQHBhcmFtIHtudW1iZXJ9IFtvdXRwdXRNYXg9MV1cdFRoZSBvdXRwdXQgdmFsdWUgd2hlbiB0aGUgaW5wdXQgaXMgMS4gXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogdmFyIHNjYWxlID0gbmV3IFRvbmUuU2NhbGUoNTAsIDEwMCk7XG5cdFx0ICogdmFyIHNpZ25hbCA9IG5ldyBUb25lLlNpZ25hbCgwLjUpLmNvbm5lY3Qoc2NhbGUpO1xuXHRcdCAqIC8vdGhlIG91dHB1dCBvZiBzY2FsZSBlcXVhbHMgNzVcblx0XHQgKi9cblx0ICAgIFRvbmUuU2NhbGUgPSBmdW5jdGlvbiAob3V0cHV0TWluLCBvdXRwdXRNYXgpIHtcblx0ICAgICAgICBUb25lLlNpZ25hbEJhc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICAvKiogXG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqICBAdHlwZSB7bnVtYmVyfVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fb3V0cHV0TWluID0gVG9uZS5kZWZhdWx0QXJnKG91dHB1dE1pbiwgMCk7XG5cdCAgICAgICAgLyoqIFxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKiAgQHR5cGUge251bWJlcn1cblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX291dHB1dE1heCA9IFRvbmUuZGVmYXVsdEFyZyhvdXRwdXRNYXgsIDEpO1xuXHQgICAgICAgIC8qKiBcblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICogIEB0eXBlIHtUb25lLk11bHRpcGx5fVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9zY2FsZSA9IHRoaXMuaW5wdXQgPSBuZXcgVG9uZS5NdWx0aXBseSgxKTtcblx0ICAgICAgICAvKiogXG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5BZGR9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2FkZCA9IHRoaXMub3V0cHV0ID0gbmV3IFRvbmUuQWRkKDApO1xuXHQgICAgICAgIHRoaXMuX3NjYWxlLmNvbm5lY3QodGhpcy5fYWRkKTtcblx0ICAgICAgICB0aGlzLl9zZXRSYW5nZSgpO1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuU2NhbGUsIFRvbmUuU2lnbmFsQmFzZSk7XG5cdCAgICAvKipcblx0XHQgKiBUaGUgbWluaW11bSBvdXRwdXQgdmFsdWUuIFRoaXMgbnVtYmVyIGlzIG91dHB1dCB3aGVuIFxuXHRcdCAqIHRoZSB2YWx1ZSBpbnB1dCB2YWx1ZSBpcyAwLiBcblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5TY2FsZSNcblx0XHQgKiBAdHlwZSB7bnVtYmVyfVxuXHRcdCAqIEBuYW1lIG1pblxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuU2NhbGUucHJvdG90eXBlLCAnbWluJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fb3V0cHV0TWluO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAobWluKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX291dHB1dE1pbiA9IG1pbjtcblx0ICAgICAgICAgICAgdGhpcy5fc2V0UmFuZ2UoKTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqIFRoZSBtYXhpbXVtIG91dHB1dCB2YWx1ZS4gVGhpcyBudW1iZXIgaXMgb3V0cHV0IHdoZW4gXG5cdFx0ICogdGhlIHZhbHVlIGlucHV0IHZhbHVlIGlzIDEuIFxuXHRcdCAqIEBtZW1iZXJPZiBUb25lLlNjYWxlI1xuXHRcdCAqIEB0eXBlIHtudW1iZXJ9XG5cdFx0ICogQG5hbWUgbWF4XG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5TY2FsZS5wcm90b3R5cGUsICdtYXgnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9vdXRwdXRNYXg7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChtYXgpIHtcblx0ICAgICAgICAgICAgdGhpcy5fb3V0cHV0TWF4ID0gbWF4O1xuXHQgICAgICAgICAgICB0aGlzLl9zZXRSYW5nZSgpO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIHNldCB0aGUgdmFsdWVzXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLlNjYWxlLnByb3RvdHlwZS5fc2V0UmFuZ2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdGhpcy5fYWRkLnZhbHVlID0gdGhpcy5fb3V0cHV0TWluO1xuXHQgICAgICAgIHRoaXMuX3NjYWxlLnZhbHVlID0gdGhpcy5fb3V0cHV0TWF4IC0gdGhpcy5fb3V0cHV0TWluO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBDbGVhbiB1cC5cblx0XHQgKiAgQHJldHVybnMge1RvbmUuU2NhbGV9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuU2NhbGUucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5TaWduYWxCYXNlLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgdGhpcy5fYWRkLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9hZGQgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX3NjYWxlLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9zY2FsZSA9IG51bGw7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuU2NhbGU7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgIFBlcmZvcm1zIGFuIGV4cG9uZW50aWFsIHNjYWxpbmcgb24gYW4gaW5wdXQgc2lnbmFsLlxuXHRcdCAqICAgICAgICAgIFNjYWxlcyBhIE5vcm1hbFJhbmdlIHZhbHVlIFswLDFdIGV4cG9uZW50aWFsbHlcblx0XHQgKiAgICAgICAgICB0byB0aGUgb3V0cHV0IHJhbmdlIG9mIG91dHB1dE1pbiB0byBvdXRwdXRNYXguXG5cdFx0ICpcblx0XHQgKiAgQGNvbnN0cnVjdG9yXG5cdFx0ICogIEBleHRlbmRzIHtUb25lLlNpZ25hbEJhc2V9XG5cdFx0ICogIEBwYXJhbSB7bnVtYmVyfSBbb3V0cHV0TWluPTBdIFRoZSBvdXRwdXQgdmFsdWUgd2hlbiB0aGUgaW5wdXQgaXMgMC4gXG5cdFx0ICogIEBwYXJhbSB7bnVtYmVyfSBbb3V0cHV0TWF4PTFdXHRUaGUgb3V0cHV0IHZhbHVlIHdoZW4gdGhlIGlucHV0IGlzIDEuIFxuXHRcdCAqICBAcGFyYW0ge251bWJlcn0gW2V4cG9uZW50PTJdIFRoZSBleHBvbmVudCB3aGljaCBzY2FsZXMgdGhlIGluY29taW5nIHNpZ25hbC5cblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiB2YXIgc2NhbGVFeHAgPSBuZXcgVG9uZS5TY2FsZUV4cCgwLCAxMDAsIDIpO1xuXHRcdCAqIHZhciBzaWduYWwgPSBuZXcgVG9uZS5TaWduYWwoMC41KS5jb25uZWN0KHNjYWxlRXhwKTtcblx0XHQgKi9cblx0ICAgIFRvbmUuU2NhbGVFeHAgPSBmdW5jdGlvbiAob3V0cHV0TWluLCBvdXRwdXRNYXgsIGV4cG9uZW50KSB7XG5cdCAgICAgICAgVG9uZS5TaWduYWxCYXNlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgc2NhbGUgdGhlIGlucHV0IHRvIHRoZSBvdXRwdXQgcmFuZ2Vcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5TY2FsZX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fc2NhbGUgPSB0aGlzLm91dHB1dCA9IG5ldyBUb25lLlNjYWxlKG91dHB1dE1pbiwgb3V0cHV0TWF4KTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICogIEB0eXBlIHtUb25lLlBvd31cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fZXhwID0gdGhpcy5pbnB1dCA9IG5ldyBUb25lLlBvdyhUb25lLmRlZmF1bHRBcmcoZXhwb25lbnQsIDIpKTtcblx0ICAgICAgICB0aGlzLl9leHAuY29ubmVjdCh0aGlzLl9zY2FsZSk7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5TY2FsZUV4cCwgVG9uZS5TaWduYWxCYXNlKTtcblx0ICAgIC8qKlxuXHRcdCAqIEluc3RlYWQgb2YgaW50ZXJwb2xhdGluZyBsaW5lYXJseSBiZXR3ZWVuIHRoZSA8Y29kZT5taW48L2NvZGU+IGFuZCBcblx0XHQgKiA8Y29kZT5tYXg8L2NvZGU+IHZhbHVlcywgc2V0dGluZyB0aGUgZXhwb25lbnQgd2lsbCBpbnRlcnBvbGF0ZSBiZXR3ZWVuXG5cdFx0ICogdGhlIHR3byB2YWx1ZXMgd2l0aCBhbiBleHBvbmVudGlhbCBjdXJ2ZS4gXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuU2NhbGVFeHAjXG5cdFx0ICogQHR5cGUge251bWJlcn1cblx0XHQgKiBAbmFtZSBleHBvbmVudFxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuU2NhbGVFeHAucHJvdG90eXBlLCAnZXhwb25lbnQnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9leHAudmFsdWU7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChleHApIHtcblx0ICAgICAgICAgICAgdGhpcy5fZXhwLnZhbHVlID0gZXhwO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogVGhlIG1pbmltdW0gb3V0cHV0IHZhbHVlLiBUaGlzIG51bWJlciBpcyBvdXRwdXQgd2hlbiBcblx0XHQgKiB0aGUgdmFsdWUgaW5wdXQgdmFsdWUgaXMgMC4gXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuU2NhbGVFeHAjXG5cdFx0ICogQHR5cGUge251bWJlcn1cblx0XHQgKiBAbmFtZSBtaW5cblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLlNjYWxlRXhwLnByb3RvdHlwZSwgJ21pbicsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NjYWxlLm1pbjtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKG1pbikge1xuXHQgICAgICAgICAgICB0aGlzLl9zY2FsZS5taW4gPSBtaW47XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiBUaGUgbWF4aW11bSBvdXRwdXQgdmFsdWUuIFRoaXMgbnVtYmVyIGlzIG91dHB1dCB3aGVuIFxuXHRcdCAqIHRoZSB2YWx1ZSBpbnB1dCB2YWx1ZSBpcyAxLiBcblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5TY2FsZUV4cCNcblx0XHQgKiBAdHlwZSB7bnVtYmVyfVxuXHRcdCAqIEBuYW1lIG1heFxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuU2NhbGVFeHAucHJvdG90eXBlLCAnbWF4Jywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fc2NhbGUubWF4O1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAobWF4KSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3NjYWxlLm1heCA9IG1heDtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBDbGVhbiB1cC5cblx0XHQgKiAgQHJldHVybnMge1RvbmUuU2NhbGVFeHB9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuU2NhbGVFeHAucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5TaWduYWxCYXNlLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgdGhpcy5fc2NhbGUuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX3NjYWxlID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9leHAuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX2V4cCA9IG51bGw7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuU2NhbGVFeHA7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIGNyZWF0ZURlbGF5IHNoaW1cblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIGlmICh3aW5kb3cuRGVsYXlOb2RlICYmICFBdWRpb0NvbnRleHQucHJvdG90eXBlLmNyZWF0ZURlbGF5KSB7XG5cdCAgICAgICAgQXVkaW9Db250ZXh0LnByb3RvdHlwZS5jcmVhdGVEZWxheSA9IEF1ZGlvQ29udGV4dC5wcm90b3R5cGUuY3JlYXRlRGVsYXlOb2RlO1xuXHQgICAgfVxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyBXcmFwcGVyIGFyb3VuZCBXZWIgQXVkaW8ncyBuYXRpdmUgW0RlbGF5Tm9kZV0oaHR0cDovL3dlYmF1ZGlvLmdpdGh1Yi5pby93ZWItYXVkaW8tYXBpLyN0aGUtZGVsYXlub2RlLWludGVyZmFjZSkuXG5cdFx0ICogIEBleHRlbmRzIHtUb25lfVxuXHRcdCAqICBAcGFyYW0ge1RpbWU9fSBkZWxheVRpbWUgVGhlIGRlbGF5IGFwcGxpZWQgdG8gdGhlIGluY29taW5nIHNpZ25hbC5cblx0XHQgKiAgQHBhcmFtIHtUaW1lPX0gbWF4RGVsYXkgVGhlIG1heGltdW0gZGVsYXkgdGltZS5cblx0XHQgKi9cblx0ICAgIFRvbmUuRGVsYXkgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIG9wdGlvbnMgPSBUb25lLmRlZmF1bHRzKGFyZ3VtZW50cywgW1xuXHQgICAgICAgICAgICAnZGVsYXlUaW1lJyxcblx0ICAgICAgICAgICAgJ21heERlbGF5J1xuXHQgICAgICAgIF0sIFRvbmUuRGVsYXkpO1xuXHQgICAgICAgIFRvbmUuQXVkaW9Ob2RlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIG5hdGl2ZSBkZWxheSBub2RlXG5cdFx0XHQgKiAgQHR5cGUge0RlbGF5Tm9kZX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fZGVsYXlOb2RlID0gdGhpcy5pbnB1dCA9IHRoaXMub3V0cHV0ID0gdGhpcy5jb250ZXh0LmNyZWF0ZURlbGF5KHRoaXMudG9TZWNvbmRzKG9wdGlvbnMubWF4RGVsYXkpKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgYW1vdW50IG9mIHRpbWUgdGhlIGluY29taW5nIHNpZ25hbCBpc1xuXHRcdFx0ICogIGRlbGF5ZWQuXG5cdFx0XHQgKiAgQHR5cGUge1RpbWV9XG5cdFx0XHQgKiAgQHNpZ25hbFxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5kZWxheVRpbWUgPSBuZXcgVG9uZS5QYXJhbSh7XG5cdCAgICAgICAgICAgICdwYXJhbSc6IHRoaXMuX2RlbGF5Tm9kZS5kZWxheVRpbWUsXG5cdCAgICAgICAgICAgICd1bml0cyc6IFRvbmUuVHlwZS5UaW1lLFxuXHQgICAgICAgICAgICAndmFsdWUnOiBvcHRpb25zLmRlbGF5VGltZVxuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIHRoaXMuX3JlYWRPbmx5KCdkZWxheVRpbWUnKTtcblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLkRlbGF5LCBUb25lLkF1ZGlvTm9kZSk7XG5cdCAgICAvKipcblx0XHQgKiAgVGhlIGRlZmF1bHRzXG5cdFx0ICogIEBjb25zdFxuXHRcdCAqICBAdHlwZSAge09iamVjdH1cblx0XHQgKi9cblx0ICAgIFRvbmUuRGVsYXkuZGVmYXVsdHMgPSB7XG5cdCAgICAgICAgJ21heERlbGF5JzogMSxcblx0ICAgICAgICAnZGVsYXlUaW1lJzogMFxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBDbGVhbiB1cC5cblx0XHQgKiAgQHJldHVybiAge1RvbmUuRGVsYXl9ICB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkRlbGF5LnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuQXVkaW9Ob2RlLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgdGhpcy5fZGVsYXlOb2RlLmRpc2Nvbm5lY3QoKTtcblx0ICAgICAgICB0aGlzLl9kZWxheU5vZGUgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX3dyaXRhYmxlKCdkZWxheVRpbWUnKTtcblx0ICAgICAgICB0aGlzLmRlbGF5VGltZSA9IG51bGw7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuRGVsYXk7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyBDb21iIGZpbHRlcnMgYXJlIGJhc2ljIGJ1aWxkaW5nIGJsb2NrcyBmb3IgcGh5c2ljYWwgbW9kZWxpbmcuIFJlYWQgbW9yZVxuXHRcdCAqICAgICAgICAgYWJvdXQgY29tYiBmaWx0ZXJzIG9uIFtDQ1JNQSdzIHdlYnNpdGVdKGh0dHBzOi8vY2NybWEuc3RhbmZvcmQuZWR1L35qb3MvcGFzcC9GZWVkYmFja19Db21iX0ZpbHRlcnMuaHRtbCkuXG5cdFx0ICpcblx0XHQgKiAgQGV4dGVuZHMge1RvbmUuQXVkaW9Ob2RlfVxuXHRcdCAqICBAY29uc3RydWN0b3Jcblx0XHQgKiAgQHBhcmFtIHtUaW1lfE9iamVjdH0gW2RlbGF5VGltZV0gVGhlIGRlbGF5IHRpbWUgb2YgdGhlIGZpbHRlci5cblx0XHQgKiAgQHBhcmFtIHtOb3JtYWxSYW5nZT19IHJlc29uYW5jZSBUaGUgYW1vdW50IG9mIGZlZWRiYWNrIHRoZSBmaWx0ZXIgaGFzLlxuXHRcdCAqL1xuXHQgICAgVG9uZS5GZWVkYmFja0NvbWJGaWx0ZXIgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIG9wdGlvbnMgPSBUb25lLmRlZmF1bHRzKGFyZ3VtZW50cywgW1xuXHQgICAgICAgICAgICAnZGVsYXlUaW1lJyxcblx0ICAgICAgICAgICAgJ3Jlc29uYW5jZSdcblx0ICAgICAgICBdLCBUb25lLkZlZWRiYWNrQ29tYkZpbHRlcik7XG5cdCAgICAgICAgVG9uZS5BdWRpb05vZGUuY2FsbCh0aGlzKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICB0aGUgZGVsYXkgbm9kZVxuXHRcdFx0ICogIEB0eXBlIHtEZWxheU5vZGV9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2RlbGF5ID0gdGhpcy5pbnB1dCA9IHRoaXMub3V0cHV0ID0gbmV3IFRvbmUuRGVsYXkob3B0aW9ucy5kZWxheVRpbWUpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBhbW91bnQgb2YgZGVsYXkgb2YgdGhlIGNvbWIgZmlsdGVyLlxuXHRcdFx0ICogIEB0eXBlIHtUaW1lfVxuXHRcdFx0ICogIEBzaWduYWxcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuZGVsYXlUaW1lID0gdGhpcy5fZGVsYXkuZGVsYXlUaW1lO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHRoZSBmZWVkYmFjayBub2RlXG5cdFx0XHQgKiAgQHR5cGUge0dhaW5Ob2RlfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9mZWVkYmFjayA9IG5ldyBUb25lLkdhaW4ob3B0aW9ucy5yZXNvbmFuY2UsIFRvbmUuVHlwZS5Ob3JtYWxSYW5nZSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGFtb3VudCBvZiBmZWVkYmFjayBvZiB0aGUgZGVsYXllZCBzaWduYWwuXG5cdFx0XHQgKiAgQHR5cGUge05vcm1hbFJhbmdlfVxuXHRcdFx0ICogIEBzaWduYWxcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMucmVzb25hbmNlID0gdGhpcy5fZmVlZGJhY2suZ2Fpbjtcblx0ICAgICAgICB0aGlzLl9kZWxheS5jaGFpbih0aGlzLl9mZWVkYmFjaywgdGhpcy5fZGVsYXkpO1xuXHQgICAgICAgIHRoaXMuX3JlYWRPbmx5KFtcblx0ICAgICAgICAgICAgJ3Jlc29uYW5jZScsXG5cdCAgICAgICAgICAgICdkZWxheVRpbWUnXG5cdCAgICAgICAgXSk7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5GZWVkYmFja0NvbWJGaWx0ZXIsIFRvbmUuQXVkaW9Ob2RlKTtcblx0ICAgIC8qKlxuXHRcdCAqICB0aGUgZGVmYXVsdCBwYXJhbWV0ZXJzXG5cdFx0ICogIEBzdGF0aWNcblx0XHQgKiAgQGNvbnN0XG5cdFx0ICogIEB0eXBlIHtPYmplY3R9XG5cdFx0ICovXG5cdCAgICBUb25lLkZlZWRiYWNrQ29tYkZpbHRlci5kZWZhdWx0cyA9IHtcblx0ICAgICAgICAnZGVsYXlUaW1lJzogMC4xLFxuXHQgICAgICAgICdyZXNvbmFuY2UnOiAwLjVcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgY2xlYW4gdXBcblx0XHQgKiAgQHJldHVybnMge1RvbmUuRmVlZGJhY2tDb21iRmlsdGVyfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkZlZWRiYWNrQ29tYkZpbHRlci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLkF1ZGlvTm9kZS5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuX3dyaXRhYmxlKFtcblx0ICAgICAgICAgICAgJ3Jlc29uYW5jZScsXG5cdCAgICAgICAgICAgICdkZWxheVRpbWUnXG5cdCAgICAgICAgXSk7XG5cdCAgICAgICAgdGhpcy5fZGVsYXkuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX2RlbGF5ID0gbnVsbDtcblx0ICAgICAgICB0aGlzLmRlbGF5VGltZSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fZmVlZGJhY2suZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX2ZlZWRiYWNrID0gbnVsbDtcblx0ICAgICAgICB0aGlzLnJlc29uYW5jZSA9IG51bGw7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuRmVlZGJhY2tDb21iRmlsdGVyO1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgIFRvbmUuRm9sbG93ZXIgaXMgYSAgY3J1ZGUgZW52ZWxvcGUgZm9sbG93ZXIgd2hpY2ggd2lsbCBmb2xsb3dcblx0XHQgKiAgICAgICAgICB0aGUgYW1wbGl0dWRlIG9mIGFuIGluY29taW5nIHNpZ25hbC5cblx0XHQgKiAgICAgICAgICBUYWtlIGNhcmUgd2l0aCBzbWFsbCAoPCAwLjAyKSBhdHRhY2sgb3IgZGVjYXkgdmFsdWVzXG5cdFx0ICogICAgICAgICAgYXMgZm9sbG93ZXIgaGFzIHNvbWUgcmlwcGxlIHdoaWNoIGlzIGV4YWdnZXJhdGVkXG5cdFx0ICogICAgICAgICAgYXQgdGhlc2UgdmFsdWVzLiBSZWFkIG1vcmUgYWJvdXQgZW52ZWxvcGUgZm9sbG93ZXJzIChhbHNvIGtub3duXG5cdFx0ICogICAgICAgICAgYXMgZW52ZWxvcGUgZGV0ZWN0b3JzKSBvbiBbV2lraXBlZGlhXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9FbnZlbG9wZV9kZXRlY3RvcikuXG5cdFx0ICpcblx0XHQgKiAgQGNvbnN0cnVjdG9yXG5cdFx0ICogIEBleHRlbmRzIHtUb25lLkF1ZGlvTm9kZX1cblx0XHQgKiAgQHBhcmFtIHtUaW1lfE9iamVjdH0gW2F0dGFja10gVGhlIHJhdGUgYXQgd2hpY2ggdGhlIGZvbGxvd2VyIHJpc2VzLlxuXHRcdCAqICBAcGFyYW0ge1RpbWU9fSByZWxlYXNlIFRoZSByYXRlIGF0IHdoaWNoIHRoZSBmb2xvd2VyIGZhbGxzLlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIHZhciBmb2xsb3dlciA9IG5ldyBUb25lLkZvbGxvd2VyKDAuMiwgMC40KTtcblx0XHQgKi9cblx0ICAgIFRvbmUuRm9sbG93ZXIgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIG9wdGlvbnMgPSBUb25lLmRlZmF1bHRzKGFyZ3VtZW50cywgW1xuXHQgICAgICAgICAgICAnYXR0YWNrJyxcblx0ICAgICAgICAgICAgJ3JlbGVhc2UnXG5cdCAgICAgICAgXSwgVG9uZS5Gb2xsb3dlcik7XG5cdCAgICAgICAgVG9uZS5BdWRpb05vZGUuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLmNyZWF0ZUluc091dHMoMSwgMSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuQWJzfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9hYnMgPSBuZXcgVG9uZS5BYnMoKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICB0aGUgbG93cGFzcyBmaWx0ZXIgd2hpY2ggc21vb3RocyB0aGUgaW5wdXRcblx0XHRcdCAqICBAdHlwZSB7QmlxdWFkRmlsdGVyTm9kZX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fZmlsdGVyID0gdGhpcy5jb250ZXh0LmNyZWF0ZUJpcXVhZEZpbHRlcigpO1xuXHQgICAgICAgIHRoaXMuX2ZpbHRlci50eXBlID0gJ2xvd3Bhc3MnO1xuXHQgICAgICAgIHRoaXMuX2ZpbHRlci5mcmVxdWVuY3kudmFsdWUgPSAwO1xuXHQgICAgICAgIHRoaXMuX2ZpbHRlci5RLnZhbHVlID0gLTEwMDtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBAdHlwZSB7V2F2ZVNoYXBlck5vZGV9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2ZyZXF1ZW5jeVZhbHVlcyA9IG5ldyBUb25lLldhdmVTaGFwZXIoKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5TdWJ0cmFjdH1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fc3ViID0gbmV3IFRvbmUuU3VidHJhY3QoKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5EZWxheX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fZGVsYXkgPSBuZXcgVG9uZS5EZWxheSh0aGlzLmJsb2NrVGltZSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgdGhpcyBrZWVwcyBpdCBmYXIgZnJvbSAwLCBldmVuIGZvciB2ZXJ5IHNtYWxsIGRpZmZlcmVuY2VzXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuTXVsdGlwbHl9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX211bHQgPSBuZXcgVG9uZS5NdWx0aXBseSgxMDAwMCk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqICBAdHlwZSB7bnVtYmVyfVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fYXR0YWNrID0gb3B0aW9ucy5hdHRhY2s7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqICBAdHlwZSB7bnVtYmVyfVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fcmVsZWFzZSA9IG9wdGlvbnMucmVsZWFzZTtcblx0ICAgICAgICAvL3RoZSBzbW9vdGhlZCBzaWduYWwgdG8gZ2V0IHRoZSB2YWx1ZXNcblx0ICAgICAgICB0aGlzLmlucHV0LmNoYWluKHRoaXMuX2FicywgdGhpcy5fZmlsdGVyLCB0aGlzLm91dHB1dCk7XG5cdCAgICAgICAgLy90aGUgZGlmZmVyZW5jZSBwYXRoXG5cdCAgICAgICAgdGhpcy5fYWJzLmNvbm5lY3QodGhpcy5fc3ViLCAwLCAxKTtcblx0ICAgICAgICB0aGlzLl9maWx0ZXIuY2hhaW4odGhpcy5fZGVsYXksIHRoaXMuX3N1Yik7XG5cdCAgICAgICAgLy90aHJlc2hvbGQgdGhlIGRpZmZlcmVuY2UgYW5kIHVzZSB0aGUgdGhyZXNoIHRvIHNldCB0aGUgZnJlcXVlbmN5XG5cdCAgICAgICAgdGhpcy5fc3ViLmNoYWluKHRoaXMuX211bHQsIHRoaXMuX2ZyZXF1ZW5jeVZhbHVlcywgdGhpcy5fZmlsdGVyLmZyZXF1ZW5jeSk7XG5cdCAgICAgICAgLy9zZXQgdGhlIGF0dGFjayBhbmQgcmVsZWFzZSB2YWx1ZXMgaW4gdGhlIHRhYmxlXG5cdCAgICAgICAgdGhpcy5fc2V0QXR0YWNrUmVsZWFzZSh0aGlzLl9hdHRhY2ssIHRoaXMuX3JlbGVhc2UpO1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuRm9sbG93ZXIsIFRvbmUuQXVkaW9Ob2RlKTtcblx0ICAgIC8qKlxuXHRcdCAqICBAc3RhdGljXG5cdFx0ICogIEB0eXBlIHtPYmplY3R9XG5cdFx0ICovXG5cdCAgICBUb25lLkZvbGxvd2VyLmRlZmF1bHRzID0ge1xuXHQgICAgICAgICdhdHRhY2snOiAwLjA1LFxuXHQgICAgICAgICdyZWxlYXNlJzogMC41XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIHNldHMgdGhlIGF0dGFjayBhbmQgcmVsZWFzZSB0aW1lcyBpbiB0aGUgd2F2ZSBzaGFwZXJcblx0XHQgKiAgQHBhcmFtICAge1RpbWV9IGF0dGFja1xuXHRcdCAqICBAcGFyYW0gICB7VGltZX0gcmVsZWFzZVxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5Gb2xsb3dlci5wcm90b3R5cGUuX3NldEF0dGFja1JlbGVhc2UgPSBmdW5jdGlvbiAoYXR0YWNrLCByZWxlYXNlKSB7XG5cdCAgICAgICAgdmFyIG1pblRpbWUgPSB0aGlzLmJsb2NrVGltZTtcblx0ICAgICAgICBhdHRhY2sgPSBUb25lLlRpbWUoYXR0YWNrKS50b0ZyZXF1ZW5jeSgpO1xuXHQgICAgICAgIHJlbGVhc2UgPSBUb25lLlRpbWUocmVsZWFzZSkudG9GcmVxdWVuY3koKTtcblx0ICAgICAgICBhdHRhY2sgPSBNYXRoLm1heChhdHRhY2ssIG1pblRpbWUpO1xuXHQgICAgICAgIHJlbGVhc2UgPSBNYXRoLm1heChyZWxlYXNlLCBtaW5UaW1lKTtcblx0ICAgICAgICB0aGlzLl9mcmVxdWVuY3lWYWx1ZXMuc2V0TWFwKGZ1bmN0aW9uICh2YWwpIHtcblx0ICAgICAgICAgICAgaWYgKHZhbCA8PSAwKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gYXR0YWNrO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHJlbGVhc2U7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiBUaGUgYXR0YWNrIHRpbWUuXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuRm9sbG93ZXIjXG5cdFx0ICogQHR5cGUge1RpbWV9XG5cdFx0ICogQG5hbWUgYXR0YWNrXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5Gb2xsb3dlci5wcm90b3R5cGUsICdhdHRhY2snLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9hdHRhY2s7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChhdHRhY2spIHtcblx0ICAgICAgICAgICAgdGhpcy5fYXR0YWNrID0gYXR0YWNrO1xuXHQgICAgICAgICAgICB0aGlzLl9zZXRBdHRhY2tSZWxlYXNlKHRoaXMuX2F0dGFjaywgdGhpcy5fcmVsZWFzZSk7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiBUaGUgcmVsZWFzZSB0aW1lLlxuXHRcdCAqIEBtZW1iZXJPZiBUb25lLkZvbGxvd2VyI1xuXHRcdCAqIEB0eXBlIHtUaW1lfVxuXHRcdCAqIEBuYW1lIHJlbGVhc2Vcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkZvbGxvd2VyLnByb3RvdHlwZSwgJ3JlbGVhc2UnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZWxlYXNlO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAocmVsZWFzZSkge1xuXHQgICAgICAgICAgICB0aGlzLl9yZWxlYXNlID0gcmVsZWFzZTtcblx0ICAgICAgICAgICAgdGhpcy5fc2V0QXR0YWNrUmVsZWFzZSh0aGlzLl9hdHRhY2ssIHRoaXMuX3JlbGVhc2UpO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIEJvcnJvd3MgdGhlIGNvbm5lY3QgbWV0aG9kIGZyb20gU2lnbmFsIHNvIHRoYXQgdGhlIG91dHB1dCBjYW4gYmUgdXNlZFxuXHRcdCAqICBhcyBhIFRvbmUuU2lnbmFsIGNvbnRyb2wgc2lnbmFsLlxuXHRcdCAqICBAZnVuY3Rpb25cblx0XHQgKi9cblx0ICAgIFRvbmUuRm9sbG93ZXIucHJvdG90eXBlLmNvbm5lY3QgPSBUb25lLlNpZ25hbC5wcm90b3R5cGUuY29ubmVjdDtcblx0ICAgIC8qKlxuXHRcdCAqICBkaXNwb3NlXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLkZvbGxvd2VyfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkZvbGxvd2VyLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuQXVkaW9Ob2RlLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgdGhpcy5fZmlsdGVyLmRpc2Nvbm5lY3QoKTtcblx0ICAgICAgICB0aGlzLl9maWx0ZXIgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX2ZyZXF1ZW5jeVZhbHVlcy5kaXNjb25uZWN0KCk7XG5cdCAgICAgICAgdGhpcy5fZnJlcXVlbmN5VmFsdWVzID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9kZWxheS5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fZGVsYXkgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX3N1Yi5kaXNjb25uZWN0KCk7XG5cdCAgICAgICAgdGhpcy5fc3ViID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9hYnMuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX2FicyA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fbXVsdC5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fbXVsdCA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fY3VydmUgPSBudWxsO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLkZvbGxvd2VyO1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgVG9uZS5TY2FsZWRFbnZlbG9wIGlzIGFuIGVudmVsb3BlIHdoaWNoIGNhbiBiZSBzY2FsZWQgXG5cdFx0ICogICAgICAgICB0byBhbnkgcmFuZ2UuIEl0J3MgdXNlZnVsIGZvciBhcHBseWluZyBhbiBlbnZlbG9wZSBcblx0XHQgKiAgICAgICAgIHRvIGEgZnJlcXVlbmN5IG9yIGFueSBvdGhlciBub24tTm9ybWFsUmFuZ2Ugc2lnbmFsIFxuXHRcdCAqICAgICAgICAgcGFyYW1ldGVyLiBcblx0XHQgKlxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZS5FbnZlbG9wZX1cblx0XHQgKiAgQGNvbnN0cnVjdG9yXG5cdFx0ICogIEBwYXJhbSB7VGltZXxPYmplY3R9IFthdHRhY2tdXHR0aGUgYXR0YWNrIHRpbWUgaW4gc2Vjb25kc1xuXHRcdCAqICBAcGFyYW0ge1RpbWV9IFtkZWNheV1cdHRoZSBkZWNheSB0aW1lIGluIHNlY29uZHNcblx0XHQgKiAgQHBhcmFtIHtudW1iZXJ9IFtzdXN0YWluXSBcdGEgcGVyY2VudGFnZSAoMC0xKSBvZiB0aGUgZnVsbCBhbXBsaXR1ZGVcblx0XHQgKiAgQHBhcmFtIHtUaW1lfSBbcmVsZWFzZV1cdHRoZSByZWxlYXNlIHRpbWUgaW4gc2Vjb25kc1xuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICB2YXIgc2NhbGVkRW52ID0gbmV3IFRvbmUuU2NhbGVkRW52ZWxvcGUoe1xuXHRcdCAqICBcdFwiYXR0YWNrXCIgOiAwLjIsXG5cdFx0ICogIFx0XCJtaW5cIiA6IDIwMCxcblx0XHQgKiAgXHRcIm1heFwiIDogMjAwMFxuXHRcdCAqICB9KTtcblx0XHQgKiAgc2NhbGVkRW52LmNvbm5lY3Qob3NjaWxsYXRvci5mcmVxdWVuY3kpO1xuXHRcdCAqL1xuXHQgICAgVG9uZS5TY2FsZWRFbnZlbG9wZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAvL2dldCBhbGwgb2YgdGhlIGRlZmF1bHRzXG5cdCAgICAgICAgdmFyIG9wdGlvbnMgPSBUb25lLmRlZmF1bHRzKGFyZ3VtZW50cywgW1xuXHQgICAgICAgICAgICAnYXR0YWNrJyxcblx0ICAgICAgICAgICAgJ2RlY2F5Jyxcblx0ICAgICAgICAgICAgJ3N1c3RhaW4nLFxuXHQgICAgICAgICAgICAncmVsZWFzZSdcblx0ICAgICAgICBdLCBUb25lLkVudmVsb3BlKTtcblx0ICAgICAgICBUb25lLkVudmVsb3BlLmNhbGwodGhpcywgb3B0aW9ucyk7XG5cdCAgICAgICAgb3B0aW9ucyA9IFRvbmUuZGVmYXVsdEFyZyhvcHRpb25zLCBUb25lLlNjYWxlZEVudmVsb3BlLmRlZmF1bHRzKTtcblx0ICAgICAgICAvKiogXG5cdFx0XHQgKiAgc2NhbGUgdGhlIGluY29taW5nIHNpZ25hbCBieSBhbiBleHBvbmVudFxuXHRcdFx0ICogIEB0eXBlIHtUb25lLlBvd31cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fZXhwID0gdGhpcy5vdXRwdXQgPSBuZXcgVG9uZS5Qb3cob3B0aW9ucy5leHBvbmVudCk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgc2NhbGUgdGhlIHNpZ25hbCB0byB0aGUgZGVzaXJlZCByYW5nZVxuXHRcdFx0ICogIEB0eXBlIHtUb25lLk11bHRpcGx5fVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9zY2FsZSA9IHRoaXMub3V0cHV0ID0gbmV3IFRvbmUuU2NhbGUob3B0aW9ucy5taW4sIG9wdGlvbnMubWF4KTtcblx0ICAgICAgICB0aGlzLl9zaWcuY2hhaW4odGhpcy5fZXhwLCB0aGlzLl9zY2FsZSk7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5TY2FsZWRFbnZlbG9wZSwgVG9uZS5FbnZlbG9wZSk7XG5cdCAgICAvKipcblx0XHQgKiAgdGhlIGRlZmF1bHQgcGFyYW1ldGVyc1xuXHRcdCAqICBAc3RhdGljXG5cdFx0ICovXG5cdCAgICBUb25lLlNjYWxlZEVudmVsb3BlLmRlZmF1bHRzID0ge1xuXHQgICAgICAgICdtaW4nOiAwLFxuXHQgICAgICAgICdtYXgnOiAxLFxuXHQgICAgICAgICdleHBvbmVudCc6IDFcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiBUaGUgZW52ZWxvcGUncyBtaW4gb3V0cHV0IHZhbHVlLiBUaGlzIGlzIHRoZSB2YWx1ZSB3aGljaCBpdFxuXHRcdCAqIHN0YXJ0cyBhdC4gXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuU2NhbGVkRW52ZWxvcGUjXG5cdFx0ICogQHR5cGUge251bWJlcn1cblx0XHQgKiBAbmFtZSBtaW5cblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLlNjYWxlZEVudmVsb3BlLnByb3RvdHlwZSwgJ21pbicsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NjYWxlLm1pbjtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKG1pbikge1xuXHQgICAgICAgICAgICB0aGlzLl9zY2FsZS5taW4gPSBtaW47XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiBUaGUgZW52ZWxvcGUncyBtYXggb3V0cHV0IHZhbHVlLiBJbiBvdGhlciB3b3JkcywgdGhlIHZhbHVlXG5cdFx0ICogYXQgdGhlIHBlYWsgb2YgdGhlIGF0dGFjayBwb3J0aW9uIG9mIHRoZSBlbnZlbG9wZS4gXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuU2NhbGVkRW52ZWxvcGUjXG5cdFx0ICogQHR5cGUge251bWJlcn1cblx0XHQgKiBAbmFtZSBtYXhcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLlNjYWxlZEVudmVsb3BlLnByb3RvdHlwZSwgJ21heCcsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NjYWxlLm1heDtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKG1heCkge1xuXHQgICAgICAgICAgICB0aGlzLl9zY2FsZS5tYXggPSBtYXg7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiBUaGUgZW52ZWxvcGUncyBleHBvbmVudCB2YWx1ZS4gXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuU2NhbGVkRW52ZWxvcGUjXG5cdFx0ICogQHR5cGUge251bWJlcn1cblx0XHQgKiBAbmFtZSBleHBvbmVudFxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuU2NhbGVkRW52ZWxvcGUucHJvdG90eXBlLCAnZXhwb25lbnQnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9leHAudmFsdWU7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChleHApIHtcblx0ICAgICAgICAgICAgdGhpcy5fZXhwLnZhbHVlID0gZXhwO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIGNsZWFuIHVwXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLlNjYWxlZEVudmVsb3BlfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLlNjYWxlZEVudmVsb3BlLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuRW52ZWxvcGUucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLl9zY2FsZS5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fc2NhbGUgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX2V4cC5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fZXhwID0gbnVsbDtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVG9uZS5TY2FsZWRFbnZlbG9wZTtcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgXG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzIFRvbmUuRnJlcXVlbmN5RW52ZWxvcGUgaXMgYSBUb25lLlNjYWxlZEVudmVsb3BlLCBidXQgaW5zdGVhZCBvZiBgbWluYCBhbmQgYG1heGBcblx0XHQgKiAgICAgICAgIGl0J3MgZ290IGEgYGJhc2VGcmVxdWVuY3lgIGFuZCBgb2N0YXZlc2AgcGFyYW1ldGVyLiBcblx0XHQgKlxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZS5FbnZlbG9wZX1cblx0XHQgKiAgQGNvbnN0cnVjdG9yXG5cdFx0ICogIEBwYXJhbSB7VGltZXxPYmplY3R9IFthdHRhY2tdXHR0aGUgYXR0YWNrIHRpbWUgaW4gc2Vjb25kc1xuXHRcdCAqICBAcGFyYW0ge1RpbWV9IFtkZWNheV1cdHRoZSBkZWNheSB0aW1lIGluIHNlY29uZHNcblx0XHQgKiAgQHBhcmFtIHtudW1iZXJ9IFtzdXN0YWluXSBcdGEgcGVyY2VudGFnZSAoMC0xKSBvZiB0aGUgZnVsbCBhbXBsaXR1ZGVcblx0XHQgKiAgQHBhcmFtIHtUaW1lfSBbcmVsZWFzZV1cdHRoZSByZWxlYXNlIHRpbWUgaW4gc2Vjb25kc1xuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICB2YXIgZW52ID0gbmV3IFRvbmUuRnJlcXVlbmN5RW52ZWxvcGUoe1xuXHRcdCAqICBcdFwiYXR0YWNrXCIgOiAwLjIsXG5cdFx0ICogIFx0XCJiYXNlRnJlcXVlbmN5XCIgOiBcIkMyXCIsXG5cdFx0ICogIFx0XCJvY3RhdmVzXCIgOiA0XG5cdFx0ICogIH0pO1xuXHRcdCAqICBzY2FsZWRFbnYuY29ubmVjdChvc2NpbGxhdG9yLmZyZXF1ZW5jeSk7XG5cdFx0ICovXG5cdCAgICBUb25lLkZyZXF1ZW5jeUVudmVsb3BlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBvcHRpb25zID0gVG9uZS5kZWZhdWx0cyhhcmd1bWVudHMsIFtcblx0ICAgICAgICAgICAgJ2F0dGFjaycsXG5cdCAgICAgICAgICAgICdkZWNheScsXG5cdCAgICAgICAgICAgICdzdXN0YWluJyxcblx0ICAgICAgICAgICAgJ3JlbGVhc2UnXG5cdCAgICAgICAgXSwgVG9uZS5FbnZlbG9wZSk7XG5cdCAgICAgICAgVG9uZS5TY2FsZWRFbnZlbG9wZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXHQgICAgICAgIC8vbWVyZ2UgaXQgd2l0aCB0aGUgZnJlcXVlbmN5IGVudmVsb3BlIGRlZmF1bHRzXG5cdCAgICAgICAgb3B0aW9ucyA9IFRvbmUuZGVmYXVsdEFyZyhvcHRpb25zLCBUb25lLkZyZXF1ZW5jeUVudmVsb3BlLmRlZmF1bHRzKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBTdG9yZXMgdGhlIG9jdGF2ZSB2YWx1ZVxuXHRcdFx0ICogIEB0eXBlIHtQb3NpdGl2ZX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fb2N0YXZlcyA9IG9wdGlvbnMub2N0YXZlcztcblx0ICAgICAgICAvL3NldHVwXG5cdCAgICAgICAgdGhpcy5iYXNlRnJlcXVlbmN5ID0gb3B0aW9ucy5iYXNlRnJlcXVlbmN5O1xuXHQgICAgICAgIHRoaXMub2N0YXZlcyA9IG9wdGlvbnMub2N0YXZlcztcblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLkZyZXF1ZW5jeUVudmVsb3BlLCBUb25lLkVudmVsb3BlKTtcblx0ICAgIC8qKlxuXHRcdCAqICB0aGUgZGVmYXVsdCBwYXJhbWV0ZXJzXG5cdFx0ICogIEBzdGF0aWNcblx0XHQgKi9cblx0ICAgIFRvbmUuRnJlcXVlbmN5RW52ZWxvcGUuZGVmYXVsdHMgPSB7XG5cdCAgICAgICAgJ2Jhc2VGcmVxdWVuY3knOiAyMDAsXG5cdCAgICAgICAgJ29jdGF2ZXMnOiA0LFxuXHQgICAgICAgICdleHBvbmVudCc6IDJcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiBUaGUgZW52ZWxvcGUncyBtaW5pbnVtIG91dHB1dCB2YWx1ZS4gVGhpcyBpcyB0aGUgdmFsdWUgd2hpY2ggaXRcblx0XHQgKiBzdGFydHMgYXQuIFxuXHRcdCAqIEBtZW1iZXJPZiBUb25lLkZyZXF1ZW5jeUVudmVsb3BlI1xuXHRcdCAqIEB0eXBlIHtGcmVxdWVuY3l9XG5cdFx0ICogQG5hbWUgYmFzZUZyZXF1ZW5jeVxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuRnJlcXVlbmN5RW52ZWxvcGUucHJvdG90eXBlLCAnYmFzZUZyZXF1ZW5jeScsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NjYWxlLm1pbjtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKG1pbikge1xuXHQgICAgICAgICAgICB0aGlzLl9zY2FsZS5taW4gPSB0aGlzLnRvRnJlcXVlbmN5KG1pbik7XG5cdCAgICAgICAgICAgIC8vYWxzbyB1cGRhdGUgdGhlIG9jdGF2ZXNcblx0ICAgICAgICAgICAgdGhpcy5vY3RhdmVzID0gdGhpcy5fb2N0YXZlcztcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqIFRoZSBudW1iZXIgb2Ygb2N0YXZlcyBhYm92ZSB0aGUgYmFzZUZyZXF1ZW5jeSB0aGF0IHRoZVxuXHRcdCAqIGVudmVsb3BlIHdpbGwgc2NhbGUgdG8uXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuRnJlcXVlbmN5RW52ZWxvcGUjXG5cdFx0ICogQHR5cGUge1Bvc2l0aXZlfVxuXHRcdCAqIEBuYW1lIG9jdGF2ZXNcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkZyZXF1ZW5jeUVudmVsb3BlLnByb3RvdHlwZSwgJ29jdGF2ZXMnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9vY3RhdmVzO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAob2N0YXZlcykge1xuXHQgICAgICAgICAgICB0aGlzLl9vY3RhdmVzID0gb2N0YXZlcztcblx0ICAgICAgICAgICAgdGhpcy5fc2NhbGUubWF4ID0gdGhpcy5iYXNlRnJlcXVlbmN5ICogTWF0aC5wb3coMiwgb2N0YXZlcyk7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiBUaGUgZW52ZWxvcGUncyBleHBvbmVudCB2YWx1ZS4gXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuRnJlcXVlbmN5RW52ZWxvcGUjXG5cdFx0ICogQHR5cGUge251bWJlcn1cblx0XHQgKiBAbmFtZSBleHBvbmVudFxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuRnJlcXVlbmN5RW52ZWxvcGUucHJvdG90eXBlLCAnZXhwb25lbnQnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9leHAudmFsdWU7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChleHApIHtcblx0ICAgICAgICAgICAgdGhpcy5fZXhwLnZhbHVlID0gZXhwO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIGNsZWFuIHVwXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLkZyZXF1ZW5jeUVudmVsb3BlfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkZyZXF1ZW5jeUVudmVsb3BlLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuU2NhbGVkRW52ZWxvcGUucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVG9uZS5GcmVxdWVuY3lFbnZlbG9wZTtcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgXG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzICBUb25lLkdhdGUgb25seSBwYXNzZXMgYSBzaWduYWwgdGhyb3VnaCB3aGVuIHRoZSBpbmNvbWluZ1xuXHRcdCAqICAgICAgICAgIHNpZ25hbCBleGNlZWRzIGEgc3BlY2lmaWVkIHRocmVzaG9sZC4gVG8gZG8gdGhpcywgR2F0ZSB1c2VzXG5cdFx0ICogICAgICAgICAgYSBUb25lLkZvbGxvd2VyIHRvIGZvbGxvdyB0aGUgYW1wbGl0dWRlIG9mIHRoZSBpbmNvbWluZyBzaWduYWwuXG5cdFx0ICogICAgICAgICAgQSBjb21tb24gaW1wbGVtZW50YXRpb24gb2YgdGhpcyBjbGFzcyBpcyBhIFtOb2lzZSBHYXRlXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Ob2lzZV9nYXRlKS5cblx0XHQgKlxuXHRcdCAqICBAY29uc3RydWN0b3Jcblx0XHQgKiAgQGV4dGVuZHMge1RvbmUuQXVkaW9Ob2RlfVxuXHRcdCAqICBAcGFyYW0ge0RlY2liZWxzfE9iamVjdH0gW3RocmVzaG9sZF0gVGhlIHRocmVzaG9sZCBhYm92ZSB3aGljaCB0aGUgZ2F0ZSB3aWxsIG9wZW4uXG5cdFx0ICogIEBwYXJhbSB7VGltZT19IGF0dGFjayBUaGUgZm9sbG93ZXIncyBhdHRhY2sgdGltZVxuXHRcdCAqICBAcGFyYW0ge1RpbWU9fSByZWxlYXNlIFRoZSBmb2xsb3dlcidzIHJlbGVhc2UgdGltZVxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIHZhciBnYXRlID0gbmV3IFRvbmUuR2F0ZSgtMzAsIDAuMiwgMC4zKS50b01hc3RlcigpO1xuXHRcdCAqIHZhciBtaWMgPSBuZXcgVG9uZS5Vc2VyTWVkaWEoKS5jb25uZWN0KGdhdGUpO1xuXHRcdCAqIC8vdGhlIGdhdGUgd2lsbCBvbmx5IHBhc3MgdGhyb3VnaCB0aGUgaW5jb21pbmdcblx0XHQgKiAvL3NpZ25hbCB3aGVuIGl0J3MgbG91ZGVyIHRoYW4gLTMwZGJcblx0XHQgKi9cblx0ICAgIFRvbmUuR2F0ZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgb3B0aW9ucyA9IFRvbmUuZGVmYXVsdHMoYXJndW1lbnRzLCBbXG5cdCAgICAgICAgICAgICd0aHJlc2hvbGQnLFxuXHQgICAgICAgICAgICAnYXR0YWNrJyxcblx0ICAgICAgICAgICAgJ3JlbGVhc2UnXG5cdCAgICAgICAgXSwgVG9uZS5HYXRlKTtcblx0ICAgICAgICBUb25lLkF1ZGlvTm9kZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuY3JlYXRlSW5zT3V0cygxLCAxKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5Gb2xsb3dlcn1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fZm9sbG93ZXIgPSBuZXcgVG9uZS5Gb2xsb3dlcihvcHRpb25zLmF0dGFjaywgb3B0aW9ucy5yZWxlYXNlKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5HcmVhdGVyVGhhbn1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fZ3QgPSBuZXcgVG9uZS5HcmVhdGVyVGhhbihUb25lLmRiVG9HYWluKG9wdGlvbnMudGhyZXNob2xkKSk7XG5cdCAgICAgICAgLy90aGUgY29ubmVjdGlvbnNcblx0ICAgICAgICB0aGlzLmlucHV0LmNvbm5lY3QodGhpcy5vdXRwdXQpO1xuXHQgICAgICAgIC8vdGhlIGNvbnRyb2wgc2lnbmFsXG5cdCAgICAgICAgdGhpcy5pbnB1dC5jaGFpbih0aGlzLl9ndCwgdGhpcy5fZm9sbG93ZXIsIHRoaXMub3V0cHV0LmdhaW4pO1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuR2F0ZSwgVG9uZS5BdWRpb05vZGUpO1xuXHQgICAgLyoqXG5cdFx0ICogIEBjb25zdFxuXHRcdCAqICBAc3RhdGljXG5cdFx0ICogIEB0eXBlIHtPYmplY3R9XG5cdFx0ICovXG5cdCAgICBUb25lLkdhdGUuZGVmYXVsdHMgPSB7XG5cdCAgICAgICAgJ2F0dGFjayc6IDAuMSxcblx0ICAgICAgICAncmVsZWFzZSc6IDAuMSxcblx0ICAgICAgICAndGhyZXNob2xkJzogLTQwXG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogVGhlIHRocmVzaG9sZCBvZiB0aGUgZ2F0ZSBpbiBkZWNpYmVsc1xuXHRcdCAqIEBtZW1iZXJPZiBUb25lLkdhdGUjXG5cdFx0ICogQHR5cGUge0RlY2liZWxzfVxuXHRcdCAqIEBuYW1lIHRocmVzaG9sZFxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuR2F0ZS5wcm90b3R5cGUsICd0aHJlc2hvbGQnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBUb25lLmdhaW5Ub0RiKHRoaXMuX2d0LnZhbHVlKTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKHRocmVzaCkge1xuXHQgICAgICAgICAgICB0aGlzLl9ndC52YWx1ZSA9IFRvbmUuZGJUb0dhaW4odGhyZXNoKTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqIFRoZSBhdHRhY2sgc3BlZWQgb2YgdGhlIGdhdGVcblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5HYXRlI1xuXHRcdCAqIEB0eXBlIHtUaW1lfVxuXHRcdCAqIEBuYW1lIGF0dGFja1xuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuR2F0ZS5wcm90b3R5cGUsICdhdHRhY2snLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9mb2xsb3dlci5hdHRhY2s7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChhdHRhY2tUaW1lKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2ZvbGxvd2VyLmF0dGFjayA9IGF0dGFja1RpbWU7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiBUaGUgcmVsZWFzZSBzcGVlZCBvZiB0aGUgZ2F0ZVxuXHRcdCAqIEBtZW1iZXJPZiBUb25lLkdhdGUjXG5cdFx0ICogQHR5cGUge1RpbWV9XG5cdFx0ICogQG5hbWUgcmVsZWFzZVxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuR2F0ZS5wcm90b3R5cGUsICdyZWxlYXNlJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fZm9sbG93ZXIucmVsZWFzZTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKHJlbGVhc2VUaW1lKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2ZvbGxvd2VyLnJlbGVhc2UgPSByZWxlYXNlVGltZTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBDbGVhbiB1cC5cblx0XHQgKiAgQHJldHVybnMge1RvbmUuR2F0ZX0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5HYXRlLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuQXVkaW9Ob2RlLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgdGhpcy5fZm9sbG93ZXIuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX2d0LmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9mb2xsb3dlciA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fZ3QgPSBudWxsO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLkdhdGU7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIC8qKlxuXHRcdCAqIEBjbGFzcyBUb25lLlRpY2tTaWduYWwgZXh0ZW5kcyBUb25lLlRpbWVsaW5lU2lnbmFsLCBidXQgYWRkcyB0aGUgY2FwYWJpbGl0eVxuXHRcdCAqICAgICAgICB0byBjYWxjdWxhdGUgdGhlIG51bWJlciBvZiBlbGFwc2VkIHRpY2tzLiBleHBvbmVudGlhbCBhbmQgdGFyZ2V0IGN1cnZlc1xuXHRcdCAqICAgICAgICBhcmUgYXBwcm94aW1hdGVkIHdpdGggbXVsdGlwbGUgbGluZWFyIHJhbXBzLlxuXHRcdCAqXG5cdFx0ICogICAgICAgIFRoYW5rIHlvdSBCcnVubyBEaWFzLCBILiBTb2ZpYSBQaW50bywgYW5kIERhdmlkIE0uIE1hdG9zLCBmb3IgeW91ciBbV0FDIHBhcGVyXShodHRwczovL3NtYXJ0ZWNoLmdhdGVjaC5lZHUvYml0c3RyZWFtL2hhbmRsZS8xODUzLzU0NTg4L1dBQzIwMTYtNDkucGRmKVxuXHRcdCAqICAgICAgICBkZXNjcmliaW5nIGludGVncmF0aW5nIHRpbWluZyBmdW5jdGlvbnMgZm9yIHRlbXBvIGNhbGN1bGF0aW9ucy5cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSBUaGUgaW5pdGlhbCB2YWx1ZSBvZiB0aGUgc2lnbmFsXG5cdFx0ICogQGV4dGVuZHMge1RvbmUuVGltZWxpbmVTaWduYWx9XG5cdFx0ICovXG5cdCAgICBUb25lLlRpY2tTaWduYWwgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgICB2YWx1ZSA9IFRvbmUuZGVmYXVsdEFyZyh2YWx1ZSwgMSk7XG5cdCAgICAgICAgVG9uZS5UaW1lbGluZVNpZ25hbC5jYWxsKHRoaXMsIHtcblx0ICAgICAgICAgICAgJ3VuaXRzJzogVG9uZS5UeXBlLlRpY2tzLFxuXHQgICAgICAgICAgICAndmFsdWUnOiB2YWx1ZVxuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIC8vZXh0ZW5kIHRoZSBtZW1vcnlcblx0ICAgICAgICB0aGlzLl9ldmVudHMubWVtb3J5ID0gSW5maW5pdHk7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5UaWNrU2lnbmFsLCBUb25lLlRpbWVsaW5lU2lnbmFsKTtcblx0ICAgIC8qKlxuXHRcdCAqIFdyYXBzIFRvbmUuVGltZWxpbmVTaWduYWwgbWV0aG9kcyBzbyB0aGF0IHRoZXkgYWxzb1xuXHRcdCAqIHJlY29yZCB0aGUgdGlja3MuXG5cdFx0ICogQHBhcmFtICB7RnVuY3Rpb259IG1ldGhvZFxuXHRcdCAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBmdW5jdGlvbiBfd3JhcFNjaGVkdWxlTWV0aG9kcyhtZXRob2QpIHtcblx0ICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlLCB0aW1lKSB7XG5cdCAgICAgICAgICAgIHRpbWUgPSB0aGlzLnRvU2Vjb25kcyh0aW1lKTtcblx0ICAgICAgICAgICAgbWV0aG9kLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdCAgICAgICAgICAgIHZhciBldmVudCA9IHRoaXMuX2V2ZW50cy5nZXQodGltZSk7XG5cdCAgICAgICAgICAgIHZhciBwcmV2aW91c0V2ZW50ID0gdGhpcy5fZXZlbnRzLnByZXZpb3VzRXZlbnQoZXZlbnQpO1xuXHQgICAgICAgICAgICB2YXIgdGlja3NVbnRpbFRpbWUgPSB0aGlzLl9nZXRUaWNrVW50aWxFdmVudChwcmV2aW91c0V2ZW50LCB0aW1lIC0gdGhpcy5zYW1wbGVUaW1lKTtcblx0ICAgICAgICAgICAgZXZlbnQudGlja3MgPSBNYXRoLm1heCh0aWNrc1VudGlsVGltZSwgMCk7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgICAgIH07XG5cdCAgICB9XG5cdCAgICBUb25lLlRpY2tTaWduYWwucHJvdG90eXBlLnNldFZhbHVlQXRUaW1lID0gX3dyYXBTY2hlZHVsZU1ldGhvZHMoVG9uZS5UaW1lbGluZVNpZ25hbC5wcm90b3R5cGUuc2V0VmFsdWVBdFRpbWUpO1xuXHQgICAgVG9uZS5UaWNrU2lnbmFsLnByb3RvdHlwZS5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZSA9IF93cmFwU2NoZWR1bGVNZXRob2RzKFRvbmUuVGltZWxpbmVTaWduYWwucHJvdG90eXBlLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKTtcblx0ICAgIC8qKlxuXHRcdCAqICBTdGFydCBleHBvbmVudGlhbGx5IGFwcHJvYWNoaW5nIHRoZSB0YXJnZXQgdmFsdWUgYXQgdGhlIGdpdmVuIHRpbWUgd2l0aFxuXHRcdCAqICBhIHJhdGUgaGF2aW5nIHRoZSBnaXZlbiB0aW1lIGNvbnN0YW50LlxuXHRcdCAqICBAcGFyYW0ge251bWJlcn0gdmFsdWVcblx0XHQgKiAgQHBhcmFtIHtUaW1lfSBzdGFydFRpbWVcblx0XHQgKiAgQHBhcmFtIHtudW1iZXJ9IHRpbWVDb25zdGFudFxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5UaWNrU2lnbmFsfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLlRpY2tTaWduYWwucHJvdG90eXBlLnNldFRhcmdldEF0VGltZSA9IGZ1bmN0aW9uICh2YWx1ZSwgdGltZSwgY29uc3RhbnQpIHtcblx0ICAgICAgICAvL2Fwcm94aW1hdGUgaXQgd2l0aCBtdWx0aXBsZSBsaW5lYXIgcmFtcHNcblx0ICAgICAgICB0aW1lID0gdGhpcy50b1NlY29uZHModGltZSk7XG5cdCAgICAgICAgdGhpcy5zZXRSYW1wUG9pbnQodGltZSk7XG5cdCAgICAgICAgdmFsdWUgPSB0aGlzLl9mcm9tVW5pdHModmFsdWUpO1xuXHQgICAgICAgIC8vc3RhcnQgZnJvbSBwcmV2aW91c2x5IHNjaGVkdWxlZCB2YWx1ZVxuXHQgICAgICAgIHZhciBwcmV2RXZlbnQgPSB0aGlzLl9ldmVudHMuZ2V0KHRpbWUpO1xuXHQgICAgICAgIHZhciBzZWdtZW50cyA9IDU7XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gc2VnbWVudHM7IGkrKykge1xuXHQgICAgICAgICAgICB2YXIgc2VnVGltZSA9IGNvbnN0YW50ICogaSArIHRpbWU7XG5cdCAgICAgICAgICAgIHZhciByYW1wVmFsID0gdGhpcy5fZXhwb25lbnRpYWxBcHByb2FjaChwcmV2RXZlbnQudGltZSwgcHJldkV2ZW50LnZhbHVlLCB2YWx1ZSwgY29uc3RhbnQsIHNlZ1RpbWUpO1xuXHQgICAgICAgICAgICB0aGlzLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKHRoaXMuX3RvVW5pdHMocmFtcFZhbCksIHNlZ1RpbWUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgU2NoZWR1bGVzIGFuIGV4cG9uZW50aWFsIGNvbnRpbnVvdXMgY2hhbmdlIGluIHBhcmFtZXRlciB2YWx1ZSBmcm9tXG5cdFx0ICogIHRoZSBwcmV2aW91cyBzY2hlZHVsZWQgcGFyYW1ldGVyIHZhbHVlIHRvIHRoZSBnaXZlbiB2YWx1ZS5cblx0XHQgKiAgQHBhcmFtICB7bnVtYmVyfSB2YWx1ZVxuXHRcdCAqICBAcGFyYW0gIHtUaW1lfSBlbmRUaW1lXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLlRpY2tTaWduYWx9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuVGlja1NpZ25hbC5wcm90b3R5cGUuZXhwb25lbnRpYWxSYW1wVG9WYWx1ZUF0VGltZSA9IGZ1bmN0aW9uICh2YWx1ZSwgdGltZSkge1xuXHQgICAgICAgIC8vYXByb3hpbWF0ZSBpdCB3aXRoIG11bHRpcGxlIGxpbmVhciByYW1wc1xuXHQgICAgICAgIHRpbWUgPSB0aGlzLnRvU2Vjb25kcyh0aW1lKTtcblx0ICAgICAgICB2YWx1ZSA9IHRoaXMuX2Zyb21Vbml0cyh2YWx1ZSk7XG5cdCAgICAgICAgLy9zdGFydCBmcm9tIHByZXZpb3VzbHkgc2NoZWR1bGVkIHZhbHVlXG5cdCAgICAgICAgdmFyIHByZXZFdmVudCA9IHRoaXMuX2V2ZW50cy5nZXQodGltZSk7XG5cdCAgICAgICAgaWYgKHByZXZFdmVudCA9PT0gbnVsbCkge1xuXHQgICAgICAgICAgICBwcmV2RXZlbnQgPSB7XG5cdCAgICAgICAgICAgICAgICAndmFsdWUnOiB0aGlzLl9pbml0aWFsLFxuXHQgICAgICAgICAgICAgICAgJ3RpbWUnOiAwXG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBzZWdtZW50cyA9IDU7XG5cdCAgICAgICAgdmFyIHNlZ21lbnREdXIgPSAodGltZSAtIHByZXZFdmVudC50aW1lKSAvIHNlZ21lbnRzO1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDw9IHNlZ21lbnRzOyBpKyspIHtcblx0ICAgICAgICAgICAgdmFyIHNlZ1RpbWUgPSBzZWdtZW50RHVyICogaSArIHByZXZFdmVudC50aW1lO1xuXHQgICAgICAgICAgICB2YXIgcmFtcFZhbCA9IHRoaXMuX2V4cG9uZW50aWFsSW50ZXJwb2xhdGUocHJldkV2ZW50LnRpbWUsIHByZXZFdmVudC52YWx1ZSwgdGltZSwgdmFsdWUsIHNlZ1RpbWUpO1xuXHQgICAgICAgICAgICB0aGlzLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKHRoaXMuX3RvVW5pdHMocmFtcFZhbCksIHNlZ1RpbWUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiBSZXR1cm5zIHRoZSB0aWNrIHZhbHVlIGF0IHRoZSB0aW1lLiBUYWtlcyBpbnRvIGFjY291bnRcblx0XHQgKiBhbnkgYXV0b21hdGlvbiBjdXJ2ZXMgc2NoZWR1bGVkIG9uIHRoZSBzaWduYWwuXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKiBAcGFyYW0gIHtUaW1lfSB0aW1lIFRoZSB0aW1lIHRvIGdldCB0aGUgdGljayBjb3VudCBhdFxuXHRcdCAqIEByZXR1cm4ge1RpY2tzfSAgICAgIFRoZSBudW1iZXIgb2YgdGlja3Mgd2hpY2ggaGF2ZSBlbGFwc2VkIGF0IHRoZSB0aW1lXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgIGdpdmVuIGFueSBhdXRvbWF0aW9ucy5cblx0XHQgKi9cblx0ICAgIFRvbmUuVGlja1NpZ25hbC5wcm90b3R5cGUuX2dldFRpY2tVbnRpbEV2ZW50ID0gZnVuY3Rpb24gKGV2ZW50LCB0aW1lKSB7XG5cdCAgICAgICAgaWYgKGV2ZW50ID09PSBudWxsKSB7XG5cdCAgICAgICAgICAgIGV2ZW50ID0ge1xuXHQgICAgICAgICAgICAgICAgJ3RpY2tzJzogMCxcblx0ICAgICAgICAgICAgICAgICd0aW1lJzogMFxuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgdmFsMCA9IHRoaXMuZ2V0VmFsdWVBdFRpbWUoZXZlbnQudGltZSk7XG5cdCAgICAgICAgdmFyIHZhbDEgPSB0aGlzLmdldFZhbHVlQXRUaW1lKHRpbWUpO1xuXHQgICAgICAgIHJldHVybiAwLjUgKiAodGltZSAtIGV2ZW50LnRpbWUpICogKHZhbDAgKyB2YWwxKSArIGV2ZW50LnRpY2tzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqIFJldHVybnMgdGhlIHRpY2sgdmFsdWUgYXQgdGhlIHRpbWUuIFRha2VzIGludG8gYWNjb3VudFxuXHRcdCAqIGFueSBhdXRvbWF0aW9uIGN1cnZlcyBzY2hlZHVsZWQgb24gdGhlIHNpZ25hbC5cblx0XHQgKiBAcGFyYW0gIHtUaW1lfSB0aW1lIFRoZSB0aW1lIHRvIGdldCB0aGUgdGljayBjb3VudCBhdFxuXHRcdCAqIEByZXR1cm4ge1RpY2tzfSAgICAgIFRoZSBudW1iZXIgb2YgdGlja3Mgd2hpY2ggaGF2ZSBlbGFwc2VkIGF0IHRoZSB0aW1lXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgIGdpdmVuIGFueSBhdXRvbWF0aW9ucy5cblx0XHQgKi9cblx0ICAgIFRvbmUuVGlja1NpZ25hbC5wcm90b3R5cGUuZ2V0VGlja0F0VGltZSA9IGZ1bmN0aW9uICh0aW1lKSB7XG5cdCAgICAgICAgdGltZSA9IHRoaXMudG9TZWNvbmRzKHRpbWUpO1xuXHQgICAgICAgIHZhciBldmVudCA9IHRoaXMuX2V2ZW50cy5nZXQodGltZSk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuX2dldFRpY2tVbnRpbEV2ZW50KGV2ZW50LCB0aW1lKTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiBSZXR1cm4gdGhlIGVsYXBzZWQgdGltZSBvZiB0aGUgbnVtYmVyIG9mIHRpY2tzIGZyb20gdGhlIGdpdmVuIHRpbWVcblx0XHQgKiBAcGFyYW0ge1RpY2tzfSB0aWNrcyBUaGUgbnVtYmVyIG9mIHRpY2tzIHRvIGNhbGN1bGF0ZVxuXHRcdCAqIEBwYXJhbSAge1RpbWV9IHRpbWUgVGhlIHRpbWUgdG8gZ2V0IHRoZSBuZXh0IHRpY2sgZnJvbVxuXHRcdCAqIEByZXR1cm4ge1NlY29uZHN9IFRoZSBkdXJhdGlvbiBvZiB0aGUgbnVtYmVyIG9mIHRpY2tzIGZyb20gdGhlIGdpdmVuIHRpbWUgaW4gc2Vjb25kc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5UaWNrU2lnbmFsLnByb3RvdHlwZS5nZXREdXJhdGlvbk9mVGlja3MgPSBmdW5jdGlvbiAodGlja3MsIHRpbWUpIHtcblx0ICAgICAgICB0aW1lID0gdGhpcy50b1NlY29uZHModGltZSk7XG5cdCAgICAgICAgdmFyIGN1cnJlbnRUaWNrID0gdGhpcy5nZXRUaWNrQXRUaW1lKHRpbWUpO1xuXHQgICAgICAgIHJldHVybiB0aGlzLmdldFRpbWVPZlRpY2soY3VycmVudFRpY2sgKyB0aWNrcykgLSB0aW1lO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqIEdpdmVuIGEgdGljaywgcmV0dXJucyB0aGUgdGltZSB0aGF0IHRpY2sgb2NjdXJzIGF0LlxuXHRcdCAqIEBwYXJhbSAge1RpY2tzfSB0aWNrXG5cdFx0ICogQHJldHVybiB7VGltZX0gICAgICBUaGUgdGltZSB0aGF0IHRoZSB0aWNrIG9jY3Vycy5cblx0XHQgKi9cblx0ICAgIFRvbmUuVGlja1NpZ25hbC5wcm90b3R5cGUuZ2V0VGltZU9mVGljayA9IGZ1bmN0aW9uICh0aWNrKSB7XG5cdCAgICAgICAgdmFyIGJlZm9yZSA9IHRoaXMuX2V2ZW50cy5nZXQodGljaywgJ3RpY2tzJyk7XG5cdCAgICAgICAgdmFyIGFmdGVyID0gdGhpcy5fZXZlbnRzLmdldEFmdGVyKHRpY2ssICd0aWNrcycpO1xuXHQgICAgICAgIGlmIChiZWZvcmUgJiYgYmVmb3JlLnRpY2tzID09PSB0aWNrKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBiZWZvcmUudGltZTtcblx0ICAgICAgICB9IGVsc2UgaWYgKGJlZm9yZSAmJiBhZnRlciAmJiBhZnRlci50eXBlID09PSBUb25lLlRpbWVsaW5lU2lnbmFsLlR5cGUuTGluZWFyICYmIGJlZm9yZS52YWx1ZSAhPT0gYWZ0ZXIudmFsdWUpIHtcblx0ICAgICAgICAgICAgdmFyIHZhbDAgPSB0aGlzLmdldFZhbHVlQXRUaW1lKGJlZm9yZS50aW1lKTtcblx0ICAgICAgICAgICAgdmFyIHZhbDEgPSB0aGlzLmdldFZhbHVlQXRUaW1lKGFmdGVyLnRpbWUpO1xuXHQgICAgICAgICAgICB2YXIgZGVsdGEgPSAodmFsMSAtIHZhbDApIC8gKGFmdGVyLnRpbWUgLSBiZWZvcmUudGltZSk7XG5cdCAgICAgICAgICAgIHZhciBrID0gTWF0aC5zcXJ0KE1hdGgucG93KHZhbDAsIDIpIC0gMiAqIGRlbHRhICogKGJlZm9yZS50aWNrcyAtIHRpY2spKTtcblx0ICAgICAgICAgICAgdmFyIHNvbDEgPSAoLXZhbDAgKyBrKSAvIGRlbHRhO1xuXHQgICAgICAgICAgICB2YXIgc29sMiA9ICgtdmFsMCAtIGspIC8gZGVsdGE7XG5cdCAgICAgICAgICAgIHJldHVybiAoc29sMSA+IDAgPyBzb2wxIDogc29sMikgKyBiZWZvcmUudGltZTtcblx0ICAgICAgICB9IGVsc2UgaWYgKGJlZm9yZSkge1xuXHQgICAgICAgICAgICBpZiAoYmVmb3JlLnZhbHVlID09PSAwKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gSW5maW5pdHk7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gYmVmb3JlLnRpbWUgKyAodGljayAtIGJlZm9yZS50aWNrcykgLyBiZWZvcmUudmFsdWU7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICByZXR1cm4gdGljayAvIHRoaXMuX2luaXRpYWw7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLlRpY2tTaWduYWw7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyAgQSBUaW1lbGluZSBTdGF0ZS4gUHJvdmlkZXMgdGhlIG1ldGhvZHM6IDxjb2RlPnNldFN0YXRlQXRUaW1lKFwic3RhdGVcIiwgdGltZSk8L2NvZGU+XG5cdFx0ICogICAgICAgICAgYW5kIDxjb2RlPmdldFZhbHVlQXRUaW1lKHRpbWUpPC9jb2RlPi5cblx0XHQgKlxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZS5UaW1lbGluZX1cblx0XHQgKiAgQHBhcmFtIHtTdHJpbmd9IGluaXRpYWwgVGhlIGluaXRpYWwgc3RhdGUgb2YgdGhlIFRpbWVsaW5lU3RhdGUuIFxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICBEZWZhdWx0cyB0byA8Y29kZT51bmRlZmluZWQ8L2NvZGU+XG5cdFx0ICovXG5cdCAgICBUb25lLlRpbWVsaW5lU3RhdGUgPSBmdW5jdGlvbiAoaW5pdGlhbCkge1xuXHQgICAgICAgIFRvbmUuVGltZWxpbmUuY2FsbCh0aGlzKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgaW5pdGlhbCBzdGF0ZVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKiAgQHR5cGUge1N0cmluZ31cblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2luaXRpYWwgPSBpbml0aWFsO1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuVGltZWxpbmVTdGF0ZSwgVG9uZS5UaW1lbGluZSk7XG5cdCAgICAvKipcblx0XHQgKiAgUmV0dXJucyB0aGUgc2NoZWR1bGVkIHN0YXRlIHNjaGVkdWxlZCBiZWZvcmUgb3IgYXRcblx0XHQgKiAgdGhlIGdpdmVuIHRpbWUuXG5cdFx0ICogIEBwYXJhbSAge051bWJlcn0gIHRpbWUgIFRoZSB0aW1lIHRvIHF1ZXJ5LlxuXHRcdCAqICBAcmV0dXJuICB7U3RyaW5nfSAgVGhlIG5hbWUgb2YgdGhlIHN0YXRlIGlucHV0IGluIHNldFN0YXRlQXRUaW1lLlxuXHRcdCAqL1xuXHQgICAgVG9uZS5UaW1lbGluZVN0YXRlLnByb3RvdHlwZS5nZXRWYWx1ZUF0VGltZSA9IGZ1bmN0aW9uICh0aW1lKSB7XG5cdCAgICAgICAgdmFyIGV2ZW50ID0gdGhpcy5nZXQodGltZSk7XG5cdCAgICAgICAgaWYgKGV2ZW50ICE9PSBudWxsKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBldmVudC5zdGF0ZTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5faW5pdGlhbDtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIEFkZCBhIHN0YXRlIHRvIHRoZSB0aW1lbGluZS5cblx0XHQgKiAgQHBhcmFtICB7U3RyaW5nfSAgc3RhdGUgVGhlIG5hbWUgb2YgdGhlIHN0YXRlIHRvIHNldC5cblx0XHQgKiAgQHBhcmFtICB7TnVtYmVyfSAgdGltZSAgVGhlIHRpbWUgdG8gcXVlcnkuXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLlRpbWVsaW5lU3RhdGV9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuVGltZWxpbmVTdGF0ZS5wcm90b3R5cGUuc2V0U3RhdGVBdFRpbWUgPSBmdW5jdGlvbiAoc3RhdGUsIHRpbWUpIHtcblx0ICAgICAgICB0aGlzLmFkZCh7XG5cdCAgICAgICAgICAgICdzdGF0ZSc6IHN0YXRlLFxuXHQgICAgICAgICAgICAndGltZSc6IHRpbWVcblx0ICAgICAgICB9KTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVG9uZS5UaW1lbGluZVN0YXRlO1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgIEEgc2FtcGxlIGFjY3VyYXRlIGNsb2NrIHdoaWNoIHByb3ZpZGVzIGEgY2FsbGJhY2sgYXQgdGhlIGdpdmVuIHJhdGUuIFxuXHRcdCAqICAgICAgICAgIFdoaWxlIHRoZSBjYWxsYmFjayBpcyBub3Qgc2FtcGxlLWFjY3VyYXRlIChpdCBpcyBzdGlsbCBzdXNjZXB0aWJsZSB0b1xuXHRcdCAqICAgICAgICAgIGxvb3NlIEpTIHRpbWluZyksIHRoZSB0aW1lIHBhc3NlZCBpbiBhcyB0aGUgYXJndW1lbnQgdG8gdGhlIGNhbGxiYWNrXG5cdFx0ICogICAgICAgICAgaXMgcHJlY2lzZS4gRm9yIG1vc3QgYXBwbGljYXRpb25zLCBpdCBpcyBiZXR0ZXIgdG8gdXNlIFRvbmUuVHJhbnNwb3J0XG5cdFx0ICogICAgICAgICAgaW5zdGVhZCBvZiB0aGUgQ2xvY2sgYnkgaXRzZWxmIHNpbmNlIHlvdSBjYW4gc3luY2hyb25pemUgbXVsdGlwbGUgY2FsbGJhY2tzLlxuXHRcdCAqXG5cdFx0ICogXHRAY29uc3RydWN0b3Jcblx0XHQgKiAgQGV4dGVuZHMge1RvbmUuRW1pdHRlcn1cblx0XHQgKiBcdEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIFRoZSBjYWxsYmFjayB0byBiZSBpbnZva2VkIHdpdGggdGhlIHRpbWUgb2YgdGhlIGF1ZGlvIGV2ZW50XG5cdFx0ICogXHRAcGFyYW0ge0ZyZXF1ZW5jeX0gZnJlcXVlbmN5IFRoZSByYXRlIG9mIHRoZSBjYWxsYmFja1xuXHRcdCAqIFx0QGV4YW1wbGVcblx0XHQgKiAvL3RoZSBjYWxsYmFjayB3aWxsIGJlIGludm9rZWQgYXBwcm94aW1hdGVseSBvbmNlIGEgc2Vjb25kXG5cdFx0ICogLy9hbmQgd2lsbCBwcmludCB0aGUgdGltZSBleGFjdGx5IG9uY2UgYSBzZWNvbmQgYXBhcnQuXG5cdFx0ICogdmFyIGNsb2NrID0gbmV3IFRvbmUuQ2xvY2soZnVuY3Rpb24odGltZSl7XG5cdFx0ICogXHRjb25zb2xlLmxvZyh0aW1lKTtcblx0XHQgKiB9LCAxKTtcblx0XHQgKi9cblx0ICAgIFRvbmUuQ2xvY2sgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIG9wdGlvbnMgPSBUb25lLmRlZmF1bHRzKGFyZ3VtZW50cywgW1xuXHQgICAgICAgICAgICAnY2FsbGJhY2snLFxuXHQgICAgICAgICAgICAnZnJlcXVlbmN5J1xuXHQgICAgICAgIF0sIFRvbmUuQ2xvY2spO1xuXHQgICAgICAgIFRvbmUuRW1pdHRlci5jYWxsKHRoaXMpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBjYWxsYmFjayBmdW5jdGlvbiB0byBpbnZva2UgYXQgdGhlIHNjaGVkdWxlZCB0aWNrLlxuXHRcdFx0ICogIEB0eXBlICB7RnVuY3Rpb259XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmNhbGxiYWNrID0gb3B0aW9ucy5jYWxsYmFjaztcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgbmV4dCB0aW1lIHRoZSBjYWxsYmFjayBpcyBzY2hlZHVsZWQuXG5cdFx0XHQgKiAgQHR5cGUge051bWJlcn1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fbmV4dFRpY2sgPSAwO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBsYXN0IHN0YXRlIG9mIHRoZSBjbG9jay5cblx0XHRcdCAqICBAdHlwZSAge1N0YXRlfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9sYXN0U3RhdGUgPSBUb25lLlN0YXRlLlN0b3BwZWQ7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIHJhdGUgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHNob3VsZCBiZSBpbnZva2VkLiBcblx0XHRcdCAqICBAdHlwZSAge0JQTX1cblx0XHRcdCAqICBAc2lnbmFsXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmZyZXF1ZW5jeSA9IG5ldyBUb25lLlRpY2tTaWduYWwob3B0aW9ucy5mcmVxdWVuY3ksIFRvbmUuVHlwZS5GcmVxdWVuY3kpO1xuXHQgICAgICAgIHRoaXMuX3JlYWRPbmx5KCdmcmVxdWVuY3knKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgbnVtYmVyIG9mIHRpbWVzIHRoZSBjYWxsYmFjayB3YXMgaW52b2tlZC4gU3RhcnRzIGNvdW50aW5nIGF0IDBcblx0XHRcdCAqICBhbmQgaW5jcmVtZW50cyBhZnRlciB0aGUgY2FsbGJhY2sgd2FzIGludm9rZWQuIFxuXHRcdFx0ICogIEB0eXBlIHtUaWNrc31cblx0XHRcdCAqICBAcmVhZE9ubHlcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMudGlja3MgPSAwO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBzdGF0ZSB0aW1lbGluZVxuXHRcdFx0ICogIEB0eXBlIHtUb25lLlRpbWVsaW5lU3RhdGV9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX3N0YXRlID0gbmV3IFRvbmUuVGltZWxpbmVTdGF0ZShUb25lLlN0YXRlLlN0b3BwZWQpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBsb29wIGZ1bmN0aW9uIGJvdW5kIHRvIGl0cyBjb250ZXh0LiBcblx0XHRcdCAqICBUaGlzIGlzIG5lY2Vzc2FyeSB0byByZW1vdmUgdGhlIGV2ZW50IGluIHRoZSBlbmQuXG5cdFx0XHQgKiAgQHR5cGUge0Z1bmN0aW9ufVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9ib3VuZExvb3AgPSB0aGlzLl9sb29wLmJpbmQodGhpcyk7XG5cdCAgICAgICAgLy9iaW5kIGEgY2FsbGJhY2sgdG8gdGhlIHdvcmtlciB0aHJlYWRcblx0ICAgICAgICB0aGlzLmNvbnRleHQub24oJ3RpY2snLCB0aGlzLl9ib3VuZExvb3ApO1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuQ2xvY2ssIFRvbmUuRW1pdHRlcik7XG5cdCAgICAvKipcblx0XHQgKiAgVGhlIGRlZmF1bHRzXG5cdFx0ICogIEBjb25zdFxuXHRcdCAqICBAdHlwZSAge09iamVjdH1cblx0XHQgKi9cblx0ICAgIFRvbmUuQ2xvY2suZGVmYXVsdHMgPSB7XG5cdCAgICAgICAgJ2NhbGxiYWNrJzogVG9uZS5ub09wLFxuXHQgICAgICAgICdmcmVxdWVuY3knOiAxXG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFJldHVybnMgdGhlIHBsYXliYWNrIHN0YXRlIG9mIHRoZSBzb3VyY2UsIGVpdGhlciBcInN0YXJ0ZWRcIiwgXCJzdG9wcGVkXCIgb3IgXCJwYXVzZWRcIi5cblx0XHQgKiAgQHR5cGUge1RvbmUuU3RhdGV9XG5cdFx0ICogIEByZWFkT25seVxuXHRcdCAqICBAbWVtYmVyT2YgVG9uZS5DbG9jayNcblx0XHQgKiAgQG5hbWUgc3RhdGVcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkNsb2NrLnByb3RvdHlwZSwgJ3N0YXRlJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fc3RhdGUuZ2V0VmFsdWVBdFRpbWUodGhpcy5ub3coKSk7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgU3RhcnQgdGhlIGNsb2NrIGF0IHRoZSBnaXZlbiB0aW1lLiBPcHRpb25hbGx5IHBhc3MgaW4gYW4gb2Zmc2V0XG5cdFx0ICogIG9mIHdoZXJlIHRvIHN0YXJ0IHRoZSB0aWNrIGNvdW50ZXIgZnJvbS5cblx0XHQgKiAgQHBhcmFtICB7VGltZT19ICB0aW1lICAgIFRoZSB0aW1lIHRoZSBjbG9jayBzaG91bGQgc3RhcnRcblx0XHQgKiAgQHBhcmFtICB7VGlja3M9fSAgb2Zmc2V0ICBXaGVyZSB0aGUgdGljayBjb3VudGVyIHN0YXJ0cyBjb3VudGluZyBmcm9tLlxuXHRcdCAqICBAcmV0dXJuICB7VG9uZS5DbG9ja30gIHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuQ2xvY2sucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24gKHRpbWUsIG9mZnNldCkge1xuXHQgICAgICAgIHRpbWUgPSB0aGlzLnRvU2Vjb25kcyh0aW1lKTtcblx0ICAgICAgICBpZiAodGhpcy5fc3RhdGUuZ2V0VmFsdWVBdFRpbWUodGltZSkgIT09IFRvbmUuU3RhdGUuU3RhcnRlZCkge1xuXHQgICAgICAgICAgICB0aGlzLl9zdGF0ZS5zZXRTdGF0ZUF0VGltZShUb25lLlN0YXRlLlN0YXJ0ZWQsIHRpbWUpO1xuXHQgICAgICAgICAgICB0aGlzLl9zdGF0ZS5nZXQodGltZSkub2Zmc2V0ID0gb2Zmc2V0O1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgU3RvcCB0aGUgY2xvY2suIFN0b3BwaW5nIHRoZSBjbG9jayByZXNldHMgdGhlIHRpY2sgY291bnRlciB0byAwLlxuXHRcdCAqICBAcGFyYW0ge1RpbWV9IFt0aW1lPW5vd10gVGhlIHRpbWUgd2hlbiB0aGUgY2xvY2sgc2hvdWxkIHN0b3AuXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLkNsb2NrfSB0aGlzXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogY2xvY2suc3RvcCgpO1xuXHRcdCAqL1xuXHQgICAgVG9uZS5DbG9jay5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICh0aW1lKSB7XG5cdCAgICAgICAgdGltZSA9IHRoaXMudG9TZWNvbmRzKHRpbWUpO1xuXHQgICAgICAgIHRoaXMuX3N0YXRlLmNhbmNlbCh0aW1lKTtcblx0ICAgICAgICB0aGlzLl9zdGF0ZS5zZXRTdGF0ZUF0VGltZShUb25lLlN0YXRlLlN0b3BwZWQsIHRpbWUpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBQYXVzZSB0aGUgY2xvY2suIFBhdXNpbmcgZG9lcyBub3QgcmVzZXQgdGhlIHRpY2sgY291bnRlci5cblx0XHQgKiAgQHBhcmFtIHtUaW1lfSBbdGltZT1ub3ddIFRoZSB0aW1lIHdoZW4gdGhlIGNsb2NrIHNob3VsZCBzdG9wLlxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5DbG9ja30gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5DbG9jay5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiAodGltZSkge1xuXHQgICAgICAgIHRpbWUgPSB0aGlzLnRvU2Vjb25kcyh0aW1lKTtcblx0ICAgICAgICBpZiAodGhpcy5fc3RhdGUuZ2V0VmFsdWVBdFRpbWUodGltZSkgPT09IFRvbmUuU3RhdGUuU3RhcnRlZCkge1xuXHQgICAgICAgICAgICB0aGlzLl9zdGF0ZS5zZXRTdGF0ZUF0VGltZShUb25lLlN0YXRlLlBhdXNlZCwgdGltZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgc2NoZWR1bGluZyBsb29wLlxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5DbG9jay5wcm90b3R5cGUuX2xvb3AgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgLy90aGUgZW5kIG9mIHRoZSB1cGRhdGUgaW50ZXJ2YWxcblx0ICAgICAgICB2YXIgZW5kVGltZSA9IHRoaXMubm93KCkgKyB0aGlzLmNvbnRleHQudXBkYXRlSW50ZXJ2YWw7XG5cdCAgICAgICAgLy90aGUgY3VycmVudCBldmVudCBhdCB0aGUgdGltZSBvZiB0aGUgbG9vcFxuXHQgICAgICAgIHZhciBldmVudCA9IHRoaXMuX3N0YXRlLmdldChlbmRUaW1lKTtcblx0ICAgICAgICBpZiAoZXZlbnQpIHtcblx0ICAgICAgICAgICAgLy9zdGF0ZSBjaGFuZ2UgZXZlbnRzXG5cdCAgICAgICAgICAgIGlmIChldmVudC5zdGF0ZSAhPT0gdGhpcy5fbGFzdFN0YXRlKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9sYXN0U3RhdGUgPSBldmVudC5zdGF0ZTtcblx0ICAgICAgICAgICAgICAgIHN3aXRjaCAoZXZlbnQuc3RhdGUpIHtcblx0ICAgICAgICAgICAgICAgIGNhc2UgVG9uZS5TdGF0ZS5TdGFydGVkOlxuXHQgICAgICAgICAgICAgICAgICAgIGlmICghVG9uZS5pc1VuZGVmKGV2ZW50Lm9mZnNldCkpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50aWNrcyA9IGV2ZW50Lm9mZnNldDtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5fbmV4dFRpY2sgPSBldmVudC50aW1lO1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnc3RhcnQnLCBldmVudC50aW1lLCB0aGlzLnRpY2tzKTtcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgICAgIGNhc2UgVG9uZS5TdGF0ZS5TdG9wcGVkOlxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMudGlja3MgPSAwO1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnc3RvcCcsIGV2ZW50LnRpbWUpO1xuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICAgICAgY2FzZSBUb25lLlN0YXRlLlBhdXNlZDpcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ3BhdXNlJywgZXZlbnQudGltZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgLy9hbGwgdGhlIHRpY2sgZXZlbnRzXG5cdCAgICAgICAgICAgIHdoaWxlIChlbmRUaW1lID4gdGhpcy5fbmV4dFRpY2sgJiYgdGhpcy5fc3RhdGUpIHtcblx0ICAgICAgICAgICAgICAgIHZhciB0aWNrVGltZSA9IHRoaXMuX25leHRUaWNrO1xuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMuZnJlcXVlbmN5KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5fbmV4dFRpY2sgKz0gdGhpcy5mcmVxdWVuY3kuZ2V0RHVyYXRpb25PZlRpY2tzKDEsIHRoaXMuX25leHRUaWNrKTtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnQuc3RhdGUgPT09IFRvbmUuU3RhdGUuU3RhcnRlZCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jYWxsYmFjayh0aWNrVGltZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRpY2tzKys7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudGlja3MrKztcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGU7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFJldHVybnMgdGhlIHNjaGVkdWxlZCBzdGF0ZSBhdCB0aGUgZ2l2ZW4gdGltZS5cblx0XHQgKiAgQHBhcmFtICB7VGltZX0gIHRpbWUgIFRoZSB0aW1lIHRvIHF1ZXJ5LlxuXHRcdCAqICBAcmV0dXJuICB7U3RyaW5nfSAgVGhlIG5hbWUgb2YgdGhlIHN0YXRlIGlucHV0IGluIHNldFN0YXRlQXRUaW1lLlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIGNsb2NrLnN0YXJ0KFwiKzAuMVwiKTtcblx0XHQgKiBjbG9jay5nZXRTdGF0ZUF0VGltZShcIiswLjFcIik7IC8vcmV0dXJucyBcInN0YXJ0ZWRcIlxuXHRcdCAqL1xuXHQgICAgVG9uZS5DbG9jay5wcm90b3R5cGUuZ2V0U3RhdGVBdFRpbWUgPSBmdW5jdGlvbiAodGltZSkge1xuXHQgICAgICAgIHRpbWUgPSB0aGlzLnRvU2Vjb25kcyh0aW1lKTtcblx0ICAgICAgICByZXR1cm4gdGhpcy5fc3RhdGUuZ2V0VmFsdWVBdFRpbWUodGltZSk7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIENsZWFuIHVwXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLkNsb2NrfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkNsb2NrLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuRW1pdHRlci5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuY29udGV4dC5vZmYoJ3RpY2snLCB0aGlzLl9ib3VuZExvb3ApO1xuXHQgICAgICAgIHRoaXMuX3dyaXRhYmxlKCdmcmVxdWVuY3knKTtcblx0ICAgICAgICB0aGlzLmZyZXF1ZW5jeS5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5mcmVxdWVuY3kgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX2JvdW5kTG9vcCA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fbmV4dFRpY2sgPSBJbmZpbml0eTtcblx0ICAgICAgICB0aGlzLmNhbGxiYWNrID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9zdGF0ZS5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fc3RhdGUgPSBudWxsO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLkNsb2NrO1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgU2ltaWxhciB0byBUb25lLlRpbWVsaW5lLCBidXQgYWxsIGV2ZW50cyByZXByZXNlbnRcblx0XHQgKiAgICAgICAgIGludGVydmFscyB3aXRoIGJvdGggXCJ0aW1lXCIgYW5kIFwiZHVyYXRpb25cIiB0aW1lcy4gVGhlIFxuXHRcdCAqICAgICAgICAgZXZlbnRzIGFyZSBwbGFjZWQgaW4gYSB0cmVlIHN0cnVjdHVyZSBvcHRpbWl6ZWRcblx0XHQgKiAgICAgICAgIGZvciBxdWVyeWluZyBhbiBpbnRlcnNlY3Rpb24gcG9pbnQgd2l0aCB0aGUgdGltZWxpbmVcblx0XHQgKiAgICAgICAgIGV2ZW50cy4gSW50ZXJuYWxseSB1c2VzIGFuIFtJbnRlcnZhbCBUcmVlXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JbnRlcnZhbF90cmVlKVxuXHRcdCAqICAgICAgICAgdG8gcmVwcmVzZW50IHRoZSBkYXRhLlxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZX1cblx0XHQgKi9cblx0ICAgIFRvbmUuSW50ZXJ2YWxUaW1lbGluZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLmNhbGwodGhpcyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIHJvb3Qgbm9kZSBvZiB0aGUgaW50ZXZhbCB0cmVlXG5cdFx0XHQgKiAgQHR5cGUgIHtJbnRlcnZhbE5vZGV9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX3Jvb3QgPSBudWxsO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIEtlZXAgdHJhY2sgb2YgdGhlIGxlbmd0aCBvZiB0aGUgdGltZWxpbmUuXG5cdFx0XHQgKiAgQHR5cGUgIHtOdW1iZXJ9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2xlbmd0aCA9IDA7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5JbnRlcnZhbFRpbWVsaW5lKTtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgZXZlbnQgdG8gYWRkIHRvIHRoZSB0aW1lbGluZS4gQWxsIGV2ZW50cyBtdXN0IFxuXHRcdCAqICBoYXZlIGEgdGltZSBhbmQgZHVyYXRpb24gdmFsdWVcblx0XHQgKiAgQHBhcmFtICB7T2JqZWN0fSAgZXZlbnQgIFRoZSBldmVudCB0byBhZGQgdG8gdGhlIHRpbWVsaW5lXG5cdFx0ICogIEByZXR1cm4gIHtUb25lLkludGVydmFsVGltZWxpbmV9ICB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkludGVydmFsVGltZWxpbmUucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChldmVudCkge1xuXHQgICAgICAgIGlmIChUb25lLmlzVW5kZWYoZXZlbnQudGltZSkgfHwgVG9uZS5pc1VuZGVmKGV2ZW50LmR1cmF0aW9uKSkge1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RvbmUuSW50ZXJ2YWxUaW1lbGluZTogZXZlbnRzIG11c3QgaGF2ZSB0aW1lIGFuZCBkdXJhdGlvbiBwYXJhbWV0ZXJzJyk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBub2RlID0gbmV3IEludGVydmFsTm9kZShldmVudC50aW1lLCBldmVudC50aW1lICsgZXZlbnQuZHVyYXRpb24sIGV2ZW50KTtcblx0ICAgICAgICBpZiAodGhpcy5fcm9vdCA9PT0gbnVsbCkge1xuXHQgICAgICAgICAgICB0aGlzLl9yb290ID0gbm9kZTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICB0aGlzLl9yb290Lmluc2VydChub2RlKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdGhpcy5fbGVuZ3RoKys7XG5cdCAgICAgICAgLy8gUmVzdHJ1Y3R1cmUgdHJlZSB0byBiZSBiYWxhbmNlZFxuXHQgICAgICAgIHdoaWxlIChub2RlICE9PSBudWxsKSB7XG5cdCAgICAgICAgICAgIG5vZGUudXBkYXRlSGVpZ2h0KCk7XG5cdCAgICAgICAgICAgIG5vZGUudXBkYXRlTWF4KCk7XG5cdCAgICAgICAgICAgIHRoaXMuX3JlYmFsYW5jZShub2RlKTtcblx0ICAgICAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50O1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgUmVtb3ZlIGFuIGV2ZW50IGZyb20gdGhlIHRpbWVsaW5lLlxuXHRcdCAqICBAcGFyYW0gIHtPYmplY3R9ICBldmVudCAgVGhlIGV2ZW50IHRvIHJlbW92ZSBmcm9tIHRoZSB0aW1lbGluZVxuXHRcdCAqICBAcmV0dXJuICB7VG9uZS5JbnRlcnZhbFRpbWVsaW5lfSAgdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5JbnRlcnZhbFRpbWVsaW5lLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblx0ICAgICAgICBpZiAodGhpcy5fcm9vdCAhPT0gbnVsbCkge1xuXHQgICAgICAgICAgICB2YXIgcmVzdWx0cyA9IFtdO1xuXHQgICAgICAgICAgICB0aGlzLl9yb290LnNlYXJjaChldmVudC50aW1lLCByZXN1bHRzKTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXN1bHRzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IHJlc3VsdHNbaV07XG5cdCAgICAgICAgICAgICAgICBpZiAobm9kZS5ldmVudCA9PT0gZXZlbnQpIHtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZW1vdmVOb2RlKG5vZGUpO1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuX2xlbmd0aC0tO1xuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgbnVtYmVyIG9mIGl0ZW1zIGluIHRoZSB0aW1lbGluZS5cblx0XHQgKiAgQHR5cGUge051bWJlcn1cblx0XHQgKiAgQG1lbWJlck9mIFRvbmUuSW50ZXJ2YWxUaW1lbGluZSNcblx0XHQgKiAgQG5hbWUgbGVuZ3RoXG5cdFx0ICogIEByZWFkT25seVxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuSW50ZXJ2YWxUaW1lbGluZS5wcm90b3R5cGUsICdsZW5ndGgnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9sZW5ndGg7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgUmVtb3ZlIGV2ZW50cyB3aG9zZSB0aW1lIHRpbWUgaXMgYWZ0ZXIgdGhlIGdpdmVuIHRpbWVcblx0XHQgKiAgQHBhcmFtICB7TnVtYmVyfSAgdGltZSAgVGhlIHRpbWUgdG8gcXVlcnkuXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLkludGVydmFsVGltZWxpbmV9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuSW50ZXJ2YWxUaW1lbGluZS5wcm90b3R5cGUuY2FuY2VsID0gZnVuY3Rpb24gKGFmdGVyKSB7XG5cdCAgICAgICAgdGhpcy5mb3JFYWNoQWZ0ZXIoYWZ0ZXIsIGZ1bmN0aW9uIChldmVudCkge1xuXHQgICAgICAgICAgICB0aGlzLnJlbW92ZShldmVudCk7XG5cdCAgICAgICAgfS5iaW5kKHRoaXMpKTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgU2V0IHRoZSByb290IG5vZGUgYXMgdGhlIGdpdmVuIG5vZGVcblx0XHQgKiAgQHBhcmFtIHtJbnRlcnZhbE5vZGV9IG5vZGVcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuSW50ZXJ2YWxUaW1lbGluZS5wcm90b3R5cGUuX3NldFJvb3QgPSBmdW5jdGlvbiAobm9kZSkge1xuXHQgICAgICAgIHRoaXMuX3Jvb3QgPSBub2RlO1xuXHQgICAgICAgIGlmICh0aGlzLl9yb290ICE9PSBudWxsKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3Jvb3QucGFyZW50ID0gbnVsbDtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFJlcGxhY2UgdGhlIHJlZmVyZW5jZXMgdG8gdGhlIG5vZGUgaW4gdGhlIG5vZGUncyBwYXJlbnRcblx0XHQgKiAgd2l0aCB0aGUgcmVwbGFjZW1lbnQgbm9kZS5cblx0XHQgKiAgQHBhcmFtICB7SW50ZXJ2YWxOb2RlfSAgbm9kZSAgICAgICAgXG5cdFx0ICogIEBwYXJhbSAge0ludGVydmFsTm9kZX0gIHJlcGxhY2VtZW50IFxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5JbnRlcnZhbFRpbWVsaW5lLnByb3RvdHlwZS5fcmVwbGFjZU5vZGVJblBhcmVudCA9IGZ1bmN0aW9uIChub2RlLCByZXBsYWNlbWVudCkge1xuXHQgICAgICAgIGlmIChub2RlLnBhcmVudCAhPT0gbnVsbCkge1xuXHQgICAgICAgICAgICBpZiAobm9kZS5pc0xlZnRDaGlsZCgpKSB7XG5cdCAgICAgICAgICAgICAgICBub2RlLnBhcmVudC5sZWZ0ID0gcmVwbGFjZW1lbnQ7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICBub2RlLnBhcmVudC5yaWdodCA9IHJlcGxhY2VtZW50O1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHRoaXMuX3JlYmFsYW5jZShub2RlLnBhcmVudCk7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgdGhpcy5fc2V0Um9vdChyZXBsYWNlbWVudCk7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBSZW1vdmUgdGhlIG5vZGUgZnJvbSB0aGUgdHJlZSBhbmQgcmVwbGFjZSBpdCB3aXRoIFxuXHRcdCAqICBhIHN1Y2Nlc3NvciB3aGljaCBmb2xsb3dzIHRoZSBzY2hlbWEuXG5cdFx0ICogIEBwYXJhbSAge0ludGVydmFsTm9kZX0gIG5vZGVcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuSW50ZXJ2YWxUaW1lbGluZS5wcm90b3R5cGUuX3JlbW92ZU5vZGUgPSBmdW5jdGlvbiAobm9kZSkge1xuXHQgICAgICAgIGlmIChub2RlLmxlZnQgPT09IG51bGwgJiYgbm9kZS5yaWdodCA9PT0gbnVsbCkge1xuXHQgICAgICAgICAgICB0aGlzLl9yZXBsYWNlTm9kZUluUGFyZW50KG5vZGUsIG51bGwpO1xuXHQgICAgICAgIH0gZWxzZSBpZiAobm9kZS5yaWdodCA9PT0gbnVsbCkge1xuXHQgICAgICAgICAgICB0aGlzLl9yZXBsYWNlTm9kZUluUGFyZW50KG5vZGUsIG5vZGUubGVmdCk7XG5cdCAgICAgICAgfSBlbHNlIGlmIChub2RlLmxlZnQgPT09IG51bGwpIHtcblx0ICAgICAgICAgICAgdGhpcy5fcmVwbGFjZU5vZGVJblBhcmVudChub2RlLCBub2RlLnJpZ2h0KTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICB2YXIgYmFsYW5jZSA9IG5vZGUuZ2V0QmFsYW5jZSgpO1xuXHQgICAgICAgICAgICB2YXIgcmVwbGFjZW1lbnQsIHRlbXA7XG5cdCAgICAgICAgICAgIGlmIChiYWxhbmNlID4gMCkge1xuXHQgICAgICAgICAgICAgICAgaWYgKG5vZGUubGVmdC5yaWdodCA9PT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJlcGxhY2VtZW50ID0gbm9kZS5sZWZ0O1xuXHQgICAgICAgICAgICAgICAgICAgIHJlcGxhY2VtZW50LnJpZ2h0ID0gbm9kZS5yaWdodDtcblx0ICAgICAgICAgICAgICAgICAgICB0ZW1wID0gcmVwbGFjZW1lbnQ7XG5cdCAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIHJlcGxhY2VtZW50ID0gbm9kZS5sZWZ0LnJpZ2h0O1xuXHQgICAgICAgICAgICAgICAgICAgIHdoaWxlIChyZXBsYWNlbWVudC5yaWdodCAhPT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXBsYWNlbWVudCA9IHJlcGxhY2VtZW50LnJpZ2h0O1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICByZXBsYWNlbWVudC5wYXJlbnQucmlnaHQgPSByZXBsYWNlbWVudC5sZWZ0O1xuXHQgICAgICAgICAgICAgICAgICAgIHRlbXAgPSByZXBsYWNlbWVudC5wYXJlbnQ7XG5cdCAgICAgICAgICAgICAgICAgICAgcmVwbGFjZW1lbnQubGVmdCA9IG5vZGUubGVmdDtcblx0ICAgICAgICAgICAgICAgICAgICByZXBsYWNlbWVudC5yaWdodCA9IG5vZGUucmlnaHQ7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICBpZiAobm9kZS5yaWdodC5sZWZ0ID09PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmVwbGFjZW1lbnQgPSBub2RlLnJpZ2h0O1xuXHQgICAgICAgICAgICAgICAgICAgIHJlcGxhY2VtZW50LmxlZnQgPSBub2RlLmxlZnQ7XG5cdCAgICAgICAgICAgICAgICAgICAgdGVtcCA9IHJlcGxhY2VtZW50O1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXBsYWNlbWVudCA9IG5vZGUucmlnaHQubGVmdDtcblx0ICAgICAgICAgICAgICAgICAgICB3aGlsZSAocmVwbGFjZW1lbnQubGVmdCAhPT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXBsYWNlbWVudCA9IHJlcGxhY2VtZW50LmxlZnQ7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIHJlcGxhY2VtZW50LnBhcmVudCA9IHJlcGxhY2VtZW50LnBhcmVudDtcblx0ICAgICAgICAgICAgICAgICAgICByZXBsYWNlbWVudC5wYXJlbnQubGVmdCA9IHJlcGxhY2VtZW50LnJpZ2h0O1xuXHQgICAgICAgICAgICAgICAgICAgIHRlbXAgPSByZXBsYWNlbWVudC5wYXJlbnQ7XG5cdCAgICAgICAgICAgICAgICAgICAgcmVwbGFjZW1lbnQubGVmdCA9IG5vZGUubGVmdDtcblx0ICAgICAgICAgICAgICAgICAgICByZXBsYWNlbWVudC5yaWdodCA9IG5vZGUucmlnaHQ7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgaWYgKG5vZGUucGFyZW50ICE9PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAobm9kZS5pc0xlZnRDaGlsZCgpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgbm9kZS5wYXJlbnQubGVmdCA9IHJlcGxhY2VtZW50O1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICBub2RlLnBhcmVudC5yaWdodCA9IHJlcGxhY2VtZW50O1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fc2V0Um9vdChyZXBsYWNlbWVudCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgLy8gdGhpcy5fcmVwbGFjZU5vZGVJblBhcmVudChub2RlLCByZXBsYWNlbWVudCk7XG5cdCAgICAgICAgICAgIHRoaXMuX3JlYmFsYW5jZSh0ZW1wKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgbm9kZS5kaXNwb3NlKCk7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFJvdGF0ZSB0aGUgdHJlZSB0byB0aGUgbGVmdFxuXHRcdCAqICBAcGFyYW0gIHtJbnRlcnZhbE5vZGV9ICBub2RlXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLkludGVydmFsVGltZWxpbmUucHJvdG90eXBlLl9yb3RhdGVMZWZ0ID0gZnVuY3Rpb24gKG5vZGUpIHtcblx0ICAgICAgICB2YXIgcGFyZW50ID0gbm9kZS5wYXJlbnQ7XG5cdCAgICAgICAgdmFyIGlzTGVmdENoaWxkID0gbm9kZS5pc0xlZnRDaGlsZCgpO1xuXHQgICAgICAgIC8vIE1ha2Ugbm9kZS5yaWdodCB0aGUgbmV3IHJvb3Qgb2YgdGhpcyBzdWIgdHJlZSAoaW5zdGVhZCBvZiBub2RlKVxuXHQgICAgICAgIHZhciBwaXZvdE5vZGUgPSBub2RlLnJpZ2h0O1xuXHQgICAgICAgIG5vZGUucmlnaHQgPSBwaXZvdE5vZGUubGVmdDtcblx0ICAgICAgICBwaXZvdE5vZGUubGVmdCA9IG5vZGU7XG5cdCAgICAgICAgaWYgKHBhcmVudCAhPT0gbnVsbCkge1xuXHQgICAgICAgICAgICBpZiAoaXNMZWZ0Q2hpbGQpIHtcblx0ICAgICAgICAgICAgICAgIHBhcmVudC5sZWZ0ID0gcGl2b3ROb2RlO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgcGFyZW50LnJpZ2h0ID0gcGl2b3ROb2RlO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgdGhpcy5fc2V0Um9vdChwaXZvdE5vZGUpO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgUm90YXRlIHRoZSB0cmVlIHRvIHRoZSByaWdodFxuXHRcdCAqICBAcGFyYW0gIHtJbnRlcnZhbE5vZGV9ICBub2RlXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLkludGVydmFsVGltZWxpbmUucHJvdG90eXBlLl9yb3RhdGVSaWdodCA9IGZ1bmN0aW9uIChub2RlKSB7XG5cdCAgICAgICAgdmFyIHBhcmVudCA9IG5vZGUucGFyZW50O1xuXHQgICAgICAgIHZhciBpc0xlZnRDaGlsZCA9IG5vZGUuaXNMZWZ0Q2hpbGQoKTtcblx0ICAgICAgICAvLyBNYWtlIG5vZGUubGVmdCB0aGUgbmV3IHJvb3Qgb2YgdGhpcyBzdWIgdHJlZSAoaW5zdGVhZCBvZiBub2RlKVxuXHQgICAgICAgIHZhciBwaXZvdE5vZGUgPSBub2RlLmxlZnQ7XG5cdCAgICAgICAgbm9kZS5sZWZ0ID0gcGl2b3ROb2RlLnJpZ2h0O1xuXHQgICAgICAgIHBpdm90Tm9kZS5yaWdodCA9IG5vZGU7XG5cdCAgICAgICAgaWYgKHBhcmVudCAhPT0gbnVsbCkge1xuXHQgICAgICAgICAgICBpZiAoaXNMZWZ0Q2hpbGQpIHtcblx0ICAgICAgICAgICAgICAgIHBhcmVudC5sZWZ0ID0gcGl2b3ROb2RlO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgcGFyZW50LnJpZ2h0ID0gcGl2b3ROb2RlO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgdGhpcy5fc2V0Um9vdChwaXZvdE5vZGUpO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgQmFsYW5jZSB0aGUgQlNUXG5cdFx0ICogIEBwYXJhbSAge0ludGVydmFsTm9kZX0gIG5vZGVcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuSW50ZXJ2YWxUaW1lbGluZS5wcm90b3R5cGUuX3JlYmFsYW5jZSA9IGZ1bmN0aW9uIChub2RlKSB7XG5cdCAgICAgICAgdmFyIGJhbGFuY2UgPSBub2RlLmdldEJhbGFuY2UoKTtcblx0ICAgICAgICBpZiAoYmFsYW5jZSA+IDEpIHtcblx0ICAgICAgICAgICAgaWYgKG5vZGUubGVmdC5nZXRCYWxhbmNlKCkgPCAwKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9yb3RhdGVMZWZ0KG5vZGUubGVmdCk7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9yb3RhdGVSaWdodChub2RlKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0gZWxzZSBpZiAoYmFsYW5jZSA8IC0xKSB7XG5cdCAgICAgICAgICAgIGlmIChub2RlLnJpZ2h0LmdldEJhbGFuY2UoKSA+IDApIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX3JvdGF0ZVJpZ2h0KG5vZGUucmlnaHQpO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fcm90YXRlTGVmdChub2RlKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgR2V0IGFuIGV2ZW50IHdob3NlIHRpbWUgYW5kIGR1cmF0aW9uIHNwYW4gdGhlIGdpdmUgdGltZS4gV2lsbFxuXHRcdCAqICByZXR1cm4gdGhlIG1hdGNoIHdob3NlIFwidGltZVwiIHZhbHVlIGlzIGNsb3Nlc3QgdG8gdGhlIGdpdmVuIHRpbWUuXG5cdFx0ICogIEBwYXJhbSAge09iamVjdH0gIGV2ZW50ICBUaGUgZXZlbnQgdG8gYWRkIHRvIHRoZSB0aW1lbGluZVxuXHRcdCAqICBAcmV0dXJuICB7T2JqZWN0fSAgVGhlIGV2ZW50IHdoaWNoIHNwYW5zIHRoZSBkZXNpcmVkIHRpbWVcblx0XHQgKi9cblx0ICAgIFRvbmUuSW50ZXJ2YWxUaW1lbGluZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKHRpbWUpIHtcblx0ICAgICAgICBpZiAodGhpcy5fcm9vdCAhPT0gbnVsbCkge1xuXHQgICAgICAgICAgICB2YXIgcmVzdWx0cyA9IFtdO1xuXHQgICAgICAgICAgICB0aGlzLl9yb290LnNlYXJjaCh0aW1lLCByZXN1bHRzKTtcblx0ICAgICAgICAgICAgaWYgKHJlc3VsdHMubGVuZ3RoID4gMCkge1xuXHQgICAgICAgICAgICAgICAgdmFyIG1heCA9IHJlc3VsdHNbMF07XG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IHJlc3VsdHMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0c1tpXS5sb3cgPiBtYXgubG93KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG1heCA9IHJlc3VsdHNbaV07XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIG1heC5ldmVudDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gbnVsbDtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgSXRlcmF0ZSBvdmVyIGV2ZXJ5dGhpbmcgaW4gdGhlIHRpbWVsaW5lLlxuXHRcdCAqICBAcGFyYW0gIHtGdW5jdGlvbn0gIGNhbGxiYWNrIFRoZSBjYWxsYmFjayB0byBpbnZva2Ugd2l0aCBldmVyeSBpdGVtXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLkludGVydmFsVGltZWxpbmV9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuSW50ZXJ2YWxUaW1lbGluZS5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuXHQgICAgICAgIGlmICh0aGlzLl9yb290ICE9PSBudWxsKSB7XG5cdCAgICAgICAgICAgIHZhciBhbGxOb2RlcyA9IFtdO1xuXHQgICAgICAgICAgICB0aGlzLl9yb290LnRyYXZlcnNlKGZ1bmN0aW9uIChub2RlKSB7XG5cdCAgICAgICAgICAgICAgICBhbGxOb2Rlcy5wdXNoKG5vZGUpO1xuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbGxOb2Rlcy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgdmFyIGV2ID0gYWxsTm9kZXNbaV0uZXZlbnQ7XG5cdCAgICAgICAgICAgICAgICBpZiAoZXYpIHtcblx0ICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhldik7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIEl0ZXJhdGUgb3ZlciBldmVyeXRoaW5nIGluIHRoZSBhcnJheSBpbiB3aGljaCB0aGUgZ2l2ZW4gdGltZVxuXHRcdCAqICBvdmVybGFwcyB3aXRoIHRoZSB0aW1lIGFuZCBkdXJhdGlvbiB0aW1lIG9mIHRoZSBldmVudC5cblx0XHQgKiAgQHBhcmFtICB7TnVtYmVyfSAgdGltZSBUaGUgdGltZSB0byBjaGVjayBpZiBpdGVtcyBhcmUgb3ZlcmxhcHBpbmdcblx0XHQgKiAgQHBhcmFtICB7RnVuY3Rpb259ICBjYWxsYmFjayBUaGUgY2FsbGJhY2sgdG8gaW52b2tlIHdpdGggZXZlcnkgaXRlbVxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5JbnRlcnZhbFRpbWVsaW5lfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkludGVydmFsVGltZWxpbmUucHJvdG90eXBlLmZvckVhY2hBdFRpbWUgPSBmdW5jdGlvbiAodGltZSwgY2FsbGJhY2spIHtcblx0ICAgICAgICBpZiAodGhpcy5fcm9vdCAhPT0gbnVsbCkge1xuXHQgICAgICAgICAgICB2YXIgcmVzdWx0cyA9IFtdO1xuXHQgICAgICAgICAgICB0aGlzLl9yb290LnNlYXJjaCh0aW1lLCByZXN1bHRzKTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IHJlc3VsdHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0ICAgICAgICAgICAgICAgIHZhciBldiA9IHJlc3VsdHNbaV0uZXZlbnQ7XG5cdCAgICAgICAgICAgICAgICBpZiAoZXYpIHtcblx0ICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhldik7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIEl0ZXJhdGUgb3ZlciBldmVyeXRoaW5nIGluIHRoZSBhcnJheSBpbiB3aGljaCB0aGUgdGltZSBpcyBncmVhdGVyXG5cdFx0ICogIHRoYW4gdGhlIGdpdmVuIHRpbWUuXG5cdFx0ICogIEBwYXJhbSAge051bWJlcn0gIHRpbWUgVGhlIHRpbWUgdG8gY2hlY2sgaWYgaXRlbXMgYXJlIGJlZm9yZVxuXHRcdCAqICBAcGFyYW0gIHtGdW5jdGlvbn0gIGNhbGxiYWNrIFRoZSBjYWxsYmFjayB0byBpbnZva2Ugd2l0aCBldmVyeSBpdGVtXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLkludGVydmFsVGltZWxpbmV9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuSW50ZXJ2YWxUaW1lbGluZS5wcm90b3R5cGUuZm9yRWFjaEFmdGVyID0gZnVuY3Rpb24gKHRpbWUsIGNhbGxiYWNrKSB7XG5cdCAgICAgICAgaWYgKHRoaXMuX3Jvb3QgIT09IG51bGwpIHtcblx0ICAgICAgICAgICAgdmFyIHJlc3VsdHMgPSBbXTtcblx0ICAgICAgICAgICAgdGhpcy5fcm9vdC5zZWFyY2hBZnRlcih0aW1lLCByZXN1bHRzKTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IHJlc3VsdHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0ICAgICAgICAgICAgICAgIHZhciBldiA9IHJlc3VsdHNbaV0uZXZlbnQ7XG5cdCAgICAgICAgICAgICAgICBjYWxsYmFjayhldik7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIENsZWFuIHVwXG5cdFx0ICogIEByZXR1cm4gIHtUb25lLkludGVydmFsVGltZWxpbmV9ICB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkludGVydmFsVGltZWxpbmUucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIGFsbE5vZGVzID0gW107XG5cdCAgICAgICAgaWYgKHRoaXMuX3Jvb3QgIT09IG51bGwpIHtcblx0ICAgICAgICAgICAgdGhpcy5fcm9vdC50cmF2ZXJzZShmdW5jdGlvbiAobm9kZSkge1xuXHQgICAgICAgICAgICAgICAgYWxsTm9kZXMucHVzaChub2RlKTtcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWxsTm9kZXMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgYWxsTm9kZXNbaV0uZGlzcG9zZSgpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBhbGxOb2RlcyA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fcm9vdCA9IG51bGw7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdCAgICAvL1x0SU5URVJWQUwgTk9ERSBIRUxQRVJcblx0ICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQgICAgLyoqXG5cdFx0ICogIFJlcHJlc2VudHMgYSBub2RlIGluIHRoZSBiaW5hcnkgc2VhcmNoIHRyZWUsIHdpdGggdGhlIGFkZGl0aW9uXG5cdFx0ICogIG9mIGEgXCJoaWdoXCIgdmFsdWUgd2hpY2gga2VlcHMgdHJhY2sgb2YgdGhlIGhpZ2hlc3QgdmFsdWUgb2Zcblx0XHQgKiAgaXRzIGNoaWxkcmVuLiBcblx0XHQgKiAgUmVmZXJlbmNlczogXG5cdFx0ICogIGh0dHBzOi8vYnJvb2tub3Zhay53b3JkcHJlc3MuY29tLzIwMTMvMTIvMDcvYXVnbWVudGVkLWludGVydmFsLXRyZWUtaW4tYy9cblx0XHQgKiAgaHR0cDovL3d3dy5taWYudnUubHQvfnZhbGRhcy9BTEdPUklUTUFJL0xJVEVSQVRVUkEvQ29ybWVuL0Nvcm1lbi5wZGZcblx0XHQgKiAgQHBhcmFtIHtOdW1iZXJ9IGxvd1xuXHRcdCAqICBAcGFyYW0ge051bWJlcn0gaGlnaFxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgdmFyIEludGVydmFsTm9kZSA9IGZ1bmN0aW9uIChsb3csIGhpZ2gsIGV2ZW50KSB7XG5cdCAgICAgICAgLy90aGUgZXZlbnQgY29udGFpbmVyXG5cdCAgICAgICAgdGhpcy5ldmVudCA9IGV2ZW50O1xuXHQgICAgICAgIC8vdGhlIGxvdyB2YWx1ZVxuXHQgICAgICAgIHRoaXMubG93ID0gbG93O1xuXHQgICAgICAgIC8vdGhlIGhpZ2ggdmFsdWVcblx0ICAgICAgICB0aGlzLmhpZ2ggPSBoaWdoO1xuXHQgICAgICAgIC8vdGhlIGhpZ2ggdmFsdWUgZm9yIHRoaXMgYW5kIGFsbCBjaGlsZCBub2Rlc1xuXHQgICAgICAgIHRoaXMubWF4ID0gdGhpcy5oaWdoO1xuXHQgICAgICAgIC8vdGhlIG5vZGVzIHRvIHRoZSBsZWZ0XG5cdCAgICAgICAgdGhpcy5fbGVmdCA9IG51bGw7XG5cdCAgICAgICAgLy90aGUgbm9kZXMgdG8gdGhlIHJpZ2h0XG5cdCAgICAgICAgdGhpcy5fcmlnaHQgPSBudWxsO1xuXHQgICAgICAgIC8vdGhlIHBhcmVudCBub2RlXG5cdCAgICAgICAgdGhpcy5wYXJlbnQgPSBudWxsO1xuXHQgICAgICAgIC8vdGhlIG51bWJlciBvZiBjaGlsZCBub2Rlc1xuXHQgICAgICAgIHRoaXMuaGVpZ2h0ID0gMDtcblx0ICAgIH07XG5cdCAgICAvKiogXG5cdFx0ICogIEluc2VydCBhIG5vZGUgaW50byB0aGUgY29ycmVjdCBzcG90IGluIHRoZSB0cmVlXG5cdFx0ICogIEBwYXJhbSAge0ludGVydmFsTm9kZX0gIG5vZGVcblx0XHQgKi9cblx0ICAgIEludGVydmFsTm9kZS5wcm90b3R5cGUuaW5zZXJ0ID0gZnVuY3Rpb24gKG5vZGUpIHtcblx0ICAgICAgICBpZiAobm9kZS5sb3cgPD0gdGhpcy5sb3cpIHtcblx0ICAgICAgICAgICAgaWYgKHRoaXMubGVmdCA9PT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5sZWZ0ID0gbm9kZTtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMubGVmdC5pbnNlcnQobm9kZSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICBpZiAodGhpcy5yaWdodCA9PT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5yaWdodCA9IG5vZGU7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLnJpZ2h0Lmluc2VydChub2RlKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgU2VhcmNoIHRoZSB0cmVlIGZvciBub2RlcyB3aGljaCBvdmVybGFwIFxuXHRcdCAqICB3aXRoIHRoZSBnaXZlbiBwb2ludFxuXHRcdCAqICBAcGFyYW0gIHtOdW1iZXJ9ICBwb2ludCAgVGhlIHBvaW50IHRvIHF1ZXJ5XG5cdFx0ICogIEBwYXJhbSAge0FycmF5fSAgcmVzdWx0cyAgVGhlIGFycmF5IHRvIHB1dCB0aGUgcmVzdWx0c1xuXHRcdCAqL1xuXHQgICAgSW50ZXJ2YWxOb2RlLnByb3RvdHlwZS5zZWFyY2ggPSBmdW5jdGlvbiAocG9pbnQsIHJlc3VsdHMpIHtcblx0ICAgICAgICAvLyBJZiBwIGlzIHRvIHRoZSByaWdodCBvZiB0aGUgcmlnaHRtb3N0IHBvaW50IG9mIGFueSBpbnRlcnZhbFxuXHQgICAgICAgIC8vIGluIHRoaXMgbm9kZSBhbmQgYWxsIGNoaWxkcmVuLCB0aGVyZSB3b24ndCBiZSBhbnkgbWF0Y2hlcy5cblx0ICAgICAgICBpZiAocG9pbnQgPiB0aGlzLm1heCkge1xuXHQgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8vIFNlYXJjaCBsZWZ0IGNoaWxkcmVuXG5cdCAgICAgICAgaWYgKHRoaXMubGVmdCAhPT0gbnVsbCkge1xuXHQgICAgICAgICAgICB0aGlzLmxlZnQuc2VhcmNoKHBvaW50LCByZXN1bHRzKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgLy8gQ2hlY2sgdGhpcyBub2RlXG5cdCAgICAgICAgaWYgKHRoaXMubG93IDw9IHBvaW50ICYmIHRoaXMuaGlnaCA+IHBvaW50KSB7XG5cdCAgICAgICAgICAgIHJlc3VsdHMucHVzaCh0aGlzKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgLy8gSWYgcCBpcyB0byB0aGUgbGVmdCBvZiB0aGUgdGltZSBvZiB0aGlzIGludGVydmFsLFxuXHQgICAgICAgIC8vIHRoZW4gaXQgY2FuJ3QgYmUgaW4gYW55IGNoaWxkIHRvIHRoZSByaWdodC5cblx0ICAgICAgICBpZiAodGhpcy5sb3cgPiBwb2ludCkge1xuXHQgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8vIFNlYXJjaCByaWdodCBjaGlsZHJlblxuXHQgICAgICAgIGlmICh0aGlzLnJpZ2h0ICE9PSBudWxsKSB7XG5cdCAgICAgICAgICAgIHRoaXMucmlnaHQuc2VhcmNoKHBvaW50LCByZXN1bHRzKTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFNlYXJjaCB0aGUgdHJlZSBmb3Igbm9kZXMgd2hpY2ggYXJlIGxlc3MgXG5cdFx0ICogIHRoYW4gdGhlIGdpdmVuIHBvaW50XG5cdFx0ICogIEBwYXJhbSAge051bWJlcn0gIHBvaW50ICBUaGUgcG9pbnQgdG8gcXVlcnlcblx0XHQgKiAgQHBhcmFtICB7QXJyYXl9ICByZXN1bHRzICBUaGUgYXJyYXkgdG8gcHV0IHRoZSByZXN1bHRzXG5cdFx0ICovXG5cdCAgICBJbnRlcnZhbE5vZGUucHJvdG90eXBlLnNlYXJjaEFmdGVyID0gZnVuY3Rpb24gKHBvaW50LCByZXN1bHRzKSB7XG5cdCAgICAgICAgLy8gQ2hlY2sgdGhpcyBub2RlXG5cdCAgICAgICAgaWYgKHRoaXMubG93ID49IHBvaW50KSB7XG5cdCAgICAgICAgICAgIHJlc3VsdHMucHVzaCh0aGlzKTtcblx0ICAgICAgICAgICAgaWYgKHRoaXMubGVmdCAhPT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5sZWZ0LnNlYXJjaEFmdGVyKHBvaW50LCByZXN1bHRzKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICAvLyBzZWFyY2ggdGhlIHJpZ2h0IHNpZGVcblx0ICAgICAgICBpZiAodGhpcy5yaWdodCAhPT0gbnVsbCkge1xuXHQgICAgICAgICAgICB0aGlzLnJpZ2h0LnNlYXJjaEFmdGVyKHBvaW50LCByZXN1bHRzKTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIEludm9rZSB0aGUgY2FsbGJhY2sgb24gdGhpcyBlbGVtZW50IGFuZCBib3RoIGl0J3MgYnJhbmNoZXNcblx0XHQgKiAgQHBhcmFtICB7RnVuY3Rpb259ICBjYWxsYmFja1xuXHRcdCAqL1xuXHQgICAgSW50ZXJ2YWxOb2RlLnByb3RvdHlwZS50cmF2ZXJzZSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuXHQgICAgICAgIGNhbGxiYWNrKHRoaXMpO1xuXHQgICAgICAgIGlmICh0aGlzLmxlZnQgIT09IG51bGwpIHtcblx0ICAgICAgICAgICAgdGhpcy5sZWZ0LnRyYXZlcnNlKGNhbGxiYWNrKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKHRoaXMucmlnaHQgIT09IG51bGwpIHtcblx0ICAgICAgICAgICAgdGhpcy5yaWdodC50cmF2ZXJzZShjYWxsYmFjayk7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBVcGRhdGUgdGhlIGhlaWdodCBvZiB0aGUgbm9kZVxuXHRcdCAqL1xuXHQgICAgSW50ZXJ2YWxOb2RlLnByb3RvdHlwZS51cGRhdGVIZWlnaHQgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgaWYgKHRoaXMubGVmdCAhPT0gbnVsbCAmJiB0aGlzLnJpZ2h0ICE9PSBudWxsKSB7XG5cdCAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gTWF0aC5tYXgodGhpcy5sZWZ0LmhlaWdodCwgdGhpcy5yaWdodC5oZWlnaHQpICsgMTtcblx0ICAgICAgICB9IGVsc2UgaWYgKHRoaXMucmlnaHQgIT09IG51bGwpIHtcblx0ICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSB0aGlzLnJpZ2h0LmhlaWdodCArIDE7XG5cdCAgICAgICAgfSBlbHNlIGlmICh0aGlzLmxlZnQgIT09IG51bGwpIHtcblx0ICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSB0aGlzLmxlZnQuaGVpZ2h0ICsgMTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICB0aGlzLmhlaWdodCA9IDA7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBVcGRhdGUgdGhlIGhlaWdodCBvZiB0aGUgbm9kZVxuXHRcdCAqL1xuXHQgICAgSW50ZXJ2YWxOb2RlLnByb3RvdHlwZS51cGRhdGVNYXggPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdGhpcy5tYXggPSB0aGlzLmhpZ2g7XG5cdCAgICAgICAgaWYgKHRoaXMubGVmdCAhPT0gbnVsbCkge1xuXHQgICAgICAgICAgICB0aGlzLm1heCA9IE1hdGgubWF4KHRoaXMubWF4LCB0aGlzLmxlZnQubWF4KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKHRoaXMucmlnaHQgIT09IG51bGwpIHtcblx0ICAgICAgICAgICAgdGhpcy5tYXggPSBNYXRoLm1heCh0aGlzLm1heCwgdGhpcy5yaWdodC5tYXgpO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgVGhlIGJhbGFuY2UgaXMgaG93IHRoZSBsZWFmcyBhcmUgZGlzdHJpYnV0ZWQgb24gdGhlIG5vZGVcblx0XHQgKiAgQHJldHVybiAge051bWJlcn0gIE5lZ2F0aXZlIG51bWJlcnMgYXJlIGJhbGFuY2VkIHRvIHRoZSByaWdodFxuXHRcdCAqL1xuXHQgICAgSW50ZXJ2YWxOb2RlLnByb3RvdHlwZS5nZXRCYWxhbmNlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBiYWxhbmNlID0gMDtcblx0ICAgICAgICBpZiAodGhpcy5sZWZ0ICE9PSBudWxsICYmIHRoaXMucmlnaHQgIT09IG51bGwpIHtcblx0ICAgICAgICAgICAgYmFsYW5jZSA9IHRoaXMubGVmdC5oZWlnaHQgLSB0aGlzLnJpZ2h0LmhlaWdodDtcblx0ICAgICAgICB9IGVsc2UgaWYgKHRoaXMubGVmdCAhPT0gbnVsbCkge1xuXHQgICAgICAgICAgICBiYWxhbmNlID0gdGhpcy5sZWZ0LmhlaWdodCArIDE7XG5cdCAgICAgICAgfSBlbHNlIGlmICh0aGlzLnJpZ2h0ICE9PSBudWxsKSB7XG5cdCAgICAgICAgICAgIGJhbGFuY2UgPSAtKHRoaXMucmlnaHQuaGVpZ2h0ICsgMSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBiYWxhbmNlO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBAcmV0dXJucyB7Qm9vbGVhbn0gdHJ1ZSBpZiB0aGlzIG5vZGUgaXMgdGhlIGxlZnQgY2hpbGRcblx0XHQgKiAgb2YgaXRzIHBhcmVudFxuXHRcdCAqL1xuXHQgICAgSW50ZXJ2YWxOb2RlLnByb3RvdHlwZS5pc0xlZnRDaGlsZCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQgIT09IG51bGwgJiYgdGhpcy5wYXJlbnQubGVmdCA9PT0gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgZ2V0L3NldCB0aGUgbGVmdCBub2RlXG5cdFx0ICogIEB0eXBlIHtJbnRlcnZhbE5vZGV9XG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSW50ZXJ2YWxOb2RlLnByb3RvdHlwZSwgJ2xlZnQnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9sZWZ0O1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAobm9kZSkge1xuXHQgICAgICAgICAgICB0aGlzLl9sZWZ0ID0gbm9kZTtcblx0ICAgICAgICAgICAgaWYgKG5vZGUgIT09IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgIG5vZGUucGFyZW50ID0gdGhpcztcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB0aGlzLnVwZGF0ZUhlaWdodCgpO1xuXHQgICAgICAgICAgICB0aGlzLnVwZGF0ZU1heCgpO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIGdldC9zZXQgdGhlIHJpZ2h0IG5vZGVcblx0XHQgKiAgQHR5cGUge0ludGVydmFsTm9kZX1cblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShJbnRlcnZhbE5vZGUucHJvdG90eXBlLCAncmlnaHQnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9yaWdodDtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKG5vZGUpIHtcblx0ICAgICAgICAgICAgdGhpcy5fcmlnaHQgPSBub2RlO1xuXHQgICAgICAgICAgICBpZiAobm9kZSAhPT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgbm9kZS5wYXJlbnQgPSB0aGlzO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHRoaXMudXBkYXRlSGVpZ2h0KCk7XG5cdCAgICAgICAgICAgIHRoaXMudXBkYXRlTWF4KCk7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgbnVsbCBvdXQgcmVmZXJlbmNlcy5cblx0XHQgKi9cblx0ICAgIEludGVydmFsTm9kZS5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB0aGlzLnBhcmVudCA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fbGVmdCA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fcmlnaHQgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuZXZlbnQgPSBudWxsO1xuXHQgICAgfTtcblx0ICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQgICAgLy9cdEVORCBJTlRFUlZBTCBOT0RFIEhFTFBFUlxuXHQgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdCAgICByZXR1cm4gVG9uZS5JbnRlcnZhbFRpbWVsaW5lO1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgIFRyYW5zcG9ydCBmb3IgdGltaW5nIG11c2ljYWwgZXZlbnRzLlxuXHRcdCAqICAgICAgICAgIFN1cHBvcnRzIHRlbXBvIGN1cnZlcyBhbmQgdGltZSBjaGFuZ2VzLiBVbmxpa2UgYnJvd3Nlci1iYXNlZCB0aW1pbmcgKHNldEludGVydmFsLCByZXF1ZXN0QW5pbWF0aW9uRnJhbWUpXG5cdFx0ICogICAgICAgICAgVG9uZS5UcmFuc3BvcnQgdGltaW5nIGV2ZW50cyBwYXNzIGluIHRoZSBleGFjdCB0aW1lIG9mIHRoZSBzY2hlZHVsZWQgZXZlbnRcblx0XHQgKiAgICAgICAgICBpbiB0aGUgYXJndW1lbnQgb2YgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uLiBQYXNzIHRoYXQgdGltZSB2YWx1ZSB0byB0aGUgb2JqZWN0XG5cdFx0ICogICAgICAgICAgeW91J3JlIHNjaGVkdWxpbmcuIDxicj48YnI+XG5cdFx0ICogICAgICAgICAgQSBzaW5nbGUgdHJhbnNwb3J0IGlzIGNyZWF0ZWQgZm9yIHlvdSB3aGVuIHRoZSBsaWJyYXJ5IGlzIGluaXRpYWxpemVkLiBcblx0XHQgKiAgICAgICAgICA8YnI+PGJyPlxuXHRcdCAqICAgICAgICAgIFRoZSB0cmFuc3BvcnQgZW1pdHMgdGhlIGV2ZW50czogXCJzdGFydFwiLCBcInN0b3BcIiwgXCJwYXVzZVwiLCBhbmQgXCJsb29wXCIgd2hpY2ggYXJlXG5cdFx0ICogICAgICAgICAgY2FsbGVkIHdpdGggdGhlIHRpbWUgb2YgdGhhdCBldmVudCBhcyB0aGUgYXJndW1lbnQuIFxuXHRcdCAqXG5cdFx0ICogIEBleHRlbmRzIHtUb25lLkVtaXR0ZXJ9XG5cdFx0ICogIEBzaW5nbGV0b25cblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAvL3JlcGVhdGVkIGV2ZW50IGV2ZXJ5IDh0aCBub3RlXG5cdFx0ICogVG9uZS5UcmFuc3BvcnQuc2NoZWR1bGVSZXBlYXQoZnVuY3Rpb24odGltZSl7XG5cdFx0ICogXHQvL2RvIHNvbWV0aGluZyB3aXRoIHRoZSB0aW1lXG5cdFx0ICogfSwgXCI4blwiKTtcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAvL3NjaGVkdWxlIGFuIGV2ZW50IG9uIHRoZSAxNnRoIG1lYXN1cmVcblx0XHQgKiBUb25lLlRyYW5zcG9ydC5zY2hlZHVsZShmdW5jdGlvbih0aW1lKXtcblx0XHQgKiBcdC8vZG8gc29tZXRoaW5nIHdpdGggdGhlIHRpbWVcblx0XHQgKiB9LCBcIjE2OjA6MFwiKTtcblx0XHQgKi9cblx0ICAgIFRvbmUuVHJhbnNwb3J0ID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuRW1pdHRlci5jYWxsKHRoaXMpO1xuXHQgICAgICAgIFRvbmUuZ2V0Q29udGV4dChmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdCAgICAgICAgICAgIC8vXHRMT09QSU5HXG5cdCAgICAgICAgICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblx0ICAgICAgICAgICAgLyoqIFxuXHRcdFx0XHQgKiBcdElmIHRoZSB0cmFuc3BvcnQgbG9vcHMgb3Igbm90LlxuXHRcdFx0XHQgKiAgQHR5cGUge2Jvb2xlYW59XG5cdFx0XHRcdCAqL1xuXHQgICAgICAgICAgICB0aGlzLmxvb3AgPSBmYWxzZTtcblx0ICAgICAgICAgICAgLyoqIFxuXHRcdFx0XHQgKiBcdFRoZSBsb29wIHN0YXJ0IHBvc2l0aW9uIGluIHRpY2tzXG5cdFx0XHRcdCAqICBAdHlwZSB7VGlja3N9XG5cdFx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0XHQgKi9cblx0ICAgICAgICAgICAgdGhpcy5fbG9vcFN0YXJ0ID0gMDtcblx0ICAgICAgICAgICAgLyoqIFxuXHRcdFx0XHQgKiBcdFRoZSBsb29wIGVuZCBwb3NpdGlvbiBpbiB0aWNrc1xuXHRcdFx0XHQgKiAgQHR5cGUge1RpY2tzfVxuXHRcdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdFx0ICovXG5cdCAgICAgICAgICAgIHRoaXMuX2xvb3BFbmQgPSAwO1xuXHQgICAgICAgICAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQgICAgICAgICAgICAvL1x0Q0xPQ0svVEVNUE9cblx0ICAgICAgICAgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQgICAgICAgICAgICAvKipcblx0XHRcdFx0ICogIFB1bHNlcyBwZXIgcXVhcnRlciBpcyB0aGUgbnVtYmVyIG9mIHRpY2tzIHBlciBxdWFydGVyIG5vdGUuXG5cdFx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0XHQgKiAgQHR5cGUgIHtOdW1iZXJ9XG5cdFx0XHRcdCAqL1xuXHQgICAgICAgICAgICB0aGlzLl9wcHEgPSBUcmFuc3BvcnRDb25zdHJ1Y3Rvci5kZWZhdWx0cy5QUFE7XG5cdCAgICAgICAgICAgIC8qKlxuXHRcdFx0XHQgKiAgd2F0Y2hlcyB0aGUgbWFpbiBvc2NpbGxhdG9yIGZvciB0aW1pbmcgdGlja3Ncblx0XHRcdFx0ICogIGluaXRpYWxseSBzdGFydHMgYXQgMTIwYnBtXG5cdFx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0XHQgKiAgQHR5cGUge1RvbmUuQ2xvY2t9XG5cdFx0XHRcdCAqL1xuXHQgICAgICAgICAgICB0aGlzLl9jbG9jayA9IG5ldyBUb25lLkNsb2NrKHtcblx0ICAgICAgICAgICAgICAgICdjYWxsYmFjayc6IHRoaXMuX3Byb2Nlc3NUaWNrLmJpbmQodGhpcyksXG5cdCAgICAgICAgICAgICAgICAnZnJlcXVlbmN5JzogMFxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgdGhpcy5fYmluZENsb2NrRXZlbnRzKCk7XG5cdCAgICAgICAgICAgIC8qKlxuXHRcdFx0XHQgKiAgVGhlIEJlYXRzIFBlciBNaW51dGUgb2YgdGhlIFRyYW5zcG9ydC4gXG5cdFx0XHRcdCAqICBAdHlwZSB7QlBNfVxuXHRcdFx0XHQgKiAgQHNpZ25hbFxuXHRcdFx0XHQgKiAgQGV4YW1wbGVcblx0XHRcdFx0ICogVG9uZS5UcmFuc3BvcnQuYnBtLnZhbHVlID0gODA7XG5cdFx0XHRcdCAqIC8vcmFtcCB0aGUgYnBtIHRvIDEyMCBvdmVyIDEwIHNlY29uZHNcblx0XHRcdFx0ICogVG9uZS5UcmFuc3BvcnQuYnBtLnJhbXBUbygxMjAsIDEwKTtcblx0XHRcdFx0ICovXG5cdCAgICAgICAgICAgIHRoaXMuYnBtID0gdGhpcy5fY2xvY2suZnJlcXVlbmN5O1xuXHQgICAgICAgICAgICB0aGlzLmJwbS5fdG9Vbml0cyA9IHRoaXMuX3RvVW5pdHMuYmluZCh0aGlzKTtcblx0ICAgICAgICAgICAgdGhpcy5icG0uX2Zyb21Vbml0cyA9IHRoaXMuX2Zyb21Vbml0cy5iaW5kKHRoaXMpO1xuXHQgICAgICAgICAgICB0aGlzLmJwbS51bml0cyA9IFRvbmUuVHlwZS5CUE07XG5cdCAgICAgICAgICAgIHRoaXMuYnBtLnZhbHVlID0gVHJhbnNwb3J0Q29uc3RydWN0b3IuZGVmYXVsdHMuYnBtO1xuXHQgICAgICAgICAgICB0aGlzLl9yZWFkT25seSgnYnBtJyk7XG5cdCAgICAgICAgICAgIC8qKlxuXHRcdFx0XHQgKiAgVGhlIHRpbWUgc2lnbmF0dXJlLCBvciBtb3JlIGFjY3VyYXRlbHkgdGhlIG51bWVyYXRvclxuXHRcdFx0XHQgKiAgb2YgdGhlIHRpbWUgc2lnbmF0dXJlIG92ZXIgYSBkZW5vbWluYXRvciBvZiA0LiBcblx0XHRcdFx0ICogIEB0eXBlIHtOdW1iZXJ9XG5cdFx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0XHQgKi9cblx0ICAgICAgICAgICAgdGhpcy5fdGltZVNpZ25hdHVyZSA9IFRyYW5zcG9ydENvbnN0cnVjdG9yLmRlZmF1bHRzLnRpbWVTaWduYXR1cmU7XG5cdCAgICAgICAgICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdCAgICAgICAgICAgIC8vXHRUSU1FTElORSBFVkVOVFNcblx0ICAgICAgICAgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQgICAgICAgICAgICAvKipcblx0XHRcdFx0ICogIEFsbCB0aGUgZXZlbnRzIGluIGFuIG9iamVjdCB0byBrZWVwIHRyYWNrIGJ5IElEXG5cdFx0XHRcdCAqICBAdHlwZSB7T2JqZWN0fVxuXHRcdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdFx0ICovXG5cdCAgICAgICAgICAgIHRoaXMuX3NjaGVkdWxlZEV2ZW50cyA9IHt9O1xuXHQgICAgICAgICAgICAvKipcblx0XHRcdFx0ICogIFRoZSBldmVudCBJRCBjb3VudGVyXG5cdFx0XHRcdCAqICBAdHlwZSB7TnVtYmVyfVxuXHRcdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdFx0ICovXG5cdCAgICAgICAgICAgIHRoaXMuX2V2ZW50SUQgPSAwO1xuXHQgICAgICAgICAgICAvKipcblx0XHRcdFx0ICogXHRUaGUgc2NoZWR1bGVkIGV2ZW50cy5cblx0XHRcdFx0ICogIEB0eXBlIHtUb25lLlRpbWVsaW5lfVxuXHRcdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdFx0ICovXG5cdCAgICAgICAgICAgIHRoaXMuX3RpbWVsaW5lID0gbmV3IFRvbmUuVGltZWxpbmUoKTtcblx0ICAgICAgICAgICAgLyoqXG5cdFx0XHRcdCAqICBSZXBlYXRlZCBldmVudHNcblx0XHRcdFx0ICogIEB0eXBlIHtBcnJheX1cblx0XHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHRcdCAqL1xuXHQgICAgICAgICAgICB0aGlzLl9yZXBlYXRlZEV2ZW50cyA9IG5ldyBUb25lLkludGVydmFsVGltZWxpbmUoKTtcblx0ICAgICAgICAgICAgLyoqXG5cdFx0XHRcdCAqICBFdmVudHMgdGhhdCBvY2N1ciBvbmNlXG5cdFx0XHRcdCAqICBAdHlwZSB7QXJyYXl9XG5cdFx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0XHQgKi9cblx0ICAgICAgICAgICAgdGhpcy5fb25jZUV2ZW50cyA9IG5ldyBUb25lLlRpbWVsaW5lKCk7XG5cdCAgICAgICAgICAgIC8qKiBcblx0XHRcdFx0ICogIEFsbCBvZiB0aGUgc3luY2VkIFNpZ25hbHNcblx0XHRcdFx0ICogIEBwcml2YXRlIFxuXHRcdFx0XHQgKiAgQHR5cGUge0FycmF5fVxuXHRcdFx0XHQgKi9cblx0ICAgICAgICAgICAgdGhpcy5fc3luY2VkU2lnbmFscyA9IFtdO1xuXHQgICAgICAgICAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQgICAgICAgICAgICAvL1x0U1dJTkdcblx0ICAgICAgICAgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQgICAgICAgICAgICAvKipcblx0XHRcdFx0ICogIFRoZSBzdWJkaXZpc2lvbiBvZiB0aGUgc3dpbmdcblx0XHRcdFx0ICogIEB0eXBlICB7VGlja3N9XG5cdFx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0XHQgKi9cblx0ICAgICAgICAgICAgdGhpcy5fc3dpbmdUaWNrcyA9IFRyYW5zcG9ydENvbnN0cnVjdG9yLmRlZmF1bHRzLlBQUSAvIDI7XG5cdCAgICAgICAgICAgIC8vOG5cblx0ICAgICAgICAgICAgLyoqXG5cdFx0XHRcdCAqICBUaGUgc3dpbmcgYW1vdW50XG5cdFx0XHRcdCAqICBAdHlwZSB7Tm9ybWFsUmFuZ2V9XG5cdFx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0XHQgKi9cblx0ICAgICAgICAgICAgdGhpcy5fc3dpbmdBbW91bnQgPSAwO1xuXHQgICAgICAgIH0uYmluZCh0aGlzKSk7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5UcmFuc3BvcnQsIFRvbmUuRW1pdHRlcik7XG5cdCAgICAvKipcblx0XHQgKiAgdGhlIGRlZmF1bHRzXG5cdFx0ICogIEB0eXBlIHtPYmplY3R9XG5cdFx0ICogIEBjb25zdFxuXHRcdCAqICBAc3RhdGljXG5cdFx0ICovXG5cdCAgICBUb25lLlRyYW5zcG9ydC5kZWZhdWx0cyA9IHtcblx0ICAgICAgICAnYnBtJzogMTIwLFxuXHQgICAgICAgICdzd2luZyc6IDAsXG5cdCAgICAgICAgJ3N3aW5nU3ViZGl2aXNpb24nOiAnOG4nLFxuXHQgICAgICAgICd0aW1lU2lnbmF0dXJlJzogNCxcblx0ICAgICAgICAnbG9vcFN0YXJ0JzogMCxcblx0ICAgICAgICAnbG9vcEVuZCc6ICc0bScsXG5cdCAgICAgICAgJ1BQUSc6IDE5MlxuXHQgICAgfTtcblx0ICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblx0ICAgIC8vXHRUSUNLU1xuXHQgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQgICAgLyoqXG5cdFx0ICogIGNhbGxlZCBvbiBldmVyeSB0aWNrXG5cdFx0ICogIEBwYXJhbSAgIHtudW1iZXJ9IHRpY2tUaW1lIGNsb2NrIHJlbGF0aXZlIHRpY2sgdGltZVxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5UcmFuc3BvcnQucHJvdG90eXBlLl9wcm9jZXNzVGljayA9IGZ1bmN0aW9uICh0aWNrVGltZSkge1xuXHQgICAgICAgIHZhciB0aWNrcyA9IHRoaXMuX2Nsb2NrLnRpY2tzO1xuXHQgICAgICAgIC8vaGFuZGxlIHN3aW5nXG5cdCAgICAgICAgaWYgKHRoaXMuX3N3aW5nQW1vdW50ID4gMCAmJiB0aWNrcyAlIHRoaXMuX3BwcSAhPT0gMCAmJiAvL25vdCBvbiBhIGRvd25iZWF0XG5cdCAgICAgICAgICAgIHRpY2tzICUgKHRoaXMuX3N3aW5nVGlja3MgKiAyKSAhPT0gMCkge1xuXHQgICAgICAgICAgICAvL2FkZCBzb21lIHN3aW5nXG5cdCAgICAgICAgICAgIHZhciBwcm9ncmVzcyA9IHRpY2tzICUgKHRoaXMuX3N3aW5nVGlja3MgKiAyKSAvICh0aGlzLl9zd2luZ1RpY2tzICogMik7XG5cdCAgICAgICAgICAgIHZhciBhbW91bnQgPSBNYXRoLnNpbihwcm9ncmVzcyAqIE1hdGguUEkpICogdGhpcy5fc3dpbmdBbW91bnQ7XG5cdCAgICAgICAgICAgIHRpY2tUaW1lICs9IFRvbmUuVGltZSh0aGlzLl9zd2luZ1RpY2tzICogMiAvIDMsICdpJykgKiBhbW91bnQ7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8vZG8gdGhlIGxvb3AgdGVzdFxuXHQgICAgICAgIGlmICh0aGlzLmxvb3ApIHtcblx0ICAgICAgICAgICAgaWYgKHRpY2tzID49IHRoaXMuX2xvb3BFbmQpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnbG9vcEVuZCcsIHRpY2tUaW1lKTtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX2Nsb2NrLnRpY2tzID0gdGhpcy5fbG9vcFN0YXJ0O1xuXHQgICAgICAgICAgICAgICAgdGlja3MgPSB0aGlzLl9sb29wU3RhcnQ7XG5cdCAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2xvb3BTdGFydCcsIHRpY2tUaW1lLCB0aGlzLnNlY29uZHMpO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdsb29wJywgdGlja1RpbWUpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8vcHJvY2VzcyB0aGUgc2luZ2xlIG9jY3VycmVuY2UgZXZlbnRzXG5cdCAgICAgICAgdGhpcy5fb25jZUV2ZW50cy5mb3JFYWNoQmVmb3JlKHRpY2tzLCBmdW5jdGlvbiAoZXZlbnQpIHtcblx0ICAgICAgICAgICAgZXZlbnQuY2FsbGJhY2sodGlja1RpbWUpO1xuXHQgICAgICAgICAgICAvL3JlbW92ZSB0aGUgZXZlbnRcblx0ICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3NjaGVkdWxlZEV2ZW50c1tldmVudC5pZC50b1N0cmluZygpXTtcblx0ICAgICAgICB9LmJpbmQodGhpcykpO1xuXHQgICAgICAgIC8vYW5kIGNsZWFyIHRoZSBzaW5nbGUgb2NjdXJyZW5jZSB0aW1lbGluZVxuXHQgICAgICAgIHRoaXMuX29uY2VFdmVudHMuY2FuY2VsQmVmb3JlKHRpY2tzKTtcblx0ICAgICAgICAvL2ZpcmUgdGhlIG5leHQgdGljayBldmVudHMgaWYgdGhlaXIgdGltZSBoYXMgY29tZVxuXHQgICAgICAgIHRoaXMuX3RpbWVsaW5lLmZvckVhY2hBdFRpbWUodGlja3MsIGZ1bmN0aW9uIChldmVudCkge1xuXHQgICAgICAgICAgICBldmVudC5jYWxsYmFjayh0aWNrVGltZSk7XG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgLy9wcm9jZXNzIHRoZSByZXBlYXRlZCBldmVudHNcblx0ICAgICAgICB0aGlzLl9yZXBlYXRlZEV2ZW50cy5mb3JFYWNoQXRUaW1lKHRpY2tzLCBmdW5jdGlvbiAoZXZlbnQpIHtcblx0ICAgICAgICAgICAgaWYgKCh0aWNrcyAtIGV2ZW50LnRpbWUpICUgZXZlbnQuaW50ZXJ2YWwgPT09IDApIHtcblx0ICAgICAgICAgICAgICAgIGV2ZW50LmNhbGxiYWNrKHRpY2tUaW1lKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0pO1xuXHQgICAgfTtcblx0ICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblx0ICAgIC8vXHRTQ0hFRFVMQUJMRSBFVkVOVFNcblx0ICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblx0ICAgIC8qKlxuXHRcdCAqICBTY2hlZHVsZSBhbiBldmVudCBhbG9uZyB0aGUgdGltZWxpbmUuXG5cdFx0ICogIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBjYWxsYmFjayB0byBiZSBpbnZva2VkIGF0IHRoZSB0aW1lLlxuXHRcdCAqICBAcGFyYW0ge1RyYW5zcG9ydFRpbWV9ICB0aW1lIFRoZSB0aW1lIHRvIGludm9rZSB0aGUgY2FsbGJhY2sgYXQuXG5cdFx0ICogIEByZXR1cm4ge051bWJlcn0gVGhlIGlkIG9mIHRoZSBldmVudCB3aGljaCBjYW4gYmUgdXNlZCBmb3IgY2FuY2VsaW5nIHRoZSBldmVudC4gXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogLy90cmlnZ2VyIHRoZSBjYWxsYmFjayB3aGVuIHRoZSBUcmFuc3BvcnQgcmVhY2hlcyB0aGUgZGVzaXJlZCB0aW1lXG5cdFx0ICogVG9uZS5UcmFuc3BvcnQuc2NoZWR1bGUoZnVuY3Rpb24odGltZSl7XG5cdFx0ICogXHRlbnZlbG9wZS50cmlnZ2VyQXR0YWNrKHRpbWUpO1xuXHRcdCAqIH0sIFwiMTI4aVwiKTtcblx0XHQgKi9cblx0ICAgIFRvbmUuVHJhbnNwb3J0LnByb3RvdHlwZS5zY2hlZHVsZSA9IGZ1bmN0aW9uIChjYWxsYmFjaywgdGltZSkge1xuXHQgICAgICAgIHZhciBldmVudCA9IHtcblx0ICAgICAgICAgICAgJ3RpbWUnOiB0aGlzLnRvVGlja3ModGltZSksXG5cdCAgICAgICAgICAgICdjYWxsYmFjayc6IGNhbGxiYWNrXG5cdCAgICAgICAgfTtcblx0ICAgICAgICB2YXIgaWQgPSB0aGlzLl9ldmVudElEKys7XG5cdCAgICAgICAgdGhpcy5fc2NoZWR1bGVkRXZlbnRzW2lkLnRvU3RyaW5nKCldID0ge1xuXHQgICAgICAgICAgICAnZXZlbnQnOiBldmVudCxcblx0ICAgICAgICAgICAgJ3RpbWVsaW5lJzogdGhpcy5fdGltZWxpbmVcblx0ICAgICAgICB9O1xuXHQgICAgICAgIHRoaXMuX3RpbWVsaW5lLmFkZChldmVudCk7XG5cdCAgICAgICAgcmV0dXJuIGlkO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBTY2hlZHVsZSBhIHJlcGVhdGVkIGV2ZW50IGFsb25nIHRoZSB0aW1lbGluZS4gVGhlIGV2ZW50IHdpbGwgZmlyZVxuXHRcdCAqICBhdCB0aGUgYGludGVydmFsYCBzdGFydGluZyBhdCB0aGUgYHN0YXJ0VGltZWAgYW5kIGZvciB0aGUgc3BlY2lmaWVkXG5cdFx0ICogIGBkdXJhdGlvbmAuIFxuXHRcdCAqICBAcGFyYW0gIHtGdW5jdGlvbn0gIGNhbGxiYWNrICAgVGhlIGNhbGxiYWNrIHRvIGludm9rZS5cblx0XHQgKiAgQHBhcmFtICB7VGltZX0gICAgaW50ZXJ2YWwgICBUaGUgZHVyYXRpb24gYmV0d2VlbiBzdWNjZXNzaXZlXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tzLlxuXHRcdCAqICBAcGFyYW0gIHtUaW1lbGluZVBvc2l0aW9uPX0gICAgc3RhcnRUaW1lICBXaGVuIGFsb25nIHRoZSB0aW1lbGluZSB0aGUgZXZlbnRzIHNob3VsZFxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0IGJlaW5nIGludm9rZWQuXG5cdFx0ICogIEBwYXJhbSB7VGltZX0gW2R1cmF0aW9uPUluZmluaXR5XSBIb3cgbG9uZyB0aGUgZXZlbnQgc2hvdWxkIHJlcGVhdC4gXG5cdFx0ICogIEByZXR1cm4gIHtOdW1iZXJ9ICAgIFRoZSBJRCBvZiB0aGUgc2NoZWR1bGVkIGV2ZW50LiBVc2UgdGhpcyB0byBjYW5jZWxcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSBldmVudC4gXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogLy9hIGNhbGxiYWNrIGludm9rZWQgZXZlcnkgZWlnaHRoIG5vdGUgYWZ0ZXIgdGhlIGZpcnN0IG1lYXN1cmVcblx0XHQgKiBUb25lLlRyYW5zcG9ydC5zY2hlZHVsZVJlcGVhdChjYWxsYmFjaywgXCI4blwiLCBcIjFtXCIpO1xuXHRcdCAqL1xuXHQgICAgVG9uZS5UcmFuc3BvcnQucHJvdG90eXBlLnNjaGVkdWxlUmVwZWF0ID0gZnVuY3Rpb24gKGNhbGxiYWNrLCBpbnRlcnZhbCwgc3RhcnRUaW1lLCBkdXJhdGlvbikge1xuXHQgICAgICAgIGlmIChpbnRlcnZhbCA8PSAwKSB7XG5cdCAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVG9uZS5UcmFuc3BvcnQ6IHJlcGVhdCBldmVudHMgbXVzdCBoYXZlIGFuIGludGVydmFsIGxhcmdlciB0aGFuIDAnKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIGV2ZW50ID0ge1xuXHQgICAgICAgICAgICAndGltZSc6IHRoaXMudG9UaWNrcyhzdGFydFRpbWUpLFxuXHQgICAgICAgICAgICAnZHVyYXRpb24nOiB0aGlzLnRvVGlja3MoVG9uZS5kZWZhdWx0QXJnKGR1cmF0aW9uLCBJbmZpbml0eSkpLFxuXHQgICAgICAgICAgICAnaW50ZXJ2YWwnOiB0aGlzLnRvVGlja3MoaW50ZXJ2YWwpLFxuXHQgICAgICAgICAgICAnY2FsbGJhY2snOiBjYWxsYmFja1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgdmFyIGlkID0gdGhpcy5fZXZlbnRJRCsrO1xuXHQgICAgICAgIHRoaXMuX3NjaGVkdWxlZEV2ZW50c1tpZC50b1N0cmluZygpXSA9IHtcblx0ICAgICAgICAgICAgJ2V2ZW50JzogZXZlbnQsXG5cdCAgICAgICAgICAgICd0aW1lbGluZSc6IHRoaXMuX3JlcGVhdGVkRXZlbnRzXG5cdCAgICAgICAgfTtcblx0ICAgICAgICB0aGlzLl9yZXBlYXRlZEV2ZW50cy5hZGQoZXZlbnQpO1xuXHQgICAgICAgIHJldHVybiBpZDtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgU2NoZWR1bGUgYW4gZXZlbnQgdGhhdCB3aWxsIGJlIHJlbW92ZWQgYWZ0ZXIgaXQgaXMgaW52b2tlZC4gXG5cdFx0ICogIE5vdGUgdGhhdCBpZiB0aGUgZ2l2ZW4gdGltZSBpcyBsZXNzIHRoYW4gdGhlIGN1cnJlbnQgdHJhbnNwb3J0IHRpbWUsIFxuXHRcdCAqICB0aGUgZXZlbnQgd2lsbCBiZSBpbnZva2VkIGltbWVkaWF0ZWx5LiBcblx0XHQgKiAgQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGNhbGxiYWNrIHRvIGludm9rZSBvbmNlLlxuXHRcdCAqICBAcGFyYW0ge1RyYW5zcG9ydFRpbWV9IHRpbWUgVGhlIHRpbWUgdGhlIGNhbGxiYWNrIHNob3VsZCBiZSBpbnZva2VkLlxuXHRcdCAqICBAcmV0dXJucyB7TnVtYmVyfSBUaGUgSUQgb2YgdGhlIHNjaGVkdWxlZCBldmVudC4gXG5cdFx0ICovXG5cdCAgICBUb25lLlRyYW5zcG9ydC5wcm90b3R5cGUuc2NoZWR1bGVPbmNlID0gZnVuY3Rpb24gKGNhbGxiYWNrLCB0aW1lKSB7XG5cdCAgICAgICAgdmFyIGlkID0gdGhpcy5fZXZlbnRJRCsrO1xuXHQgICAgICAgIHZhciBldmVudCA9IHtcblx0ICAgICAgICAgICAgJ3RpbWUnOiB0aGlzLnRvVGlja3ModGltZSksXG5cdCAgICAgICAgICAgICdjYWxsYmFjayc6IGNhbGxiYWNrLFxuXHQgICAgICAgICAgICAnaWQnOiBpZFxuXHQgICAgICAgIH07XG5cdCAgICAgICAgdGhpcy5fc2NoZWR1bGVkRXZlbnRzW2lkLnRvU3RyaW5nKCldID0ge1xuXHQgICAgICAgICAgICAnZXZlbnQnOiBldmVudCxcblx0ICAgICAgICAgICAgJ3RpbWVsaW5lJzogdGhpcy5fb25jZUV2ZW50c1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgdGhpcy5fb25jZUV2ZW50cy5hZGQoZXZlbnQpO1xuXHQgICAgICAgIHJldHVybiBpZDtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgQ2xlYXIgdGhlIHBhc3NlZCBpbiBldmVudCBpZCBmcm9tIHRoZSB0aW1lbGluZVxuXHRcdCAqICBAcGFyYW0ge051bWJlcn0gZXZlbnRJZCBUaGUgaWQgb2YgdGhlIGV2ZW50LlxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5UcmFuc3BvcnR9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuVHJhbnNwb3J0LnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uIChldmVudElkKSB7XG5cdCAgICAgICAgaWYgKHRoaXMuX3NjaGVkdWxlZEV2ZW50cy5oYXNPd25Qcm9wZXJ0eShldmVudElkKSkge1xuXHQgICAgICAgICAgICB2YXIgaXRlbSA9IHRoaXMuX3NjaGVkdWxlZEV2ZW50c1tldmVudElkLnRvU3RyaW5nKCldO1xuXHQgICAgICAgICAgICBpdGVtLnRpbWVsaW5lLnJlbW92ZShpdGVtLmV2ZW50KTtcblx0ICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3NjaGVkdWxlZEV2ZW50c1tldmVudElkLnRvU3RyaW5nKCldO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgUmVtb3ZlIHNjaGVkdWxlZCBldmVudHMgZnJvbSB0aGUgdGltZWxpbmUgYWZ0ZXJcblx0XHQgKiAgdGhlIGdpdmVuIHRpbWUuIFJlcGVhdGVkIGV2ZW50cyB3aWxsIGJlIHJlbW92ZWRcblx0XHQgKiAgaWYgdGhlaXIgc3RhcnRUaW1lIGlzIGFmdGVyIHRoZSBnaXZlbiB0aW1lXG5cdFx0ICogIEBwYXJhbSB7VHJhbnNwb3J0VGltZX0gW2FmdGVyPTBdIENsZWFyIGFsbCBldmVudHMgYWZ0ZXJcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcyB0aW1lLiBcblx0XHQgKiAgQHJldHVybnMge1RvbmUuVHJhbnNwb3J0fSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLlRyYW5zcG9ydC5wcm90b3R5cGUuY2FuY2VsID0gZnVuY3Rpb24gKGFmdGVyKSB7XG5cdCAgICAgICAgYWZ0ZXIgPSBUb25lLmRlZmF1bHRBcmcoYWZ0ZXIsIDApO1xuXHQgICAgICAgIGFmdGVyID0gdGhpcy50b1RpY2tzKGFmdGVyKTtcblx0ICAgICAgICB0aGlzLl90aW1lbGluZS5jYW5jZWwoYWZ0ZXIpO1xuXHQgICAgICAgIHRoaXMuX29uY2VFdmVudHMuY2FuY2VsKGFmdGVyKTtcblx0ICAgICAgICB0aGlzLl9yZXBlYXRlZEV2ZW50cy5jYW5jZWwoYWZ0ZXIpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblx0ICAgIC8vXHRTVEFSVC9TVE9QL1BBVVNFXG5cdCAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdCAgICAvKipcblx0XHQgKiAgQmluZCBzdGFydC9zdG9wL3BhdXNlIGV2ZW50cyBmcm9tIHRoZSBjbG9jayBhbmQgZW1pdCB0aGVtLlxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5UcmFuc3BvcnQucHJvdG90eXBlLl9iaW5kQ2xvY2tFdmVudHMgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdGhpcy5fY2xvY2sub24oJ3N0YXJ0JywgZnVuY3Rpb24gKHRpbWUsIG9mZnNldCkge1xuXHQgICAgICAgICAgICBvZmZzZXQgPSBUb25lLlRpbWUodGhpcy5fY2xvY2sudGlja3MsICdpJykudG9TZWNvbmRzKCk7XG5cdCAgICAgICAgICAgIHRoaXMuZW1pdCgnc3RhcnQnLCB0aW1lLCBvZmZzZXQpO1xuXHQgICAgICAgIH0uYmluZCh0aGlzKSk7XG5cdCAgICAgICAgdGhpcy5fY2xvY2sub24oJ3N0b3AnLCBmdW5jdGlvbiAodGltZSkge1xuXHQgICAgICAgICAgICB0aGlzLmVtaXQoJ3N0b3AnLCB0aW1lKTtcblx0ICAgICAgICB9LmJpbmQodGhpcykpO1xuXHQgICAgICAgIHRoaXMuX2Nsb2NrLm9uKCdwYXVzZScsIGZ1bmN0aW9uICh0aW1lKSB7XG5cdCAgICAgICAgICAgIHRoaXMuZW1pdCgncGF1c2UnLCB0aW1lKTtcblx0ICAgICAgICB9LmJpbmQodGhpcykpO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBSZXR1cm5zIHRoZSBwbGF5YmFjayBzdGF0ZSBvZiB0aGUgc291cmNlLCBlaXRoZXIgXCJzdGFydGVkXCIsIFwic3RvcHBlZFwiLCBvciBcInBhdXNlZFwiXG5cdFx0ICogIEB0eXBlIHtUb25lLlN0YXRlfVxuXHRcdCAqICBAcmVhZE9ubHlcblx0XHQgKiAgQG1lbWJlck9mIFRvbmUuVHJhbnNwb3J0I1xuXHRcdCAqICBAbmFtZSBzdGF0ZVxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuVHJhbnNwb3J0LnByb3RvdHlwZSwgJ3N0YXRlJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fY2xvY2suZ2V0U3RhdGVBdFRpbWUodGhpcy5ub3coKSk7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgU3RhcnQgdGhlIHRyYW5zcG9ydCBhbmQgYWxsIHNvdXJjZXMgc3luY2VkIHRvIHRoZSB0cmFuc3BvcnQuXG5cdFx0ICogIEBwYXJhbSAge1RpbWV9IFt0aW1lPW5vd10gVGhlIHRpbWUgd2hlbiB0aGUgdHJhbnNwb3J0IHNob3VsZCBzdGFydC5cblx0XHQgKiAgQHBhcmFtICB7VHJhbnNwb3J0VGltZT19IG9mZnNldCBUaGUgdGltZWxpbmUgb2Zmc2V0IHRvIHN0YXJ0IHRoZSB0cmFuc3BvcnQuXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLlRyYW5zcG9ydH0gdGhpc1xuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIC8vc3RhcnQgdGhlIHRyYW5zcG9ydCBpbiBvbmUgc2Vjb25kIHN0YXJ0aW5nIGF0IGJlZ2lubmluZyBvZiB0aGUgNXRoIG1lYXN1cmUuIFxuXHRcdCAqIFRvbmUuVHJhbnNwb3J0LnN0YXJ0KFwiKzFcIiwgXCI0OjA6MFwiKTtcblx0XHQgKi9cblx0ICAgIFRvbmUuVHJhbnNwb3J0LnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uICh0aW1lLCBvZmZzZXQpIHtcblx0ICAgICAgICAvL3N0YXJ0IHRoZSBjbG9ja1xuXHQgICAgICAgIGlmICghVG9uZS5pc1VuZGVmKG9mZnNldCkpIHtcblx0ICAgICAgICAgICAgb2Zmc2V0ID0gdGhpcy50b1RpY2tzKG9mZnNldCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHRoaXMuX2Nsb2NrLnN0YXJ0KHRpbWUsIG9mZnNldCk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFN0b3AgdGhlIHRyYW5zcG9ydCBhbmQgYWxsIHNvdXJjZXMgc3luY2VkIHRvIHRoZSB0cmFuc3BvcnQuXG5cdFx0ICogIEBwYXJhbSAge1RpbWV9IFt0aW1lPW5vd10gVGhlIHRpbWUgd2hlbiB0aGUgdHJhbnNwb3J0IHNob3VsZCBzdG9wLiBcblx0XHQgKiAgQHJldHVybnMge1RvbmUuVHJhbnNwb3J0fSB0aGlzXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogVG9uZS5UcmFuc3BvcnQuc3RvcCgpO1xuXHRcdCAqL1xuXHQgICAgVG9uZS5UcmFuc3BvcnQucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAodGltZSkge1xuXHQgICAgICAgIHRoaXMuX2Nsb2NrLnN0b3AodGltZSk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFBhdXNlIHRoZSB0cmFuc3BvcnQgYW5kIGFsbCBzb3VyY2VzIHN5bmNlZCB0byB0aGUgdHJhbnNwb3J0LlxuXHRcdCAqICBAcGFyYW0gIHtUaW1lfSBbdGltZT1ub3ddXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLlRyYW5zcG9ydH0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5UcmFuc3BvcnQucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24gKHRpbWUpIHtcblx0ICAgICAgICB0aGlzLl9jbG9jay5wYXVzZSh0aW1lKTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiBUb2dnbGUgdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIHRyYW5zcG9ydC4gSWYgaXQgaXNcblx0XHQgKiBzdGFydGVkLCBpdCB3aWxsIHN0b3AgaXQsIG90aGVyd2lzZSBpdCB3aWxsIHN0YXJ0IHRoZSBUcmFuc3BvcnQuXG5cdFx0ICogQHBhcmFtICB7VGltZT19IHRpbWUgVGhlIHRpbWUgb2YgdGhlIGV2ZW50XG5cdFx0ICogQHJldHVybiB7VG9uZS5UcmFuc3BvcnR9ICAgICAgdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5UcmFuc3BvcnQucHJvdG90eXBlLnRvZ2dsZSA9IGZ1bmN0aW9uICh0aW1lKSB7XG5cdCAgICAgICAgdGltZSA9IHRoaXMudG9TZWNvbmRzKHRpbWUpO1xuXHQgICAgICAgIGlmICh0aGlzLl9jbG9jay5nZXRTdGF0ZUF0VGltZSh0aW1lKSAhPT0gVG9uZS5TdGF0ZS5TdGFydGVkKSB7XG5cdCAgICAgICAgICAgIHRoaXMuc3RhcnQodGltZSk7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgdGhpcy5zdG9wKHRpbWUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdCAgICAvL1x0U0VUVEVSUy9HRVRURVJTXG5cdCAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdCAgICAvKipcblx0XHQgKiAgVGhlIHRpbWUgc2lnbmF0dXJlIGFzIGp1c3QgdGhlIG51bWVyYXRvciBvdmVyIDQuIFxuXHRcdCAqICBGb3IgZXhhbXBsZSA0LzQgd291bGQgYmUganVzdCA0IGFuZCA2Lzggd291bGQgYmUgMy5cblx0XHQgKiAgQG1lbWJlck9mIFRvbmUuVHJhbnNwb3J0I1xuXHRcdCAqICBAdHlwZSB7TnVtYmVyfEFycmF5fVxuXHRcdCAqICBAbmFtZSB0aW1lU2lnbmF0dXJlXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogLy9jb21tb24gdGltZVxuXHRcdCAqIFRvbmUuVHJhbnNwb3J0LnRpbWVTaWduYXR1cmUgPSA0O1xuXHRcdCAqIC8vIDcvOFxuXHRcdCAqIFRvbmUuVHJhbnNwb3J0LnRpbWVTaWduYXR1cmUgPSBbNywgOF07XG5cdFx0ICogLy90aGlzIHdpbGwgYmUgcmVkdWNlZCB0byBhIHNpbmdsZSBudW1iZXJcblx0XHQgKiBUb25lLlRyYW5zcG9ydC50aW1lU2lnbmF0dXJlOyAvL3JldHVybnMgMy41XG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5UcmFuc3BvcnQucHJvdG90eXBlLCAndGltZVNpZ25hdHVyZScsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RpbWVTaWduYXR1cmU7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uICh0aW1lU2lnKSB7XG5cdCAgICAgICAgICAgIGlmIChUb25lLmlzQXJyYXkodGltZVNpZykpIHtcblx0ICAgICAgICAgICAgICAgIHRpbWVTaWcgPSB0aW1lU2lnWzBdIC8gdGltZVNpZ1sxXSAqIDQ7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdGhpcy5fdGltZVNpZ25hdHVyZSA9IHRpbWVTaWc7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiBXaGVuIHRoZSBUb25lLlRyYW5zcG9ydC5sb29wID0gdHJ1ZSwgdGhpcyBpcyB0aGUgc3RhcnRpbmcgcG9zaXRpb24gb2YgdGhlIGxvb3AuXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuVHJhbnNwb3J0I1xuXHRcdCAqIEB0eXBlIHtUcmFuc3BvcnRUaW1lfVxuXHRcdCAqIEBuYW1lIGxvb3BTdGFydFxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuVHJhbnNwb3J0LnByb3RvdHlwZSwgJ2xvb3BTdGFydCcsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIFRvbmUuVHJhbnNwb3J0VGltZSh0aGlzLl9sb29wU3RhcnQsICdpJykudG9TZWNvbmRzKCk7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChzdGFydFBvc2l0aW9uKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2xvb3BTdGFydCA9IHRoaXMudG9UaWNrcyhzdGFydFBvc2l0aW9uKTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqIFdoZW4gdGhlIFRvbmUuVHJhbnNwb3J0Lmxvb3AgPSB0cnVlLCB0aGlzIGlzIHRoZSBlbmRpbmcgcG9zaXRpb24gb2YgdGhlIGxvb3AuXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuVHJhbnNwb3J0I1xuXHRcdCAqIEB0eXBlIHtUcmFuc3BvcnRUaW1lfVxuXHRcdCAqIEBuYW1lIGxvb3BFbmRcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLlRyYW5zcG9ydC5wcm90b3R5cGUsICdsb29wRW5kJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gVG9uZS5UcmFuc3BvcnRUaW1lKHRoaXMuX2xvb3BFbmQsICdpJykudG9TZWNvbmRzKCk7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChlbmRQb3NpdGlvbikge1xuXHQgICAgICAgICAgICB0aGlzLl9sb29wRW5kID0gdGhpcy50b1RpY2tzKGVuZFBvc2l0aW9uKTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBTZXQgdGhlIGxvb3Agc3RhcnQgYW5kIHN0b3AgYXQgdGhlIHNhbWUgdGltZS4gXG5cdFx0ICogIEBwYXJhbSB7VHJhbnNwb3J0VGltZX0gc3RhcnRQb3NpdGlvbiBcblx0XHQgKiAgQHBhcmFtIHtUcmFuc3BvcnRUaW1lfSBlbmRQb3NpdGlvbiAgIFxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5UcmFuc3BvcnR9IHRoaXNcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAvL2xvb3Agb3ZlciB0aGUgZmlyc3QgbWVhc3VyZVxuXHRcdCAqIFRvbmUuVHJhbnNwb3J0LnNldExvb3BQb2ludHMoMCwgXCIxbVwiKTtcblx0XHQgKiBUb25lLlRyYW5zcG9ydC5sb29wID0gdHJ1ZTtcblx0XHQgKi9cblx0ICAgIFRvbmUuVHJhbnNwb3J0LnByb3RvdHlwZS5zZXRMb29wUG9pbnRzID0gZnVuY3Rpb24gKHN0YXJ0UG9zaXRpb24sIGVuZFBvc2l0aW9uKSB7XG5cdCAgICAgICAgdGhpcy5sb29wU3RhcnQgPSBzdGFydFBvc2l0aW9uO1xuXHQgICAgICAgIHRoaXMubG9vcEVuZCA9IGVuZFBvc2l0aW9uO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgc3dpbmcgdmFsdWUuIEJldHdlZW4gMC0xIHdoZXJlIDEgZXF1YWwgdG8gXG5cdFx0ICogIHRoZSBub3RlICsgaGFsZiB0aGUgc3ViZGl2aXNpb24uXG5cdFx0ICogIEBtZW1iZXJPZiBUb25lLlRyYW5zcG9ydCNcblx0XHQgKiAgQHR5cGUge05vcm1hbFJhbmdlfVxuXHRcdCAqICBAbmFtZSBzd2luZ1xuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuVHJhbnNwb3J0LnByb3RvdHlwZSwgJ3N3aW5nJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fc3dpbmdBbW91bnQ7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChhbW91bnQpIHtcblx0ICAgICAgICAgICAgLy9zY2FsZSB0aGUgdmFsdWVzIHRvIGEgbm9ybWFsIHJhbmdlXG5cdCAgICAgICAgICAgIHRoaXMuX3N3aW5nQW1vdW50ID0gYW1vdW50O1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIFNldCB0aGUgc3ViZGl2aXNpb24gd2hpY2ggdGhlIHN3aW5nIHdpbGwgYmUgYXBwbGllZCB0by4gXG5cdFx0ICogIFRoZSBkZWZhdWx0IHZhbHVlIGlzIGFuIDh0aCBub3RlLiBWYWx1ZSBtdXN0IGJlIGxlc3MgXG5cdFx0ICogIHRoYW4gYSBxdWFydGVyIG5vdGUuXG5cdFx0ICogIFxuXHRcdCAqICBAbWVtYmVyT2YgVG9uZS5UcmFuc3BvcnQjXG5cdFx0ICogIEB0eXBlIHtUaW1lfVxuXHRcdCAqICBAbmFtZSBzd2luZ1N1YmRpdmlzaW9uXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5UcmFuc3BvcnQucHJvdG90eXBlLCAnc3dpbmdTdWJkaXZpc2lvbicsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIFRvbmUuVGltZSh0aGlzLl9zd2luZ1RpY2tzLCAnaScpLnRvTm90YXRpb24oKTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKHN1YmRpdmlzaW9uKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3N3aW5nVGlja3MgPSB0aGlzLnRvVGlja3Moc3ViZGl2aXNpb24pO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIFRoZSBUcmFuc3BvcnQncyBwb3NpdGlvbiBpbiBCYXJzOkJlYXRzOlNpeHRlZW50aHMuXG5cdFx0ICogIFNldHRpbmcgdGhlIHZhbHVlIHdpbGwganVtcCB0byB0aGF0IHBvc2l0aW9uIHJpZ2h0IGF3YXkuIFxuXHRcdCAqICBAbWVtYmVyT2YgVG9uZS5UcmFuc3BvcnQjXG5cdFx0ICogIEB0eXBlIHtCYXJzQmVhdHNTaXh0ZWVudGhzfVxuXHRcdCAqICBAbmFtZSBwb3NpdGlvblxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuVHJhbnNwb3J0LnByb3RvdHlwZSwgJ3Bvc2l0aW9uJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gVG9uZS5UcmFuc3BvcnRUaW1lKHRoaXMudGlja3MsICdpJykudG9CYXJzQmVhdHNTaXh0ZWVudGhzKCk7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChwcm9ncmVzcykge1xuXHQgICAgICAgICAgICB2YXIgdGlja3MgPSB0aGlzLnRvVGlja3MocHJvZ3Jlc3MpO1xuXHQgICAgICAgICAgICB0aGlzLnRpY2tzID0gdGlja3M7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgVGhlIFRyYW5zcG9ydCdzIHBvc2l0aW9uIGluIHNlY29uZHNcblx0XHQgKiAgU2V0dGluZyB0aGUgdmFsdWUgd2lsbCBqdW1wIHRvIHRoYXQgcG9zaXRpb24gcmlnaHQgYXdheS4gXG5cdFx0ICogIEBtZW1iZXJPZiBUb25lLlRyYW5zcG9ydCNcblx0XHQgKiAgQHR5cGUge1NlY29uZHN9XG5cdFx0ICogIEBuYW1lIHNlY29uZHNcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLlRyYW5zcG9ydC5wcm90b3R5cGUsICdzZWNvbmRzJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gVG9uZS5UcmFuc3BvcnRUaW1lKHRoaXMudGlja3MsICdpJykudG9TZWNvbmRzKCk7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChwcm9ncmVzcykge1xuXHQgICAgICAgICAgICB2YXIgdGlja3MgPSB0aGlzLnRvVGlja3MocHJvZ3Jlc3MpO1xuXHQgICAgICAgICAgICB0aGlzLnRpY2tzID0gdGlja3M7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgVGhlIFRyYW5zcG9ydCdzIGxvb3AgcG9zaXRpb24gYXMgYSBub3JtYWxpemVkIHZhbHVlLiBBbHdheXNcblx0XHQgKiAgcmV0dXJucyAwIGlmIHRoZSB0cmFuc3BvcnQgaWYgbG9vcCBpcyBub3QgdHJ1ZS4gXG5cdFx0ICogIEBtZW1iZXJPZiBUb25lLlRyYW5zcG9ydCNcblx0XHQgKiAgQG5hbWUgcHJvZ3Jlc3Ncblx0XHQgKiAgQHR5cGUge05vcm1hbFJhbmdlfVxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuVHJhbnNwb3J0LnByb3RvdHlwZSwgJ3Byb2dyZXNzJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICBpZiAodGhpcy5sb29wKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gKHRoaXMudGlja3MgLSB0aGlzLl9sb29wU3RhcnQpIC8gKHRoaXMuX2xvb3BFbmQgLSB0aGlzLl9sb29wU3RhcnQpO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIDA7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgdHJhbnNwb3J0cyBjdXJyZW50IHRpY2sgcG9zaXRpb24uXG5cdFx0ICogIFxuXHRcdCAqICBAbWVtYmVyT2YgVG9uZS5UcmFuc3BvcnQjXG5cdFx0ICogIEB0eXBlIHtUaWNrc31cblx0XHQgKiAgQG5hbWUgdGlja3Ncblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLlRyYW5zcG9ydC5wcm90b3R5cGUsICd0aWNrcycsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Nsb2NrLnRpY2tzO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAodCkge1xuXHQgICAgICAgICAgICBpZiAodGhpcy5fY2xvY2sudGlja3MgIT09IHQpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBub3cgPSB0aGlzLm5vdygpO1xuXHQgICAgICAgICAgICAgICAgLy9zdG9wIGV2ZXJ5dGhpbmcgc3luY2VkIHRvIHRoZSB0cmFuc3BvcnRcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlID09PSBUb25lLlN0YXRlLlN0YXJ0ZWQpIHtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ3N0b3AnLCBub3cpO1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuX2Nsb2NrLnRpY2tzID0gdDtcblx0ICAgICAgICAgICAgICAgICAgICAvL3Jlc3RhcnQgaXQgd2l0aCB0aGUgbmV3IHRpbWVcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ3N0YXJ0Jywgbm93LCB0aGlzLnNlY29uZHMpO1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLl9jbG9jay50aWNrcyA9IHQ7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBQdWxzZXMgUGVyIFF1YXJ0ZXIgbm90ZS4gVGhpcyBpcyB0aGUgc21hbGxlc3QgcmVzb2x1dGlvblxuXHRcdCAqICB0aGUgVHJhbnNwb3J0IHRpbWluZyBzdXBwb3J0cy4gVGhpcyBzaG91bGQgYmUgc2V0IG9uY2Vcblx0XHQgKiAgb24gaW5pdGlhbGl6YXRpb24gYW5kIG5vdCBzZXQgYWdhaW4uIENoYW5naW5nIHRoaXMgdmFsdWUgXG5cdFx0ICogIGFmdGVyIG90aGVyIG9iamVjdHMgaGF2ZSBiZWVuIGNyZWF0ZWQgY2FuIGNhdXNlIHByb2JsZW1zLiBcblx0XHQgKiAgXG5cdFx0ICogIEBtZW1iZXJPZiBUb25lLlRyYW5zcG9ydCNcblx0XHQgKiAgQHR5cGUge051bWJlcn1cblx0XHQgKiAgQG5hbWUgUFBRXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5UcmFuc3BvcnQucHJvdG90eXBlLCAnUFBRJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fcHBxO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAocHBxKSB7XG5cdCAgICAgICAgICAgIHZhciBicG0gPSB0aGlzLmJwbS52YWx1ZTtcblx0ICAgICAgICAgICAgdGhpcy5fcHBxID0gcHBxO1xuXHQgICAgICAgICAgICB0aGlzLmJwbS52YWx1ZSA9IGJwbTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBDb252ZXJ0IGZyb20gQlBNIHRvIGZyZXF1ZW5jeSAoZmFjdG9yaW5nIGluIFBQUSlcblx0XHQgKiAgQHBhcmFtICB7QlBNfSAgYnBtIFRoZSBCUE0gdmFsdWUgdG8gY29udmVydCB0byBmcmVxdWVuY3lcblx0XHQgKiAgQHJldHVybiAge0ZyZXF1ZW5jeX0gIFRoZSBCUE0gYXMgYSBmcmVxdWVuY3kgd2l0aCBQUFEgZmFjdG9yZWQgaW4uXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLlRyYW5zcG9ydC5wcm90b3R5cGUuX2Zyb21Vbml0cyA9IGZ1bmN0aW9uIChicG0pIHtcblx0ICAgICAgICByZXR1cm4gMSAvICg2MCAvIGJwbSAvIHRoaXMuUFBRKTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgQ29udmVydCBmcm9tIGZyZXF1ZW5jeSAod2l0aCBQUFEpIGludG8gQlBNXG5cdFx0ICogIEBwYXJhbSAge0ZyZXF1ZW5jeX0gIGZyZXEgVGhlIGNsb2NrcyBmcmVxdWVuY3kgdG8gY29udmVydCB0byBCUE1cblx0XHQgKiAgQHJldHVybiAge0JQTX0gIFRoZSBmcmVxdWVuY3kgdmFsdWUgYXMgQlBNLlxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5UcmFuc3BvcnQucHJvdG90eXBlLl90b1VuaXRzID0gZnVuY3Rpb24gKGZyZXEpIHtcblx0ICAgICAgICByZXR1cm4gZnJlcSAvIHRoaXMuUFBRICogNjA7XG5cdCAgICB9O1xuXHQgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQgICAgLy9cdFNZTkNJTkdcblx0ICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblx0ICAgIC8qKlxuXHRcdCAqICBSZXR1cm5zIHRoZSB0aW1lIGFsaWduZWQgdG8gdGhlIG5leHQgc3ViZGl2aXNpb25cblx0XHQgKiAgb2YgdGhlIFRyYW5zcG9ydC4gSWYgdGhlIFRyYW5zcG9ydCBpcyBub3Qgc3RhcnRlZCxcblx0XHQgKiAgaXQgd2lsbCByZXR1cm4gMC5cblx0XHQgKiAgTm90ZTogdGhpcyB3aWxsIG5vdCB3b3JrIHByZWNpc2VseSBkdXJpbmcgdGVtcG8gcmFtcHMuXG5cdFx0ICogIEBwYXJhbSAge1RpbWV9ICBzdWJkaXZpc2lvbiAgVGhlIHN1YmRpdmlzaW9uIHRvIHF1YW50aXplIHRvXG5cdFx0ICogIEByZXR1cm4gIHtOdW1iZXJ9ICBUaGUgY29udGV4dCB0aW1lIG9mIHRoZSBuZXh0IHN1YmRpdmlzaW9uLlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIFRvbmUuVHJhbnNwb3J0LnN0YXJ0KCk7IC8vdGhlIHRyYW5zcG9ydCBtdXN0IGJlIHN0YXJ0ZWRcblx0XHQgKiBUb25lLlRyYW5zcG9ydC5uZXh0U3ViZGl2aXNpb24oXCI0blwiKTtcblx0XHQgKi9cblx0ICAgIFRvbmUuVHJhbnNwb3J0LnByb3RvdHlwZS5uZXh0U3ViZGl2aXNpb24gPSBmdW5jdGlvbiAoc3ViZGl2aXNpb24pIHtcblx0ICAgICAgICBzdWJkaXZpc2lvbiA9IHRoaXMudG9TZWNvbmRzKHN1YmRpdmlzaW9uKTtcblx0ICAgICAgICAvL2lmIHRoZSB0cmFuc3BvcnQncyBub3Qgc3RhcnRlZCwgcmV0dXJuIDBcblx0ICAgICAgICB2YXIgbm93O1xuXHQgICAgICAgIGlmICh0aGlzLnN0YXRlID09PSBUb25lLlN0YXRlLlN0YXJ0ZWQpIHtcblx0ICAgICAgICAgICAgbm93ID0gdGhpcy5fY2xvY2suX25leHRUaWNrO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIHJldHVybiAwO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgdHJhbnNwb3J0UG9zID0gVG9uZS5UaW1lKHRoaXMudGlja3MsICdpJyk7XG5cdCAgICAgICAgdmFyIHJlbWFpbmluZ1RpbWUgPSBzdWJkaXZpc2lvbiAtIHRyYW5zcG9ydFBvcyAlIHN1YmRpdmlzaW9uO1xuXHQgICAgICAgIGlmIChyZW1haW5pbmdUaW1lID09PSAwKSB7XG5cdCAgICAgICAgICAgIHJlbWFpbmluZ1RpbWUgPSBzdWJkaXZpc2lvbjtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIG5vdyArIHJlbWFpbmluZ1RpbWU7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIEF0dGFjaGVzIHRoZSBzaWduYWwgdG8gdGhlIHRlbXBvIGNvbnRyb2wgc2lnbmFsIHNvIHRoYXQgXG5cdFx0ICogIGFueSBjaGFuZ2VzIGluIHRoZSB0ZW1wbyB3aWxsIGNoYW5nZSB0aGUgc2lnbmFsIGluIHRoZSBzYW1lXG5cdFx0ICogIHJhdGlvLiBcblx0XHQgKiAgXG5cdFx0ICogIEBwYXJhbSAge1RvbmUuU2lnbmFsfSBzaWduYWwgXG5cdFx0ICogIEBwYXJhbSB7bnVtYmVyPX0gcmF0aW8gT3B0aW9uYWxseSBwYXNzIGluIHRoZSByYXRpbyBiZXR3ZWVuXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgdGhlIHR3byBzaWduYWxzLiBPdGhlcndpc2UgaXQgd2lsbCBiZSBjb21wdXRlZFxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgICAgIGJhc2VkIG9uIHRoZWlyIGN1cnJlbnQgdmFsdWVzLiBcblx0XHQgKiAgQHJldHVybnMge1RvbmUuVHJhbnNwb3J0fSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLlRyYW5zcG9ydC5wcm90b3R5cGUuc3luY1NpZ25hbCA9IGZ1bmN0aW9uIChzaWduYWwsIHJhdGlvKSB7XG5cdCAgICAgICAgaWYgKCFyYXRpbykge1xuXHQgICAgICAgICAgICAvL2dldCB0aGUgc3luYyByYXRpb1xuXHQgICAgICAgICAgICBpZiAoc2lnbmFsLl9wYXJhbS52YWx1ZSAhPT0gMCkge1xuXHQgICAgICAgICAgICAgICAgcmF0aW8gPSBzaWduYWwuX3BhcmFtLnZhbHVlIC8gdGhpcy5icG0uX3BhcmFtLnZhbHVlO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgcmF0aW8gPSAwO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciByYXRpb1NpZ25hbCA9IG5ldyBUb25lLkdhaW4ocmF0aW8pO1xuXHQgICAgICAgIHRoaXMuYnBtLmNoYWluKHJhdGlvU2lnbmFsLCBzaWduYWwuX3BhcmFtKTtcblx0ICAgICAgICB0aGlzLl9zeW5jZWRTaWduYWxzLnB1c2goe1xuXHQgICAgICAgICAgICAncmF0aW8nOiByYXRpb1NpZ25hbCxcblx0ICAgICAgICAgICAgJ3NpZ25hbCc6IHNpZ25hbCxcblx0ICAgICAgICAgICAgJ2luaXRpYWwnOiBzaWduYWwuX3BhcmFtLnZhbHVlXG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgc2lnbmFsLl9wYXJhbS52YWx1ZSA9IDA7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFVuc3luY3MgYSBwcmV2aW91c2x5IHN5bmNlZCBzaWduYWwgZnJvbSB0aGUgdHJhbnNwb3J0J3MgY29udHJvbC4gXG5cdFx0ICogIFNlZSBUb25lLlRyYW5zcG9ydC5zeW5jU2lnbmFsLlxuXHRcdCAqICBAcGFyYW0gIHtUb25lLlNpZ25hbH0gc2lnbmFsIFxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5UcmFuc3BvcnR9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuVHJhbnNwb3J0LnByb3RvdHlwZS51bnN5bmNTaWduYWwgPSBmdW5jdGlvbiAoc2lnbmFsKSB7XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMuX3N5bmNlZFNpZ25hbHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0ICAgICAgICAgICAgdmFyIHN5bmNlZFNpZ25hbCA9IHRoaXMuX3N5bmNlZFNpZ25hbHNbaV07XG5cdCAgICAgICAgICAgIGlmIChzeW5jZWRTaWduYWwuc2lnbmFsID09PSBzaWduYWwpIHtcblx0ICAgICAgICAgICAgICAgIHN5bmNlZFNpZ25hbC5yYXRpby5kaXNwb3NlKCk7XG5cdCAgICAgICAgICAgICAgICBzeW5jZWRTaWduYWwuc2lnbmFsLl9wYXJhbS52YWx1ZSA9IHN5bmNlZFNpZ25hbC5pbml0aWFsO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fc3luY2VkU2lnbmFscy5zcGxpY2UoaSwgMSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIENsZWFuIHVwLiBcblx0XHQgKiAgQHJldHVybnMge1RvbmUuVHJhbnNwb3J0fSB0aGlzXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLlRyYW5zcG9ydC5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLkVtaXR0ZXIucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLl9jbG9jay5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fY2xvY2sgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX3dyaXRhYmxlKCdicG0nKTtcblx0ICAgICAgICB0aGlzLmJwbSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fdGltZWxpbmUuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX3RpbWVsaW5lID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9vbmNlRXZlbnRzLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9vbmNlRXZlbnRzID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9yZXBlYXRlZEV2ZW50cy5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fcmVwZWF0ZWRFdmVudHMgPSBudWxsO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblx0ICAgIC8vXHRJTklUSUFMSVpBVElPTlxuXHQgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQgICAgdmFyIFRyYW5zcG9ydENvbnN0cnVjdG9yID0gVG9uZS5UcmFuc3BvcnQ7XG5cdCAgICBUb25lLlRyYW5zcG9ydCA9IG5ldyBUcmFuc3BvcnRDb25zdHJ1Y3RvcigpO1xuXHQgICAgVG9uZS5Db250ZXh0Lm9uKCdpbml0JywgZnVuY3Rpb24gKGNvbnRleHQpIHtcblx0ICAgICAgICBpZiAoY29udGV4dC5UcmFuc3BvcnQgaW5zdGFuY2VvZiBUcmFuc3BvcnRDb25zdHJ1Y3Rvcikge1xuXHQgICAgICAgICAgICBUb25lLlRyYW5zcG9ydCA9IGNvbnRleHQuVHJhbnNwb3J0O1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIFRvbmUuVHJhbnNwb3J0ID0gbmV3IFRyYW5zcG9ydENvbnN0cnVjdG9yKCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8vc3RvcmUgdGhlIFRyYW5zcG9ydCBvbiB0aGUgY29udGV4dCBzbyBpdCBjYW4gYmUgcmV0cmlldmVkIGxhdGVyXG5cdCAgICAgICAgY29udGV4dC5UcmFuc3BvcnQgPSBUb25lLlRyYW5zcG9ydDtcblx0ICAgIH0pO1xuXHQgICAgVG9uZS5Db250ZXh0Lm9uKCdjbG9zZScsIGZ1bmN0aW9uIChjb250ZXh0KSB7XG5cdCAgICAgICAgaWYgKGNvbnRleHQuVHJhbnNwb3J0IGluc3RhbmNlb2YgVHJhbnNwb3J0Q29uc3RydWN0b3IpIHtcblx0ICAgICAgICAgICAgY29udGV4dC5UcmFuc3BvcnQuZGlzcG9zZSgpO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgcmV0dXJuIFRvbmUuVHJhbnNwb3J0O1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgVG9uZS5Wb2x1bWUgaXMgYSBzaW1wbGUgdm9sdW1lIG5vZGUsIHVzZWZ1bCBmb3IgY3JlYXRpbmcgYSB2b2x1bWUgZmFkZXIuXG5cdFx0ICpcblx0XHQgKiAgQGV4dGVuZHMge1RvbmUuQXVkaW9Ob2RlfVxuXHRcdCAqICBAY29uc3RydWN0b3Jcblx0XHQgKiAgQHBhcmFtIHtEZWNpYmVsc30gW3ZvbHVtZT0wXSB0aGUgaW5pdGlhbCB2b2x1bWVcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiB2YXIgdm9sID0gbmV3IFRvbmUuVm9sdW1lKC0xMik7XG5cdFx0ICogaW5zdHJ1bWVudC5jaGFpbih2b2wsIFRvbmUuTWFzdGVyKTtcblx0XHQgKi9cblx0ICAgIFRvbmUuVm9sdW1lID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBvcHRpb25zID0gVG9uZS5kZWZhdWx0cyhhcmd1bWVudHMsIFsndm9sdW1lJ10sIFRvbmUuVm9sdW1lKTtcblx0ICAgICAgICBUb25lLkF1ZGlvTm9kZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogdGhlIG91dHB1dCBub2RlXG5cdFx0XHQgKiBAdHlwZSB7R2Fpbk5vZGV9XG5cdFx0XHQgKiBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5vdXRwdXQgPSB0aGlzLmlucHV0ID0gbmV3IFRvbmUuR2FpbihvcHRpb25zLnZvbHVtZSwgVG9uZS5UeXBlLkRlY2liZWxzKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqIFRoZSB1bm11dGVkIHZvbHVtZVxuXHRcdFx0ICogQHR5cGUge0RlY2liZWxzfVxuXHRcdFx0ICogQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX3VubXV0ZWRWb2x1bWUgPSBvcHRpb25zLnZvbHVtZTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgdm9sdW1lIGNvbnRyb2wgaW4gZGVjaWJlbHMuXG5cdFx0XHQgKiAgQHR5cGUge0RlY2liZWxzfVxuXHRcdFx0ICogIEBzaWduYWxcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMudm9sdW1lID0gdGhpcy5vdXRwdXQuZ2Fpbjtcblx0ICAgICAgICB0aGlzLl9yZWFkT25seSgndm9sdW1lJyk7XG5cdCAgICAgICAgLy9zZXQgdGhlIG11dGUgaW5pdGlhbGx5XG5cdCAgICAgICAgdGhpcy5tdXRlID0gb3B0aW9ucy5tdXRlO1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuVm9sdW1lLCBUb25lLkF1ZGlvTm9kZSk7XG5cdCAgICAvKipcblx0XHQgKiAgRGVmYXVsdHNcblx0XHQgKiAgQHR5cGUgIHtPYmplY3R9XG5cdFx0ICogIEBjb25zdFxuXHRcdCAqICBAc3RhdGljXG5cdFx0ICovXG5cdCAgICBUb25lLlZvbHVtZS5kZWZhdWx0cyA9IHtcblx0ICAgICAgICAndm9sdW1lJzogMCxcblx0ICAgICAgICAnbXV0ZSc6IGZhbHNlXG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogTXV0ZSB0aGUgb3V0cHV0LlxuXHRcdCAqIEBtZW1iZXJPZiBUb25lLlZvbHVtZSNcblx0XHQgKiBAdHlwZSB7Ym9vbGVhbn1cblx0XHQgKiBAbmFtZSBtdXRlXG5cdFx0ICogQGV4YW1wbGVcblx0XHQgKiAvL211dGUgdGhlIG91dHB1dFxuXHRcdCAqIHZvbHVtZS5tdXRlID0gdHJ1ZTtcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLlZvbHVtZS5wcm90b3R5cGUsICdtdXRlJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy52b2x1bWUudmFsdWUgPT09IC1JbmZpbml0eTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKG11dGUpIHtcblx0ICAgICAgICAgICAgaWYgKCF0aGlzLm11dGUgJiYgbXV0ZSkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fdW5tdXRlZFZvbHVtZSA9IHRoaXMudm9sdW1lLnZhbHVlO1xuXHQgICAgICAgICAgICAgICAgLy9tYXliZSBpdCBzaG91bGQgcmFtcCBoZXJlP1xuXHQgICAgICAgICAgICAgICAgdGhpcy52b2x1bWUudmFsdWUgPSAtSW5maW5pdHk7XG5cdCAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5tdXRlICYmICFtdXRlKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLnZvbHVtZS52YWx1ZSA9IHRoaXMuX3VubXV0ZWRWb2x1bWU7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBjbGVhbiB1cFxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5Wb2x1bWV9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuVm9sdW1lLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHRoaXMuaW5wdXQuZGlzcG9zZSgpO1xuXHQgICAgICAgIFRvbmUuQXVkaW9Ob2RlLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgdGhpcy5fd3JpdGFibGUoJ3ZvbHVtZScpO1xuXHQgICAgICAgIHRoaXMudm9sdW1lLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLnZvbHVtZSA9IG51bGw7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuVm9sdW1lO1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgIEEgc2luZ2xlIG1hc3RlciBvdXRwdXQgd2hpY2ggaXMgY29ubmVjdGVkIHRvIHRoZVxuXHRcdCAqICAgICAgICAgIEF1ZGlvRGVzdGluYXRpb25Ob2RlIChha2EgeW91ciBzcGVha2VycykuXG5cdFx0ICogICAgICAgICAgSXQgcHJvdmlkZXMgdXNlZnVsIGNvbnZlbmllbmNlcyBzdWNoIGFzIHRoZSBhYmlsaXR5XG5cdFx0ICogICAgICAgICAgdG8gc2V0IHRoZSB2b2x1bWUgYW5kIG11dGUgdGhlIGVudGlyZSBhcHBsaWNhdGlvbi5cblx0XHQgKiAgICAgICAgICBJdCBhbHNvIGdpdmVzIHlvdSB0aGUgYWJpbGl0eSB0byBhcHBseSBtYXN0ZXIgZWZmZWN0cyB0byB5b3VyIGFwcGxpY2F0aW9uLlxuXHRcdCAqICAgICAgICAgIDxicj48YnI+XG5cdFx0ICogICAgICAgICAgTGlrZSBUb25lLlRyYW5zcG9ydCwgQSBzaW5nbGUgVG9uZS5NYXN0ZXIgaXMgY3JlYXRlZFxuXHRcdCAqICAgICAgICAgIG9uIGluaXRpYWxpemF0aW9uIGFuZCB5b3UgZG8gbm90IG5lZWQgdG8gZXhwbGljaXRseSBjb25zdHJ1Y3Qgb25lLlxuXHRcdCAqXG5cdFx0ICogIEBjb25zdHJ1Y3RvclxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZX1cblx0XHQgKiAgQHNpbmdsZXRvblxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIC8vdGhlIGF1ZGlvIHdpbGwgZ28gZnJvbSB0aGUgb3NjaWxsYXRvciB0byB0aGUgc3BlYWtlcnNcblx0XHQgKiBvc2NpbGxhdG9yLmNvbm5lY3QoVG9uZS5NYXN0ZXIpO1xuXHRcdCAqIC8vYSBjb252ZW5pZW5jZSBmb3IgY29ubmVjdGluZyB0byB0aGUgbWFzdGVyIG91dHB1dCBpcyBhbHNvIHByb3ZpZGVkOlxuXHRcdCAqIG9zY2lsbGF0b3IudG9NYXN0ZXIoKTtcblx0XHQgKiAvL3RoZSBhYm92ZSB0d28gZXhhbXBsZXMgYXJlIGVxdWl2YWxlbnQuXG5cdFx0ICovXG5cdCAgICBUb25lLk1hc3RlciA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLkF1ZGlvTm9kZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIFRvbmUuZ2V0Q29udGV4dChmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHRoaXMuY3JlYXRlSW5zT3V0cygxLCAwKTtcblx0ICAgICAgICAgICAgLyoqXG5cdFx0XHRcdCAqICBUaGUgcHJpdmF0ZSB2b2x1bWUgbm9kZVxuXHRcdFx0XHQgKiAgQHR5cGUgIHtUb25lLlZvbHVtZX1cblx0XHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHRcdCAqL1xuXHQgICAgICAgICAgICB0aGlzLl92b2x1bWUgPSB0aGlzLm91dHB1dCA9IG5ldyBUb25lLlZvbHVtZSgpO1xuXHQgICAgICAgICAgICAvKipcblx0XHRcdFx0ICogVGhlIHZvbHVtZSBvZiB0aGUgbWFzdGVyIG91dHB1dC5cblx0XHRcdFx0ICogQHR5cGUge0RlY2liZWxzfVxuXHRcdFx0XHQgKiBAc2lnbmFsXG5cdFx0XHRcdCAqL1xuXHQgICAgICAgICAgICB0aGlzLnZvbHVtZSA9IHRoaXMuX3ZvbHVtZS52b2x1bWU7XG5cdCAgICAgICAgICAgIHRoaXMuX3JlYWRPbmx5KCd2b2x1bWUnKTtcblx0ICAgICAgICAgICAgLy9jb25uZWN0aW9uc1xuXHQgICAgICAgICAgICB0aGlzLmlucHV0LmNoYWluKHRoaXMub3V0cHV0LCB0aGlzLmNvbnRleHQuZGVzdGluYXRpb24pO1xuXHQgICAgICAgIH0uYmluZCh0aGlzKSk7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5NYXN0ZXIsIFRvbmUuQXVkaW9Ob2RlKTtcblx0ICAgIC8qKlxuXHRcdCAqICBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqICBAY29uc3Rcblx0XHQgKi9cblx0ICAgIFRvbmUuTWFzdGVyLmRlZmF1bHRzID0ge1xuXHQgICAgICAgICd2b2x1bWUnOiAwLFxuXHQgICAgICAgICdtdXRlJzogZmFsc2Vcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiBNdXRlIHRoZSBvdXRwdXQuXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuTWFzdGVyI1xuXHRcdCAqIEB0eXBlIHtib29sZWFufVxuXHRcdCAqIEBuYW1lIG11dGVcblx0XHQgKiBAZXhhbXBsZVxuXHRcdCAqIC8vbXV0ZSB0aGUgb3V0cHV0XG5cdFx0ICogVG9uZS5NYXN0ZXIubXV0ZSA9IHRydWU7XG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5NYXN0ZXIucHJvdG90eXBlLCAnbXV0ZScsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ZvbHVtZS5tdXRlO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAobXV0ZSkge1xuXHQgICAgICAgICAgICB0aGlzLl92b2x1bWUubXV0ZSA9IG11dGU7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgQWRkIGEgbWFzdGVyIGVmZmVjdHMgY2hhaW4uIE5PVEU6IHRoaXMgd2lsbCBkaXNjb25uZWN0IGFueSBub2RlcyB3aGljaCB3ZXJlIHByZXZpb3VzbHlcblx0XHQgKiAgY2hhaW5lZCBpbiB0aGUgbWFzdGVyIGVmZmVjdHMgY2hhaW4uXG5cdFx0ICogIEBwYXJhbSB7QXVkaW9Ob2RlfFRvbmV9IGFyZ3MuLi4gQWxsIGFyZ3VtZW50cyB3aWxsIGJlIGNvbm5lY3RlZCBpbiBhIHJvd1xuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuZCB0aGUgTWFzdGVyIHdpbGwgYmUgcm91dGVkIHRocm91Z2ggaXQuXG5cdFx0ICogIEByZXR1cm4gIHtUb25lLk1hc3Rlcn0gIHRoaXNcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAvL3NvbWUgb3ZlcmFsbCBjb21wcmVzc2lvbiB0byBrZWVwIHRoZSBsZXZlbHMgaW4gY2hlY2tcblx0XHQgKiB2YXIgbWFzdGVyQ29tcHJlc3NvciA9IG5ldyBUb25lLkNvbXByZXNzb3Ioe1xuXHRcdCAqIFx0XCJ0aHJlc2hvbGRcIiA6IC02LFxuXHRcdCAqIFx0XCJyYXRpb1wiIDogMyxcblx0XHQgKiBcdFwiYXR0YWNrXCIgOiAwLjUsXG5cdFx0ICogXHRcInJlbGVhc2VcIiA6IDAuMVxuXHRcdCAqIH0pO1xuXHRcdCAqIC8vZ2l2ZSBhIGxpdHRsZSBib29zdCB0byB0aGUgbG93c1xuXHRcdCAqIHZhciBsb3dCdW1wID0gbmV3IFRvbmUuRmlsdGVyKDIwMCwgXCJsb3dzaGVsZlwiKTtcblx0XHQgKiAvL3JvdXRlIGV2ZXJ5dGhpbmcgdGhyb3VnaCB0aGUgZmlsdGVyXG5cdFx0ICogLy9hbmQgY29tcHJlc3NvciBiZWZvcmUgZ29pbmcgdG8gdGhlIHNwZWFrZXJzXG5cdFx0ICogVG9uZS5NYXN0ZXIuY2hhaW4obG93QnVtcCwgbWFzdGVyQ29tcHJlc3Nvcik7XG5cdFx0ICovXG5cdCAgICBUb25lLk1hc3Rlci5wcm90b3R5cGUuY2hhaW4gPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdGhpcy5pbnB1dC5kaXNjb25uZWN0KCk7XG5cdCAgICAgICAgdGhpcy5pbnB1dC5jaGFpbi5hcHBseSh0aGlzLmlucHV0LCBhcmd1bWVudHMpO1xuXHQgICAgICAgIGFyZ3VtZW50c1thcmd1bWVudHMubGVuZ3RoIC0gMV0uY29ubmVjdCh0aGlzLm91dHB1dCk7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIENsZWFuIHVwXG5cdFx0ICogIEByZXR1cm4gIHtUb25lLk1hc3Rlcn0gIHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuTWFzdGVyLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuQXVkaW9Ob2RlLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgdGhpcy5fd3JpdGFibGUoJ3ZvbHVtZScpO1xuXHQgICAgICAgIHRoaXMuX3ZvbHVtZS5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fdm9sdW1lID0gbnVsbDtcblx0ICAgICAgICB0aGlzLnZvbHVtZSA9IG51bGw7XG5cdCAgICB9O1xuXHQgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdCAgICAvL1x0QVVHTUVOVCBUT05FJ3MgUFJPVE9UWVBFXG5cdCAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblx0ICAgIC8qKlxuXHRcdCAqICBDb25uZWN0ICd0aGlzJyB0byB0aGUgbWFzdGVyIG91dHB1dC4gU2hvcnRoYW5kIGZvciB0aGlzLmNvbm5lY3QoVG9uZS5NYXN0ZXIpXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLkF1ZGlvTm9kZX0gdGhpc1xuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIC8vY29ubmVjdCBhbiBvc2NpbGxhdG9yIHRvIHRoZSBtYXN0ZXIgb3V0cHV0XG5cdFx0ICogdmFyIG9zYyA9IG5ldyBUb25lLk9zY2lsbGF0b3IoKS50b01hc3RlcigpO1xuXHRcdCAqL1xuXHQgICAgVG9uZS5BdWRpb05vZGUucHJvdG90eXBlLnRvTWFzdGVyID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHRoaXMuY29ubmVjdChUb25lLk1hc3Rlcik7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgaWYgKHdpbmRvdy5BdWRpb05vZGUpIHtcblx0ICAgICAgICAvLyBBbHNvIGF1Z21lbnQgQXVkaW9Ob2RlJ3MgcHJvdG90eXBlIHRvIGluY2x1ZGUgdG9NYXN0ZXIgYXMgYSBjb252ZW5pZW5jZVxuXHQgICAgICAgIEF1ZGlvTm9kZS5wcm90b3R5cGUudG9NYXN0ZXIgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHRoaXMuY29ubmVjdChUb25lLk1hc3Rlcik7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgICAgIH07XG5cdCAgICB9XG5cdCAgICAvKipcblx0XHQgKiAgaW5pdGlhbGl6ZSB0aGUgbW9kdWxlIGFuZCBsaXN0ZW4gZm9yIG5ldyBhdWRpbyBjb250ZXh0c1xuXHRcdCAqL1xuXHQgICAgdmFyIE1hc3RlckNvbnN0cnVjdG9yID0gVG9uZS5NYXN0ZXI7XG5cdCAgICBUb25lLk1hc3RlciA9IG5ldyBNYXN0ZXJDb25zdHJ1Y3RvcigpO1xuXHQgICAgVG9uZS5Db250ZXh0Lm9uKCdpbml0JywgZnVuY3Rpb24gKGNvbnRleHQpIHtcblx0ICAgICAgICAvLyBpZiBpdCBhbHJlYWR5IGV4aXN0cywganVzdCByZXN0b3JlIGl0XG5cdCAgICAgICAgaWYgKGNvbnRleHQuTWFzdGVyIGluc3RhbmNlb2YgTWFzdGVyQ29uc3RydWN0b3IpIHtcblx0ICAgICAgICAgICAgVG9uZS5NYXN0ZXIgPSBjb250ZXh0Lk1hc3Rlcjtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICBUb25lLk1hc3RlciA9IG5ldyBNYXN0ZXJDb25zdHJ1Y3RvcigpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBjb250ZXh0Lk1hc3RlciA9IFRvbmUuTWFzdGVyO1xuXHQgICAgfSk7XG5cdCAgICBUb25lLkNvbnRleHQub24oJ2Nsb3NlJywgZnVuY3Rpb24gKGNvbnRleHQpIHtcblx0ICAgICAgICBpZiAoY29udGV4dC5NYXN0ZXIgaW5zdGFuY2VvZiBNYXN0ZXJDb25zdHJ1Y3Rvcikge1xuXHQgICAgICAgICAgICBjb250ZXh0Lk1hc3Rlci5kaXNwb3NlKCk7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICByZXR1cm4gVG9uZS5NYXN0ZXI7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyAgQmFzZSBjbGFzcyBmb3Igc291cmNlcy4gU291cmNlcyBoYXZlIHN0YXJ0L3N0b3AgbWV0aG9kc1xuXHRcdCAqICAgICAgICAgIGFuZCB0aGUgYWJpbGl0eSB0byBiZSBzeW5jZWQgdG8gdGhlXG5cdFx0ICogICAgICAgICAgc3RhcnQvc3RvcCBvZiBUb25lLlRyYW5zcG9ydC5cblx0XHQgKlxuXHRcdCAqICBAY29uc3RydWN0b3Jcblx0XHQgKiAgQGV4dGVuZHMge1RvbmUuQXVkaW9Ob2RlfVxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIC8vTXVsdGlwbGUgc3RhdGUgY2hhbmdlIGV2ZW50cyBjYW4gYmUgY2hhaW5lZCB0b2dldGhlcixcblx0XHQgKiAvL2J1dCBtdXN0IGJlIHNldCBpbiB0aGUgY29ycmVjdCBvcmRlciBhbmQgd2l0aCBhc2NlbmRpbmcgdGltZXNcblx0XHQgKlxuXHRcdCAqIC8vIE9LXG5cdFx0ICogc3RhdGUuc3RhcnQoKS5zdG9wKFwiKzAuMlwiKTtcblx0XHQgKiAvLyBBTkRcblx0XHQgKiBzdGF0ZS5zdGFydCgpLnN0b3AoXCIrMC4yXCIpLnN0YXJ0KFwiKzAuNFwiKS5zdG9wKFwiKzAuN1wiKVxuXHRcdCAqXG5cdFx0ICogLy8gQkFEXG5cdFx0ICogc3RhdGUuc3RvcChcIiswLjJcIikuc3RhcnQoKTtcblx0XHQgKiAvLyBPUlxuXHRcdCAqIHN0YXRlLnN0YXJ0KFwiKzAuM1wiKS5zdG9wKFwiKzAuMlwiKTtcblx0XHQgKlxuXHRcdCAqL1xuXHQgICAgVG9uZS5Tb3VyY2UgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuXHQgICAgICAgIG9wdGlvbnMgPSBUb25lLmRlZmF1bHRBcmcob3B0aW9ucywgVG9uZS5Tb3VyY2UuZGVmYXVsdHMpO1xuXHQgICAgICAgIFRvbmUuQXVkaW9Ob2RlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIG91dHB1dCB2b2x1bWUgbm9kZVxuXHRcdFx0ICogIEB0eXBlICB7VG9uZS5Wb2x1bWV9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX3ZvbHVtZSA9IHRoaXMub3V0cHV0ID0gbmV3IFRvbmUuVm9sdW1lKG9wdGlvbnMudm9sdW1lKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqIFRoZSB2b2x1bWUgb2YgdGhlIG91dHB1dCBpbiBkZWNpYmVscy5cblx0XHRcdCAqIEB0eXBlIHtEZWNpYmVsc31cblx0XHRcdCAqIEBzaWduYWxcblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiBzb3VyY2Uudm9sdW1lLnZhbHVlID0gLTY7XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLnZvbHVtZSA9IHRoaXMuX3ZvbHVtZS52b2x1bWU7XG5cdCAgICAgICAgdGhpcy5fcmVhZE9ubHkoJ3ZvbHVtZScpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogXHRLZWVwIHRyYWNrIG9mIHRoZSBzY2hlZHVsZWQgc3RhdGUuXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuVGltZWxpbmVTdGF0ZX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fc3RhdGUgPSBuZXcgVG9uZS5UaW1lbGluZVN0YXRlKFRvbmUuU3RhdGUuU3RvcHBlZCk7XG5cdCAgICAgICAgdGhpcy5fc3RhdGUubWVtb3J5ID0gMTA7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIHN5bmNlZCBgc3RhcnRgIGNhbGxiYWNrIGZ1bmN0aW9uIGZyb20gdGhlIHRyYW5zcG9ydFxuXHRcdFx0ICogIEB0eXBlIHtGdW5jdGlvbn1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fc3luY2VkID0gZmFsc2U7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgS2VlcCB0cmFjayBvZiBhbGwgb2YgdGhlIHNjaGVkdWxlZCBldmVudCBpZHNcblx0XHRcdCAqICBAdHlwZSAge0FycmF5fVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9zY2hlZHVsZWQgPSBbXTtcblx0ICAgICAgICAvL21ha2UgdGhlIG91dHB1dCBleHBsaWNpdGx5IHN0ZXJlb1xuXHQgICAgICAgIHRoaXMuX3ZvbHVtZS5vdXRwdXQub3V0cHV0LmNoYW5uZWxDb3VudCA9IDI7XG5cdCAgICAgICAgdGhpcy5fdm9sdW1lLm91dHB1dC5vdXRwdXQuY2hhbm5lbENvdW50TW9kZSA9ICdleHBsaWNpdCc7XG5cdCAgICAgICAgLy9tdXRlIGluaXRpYWxseVxuXHQgICAgICAgIHRoaXMubXV0ZSA9IG9wdGlvbnMubXV0ZTtcblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLlNvdXJjZSwgVG9uZS5BdWRpb05vZGUpO1xuXHQgICAgLyoqXG5cdFx0ICogIFRoZSBkZWZhdWx0IHBhcmFtZXRlcnNcblx0XHQgKiAgQHN0YXRpY1xuXHRcdCAqICBAY29uc3Rcblx0XHQgKiAgQHR5cGUge09iamVjdH1cblx0XHQgKi9cblx0ICAgIFRvbmUuU291cmNlLmRlZmF1bHRzID0ge1xuXHQgICAgICAgICd2b2x1bWUnOiAwLFxuXHQgICAgICAgICdtdXRlJzogZmFsc2Vcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgUmV0dXJucyB0aGUgcGxheWJhY2sgc3RhdGUgb2YgdGhlIHNvdXJjZSwgZWl0aGVyIFwic3RhcnRlZFwiIG9yIFwic3RvcHBlZFwiLlxuXHRcdCAqICBAdHlwZSB7VG9uZS5TdGF0ZX1cblx0XHQgKiAgQHJlYWRPbmx5XG5cdFx0ICogIEBtZW1iZXJPZiBUb25lLlNvdXJjZSNcblx0XHQgKiAgQG5hbWUgc3RhdGVcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLlNvdXJjZS5wcm90b3R5cGUsICdzdGF0ZScsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgaWYgKHRoaXMuX3N5bmNlZCkge1xuXHQgICAgICAgICAgICAgICAgaWYgKFRvbmUuVHJhbnNwb3J0LnN0YXRlID09PSBUb25lLlN0YXRlLlN0YXJ0ZWQpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fc3RhdGUuZ2V0VmFsdWVBdFRpbWUoVG9uZS5UcmFuc3BvcnQuc2Vjb25kcyk7XG5cdCAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBUb25lLlN0YXRlLlN0b3BwZWQ7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fc3RhdGUuZ2V0VmFsdWVBdFRpbWUodGhpcy5ub3coKSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqIE11dGUgdGhlIG91dHB1dC5cblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5Tb3VyY2UjXG5cdFx0ICogQHR5cGUge2Jvb2xlYW59XG5cdFx0ICogQG5hbWUgbXV0ZVxuXHRcdCAqIEBleGFtcGxlXG5cdFx0ICogLy9tdXRlIHRoZSBvdXRwdXRcblx0XHQgKiBzb3VyY2UubXV0ZSA9IHRydWU7XG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5Tb3VyY2UucHJvdG90eXBlLCAnbXV0ZScsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ZvbHVtZS5tdXRlO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAobXV0ZSkge1xuXHQgICAgICAgICAgICB0aGlzLl92b2x1bWUubXV0ZSA9IG11dGU7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvL292ZXJ3cml0ZSB0aGVzZSBmdW5jdGlvbnNcblx0ICAgIFRvbmUuU291cmNlLnByb3RvdHlwZS5fc3RhcnQgPSBUb25lLm5vT3A7XG5cdCAgICBUb25lLlNvdXJjZS5wcm90b3R5cGUuX3N0b3AgPSBUb25lLm5vT3A7XG5cdCAgICAvKipcblx0XHQgKiAgU3RhcnQgdGhlIHNvdXJjZSBhdCB0aGUgc3BlY2lmaWVkIHRpbWUuIElmIG5vIHRpbWUgaXMgZ2l2ZW4sXG5cdFx0ICogIHN0YXJ0IHRoZSBzb3VyY2Ugbm93LlxuXHRcdCAqICBAcGFyYW0gIHtUaW1lfSBbdGltZT1ub3ddIFdoZW4gdGhlIHNvdXJjZSBzaG91bGQgYmUgc3RhcnRlZC5cblx0XHQgKiAgQHJldHVybnMge1RvbmUuU291cmNlfSB0aGlzXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogc291cmNlLnN0YXJ0KFwiKzAuNVwiKTsgLy9zdGFydHMgdGhlIHNvdXJjZSAwLjUgc2Vjb25kcyBmcm9tIG5vd1xuXHRcdCAqL1xuXHQgICAgVG9uZS5Tb3VyY2UucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24gKHRpbWUsIG9mZnNldCwgZHVyYXRpb24pIHtcblx0ICAgICAgICBpZiAoVG9uZS5pc1VuZGVmKHRpbWUpICYmIHRoaXMuX3N5bmNlZCkge1xuXHQgICAgICAgICAgICB0aW1lID0gVG9uZS5UcmFuc3BvcnQuc2Vjb25kcztcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICB0aW1lID0gdGhpcy50b1NlY29uZHModGltZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8vaWYgaXQncyBzdGFydGVkLCBzdG9wIGl0IGFuZCByZXN0YXJ0IGl0XG5cdCAgICAgICAgaWYgKCF0aGlzLnJldHJpZ2dlciAmJiB0aGlzLl9zdGF0ZS5nZXRWYWx1ZUF0VGltZSh0aW1lKSA9PT0gVG9uZS5TdGF0ZS5TdGFydGVkKSB7XG5cdCAgICAgICAgICAgIHRoaXMuc3RvcCh0aW1lKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdGhpcy5fc3RhdGUuc2V0U3RhdGVBdFRpbWUoVG9uZS5TdGF0ZS5TdGFydGVkLCB0aW1lKTtcblx0ICAgICAgICBpZiAodGhpcy5fc3luY2VkKSB7XG5cdCAgICAgICAgICAgIC8vIGFkZCB0aGUgb2Zmc2V0IHRpbWUgdG8gdGhlIGV2ZW50XG5cdCAgICAgICAgICAgIHZhciBldmVudCA9IHRoaXMuX3N0YXRlLmdldCh0aW1lKTtcblx0ICAgICAgICAgICAgZXZlbnQub2Zmc2V0ID0gVG9uZS5kZWZhdWx0QXJnKG9mZnNldCwgMCk7XG5cdCAgICAgICAgICAgIGV2ZW50LmR1cmF0aW9uID0gZHVyYXRpb247XG5cdCAgICAgICAgICAgIHZhciBzY2hlZCA9IFRvbmUuVHJhbnNwb3J0LnNjaGVkdWxlKGZ1bmN0aW9uICh0KSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9zdGFydCh0LCBvZmZzZXQsIGR1cmF0aW9uKTtcblx0ICAgICAgICAgICAgfS5iaW5kKHRoaXMpLCB0aW1lKTtcblx0ICAgICAgICAgICAgdGhpcy5fc2NoZWR1bGVkLnB1c2goc2NoZWQpO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3N0YXJ0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBTdG9wIHRoZSBzb3VyY2UgYXQgdGhlIHNwZWNpZmllZCB0aW1lLiBJZiBubyB0aW1lIGlzIGdpdmVuLFxuXHRcdCAqICBzdG9wIHRoZSBzb3VyY2Ugbm93LlxuXHRcdCAqICBAcGFyYW0gIHtUaW1lfSBbdGltZT1ub3ddIFdoZW4gdGhlIHNvdXJjZSBzaG91bGQgYmUgc3RvcHBlZC5cblx0XHQgKiAgQHJldHVybnMge1RvbmUuU291cmNlfSB0aGlzXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogc291cmNlLnN0b3AoKTsgLy8gc3RvcHMgdGhlIHNvdXJjZSBpbW1lZGlhdGVseVxuXHRcdCAqL1xuXHQgICAgVG9uZS5Tb3VyY2UucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAodGltZSkge1xuXHQgICAgICAgIGlmIChUb25lLmlzVW5kZWYodGltZSkgJiYgdGhpcy5fc3luY2VkKSB7XG5cdCAgICAgICAgICAgIHRpbWUgPSBUb25lLlRyYW5zcG9ydC5zZWNvbmRzO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIHRpbWUgPSB0aGlzLnRvU2Vjb25kcyh0aW1lKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdGhpcy5fc3RhdGUuY2FuY2VsKHRpbWUpO1xuXHQgICAgICAgIHRoaXMuX3N0YXRlLnNldFN0YXRlQXRUaW1lKFRvbmUuU3RhdGUuU3RvcHBlZCwgdGltZSk7XG5cdCAgICAgICAgaWYgKCF0aGlzLl9zeW5jZWQpIHtcblx0ICAgICAgICAgICAgdGhpcy5fc3RvcC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIHZhciBzY2hlZCA9IFRvbmUuVHJhbnNwb3J0LnNjaGVkdWxlKHRoaXMuX3N0b3AuYmluZCh0aGlzKSwgdGltZSk7XG5cdCAgICAgICAgICAgIHRoaXMuX3NjaGVkdWxlZC5wdXNoKHNjaGVkKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFN5bmMgdGhlIHNvdXJjZSB0byB0aGUgVHJhbnNwb3J0IHNvIHRoYXQgYWxsIHN1YnNlcXVlbnRcblx0XHQgKiAgY2FsbHMgdG8gYHN0YXJ0YCBhbmQgYHN0b3BgIGFyZSBzeW5jZWQgdG8gdGhlIFRyYW5zcG9ydFRpbWVcblx0XHQgKiAgaW5zdGVhZCBvZiB0aGUgQXVkaW9Db250ZXh0IHRpbWUuXG5cdFx0ICpcblx0XHQgKiAgQHJldHVybnMge1RvbmUuU291cmNlfSB0aGlzXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogLy9zeW5jIHRoZSBzb3VyY2Ugc28gdGhhdCBpdCBwbGF5cyBiZXR3ZWVuIDAgYW5kIDAuMyBvbiB0aGUgVHJhbnNwb3J0J3MgdGltZWxpbmVcblx0XHQgKiBzb3VyY2Uuc3luYygpLnN0YXJ0KDApLnN0b3AoMC4zKTtcblx0XHQgKiAvL3N0YXJ0IHRoZSB0cmFuc3BvcnQuXG5cdFx0ICogVG9uZS5UcmFuc3BvcnQuc3RhcnQoKTtcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIC8vc3RhcnQgdGhlIHRyYW5zcG9ydCB3aXRoIGFuIG9mZnNldCBhbmQgdGhlIHN5bmMnZWQgc291cmNlc1xuXHRcdCAqIC8vd2lsbCBzdGFydCBpbiB0aGUgY29ycmVjdCBwb3NpdGlvblxuXHRcdCAqIHNvdXJjZS5zeW5jKCkuc3RhcnQoMC4xKTtcblx0XHQgKiAvL3RoZSBzb3VyY2Ugd2lsbCBiZSBpbnZva2VkIHdpdGggYW4gb2Zmc2V0IG9mIDAuNFxuXHRcdCAqIFRvbmUuVHJhbnNwb3J0LnN0YXJ0KFwiKzAuNVwiLCAwLjUpO1xuXHRcdCAqL1xuXHQgICAgVG9uZS5Tb3VyY2UucHJvdG90eXBlLnN5bmMgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdGhpcy5fc3luY2VkID0gdHJ1ZTtcblx0ICAgICAgICB0aGlzLl9zeW5jZWRTdGFydCA9IGZ1bmN0aW9uICh0aW1lLCBvZmZzZXQpIHtcblx0ICAgICAgICAgICAgaWYgKG9mZnNldCA+IDApIHtcblx0ICAgICAgICAgICAgICAgIC8vIGdldCB0aGUgcGxheWJhY2sgc3RhdGUgYXQgdGhhdCB0aW1lXG5cdCAgICAgICAgICAgICAgICB2YXIgc3RhdGVFdmVudCA9IHRoaXMuX3N0YXRlLmdldChvZmZzZXQpO1xuXHQgICAgICAgICAgICAgICAgLy8gbGlzdGVuIGZvciBzdGFydCBldmVudHMgd2hpY2ggbWF5IG9jY3VyIGluIHRoZSBtaWRkbGUgb2YgdGhlIHN5bmMnZWQgdGltZVxuXHQgICAgICAgICAgICAgICAgaWYgKHN0YXRlRXZlbnQgJiYgc3RhdGVFdmVudC5zdGF0ZSA9PT0gVG9uZS5TdGF0ZS5TdGFydGVkICYmIHN0YXRlRXZlbnQudGltZSAhPT0gb2Zmc2V0KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgLy8gZ2V0IHRoZSBvZmZzZXRcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgc3RhcnRPZmZzZXQgPSBvZmZzZXQgLSB0aGlzLnRvU2Vjb25kcyhzdGF0ZUV2ZW50LnRpbWUpO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBkdXJhdGlvbjtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdGVFdmVudC5kdXJhdGlvbikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBkdXJhdGlvbiA9IHRoaXMudG9TZWNvbmRzKHN0YXRlRXZlbnQuZHVyYXRpb24pIC0gc3RhcnRPZmZzZXQ7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0KHRpbWUsIHRoaXMudG9TZWNvbmRzKHN0YXRlRXZlbnQub2Zmc2V0KSArIHN0YXJ0T2Zmc2V0LCBkdXJhdGlvbik7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9LmJpbmQodGhpcyk7XG5cdCAgICAgICAgdGhpcy5fc3luY2VkU3RvcCA9IGZ1bmN0aW9uICh0aW1lKSB7XG5cdCAgICAgICAgICAgIGlmICh0aGlzLl9zdGF0ZS5nZXRWYWx1ZUF0VGltZShUb25lLlRyYW5zcG9ydC5zZWNvbmRzKSA9PT0gVG9uZS5TdGF0ZS5TdGFydGVkKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9zdG9wKHRpbWUpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfS5iaW5kKHRoaXMpO1xuXHQgICAgICAgIFRvbmUuVHJhbnNwb3J0Lm9uKCdzdGFydCBsb29wU3RhcnQnLCB0aGlzLl9zeW5jZWRTdGFydCk7XG5cdCAgICAgICAgVG9uZS5UcmFuc3BvcnQub24oJ3N0b3AgcGF1c2UgbG9vcEVuZCcsIHRoaXMuX3N5bmNlZFN0b3ApO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBVbnN5bmMgdGhlIHNvdXJjZSB0byB0aGUgVHJhbnNwb3J0LiBTZWUgVG9uZS5Tb3VyY2Uuc3luY1xuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5Tb3VyY2V9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuU291cmNlLnByb3RvdHlwZS51bnN5bmMgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgaWYgKHRoaXMuX3N5bmNlZCkge1xuXHQgICAgICAgICAgICBUb25lLlRyYW5zcG9ydC5vZmYoJ3N0b3AgcGF1c2UgbG9vcEVuZCcsIHRoaXMuX3N5bmNlZFN0b3ApO1xuXHQgICAgICAgICAgICBUb25lLlRyYW5zcG9ydC5vZmYoJ3N0YXJ0IGxvb3BTdGFydCcsIHRoaXMuX3N5bmNlZFN0YXJ0KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdGhpcy5fc3luY2VkID0gZmFsc2U7XG5cdCAgICAgICAgLy8gY2xlYXIgYWxsIG9mIHRoZSBzY2hlZHVsZWQgaWRzXG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9zY2hlZHVsZWQubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgdmFyIGlkID0gdGhpcy5fc2NoZWR1bGVkW2ldO1xuXHQgICAgICAgICAgICBUb25lLlRyYW5zcG9ydC5jbGVhcihpZCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHRoaXMuX3NjaGVkdWxlZCA9IFtdO1xuXHQgICAgICAgIHRoaXMuX3N0YXRlLmNhbmNlbCgwKTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKlx0Q2xlYW4gdXAuXG5cdFx0ICogIEByZXR1cm4ge1RvbmUuU291cmNlfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLlNvdXJjZS5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLkF1ZGlvTm9kZS5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMudW5zeW5jKCk7XG5cdCAgICAgICAgdGhpcy5fc2NoZWR1bGVkID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl93cml0YWJsZSgndm9sdW1lJyk7XG5cdCAgICAgICAgdGhpcy5fdm9sdW1lLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl92b2x1bWUgPSBudWxsO1xuXHQgICAgICAgIHRoaXMudm9sdW1lID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9zdGF0ZS5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fc3RhdGUgPSBudWxsO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLlNvdXJjZTtcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgXG5cdCAgICAvKipcblx0XHQgKiAgT3NjaWxsYXRvck5vZGUgc2hpbVxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgaWYgKHdpbmRvdy5Pc2NpbGxhdG9yTm9kZSAmJiAhT3NjaWxsYXRvck5vZGUucHJvdG90eXBlLnN0YXJ0KSB7XG5cdCAgICAgICAgT3NjaWxsYXRvck5vZGUucHJvdG90eXBlLnN0YXJ0ID0gT3NjaWxsYXRvck5vZGUucHJvdG90eXBlLm5vdGVPbjtcblx0ICAgICAgICBPc2NpbGxhdG9yTm9kZS5wcm90b3R5cGUuc3RvcCA9IE9zY2lsbGF0b3JOb2RlLnByb3RvdHlwZS5ub3RlT2ZmO1xuXHQgICAgICAgIGlmICghT3NjaWxsYXRvck5vZGUucHJvdG90eXBlLnNldFBlcmlvZGljV2F2ZSkge1xuXHQgICAgICAgICAgICBPc2NpbGxhdG9yTm9kZS5wcm90b3R5cGUuc2V0UGVyaW9kaWNXYXZlID0gT3NjaWxsYXRvck5vZGUucHJvdG90eXBlLnNldFdhdmVUYWJsZTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKCFBdWRpb0NvbnRleHQucHJvdG90eXBlLmNyZWF0ZVBlcmlvZGljV2F2ZSkge1xuXHQgICAgICAgICAgICBBdWRpb0NvbnRleHQucHJvdG90eXBlLmNyZWF0ZVBlcmlvZGljV2F2ZSA9IEF1ZGlvQ29udGV4dC5wcm90b3R5cGUuY3JlYXRlV2F2ZVRhYmxlO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgVG9uZS5Pc2NpbGxhdG9yIHN1cHBvcnRzIGEgbnVtYmVyIG9mIGZlYXR1cmVzIGluY2x1ZGluZ1xuXHRcdCAqICAgICAgICAgcGhhc2Ugcm90YXRpb24sIG11bHRpcGxlIG9zY2lsbGF0b3IgdHlwZXMgKHNlZSBUb25lLk9zY2lsbGF0b3IudHlwZSksIFxuXHRcdCAqICAgICAgICAgYW5kIFRyYW5zcG9ydCBzeW5jaW5nIChzZWUgVG9uZS5Pc2NpbGxhdG9yLnN5bmNGcmVxdWVuY3kpLlxuXHRcdCAqXG5cdFx0ICogIEBjb25zdHJ1Y3RvclxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZS5Tb3VyY2V9XG5cdFx0ICogIEBwYXJhbSB7RnJlcXVlbmN5fSBbZnJlcXVlbmN5XSBTdGFydGluZyBmcmVxdWVuY3lcblx0XHQgKiAgQHBhcmFtIHtzdHJpbmd9IFt0eXBlXSBUaGUgb3NjaWxsYXRvciB0eXBlLiBSZWFkIG1vcmUgYWJvdXQgdHlwZSBiZWxvdy5cblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAvL21ha2UgYW5kIHN0YXJ0IGEgNDQwaHogc2luZSB0b25lXG5cdFx0ICogdmFyIG9zYyA9IG5ldyBUb25lLk9zY2lsbGF0b3IoNDQwLCBcInNpbmVcIikudG9NYXN0ZXIoKS5zdGFydCgpO1xuXHRcdCAqL1xuXHQgICAgVG9uZS5Pc2NpbGxhdG9yID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBvcHRpb25zID0gVG9uZS5kZWZhdWx0cyhhcmd1bWVudHMsIFtcblx0ICAgICAgICAgICAgJ2ZyZXF1ZW5jeScsXG5cdCAgICAgICAgICAgICd0eXBlJ1xuXHQgICAgICAgIF0sIFRvbmUuT3NjaWxsYXRvcik7XG5cdCAgICAgICAgVG9uZS5Tb3VyY2UuY2FsbCh0aGlzLCBvcHRpb25zKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICB0aGUgbWFpbiBvc2NpbGxhdG9yXG5cdFx0XHQgKiAgQHR5cGUge09zY2lsbGF0b3JOb2RlfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9vc2NpbGxhdG9yID0gbnVsbDtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgZnJlcXVlbmN5IGNvbnRyb2wuXG5cdFx0XHQgKiAgQHR5cGUge0ZyZXF1ZW5jeX1cblx0XHRcdCAqICBAc2lnbmFsXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmZyZXF1ZW5jeSA9IG5ldyBUb25lLlNpZ25hbChvcHRpb25zLmZyZXF1ZW5jeSwgVG9uZS5UeXBlLkZyZXF1ZW5jeSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGRldHVuZSBjb250cm9sIHNpZ25hbC5cblx0XHRcdCAqICBAdHlwZSB7Q2VudHN9XG5cdFx0XHQgKiAgQHNpZ25hbFxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5kZXR1bmUgPSBuZXcgVG9uZS5TaWduYWwob3B0aW9ucy5kZXR1bmUsIFRvbmUuVHlwZS5DZW50cyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgdGhlIHBlcmlvZGljIHdhdmVcblx0XHRcdCAqICBAdHlwZSB7UGVyaW9kaWNXYXZlfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl93YXZlID0gbnVsbDtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgcGFydGlhbHMgb2YgdGhlIG9zY2lsbGF0b3Jcblx0XHRcdCAqICBAdHlwZSB7QXJyYXl9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX3BhcnRpYWxzID0gVG9uZS5kZWZhdWx0QXJnKG9wdGlvbnMucGFydGlhbHMsIFsxXSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgdGhlIHBoYXNlIG9mIHRoZSBvc2NpbGxhdG9yXG5cdFx0XHQgKiAgYmV0d2VlbiAwIC0gMzYwXG5cdFx0XHQgKiAgQHR5cGUge251bWJlcn1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fcGhhc2UgPSBvcHRpb25zLnBoYXNlO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHRoZSB0eXBlIG9mIHRoZSBvc2NpbGxhdG9yXG5cdFx0XHQgKiAgQHR5cGUge3N0cmluZ31cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fdHlwZSA9IG51bGw7XG5cdCAgICAgICAgLy9zZXR1cFxuXHQgICAgICAgIHRoaXMudHlwZSA9IG9wdGlvbnMudHlwZTtcblx0ICAgICAgICB0aGlzLnBoYXNlID0gdGhpcy5fcGhhc2U7XG5cdCAgICAgICAgdGhpcy5fcmVhZE9ubHkoW1xuXHQgICAgICAgICAgICAnZnJlcXVlbmN5Jyxcblx0ICAgICAgICAgICAgJ2RldHVuZSdcblx0ICAgICAgICBdKTtcblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLk9zY2lsbGF0b3IsIFRvbmUuU291cmNlKTtcblx0ICAgIC8qKlxuXHRcdCAqICB0aGUgZGVmYXVsdCBwYXJhbWV0ZXJzXG5cdFx0ICogIEB0eXBlIHtPYmplY3R9XG5cdFx0ICovXG5cdCAgICBUb25lLk9zY2lsbGF0b3IuZGVmYXVsdHMgPSB7XG5cdCAgICAgICAgJ3R5cGUnOiAnc2luZScsXG5cdCAgICAgICAgJ2ZyZXF1ZW5jeSc6IDQ0MCxcblx0ICAgICAgICAnZGV0dW5lJzogMCxcblx0ICAgICAgICAncGhhc2UnOiAwLFxuXHQgICAgICAgICdwYXJ0aWFscyc6IFtdXG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFRoZSBPc2NpbGxhdG9yIHR5cGVzXG5cdFx0ICogIEBlbnVtIHtTdHJpbmd9XG5cdFx0ICovXG5cdCAgICBUb25lLk9zY2lsbGF0b3IuVHlwZSA9IHtcblx0ICAgICAgICBTaW5lOiAnc2luZScsXG5cdCAgICAgICAgVHJpYW5nbGU6ICd0cmlhbmdsZScsXG5cdCAgICAgICAgU2F3dG9vdGg6ICdzYXd0b290aCcsXG5cdCAgICAgICAgU3F1YXJlOiAnc3F1YXJlJyxcblx0ICAgICAgICBDdXN0b206ICdjdXN0b20nXG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIHN0YXJ0IHRoZSBvc2NpbGxhdG9yXG5cdFx0ICogIEBwYXJhbSAge1RpbWV9IFt0aW1lPW5vd10gXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLk9zY2lsbGF0b3IucHJvdG90eXBlLl9zdGFydCA9IGZ1bmN0aW9uICh0aW1lKSB7XG5cdCAgICAgICAgLy9uZXcgb3NjaWxsYXRvciB3aXRoIHByZXZpb3VzIHZhbHVlc1xuXHQgICAgICAgIHRoaXMuX29zY2lsbGF0b3IgPSB0aGlzLmNvbnRleHQuY3JlYXRlT3NjaWxsYXRvcigpO1xuXHQgICAgICAgIHRoaXMuX29zY2lsbGF0b3Iuc2V0UGVyaW9kaWNXYXZlKHRoaXMuX3dhdmUpO1xuXHQgICAgICAgIC8vY29ubmVjdCB0aGUgY29udHJvbCBzaWduYWwgdG8gdGhlIG9zY2lsbGF0b3IgZnJlcXVlbmN5ICYgZGV0dW5lXG5cdCAgICAgICAgdGhpcy5fb3NjaWxsYXRvci5jb25uZWN0KHRoaXMub3V0cHV0KTtcblx0ICAgICAgICB0aGlzLmZyZXF1ZW5jeS5jb25uZWN0KHRoaXMuX29zY2lsbGF0b3IuZnJlcXVlbmN5KTtcblx0ICAgICAgICB0aGlzLmRldHVuZS5jb25uZWN0KHRoaXMuX29zY2lsbGF0b3IuZGV0dW5lKTtcblx0ICAgICAgICAvL3N0YXJ0IHRoZSBvc2NpbGxhdG9yXG5cdCAgICAgICAgdGhpcy5fb3NjaWxsYXRvci5zdGFydCh0aGlzLnRvU2Vjb25kcyh0aW1lKSk7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIHN0b3AgdGhlIG9zY2lsbGF0b3Jcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKiAgQHBhcmFtICB7VGltZX0gW3RpbWU9bm93XSAob3B0aW9uYWwpIHRpbWluZyBwYXJhbWV0ZXJcblx0XHQgKiAgQHJldHVybnMge1RvbmUuT3NjaWxsYXRvcn0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5Pc2NpbGxhdG9yLnByb3RvdHlwZS5fc3RvcCA9IGZ1bmN0aW9uICh0aW1lKSB7XG5cdCAgICAgICAgaWYgKHRoaXMuX29zY2lsbGF0b3IpIHtcblx0ICAgICAgICAgICAgdGhpcy5fb3NjaWxsYXRvci5zdG9wKHRoaXMudG9TZWNvbmRzKHRpbWUpKTtcblx0ICAgICAgICAgICAgdGhpcy5fb3NjaWxsYXRvciA9IG51bGw7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBTeW5jIHRoZSBzaWduYWwgdG8gdGhlIFRyYW5zcG9ydCdzIGJwbS4gQW55IGNoYW5nZXMgdG8gdGhlIHRyYW5zcG9ydHMgYnBtLFxuXHRcdCAqICB3aWxsIGFsc28gYWZmZWN0IHRoZSBvc2NpbGxhdG9ycyBmcmVxdWVuY3kuIFxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5Pc2NpbGxhdG9yfSB0aGlzXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogVG9uZS5UcmFuc3BvcnQuYnBtLnZhbHVlID0gMTIwO1xuXHRcdCAqIG9zYy5mcmVxdWVuY3kudmFsdWUgPSA0NDA7XG5cdFx0ICogLy90aGUgcmF0aW9uIGJldHdlZW4gdGhlIGJwbSBhbmQgdGhlIGZyZXF1ZW5jeSB3aWxsIGJlIG1haW50YWluZWRcblx0XHQgKiBvc2Muc3luY0ZyZXF1ZW5jeSgpO1xuXHRcdCAqIFRvbmUuVHJhbnNwb3J0LmJwbS52YWx1ZSA9IDI0MDsgXG5cdFx0ICogLy8gdGhlIGZyZXF1ZW5jeSBvZiB0aGUgb3NjaWxsYXRvciBpcyBkb3VibGVkIHRvIDg4MFxuXHRcdCAqL1xuXHQgICAgVG9uZS5Pc2NpbGxhdG9yLnByb3RvdHlwZS5zeW5jRnJlcXVlbmN5ID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuVHJhbnNwb3J0LnN5bmNTaWduYWwodGhpcy5mcmVxdWVuY3kpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBVbnN5bmMgdGhlIG9zY2lsbGF0b3IncyBmcmVxdWVuY3kgZnJvbSB0aGUgVHJhbnNwb3J0LiBcblx0XHQgKiAgU2VlIFRvbmUuT3NjaWxsYXRvci5zeW5jRnJlcXVlbmN5XG5cdFx0ICogIEByZXR1cm5zIHtUb25lLk9zY2lsbGF0b3J9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuT3NjaWxsYXRvci5wcm90b3R5cGUudW5zeW5jRnJlcXVlbmN5ID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuVHJhbnNwb3J0LnVuc3luY1NpZ25hbCh0aGlzLmZyZXF1ZW5jeSk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogVGhlIHR5cGUgb2YgdGhlIG9zY2lsbGF0b3I6IGVpdGhlciBzaW5lLCBzcXVhcmUsIHRyaWFuZ2xlLCBvciBzYXd0b290aC4gQWxzbyBjYXBhYmxlIG9mXG5cdFx0ICogc2V0dGluZyB0aGUgZmlyc3QgeCBudW1iZXIgb2YgcGFydGlhbHMgb2YgdGhlIG9zY2lsbGF0b3IuIEZvciBleGFtcGxlOiBcInNpbmU0XCIgd291bGRcblx0XHQgKiBzZXQgYmUgdGhlIGZpcnN0IDQgcGFydGlhbHMgb2YgdGhlIHNpbmUgd2F2ZSBhbmQgXCJ0cmlhbmdsZThcIiB3b3VsZCBzZXQgdGhlIGZpcnN0XG5cdFx0ICogOCBwYXJ0aWFscyBvZiB0aGUgdHJpYW5nbGUgd2F2ZS5cblx0XHQgKiA8YnI+PGJyPiBcblx0XHQgKiBVc2VzIFBlcmlvZGljV2F2ZSBpbnRlcm5hbGx5IGV2ZW4gZm9yIG5hdGl2ZSB0eXBlcyBzbyB0aGF0IGl0IGNhbiBzZXQgdGhlIHBoYXNlLiBcblx0XHQgKiBQZXJpb2RpY1dhdmUgZXF1YXRpb25zIGFyZSBmcm9tIHRoZSBcblx0XHQgKiBbV2Via2l0IFdlYiBBdWRpbyBpbXBsZW1lbnRhdGlvbl0oaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9jb2Rlc2VhcmNoI2Nocm9taXVtL3NyYy90aGlyZF9wYXJ0eS9XZWJLaXQvU291cmNlL21vZHVsZXMvd2ViYXVkaW8vUGVyaW9kaWNXYXZlLmNwcCZzcT1wYWNrYWdlOmNocm9taXVtKS5cblx0XHQgKiAgXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuT3NjaWxsYXRvciNcblx0XHQgKiBAdHlwZSB7c3RyaW5nfVxuXHRcdCAqIEBuYW1lIHR5cGVcblx0XHQgKiBAZXhhbXBsZVxuXHRcdCAqIC8vc2V0IGl0IHRvIGEgc3F1YXJlIHdhdmVcblx0XHQgKiBvc2MudHlwZSA9IFwic3F1YXJlXCI7XG5cdFx0ICogQGV4YW1wbGVcblx0XHQgKiAvL3NldCB0aGUgZmlyc3QgNiBwYXJ0aWFscyBvZiBhIHNhd3Rvb3RoIHdhdmVcblx0XHQgKiBvc2MudHlwZSA9IFwic2F3dG9vdGg2XCI7XG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5Pc2NpbGxhdG9yLnByb3RvdHlwZSwgJ3R5cGUnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl90eXBlO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAodHlwZSkge1xuXHQgICAgICAgICAgICB2YXIgY29lZnMgPSB0aGlzLl9nZXRSZWFsSW1hZ2luYXJ5KHR5cGUsIHRoaXMuX3BoYXNlKTtcblx0ICAgICAgICAgICAgdmFyIHBlcmlvZGljV2F2ZSA9IHRoaXMuY29udGV4dC5jcmVhdGVQZXJpb2RpY1dhdmUoY29lZnNbMF0sIGNvZWZzWzFdKTtcblx0ICAgICAgICAgICAgdGhpcy5fd2F2ZSA9IHBlcmlvZGljV2F2ZTtcblx0ICAgICAgICAgICAgaWYgKHRoaXMuX29zY2lsbGF0b3IgIT09IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX29zY2lsbGF0b3Iuc2V0UGVyaW9kaWNXYXZlKHRoaXMuX3dhdmUpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHRoaXMuX3R5cGUgPSB0eXBlO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIFJldHVybnMgdGhlIHJlYWwgYW5kIGltYWdpbmFyeSBjb21wb25lbnRzIGJhc2VkIFxuXHRcdCAqICBvbiB0aGUgb3NjaWxsYXRvciB0eXBlLlxuXHRcdCAqICBAcmV0dXJucyB7QXJyYXl9IFtyZWFsLCBpbWFnaW5hcnldXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLk9zY2lsbGF0b3IucHJvdG90eXBlLl9nZXRSZWFsSW1hZ2luYXJ5ID0gZnVuY3Rpb24gKHR5cGUsIHBoYXNlKSB7XG5cdCAgICAgICAgdmFyIGZmdFNpemUgPSA0MDk2O1xuXHQgICAgICAgIHZhciBwZXJpb2RpY1dhdmVTaXplID0gZmZ0U2l6ZSAvIDI7XG5cdCAgICAgICAgdmFyIHJlYWwgPSBuZXcgRmxvYXQzMkFycmF5KHBlcmlvZGljV2F2ZVNpemUpO1xuXHQgICAgICAgIHZhciBpbWFnID0gbmV3IEZsb2F0MzJBcnJheShwZXJpb2RpY1dhdmVTaXplKTtcblx0ICAgICAgICB2YXIgcGFydGlhbENvdW50ID0gMTtcblx0ICAgICAgICBpZiAodHlwZSA9PT0gVG9uZS5Pc2NpbGxhdG9yLlR5cGUuQ3VzdG9tKSB7XG5cdCAgICAgICAgICAgIHBhcnRpYWxDb3VudCA9IHRoaXMuX3BhcnRpYWxzLmxlbmd0aCArIDE7XG5cdCAgICAgICAgICAgIHBlcmlvZGljV2F2ZVNpemUgPSBwYXJ0aWFsQ291bnQ7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgdmFyIHBhcnRpYWwgPSAvXihzaW5lfHRyaWFuZ2xlfHNxdWFyZXxzYXd0b290aCkoXFxkKykkLy5leGVjKHR5cGUpO1xuXHQgICAgICAgICAgICBpZiAocGFydGlhbCkge1xuXHQgICAgICAgICAgICAgICAgcGFydGlhbENvdW50ID0gcGFyc2VJbnQocGFydGlhbFsyXSkgKyAxO1xuXHQgICAgICAgICAgICAgICAgdHlwZSA9IHBhcnRpYWxbMV07XG5cdCAgICAgICAgICAgICAgICBwYXJ0aWFsQ291bnQgPSBNYXRoLm1heChwYXJ0aWFsQ291bnQsIDIpO1xuXHQgICAgICAgICAgICAgICAgcGVyaW9kaWNXYXZlU2l6ZSA9IHBhcnRpYWxDb3VudDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICBmb3IgKHZhciBuID0gMTsgbiA8IHBlcmlvZGljV2F2ZVNpemU7ICsrbikge1xuXHQgICAgICAgICAgICB2YXIgcGlGYWN0b3IgPSAyIC8gKG4gKiBNYXRoLlBJKTtcblx0ICAgICAgICAgICAgdmFyIGI7XG5cdCAgICAgICAgICAgIHN3aXRjaCAodHlwZSkge1xuXHQgICAgICAgICAgICBjYXNlIFRvbmUuT3NjaWxsYXRvci5UeXBlLlNpbmU6XG5cdCAgICAgICAgICAgICAgICBiID0gbiA8PSBwYXJ0aWFsQ291bnQgPyAxIDogMDtcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICBjYXNlIFRvbmUuT3NjaWxsYXRvci5UeXBlLlNxdWFyZTpcblx0ICAgICAgICAgICAgICAgIGIgPSBuICYgMSA/IDIgKiBwaUZhY3RvciA6IDA7XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgY2FzZSBUb25lLk9zY2lsbGF0b3IuVHlwZS5TYXd0b290aDpcblx0ICAgICAgICAgICAgICAgIGIgPSBwaUZhY3RvciAqIChuICYgMSA/IDEgOiAtMSk7XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgY2FzZSBUb25lLk9zY2lsbGF0b3IuVHlwZS5UcmlhbmdsZTpcblx0ICAgICAgICAgICAgICAgIGlmIChuICYgMSkge1xuXHQgICAgICAgICAgICAgICAgICAgIGIgPSAyICogKHBpRmFjdG9yICogcGlGYWN0b3IpICogKG4gLSAxID4+IDEgJiAxID8gLTEgOiAxKTtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgYiA9IDA7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgY2FzZSBUb25lLk9zY2lsbGF0b3IuVHlwZS5DdXN0b206XG5cdCAgICAgICAgICAgICAgICBiID0gdGhpcy5fcGFydGlhbHNbbiAtIDFdO1xuXHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgIGRlZmF1bHQ6XG5cdCAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUb25lLk9zY2lsbGF0b3I6IGludmFsaWQgdHlwZTogJyArIHR5cGUpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGlmIChiICE9PSAwKSB7XG5cdCAgICAgICAgICAgICAgICByZWFsW25dID0gLWIgKiBNYXRoLnNpbihwaGFzZSAqIG4pO1xuXHQgICAgICAgICAgICAgICAgaW1hZ1tuXSA9IGIgKiBNYXRoLmNvcyhwaGFzZSAqIG4pO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgcmVhbFtuXSA9IDA7XG5cdCAgICAgICAgICAgICAgICBpbWFnW25dID0gMDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gW1xuXHQgICAgICAgICAgICByZWFsLFxuXHQgICAgICAgICAgICBpbWFnXG5cdCAgICAgICAgXTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgQ29tcHV0ZSB0aGUgaW52ZXJzZSBGRlQgZm9yIGEgZ2l2ZW4gcGhhc2UuXHRcblx0XHQgKiAgQHBhcmFtICB7RmxvYXQzMkFycmF5fSAgcmVhbFxuXHRcdCAqICBAcGFyYW0gIHtGbG9hdDMyQXJyYXl9ICBpbWFnIFxuXHRcdCAqICBAcGFyYW0gIHtOb3JtYWxSYW5nZX0gIHBoYXNlIFxuXHRcdCAqICBAcmV0dXJuICB7QXVkaW9SYW5nZX1cblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuT3NjaWxsYXRvci5wcm90b3R5cGUuX2ludmVyc2VGRlQgPSBmdW5jdGlvbiAocmVhbCwgaW1hZywgcGhhc2UpIHtcblx0ICAgICAgICB2YXIgc3VtID0gMDtcblx0ICAgICAgICB2YXIgbGVuID0gcmVhbC5sZW5ndGg7XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuXHQgICAgICAgICAgICBzdW0gKz0gcmVhbFtpXSAqIE1hdGguY29zKGkgKiBwaGFzZSkgKyBpbWFnW2ldICogTWF0aC5zaW4oaSAqIHBoYXNlKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHN1bTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgUmV0dXJucyB0aGUgaW5pdGlhbCB2YWx1ZSBvZiB0aGUgb3NjaWxsYXRvci5cblx0XHQgKiAgQHJldHVybiAge0F1ZGlvUmFuZ2V9XG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLk9zY2lsbGF0b3IucHJvdG90eXBlLl9nZXRJbml0aWFsVmFsdWUgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIGNvZWZzID0gdGhpcy5fZ2V0UmVhbEltYWdpbmFyeSh0aGlzLl90eXBlLCAwKTtcblx0ICAgICAgICB2YXIgcmVhbCA9IGNvZWZzWzBdO1xuXHQgICAgICAgIHZhciBpbWFnID0gY29lZnNbMV07XG5cdCAgICAgICAgdmFyIG1heFZhbHVlID0gMDtcblx0ICAgICAgICB2YXIgdHdvUGkgPSBNYXRoLlBJICogMjtcblx0ICAgICAgICAvL2NoZWNrIGZvciBwZWFrcyBpbiA4IHBsYWNlc1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgODsgaSsrKSB7XG5cdCAgICAgICAgICAgIG1heFZhbHVlID0gTWF0aC5tYXgodGhpcy5faW52ZXJzZUZGVChyZWFsLCBpbWFnLCBpIC8gOCAqIHR3b1BpKSwgbWF4VmFsdWUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gLXRoaXMuX2ludmVyc2VGRlQocmVhbCwgaW1hZywgdGhpcy5fcGhhc2UpIC8gbWF4VmFsdWU7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogVGhlIHBhcnRpYWxzIG9mIHRoZSB3YXZlZm9ybS4gQSBwYXJ0aWFsIHJlcHJlc2VudHMgXG5cdFx0ICogdGhlIGFtcGxpdHVkZSBhdCBhIGhhcm1vbmljLiBUaGUgZmlyc3QgaGFybW9uaWMgaXMgdGhlIFxuXHRcdCAqIGZ1bmRhbWVudGFsIGZyZXF1ZW5jeSwgdGhlIHNlY29uZCBpcyB0aGUgb2N0YXZlIGFuZCBzbyBvblxuXHRcdCAqIGZvbGxvd2luZyB0aGUgaGFybW9uaWMgc2VyaWVzLiBcblx0XHQgKiBTZXR0aW5nIHRoaXMgdmFsdWUgd2lsbCBhdXRvbWF0aWNhbGx5IHNldCB0aGUgdHlwZSB0byBcImN1c3RvbVwiLiBcblx0XHQgKiBUaGUgdmFsdWUgaXMgYW4gZW1wdHkgYXJyYXkgd2hlbiB0aGUgdHlwZSBpcyBub3QgXCJjdXN0b21cIi4gXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuT3NjaWxsYXRvciNcblx0XHQgKiBAdHlwZSB7QXJyYXl9XG5cdFx0ICogQG5hbWUgcGFydGlhbHNcblx0XHQgKiBAZXhhbXBsZVxuXHRcdCAqIG9zYy5wYXJ0aWFscyA9IFsxLCAwLjIsIDAuMDFdO1xuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuT3NjaWxsYXRvci5wcm90b3R5cGUsICdwYXJ0aWFscycsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgaWYgKHRoaXMuX3R5cGUgIT09IFRvbmUuT3NjaWxsYXRvci5UeXBlLkN1c3RvbSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BhcnRpYWxzO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChwYXJ0aWFscykge1xuXHQgICAgICAgICAgICB0aGlzLl9wYXJ0aWFscyA9IHBhcnRpYWxzO1xuXHQgICAgICAgICAgICB0aGlzLnR5cGUgPSBUb25lLk9zY2lsbGF0b3IuVHlwZS5DdXN0b207XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiBUaGUgcGhhc2Ugb2YgdGhlIG9zY2lsbGF0b3IgaW4gZGVncmVlcy4gXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuT3NjaWxsYXRvciNcblx0XHQgKiBAdHlwZSB7RGVncmVlc31cblx0XHQgKiBAbmFtZSBwaGFzZVxuXHRcdCAqIEBleGFtcGxlXG5cdFx0ICogb3NjLnBoYXNlID0gMTgwOyAvL2ZsaXBzIHRoZSBwaGFzZSBvZiB0aGUgb3NjaWxsYXRvclxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuT3NjaWxsYXRvci5wcm90b3R5cGUsICdwaGFzZScsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BoYXNlICogKDE4MCAvIE1hdGguUEkpO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAocGhhc2UpIHtcblx0ICAgICAgICAgICAgdGhpcy5fcGhhc2UgPSBwaGFzZSAqIE1hdGguUEkgLyAxODA7XG5cdCAgICAgICAgICAgIC8vcmVzZXQgdGhlIHR5cGVcblx0ICAgICAgICAgICAgdGhpcy50eXBlID0gdGhpcy5fdHlwZTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBEaXNwb3NlIGFuZCBkaXNjb25uZWN0LlxuXHRcdCAqICBAcmV0dXJuIHtUb25lLk9zY2lsbGF0b3J9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuT3NjaWxsYXRvci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLlNvdXJjZS5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIGlmICh0aGlzLl9vc2NpbGxhdG9yICE9PSBudWxsKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX29zY2lsbGF0b3IuZGlzY29ubmVjdCgpO1xuXHQgICAgICAgICAgICB0aGlzLl9vc2NpbGxhdG9yID0gbnVsbDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdGhpcy5fd2F2ZSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fd3JpdGFibGUoW1xuXHQgICAgICAgICAgICAnZnJlcXVlbmN5Jyxcblx0ICAgICAgICAgICAgJ2RldHVuZSdcblx0ICAgICAgICBdKTtcblx0ICAgICAgICB0aGlzLmZyZXF1ZW5jeS5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5mcmVxdWVuY3kgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuZGV0dW5lLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLmRldHVuZSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fcGFydGlhbHMgPSBudWxsO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLk9zY2lsbGF0b3I7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgVG9uZS5aZXJvIG91dHB1dHMgMCdzIGF0IGF1ZGlvLXJhdGUuIFRoZSByZWFzb24gdGhpcyBoYXMgdG8gYmVcblx0XHQgKiAgICAgICAgIGl0J3Mgb3duIGNsYXNzIGlzIHRoYXQgbWFueSBicm93c2VycyBvcHRpbWl6ZSBvdXQgVG9uZS5TaWduYWxcblx0XHQgKiAgICAgICAgIHdpdGggYSB2YWx1ZSBvZiAwIGFuZCB3aWxsIG5vdCBwcm9jZXNzIG5vZGVzIGZ1cnRoZXIgZG93biB0aGUgZ3JhcGguXG5cdFx0ICogIEBleHRlbmRzIHtUb25lLlNpZ25hbEJhc2V9XG5cdFx0ICovXG5cdCAgICBUb25lLlplcm8gPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5TaWduYWxCYXNlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGdhaW4gbm9kZVxuXHRcdFx0ICogIEB0eXBlICB7VG9uZS5HYWlufVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9nYWluID0gdGhpcy5pbnB1dCA9IHRoaXMub3V0cHV0ID0gbmV3IFRvbmUuR2FpbigpO1xuXHQgICAgICAgIHRoaXMuY29udGV4dC5nZXRDb25zdGFudCgwKS5jb25uZWN0KHRoaXMuX2dhaW4pO1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuWmVybywgVG9uZS5TaWduYWxCYXNlKTtcblx0ICAgIC8qKlxuXHRcdCAqICBjbGVhbiB1cFxuXHRcdCAqICBAcmV0dXJuICB7VG9uZS5aZXJvfSAgdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5aZXJvLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuU2lnbmFsQmFzZS5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuX2dhaW4uZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX2dhaW4gPSBudWxsO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLlplcm87XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyAgTEZPIHN0YW5kcyBmb3IgbG93IGZyZXF1ZW5jeSBvc2NpbGxhdG9yLiBUb25lLkxGTyBwcm9kdWNlcyBhbiBvdXRwdXQgc2lnbmFsXG5cdFx0ICogICAgICAgICAgd2hpY2ggY2FuIGJlIGF0dGFjaGVkIHRvIGFuIEF1ZGlvUGFyYW0gb3IgVG9uZS5TaWduYWxcblx0XHQgKiAgICAgICAgICBpbiBvcmRlciB0byBtb2R1bGF0ZSB0aGF0IHBhcmFtZXRlciB3aXRoIGFuIG9zY2lsbGF0b3IuIFRoZSBMRk8gY2FuXG5cdFx0ICogICAgICAgICAgYWxzbyBiZSBzeW5jZWQgdG8gdGhlIHRyYW5zcG9ydCB0byBzdGFydC9zdG9wIGFuZCBjaGFuZ2Ugd2hlbiB0aGUgdGVtcG8gY2hhbmdlcy5cblx0XHQgKlxuXHRcdCAqICBAY29uc3RydWN0b3Jcblx0XHQgKiAgQGV4dGVuZHMge1RvbmUuQXVkaW9Ob2RlfVxuXHRcdCAqICBAcGFyYW0ge0ZyZXF1ZW5jeXxPYmplY3R9IFtmcmVxdWVuY3ldIFRoZSBmcmVxdWVuY3kgb2YgdGhlIG9zY2lsbGF0aW9uLiBUeXBpY2FsbHksIExGT3Mgd2lsbCBiZVxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluIHRoZSBmcmVxdWVuY3kgcmFuZ2Ugb2YgMC4xIHRvIDEwIGhlcnR6LlxuXHRcdCAqICBAcGFyYW0ge251bWJlcj19IG1pbiBUaGUgbWluaW11bSBvdXRwdXQgdmFsdWUgb2YgdGhlIExGTy5cblx0XHQgKiAgQHBhcmFtIHtudW1iZXI9fSBtYXggVGhlIG1heGltdW0gdmFsdWUgb2YgdGhlIExGTy5cblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiB2YXIgbGZvID0gbmV3IFRvbmUuTEZPKFwiNG5cIiwgNDAwLCA0MDAwKTtcblx0XHQgKiBsZm8uY29ubmVjdChmaWx0ZXIuZnJlcXVlbmN5KTtcblx0XHQgKi9cblx0ICAgIFRvbmUuTEZPID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBvcHRpb25zID0gVG9uZS5kZWZhdWx0cyhhcmd1bWVudHMsIFtcblx0ICAgICAgICAgICAgJ2ZyZXF1ZW5jeScsXG5cdCAgICAgICAgICAgICdtaW4nLFxuXHQgICAgICAgICAgICAnbWF4J1xuXHQgICAgICAgIF0sIFRvbmUuTEZPKTtcblx0ICAgICAgICBUb25lLkF1ZGlvTm9kZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBvc2NpbGxhdG9yLlxuXHRcdFx0ICogIEB0eXBlIHtUb25lLk9zY2lsbGF0b3J9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX29zY2lsbGF0b3IgPSBuZXcgVG9uZS5Pc2NpbGxhdG9yKHtcblx0ICAgICAgICAgICAgJ2ZyZXF1ZW5jeSc6IG9wdGlvbnMuZnJlcXVlbmN5LFxuXHQgICAgICAgICAgICAndHlwZSc6IG9wdGlvbnMudHlwZVxuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHRoZSBsZm8ncyBmcmVxdWVuY3lcblx0XHRcdCAqICBAdHlwZSB7RnJlcXVlbmN5fVxuXHRcdFx0ICogIEBzaWduYWxcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuZnJlcXVlbmN5ID0gdGhpcy5fb3NjaWxsYXRvci5mcmVxdWVuY3k7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiBUaGUgYW1wbGl0dWRlIG9mIHRoZSBMRk8sIHdoaWNoIGNvbnRyb2xzIHRoZSBvdXRwdXQgcmFuZ2UgYmV0d2VlblxuXHRcdFx0ICogdGhlIG1pbiBhbmQgbWF4IG91dHB1dC4gRm9yIGV4YW1wbGUgaWYgdGhlIG1pbiBpcyAtMTAgYW5kIHRoZSBtYXhcblx0XHRcdCAqIGlzIDEwLCBzZXR0aW5nIHRoZSBhbXBsaXR1ZGUgdG8gMC41IHdvdWxkIG1ha2UgdGhlIExGTyBtb2R1bGF0ZVxuXHRcdFx0ICogYmV0d2VlbiAtNSBhbmQgNS5cblx0XHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0XHQgKiBAc2lnbmFsXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmFtcGxpdHVkZSA9IHRoaXMuX29zY2lsbGF0b3Iudm9sdW1lO1xuXHQgICAgICAgIHRoaXMuYW1wbGl0dWRlLnVuaXRzID0gVG9uZS5UeXBlLk5vcm1hbFJhbmdlO1xuXHQgICAgICAgIHRoaXMuYW1wbGl0dWRlLnZhbHVlID0gb3B0aW9ucy5hbXBsaXR1ZGU7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIHNpZ25hbCB3aGljaCBpcyBvdXRwdXQgd2hlbiB0aGUgTEZPIGlzIHN0b3BwZWRcblx0XHRcdCAqICBAdHlwZSAge1RvbmUuU2lnbmFsfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9zdG9wcGVkU2lnbmFsID0gbmV3IFRvbmUuU2lnbmFsKDAsIFRvbmUuVHlwZS5BdWRpb1JhbmdlKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBKdXN0IG91dHB1dHMgemVyb3MuXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuWmVyb31cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5femVyb3MgPSBuZXcgVG9uZS5aZXJvKCk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIHZhbHVlIHRoYXQgdGhlIExGTyBvdXRwdXRzIHdoZW4gaXQncyBzdG9wcGVkXG5cdFx0XHQgKiAgQHR5cGUge0F1ZGlvUmFuZ2V9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX3N0b3BwZWRWYWx1ZSA9IDA7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuQXVkaW9Ub0dhaW59XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2EyZyA9IG5ldyBUb25lLkF1ZGlvVG9HYWluKCk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuU2NhbGV9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX3NjYWxlciA9IHRoaXMub3V0cHV0ID0gbmV3IFRvbmUuU2NhbGUob3B0aW9ucy5taW4sIG9wdGlvbnMubWF4KTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICB0aGUgdW5pdHMgb2YgdGhlIExGTyAodXNlZCBmb3IgY29udmVydGluZylcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5UeXBlfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl91bml0cyA9IFRvbmUuVHlwZS5EZWZhdWx0O1xuXHQgICAgICAgIHRoaXMudW5pdHMgPSBvcHRpb25zLnVuaXRzO1xuXHQgICAgICAgIC8vY29ubmVjdCBpdCB1cFxuXHQgICAgICAgIHRoaXMuX29zY2lsbGF0b3IuY2hhaW4odGhpcy5fYTJnLCB0aGlzLl9zY2FsZXIpO1xuXHQgICAgICAgIHRoaXMuX3plcm9zLmNvbm5lY3QodGhpcy5fYTJnKTtcblx0ICAgICAgICB0aGlzLl9zdG9wcGVkU2lnbmFsLmNvbm5lY3QodGhpcy5fYTJnKTtcblx0ICAgICAgICB0aGlzLl9yZWFkT25seShbXG5cdCAgICAgICAgICAgICdhbXBsaXR1ZGUnLFxuXHQgICAgICAgICAgICAnZnJlcXVlbmN5J1xuXHQgICAgICAgIF0pO1xuXHQgICAgICAgIHRoaXMucGhhc2UgPSBvcHRpb25zLnBoYXNlO1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuTEZPLCBUb25lLkF1ZGlvTm9kZSk7XG5cdCAgICAvKipcblx0XHQgKiAgdGhlIGRlZmF1bHQgcGFyYW1ldGVyc1xuXHRcdCAqXG5cdFx0ICogIEBzdGF0aWNcblx0XHQgKiAgQGNvbnN0XG5cdFx0ICogIEB0eXBlIHtPYmplY3R9XG5cdFx0ICovXG5cdCAgICBUb25lLkxGTy5kZWZhdWx0cyA9IHtcblx0ICAgICAgICAndHlwZSc6ICdzaW5lJyxcblx0ICAgICAgICAnbWluJzogMCxcblx0ICAgICAgICAnbWF4JzogMSxcblx0ICAgICAgICAncGhhc2UnOiAwLFxuXHQgICAgICAgICdmcmVxdWVuY3knOiAnNG4nLFxuXHQgICAgICAgICdhbXBsaXR1ZGUnOiAxLFxuXHQgICAgICAgICd1bml0cyc6IFRvbmUuVHlwZS5EZWZhdWx0XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFN0YXJ0IHRoZSBMRk8uXG5cdFx0ICogIEBwYXJhbSAge1RpbWV9IFt0aW1lPW5vd10gdGhlIHRpbWUgdGhlIExGTyB3aWxsIHN0YXJ0XG5cdFx0ICogIEByZXR1cm5zIHtUb25lLkxGT30gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5MRk8ucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24gKHRpbWUpIHtcblx0ICAgICAgICB0aW1lID0gdGhpcy50b1NlY29uZHModGltZSk7XG5cdCAgICAgICAgdGhpcy5fc3RvcHBlZFNpZ25hbC5zZXRWYWx1ZUF0VGltZSgwLCB0aW1lKTtcblx0ICAgICAgICB0aGlzLl9vc2NpbGxhdG9yLnN0YXJ0KHRpbWUpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBTdG9wIHRoZSBMRk8uXG5cdFx0ICogIEBwYXJhbSAge1RpbWV9IFt0aW1lPW5vd10gdGhlIHRpbWUgdGhlIExGTyB3aWxsIHN0b3Bcblx0XHQgKiAgQHJldHVybnMge1RvbmUuTEZPfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkxGTy5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICh0aW1lKSB7XG5cdCAgICAgICAgdGltZSA9IHRoaXMudG9TZWNvbmRzKHRpbWUpO1xuXHQgICAgICAgIHRoaXMuX3N0b3BwZWRTaWduYWwuc2V0VmFsdWVBdFRpbWUodGhpcy5fc3RvcHBlZFZhbHVlLCB0aW1lKTtcblx0ICAgICAgICB0aGlzLl9vc2NpbGxhdG9yLnN0b3AodGltZSk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFN5bmMgdGhlIHN0YXJ0L3N0b3AvcGF1c2UgdG8gdGhlIHRyYW5zcG9ydFxuXHRcdCAqICBhbmQgdGhlIGZyZXF1ZW5jeSB0byB0aGUgYnBtIG9mIHRoZSB0cmFuc3BvcnRcblx0XHQgKiAgQHJldHVybnMge1RvbmUuTEZPfSB0aGlzXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogIGxmby5mcmVxdWVuY3kudmFsdWUgPSBcIjhuXCI7XG5cdFx0ICogIGxmby5zeW5jKCkuc3RhcnQoMClcblx0XHQgKiAgLy90aGUgcmF0ZSBvZiB0aGUgTEZPIHdpbGwgYWx3YXlzIGJlIGFuIGVpZ2h0aCBub3RlLFxuXHRcdCAqICAvL2V2ZW4gYXMgdGhlIHRlbXBvIGNoYW5nZXNcblx0XHQgKi9cblx0ICAgIFRvbmUuTEZPLnByb3RvdHlwZS5zeW5jID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHRoaXMuX29zY2lsbGF0b3Iuc3luYygpO1xuXHQgICAgICAgIHRoaXMuX29zY2lsbGF0b3Iuc3luY0ZyZXF1ZW5jeSgpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICB1bnN5bmMgdGhlIExGTyBmcm9tIHRyYW5zcG9ydCBjb250cm9sXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLkxGT30gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5MRk8ucHJvdG90eXBlLnVuc3luYyA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB0aGlzLl9vc2NpbGxhdG9yLnVuc3luYygpO1xuXHQgICAgICAgIHRoaXMuX29zY2lsbGF0b3IudW5zeW5jRnJlcXVlbmN5KCk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogVGhlIG1pbml1bXVtIG91dHB1dCBvZiB0aGUgTEZPLlxuXHRcdCAqIEBtZW1iZXJPZiBUb25lLkxGTyNcblx0XHQgKiBAdHlwZSB7bnVtYmVyfVxuXHRcdCAqIEBuYW1lIG1pblxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuTEZPLnByb3RvdHlwZSwgJ21pbicsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RvVW5pdHModGhpcy5fc2NhbGVyLm1pbik7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChtaW4pIHtcblx0ICAgICAgICAgICAgbWluID0gdGhpcy5fZnJvbVVuaXRzKG1pbik7XG5cdCAgICAgICAgICAgIHRoaXMuX3NjYWxlci5taW4gPSBtaW47XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiBUaGUgbWF4aW11bSBvdXRwdXQgb2YgdGhlIExGTy5cblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5MRk8jXG5cdFx0ICogQHR5cGUge251bWJlcn1cblx0XHQgKiBAbmFtZSBtYXhcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkxGTy5wcm90b3R5cGUsICdtYXgnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl90b1VuaXRzKHRoaXMuX3NjYWxlci5tYXgpO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAobWF4KSB7XG5cdCAgICAgICAgICAgIG1heCA9IHRoaXMuX2Zyb21Vbml0cyhtYXgpO1xuXHQgICAgICAgICAgICB0aGlzLl9zY2FsZXIubWF4ID0gbWF4O1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogVGhlIHR5cGUgb2YgdGhlIG9zY2lsbGF0b3I6IHNpbmUsIHNxdWFyZSwgc2F3dG9vdGgsIHRyaWFuZ2xlLlxuXHRcdCAqIEBtZW1iZXJPZiBUb25lLkxGTyNcblx0XHQgKiBAdHlwZSB7c3RyaW5nfVxuXHRcdCAqIEBuYW1lIHR5cGVcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkxGTy5wcm90b3R5cGUsICd0eXBlJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fb3NjaWxsYXRvci50eXBlO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAodHlwZSkge1xuXHQgICAgICAgICAgICB0aGlzLl9vc2NpbGxhdG9yLnR5cGUgPSB0eXBlO1xuXHQgICAgICAgICAgICB0aGlzLl9zdG9wcGVkVmFsdWUgPSB0aGlzLl9vc2NpbGxhdG9yLl9nZXRJbml0aWFsVmFsdWUoKTtcblx0ICAgICAgICAgICAgdGhpcy5fc3RvcHBlZFNpZ25hbC52YWx1ZSA9IHRoaXMuX3N0b3BwZWRWYWx1ZTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqIFRoZSBwaGFzZSBvZiB0aGUgTEZPLlxuXHRcdCAqIEBtZW1iZXJPZiBUb25lLkxGTyNcblx0XHQgKiBAdHlwZSB7bnVtYmVyfVxuXHRcdCAqIEBuYW1lIHBoYXNlXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5MRk8ucHJvdG90eXBlLCAncGhhc2UnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9vc2NpbGxhdG9yLnBoYXNlO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAocGhhc2UpIHtcblx0ICAgICAgICAgICAgdGhpcy5fb3NjaWxsYXRvci5waGFzZSA9IHBoYXNlO1xuXHQgICAgICAgICAgICB0aGlzLl9zdG9wcGVkVmFsdWUgPSB0aGlzLl9vc2NpbGxhdG9yLl9nZXRJbml0aWFsVmFsdWUoKTtcblx0ICAgICAgICAgICAgdGhpcy5fc3RvcHBlZFNpZ25hbC52YWx1ZSA9IHRoaXMuX3N0b3BwZWRWYWx1ZTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqIFRoZSBvdXRwdXQgdW5pdHMgb2YgdGhlIExGTy5cblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5MRk8jXG5cdFx0ICogQHR5cGUge1RvbmUuVHlwZX1cblx0XHQgKiBAbmFtZSB1bml0c1xuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuTEZPLnByb3RvdHlwZSwgJ3VuaXRzJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fdW5pdHM7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcblx0ICAgICAgICAgICAgdmFyIGN1cnJlbnRNaW4gPSB0aGlzLm1pbjtcblx0ICAgICAgICAgICAgdmFyIGN1cnJlbnRNYXggPSB0aGlzLm1heDtcblx0ICAgICAgICAgICAgLy9jb252ZXJ0IHRoZSBtaW4gYW5kIHRoZSBtYXhcblx0ICAgICAgICAgICAgdGhpcy5fdW5pdHMgPSB2YWw7XG5cdCAgICAgICAgICAgIHRoaXMubWluID0gY3VycmVudE1pbjtcblx0ICAgICAgICAgICAgdGhpcy5tYXggPSBjdXJyZW50TWF4O1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogTXV0ZSB0aGUgb3V0cHV0LlxuXHRcdCAqIEBtZW1iZXJPZiBUb25lLkxGTyNcblx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0XHQgKiBAbmFtZSBtdXRlXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5MRk8ucHJvdG90eXBlLCAnbXV0ZScsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX29zY2lsbGF0b3IubXV0ZTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKG11dGUpIHtcblx0ICAgICAgICAgICAgdGhpcy5fb3NjaWxsYXRvci5tdXRlID0gbXV0ZTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBSZXR1cm5zIHRoZSBwbGF5YmFjayBzdGF0ZSBvZiB0aGUgc291cmNlLCBlaXRoZXIgXCJzdGFydGVkXCIgb3IgXCJzdG9wcGVkXCIuXG5cdFx0ICogIEB0eXBlIHtUb25lLlN0YXRlfVxuXHRcdCAqICBAcmVhZE9ubHlcblx0XHQgKiAgQG1lbWJlck9mIFRvbmUuTEZPI1xuXHRcdCAqICBAbmFtZSBzdGF0ZVxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuTEZPLnByb3RvdHlwZSwgJ3N0YXRlJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fb3NjaWxsYXRvci5zdGF0ZTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBDb25uZWN0IHRoZSBvdXRwdXQgb2YgdGhlIExGTyB0byBhbiBBdWRpb1BhcmFtLCBBdWRpb05vZGUsIG9yIFRvbmUgTm9kZS5cblx0XHQgKiAgVG9uZS5MRk8gd2lsbCBhdXRvbWF0aWNhbGx5IGNvbnZlcnQgdG8gdGhlIGRlc3RpbmF0aW9uIHVuaXRzIG9mIHRoZVxuXHRcdCAqICB3aWxsIGdldCB0aGUgdW5pdHMgZnJvbSB0aGUgY29ubmVjdGVkIG5vZGUuXG5cdFx0ICogIEBwYXJhbSAge1RvbmUgfCBBdWRpb1BhcmFtIHwgQXVkaW9Ob2RlfSBub2RlXG5cdFx0ICogIEBwYXJhbSB7bnVtYmVyfSBbb3V0cHV0TnVtPTBdIG9wdGlvbmFsbHkgd2hpY2ggb3V0cHV0IHRvIGNvbm5lY3QgZnJvbVxuXHRcdCAqICBAcGFyYW0ge251bWJlcn0gW2lucHV0TnVtPTBdIG9wdGlvbmFsbHkgd2hpY2ggaW5wdXQgdG8gY29ubmVjdCB0b1xuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5MRk99IHRoaXNcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuTEZPLnByb3RvdHlwZS5jb25uZWN0ID0gZnVuY3Rpb24gKG5vZGUpIHtcblx0ICAgICAgICBpZiAobm9kZS5jb25zdHJ1Y3RvciA9PT0gVG9uZS5TaWduYWwgfHwgbm9kZS5jb25zdHJ1Y3RvciA9PT0gVG9uZS5QYXJhbSB8fCBub2RlLmNvbnN0cnVjdG9yID09PSBUb25lLlRpbWVsaW5lU2lnbmFsKSB7XG5cdCAgICAgICAgICAgIHRoaXMuY29udmVydCA9IG5vZGUuY29udmVydDtcblx0ICAgICAgICAgICAgdGhpcy51bml0cyA9IG5vZGUudW5pdHM7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIFRvbmUuU2lnbmFsLnByb3RvdHlwZS5jb25uZWN0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIHByaXZhdGUgbWV0aG9kIGJvcnJvd2VkIGZyb20gUGFyYW0gY29udmVydHNcblx0XHQgKiAgdW5pdHMgZnJvbSB0aGVpciBkZXN0aW5hdGlvbiB2YWx1ZVxuXHRcdCAqICBAZnVuY3Rpb25cblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuTEZPLnByb3RvdHlwZS5fZnJvbVVuaXRzID0gVG9uZS5QYXJhbS5wcm90b3R5cGUuX2Zyb21Vbml0cztcblx0ICAgIC8qKlxuXHRcdCAqICBwcml2YXRlIG1ldGhvZCBib3Jyb3dlZCBmcm9tIFBhcmFtIGNvbnZlcnRzXG5cdFx0ICogIHVuaXRzIHRvIHRoZWlyIGRlc3RpbmF0aW9uIHZhbHVlXG5cdFx0ICogIEBmdW5jdGlvblxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5MRk8ucHJvdG90eXBlLl90b1VuaXRzID0gVG9uZS5QYXJhbS5wcm90b3R5cGUuX3RvVW5pdHM7XG5cdCAgICAvKipcblx0XHQgKiAgZGlzY29ubmVjdCBhbmQgZGlzcG9zZVxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5MRk99IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuTEZPLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuQXVkaW9Ob2RlLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgdGhpcy5fd3JpdGFibGUoW1xuXHQgICAgICAgICAgICAnYW1wbGl0dWRlJyxcblx0ICAgICAgICAgICAgJ2ZyZXF1ZW5jeSdcblx0ICAgICAgICBdKTtcblx0ICAgICAgICB0aGlzLl9vc2NpbGxhdG9yLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9vc2NpbGxhdG9yID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9zdG9wcGVkU2lnbmFsLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9zdG9wcGVkU2lnbmFsID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl96ZXJvcy5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5femVyb3MgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX3NjYWxlci5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fc2NhbGVyID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9hMmcuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX2EyZyA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5mcmVxdWVuY3kgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuYW1wbGl0dWRlID0gbnVsbDtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVG9uZS5MRk87XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyBUb25lLkxpbWl0ZXIgd2lsbCBsaW1pdCB0aGUgbG91ZG5lc3Mgb2YgYW4gaW5jb21pbmcgc2lnbmFsLlxuXHRcdCAqICAgICAgICAgSXQgaXMgY29tcG9zZWQgb2YgYSBUb25lLkNvbXByZXNzb3Igd2l0aCBhIGZhc3QgYXR0YWNrXG5cdFx0ICogICAgICAgICBhbmQgcmVsZWFzZS4gTGltaXRlcnMgYXJlIGNvbW1vbmx5IHVzZWQgdG8gc2FmZWd1YXJkIGFnYWluc3Rcblx0XHQgKiAgICAgICAgIHNpZ25hbCBjbGlwcGluZy4gVW5saWtlIGEgY29tcHJlc3NvciwgbGltaXRlcnMgZG8gbm90IHByb3ZpZGVcblx0XHQgKiAgICAgICAgIHNtb290aCBnYWluIHJlZHVjdGlvbiBhbmQgYWxtb3N0IGNvbXBsZXRlbHkgcHJldmVudFxuXHRcdCAqICAgICAgICAgYWRkaXRpb25hbCBnYWluIGFib3ZlIHRoZSB0aHJlc2hvbGQuXG5cdFx0ICpcblx0XHQgKiAgQGV4dGVuZHMge1RvbmUuQXVkaW9Ob2RlfVxuXHRcdCAqICBAY29uc3RydWN0b3Jcblx0XHQgKiAgQHBhcmFtIHtudW1iZXJ9IHRocmVzaG9sZCBUaGUgdGhlc2hvbGQgYWJvdmUgd2hpY2ggdGhlIGxpbWl0aW5nIGlzIGFwcGxpZWQuXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogIHZhciBsaW1pdGVyID0gbmV3IFRvbmUuTGltaXRlcigtNik7XG5cdFx0ICovXG5cdCAgICBUb25lLkxpbWl0ZXIgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIG9wdGlvbnMgPSBUb25lLmRlZmF1bHRzKGFyZ3VtZW50cywgWyd0aHJlc2hvbGQnXSwgVG9uZS5MaW1pdGVyKTtcblx0ICAgICAgICBUb25lLkF1ZGlvTm9kZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHRoZSBjb21wcmVzc29yXG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5Db21wcmVzc29yfVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fY29tcHJlc3NvciA9IHRoaXMuaW5wdXQgPSB0aGlzLm91dHB1dCA9IG5ldyBUb25lLkNvbXByZXNzb3Ioe1xuXHQgICAgICAgICAgICAnYXR0YWNrJzogMC4wMDEsXG5cdCAgICAgICAgICAgICdkZWNheSc6IDAuMDAxLFxuXHQgICAgICAgICAgICAndGhyZXNob2xkJzogb3B0aW9ucy50aHJlc2hvbGRcblx0ICAgICAgICB9KTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqIFRoZSB0aHJlc2hvbGQgb2Ygb2YgdGhlIGxpbWl0ZXJcblx0XHRcdCAqIEB0eXBlIHtEZWNpYmVsfVxuXHRcdFx0ICogQHNpZ25hbFxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy50aHJlc2hvbGQgPSB0aGlzLl9jb21wcmVzc29yLnRocmVzaG9sZDtcblx0ICAgICAgICB0aGlzLl9yZWFkT25seSgndGhyZXNob2xkJyk7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5MaW1pdGVyLCBUb25lLkF1ZGlvTm9kZSk7XG5cdCAgICAvKipcblx0XHQgKiAgVGhlIGRlZmF1bHQgdmFsdWVcblx0XHQgKiAgQHR5cGUge09iamVjdH1cblx0XHQgKiAgQGNvbnN0XG5cdFx0ICogIEBzdGF0aWNcblx0XHQgKi9cblx0ICAgIFRvbmUuTGltaXRlci5kZWZhdWx0cyA9IHsgJ3RocmVzaG9sZCc6IC0xMiB9O1xuXHQgICAgLyoqXG5cdFx0ICogIENsZWFuIHVwLlxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5MaW1pdGVyfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkxpbWl0ZXIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5BdWRpb05vZGUucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLl9jb21wcmVzc29yLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9jb21wcmVzc29yID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl93cml0YWJsZSgndGhyZXNob2xkJyk7XG5cdCAgICAgICAgdGhpcy50aHJlc2hvbGQgPSBudWxsO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLkxpbWl0ZXI7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyBUb25lLkxvd3Bhc3MgaXMgYSBsb3dwYXNzIGZlZWRiYWNrIGNvbWIgZmlsdGVyLiBJdCBpcyBzaW1pbGFyIHRvXG5cdFx0ICogICAgICAgICBUb25lLkZlZWRiYWNrQ29tYkZpbHRlciwgYnV0IGluY2x1ZGVzIGEgbG93cGFzcyBmaWx0ZXIuXG5cdFx0ICpcblx0XHQgKiAgQGV4dGVuZHMge1RvbmUuQXVkaW9Ob2RlfVxuXHRcdCAqICBAY29uc3RydWN0b3Jcblx0XHQgKiAgQHBhcmFtIHtUaW1lfE9iamVjdH0gW2RlbGF5VGltZV0gVGhlIGRlbGF5IHRpbWUgb2YgdGhlIGNvbWIgZmlsdGVyXG5cdFx0ICogIEBwYXJhbSB7Tm9ybWFsUmFuZ2U9fSByZXNvbmFuY2UgVGhlIHJlc29uYW5jZSAoZmVlZGJhY2spIG9mIHRoZSBjb21iIGZpbHRlclxuXHRcdCAqICBAcGFyYW0ge0ZyZXF1ZW5jeT19IGRhbXBlbmluZyBUaGUgY3V0b2ZmIG9mIHRoZSBsb3dwYXNzIGZpbHRlciBkYW1wZW5zIHRoZVxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaWduYWwgYXMgaXQgaXMgZmVkYmFjay5cblx0XHQgKi9cblx0ICAgIFRvbmUuTG93cGFzc0NvbWJGaWx0ZXIgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIG9wdGlvbnMgPSBUb25lLmRlZmF1bHRzKGFyZ3VtZW50cywgW1xuXHQgICAgICAgICAgICAnZGVsYXlUaW1lJyxcblx0ICAgICAgICAgICAgJ3Jlc29uYW5jZScsXG5cdCAgICAgICAgICAgICdkYW1wZW5pbmcnXG5cdCAgICAgICAgXSwgVG9uZS5Mb3dwYXNzQ29tYkZpbHRlcik7XG5cdCAgICAgICAgVG9uZS5BdWRpb05vZGUuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLmNyZWF0ZUluc091dHMoMSwgMSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgdGhlIGRlbGF5IG5vZGVcblx0XHRcdCAqICBAdHlwZSB7RGVsYXlOb2RlfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9kZWxheSA9IHRoaXMuaW5wdXQgPSBuZXcgVG9uZS5EZWxheShvcHRpb25zLmRlbGF5VGltZSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGRlbGF5VGltZSBvZiB0aGUgY29tYiBmaWx0ZXIuXG5cdFx0XHQgKiAgQHR5cGUge1RpbWV9XG5cdFx0XHQgKiAgQHNpZ25hbFxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5kZWxheVRpbWUgPSB0aGlzLl9kZWxheS5kZWxheVRpbWU7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgdGhlIGxvd3Bhc3MgZmlsdGVyXG5cdFx0XHQgKiAgQHR5cGUgIHtCaXF1YWRGaWx0ZXJOb2RlfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9sb3dwYXNzID0gdGhpcy5vdXRwdXQgPSB0aGlzLmNvbnRleHQuY3JlYXRlQmlxdWFkRmlsdGVyKCk7XG5cdCAgICAgICAgdGhpcy5fbG93cGFzcy5RLnZhbHVlID0gLTMuMDEwMjk5OTU2NjM5ODEyNTtcblx0ICAgICAgICB0aGlzLl9sb3dwYXNzLnR5cGUgPSAnbG93cGFzcyc7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGRhbXBlbmluZyBjb250cm9sIG9mIHRoZSBmZWVkYmFja1xuXHRcdFx0ICogIEB0eXBlIHtGcmVxdWVuY3l9XG5cdFx0XHQgKiAgQHNpZ25hbFxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5kYW1wZW5pbmcgPSBuZXcgVG9uZS5QYXJhbSh7XG5cdCAgICAgICAgICAgICdwYXJhbSc6IHRoaXMuX2xvd3Bhc3MuZnJlcXVlbmN5LFxuXHQgICAgICAgICAgICAndW5pdHMnOiBUb25lLlR5cGUuRnJlcXVlbmN5LFxuXHQgICAgICAgICAgICAndmFsdWUnOiBvcHRpb25zLmRhbXBlbmluZ1xuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHRoZSBmZWVkYmFjayBnYWluXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuR2Fpbn1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fZmVlZGJhY2sgPSBuZXcgVG9uZS5HYWluKG9wdGlvbnMucmVzb25hbmNlLCBUb25lLlR5cGUuTm9ybWFsUmFuZ2UpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBhbW91bnQgb2YgZmVlZGJhY2sgb2YgdGhlIGRlbGF5ZWQgc2lnbmFsLlxuXHRcdFx0ICogIEB0eXBlIHtOb3JtYWxSYW5nZX1cblx0XHRcdCAqICBAc2lnbmFsXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLnJlc29uYW5jZSA9IHRoaXMuX2ZlZWRiYWNrLmdhaW47XG5cdCAgICAgICAgLy9jb25uZWN0aW9uc1xuXHQgICAgICAgIHRoaXMuX2RlbGF5LmNoYWluKHRoaXMuX2xvd3Bhc3MsIHRoaXMuX2ZlZWRiYWNrLCB0aGlzLl9kZWxheSk7XG5cdCAgICAgICAgdGhpcy5fcmVhZE9ubHkoW1xuXHQgICAgICAgICAgICAnZGFtcGVuaW5nJyxcblx0ICAgICAgICAgICAgJ3Jlc29uYW5jZScsXG5cdCAgICAgICAgICAgICdkZWxheVRpbWUnXG5cdCAgICAgICAgXSk7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5Mb3dwYXNzQ29tYkZpbHRlciwgVG9uZS5BdWRpb05vZGUpO1xuXHQgICAgLyoqXG5cdFx0ICogIHRoZSBkZWZhdWx0IHBhcmFtZXRlcnNcblx0XHQgKiAgQHN0YXRpY1xuXHRcdCAqICBAY29uc3Rcblx0XHQgKiAgQHR5cGUge09iamVjdH1cblx0XHQgKi9cblx0ICAgIFRvbmUuTG93cGFzc0NvbWJGaWx0ZXIuZGVmYXVsdHMgPSB7XG5cdCAgICAgICAgJ2RlbGF5VGltZSc6IDAuMSxcblx0ICAgICAgICAncmVzb25hbmNlJzogMC41LFxuXHQgICAgICAgICdkYW1wZW5pbmcnOiAzMDAwXG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIENsZWFuIHVwLlxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5Mb3dwYXNzQ29tYkZpbHRlcn0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5Mb3dwYXNzQ29tYkZpbHRlci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLkF1ZGlvTm9kZS5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuX3dyaXRhYmxlKFtcblx0ICAgICAgICAgICAgJ2RhbXBlbmluZycsXG5cdCAgICAgICAgICAgICdyZXNvbmFuY2UnLFxuXHQgICAgICAgICAgICAnZGVsYXlUaW1lJ1xuXHQgICAgICAgIF0pO1xuXHQgICAgICAgIHRoaXMuZGFtcGVuaW5nLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLmRhbXBlbmluZyA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5yZXNvbmFuY2UuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMucmVzb25hbmNlID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9kZWxheS5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fZGVsYXkgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuZGVsYXlUaW1lID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9sb3dwYXNzLmRpc2Nvbm5lY3QoKTtcblx0ICAgICAgICB0aGlzLl9sb3dwYXNzID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9mZWVkYmFjay5kaXNjb25uZWN0KCk7XG5cdCAgICAgICAgdGhpcy5fZmVlZGJhY2sgPSBudWxsO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLkxvd3Bhc3NDb21iRmlsdGVyO1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgIFRvbmUuTWVyZ2UgYnJpbmdzIHR3byBzaWduYWxzIGludG8gdGhlIGxlZnQgYW5kIHJpZ2h0XG5cdFx0ICogICAgICAgICAgY2hhbm5lbHMgb2YgYSBzaW5nbGUgc3RlcmVvIGNoYW5uZWwuXG5cdFx0ICpcblx0XHQgKiAgQGNvbnN0cnVjdG9yXG5cdFx0ICogIEBleHRlbmRzIHtUb25lLkF1ZGlvTm9kZX1cblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiB2YXIgbWVyZ2UgPSBuZXcgVG9uZS5NZXJnZSgpLnRvTWFzdGVyKCk7XG5cdFx0ICogLy9yb3V0aW5nIGEgc2luZSB0b25lIGluIHRoZSBsZWZ0IGNoYW5uZWxcblx0XHQgKiAvL2FuZCBub2lzZSBpbiB0aGUgcmlnaHQgY2hhbm5lbFxuXHRcdCAqIHZhciBvc2MgPSBuZXcgVG9uZS5Pc2NpbGxhdG9yKCkuY29ubmVjdChtZXJnZS5sZWZ0KTtcblx0XHQgKiB2YXIgbm9pc2UgPSBuZXcgVG9uZS5Ob2lzZSgpLmNvbm5lY3QobWVyZ2UucmlnaHQpO1xuXHRcdCAqIC8vc3RhcnRpbmcgb3VyIG9zY2lsbGF0b3JzXG5cdFx0ICogbm9pc2Uuc3RhcnQoKTtcblx0XHQgKiBvc2Muc3RhcnQoKTtcblx0XHQgKi9cblx0ICAgIFRvbmUuTWVyZ2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5BdWRpb05vZGUuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLmNyZWF0ZUluc091dHMoMiwgMCk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGxlZnQgaW5wdXQgY2hhbm5lbC5cblx0XHRcdCAqICBBbGlhcyBmb3IgPGNvZGU+aW5wdXRbMF08L2NvZGU+XG5cdFx0XHQgKiAgQHR5cGUge0dhaW5Ob2RlfVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5sZWZ0ID0gdGhpcy5pbnB1dFswXSA9IG5ldyBUb25lLkdhaW4oKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgcmlnaHQgaW5wdXQgY2hhbm5lbC5cblx0XHRcdCAqICBBbGlhcyBmb3IgPGNvZGU+aW5wdXRbMV08L2NvZGU+LlxuXHRcdFx0ICogIEB0eXBlIHtHYWluTm9kZX1cblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMucmlnaHQgPSB0aGlzLmlucHV0WzFdID0gbmV3IFRvbmUuR2FpbigpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHRoZSBtZXJnZXIgbm9kZSBmb3IgdGhlIHR3byBjaGFubmVsc1xuXHRcdFx0ICogIEB0eXBlIHtDaGFubmVsTWVyZ2VyTm9kZX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fbWVyZ2VyID0gdGhpcy5vdXRwdXQgPSB0aGlzLmNvbnRleHQuY3JlYXRlQ2hhbm5lbE1lcmdlcigyKTtcblx0ICAgICAgICAvL2Nvbm5lY3Rpb25zXG5cdCAgICAgICAgdGhpcy5sZWZ0LmNvbm5lY3QodGhpcy5fbWVyZ2VyLCAwLCAwKTtcblx0ICAgICAgICB0aGlzLnJpZ2h0LmNvbm5lY3QodGhpcy5fbWVyZ2VyLCAwLCAxKTtcblx0ICAgICAgICB0aGlzLmxlZnQuY2hhbm5lbENvdW50ID0gMTtcblx0ICAgICAgICB0aGlzLnJpZ2h0LmNoYW5uZWxDb3VudCA9IDE7XG5cdCAgICAgICAgdGhpcy5sZWZ0LmNoYW5uZWxDb3VudE1vZGUgPSAnZXhwbGljaXQnO1xuXHQgICAgICAgIHRoaXMucmlnaHQuY2hhbm5lbENvdW50TW9kZSA9ICdleHBsaWNpdCc7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5NZXJnZSwgVG9uZS5BdWRpb05vZGUpO1xuXHQgICAgLyoqXG5cdFx0ICogIENsZWFuIHVwLlxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5NZXJnZX0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5NZXJnZS5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLkF1ZGlvTm9kZS5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMubGVmdC5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5sZWZ0ID0gbnVsbDtcblx0ICAgICAgICB0aGlzLnJpZ2h0LmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLnJpZ2h0ID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9tZXJnZXIuZGlzY29ubmVjdCgpO1xuXHQgICAgICAgIHRoaXMuX21lcmdlciA9IG51bGw7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuTWVyZ2U7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyAgVG9uZS5NZXRlciBnZXRzIHRoZSBbUk1TXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Sb290X21lYW5fc3F1YXJlKVxuXHRcdCAqICAgICAgICAgIG9mIGFuIGlucHV0IHNpZ25hbCB3aXRoIHNvbWUgYXZlcmFnaW5nIGFwcGxpZWQuIEl0IGNhbiBhbHNvIGdldCB0aGUgcmF3XG5cdFx0ICogICAgICAgICAgdmFsdWUgb2YgdGhlIGlucHV0IHNpZ25hbC5cblx0XHQgKlxuXHRcdCAqICBAY29uc3RydWN0b3Jcblx0XHQgKiAgQGV4dGVuZHMge1RvbmUuQXVkaW9Ob2RlfVxuXHRcdCAqICBAcGFyYW0ge1N0cmluZ30gdHlwZSBFaXRoZXIgXCJsZXZlbFwiIG9yIFwic2lnbmFsXCIuXG5cdFx0ICogIEBwYXJhbSB7TnVtYmVyfSBzbW9vdGhpbmcgVGhlIGFtb3VudCBvZiBzbW9vdGhpbmcgYXBwbGllZCBiZXR3ZWVuIGZyYW1lcy5cblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiB2YXIgbWV0ZXIgPSBuZXcgVG9uZS5NZXRlcigpO1xuXHRcdCAqIHZhciBtaWMgPSBuZXcgVG9uZS5Vc2VyTWVkaWEoKS5vcGVuKCk7XG5cdFx0ICogLy9jb25uZWN0IG1pYyB0byB0aGUgbWV0ZXJcblx0XHQgKiBtaWMuY29ubmVjdChtZXRlcik7XG5cdFx0ICogLy90aGUgY3VycmVudCBsZXZlbCBvZiB0aGUgbWljIGlucHV0XG5cdFx0ICogdmFyIGxldmVsID0gbWV0ZXIudmFsdWU7XG5cdFx0ICovXG5cdCAgICBUb25lLk1ldGVyID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBvcHRpb25zID0gVG9uZS5kZWZhdWx0cyhhcmd1bWVudHMsIFtcblx0ICAgICAgICAgICAgJ3R5cGUnLFxuXHQgICAgICAgICAgICAnc21vb3RoaW5nJ1xuXHQgICAgICAgIF0sIFRvbmUuTWV0ZXIpO1xuXHQgICAgICAgIFRvbmUuQXVkaW9Ob2RlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIHR5cGUgb2YgdGhlIG1ldGVyLCBlaXRoZXIgXCJsZXZlbFwiIG9yIFwic2lnbmFsXCIuXG5cdFx0XHQgKiAgQSBcImxldmVsXCIgbWV0ZXIgd2lsbCByZXR1cm4gdGhlIHZvbHVtZSBsZXZlbCAocm1zKSBvZiB0aGVcblx0XHRcdCAqICBpbnB1dCBzaWduYWwgYW5kIGEgXCJzaWduYWxcIiBtZXRlciB3aWxsIHJldHVyblxuXHRcdFx0ICogIHRoZSBzaWduYWwgdmFsdWUgb2YgdGhlIGlucHV0LlxuXHRcdFx0ICogIEB0eXBlICB7U3RyaW5nfVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy50eXBlID0gb3B0aW9ucy50eXBlO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBhbmFseXNlciBub2RlIHdoaWNoIGNvbXB1dGVzIHRoZSBsZXZlbHMuXG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqICBAdHlwZSAge1RvbmUuQW5hbHlzZXJ9XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmlucHV0ID0gdGhpcy5vdXRwdXQgPSB0aGlzLl9hbmFseXNlciA9IG5ldyBUb25lLkFuYWx5c2VyKCd3YXZlZm9ybScsIDUxMik7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGFtb3VudCBvZiBjYXJyeW92ZXIgYmV0d2VlbiB0aGUgY3VycmVudCBhbmQgbGFzdCBmcmFtZS5cblx0XHRcdCAqICBPbmx5IGFwcGxpZWQgbWV0ZXIgZm9yIFwibGV2ZWxcIiB0eXBlLlxuXHRcdFx0ICogIEB0eXBlICB7TnVtYmVyfVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5zbW9vdGhpbmcgPSBvcHRpb25zLnNtb290aGluZztcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgbGFzdCBjb21wdXRlZCB2YWx1ZVxuXHRcdFx0ICogIEB0eXBlIHtOdW1iZXJ9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2xhc3RWYWx1ZSA9IDA7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5NZXRlciwgVG9uZS5BdWRpb05vZGUpO1xuXHQgICAgLyoqXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICogIEBlbnVtIHtTdHJpbmd9XG5cdFx0ICovXG5cdCAgICBUb25lLk1ldGVyLlR5cGUgPSB7XG5cdCAgICAgICAgTGV2ZWw6ICdsZXZlbCcsXG5cdCAgICAgICAgU2lnbmFsOiAnc2lnbmFsJ1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgZGVmYXVsdHNcblx0XHQgKiAgQHR5cGUge09iamVjdH1cblx0XHQgKiAgQHN0YXRpY1xuXHRcdCAqICBAY29uc3Rcblx0XHQgKi9cblx0ICAgIFRvbmUuTWV0ZXIuZGVmYXVsdHMgPSB7XG5cdCAgICAgICAgJ3Ntb290aGluZyc6IDAuOCxcblx0ICAgICAgICAndHlwZSc6IFRvbmUuTWV0ZXIuVHlwZS5MZXZlbFxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqIFRoZSBjdXJyZW50IHZhbHVlIG9mIHRoZSBtZXRlci4gQSB2YWx1ZSBvZiAxIGlzXG5cdFx0ICogXCJ1bml0eVwiLlxuXHRcdCAqIEBtZW1iZXJPZiBUb25lLk1ldGVyI1xuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogQG5hbWUgdmFsdWVcblx0XHQgKiBAcmVhZE9ubHlcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLk1ldGVyLnByb3RvdHlwZSwgJ3ZhbHVlJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgc2lnbmFsID0gdGhpcy5fYW5hbHlzZXIuYW5hbHlzZSgpO1xuXHQgICAgICAgICAgICBpZiAodGhpcy50eXBlID09PSBUb25lLk1ldGVyLlR5cGUuTGV2ZWwpIHtcblx0ICAgICAgICAgICAgICAgIC8vcm1zXG5cdCAgICAgICAgICAgICAgICB2YXIgc3VtID0gMDtcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2lnbmFsLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgc3VtICs9IE1hdGgucG93KHNpZ25hbFtpXSwgMik7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB2YXIgcm1zID0gTWF0aC5zcXJ0KHN1bSAvIHNpZ25hbC5sZW5ndGgpO1xuXHQgICAgICAgICAgICAgICAgLy9zbW9vdGggaXRcblx0ICAgICAgICAgICAgICAgIHJtcyA9IE1hdGgubWF4KHJtcywgdGhpcy5fbGFzdFZhbHVlICogdGhpcy5zbW9vdGhpbmcpO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fbGFzdFZhbHVlID0gcm1zO1xuXHQgICAgICAgICAgICAgICAgLy9zY2FsZSBpdFxuXHQgICAgICAgICAgICAgICAgdmFyIHVuaXR5ID0gMC4zNTtcblx0ICAgICAgICAgICAgICAgIHZhciB2YWwgPSBybXMgLyB1bml0eTtcblx0ICAgICAgICAgICAgICAgIC8vc2NhbGUgdGhlIG91dHB1dCBjdXJ2ZVxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIE1hdGguc3FydCh2YWwpO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHNpZ25hbFswXTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIENsZWFuIHVwLlxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5NZXRlcn0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5NZXRlci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLkF1ZGlvTm9kZS5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuX2FuYWx5c2VyLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9hbmFseXNlciA9IG51bGw7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuTWV0ZXI7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICpcdEBjbGFzcyAgVG9uZS5TcGxpdCBzcGxpdHMgYW4gaW5jb21pbmcgc2lnbmFsIGludG8gbGVmdCBhbmQgcmlnaHQgY2hhbm5lbHMuXG5cdFx0ICpcblx0XHQgKiAgQGNvbnN0cnVjdG9yXG5cdFx0ICogIEBleHRlbmRzIHtUb25lLkF1ZGlvTm9kZX1cblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiB2YXIgc3BsaXQgPSBuZXcgVG9uZS5TcGxpdCgpO1xuXHRcdCAqIHN0ZXJlb1NpZ25hbC5jb25uZWN0KHNwbGl0KTtcblx0XHQgKi9cblx0ICAgIFRvbmUuU3BsaXQgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5BdWRpb05vZGUuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLmNyZWF0ZUluc091dHMoMCwgMik7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgQHR5cGUge0NoYW5uZWxTcGxpdHRlck5vZGV9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX3NwbGl0dGVyID0gdGhpcy5pbnB1dCA9IHRoaXMuY29udGV4dC5jcmVhdGVDaGFubmVsU3BsaXR0ZXIoMik7XG5cdCAgICAgICAgdGhpcy5fc3BsaXR0ZXIuY2hhbm5lbENvdW50ID0gMjtcblx0ICAgICAgICB0aGlzLl9zcGxpdHRlci5jaGFubmVsQ291bnRNb2RlID0gJ2V4cGxpY2l0Jztcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBMZWZ0IGNoYW5uZWwgb3V0cHV0LlxuXHRcdFx0ICogIEFsaWFzIGZvciA8Y29kZT5vdXRwdXRbMF08L2NvZGU+XG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuR2Fpbn1cblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMubGVmdCA9IHRoaXMub3V0cHV0WzBdID0gbmV3IFRvbmUuR2FpbigpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFJpZ2h0IGNoYW5uZWwgb3V0cHV0LlxuXHRcdFx0ICogIEFsaWFzIGZvciA8Y29kZT5vdXRwdXRbMV08L2NvZGU+XG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuR2Fpbn1cblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMucmlnaHQgPSB0aGlzLm91dHB1dFsxXSA9IG5ldyBUb25lLkdhaW4oKTtcblx0ICAgICAgICAvL2Nvbm5lY3Rpb25zXG5cdCAgICAgICAgdGhpcy5fc3BsaXR0ZXIuY29ubmVjdCh0aGlzLmxlZnQsIDAsIDApO1xuXHQgICAgICAgIHRoaXMuX3NwbGl0dGVyLmNvbm5lY3QodGhpcy5yaWdodCwgMSwgMCk7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5TcGxpdCwgVG9uZS5BdWRpb05vZGUpO1xuXHQgICAgLyoqXG5cdFx0ICogIENsZWFuIHVwLlxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5TcGxpdH0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5TcGxpdC5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLkF1ZGlvTm9kZS5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuX3NwbGl0dGVyLmRpc2Nvbm5lY3QoKTtcblx0ICAgICAgICB0aGlzLmxlZnQuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMubGVmdCA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5yaWdodC5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5yaWdodCA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fc3BsaXR0ZXIgPSBudWxsO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLlNwbGl0O1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgTWlkL1NpZGUgcHJvY2Vzc2luZyBzZXBhcmF0ZXMgdGhlIHRoZSAnbWlkJyBzaWduYWxcblx0XHQgKiAgICAgICAgICh3aGljaCBjb21lcyBvdXQgb2YgYm90aCB0aGUgbGVmdCBhbmQgdGhlIHJpZ2h0IGNoYW5uZWwpXG5cdFx0ICogICAgICAgICBhbmQgdGhlICdzaWRlJyAod2hpY2ggb25seSBjb21lcyBvdXQgb2YgdGhlIHRoZSBzaWRlIGNoYW5uZWxzKS4gPGJyPjxicj5cblx0XHQgKiAgICAgICAgIDxjb2RlPlxuXHRcdCAqICAgICAgICAgTWlkID0gKExlZnQrUmlnaHQpL3NxcnQoMik7ICAgLy8gb2J0YWluIG1pZC1zaWduYWwgZnJvbSBsZWZ0IGFuZCByaWdodDxicj5cblx0XHQgKiAgICAgICAgIFNpZGUgPSAoTGVmdC1SaWdodCkvc3FydCgyKTsgICAvLyBvYnRhaW4gc2lkZS1zaWduYWwgZnJvbSBsZWZ0IGFuZCByaWdoPGJyPlxuXHRcdCAqICAgICAgICAgPC9jb2RlPlxuXHRcdCAqXG5cdFx0ICogIEBleHRlbmRzIHtUb25lLkF1ZGlvTm9kZX1cblx0XHQgKiAgQGNvbnN0cnVjdG9yXG5cdFx0ICovXG5cdCAgICBUb25lLk1pZFNpZGVTcGxpdCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLkF1ZGlvTm9kZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuY3JlYXRlSW5zT3V0cygwLCAyKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBzcGxpdCB0aGUgaW5jb21pbmcgc2lnbmFsIGludG8gbGVmdCBhbmQgcmlnaHQgY2hhbm5lbHNcblx0XHRcdCAqICBAdHlwZSAge1RvbmUuU3BsaXR9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX3NwbGl0ID0gdGhpcy5pbnB1dCA9IG5ldyBUb25lLlNwbGl0KCk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIG1pZCBzZW5kLiBDb25uZWN0IHRvIG1pZCBwcm9jZXNzaW5nLiBBbGlhcyBmb3Jcblx0XHRcdCAqICA8Y29kZT5vdXRwdXRbMF08L2NvZGU+XG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuRXhwcn1cblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMubWlkID0gdGhpcy5vdXRwdXRbMF0gPSBuZXcgVG9uZS5FeHByKCcoJDAgKyAkMSkgKiAkMicpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBzaWRlIG91dHB1dC4gQ29ubmVjdCB0byBzaWRlIHByb2Nlc3NpbmcuIEFsaWFzIGZvclxuXHRcdFx0ICogIDxjb2RlPm91dHB1dFsxXTwvY29kZT5cblx0XHRcdCAqICBAdHlwZSB7VG9uZS5FeHByfVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5zaWRlID0gdGhpcy5vdXRwdXRbMV0gPSBuZXcgVG9uZS5FeHByKCcoJDAgLSAkMSkgKiAkMicpO1xuXHQgICAgICAgIHRoaXMuX3NwbGl0LmNvbm5lY3QodGhpcy5taWQsIDAsIDApO1xuXHQgICAgICAgIHRoaXMuX3NwbGl0LmNvbm5lY3QodGhpcy5taWQsIDEsIDEpO1xuXHQgICAgICAgIHRoaXMuX3NwbGl0LmNvbm5lY3QodGhpcy5zaWRlLCAwLCAwKTtcblx0ICAgICAgICB0aGlzLl9zcGxpdC5jb25uZWN0KHRoaXMuc2lkZSwgMSwgMSk7XG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmdldENvbnN0YW50KE1hdGguU1FSVDFfMikuY29ubmVjdCh0aGlzLm1pZCwgMCwgMik7XG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmdldENvbnN0YW50KE1hdGguU1FSVDFfMikuY29ubmVjdCh0aGlzLnNpZGUsIDAsIDIpO1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuTWlkU2lkZVNwbGl0LCBUb25lLkF1ZGlvTm9kZSk7XG5cdCAgICAvKipcblx0XHQgKiAgY2xlYW4gdXBcblx0XHQgKiAgQHJldHVybnMge1RvbmUuTWlkU2lkZVNwbGl0fSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLk1pZFNpZGVTcGxpdC5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLkF1ZGlvTm9kZS5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMubWlkLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLm1pZCA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5zaWRlLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLnNpZGUgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX3NwbGl0LmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9zcGxpdCA9IG51bGw7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuTWlkU2lkZVNwbGl0O1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgTWlkL1NpZGUgcHJvY2Vzc2luZyBzZXBhcmF0ZXMgdGhlIHRoZSAnbWlkJyBzaWduYWxcblx0XHQgKiAgICAgICAgICh3aGljaCBjb21lcyBvdXQgb2YgYm90aCB0aGUgbGVmdCBhbmQgdGhlIHJpZ2h0IGNoYW5uZWwpXG5cdFx0ICogICAgICAgICBhbmQgdGhlICdzaWRlJyAod2hpY2ggb25seSBjb21lcyBvdXQgb2YgdGhlIHRoZSBzaWRlIGNoYW5uZWxzKS5cblx0XHQgKiAgICAgICAgIE1pZFNpZGVNZXJnZSBtZXJnZXMgdGhlIG1pZCBhbmQgc2lkZSBzaWduYWwgYWZ0ZXIgdGhleSd2ZSBiZWVuIHNlcGVyYXRlZFxuXHRcdCAqICAgICAgICAgYnkgVG9uZS5NaWRTaWRlU3BsaXQuPGJyPjxicj5cblx0XHQgKiAgICAgICAgIDxjb2RlPlxuXHRcdCAqICAgICAgICAgTGVmdCA9IChNaWQrU2lkZSkvc3FydCgyKTsgICAvLyBvYnRhaW4gbGVmdCBzaWduYWwgZnJvbSBtaWQgYW5kIHNpZGU8YnI+XG5cdFx0ICogICAgICAgICBSaWdodCA9IChNaWQtU2lkZSkvc3FydCgyKTsgICAvLyBvYnRhaW4gcmlnaHQgc2lnbmFsIGZyb20gbWlkIGFuZCBzaWRlPGJyPlxuXHRcdCAqICAgICAgICAgPC9jb2RlPlxuXHRcdCAqXG5cdFx0ICogIEBleHRlbmRzIHtUb25lLkF1ZGlvTm9kZX1cblx0XHQgKiAgQGNvbnN0cnVjdG9yXG5cdFx0ICovXG5cdCAgICBUb25lLk1pZFNpZGVNZXJnZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLkF1ZGlvTm9kZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuY3JlYXRlSW5zT3V0cygyLCAwKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgbWlkIHNpZ25hbCBpbnB1dC4gQWxpYXMgZm9yXG5cdFx0XHQgKiAgPGNvZGU+aW5wdXRbMF08L2NvZGU+XG5cdFx0XHQgKiAgQHR5cGUgIHtUb25lLkdhaW59XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLm1pZCA9IHRoaXMuaW5wdXRbMF0gPSBuZXcgVG9uZS5HYWluKCk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgcmVjb21iaW5lIHRoZSBtaWQvc2lkZSBpbnRvIExlZnRcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5FeHByfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9sZWZ0ID0gbmV3IFRvbmUuRXhwcignKCQwICsgJDEpICogJDInKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgc2lkZSBzaWduYWwgaW5wdXQuIEFsaWFzIGZvclxuXHRcdFx0ICogIDxjb2RlPmlucHV0WzFdPC9jb2RlPlxuXHRcdFx0ICogIEB0eXBlICB7VG9uZS5HYWlufVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5zaWRlID0gdGhpcy5pbnB1dFsxXSA9IG5ldyBUb25lLkdhaW4oKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICByZWNvbWJpbmUgdGhlIG1pZC9zaWRlIGludG8gUmlnaHRcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5FeHByfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9yaWdodCA9IG5ldyBUb25lLkV4cHIoJygkMCAtICQxKSAqICQyJyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgTWVyZ2UgdGhlIGxlZnQvcmlnaHQgc2lnbmFsIGJhY2sgaW50byBhIHN0ZXJlbyBzaWduYWwuXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuTWVyZ2V9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX21lcmdlID0gdGhpcy5vdXRwdXQgPSBuZXcgVG9uZS5NZXJnZSgpO1xuXHQgICAgICAgIHRoaXMubWlkLmNvbm5lY3QodGhpcy5fbGVmdCwgMCwgMCk7XG5cdCAgICAgICAgdGhpcy5zaWRlLmNvbm5lY3QodGhpcy5fbGVmdCwgMCwgMSk7XG5cdCAgICAgICAgdGhpcy5taWQuY29ubmVjdCh0aGlzLl9yaWdodCwgMCwgMCk7XG5cdCAgICAgICAgdGhpcy5zaWRlLmNvbm5lY3QodGhpcy5fcmlnaHQsIDAsIDEpO1xuXHQgICAgICAgIHRoaXMuX2xlZnQuY29ubmVjdCh0aGlzLl9tZXJnZSwgMCwgMCk7XG5cdCAgICAgICAgdGhpcy5fcmlnaHQuY29ubmVjdCh0aGlzLl9tZXJnZSwgMCwgMSk7XG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmdldENvbnN0YW50KE1hdGguU1FSVDFfMikuY29ubmVjdCh0aGlzLl9sZWZ0LCAwLCAyKTtcblx0ICAgICAgICB0aGlzLmNvbnRleHQuZ2V0Q29uc3RhbnQoTWF0aC5TUVJUMV8yKS5jb25uZWN0KHRoaXMuX3JpZ2h0LCAwLCAyKTtcblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLk1pZFNpZGVNZXJnZSwgVG9uZS5BdWRpb05vZGUpO1xuXHQgICAgLyoqXG5cdFx0ICogIGNsZWFuIHVwXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLk1pZFNpZGVNZXJnZX0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5NaWRTaWRlTWVyZ2UucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5BdWRpb05vZGUucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLm1pZC5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5taWQgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuc2lkZS5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5zaWRlID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9sZWZ0LmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9sZWZ0ID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9yaWdodC5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fcmlnaHQgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX21lcmdlLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9tZXJnZSA9IG51bGw7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuTWlkU2lkZU1lcmdlO1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgVG9uZS5NaWRTaWRlQ29tcHJlc3NvciBhcHBsaWVzIHR3byBkaWZmZXJlbnQgY29tcHJlc3NvcnMgdG8gdGhlIG1pZFxuXHRcdCAqICAgICAgICAgYW5kIHNpZGUgc2lnbmFsIGNvbXBvbmVudHMuIFNlZSBUb25lLk1pZFNpZGVTcGxpdC5cblx0XHQgKlxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZS5BdWRpb05vZGV9XG5cdFx0ICogIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIFRoZSBvcHRpb25zIHRoYXQgYXJlIHBhc3NlZCB0byB0aGUgbWlkIGFuZCBzaWRlXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXByZXNzb3JzLlxuXHRcdCAqICBAY29uc3RydWN0b3Jcblx0XHQgKi9cblx0ICAgIFRvbmUuTWlkU2lkZUNvbXByZXNzb3IgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuXHQgICAgICAgIFRvbmUuQXVkaW9Ob2RlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgb3B0aW9ucyA9IFRvbmUuZGVmYXVsdEFyZyhvcHRpb25zLCBUb25lLk1pZFNpZGVDb21wcmVzc29yLmRlZmF1bHRzKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICB0aGUgbWlkL3NpZGUgc3BsaXRcblx0XHRcdCAqICBAdHlwZSAge1RvbmUuTWlkU2lkZVNwbGl0fVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9taWRTaWRlU3BsaXQgPSB0aGlzLmlucHV0ID0gbmV3IFRvbmUuTWlkU2lkZVNwbGl0KCk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgdGhlIG1pZC9zaWRlIHJlY29tYmluYXRpb25cblx0XHRcdCAqICBAdHlwZSAge1RvbmUuTWlkU2lkZU1lcmdlfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9taWRTaWRlTWVyZ2UgPSB0aGlzLm91dHB1dCA9IG5ldyBUb25lLk1pZFNpZGVNZXJnZSgpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBjb21wcmVzc29yIGFwcGxpZWQgdG8gdGhlIG1pZCBzaWduYWxcblx0XHRcdCAqICBAdHlwZSAge1RvbmUuQ29tcHJlc3Nvcn1cblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMubWlkID0gbmV3IFRvbmUuQ29tcHJlc3NvcihvcHRpb25zLm1pZCk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGNvbXByZXNzb3IgYXBwbGllZCB0byB0aGUgc2lkZSBzaWduYWxcblx0XHRcdCAqICBAdHlwZSAge1RvbmUuQ29tcHJlc3Nvcn1cblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuc2lkZSA9IG5ldyBUb25lLkNvbXByZXNzb3Iob3B0aW9ucy5zaWRlKTtcblx0ICAgICAgICB0aGlzLl9taWRTaWRlU3BsaXQubWlkLmNoYWluKHRoaXMubWlkLCB0aGlzLl9taWRTaWRlTWVyZ2UubWlkKTtcblx0ICAgICAgICB0aGlzLl9taWRTaWRlU3BsaXQuc2lkZS5jaGFpbih0aGlzLnNpZGUsIHRoaXMuX21pZFNpZGVNZXJnZS5zaWRlKTtcblx0ICAgICAgICB0aGlzLl9yZWFkT25seShbXG5cdCAgICAgICAgICAgICdtaWQnLFxuXHQgICAgICAgICAgICAnc2lkZSdcblx0ICAgICAgICBdKTtcblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLk1pZFNpZGVDb21wcmVzc29yLCBUb25lLkF1ZGlvTm9kZSk7XG5cdCAgICAvKipcblx0XHQgKiAgQGNvbnN0XG5cdFx0ICogIEBzdGF0aWNcblx0XHQgKiAgQHR5cGUge09iamVjdH1cblx0XHQgKi9cblx0ICAgIFRvbmUuTWlkU2lkZUNvbXByZXNzb3IuZGVmYXVsdHMgPSB7XG5cdCAgICAgICAgJ21pZCc6IHtcblx0ICAgICAgICAgICAgJ3JhdGlvJzogMyxcblx0ICAgICAgICAgICAgJ3RocmVzaG9sZCc6IC0yNCxcblx0ICAgICAgICAgICAgJ3JlbGVhc2UnOiAwLjAzLFxuXHQgICAgICAgICAgICAnYXR0YWNrJzogMC4wMixcblx0ICAgICAgICAgICAgJ2tuZWUnOiAxNlxuXHQgICAgICAgIH0sXG5cdCAgICAgICAgJ3NpZGUnOiB7XG5cdCAgICAgICAgICAgICdyYXRpbyc6IDYsXG5cdCAgICAgICAgICAgICd0aHJlc2hvbGQnOiAtMzAsXG5cdCAgICAgICAgICAgICdyZWxlYXNlJzogMC4yNSxcblx0ICAgICAgICAgICAgJ2F0dGFjayc6IDAuMDMsXG5cdCAgICAgICAgICAgICdrbmVlJzogMTBcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIENsZWFuIHVwLlxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5NaWRTaWRlQ29tcHJlc3Nvcn0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5NaWRTaWRlQ29tcHJlc3Nvci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLkF1ZGlvTm9kZS5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuX3dyaXRhYmxlKFtcblx0ICAgICAgICAgICAgJ21pZCcsXG5cdCAgICAgICAgICAgICdzaWRlJ1xuXHQgICAgICAgIF0pO1xuXHQgICAgICAgIHRoaXMubWlkLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLm1pZCA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5zaWRlLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLnNpZGUgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX21pZFNpZGVTcGxpdC5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fbWlkU2lkZVNwbGl0ID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9taWRTaWRlTWVyZ2UuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX21pZFNpZGVNZXJnZSA9IG51bGw7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuTWlkU2lkZUNvbXByZXNzb3I7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyBUb25lLk1vbm8gY29lcmNlcyB0aGUgaW5jb21pbmcgbW9ubyBvciBzdGVyZW8gc2lnbmFsIGludG8gYSBtb25vIHNpZ25hbFxuXHRcdCAqICAgICAgICAgd2hlcmUgYm90aCBsZWZ0IGFuZCByaWdodCBjaGFubmVscyBoYXZlIHRoZSBzYW1lIHZhbHVlLiBUaGlzIGNhbiBiZSB1c2VmdWxcblx0XHQgKiAgICAgICAgIGZvciBbc3RlcmVvIGltYWdpbmddKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1N0ZXJlb19pbWFnaW5nKS5cblx0XHQgKlxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZS5BdWRpb05vZGV9XG5cdFx0ICogIEBjb25zdHJ1Y3RvclxuXHRcdCAqL1xuXHQgICAgVG9uZS5Nb25vID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuQXVkaW9Ob2RlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgdGhpcy5jcmVhdGVJbnNPdXRzKDEsIDApO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIG1lcmdlIHRoZSBzaWduYWxcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5NZXJnZX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fbWVyZ2UgPSB0aGlzLm91dHB1dCA9IG5ldyBUb25lLk1lcmdlKCk7XG5cdCAgICAgICAgdGhpcy5pbnB1dC5jb25uZWN0KHRoaXMuX21lcmdlLCAwLCAwKTtcblx0ICAgICAgICB0aGlzLmlucHV0LmNvbm5lY3QodGhpcy5fbWVyZ2UsIDAsIDEpO1xuXHQgICAgICAgIHRoaXMuaW5wdXQuZ2Fpbi52YWx1ZSA9IFRvbmUuZGJUb0dhaW4oLTEwKTtcblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLk1vbm8pO1xuXHQgICAgLyoqXG5cdFx0ICogIGNsZWFuIHVwXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLk1vbm99IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuTW9uby5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLkF1ZGlvTm9kZS5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuX21lcmdlLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9tZXJnZSA9IG51bGw7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuTW9ubztcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgXG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzIEEgY29tcHJlc3NvciB3aXRoIHNlcGVyYXRlIGNvbnRyb2xzIG92ZXIgbG93L21pZC9oaWdoIGR5bmFtaWNzXG5cdFx0ICpcblx0XHQgKiAgQGV4dGVuZHMge1RvbmUuQXVkaW9Ob2RlfVxuXHRcdCAqICBAY29uc3RydWN0b3Jcblx0XHQgKiAgQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgVGhlIGxvdy9taWQvaGlnaCBjb21wcmVzc29yIHNldHRpbmdzLlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICB2YXIgbXVsdGliYW5kID0gbmV3IFRvbmUuTXVsdGliYW5kQ29tcHJlc3Nvcih7XG5cdFx0ICogIFx0XCJsb3dGcmVxdWVuY3lcIiA6IDIwMCxcblx0XHQgKiAgXHRcImhpZ2hGcmVxdWVuY3lcIiA6IDEzMDBcblx0XHQgKiAgXHRcImxvd1wiIDoge1xuXHRcdCAqICBcdFx0XCJ0aHJlc2hvbGRcIiA6IC0xMlxuXHRcdCAqICBcdH1cblx0XHQgKiAgfSlcblx0XHQgKi9cblx0ICAgIFRvbmUuTXVsdGliYW5kQ29tcHJlc3NvciA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG5cdCAgICAgICAgVG9uZS5BdWRpb05vZGUuY2FsbCh0aGlzKTtcblx0ICAgICAgICBvcHRpb25zID0gVG9uZS5kZWZhdWx0QXJnKGFyZ3VtZW50cywgVG9uZS5NdWx0aWJhbmRDb21wcmVzc29yLmRlZmF1bHRzKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBzcGxpdCB0aGUgaW5jb21pbmcgc2lnbmFsIGludG8gaGlnaC9taWQvbG93XG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuTXVsdGliYW5kU3BsaXR9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX3NwbGl0dGVyID0gdGhpcy5pbnB1dCA9IG5ldyBUb25lLk11bHRpYmFuZFNwbGl0KHtcblx0ICAgICAgICAgICAgJ2xvd0ZyZXF1ZW5jeSc6IG9wdGlvbnMubG93RnJlcXVlbmN5LFxuXHQgICAgICAgICAgICAnaGlnaEZyZXF1ZW5jeSc6IG9wdGlvbnMuaGlnaEZyZXF1ZW5jeVxuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIGxvdy9taWQgY3Jvc3NvdmVyIGZyZXF1ZW5jeS5cblx0XHRcdCAqICBAdHlwZSB7RnJlcXVlbmN5fVxuXHRcdFx0ICogIEBzaWduYWxcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMubG93RnJlcXVlbmN5ID0gdGhpcy5fc3BsaXR0ZXIubG93RnJlcXVlbmN5O1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIG1pZC9oaWdoIGNyb3Nzb3ZlciBmcmVxdWVuY3kuXG5cdFx0XHQgKiAgQHR5cGUge0ZyZXF1ZW5jeX1cblx0XHRcdCAqICBAc2lnbmFsXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmhpZ2hGcmVxdWVuY3kgPSB0aGlzLl9zcGxpdHRlci5oaWdoRnJlcXVlbmN5O1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHRoZSBvdXRwdXRcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5HYWlufVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLm91dHB1dCA9IG5ldyBUb25lLkdhaW4oKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgY29tcHJlc3NvciBhcHBsaWVkIHRvIHRoZSBsb3cgZnJlcXVlbmNpZXMuXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuQ29tcHJlc3Nvcn1cblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMubG93ID0gbmV3IFRvbmUuQ29tcHJlc3NvcihvcHRpb25zLmxvdyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGNvbXByZXNzb3IgYXBwbGllZCB0byB0aGUgbWlkIGZyZXF1ZW5jaWVzLlxuXHRcdFx0ICogIEB0eXBlIHtUb25lLkNvbXByZXNzb3J9XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLm1pZCA9IG5ldyBUb25lLkNvbXByZXNzb3Iob3B0aW9ucy5taWQpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBjb21wcmVzc29yIGFwcGxpZWQgdG8gdGhlIGhpZ2ggZnJlcXVlbmNpZXMuXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuQ29tcHJlc3Nvcn1cblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuaGlnaCA9IG5ldyBUb25lLkNvbXByZXNzb3Iob3B0aW9ucy5oaWdoKTtcblx0ICAgICAgICAvL2Nvbm5lY3QgdGhlIGNvbXByZXNzb3Jcblx0ICAgICAgICB0aGlzLl9zcGxpdHRlci5sb3cuY2hhaW4odGhpcy5sb3csIHRoaXMub3V0cHV0KTtcblx0ICAgICAgICB0aGlzLl9zcGxpdHRlci5taWQuY2hhaW4odGhpcy5taWQsIHRoaXMub3V0cHV0KTtcblx0ICAgICAgICB0aGlzLl9zcGxpdHRlci5oaWdoLmNoYWluKHRoaXMuaGlnaCwgdGhpcy5vdXRwdXQpO1xuXHQgICAgICAgIHRoaXMuX3JlYWRPbmx5KFtcblx0ICAgICAgICAgICAgJ2hpZ2gnLFxuXHQgICAgICAgICAgICAnbWlkJyxcblx0ICAgICAgICAgICAgJ2xvdycsXG5cdCAgICAgICAgICAgICdoaWdoRnJlcXVlbmN5Jyxcblx0ICAgICAgICAgICAgJ2xvd0ZyZXF1ZW5jeSdcblx0ICAgICAgICBdKTtcblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLk11bHRpYmFuZENvbXByZXNzb3IsIFRvbmUuQXVkaW9Ob2RlKTtcblx0ICAgIC8qKlxuXHRcdCAqICBAY29uc3Rcblx0XHQgKiAgQHN0YXRpY1xuXHRcdCAqICBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqL1xuXHQgICAgVG9uZS5NdWx0aWJhbmRDb21wcmVzc29yLmRlZmF1bHRzID0ge1xuXHQgICAgICAgICdsb3cnOiBUb25lLkNvbXByZXNzb3IuZGVmYXVsdHMsXG5cdCAgICAgICAgJ21pZCc6IFRvbmUuQ29tcHJlc3Nvci5kZWZhdWx0cyxcblx0ICAgICAgICAnaGlnaCc6IFRvbmUuQ29tcHJlc3Nvci5kZWZhdWx0cyxcblx0ICAgICAgICAnbG93RnJlcXVlbmN5JzogMjUwLFxuXHQgICAgICAgICdoaWdoRnJlcXVlbmN5JzogMjAwMFxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBjbGVhbiB1cFxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5NdWx0aWJhbmRDb21wcmVzc29yfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLk11bHRpYmFuZENvbXByZXNzb3IucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5BdWRpb05vZGUucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLl9zcGxpdHRlci5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fd3JpdGFibGUoW1xuXHQgICAgICAgICAgICAnaGlnaCcsXG5cdCAgICAgICAgICAgICdtaWQnLFxuXHQgICAgICAgICAgICAnbG93Jyxcblx0ICAgICAgICAgICAgJ2hpZ2hGcmVxdWVuY3knLFxuXHQgICAgICAgICAgICAnbG93RnJlcXVlbmN5J1xuXHQgICAgICAgIF0pO1xuXHQgICAgICAgIHRoaXMubG93LmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLm1pZC5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5oaWdoLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9zcGxpdHRlciA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5sb3cgPSBudWxsO1xuXHQgICAgICAgIHRoaXMubWlkID0gbnVsbDtcblx0ICAgICAgICB0aGlzLmhpZ2ggPSBudWxsO1xuXHQgICAgICAgIHRoaXMubG93RnJlcXVlbmN5ID0gbnVsbDtcblx0ICAgICAgICB0aGlzLmhpZ2hGcmVxdWVuY3kgPSBudWxsO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLk11bHRpYmFuZENvbXByZXNzb3I7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyAgVG9uZS5QYW5uZXIgaXMgYW4gZXF1YWwgcG93ZXIgTGVmdC9SaWdodCBQYW5uZXIgYW5kIGRvZXMgbm90XG5cdFx0ICogICAgICAgICAgc3VwcG9ydCAzRC4gUGFubmVyIHVzZXMgdGhlIFN0ZXJlb1Bhbm5lck5vZGUgd2hlbiBhdmFpbGFibGUuXG5cdFx0ICpcblx0XHQgKiAgQGNvbnN0cnVjdG9yXG5cdFx0ICogIEBleHRlbmRzIHtUb25lLkF1ZGlvTm9kZX1cblx0XHQgKiAgQHBhcmFtIHtOb3JtYWxSYW5nZX0gW2luaXRpYWxQYW49MF0gVGhlIGluaXRhaWwgcGFubmVyIHZhbHVlIChjZW50ZXIpLlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAvL3BhbiB0aGUgaW5wdXQgc2lnbmFsIGhhcmQgcmlnaHQuXG5cdFx0ICogIHZhciBwYW5uZXIgPSBuZXcgVG9uZS5QYW5uZXIoMSk7XG5cdFx0ICovXG5cdCAgICBUb25lLlBhbm5lciA9IGZ1bmN0aW9uIChpbml0aWFsUGFuKSB7XG5cdCAgICAgICAgVG9uZS5BdWRpb05vZGUuY2FsbCh0aGlzKTtcblx0ICAgICAgICBpZiAoVG9uZS5QYW5uZXIuaGFzU3RlcmVvUGFubmVyKSB7XG5cdCAgICAgICAgICAgIC8qKlxuXHRcdFx0XHQgKiAgdGhlIHBhbm5lciBub2RlXG5cdFx0XHRcdCAqICBAdHlwZSB7U3RlcmVvUGFubmVyTm9kZX1cblx0XHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHRcdCAqL1xuXHQgICAgICAgICAgICB0aGlzLl9wYW5uZXIgPSB0aGlzLmlucHV0ID0gdGhpcy5vdXRwdXQgPSB0aGlzLmNvbnRleHQuY3JlYXRlU3RlcmVvUGFubmVyKCk7XG5cdCAgICAgICAgICAgIC8qKlxuXHRcdFx0XHQgKiAgVGhlIHBhbiBjb250cm9sLiAtMSA9IGhhcmQgbGVmdCwgMSA9IGhhcmQgcmlnaHQuXG5cdFx0XHRcdCAqICBAdHlwZSB7Tm9ybWFsUmFuZ2V9XG5cdFx0XHRcdCAqICBAc2lnbmFsXG5cdFx0XHRcdCAqL1xuXHQgICAgICAgICAgICB0aGlzLnBhbiA9IHRoaXMuX3Bhbm5lci5wYW47XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgLyoqXG5cdFx0XHRcdCAqICB0aGUgZHJ5L3dldCBrbm9iXG5cdFx0XHRcdCAqICBAdHlwZSB7VG9uZS5Dcm9zc0ZhZGV9XG5cdFx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0XHQgKi9cblx0ICAgICAgICAgICAgdGhpcy5fY3Jvc3NGYWRlID0gbmV3IFRvbmUuQ3Jvc3NGYWRlKCk7XG5cdCAgICAgICAgICAgIC8qKlxuXHRcdFx0XHQgKiAgQHR5cGUge1RvbmUuTWVyZ2V9XG5cdFx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0XHQgKi9cblx0ICAgICAgICAgICAgdGhpcy5fbWVyZ2VyID0gdGhpcy5vdXRwdXQgPSBuZXcgVG9uZS5NZXJnZSgpO1xuXHQgICAgICAgICAgICAvKipcblx0XHRcdFx0ICogIEB0eXBlIHtUb25lLlNwbGl0fVxuXHRcdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdFx0ICovXG5cdCAgICAgICAgICAgIHRoaXMuX3NwbGl0dGVyID0gdGhpcy5pbnB1dCA9IG5ldyBUb25lLlNwbGl0KCk7XG5cdCAgICAgICAgICAgIC8qKlxuXHRcdFx0XHQgKiAgVGhlIHBhbiBjb250cm9sLiAtMSA9IGhhcmQgbGVmdCwgMSA9IGhhcmQgcmlnaHQuXG5cdFx0XHRcdCAqICBAdHlwZSB7QXVkaW9SYW5nZX1cblx0XHRcdFx0ICogIEBzaWduYWxcblx0XHRcdFx0ICovXG5cdCAgICAgICAgICAgIHRoaXMucGFuID0gbmV3IFRvbmUuU2lnbmFsKDAsIFRvbmUuVHlwZS5BdWRpb1JhbmdlKTtcblx0ICAgICAgICAgICAgLyoqXG5cdFx0XHRcdCAqICBhbHdheXMgc2VuZHMgMFxuXHRcdFx0XHQgKiAgQHR5cGUge1RvbmUuWmVyb31cblx0XHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHRcdCAqL1xuXHQgICAgICAgICAgICB0aGlzLl96ZXJvID0gbmV3IFRvbmUuWmVybygpO1xuXHQgICAgICAgICAgICAvKipcblx0XHRcdFx0ICogIFRoZSBhbmFsb2cgdG8gZ2FpbiBjb252ZXJzaW9uXG5cdFx0XHRcdCAqICBAdHlwZSAge1RvbmUuQXVkaW9Ub0dhaW59XG5cdFx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0XHQgKi9cblx0ICAgICAgICAgICAgdGhpcy5fYTJnID0gbmV3IFRvbmUuQXVkaW9Ub0dhaW4oKTtcblx0ICAgICAgICAgICAgLy9DT05ORUNUSU9OUzpcblx0ICAgICAgICAgICAgdGhpcy5femVyby5jb25uZWN0KHRoaXMuX2EyZyk7XG5cdCAgICAgICAgICAgIHRoaXMucGFuLmNoYWluKHRoaXMuX2EyZywgdGhpcy5fY3Jvc3NGYWRlLmZhZGUpO1xuXHQgICAgICAgICAgICAvL2xlZnQgY2hhbm5lbCBpcyBhLCByaWdodCBjaGFubmVsIGlzIGJcblx0ICAgICAgICAgICAgdGhpcy5fc3BsaXR0ZXIuY29ubmVjdCh0aGlzLl9jcm9zc0ZhZGUsIDAsIDApO1xuXHQgICAgICAgICAgICB0aGlzLl9zcGxpdHRlci5jb25uZWN0KHRoaXMuX2Nyb3NzRmFkZSwgMSwgMSk7XG5cdCAgICAgICAgICAgIC8vbWVyZ2UgaXQgYmFjayB0b2dldGhlclxuXHQgICAgICAgICAgICB0aGlzLl9jcm9zc0ZhZGUuYS5jb25uZWN0KHRoaXMuX21lcmdlciwgMCwgMCk7XG5cdCAgICAgICAgICAgIHRoaXMuX2Nyb3NzRmFkZS5iLmNvbm5lY3QodGhpcy5fbWVyZ2VyLCAwLCAxKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgLy9pbml0aWFsIHZhbHVlXG5cdCAgICAgICAgdGhpcy5wYW4udmFsdWUgPSBUb25lLmRlZmF1bHRBcmcoaW5pdGlhbFBhbiwgMCk7XG5cdCAgICAgICAgdGhpcy5fcmVhZE9ubHkoJ3BhbicpO1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuUGFubmVyLCBUb25lLkF1ZGlvTm9kZSk7XG5cdCAgICAvKipcblx0XHQgKiAgSW5kaWNhdGVzIGlmIHRoZSBwYW5uZXIgaXMgdXNpbmcgdGhlIG5ldyBTdGVyZW9QYW5uZXJOb2RlIGludGVybmFsbHlcblx0XHQgKiAgQHR5cGUgIHtCb29sZWFufVxuXHRcdCAqICBAc3RhdGljXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICogIEByZWFkT25seVxuXHRcdCAqL1xuXHQgICAgVG9uZS5QYW5uZXIuaGFzU3RlcmVvUGFubmVyID0gVG9uZS5jb250ZXh0ICYmIFRvbmUuaXNGdW5jdGlvbihUb25lLmNvbnRleHQuY3JlYXRlU3RlcmVvUGFubmVyKTtcblx0ICAgIC8qKlxuXHRcdCAqICBDbGVhbiB1cC5cblx0XHQgKiAgQHJldHVybnMge1RvbmUuUGFubmVyfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLlBhbm5lci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLkF1ZGlvTm9kZS5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuX3dyaXRhYmxlKCdwYW4nKTtcblx0ICAgICAgICBpZiAoVG9uZS5QYW5uZXIuaGFzU3RlcmVvUGFubmVyKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3Bhbm5lci5kaXNjb25uZWN0KCk7XG5cdCAgICAgICAgICAgIHRoaXMuX3Bhbm5lciA9IG51bGw7XG5cdCAgICAgICAgICAgIHRoaXMucGFuID0gbnVsbDtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICB0aGlzLl96ZXJvLmRpc3Bvc2UoKTtcblx0ICAgICAgICAgICAgdGhpcy5femVybyA9IG51bGw7XG5cdCAgICAgICAgICAgIHRoaXMuX2Nyb3NzRmFkZS5kaXNwb3NlKCk7XG5cdCAgICAgICAgICAgIHRoaXMuX2Nyb3NzRmFkZSA9IG51bGw7XG5cdCAgICAgICAgICAgIHRoaXMuX3NwbGl0dGVyLmRpc3Bvc2UoKTtcblx0ICAgICAgICAgICAgdGhpcy5fc3BsaXR0ZXIgPSBudWxsO1xuXHQgICAgICAgICAgICB0aGlzLl9tZXJnZXIuZGlzcG9zZSgpO1xuXHQgICAgICAgICAgICB0aGlzLl9tZXJnZXIgPSBudWxsO1xuXHQgICAgICAgICAgICB0aGlzLnBhbi5kaXNwb3NlKCk7XG5cdCAgICAgICAgICAgIHRoaXMucGFuID0gbnVsbDtcblx0ICAgICAgICAgICAgdGhpcy5fYTJnLmRpc3Bvc2UoKTtcblx0ICAgICAgICAgICAgdGhpcy5fYTJnID0gbnVsbDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuUGFubmVyO1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgIEEgc3BhdGlhbGl6ZWQgcGFubmVyIG5vZGUgd2hpY2ggc3VwcG9ydHMgZXF1YWxwb3dlciBvciBIUlRGIHBhbm5pbmcuXG5cdFx0ICogICAgICAgICAgVHJpZXMgdG8gbm9ybWFsaXplIHRoZSBBUEkgYWNyb3NzIHZhcmlvdXMgYnJvd3NlcnMuIFNlZSBUb25lLkxpc3RlbmVyXG5cdFx0ICpcblx0XHQgKiAgQGNvbnN0cnVjdG9yXG5cdFx0ICogIEBleHRlbmRzIHtUb25lLkF1ZGlvTm9kZX1cblx0XHQgKiAgQHBhcmFtIHtOdW1iZXJ9IHBvc2l0aW9uWCBUaGUgaW5pdGlhbCB4IHBvc2l0aW9uLlxuXHRcdCAqICBAcGFyYW0ge051bWJlcn0gcG9zaXRpb25ZIFRoZSBpbml0aWFsIHkgcG9zaXRpb24uXG5cdFx0ICogIEBwYXJhbSB7TnVtYmVyfSBwb3NpdGlvblogVGhlIGluaXRpYWwgeiBwb3NpdGlvbi5cblx0XHQgKi9cblx0ICAgIFRvbmUuUGFubmVyM0QgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIG9wdGlvbnMgPSBUb25lLmRlZmF1bHRzKGFyZ3VtZW50cywgW1xuXHQgICAgICAgICAgICAncG9zaXRpb25YJyxcblx0ICAgICAgICAgICAgJ3Bvc2l0aW9uWScsXG5cdCAgICAgICAgICAgICdwb3NpdGlvblonXG5cdCAgICAgICAgXSwgVG9uZS5QYW5uZXIzRCk7XG5cdCAgICAgICAgVG9uZS5BdWRpb05vZGUuY2FsbCh0aGlzKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgcGFubmVyIG5vZGVcblx0XHRcdCAqICBAdHlwZSB7UGFubmVyTm9kZX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fcGFubmVyID0gdGhpcy5pbnB1dCA9IHRoaXMub3V0cHV0ID0gdGhpcy5jb250ZXh0LmNyZWF0ZVBhbm5lcigpO1xuXHQgICAgICAgIC8vc2V0IHNvbWUgdmFsdWVzXG5cdCAgICAgICAgdGhpcy5fcGFubmVyLnBhbm5pbmdNb2RlbCA9IG9wdGlvbnMucGFubmluZ01vZGVsO1xuXHQgICAgICAgIHRoaXMuX3Bhbm5lci5tYXhEaXN0YW5jZSA9IG9wdGlvbnMubWF4RGlzdGFuY2U7XG5cdCAgICAgICAgdGhpcy5fcGFubmVyLmRpc3RhbmNlTW9kZWwgPSBvcHRpb25zLmRpc3RhbmNlTW9kZWw7XG5cdCAgICAgICAgdGhpcy5fcGFubmVyLmNvbmVPdXRlckdhaW4gPSBvcHRpb25zLmNvbmVPdXRlckdhaW47XG5cdCAgICAgICAgdGhpcy5fcGFubmVyLmNvbmVPdXRlckFuZ2xlID0gb3B0aW9ucy5jb25lT3V0ZXJBbmdsZTtcblx0ICAgICAgICB0aGlzLl9wYW5uZXIuY29uZUlubmVyQW5nbGUgPSBvcHRpb25zLmNvbmVJbm5lckFuZ2xlO1xuXHQgICAgICAgIHRoaXMuX3Bhbm5lci5yZWZEaXN0YW5jZSA9IG9wdGlvbnMucmVmRGlzdGFuY2U7XG5cdCAgICAgICAgdGhpcy5fcGFubmVyLnJvbGxvZmZGYWN0b3IgPSBvcHRpb25zLnJvbGxvZmZGYWN0b3I7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgSG9sZHMgdGhlIGN1cnJlbnQgb3JpZW50YXRpb25cblx0XHRcdCAqICBAdHlwZSAge0FycmF5fVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9vcmllbnRhdGlvbiA9IFtcblx0ICAgICAgICAgICAgb3B0aW9ucy5vcmllbnRhdGlvblgsXG5cdCAgICAgICAgICAgIG9wdGlvbnMub3JpZW50YXRpb25ZLFxuXHQgICAgICAgICAgICBvcHRpb25zLm9yaWVudGF0aW9uWlxuXHQgICAgICAgIF07XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgSG9sZHMgdGhlIGN1cnJlbnQgcG9zaXRpb25cblx0XHRcdCAqICBAdHlwZSAge0FycmF5fVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9wb3NpdGlvbiA9IFtcblx0ICAgICAgICAgICAgb3B0aW9ucy5wb3NpdGlvblgsXG5cdCAgICAgICAgICAgIG9wdGlvbnMucG9zaXRpb25ZLFxuXHQgICAgICAgICAgICBvcHRpb25zLnBvc2l0aW9uWlxuXHQgICAgICAgIF07XG5cdCAgICAgICAgLy8gc2V0IHRoZSBkZWZhdWx0IHBvc2l0aW9uL29yaWVudGF0aW9uXG5cdCAgICAgICAgdGhpcy5vcmllbnRhdGlvblggPSBvcHRpb25zLm9yaWVudGF0aW9uWDtcblx0ICAgICAgICB0aGlzLm9yaWVudGF0aW9uWSA9IG9wdGlvbnMub3JpZW50YXRpb25ZO1xuXHQgICAgICAgIHRoaXMub3JpZW50YXRpb25aID0gb3B0aW9ucy5vcmllbnRhdGlvblo7XG5cdCAgICAgICAgdGhpcy5wb3NpdGlvblggPSBvcHRpb25zLnBvc2l0aW9uWDtcblx0ICAgICAgICB0aGlzLnBvc2l0aW9uWSA9IG9wdGlvbnMucG9zaXRpb25ZO1xuXHQgICAgICAgIHRoaXMucG9zaXRpb25aID0gb3B0aW9ucy5wb3NpdGlvblo7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5QYW5uZXIzRCwgVG9uZS5BdWRpb05vZGUpO1xuXHQgICAgLyoqXG5cdFx0ICogIERlZmF1bHRzIGFjY29yZGluZyB0byB0aGUgc3BlY2lmaWNhdGlvblxuXHRcdCAqICBAc3RhdGljXG5cdFx0ICogIEBjb25zdFxuXHRcdCAqICBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqL1xuXHQgICAgVG9uZS5QYW5uZXIzRC5kZWZhdWx0cyA9IHtcblx0ICAgICAgICAncG9zaXRpb25YJzogMCxcblx0ICAgICAgICAncG9zaXRpb25ZJzogMCxcblx0ICAgICAgICAncG9zaXRpb25aJzogMCxcblx0ICAgICAgICAnb3JpZW50YXRpb25YJzogMCxcblx0ICAgICAgICAnb3JpZW50YXRpb25ZJzogMCxcblx0ICAgICAgICAnb3JpZW50YXRpb25aJzogMCxcblx0ICAgICAgICAncGFubmluZ01vZGVsJzogJ2VxdWFscG93ZXInLFxuXHQgICAgICAgICdtYXhEaXN0YW5jZSc6IDEwMDAwLFxuXHQgICAgICAgICdkaXN0YW5jZU1vZGVsJzogJ2ludmVyc2UnLFxuXHQgICAgICAgICdjb25lT3V0ZXJHYWluJzogMCxcblx0ICAgICAgICAnY29uZU91dGVyQW5nbGUnOiAzNjAsXG5cdCAgICAgICAgJ2NvbmVJbm5lckFuZ2xlJzogMzYwLFxuXHQgICAgICAgICdyZWZEaXN0YW5jZSc6IDEsXG5cdCAgICAgICAgJ3JvbGxvZmZGYWN0b3InOiAxXG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogVGhlIHJhbXAgdGltZSB3aGljaCBpcyBhcHBsaWVkIHRvIHRoZSBzZXRUYXJnZXRBdFRpbWVcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLlBhbm5lcjNELnByb3RvdHlwZS5fcmFtcFRpbWVDb25zdGFudCA9IDAuMDE7XG5cdCAgICAvKipcblx0XHQgKiAgU2V0cyB0aGUgcG9zaXRpb24gb2YgdGhlIHNvdXJjZSBpbiAzZCBzcGFjZS5cblx0XHQgKiAgQHBhcmFtICB7TnVtYmVyfSAgeFxuXHRcdCAqICBAcGFyYW0gIHtOdW1iZXJ9ICB5XG5cdFx0ICogIEBwYXJhbSAge051bWJlcn0gIHpcblx0XHQgKiAgQHJldHVybiB7VG9uZS5QYW5uZXIzRH0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5QYW5uZXIzRC5wcm90b3R5cGUuc2V0UG9zaXRpb24gPSBmdW5jdGlvbiAoeCwgeSwgeikge1xuXHQgICAgICAgIGlmICh0aGlzLl9wYW5uZXIucG9zaXRpb25YKSB7XG5cdCAgICAgICAgICAgIHZhciBub3cgPSB0aGlzLm5vdygpO1xuXHQgICAgICAgICAgICB0aGlzLl9wYW5uZXIucG9zaXRpb25YLnNldFRhcmdldEF0VGltZSh4LCBub3csIHRoaXMuX3JhbXBUaW1lQ29uc3RhbnQpO1xuXHQgICAgICAgICAgICB0aGlzLl9wYW5uZXIucG9zaXRpb25ZLnNldFRhcmdldEF0VGltZSh5LCBub3csIHRoaXMuX3JhbXBUaW1lQ29uc3RhbnQpO1xuXHQgICAgICAgICAgICB0aGlzLl9wYW5uZXIucG9zaXRpb25aLnNldFRhcmdldEF0VGltZSh6LCBub3csIHRoaXMuX3JhbXBUaW1lQ29uc3RhbnQpO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3Bhbm5lci5zZXRQb3NpdGlvbih4LCB5LCB6KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdGhpcy5fcG9zaXRpb24gPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBTZXRzIHRoZSBvcmllbnRhdGlvbiBvZiB0aGUgc291cmNlIGluIDNkIHNwYWNlLlxuXHRcdCAqICBAcGFyYW0gIHtOdW1iZXJ9ICB4XG5cdFx0ICogIEBwYXJhbSAge051bWJlcn0gIHlcblx0XHQgKiAgQHBhcmFtICB7TnVtYmVyfSAgelxuXHRcdCAqICBAcmV0dXJuIHtUb25lLlBhbm5lcjNEfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLlBhbm5lcjNELnByb3RvdHlwZS5zZXRPcmllbnRhdGlvbiA9IGZ1bmN0aW9uICh4LCB5LCB6KSB7XG5cdCAgICAgICAgaWYgKHRoaXMuX3Bhbm5lci5vcmllbnRhdGlvblgpIHtcblx0ICAgICAgICAgICAgdmFyIG5vdyA9IHRoaXMubm93KCk7XG5cdCAgICAgICAgICAgIHRoaXMuX3Bhbm5lci5vcmllbnRhdGlvblguc2V0VGFyZ2V0QXRUaW1lKHgsIG5vdywgdGhpcy5fcmFtcFRpbWVDb25zdGFudCk7XG5cdCAgICAgICAgICAgIHRoaXMuX3Bhbm5lci5vcmllbnRhdGlvblkuc2V0VGFyZ2V0QXRUaW1lKHksIG5vdywgdGhpcy5fcmFtcFRpbWVDb25zdGFudCk7XG5cdCAgICAgICAgICAgIHRoaXMuX3Bhbm5lci5vcmllbnRhdGlvblouc2V0VGFyZ2V0QXRUaW1lKHosIG5vdywgdGhpcy5fcmFtcFRpbWVDb25zdGFudCk7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgdGhpcy5fcGFubmVyLnNldE9yaWVudGF0aW9uKHgsIHksIHopO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB0aGlzLl9vcmllbnRhdGlvbiA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFRoZSB4IHBvc2l0aW9uIG9mIHRoZSBwYW5uZXIgb2JqZWN0LlxuXHRcdCAqICBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqICBAbWVtYmVyT2YgVG9uZS5QYW5uZXIzRCNcblx0XHQgKiAgQG5hbWUgcG9zaXRpb25YXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5QYW5uZXIzRC5wcm90b3R5cGUsICdwb3NpdGlvblgnLCB7XG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAocG9zKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3Bvc2l0aW9uWzBdID0gcG9zO1xuXHQgICAgICAgICAgICB0aGlzLnNldFBvc2l0aW9uLmFwcGx5KHRoaXMsIHRoaXMuX3Bvc2l0aW9uKTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fcG9zaXRpb25bMF07XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgVGhlIHkgcG9zaXRpb24gb2YgdGhlIHBhbm5lciBvYmplY3QuXG5cdFx0ICogIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogIEBtZW1iZXJPZiBUb25lLlBhbm5lcjNEI1xuXHRcdCAqICBAbmFtZSBwb3NpdGlvbllcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLlBhbm5lcjNELnByb3RvdHlwZSwgJ3Bvc2l0aW9uWScsIHtcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChwb3MpIHtcblx0ICAgICAgICAgICAgdGhpcy5fcG9zaXRpb25bMV0gPSBwb3M7XG5cdCAgICAgICAgICAgIHRoaXMuc2V0UG9zaXRpb24uYXBwbHkodGhpcywgdGhpcy5fcG9zaXRpb24pO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9wb3NpdGlvblsxXTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgeiBwb3NpdGlvbiBvZiB0aGUgcGFubmVyIG9iamVjdC5cblx0XHQgKiAgQHR5cGUge051bWJlcn1cblx0XHQgKiAgQG1lbWJlck9mIFRvbmUuUGFubmVyM0QjXG5cdFx0ICogIEBuYW1lIHBvc2l0aW9uWlxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuUGFubmVyM0QucHJvdG90eXBlLCAncG9zaXRpb25aJywge1xuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKHBvcykge1xuXHQgICAgICAgICAgICB0aGlzLl9wb3NpdGlvblsyXSA9IHBvcztcblx0ICAgICAgICAgICAgdGhpcy5zZXRQb3NpdGlvbi5hcHBseSh0aGlzLCB0aGlzLl9wb3NpdGlvbik7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Bvc2l0aW9uWzJdO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIFRoZSB4IG9yaWVudGF0aW9uIG9mIHRoZSBwYW5uZXIgb2JqZWN0LlxuXHRcdCAqICBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqICBAbWVtYmVyT2YgVG9uZS5QYW5uZXIzRCNcblx0XHQgKiAgQG5hbWUgb3JpZW50YXRpb25YXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5QYW5uZXIzRC5wcm90b3R5cGUsICdvcmllbnRhdGlvblgnLCB7XG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAocG9zKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX29yaWVudGF0aW9uWzBdID0gcG9zO1xuXHQgICAgICAgICAgICB0aGlzLnNldE9yaWVudGF0aW9uLmFwcGx5KHRoaXMsIHRoaXMuX29yaWVudGF0aW9uKTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fb3JpZW50YXRpb25bMF07XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgVGhlIHkgb3JpZW50YXRpb24gb2YgdGhlIHBhbm5lciBvYmplY3QuXG5cdFx0ICogIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogIEBtZW1iZXJPZiBUb25lLlBhbm5lcjNEI1xuXHRcdCAqICBAbmFtZSBvcmllbnRhdGlvbllcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLlBhbm5lcjNELnByb3RvdHlwZSwgJ29yaWVudGF0aW9uWScsIHtcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChwb3MpIHtcblx0ICAgICAgICAgICAgdGhpcy5fb3JpZW50YXRpb25bMV0gPSBwb3M7XG5cdCAgICAgICAgICAgIHRoaXMuc2V0T3JpZW50YXRpb24uYXBwbHkodGhpcywgdGhpcy5fb3JpZW50YXRpb24pO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9vcmllbnRhdGlvblsxXTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgeiBvcmllbnRhdGlvbiBvZiB0aGUgcGFubmVyIG9iamVjdC5cblx0XHQgKiAgQHR5cGUge051bWJlcn1cblx0XHQgKiAgQG1lbWJlck9mIFRvbmUuUGFubmVyM0QjXG5cdFx0ICogIEBuYW1lIG9yaWVudGF0aW9uWlxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuUGFubmVyM0QucHJvdG90eXBlLCAnb3JpZW50YXRpb25aJywge1xuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKHBvcykge1xuXHQgICAgICAgICAgICB0aGlzLl9vcmllbnRhdGlvblsyXSA9IHBvcztcblx0ICAgICAgICAgICAgdGhpcy5zZXRPcmllbnRhdGlvbi5hcHBseSh0aGlzLCB0aGlzLl9vcmllbnRhdGlvbik7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX29yaWVudGF0aW9uWzJdO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIFByb3h5IGEgcHJvcGVydHkgb24gdGhlIHBhbm5lciB0byBhbiBleHBvc2VkIHB1YmxpYyBwcm9wZXJ5XG5cdFx0ICogIEBwYXJhbSAge1N0cmluZ30gIHByb3Bcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuUGFubmVyM0QuX2FsaWFzUHJvcGVydHkgPSBmdW5jdGlvbiAocHJvcCkge1xuXHQgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLlBhbm5lcjNELnByb3RvdHlwZSwgcHJvcCwge1xuXHQgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX3Bhbm5lcltwcm9wXSA9IHZhbDtcblx0ICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcGFubmVyW3Byb3BdO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFRoZSBwYW5uaW5nIG1vZGVsLiBFaXRoZXIgXCJlcXVhbHBvd2VyXCIgb3IgXCJIUlRGXCIuXG5cdFx0ICogIEB0eXBlIHtTdHJpbmd9XG5cdFx0ICogIEBtZW1iZXJPZiBUb25lLlBhbm5lcjNEI1xuXHRcdCAqICBAbmFtZSBwYW5uaW5nTW9kZWxcblx0XHQgKi9cblx0ICAgIFRvbmUuUGFubmVyM0QuX2FsaWFzUHJvcGVydHkoJ3Bhbm5pbmdNb2RlbCcpO1xuXHQgICAgLyoqXG5cdFx0ICogIEEgcmVmZXJlbmNlIGRpc3RhbmNlIGZvciByZWR1Y2luZyB2b2x1bWUgYXMgc291cmNlIG1vdmUgZnVydGhlciBmcm9tIHRoZSBsaXN0ZW5lclxuXHRcdCAqICBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqICBAbWVtYmVyT2YgVG9uZS5QYW5uZXIzRCNcblx0XHQgKiAgQG5hbWUgcmVmRGlzdGFuY2Vcblx0XHQgKi9cblx0ICAgIFRvbmUuUGFubmVyM0QuX2FsaWFzUHJvcGVydHkoJ3JlZkRpc3RhbmNlJyk7XG5cdCAgICAvKipcblx0XHQgKiAgRGVzY3JpYmVzIGhvdyBxdWlja2x5IHRoZSB2b2x1bWUgaXMgcmVkdWNlZCBhcyBzb3VyY2UgbW92ZXMgYXdheSBmcm9tIGxpc3RlbmVyLlxuXHRcdCAqICBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqICBAbWVtYmVyT2YgVG9uZS5QYW5uZXIzRCNcblx0XHQgKiAgQG5hbWUgcm9sbG9mZkZhY3RvclxuXHRcdCAqL1xuXHQgICAgVG9uZS5QYW5uZXIzRC5fYWxpYXNQcm9wZXJ0eSgncm9sbG9mZkZhY3RvcicpO1xuXHQgICAgLyoqXG5cdFx0ICogIFRoZSBkaXN0YW5jZSBtb2RlbCB1c2VkIGJ5LCAgXCJsaW5lYXJcIiwgXCJpbnZlcnNlXCIsIG9yIFwiZXhwb25lbnRpYWxcIi5cblx0XHQgKiAgQHR5cGUge1N0cmluZ31cblx0XHQgKiAgQG1lbWJlck9mIFRvbmUuUGFubmVyM0QjXG5cdFx0ICogIEBuYW1lIGRpc3RhbmNlTW9kZWxcblx0XHQgKi9cblx0ICAgIFRvbmUuUGFubmVyM0QuX2FsaWFzUHJvcGVydHkoJ2Rpc3RhbmNlTW9kZWwnKTtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgYW5nbGUsIGluIGRlZ3JlZXMsIGluc2lkZSBvZiB3aGljaCB0aGVyZSB3aWxsIGJlIG5vIHZvbHVtZSByZWR1Y3Rpb25cblx0XHQgKiAgQHR5cGUge0RlZ3JlZXN9XG5cdFx0ICogIEBtZW1iZXJPZiBUb25lLlBhbm5lcjNEI1xuXHRcdCAqICBAbmFtZSBjb25lSW5uZXJBbmdsZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5QYW5uZXIzRC5fYWxpYXNQcm9wZXJ0eSgnY29uZUlubmVyQW5nbGUnKTtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgYW5nbGUsIGluIGRlZ3JlZXMsIG91dHNpZGUgb2Ygd2hpY2ggdGhlIHZvbHVtZSB3aWxsIGJlIHJlZHVjZWRcblx0XHQgKiAgdG8gYSBjb25zdGFudCB2YWx1ZSBvZiBjb25lT3V0ZXJHYWluXG5cdFx0ICogIEB0eXBlIHtEZWdyZWVzfVxuXHRcdCAqICBAbWVtYmVyT2YgVG9uZS5QYW5uZXIzRCNcblx0XHQgKiAgQG5hbWUgY29uZU91dGVyQW5nbGVcblx0XHQgKi9cblx0ICAgIFRvbmUuUGFubmVyM0QuX2FsaWFzUHJvcGVydHkoJ2NvbmVPdXRlckFuZ2xlJyk7XG5cdCAgICAvKipcblx0XHQgKiAgVGhlIGdhaW4gb3V0c2lkZSBvZiB0aGUgY29uZU91dGVyQW5nbGVcblx0XHQgKiAgQHR5cGUge0dhaW59XG5cdFx0ICogIEBtZW1iZXJPZiBUb25lLlBhbm5lcjNEI1xuXHRcdCAqICBAbmFtZSBjb25lT3V0ZXJHYWluXG5cdFx0ICovXG5cdCAgICBUb25lLlBhbm5lcjNELl9hbGlhc1Byb3BlcnR5KCdjb25lT3V0ZXJHYWluJyk7XG5cdCAgICAvKipcblx0XHQgKiAgVGhlIG1heGltdW0gZGlzdGFuY2UgYmV0d2VlbiBzb3VyY2UgYW5kIGxpc3RlbmVyLFxuXHRcdCAqICBhZnRlciB3aGljaCB0aGUgdm9sdW1lIHdpbGwgbm90IGJlIHJlZHVjZWQgYW55IGZ1cnRoZXIuXG5cdFx0ICogIEB0eXBlIHtQb3NpdGl2ZX1cblx0XHQgKiAgQG1lbWJlck9mIFRvbmUuUGFubmVyM0QjXG5cdFx0ICogIEBuYW1lIG1heERpc3RhbmNlXG5cdFx0ICovXG5cdCAgICBUb25lLlBhbm5lcjNELl9hbGlhc1Byb3BlcnR5KCdtYXhEaXN0YW5jZScpO1xuXHQgICAgLyoqXG5cdFx0ICogIENsZWFuIHVwLlxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5QYW5uZXIzRH0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5QYW5uZXIzRC5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLkF1ZGlvTm9kZS5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuX3Bhbm5lci5kaXNjb25uZWN0KCk7XG5cdCAgICAgICAgdGhpcy5fcGFubmVyID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9vcmllbnRhdGlvbiA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fcG9zaXRpb24gPSBudWxsO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLlBhbm5lcjNEO1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgVG9uZS5QYW5Wb2wgaXMgYSBUb25lLlBhbm5lciBhbmQgVG9uZS5Wb2x1bWUgaW4gb25lLlxuXHRcdCAqXG5cdFx0ICogIEBleHRlbmRzIHtUb25lLkF1ZGlvTm9kZX1cblx0XHQgKiAgQGNvbnN0cnVjdG9yXG5cdFx0ICogIEBwYXJhbSB7QXVkaW9SYW5nZX0gcGFuIHRoZSBpbml0aWFsIHBhblxuXHRcdCAqICBAcGFyYW0ge251bWJlcn0gdm9sdW1lIFRoZSBvdXRwdXQgdm9sdW1lLlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIC8vcGFuIHRoZSBpbmNvbWluZyBzaWduYWwgbGVmdCBhbmQgZHJvcCB0aGUgdm9sdW1lXG5cdFx0ICogdmFyIHBhblZvbCA9IG5ldyBUb25lLlBhblZvbCgtMC4yNSwgLTEyKTtcblx0XHQgKi9cblx0ICAgIFRvbmUuUGFuVm9sID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBvcHRpb25zID0gVG9uZS5kZWZhdWx0cyhhcmd1bWVudHMsIFtcblx0ICAgICAgICAgICAgJ3BhbicsXG5cdCAgICAgICAgICAgICd2b2x1bWUnXG5cdCAgICAgICAgXSwgVG9uZS5QYW5Wb2wpO1xuXHQgICAgICAgIFRvbmUuQXVkaW9Ob2RlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIHBhbm5pbmcgbm9kZVxuXHRcdFx0ICogIEB0eXBlIHtUb25lLlBhbm5lcn1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fcGFubmVyID0gdGhpcy5pbnB1dCA9IG5ldyBUb25lLlBhbm5lcihvcHRpb25zLnBhbik7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIEwvUiBwYW5uaW5nIGNvbnRyb2wuXG5cdFx0XHQgKiAgQHR5cGUge0F1ZGlvUmFuZ2V9XG5cdFx0XHQgKiAgQHNpZ25hbFxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5wYW4gPSB0aGlzLl9wYW5uZXIucGFuO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSB2b2x1bWUgbm9kZVxuXHRcdFx0ICogIEB0eXBlIHtUb25lLlZvbHVtZX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fdm9sdW1lID0gdGhpcy5vdXRwdXQgPSBuZXcgVG9uZS5Wb2x1bWUob3B0aW9ucy52b2x1bWUpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSB2b2x1bWUgY29udHJvbCBpbiBkZWNpYmVscy5cblx0XHRcdCAqICBAdHlwZSB7RGVjaWJlbHN9XG5cdFx0XHQgKiAgQHNpZ25hbFxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy52b2x1bWUgPSB0aGlzLl92b2x1bWUudm9sdW1lO1xuXHQgICAgICAgIC8vY29ubmVjdGlvbnNcblx0ICAgICAgICB0aGlzLl9wYW5uZXIuY29ubmVjdCh0aGlzLl92b2x1bWUpO1xuXHQgICAgICAgIHRoaXMubXV0ZSA9IG9wdGlvbnMubXV0ZTtcblx0ICAgICAgICB0aGlzLl9yZWFkT25seShbXG5cdCAgICAgICAgICAgICdwYW4nLFxuXHQgICAgICAgICAgICAndm9sdW1lJ1xuXHQgICAgICAgIF0pO1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuUGFuVm9sLCBUb25lLkF1ZGlvTm9kZSk7XG5cdCAgICAvKipcblx0XHQgKiAgVGhlIGRlZmF1bHRzXG5cdFx0ICogIEB0eXBlICB7T2JqZWN0fVxuXHRcdCAqICBAY29uc3Rcblx0XHQgKiAgQHN0YXRpY1xuXHRcdCAqL1xuXHQgICAgVG9uZS5QYW5Wb2wuZGVmYXVsdHMgPSB7XG5cdCAgICAgICAgJ3Bhbic6IDAsXG5cdCAgICAgICAgJ3ZvbHVtZSc6IDAsXG5cdCAgICAgICAgJ211dGUnOiBmYWxzZVxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqIE11dGUvdW5tdXRlIHRoZSB2b2x1bWVcblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5QYW5Wb2wjXG5cdFx0ICogQG5hbWUgbXV0ZVxuXHRcdCAqIEB0eXBlIHtCb29sZWFufVxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuUGFuVm9sLnByb3RvdHlwZSwgJ211dGUnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl92b2x1bWUubXV0ZTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKG11dGUpIHtcblx0ICAgICAgICAgICAgdGhpcy5fdm9sdW1lLm11dGUgPSBtdXRlO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIGNsZWFuIHVwXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLlBhblZvbH0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5QYW5Wb2wucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5BdWRpb05vZGUucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLl93cml0YWJsZShbXG5cdCAgICAgICAgICAgICdwYW4nLFxuXHQgICAgICAgICAgICAndm9sdW1lJ1xuXHQgICAgICAgIF0pO1xuXHQgICAgICAgIHRoaXMuX3Bhbm5lci5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fcGFubmVyID0gbnVsbDtcblx0ICAgICAgICB0aGlzLnBhbiA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fdm9sdW1lLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl92b2x1bWUgPSBudWxsO1xuXHQgICAgICAgIHRoaXMudm9sdW1lID0gbnVsbDtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVG9uZS5QYW5Wb2w7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgVG9uZS5Tb2xvIGxldHMgeW91IGlzb2xhdGUgYSBzcGVjaWZpYyBhdWRpbyBzdHJlYW0uIFdoZW5cblx0XHQgKiAgICAgICAgIGFuIGluc3RhbmNlIGlzIHNldCB0byBgc29sbz10cnVlYCwgaXQgd2lsbCBtdXRlIGFsbCBvdGhlciBpbnN0YW5jZXMuXG5cdFx0ICogIEBleHRlbmRzIHtUb25lLkF1ZGlvTm9kZX1cblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiB2YXIgc29sb0EgPSBuZXcgVG9uZS5Tb2xvKClcblx0XHQgKiB2YXIgc29sb0IgPSBuZXcgVG9uZS5Tb2xvKClcblx0XHQgKiBzb2xvQS5zb2xvID0gdHJ1ZVxuXHRcdCAqIC8vbm8gYXVkaW8gd2lsbCBwYXNzIHRocm91Z2ggc29sb0Jcblx0XHQgKi9cblx0ICAgIFRvbmUuU29sbyA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgb3B0aW9ucyA9IFRvbmUuZGVmYXVsdHMoYXJndW1lbnRzLCBbJ3NvbG8nXSwgVG9uZS5Tb2xvKTtcblx0ICAgICAgICBUb25lLkF1ZGlvTm9kZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBpbnB1dCBhbmQgb3V0cHV0IG5vZGVcblx0XHRcdCAqICBAdHlwZSAge1RvbmUuR2Fpbn1cblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuaW5wdXQgPSB0aGlzLm91dHB1dCA9IG5ldyBUb25lLkdhaW4oKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBBIGJvdW5kIF9zb2xvZWQgbWV0aG9kXG5cdFx0XHQgKiAgQHR5cGUgIHtGdW5jdGlvbn1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fc29sb0JpbmQgPSB0aGlzLl9zb2xvZWQuYmluZCh0aGlzKTtcblx0ICAgICAgICAvL2xpc3RlbiBmb3Igc29sbyBldmVudHMgY2xhc3Mtd2lkZS5cblx0ICAgICAgICB0aGlzLmNvbnRleHQub24oJ3NvbG8nLCB0aGlzLl9zb2xvQmluZCk7XG5cdCAgICAgICAgLy9zZXQgaW5pdGlhbGx5XG5cdCAgICAgICAgdGhpcy5zb2xvID0gb3B0aW9ucy5zb2xvO1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuU29sbywgVG9uZS5BdWRpb05vZGUpO1xuXHQgICAgLyoqXG5cdFx0ICogIFRoZSBkZWZhdWx0c1xuXHRcdCAqICBAdHlwZSAge09iamVjdH1cblx0XHQgKiAgQHN0YXRpY1xuXHRcdCAqL1xuXHQgICAgVG9uZS5Tb2xvLmRlZmF1bHRzID0geyBzb2xvOiBmYWxzZSB9O1xuXHQgICAgLyoqXG5cdFx0ICogIElzb2xhdGVzIHRoaXMgaW5zdGFuY2UgYW5kIG11dGVzIGFsbCBvdGhlciBpbnN0YW5jZXMgb2YgVG9uZS5Tb2xvLlxuXHRcdCAqICBPbmx5IG9uZSBpbnN0YW5jZSBjYW4gYmUgc29sb2VkIGF0IGEgdGltZS4gQSBzb2xvZWRcblx0XHQgKiAgaW5zdGFuY2Ugd2lsbCByZXBvcnQgYHNvbG89ZmFsc2VgIHdoZW4gYW5vdGhlciBpbnN0YW5jZSBpcyBzb2xvZWQuXG5cdFx0ICogIEBtZW1iZXJPZiBUb25lLlNvbG8jXG5cdFx0ICogIEB0eXBlIHtCb29sZWFufVxuXHRcdCAqICBAbmFtZSBzb2xvXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5Tb2xvLnByb3RvdHlwZSwgJ3NvbG8nLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9pc1NvbG9lZCgpO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAoc29sbykge1xuXHQgICAgICAgICAgICBpZiAoc29sbykge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fYWRkU29sbygpO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fcmVtb3ZlU29sbygpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHRoaXMuY29udGV4dC5lbWl0KCdzb2xvJywgdGhpcyk7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgSWYgdGhlIGN1cnJlbnQgaW5zdGFuY2UgaXMgbXV0ZWQsIGkuZS4gYW5vdGhlciBpbnN0YW5jZSBpcyBzb2xvZWRcblx0XHQgKiAgQG1lbWJlck9mIFRvbmUuU29sbyNcblx0XHQgKiAgQHR5cGUge0Jvb2xlYW59XG5cdFx0ICogIEBuYW1lIG11dGVkXG5cdFx0ICogIEByZWFkT25seVxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuU29sby5wcm90b3R5cGUsICdtdXRlZCcsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5wdXQuZ2Fpbi52YWx1ZSA9PT0gMDtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqIEFkZCB0aGlzIHRvIHRoZSBzb2xvZWQgYXJyYXlcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5Tb2xvLnByb3RvdHlwZS5fYWRkU29sbyA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBpZiAoIVRvbmUuaXNBcnJheSh0aGlzLmNvbnRleHQuX2N1cnJlbnRTb2xvKSkge1xuXHQgICAgICAgICAgICB0aGlzLmNvbnRleHQuX2N1cnJlbnRTb2xvID0gW107XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmICghdGhpcy5faXNTb2xvZWQoKSkge1xuXHQgICAgICAgICAgICB0aGlzLmNvbnRleHQuX2N1cnJlbnRTb2xvLnB1c2godGhpcyk7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqIFJlbW92ZSB0aGlzIGZyb20gdGhlIHNvbG9lZCBhcnJheVxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLlNvbG8ucHJvdG90eXBlLl9yZW1vdmVTb2xvID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIGlmICh0aGlzLl9pc1NvbG9lZCgpKSB7XG5cdCAgICAgICAgICAgIHZhciBpbmRleCA9IHRoaXMuY29udGV4dC5fY3VycmVudFNvbG8uaW5kZXhPZih0aGlzKTtcblx0ICAgICAgICAgICAgdGhpcy5jb250ZXh0Ll9jdXJyZW50U29sby5zcGxpY2UoaW5kZXgsIDEpO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiBAcmV0dXJuIHtCb29sZWFufSBJcyB0aGlzIG9uIHRoZSBzb2xvZWQgYXJyYXlcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5Tb2xvLnByb3RvdHlwZS5faXNTb2xvZWQgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgaWYgKFRvbmUuaXNBcnJheSh0aGlzLmNvbnRleHQuX2N1cnJlbnRTb2xvKSkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5jb250ZXh0Ll9jdXJyZW50U29sby5sZW5ndGggIT09IDAgJiYgdGhpcy5jb250ZXh0Ll9jdXJyZW50U29sby5pbmRleE9mKHRoaXMpICE9PSAtMTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqIEByZXR1cm4ge0Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiBubyBvbmUgaXMgc29sb2VkXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuU29sby5wcm90b3R5cGUuX25vU29sb3MgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgcmV0dXJuICFUb25lLmlzQXJyYXkodGhpcy5jb250ZXh0Ll9jdXJyZW50U29sbykgfHwgdGhpcy5jb250ZXh0Ll9jdXJyZW50U29sby5sZW5ndGggPT09IDA7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFNvbG8gdGhlIGN1cnJlbnQgaW5zdGFuY2UgYW5kIHVuc29sbyBhbGwgb3RoZXIgaW5zdGFuY2VzLlxuXHRcdCAqICBAcGFyYW0gIHtUb25lLlNvbG99ICBpbnN0YW5jZSAgVGhlIGluc3RhbmNlIHdoaWNoIGlzIGJlaW5nIHNvbG9lZC91bnNvbG9lZC5cblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuU29sby5wcm90b3R5cGUuX3NvbG9lZCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBpZiAodGhpcy5faXNTb2xvZWQoKSkge1xuXHQgICAgICAgICAgICB0aGlzLmlucHV0LmdhaW4udmFsdWUgPSAxO1xuXHQgICAgICAgIH0gZWxzZSBpZiAodGhpcy5fbm9Tb2xvcygpKSB7XG5cdCAgICAgICAgICAgIC8vbm8gb25lIGlzIHNvbG9lZFxuXHQgICAgICAgICAgICB0aGlzLmlucHV0LmdhaW4udmFsdWUgPSAxO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIHRoaXMuaW5wdXQuZ2Fpbi52YWx1ZSA9IDA7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBDbGVhbiB1cFxuXHRcdCAqICBAcmV0dXJuICB7VG9uZS5Tb2xvfSAgdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5Tb2xvLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHRoaXMuY29udGV4dC5vZmYoJ3NvbG8nLCB0aGlzLl9zb2xvQmluZCk7XG5cdCAgICAgICAgdGhpcy5fcmVtb3ZlU29sbygpO1xuXHQgICAgICAgIHRoaXMuX3NvbG9CaW5kID0gbnVsbDtcblx0ICAgICAgICBUb25lLkF1ZGlvTm9kZS5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLlNvbG87XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyBUb25lLkN0cmxJbnRlcnBvbGF0ZSB3aWxsIGludGVycG9sYXRlIGJldHdlZW4gZ2l2ZW4gdmFsdWVzIGJhc2VkXG5cdFx0ICogICAgICAgICBvbiB0aGUgXCJpbmRleFwiIHByb3BlcnR5LiBQYXNzaW5nIGluIGFuIGFycmF5IG9yIG9iamVjdCBsaXRlcmFsXG5cdFx0ICogICAgICAgICB3aWxsIGludGVycG9sYXRlIGVhY2ggb2YgdGhlIHBhcmFtZXRlcnMuIE5vdGUgKGkuZS4gXCJDM1wiKVxuXHRcdCAqICAgICAgICAgYW5kIFRpbWUgKGkuZS4gXCI0biArIDJcIikgY2FuIGJlIGludGVycG9sYXRlZC4gQWxsIG90aGVyIHZhbHVlcyBhcmVcblx0XHQgKiAgICAgICAgIGFzc3VtZWQgdG8gYmUgbnVtYmVycy4gXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogdmFyIGludGVycCA9IG5ldyBUb25lLkN0cmxJbnRlcnBvbGF0ZShbMCwgMiwgOSwgNF0pO1xuXHRcdCAqIGludGVycC5pbmRleCA9IDAuNzU7XG5cdFx0ICogaW50ZXJwLnZhbHVlOyAvL3JldHVybnMgMS41XG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiB2YXIgaW50ZXJwID0gbmV3IFRvbmUuQ3RybEludGVycG9sYXRlKFtcblx0XHQgKiBcdFsyLCA0LCA1XSxcblx0XHQgKiBcdFs5LCAzLCAyXSxcblx0XHQgKiBdKTtcblx0XHQgKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIGFycmF5IG9mIHZhbHVlcyB0byBpbnRlcnBvbGF0ZSBvdmVyXG5cdFx0ICogQHBhcmFtIHtQb3NpdGl2ZX0gaW5kZXggVGhlIGluaXRpYWwgaW50ZXJwb2xhdGlvbiBpbmRleC5cblx0XHQgKiBAZXh0ZW5kcyB7VG9uZX1cblx0XHQgKi9cblx0ICAgIFRvbmUuQ3RybEludGVycG9sYXRlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBvcHRpb25zID0gVG9uZS5kZWZhdWx0cyhhcmd1bWVudHMsIFtcblx0ICAgICAgICAgICAgJ3ZhbHVlcycsXG5cdCAgICAgICAgICAgICdpbmRleCdcblx0ICAgICAgICBdLCBUb25lLkN0cmxJbnRlcnBvbGF0ZSk7XG5cdCAgICAgICAgVG9uZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSB2YWx1ZXMgdG8gaW50ZXJwb2xhdGUgYmV0d2VlblxuXHRcdFx0ICogIEB0eXBlICB7QXJyYXl9XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLnZhbHVlcyA9IG9wdGlvbnMudmFsdWVzO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBpbnRlcnBvbGF0ZWQgaW5kZXggYmV0d2VlbiB2YWx1ZXMuIEZvciBleGFtcGxlOiBhIHZhbHVlIG9mIDEuNVxuXHRcdFx0ICogIHdvdWxkIGludGVycG9sYXRlIGVxdWFsbHkgYmV0d2VlbiB0aGUgdmFsdWUgYXQgaW5kZXggMVxuXHRcdFx0ICogIGFuZCB0aGUgdmFsdWUgYXQgaW5kZXggMi4gXG5cdFx0XHQgKiAgQGV4YW1wbGVcblx0XHRcdCAqIGludGVycC5pbmRleCA9IDA7IFxuXHRcdFx0ICogaW50ZXJwLnZhbHVlOyAvL3JldHVybnMgdGhlIHZhbHVlIGF0IDBcblx0XHRcdCAqIGludGVycC5pbmRleCA9IDAuNTtcblx0XHRcdCAqIGludGVycC52YWx1ZTsgLy9yZXR1cm5zIHRoZSB2YWx1ZSBiZXR3ZWVuIGluZGljZXMgMCBhbmQgMS4gXG5cdFx0XHQgKiAgQHR5cGUgIHtQb3NpdGl2ZX1cblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuaW5kZXggPSBvcHRpb25zLmluZGV4O1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuQ3RybEludGVycG9sYXRlKTtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgZGVmYXVsdHNcblx0XHQgKiAgQGNvbnN0XG5cdFx0ICogIEB0eXBlICB7T2JqZWN0fVxuXHRcdCAqL1xuXHQgICAgVG9uZS5DdHJsSW50ZXJwb2xhdGUuZGVmYXVsdHMgPSB7XG5cdCAgICAgICAgJ2luZGV4JzogMCxcblx0ICAgICAgICAndmFsdWVzJzogW11cblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgVGhlIGN1cnJlbnQgaW50ZXJwb2xhdGVkIHZhbHVlIGJhc2VkIG9uIHRoZSBpbmRleFxuXHRcdCAqICBAcmVhZE9ubHlcblx0XHQgKiAgQG1lbWJlck9mIFRvbmUuQ3RybEludGVycG9sYXRlI1xuXHRcdCAqICBAdHlwZSB7Kn1cblx0XHQgKiAgQG5hbWUgdmFsdWVcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkN0cmxJbnRlcnBvbGF0ZS5wcm90b3R5cGUsICd2YWx1ZScsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5pbmRleDtcblx0ICAgICAgICAgICAgaW5kZXggPSBNYXRoLm1pbihpbmRleCwgdGhpcy52YWx1ZXMubGVuZ3RoIC0gMSk7XG5cdCAgICAgICAgICAgIHZhciBsb3dlclBvc2l0aW9uID0gTWF0aC5mbG9vcihpbmRleCk7XG5cdCAgICAgICAgICAgIHZhciBsb3dlciA9IHRoaXMudmFsdWVzW2xvd2VyUG9zaXRpb25dO1xuXHQgICAgICAgICAgICB2YXIgdXBwZXIgPSB0aGlzLnZhbHVlc1tNYXRoLmNlaWwoaW5kZXgpXTtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ludGVycG9sYXRlKGluZGV4IC0gbG93ZXJQb3NpdGlvbiwgbG93ZXIsIHVwcGVyKTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBJbnRlcm5hbCBpbnRlcnBvbGF0aW9uIHJvdXRpbmVcblx0XHQgKiAgQHBhcmFtICB7Tm9ybWFsUmFuZ2V9ICBpbmRleCAgVGhlIGluZGV4IGJldHdlZW4gdGhlIGxvd2VyIGFuZCB1cHBlclxuXHRcdCAqICBAcGFyYW0gIHsqfSAgbG93ZXIgXG5cdFx0ICogIEBwYXJhbSAgeyp9ICB1cHBlciBcblx0XHQgKiAgQHJldHVybiAgeyp9ICBUaGUgaW50ZXJwb2xhdGVkIHZhbHVlXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLkN0cmxJbnRlcnBvbGF0ZS5wcm90b3R5cGUuX2ludGVycG9sYXRlID0gZnVuY3Rpb24gKGluZGV4LCBsb3dlciwgdXBwZXIpIHtcblx0ICAgICAgICBpZiAoVG9uZS5pc0FycmF5KGxvd2VyKSkge1xuXHQgICAgICAgICAgICB2YXIgcmV0QXJyYXkgPSBbXTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsb3dlci5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgcmV0QXJyYXlbaV0gPSB0aGlzLl9pbnRlcnBvbGF0ZShpbmRleCwgbG93ZXJbaV0sIHVwcGVyW2ldKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gcmV0QXJyYXk7XG5cdCAgICAgICAgfSBlbHNlIGlmIChUb25lLmlzT2JqZWN0KGxvd2VyKSkge1xuXHQgICAgICAgICAgICB2YXIgcmV0T2JqID0ge307XG5cdCAgICAgICAgICAgIGZvciAodmFyIGF0dHIgaW4gbG93ZXIpIHtcblx0ICAgICAgICAgICAgICAgIHJldE9ialthdHRyXSA9IHRoaXMuX2ludGVycG9sYXRlKGluZGV4LCBsb3dlclthdHRyXSwgdXBwZXJbYXR0cl0pO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiByZXRPYmo7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgbG93ZXIgPSB0aGlzLl90b051bWJlcihsb3dlcik7XG5cdCAgICAgICAgICAgIHVwcGVyID0gdGhpcy5fdG9OdW1iZXIodXBwZXIpO1xuXHQgICAgICAgICAgICByZXR1cm4gKDEgLSBpbmRleCkgKiBsb3dlciArIGluZGV4ICogdXBwZXI7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBDb252ZXJ0IGZyb20gdGhlIGdpdmVuIHR5cGUgaW50byBhIG51bWJlclxuXHRcdCAqICBAcGFyYW0gIHtOdW1iZXJ8U3RyaW5nfSAgdmFsdWVcblx0XHQgKiAgQHJldHVybiAge051bWJlcn1cblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuQ3RybEludGVycG9sYXRlLnByb3RvdHlwZS5fdG9OdW1iZXIgPSBmdW5jdGlvbiAodmFsKSB7XG5cdCAgICAgICAgaWYgKFRvbmUuaXNOdW1iZXIodmFsKSkge1xuXHQgICAgICAgICAgICByZXR1cm4gdmFsO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIC8vb3RoZXJ3aXNlIGFzc3VtZSB0aGF0IGl0J3MgVGltZS4uLlxuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy50b1NlY29uZHModmFsKTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIENsZWFuIHVwXG5cdFx0ICogIEByZXR1cm4gIHtUb25lLkN0cmxJbnRlcnBvbGF0ZX0gIHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuQ3RybEludGVycG9sYXRlLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHRoaXMudmFsdWVzID0gbnVsbDtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVG9uZS5DdHJsSW50ZXJwb2xhdGU7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyBUb25lLkN0cmxNYXJrb3YgcmVwcmVzZW50cyBhIE1hcmtvdiBDaGFpbiB3aGVyZSBlYWNoIGNhbGxcblx0XHQgKiAgICAgICAgIHRvIFRvbmUuQ3RybE1hcmtvdi5uZXh0IHdpbGwgbW92ZSB0byB0aGUgbmV4dCBzdGF0ZS4gSWYgdGhlIG5leHRcblx0XHQgKiAgICAgICAgIHN0YXRlIGNob2ljZSBpcyBhbiBhcnJheSwgdGhlIG5leHQgc3RhdGUgaXMgY2hvc2VuIHJhbmRvbWx5IHdpdGhcblx0XHQgKiAgICAgICAgIGV2ZW4gcHJvYmFiaWxpdHkgZm9yIGFsbCBvZiB0aGUgY2hvaWNlcy4gRm9yIGEgd2VpZ2h0ZWQgcHJvYmFiaWxpdHlcblx0XHQgKiAgICAgICAgIG9mIHRoZSBuZXh0IGNob2ljZXMsIHBhc3MgaW4gYW4gb2JqZWN0IHdpdGggXCJzdGF0ZVwiIGFuZCBcInByb2JhYmlsaXR5XCIgYXR0cmlidXRlcy4gXG5cdFx0ICogICAgICAgICBUaGUgcHJvYmFiaWxpdGllcyB3aWxsIGJlIG5vcm1hbGl6ZWQgYW5kIHRoZW4gY2hvc2VuLiBJZiBubyBuZXh0IG9wdGlvbnNcblx0XHQgKiAgICAgICAgIGFyZSBnaXZlbiBmb3IgdGhlIGN1cnJlbnQgc3RhdGUsIHRoZSBzdGF0ZSB3aWxsIHN0YXkgdGhlcmUuIFxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZX1cblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiB2YXIgY2hhaW4gPSBuZXcgVG9uZS5DdHJsTWFya292KHtcblx0XHQgKiBcdFwiYmVnaW5uaW5nXCIgOiBbXCJlbmRcIiwgXCJtaWRkbGVcIl0sXG5cdFx0ICogXHRcIm1pZGRsZVwiIDogXCJlbmRcIlxuXHRcdCAqIH0pO1xuXHRcdCAqIGNoYWluLnZhbHVlID0gXCJiZWdpbm5pbmdcIjtcblx0XHQgKiBjaGFpbi5uZXh0KCk7IC8vcmV0dXJucyBcImVuZFwiIG9yIFwibWlkZGxlXCIgd2l0aCA1MCUgcHJvYmFiaWxpdHlcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIHZhciBjaGFpbiA9IG5ldyBUb25lLkN0cmxNYXJrb3Yoe1xuXHRcdCAqIFx0XCJiZWdpbm5pbmdcIiA6IFt7XCJ2YWx1ZVwiIDogXCJlbmRcIiwgXCJwcm9iYWJpbGl0eVwiIDogMC44fSwgXG5cdFx0ICogXHRcdFx0XHRcdHtcInZhbHVlXCIgOiBcIm1pZGRsZVwiLCBcInByb2JhYmlsaXR5XCIgOiAwLjJ9XSxcblx0XHQgKiBcdFwibWlkZGxlXCIgOiBcImVuZFwiXG5cdFx0ICogfSk7XG5cdFx0ICogY2hhaW4udmFsdWUgPSBcImJlZ2lubmluZ1wiO1xuXHRcdCAqIGNoYWluLm5leHQoKTsgLy9yZXR1cm5zIFwiZW5kXCIgd2l0aCA4MCUgcHJvYmFiaWxpdHkgb3IgXCJtaWRkbGVcIiB3aXRoIDIwJS5cblx0XHQgKiAgQHBhcmFtIHtPYmplY3R9IHZhbHVlcyBBbiBvYmplY3Qgd2l0aCB0aGUgc3RhdGUgbmFtZXMgYXMgdGhlIGtleXNcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICBhbmQgdGhlIG5leHQgc3RhdGUocykgYXMgdGhlIHZhbHVlcy4gXG5cdFx0ICovXG5cdCAgICBUb25lLkN0cmxNYXJrb3YgPSBmdW5jdGlvbiAodmFsdWVzLCBpbml0aWFsKSB7XG5cdCAgICAgICAgVG9uZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBNYXJrb3YgdmFsdWVzIHdpdGggc3RhdGVzIGFzIHRoZSBrZXlzXG5cdFx0XHQgKiAgYW5kIG5leHQgc3RhdGUocykgYXMgdGhlIHZhbHVlcy4gXG5cdFx0XHQgKiAgQHR5cGUge09iamVjdH1cblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMudmFsdWVzID0gVG9uZS5kZWZhdWx0QXJnKHZhbHVlcywge30pO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBNYXJrb3YgdmFsdWVzLiBUaGUgbmV4dFxuXHRcdFx0ICogIHN0YXRlIHdpbGwgYmUgZXZhbHVhdGVkIGFuZCByZXR1cm5lZCB3aGVuIFRvbmUuQ3RybE1hcmtvdi5uZXh0XG5cdFx0XHQgKiAgaXMgaW52b2tlZC5cblx0XHRcdCAqICBAdHlwZSB7U3RyaW5nfVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy52YWx1ZSA9IFRvbmUuZGVmYXVsdEFyZyhpbml0aWFsLCBPYmplY3Qua2V5cyh0aGlzLnZhbHVlcylbMF0pO1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuQ3RybE1hcmtvdik7XG5cdCAgICAvKipcblx0XHQgKiAgUmV0dXJucyB0aGUgbmV4dCBzdGF0ZSBvZiB0aGUgTWFya292IHZhbHVlcy4gXG5cdFx0ICogIEByZXR1cm4gIHtTdHJpbmd9XG5cdFx0ICovXG5cdCAgICBUb25lLkN0cmxNYXJrb3YucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgaWYgKHRoaXMudmFsdWVzLmhhc093blByb3BlcnR5KHRoaXMudmFsdWUpKSB7XG5cdCAgICAgICAgICAgIHZhciBuZXh0ID0gdGhpcy52YWx1ZXNbdGhpcy52YWx1ZV07XG5cdCAgICAgICAgICAgIGlmIChUb25lLmlzQXJyYXkobmV4dCkpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBkaXN0cmlidXRpb24gPSB0aGlzLl9nZXRQcm9iRGlzdHJpYnV0aW9uKG5leHQpO1xuXHQgICAgICAgICAgICAgICAgdmFyIHJhbmQgPSBNYXRoLnJhbmRvbSgpO1xuXHQgICAgICAgICAgICAgICAgdmFyIHRvdGFsID0gMDtcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlzdHJpYnV0aW9uLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGRpc3QgPSBkaXN0cmlidXRpb25baV07XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHJhbmQgPiB0b3RhbCAmJiByYW5kIDwgdG90YWwgKyBkaXN0KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjaG9zZW4gPSBuZXh0W2ldO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoVG9uZS5pc09iamVjdChjaG9zZW4pKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gY2hvc2VuLnZhbHVlO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IGNob3Nlbjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICB0b3RhbCArPSBkaXN0O1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IG5leHQ7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIENob29zZSByYW5kb21seSBmcm9tIGFuIGFycmF5IHdlaWdodGVkIG9wdGlvbnMgaW4gdGhlIGZvcm0gXG5cdFx0ICogIHtcInN0YXRlXCIgOiBzdHJpbmcsIFwicHJvYmFiaWxpdHlcIiA6IG51bWJlcn0gb3IgYW4gYXJyYXkgb2YgdmFsdWVzXG5cdFx0ICogIEBwYXJhbSAge0FycmF5fSAgb3B0aW9ucyBcblx0XHQgKiAgQHJldHVybiAge0FycmF5fSAgVGhlIHJhbmRvbWx5IHNlbGVjdGVkIGNob2ljZVxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5DdHJsTWFya292LnByb3RvdHlwZS5fZ2V0UHJvYkRpc3RyaWJ1dGlvbiA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG5cdCAgICAgICAgdmFyIGRpc3RyaWJ1dGlvbiA9IFtdO1xuXHQgICAgICAgIHZhciB0b3RhbCA9IDA7XG5cdCAgICAgICAgdmFyIG5lZWRzTm9ybWFsaXppbmcgPSBmYWxzZTtcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9wdGlvbnMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgdmFyIG9wdGlvbiA9IG9wdGlvbnNbaV07XG5cdCAgICAgICAgICAgIGlmIChUb25lLmlzT2JqZWN0KG9wdGlvbikpIHtcblx0ICAgICAgICAgICAgICAgIG5lZWRzTm9ybWFsaXppbmcgPSB0cnVlO1xuXHQgICAgICAgICAgICAgICAgZGlzdHJpYnV0aW9uW2ldID0gb3B0aW9uLnByb2JhYmlsaXR5O1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgZGlzdHJpYnV0aW9uW2ldID0gMSAvIG9wdGlvbnMubGVuZ3RoO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHRvdGFsICs9IGRpc3RyaWJ1dGlvbltpXTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKG5lZWRzTm9ybWFsaXppbmcpIHtcblx0ICAgICAgICAgICAgLy9ub3JtYWxpemUgdGhlIHZhbHVlc1xuXHQgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGRpc3RyaWJ1dGlvbi5sZW5ndGg7IGorKykge1xuXHQgICAgICAgICAgICAgICAgZGlzdHJpYnV0aW9uW2pdID0gZGlzdHJpYnV0aW9uW2pdIC8gdG90YWw7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIGRpc3RyaWJ1dGlvbjtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgQ2xlYW4gdXBcblx0XHQgKiAgQHJldHVybiAge1RvbmUuQ3RybE1hcmtvdn0gIHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuQ3RybE1hcmtvdi5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB0aGlzLnZhbHVlcyA9IG51bGw7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuQ3RybE1hcmtvdjtcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgXG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzIEdlbmVyYXRlIHBhdHRlcm5zIGZyb20gYW4gYXJyYXkgb2YgdmFsdWVzLlxuXHRcdCAqICAgICAgICAgSGFzIGEgbnVtYmVyIG9mIGFycGVnZ2lhdGlvbiBhbmQgcmFuZG9taXplZFxuXHRcdCAqICAgICAgICAgc2VsZWN0aW9uIHBhdHRlcm5zLiBcblx0XHQgKiAgICAgICAgICAgPHVsPlxuXHRcdCAqICBcdCAgICAgICAgPGxpPlwidXBcIiAtIGN5Y2xlcyB1cHdhcmQ8L2xpPlxuXHRcdCAqICBcdFx0XHQ8bGk+XCJkb3duXCIgLSBjeWNsZXMgZG93bndhcmQ8L2xpPlxuXHRcdCAqICBcdFx0XHQ8bGk+XCJ1cERvd25cIiAtIHVwIHRoZW4gYW5kIGRvd248L2xpPlxuXHRcdCAqICBcdFx0XHQ8bGk+XCJkb3duVXBcIiAtIGN5Y2xlcyBkb3duIHRoZW4gYW5kIHVwPC9saT5cblx0XHQgKiAgXHRcdFx0PGxpPlwiYWx0ZXJuYXRlVXBcIiAtIGp1bXAgdXAgdHdvIGFuZCBkb3duIG9uZTwvbGk+XG5cdFx0ICogIFx0XHRcdDxsaT5cImFsdGVybmF0ZURvd25cIiAtIGp1bXAgZG93biB0d28gYW5kIHVwIG9uZTwvbGk+XG5cdFx0ICogIFx0XHRcdDxsaT5cInJhbmRvbVwiIC0gcmFuZG9tbHkgc2VsZWN0IGFuIGluZGV4PC9saT5cblx0XHQgKiAgXHRcdFx0PGxpPlwicmFuZG9tV2Fsa1wiIC0gcmFuZG9tbHkgbW92ZXMgb25lIGluZGV4IGF3YXkgZnJvbSB0aGUgY3VycmVudCBwb3NpdGlvbjwvbGk+XG5cdFx0ICogIFx0XHRcdDxsaT5cInJhbmRvbU9uY2VcIiAtIHJhbmRvbWx5IHNlbGVjdCBhbiBpbmRleCB3aXRob3V0IHJlcGVhdGluZyB1bnRpbCBhbGwgdmFsdWVzIGhhdmUgYmVlbiBjaG9zZW4uPC9saT5cblx0XHQgKiAgICAgXHRcdDwvdWw+XG5cdFx0ICogIEBwYXJhbSAge0FycmF5fSAgdmFsdWVzICAgQW4gYXJyYXkgb2Ygb3B0aW9ucyB0byBjaG9vc2UgZnJvbS5cblx0XHQgKiAgQHBhcmFtICB7VG9uZS5DdHJsUGF0dGVybi5UeXBlPX0gIHR5cGUgIFRoZSBuYW1lIG9mIHRoZSBwYXR0ZXJuLlxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZX1cblx0XHQgKi9cblx0ICAgIFRvbmUuQ3RybFBhdHRlcm4gPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIG9wdGlvbnMgPSBUb25lLmRlZmF1bHRzKGFyZ3VtZW50cywgW1xuXHQgICAgICAgICAgICAndmFsdWVzJyxcblx0ICAgICAgICAgICAgJ3R5cGUnXG5cdCAgICAgICAgXSwgVG9uZS5DdHJsUGF0dGVybik7XG5cdCAgICAgICAgVG9uZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBhcnJheSBvZiB2YWx1ZXMgdG8gYXJwZWdnaWF0ZSBvdmVyXG5cdFx0XHQgKiAgQHR5cGUge0FycmF5fVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy52YWx1ZXMgPSBvcHRpb25zLnZhbHVlcztcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgY3VycmVudCBwb3NpdGlvbiBpbiB0aGUgdmFsdWVzIGFycmF5XG5cdFx0XHQgKiAgQHR5cGUgIHtOdW1iZXJ9XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmluZGV4ID0gMDtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgdHlwZSBwbGFjZWhvbGRlclxuXHRcdFx0ICogIEB0eXBlIHtUb25lLkN0cmxQYXR0ZXJuLlR5cGV9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX3R5cGUgPSBudWxsO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFNodWZmbGVkIHZhbHVlcyBmb3IgdGhlIFJhbmRvbU9uY2UgdHlwZVxuXHRcdFx0ICogIEB0eXBlIHtBcnJheX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fc2h1ZmZsZWQgPSBudWxsO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBkaXJlY3Rpb24gb2YgdGhlIG1vdmVtZW50XG5cdFx0XHQgKiAgQHR5cGUge1N0cmluZ31cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fZGlyZWN0aW9uID0gbnVsbDtcblx0ICAgICAgICB0aGlzLnR5cGUgPSBvcHRpb25zLnR5cGU7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5DdHJsUGF0dGVybik7XG5cdCAgICAvKipcblx0XHQgKiAgVGhlIENvbnRyb2wgUGF0dGVybnNcblx0XHQgKiAgQHR5cGUgIHtPYmplY3R9XG5cdFx0ICogIEBzdGF0aWNcblx0XHQgKi9cblx0ICAgIFRvbmUuQ3RybFBhdHRlcm4uVHlwZSA9IHtcblx0ICAgICAgICBVcDogJ3VwJyxcblx0ICAgICAgICBEb3duOiAnZG93bicsXG5cdCAgICAgICAgVXBEb3duOiAndXBEb3duJyxcblx0ICAgICAgICBEb3duVXA6ICdkb3duVXAnLFxuXHQgICAgICAgIEFsdGVybmF0ZVVwOiAnYWx0ZXJuYXRlVXAnLFxuXHQgICAgICAgIEFsdGVybmF0ZURvd246ICdhbHRlcm5hdGVEb3duJyxcblx0ICAgICAgICBSYW5kb206ICdyYW5kb20nLFxuXHQgICAgICAgIFJhbmRvbVdhbGs6ICdyYW5kb21XYWxrJyxcblx0ICAgICAgICBSYW5kb21PbmNlOiAncmFuZG9tT25jZSdcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgVGhlIGRlZmF1bHQgdmFsdWVzLiBcblx0XHQgKiAgQHR5cGUgIHtPYmplY3R9XG5cdFx0ICovXG5cdCAgICBUb25lLkN0cmxQYXR0ZXJuLmRlZmF1bHRzID0ge1xuXHQgICAgICAgICd0eXBlJzogVG9uZS5DdHJsUGF0dGVybi5UeXBlLlVwLFxuXHQgICAgICAgICd2YWx1ZXMnOiBbXVxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgdmFsdWUgYXQgdGhlIGN1cnJlbnQgaW5kZXggb2YgdGhlIHBhdHRlcm4uXG5cdFx0ICogIEByZWFkT25seVxuXHRcdCAqICBAbWVtYmVyT2YgVG9uZS5DdHJsUGF0dGVybiNcblx0XHQgKiAgQHR5cGUgeyp9XG5cdFx0ICogIEBuYW1lIHZhbHVlXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5DdHJsUGF0dGVybi5wcm90b3R5cGUsICd2YWx1ZScsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgLy9zb21lIHNhZmVndWFyZHNcblx0ICAgICAgICAgICAgaWYgKHRoaXMudmFsdWVzLmxlbmd0aCA9PT0gMCkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMudmFsdWVzLmxlbmd0aCA9PT0gMSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVzWzBdO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHRoaXMuaW5kZXggPSBNYXRoLm1pbih0aGlzLmluZGV4LCB0aGlzLnZhbHVlcy5sZW5ndGggLSAxKTtcblx0ICAgICAgICAgICAgdmFyIHZhbCA9IHRoaXMudmFsdWVzW3RoaXMuaW5kZXhdO1xuXHQgICAgICAgICAgICBpZiAodGhpcy50eXBlID09PSBUb25lLkN0cmxQYXR0ZXJuLlR5cGUuUmFuZG9tT25jZSkge1xuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMudmFsdWVzLmxlbmd0aCAhPT0gdGhpcy5fc2h1ZmZsZWQubGVuZ3RoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2h1ZmZsZVZhbHVlcygpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgdmFsID0gdGhpcy52YWx1ZXNbdGhpcy5fc2h1ZmZsZWRbdGhpcy5pbmRleF1dO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiB2YWw7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgVGhlIHBhdHRlcm4gdXNlZCB0byBzZWxlY3QgdGhlIG5leHRcblx0XHQgKiAgaXRlbSBmcm9tIHRoZSB2YWx1ZXMgYXJyYXlcblx0XHQgKiAgQG1lbWJlck9mIFRvbmUuQ3RybFBhdHRlcm4jXG5cdFx0ICogIEB0eXBlIHtUb25lLkN0cmxQYXR0ZXJuLlR5cGV9XG5cdFx0ICogIEBuYW1lIHR5cGVcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkN0cmxQYXR0ZXJuLnByb3RvdHlwZSwgJ3R5cGUnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl90eXBlO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAodHlwZSkge1xuXHQgICAgICAgICAgICB0aGlzLl90eXBlID0gdHlwZTtcblx0ICAgICAgICAgICAgdGhpcy5fc2h1ZmZsZWQgPSBudWxsO1xuXHQgICAgICAgICAgICAvL3RoZSBmaXJzdCBpbmRleFxuXHQgICAgICAgICAgICBpZiAodGhpcy5fdHlwZSA9PT0gVG9uZS5DdHJsUGF0dGVybi5UeXBlLlVwIHx8IHRoaXMuX3R5cGUgPT09IFRvbmUuQ3RybFBhdHRlcm4uVHlwZS5VcERvd24gfHwgdGhpcy5fdHlwZSA9PT0gVG9uZS5DdHJsUGF0dGVybi5UeXBlLlJhbmRvbU9uY2UgfHwgdGhpcy5fdHlwZSA9PT0gVG9uZS5DdHJsUGF0dGVybi5UeXBlLkFsdGVybmF0ZVVwKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLmluZGV4ID0gMDtcblx0ICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLl90eXBlID09PSBUb25lLkN0cmxQYXR0ZXJuLlR5cGUuRG93biB8fCB0aGlzLl90eXBlID09PSBUb25lLkN0cmxQYXR0ZXJuLlR5cGUuRG93blVwIHx8IHRoaXMuX3R5cGUgPT09IFRvbmUuQ3RybFBhdHRlcm4uVHlwZS5BbHRlcm5hdGVEb3duKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLmluZGV4ID0gdGhpcy52YWx1ZXMubGVuZ3RoIC0gMTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAvL3RoZSBkaXJlY3Rpb25cblx0ICAgICAgICAgICAgaWYgKHRoaXMuX3R5cGUgPT09IFRvbmUuQ3RybFBhdHRlcm4uVHlwZS5VcERvd24gfHwgdGhpcy5fdHlwZSA9PT0gVG9uZS5DdHJsUGF0dGVybi5UeXBlLkFsdGVybmF0ZVVwKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9kaXJlY3Rpb24gPSBUb25lLkN0cmxQYXR0ZXJuLlR5cGUuVXA7XG5cdCAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5fdHlwZSA9PT0gVG9uZS5DdHJsUGF0dGVybi5UeXBlLkRvd25VcCB8fCB0aGlzLl90eXBlID09PSBUb25lLkN0cmxQYXR0ZXJuLlR5cGUuQWx0ZXJuYXRlRG93bikge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fZGlyZWN0aW9uID0gVG9uZS5DdHJsUGF0dGVybi5UeXBlLkRvd247XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgLy9yYW5kb21zXG5cdCAgICAgICAgICAgIGlmICh0aGlzLl90eXBlID09PSBUb25lLkN0cmxQYXR0ZXJuLlR5cGUuUmFuZG9tT25jZSkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fc2h1ZmZsZVZhbHVlcygpO1xuXHQgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX3R5cGUgPT09IFRvbmUuQ3RybFBhdHRlcm4uUmFuZG9tKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLmluZGV4ID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogdGhpcy52YWx1ZXMubGVuZ3RoKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIFJldHVybiB0aGUgbmV4dCB2YWx1ZSBnaXZlbiB0aGUgY3VycmVudCBwb3NpdGlvblxuXHRcdCAqICBhbmQgcGF0dGVybi5cblx0XHQgKiAgQHJldHVybiB7Kn0gVGhlIG5leHQgdmFsdWVcblx0XHQgKi9cblx0ICAgIFRvbmUuQ3RybFBhdHRlcm4ucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIHR5cGUgPSB0aGlzLnR5cGU7XG5cdCAgICAgICAgLy9jaG9vc2UgdGhlIG5leHQgaW5kZXhcblx0ICAgICAgICBpZiAodHlwZSA9PT0gVG9uZS5DdHJsUGF0dGVybi5UeXBlLlVwKSB7XG5cdCAgICAgICAgICAgIHRoaXMuaW5kZXgrKztcblx0ICAgICAgICAgICAgaWYgKHRoaXMuaW5kZXggPj0gdGhpcy52YWx1ZXMubGVuZ3RoKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLmluZGV4ID0gMDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gVG9uZS5DdHJsUGF0dGVybi5UeXBlLkRvd24pIHtcblx0ICAgICAgICAgICAgdGhpcy5pbmRleC0tO1xuXHQgICAgICAgICAgICBpZiAodGhpcy5pbmRleCA8IDApIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuaW5kZXggPSB0aGlzLnZhbHVlcy5sZW5ndGggLSAxO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBUb25lLkN0cmxQYXR0ZXJuLlR5cGUuVXBEb3duIHx8IHR5cGUgPT09IFRvbmUuQ3RybFBhdHRlcm4uVHlwZS5Eb3duVXApIHtcblx0ICAgICAgICAgICAgaWYgKHRoaXMuX2RpcmVjdGlvbiA9PT0gVG9uZS5DdHJsUGF0dGVybi5UeXBlLlVwKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLmluZGV4Kys7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLmluZGV4LS07XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgaWYgKHRoaXMuaW5kZXggPCAwKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLmluZGV4ID0gMTtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX2RpcmVjdGlvbiA9IFRvbmUuQ3RybFBhdHRlcm4uVHlwZS5VcDtcblx0ICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmluZGV4ID49IHRoaXMudmFsdWVzLmxlbmd0aCkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5pbmRleCA9IHRoaXMudmFsdWVzLmxlbmd0aCAtIDI7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9kaXJlY3Rpb24gPSBUb25lLkN0cmxQYXR0ZXJuLlR5cGUuRG93bjtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gVG9uZS5DdHJsUGF0dGVybi5UeXBlLlJhbmRvbSkge1xuXHQgICAgICAgICAgICB0aGlzLmluZGV4ID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogdGhpcy52YWx1ZXMubGVuZ3RoKTtcblx0ICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFRvbmUuQ3RybFBhdHRlcm4uVHlwZS5SYW5kb21XYWxrKSB7XG5cdCAgICAgICAgICAgIGlmIChNYXRoLnJhbmRvbSgpIDwgMC41KSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLmluZGV4LS07XG5cdCAgICAgICAgICAgICAgICB0aGlzLmluZGV4ID0gTWF0aC5tYXgodGhpcy5pbmRleCwgMCk7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLmluZGV4Kys7XG5cdCAgICAgICAgICAgICAgICB0aGlzLmluZGV4ID0gTWF0aC5taW4odGhpcy5pbmRleCwgdGhpcy52YWx1ZXMubGVuZ3RoIC0gMSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFRvbmUuQ3RybFBhdHRlcm4uVHlwZS5SYW5kb21PbmNlKSB7XG5cdCAgICAgICAgICAgIHRoaXMuaW5kZXgrKztcblx0ICAgICAgICAgICAgaWYgKHRoaXMuaW5kZXggPj0gdGhpcy52YWx1ZXMubGVuZ3RoKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLmluZGV4ID0gMDtcblx0ICAgICAgICAgICAgICAgIC8vcmVzaHVmZmxlIHRoZSB2YWx1ZXMgZm9yIG5leHQgdGltZVxuXHQgICAgICAgICAgICAgICAgdGhpcy5fc2h1ZmZsZVZhbHVlcygpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBUb25lLkN0cmxQYXR0ZXJuLlR5cGUuQWx0ZXJuYXRlVXApIHtcblx0ICAgICAgICAgICAgaWYgKHRoaXMuX2RpcmVjdGlvbiA9PT0gVG9uZS5DdHJsUGF0dGVybi5UeXBlLlVwKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLmluZGV4ICs9IDI7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9kaXJlY3Rpb24gPSBUb25lLkN0cmxQYXR0ZXJuLlR5cGUuRG93bjtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuaW5kZXggLT0gMTtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX2RpcmVjdGlvbiA9IFRvbmUuQ3RybFBhdHRlcm4uVHlwZS5VcDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBpZiAodGhpcy5pbmRleCA+PSB0aGlzLnZhbHVlcy5sZW5ndGgpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuaW5kZXggPSAwO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fZGlyZWN0aW9uID0gVG9uZS5DdHJsUGF0dGVybi5UeXBlLlVwO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBUb25lLkN0cmxQYXR0ZXJuLlR5cGUuQWx0ZXJuYXRlRG93bikge1xuXHQgICAgICAgICAgICBpZiAodGhpcy5fZGlyZWN0aW9uID09PSBUb25lLkN0cmxQYXR0ZXJuLlR5cGUuVXApIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuaW5kZXggKz0gMTtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX2RpcmVjdGlvbiA9IFRvbmUuQ3RybFBhdHRlcm4uVHlwZS5Eb3duO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5pbmRleCAtPSAyO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fZGlyZWN0aW9uID0gVG9uZS5DdHJsUGF0dGVybi5UeXBlLlVwO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGlmICh0aGlzLmluZGV4IDwgMCkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5pbmRleCA9IHRoaXMudmFsdWVzLmxlbmd0aCAtIDE7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9kaXJlY3Rpb24gPSBUb25lLkN0cmxQYXR0ZXJuLlR5cGUuRG93bjtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gdGhpcy52YWx1ZTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgU2h1ZmZsZXMgdGhlIHZhbHVlcyBhbmQgcGxhY2VzIHRoZSByZXN1bHRzIGludG8gdGhlIF9zaHVmZmxlZFxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5DdHJsUGF0dGVybi5wcm90b3R5cGUuX3NodWZmbGVWYWx1ZXMgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIGNvcHkgPSBbXTtcblx0ICAgICAgICB0aGlzLl9zaHVmZmxlZCA9IFtdO1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy52YWx1ZXMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgY29weVtpXSA9IGk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHdoaWxlIChjb3B5Lmxlbmd0aCA+IDApIHtcblx0ICAgICAgICAgICAgdmFyIHJhbmRWYWwgPSBjb3B5LnNwbGljZShNYXRoLmZsb29yKGNvcHkubGVuZ3RoICogTWF0aC5yYW5kb20oKSksIDEpO1xuXHQgICAgICAgICAgICB0aGlzLl9zaHVmZmxlZC5wdXNoKHJhbmRWYWxbMF0pO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgQ2xlYW4gdXBcblx0XHQgKiAgQHJldHVybnMge1RvbmUuQ3RybFBhdHRlcm59IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuQ3RybFBhdHRlcm4ucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdGhpcy5fc2h1ZmZsZWQgPSBudWxsO1xuXHQgICAgICAgIHRoaXMudmFsdWVzID0gbnVsbDtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVG9uZS5DdHJsUGF0dGVybjtcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgXG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzICBDaG9vc2UgYSByYW5kb20gdmFsdWUuXG5cdFx0ICogIEBleHRlbmRzIHtUb25lfVxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIHZhciByYW5kb21XYWxrID0gbmV3IFRvbmUuQ3RybFJhbmRvbSh7XG5cdFx0ICogXHRcIm1pblwiIDogMCxcblx0XHQgKiBcdFwibWF4XCIgOiAxMCxcblx0XHQgKiBcdFwiaW50ZWdlclwiIDogdHJ1ZVxuXHRcdCAqIH0pO1xuXHRcdCAqIHJhbmRvbVdhbGsuZXZhbCgpO1xuXHRcdCAqXG5cdFx0ICogIEBwYXJhbSB7TnVtYmVyfFRpbWU9fSBtaW4gVGhlIG1pbmltdW0gcmV0dXJuIHZhbHVlLlxuXHRcdCAqICBAcGFyYW0ge051bWJlcnxUaW1lPX0gbWF4IFRoZSBtYXhpbXVtIHJldHVybiB2YWx1ZS5cblx0XHQgKi9cblx0ICAgIFRvbmUuQ3RybFJhbmRvbSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgb3B0aW9ucyA9IFRvbmUuZGVmYXVsdHMoYXJndW1lbnRzLCBbXG5cdCAgICAgICAgICAgICdtaW4nLFxuXHQgICAgICAgICAgICAnbWF4J1xuXHQgICAgICAgIF0sIFRvbmUuQ3RybFJhbmRvbSk7XG5cdCAgICAgICAgVG9uZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBtaW5pbXVtIHJldHVybiB2YWx1ZVxuXHRcdFx0ICogIEB0eXBlICB7TnVtYmVyfFRpbWV9XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLm1pbiA9IG9wdGlvbnMubWluO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBtYXhpbXVtIHJldHVybiB2YWx1ZVxuXHRcdFx0ICogIEB0eXBlICB7TnVtYmVyfFRpbWV9XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLm1heCA9IG9wdGlvbnMubWF4O1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIElmIHRoZSByZXR1cm4gdmFsdWUgc2hvdWxkIGJlIGFuIGludGVnZXJcblx0XHRcdCAqICBAdHlwZSAge0Jvb2xlYW59XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmludGVnZXIgPSBvcHRpb25zLmludGVnZXI7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5DdHJsUmFuZG9tKTtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgZGVmYXVsdHNcblx0XHQgKiAgQGNvbnN0XG5cdFx0ICogIEB0eXBlICB7T2JqZWN0fVxuXHRcdCAqL1xuXHQgICAgVG9uZS5DdHJsUmFuZG9tLmRlZmF1bHRzID0ge1xuXHQgICAgICAgICdtaW4nOiAwLFxuXHQgICAgICAgICdtYXgnOiAxLFxuXHQgICAgICAgICdpbnRlZ2VyJzogZmFsc2Vcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgUmV0dXJuIGEgcmFuZG9tIHZhbHVlIGJldHdlZW4gbWluIGFuZCBtYXguIFxuXHRcdCAqICBAcmVhZE9ubHlcblx0XHQgKiAgQG1lbWJlck9mIFRvbmUuQ3RybFJhbmRvbSNcblx0XHQgKiAgQHR5cGUgeyp9XG5cdFx0ICogIEBuYW1lIHZhbHVlXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5DdHJsUmFuZG9tLnByb3RvdHlwZSwgJ3ZhbHVlJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgbWluID0gdGhpcy50b1NlY29uZHModGhpcy5taW4pO1xuXHQgICAgICAgICAgICB2YXIgbWF4ID0gdGhpcy50b1NlY29uZHModGhpcy5tYXgpO1xuXHQgICAgICAgICAgICB2YXIgcmFuZCA9IE1hdGgucmFuZG9tKCk7XG5cdCAgICAgICAgICAgIHZhciB2YWwgPSByYW5kICogbWluICsgKDEgLSByYW5kKSAqIG1heDtcblx0ICAgICAgICAgICAgaWYgKHRoaXMuaW50ZWdlcikge1xuXHQgICAgICAgICAgICAgICAgdmFsID0gTWF0aC5mbG9vcih2YWwpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiB2YWw7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICByZXR1cm4gVG9uZS5DdHJsUmFuZG9tO1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBBdWRpb0J1ZmZlci5jb3B5VG9DaGFubmVsIHBvbHlmaWxsXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBpZiAod2luZG93LkF1ZGlvQnVmZmVyICYmICFBdWRpb0J1ZmZlci5wcm90b3R5cGUuY29weVRvQ2hhbm5lbCkge1xuXHQgICAgICAgIEF1ZGlvQnVmZmVyLnByb3RvdHlwZS5jb3B5VG9DaGFubmVsID0gZnVuY3Rpb24gKHNyYywgY2hhbk51bSwgc3RhcnQpIHtcblx0ICAgICAgICAgICAgdmFyIGNoYW5uZWwgPSB0aGlzLmdldENoYW5uZWxEYXRhKGNoYW5OdW0pO1xuXHQgICAgICAgICAgICBzdGFydCA9IHN0YXJ0IHx8IDA7XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hhbm5lbC5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgY2hhbm5lbFtpICsgc3RhcnRdID0gc3JjW2ldO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfTtcblx0ICAgICAgICBBdWRpb0J1ZmZlci5wcm90b3R5cGUuY29weUZyb21DaGFubmVsID0gZnVuY3Rpb24gKGRlc3QsIGNoYW5OdW0sIHN0YXJ0KSB7XG5cdCAgICAgICAgICAgIHZhciBjaGFubmVsID0gdGhpcy5nZXRDaGFubmVsRGF0YShjaGFuTnVtKTtcblx0ICAgICAgICAgICAgc3RhcnQgPSBzdGFydCB8fCAwO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRlc3QubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIGRlc3RbaV0gPSBjaGFubmVsW2kgKyBzdGFydF07XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9O1xuXHQgICAgfVxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyAgQnVmZmVyIGxvYWRpbmcgYW5kIHN0b3JhZ2UuIFRvbmUuQnVmZmVyIGlzIHVzZWQgaW50ZXJuYWxseSBieSBhbGwgXG5cdFx0ICogICAgICAgICAgY2xhc3NlcyB0aGF0IG1ha2UgcmVxdWVzdHMgZm9yIGF1ZGlvIGZpbGVzIHN1Y2ggYXMgVG9uZS5QbGF5ZXIsXG5cdFx0ICogICAgICAgICAgVG9uZS5TYW1wbGVyIGFuZCBUb25lLkNvbnZvbHZlci5cblx0XHQgKiAgICAgICAgICBcblx0XHQgKiAgICAgICAgICBBc2lkZSBmcm9tIGxvYWQgY2FsbGJhY2tzIGZyb20gaW5kaXZpZHVhbCBidWZmZXJzLCBUb25lLkJ1ZmZlciBcblx0XHQgKiAgXHRcdHByb3ZpZGVzIGV2ZW50cyB3aGljaCBrZWVwIHRyYWNrIG9mIHRoZSBsb2FkaW5nIHByb2dyZXNzIFxuXHRcdCAqICBcdFx0b2YgX2FsbF8gb2YgdGhlIGJ1ZmZlcnMuIFRoZXNlIGFyZSBUb25lLkJ1ZmZlci5vbihcImxvYWRcIiAvIFwicHJvZ3Jlc3NcIiAvIFwiZXJyb3JcIilcblx0XHQgKlxuXHRcdCAqICBAY29uc3RydWN0b3IgXG5cdFx0ICogIEBleHRlbmRzIHtUb25lfVxuXHRcdCAqICBAcGFyYW0ge0F1ZGlvQnVmZmVyfFN0cmluZ30gdXJsIFRoZSB1cmwgdG8gbG9hZCwgb3IgdGhlIGF1ZGlvIGJ1ZmZlciB0byBzZXQuIFxuXHRcdCAqICBAcGFyYW0ge0Z1bmN0aW9uPX0gb25sb2FkIEEgY2FsbGJhY2sgd2hpY2ggaXMgaW52b2tlZCBhZnRlciB0aGUgYnVmZmVyIGlzIGxvYWRlZC4gXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgSXQncyByZWNvbW1lbmRlZCB0byB1c2UgYFRvbmUuQnVmZmVyLm9uKCdsb2FkJywgY2FsbGJhY2spYCBpbnN0ZWFkIFxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpbmNlIGl0IHdpbGwgZ2l2ZSB5b3UgYSBjYWxsYmFjayB3aGVuIF9hbGxfIGJ1ZmZlcnMgYXJlIGxvYWRlZC5cblx0XHQgKiAgQHBhcmFtIHtGdW5jdGlvbj19IG9uZXJyb3IgVGhlIGNhbGxiYWNrIHRvIGludm9rZSBpZiB0aGVyZSBpcyBhbiBlcnJvclxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIHZhciBidWZmZXIgPSBuZXcgVG9uZS5CdWZmZXIoXCJwYXRoL3RvL3NvdW5kLm1wM1wiLCBmdW5jdGlvbigpe1xuXHRcdCAqIFx0Ly90aGUgYnVmZmVyIGlzIG5vdyBhdmFpbGFibGUuXG5cdFx0ICogXHR2YXIgYnVmZiA9IGJ1ZmZlci5nZXQoKTtcblx0XHQgKiB9KTtcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAvL2NhbiBsb2FkIHByb3ZpZGUgZmFsbGJhY2sgZXh0ZW5zaW9uIHR5cGVzIGlmIHRoZSBmaXJzdCB0eXBlIGlzIG5vdCBzdXBwb3J0ZWQuXG5cdFx0ICogdmFyIGJ1ZmZlciA9IG5ldyBUb25lLkJ1ZmZlcihcInBhdGgvdG8vc291bmQuW21wM3xvZ2d8d2F2XVwiKTtcblx0XHQgKi9cblx0ICAgIFRvbmUuQnVmZmVyID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBvcHRpb25zID0gVG9uZS5kZWZhdWx0cyhhcmd1bWVudHMsIFtcblx0ICAgICAgICAgICAgJ3VybCcsXG5cdCAgICAgICAgICAgICdvbmxvYWQnLFxuXHQgICAgICAgICAgICAnb25lcnJvcidcblx0ICAgICAgICBdLCBUb25lLkJ1ZmZlcik7XG5cdCAgICAgICAgVG9uZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHN0b3JlcyB0aGUgbG9hZGVkIEF1ZGlvQnVmZmVyXG5cdFx0XHQgKiAgQHR5cGUge0F1ZGlvQnVmZmVyfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9idWZmZXIgPSBudWxsO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIGluZGljYXRlcyBpZiB0aGUgYnVmZmVyIHNob3VsZCBiZSByZXZlcnNlZCBvciBub3Rcblx0XHRcdCAqICBAdHlwZSB7Qm9vbGVhbn1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fcmV2ZXJzZWQgPSBvcHRpb25zLnJldmVyc2U7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIFhIUlxuXHRcdFx0ICogIEB0eXBlICB7WE1MSHR0cFJlcXVlc3R9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX3hociA9IG51bGw7XG5cdCAgICAgICAgaWYgKG9wdGlvbnMudXJsIGluc3RhbmNlb2YgQXVkaW9CdWZmZXIgfHwgb3B0aW9ucy51cmwgaW5zdGFuY2VvZiBUb25lLkJ1ZmZlcikge1xuXHQgICAgICAgICAgICB0aGlzLnNldChvcHRpb25zLnVybCk7XG5cdCAgICAgICAgICAgIC8vIGludm9rZSB0aGUgb25sb2FkIGNhbGxiYWNrXG5cdCAgICAgICAgICAgIGlmIChvcHRpb25zLm9ubG9hZCkge1xuXHQgICAgICAgICAgICAgICAgb3B0aW9ucy5vbmxvYWQodGhpcyk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9IGVsc2UgaWYgKFRvbmUuaXNTdHJpbmcob3B0aW9ucy51cmwpKSB7XG5cdCAgICAgICAgICAgIHRoaXMubG9hZChvcHRpb25zLnVybCwgb3B0aW9ucy5vbmxvYWQsIG9wdGlvbnMub25lcnJvcik7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuQnVmZmVyKTtcblx0ICAgIC8qKlxuXHRcdCAqICB0aGUgZGVmYXVsdCBwYXJhbWV0ZXJzXG5cdFx0ICogIEB0eXBlIHtPYmplY3R9XG5cdFx0ICovXG5cdCAgICBUb25lLkJ1ZmZlci5kZWZhdWx0cyA9IHtcblx0ICAgICAgICAndXJsJzogdW5kZWZpbmVkLFxuXHQgICAgICAgICdyZXZlcnNlJzogZmFsc2Vcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgUGFzcyBpbiBhbiBBdWRpb0J1ZmZlciBvciBUb25lLkJ1ZmZlciB0byBzZXQgdGhlIHZhbHVlXG5cdFx0ICogIG9mIHRoaXMgYnVmZmVyLlxuXHRcdCAqICBAcGFyYW0ge0F1ZGlvQnVmZmVyfFRvbmUuQnVmZmVyfSBidWZmZXIgdGhlIGJ1ZmZlclxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5CdWZmZXJ9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuQnVmZmVyLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAoYnVmZmVyKSB7XG5cdCAgICAgICAgaWYgKGJ1ZmZlciBpbnN0YW5jZW9mIFRvbmUuQnVmZmVyKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2J1ZmZlciA9IGJ1ZmZlci5nZXQoKTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICB0aGlzLl9idWZmZXIgPSBidWZmZXI7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBAcmV0dXJuIHtBdWRpb0J1ZmZlcn0gVGhlIGF1ZGlvIGJ1ZmZlciBzdG9yZWQgaW4gdGhlIG9iamVjdC5cblx0XHQgKi9cblx0ICAgIFRvbmUuQnVmZmVyLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuX2J1ZmZlcjtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgTWFrZXMgYW4geGhyIHJlcWVzdCBmb3IgdGhlIHNlbGVjdGVkIHVybCB0aGVuIGRlY29kZXNcblx0XHQgKiAgdGhlIGZpbGUgYXMgYW4gYXVkaW8gYnVmZmVyLiBJbnZva2VzXG5cdFx0ICogIHRoZSBjYWxsYmFjayBvbmNlIHRoZSBhdWRpbyBidWZmZXIgbG9hZHMuXG5cdFx0ICogIEBwYXJhbSB7U3RyaW5nfSB1cmwgVGhlIHVybCBvZiB0aGUgYnVmZmVyIHRvIGxvYWQuXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgZmlsZXR5cGUgc3VwcG9ydCBkZXBlbmRzIG9uIHRoZVxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgIGJyb3dzZXIuXG5cdFx0ICogIEByZXR1cm5zIHtQcm9taXNlfSByZXR1cm5zIGEgUHJvbWlzZSB3aGljaCByZXNvbHZlcyB3aXRoIHRoZSBUb25lLkJ1ZmZlclxuXHRcdCAqL1xuXHQgICAgVG9uZS5CdWZmZXIucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbiAodXJsLCBvbmxvYWQsIG9uZXJyb3IpIHtcblx0ICAgICAgICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChsb2FkLCBlcnJvcikge1xuXHQgICAgICAgICAgICB0aGlzLl94aHIgPSBUb25lLkJ1ZmZlci5sb2FkKHVybCwgLy9zdWNjZXNzXG5cdCAgICAgICAgICAgIGZ1bmN0aW9uIChidWZmKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl94aHIgPSBudWxsO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5zZXQoYnVmZik7XG5cdCAgICAgICAgICAgICAgICBsb2FkKHRoaXMpO1xuXHQgICAgICAgICAgICAgICAgaWYgKG9ubG9hZCkge1xuXHQgICAgICAgICAgICAgICAgICAgIG9ubG9hZCh0aGlzKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfS5iaW5kKHRoaXMpLCAvL2Vycm9yXG5cdCAgICAgICAgICAgIGZ1bmN0aW9uIChlcnIpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX3hociA9IG51bGw7XG5cdCAgICAgICAgICAgICAgICBlcnJvcihlcnIpO1xuXHQgICAgICAgICAgICAgICAgaWYgKG9uZXJyb3IpIHtcblx0ICAgICAgICAgICAgICAgICAgICBvbmVycm9yKGVycik7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XG5cdCAgICAgICAgfS5iaW5kKHRoaXMpKTtcblx0ICAgICAgICByZXR1cm4gcHJvbWlzZTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgZGlzcG9zZSBhbmQgZGlzY29ubmVjdFxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5CdWZmZXJ9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuQnVmZmVyLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLl9idWZmZXIgPSBudWxsO1xuXHQgICAgICAgIGlmICh0aGlzLl94aHIpIHtcblx0ICAgICAgICAgICAgVG9uZS5CdWZmZXIuX3JlbW92ZUZyb21Eb3dubG9hZFF1ZXVlKHRoaXMuX3hocik7XG5cdCAgICAgICAgICAgIHRoaXMuX3hoci5hYm9ydCgpO1xuXHQgICAgICAgICAgICB0aGlzLl94aHIgPSBudWxsO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiBJZiB0aGUgYnVmZmVyIGlzIGxvYWRlZCBvciBub3Rcblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5CdWZmZXIjXG5cdFx0ICogQHR5cGUge0Jvb2xlYW59XG5cdFx0ICogQG5hbWUgbG9hZGVkXG5cdFx0ICogQHJlYWRPbmx5XG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5CdWZmZXIucHJvdG90eXBlLCAnbG9hZGVkJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5sZW5ndGggPiAwO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogVGhlIGR1cmF0aW9uIG9mIHRoZSBidWZmZXIuIFxuXHRcdCAqIEBtZW1iZXJPZiBUb25lLkJ1ZmZlciNcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqIEBuYW1lIGR1cmF0aW9uXG5cdFx0ICogQHJlYWRPbmx5XG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5CdWZmZXIucHJvdG90eXBlLCAnZHVyYXRpb24nLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIGlmICh0aGlzLl9idWZmZXIpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9idWZmZXIuZHVyYXRpb247XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gMDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogVGhlIGxlbmd0aCBvZiB0aGUgYnVmZmVyIGluIHNhbXBsZXNcblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5CdWZmZXIjXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKiBAbmFtZSBsZW5ndGhcblx0XHQgKiBAcmVhZE9ubHlcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkJ1ZmZlci5wcm90b3R5cGUsICdsZW5ndGgnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIGlmICh0aGlzLl9idWZmZXIpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9idWZmZXIubGVuZ3RoO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIDA7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqIFRoZSBudW1iZXIgb2YgZGlzY3JldGUgYXVkaW8gY2hhbm5lbHMuIFJldHVybnMgMCBpZiBubyBidWZmZXJcblx0XHQgKiBpcyBsb2FkZWQuXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuQnVmZmVyI1xuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogQG5hbWUgbnVtYmVyT2ZDaGFubmVsc1xuXHRcdCAqIEByZWFkT25seVxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuQnVmZmVyLnByb3RvdHlwZSwgJ251bWJlck9mQ2hhbm5lbHMnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIGlmICh0aGlzLl9idWZmZXIpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9idWZmZXIubnVtYmVyT2ZDaGFubmVscztcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiAwO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgU2V0IHRoZSBhdWRpbyBidWZmZXIgZnJvbSB0aGUgYXJyYXkuIFRvIGNyZWF0ZSBhIG11bHRpY2hhbm5lbCBBdWRpb0J1ZmZlcixcblx0XHQgKiAgcGFzcyBpbiBhIG11bHRpZGltZW5zaW9uYWwgYXJyYXkuIFxuXHRcdCAqICBAcGFyYW0ge0Zsb2F0MzJBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGZpbGwgdGhlIGF1ZGlvIGJ1ZmZlclxuXHRcdCAqICBAcmV0dXJuIHtUb25lLkJ1ZmZlcn0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5CdWZmZXIucHJvdG90eXBlLmZyb21BcnJheSA9IGZ1bmN0aW9uIChhcnJheSkge1xuXHQgICAgICAgIHZhciBpc011bHRpZGltZW5zaW9uYWwgPSBhcnJheVswXS5sZW5ndGggPiAwO1xuXHQgICAgICAgIHZhciBjaGFubmVscyA9IGlzTXVsdGlkaW1lbnNpb25hbCA/IGFycmF5Lmxlbmd0aCA6IDE7XG5cdCAgICAgICAgdmFyIGxlbiA9IGlzTXVsdGlkaW1lbnNpb25hbCA/IGFycmF5WzBdLmxlbmd0aCA6IGFycmF5Lmxlbmd0aDtcblx0ICAgICAgICB2YXIgYnVmZmVyID0gdGhpcy5jb250ZXh0LmNyZWF0ZUJ1ZmZlcihjaGFubmVscywgbGVuLCB0aGlzLmNvbnRleHQuc2FtcGxlUmF0ZSk7XG5cdCAgICAgICAgaWYgKCFpc011bHRpZGltZW5zaW9uYWwgJiYgY2hhbm5lbHMgPT09IDEpIHtcblx0ICAgICAgICAgICAgYXJyYXkgPSBbYXJyYXldO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBmb3IgKHZhciBjID0gMDsgYyA8IGNoYW5uZWxzOyBjKyspIHtcblx0ICAgICAgICAgICAgYnVmZmVyLmNvcHlUb0NoYW5uZWwoYXJyYXlbY10sIGMpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB0aGlzLl9idWZmZXIgPSBidWZmZXI7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogXHRTdW1zIG11bGlwbGUgY2hhbm5lbHMgaW50byAxIGNoYW5uZWxcblx0XHQgKiAgQHBhcmFtIHtOdW1iZXI9fSBjaGFubmVsIE9wdGlvbmFsbHkgb25seSBjb3B5IGEgc2luZ2xlIGNoYW5uZWwgZnJvbSB0aGUgYXJyYXkuXG5cdFx0ICogIEByZXR1cm4ge0FycmF5fVxuXHRcdCAqL1xuXHQgICAgVG9uZS5CdWZmZXIucHJvdG90eXBlLnRvTW9ubyA9IGZ1bmN0aW9uIChjaGFuTnVtKSB7XG5cdCAgICAgICAgaWYgKFRvbmUuaXNOdW1iZXIoY2hhbk51bSkpIHtcblx0ICAgICAgICAgICAgdGhpcy5mcm9tQXJyYXkodGhpcy50b0FycmF5KGNoYW5OdW0pKTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICB2YXIgb3V0cHV0QXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KHRoaXMubGVuZ3RoKTtcblx0ICAgICAgICAgICAgdmFyIG51bUNoYW5uZWxzID0gdGhpcy5udW1iZXJPZkNoYW5uZWxzO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBjaGFubmVsID0gMDsgY2hhbm5lbCA8IG51bUNoYW5uZWxzOyBjaGFubmVsKyspIHtcblx0ICAgICAgICAgICAgICAgIHZhciBjaGFubmVsQXJyYXkgPSB0aGlzLnRvQXJyYXkoY2hhbm5lbCk7XG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoYW5uZWxBcnJheS5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgICAgIG91dHB1dEFycmF5W2ldICs9IGNoYW5uZWxBcnJheVtpXTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAvL2RpdmlkZSBieSB0aGUgbnVtYmVyIG9mIGNoYW5uZWxzXG5cdCAgICAgICAgICAgIG91dHB1dEFycmF5ID0gb3V0cHV0QXJyYXkubWFwKGZ1bmN0aW9uIChzYW1wbGUpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBzYW1wbGUgLyBudW1DaGFubmVscztcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIHRoaXMuZnJvbUFycmF5KG91dHB1dEFycmF5KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogXHRHZXQgdGhlIGJ1ZmZlciBhcyBhbiBhcnJheS4gU2luZ2xlIGNoYW5uZWwgYnVmZmVycyB3aWxsIHJldHVybiBhIDEtZGltZW5zaW9uYWwgXG5cdFx0ICogXHRGbG9hdDMyQXJyYXksIGFuZCBtdWx0aWNoYW5uZWwgYnVmZmVycyB3aWxsIHJldHVybiBtdWx0aWRpbWVuc2lvbmFsIGFycmF5cy5cblx0XHQgKiAgQHBhcmFtIHtOdW1iZXI9fSBjaGFubmVsIE9wdGlvbmFsbHkgb25seSBjb3B5IGEgc2luZ2xlIGNoYW5uZWwgZnJvbSB0aGUgYXJyYXkuXG5cdFx0ICogIEByZXR1cm4ge0FycmF5fVxuXHRcdCAqL1xuXHQgICAgVG9uZS5CdWZmZXIucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbiAoY2hhbm5lbCkge1xuXHQgICAgICAgIGlmIChUb25lLmlzTnVtYmVyKGNoYW5uZWwpKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLmdldENoYW5uZWxEYXRhKGNoYW5uZWwpO1xuXHQgICAgICAgIH0gZWxzZSBpZiAodGhpcy5udW1iZXJPZkNoYW5uZWxzID09PSAxKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLnRvQXJyYXkoMCk7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgdmFyIHJldCA9IFtdO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBjID0gMDsgYyA8IHRoaXMubnVtYmVyT2ZDaGFubmVsczsgYysrKSB7XG5cdCAgICAgICAgICAgICAgICByZXRbY10gPSB0aGlzLmdldENoYW5uZWxEYXRhKGMpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiByZXQ7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBSZXR1cm5zIHRoZSBGbG9hdDMyQXJyYXkgcmVwcmVzZW50aW5nIHRoZSBQQ00gYXVkaW8gZGF0YSBmb3IgdGhlIHNwZWNpZmljIGNoYW5uZWwuXG5cdFx0ICogIEBwYXJhbSAge051bWJlcn0gIGNoYW5uZWwgIFRoZSBjaGFubmVsIG51bWJlciB0byByZXR1cm5cblx0XHQgKiAgQHJldHVybiAge0Zsb2F0MzJBcnJheX0gIFRoZSBhdWRpbyBhcyBhIFR5cGVkQXJyYXlcblx0XHQgKi9cblx0ICAgIFRvbmUuQnVmZmVyLnByb3RvdHlwZS5nZXRDaGFubmVsRGF0YSA9IGZ1bmN0aW9uIChjaGFubmVsKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuX2J1ZmZlci5nZXRDaGFubmVsRGF0YShjaGFubmVsKTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgQ3V0IGEgc3Vic2VjdGlvbiBvZiB0aGUgYXJyYXkgYW5kIHJldHVybiBhIGJ1ZmZlciBvZiB0aGVcblx0XHQgKiAgc3Vic2VjdGlvbi4gRG9lcyBub3QgbW9kaWZ5IHRoZSBvcmlnaW5hbCBidWZmZXJcblx0XHQgKiAgQHBhcmFtIHtUaW1lfSBzdGFydCBUaGUgdGltZSB0byBzdGFydCB0aGUgc2xpY2Vcblx0XHQgKiAgQHBhcmFtIHtUaW1lPX0gZW5kIFRoZSBlbmQgdGltZSB0byBzbGljZS4gSWYgbm9uZSBpcyBnaXZlblxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgd2lsbCBkZWZhdWx0IHRvIHRoZSBlbmQgb2YgdGhlIGJ1ZmZlclxuXHRcdCAqICBAcmV0dXJuIHtUb25lLkJ1ZmZlcn0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5CdWZmZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcblx0ICAgICAgICBlbmQgPSBUb25lLmRlZmF1bHRBcmcoZW5kLCB0aGlzLmR1cmF0aW9uKTtcblx0ICAgICAgICB2YXIgc3RhcnRTYW1wbGVzID0gTWF0aC5mbG9vcih0aGlzLmNvbnRleHQuc2FtcGxlUmF0ZSAqIHRoaXMudG9TZWNvbmRzKHN0YXJ0KSk7XG5cdCAgICAgICAgdmFyIGVuZFNhbXBsZXMgPSBNYXRoLmZsb29yKHRoaXMuY29udGV4dC5zYW1wbGVSYXRlICogdGhpcy50b1NlY29uZHMoZW5kKSk7XG5cdCAgICAgICAgdmFyIHJlcGxhY2VtZW50ID0gW107XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm51bWJlck9mQ2hhbm5lbHM7IGkrKykge1xuXHQgICAgICAgICAgICByZXBsYWNlbWVudFtpXSA9IHRoaXMudG9BcnJheShpKS5zbGljZShzdGFydFNhbXBsZXMsIGVuZFNhbXBsZXMpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgcmV0QnVmZmVyID0gbmV3IFRvbmUuQnVmZmVyKCkuZnJvbUFycmF5KHJlcGxhY2VtZW50KTtcblx0ICAgICAgICByZXR1cm4gcmV0QnVmZmVyO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBSZXZlcnNlIHRoZSBidWZmZXIuXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICogIEByZXR1cm4ge1RvbmUuQnVmZmVyfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkJ1ZmZlci5wcm90b3R5cGUuX3JldmVyc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgaWYgKHRoaXMubG9hZGVkKSB7XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5udW1iZXJPZkNoYW5uZWxzOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5yZXZlcnNlLmNhbGwodGhpcy5nZXRDaGFubmVsRGF0YShpKSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogUmV2ZXJzZSB0aGUgYnVmZmVyLlxuXHRcdCAqIEBtZW1iZXJPZiBUb25lLkJ1ZmZlciNcblx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0XHQgKiBAbmFtZSByZXZlcnNlXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5CdWZmZXIucHJvdG90eXBlLCAncmV2ZXJzZScsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JldmVyc2VkO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAocmV2KSB7XG5cdCAgICAgICAgICAgIGlmICh0aGlzLl9yZXZlcnNlZCAhPT0gcmV2KSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9yZXZlcnNlZCA9IHJldjtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX3JldmVyc2UoKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdCAgICAvLyBTVEFUSUMgTUVUSE9EU1xuXHQgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdCAgICAvL3N0YXRpY2FsbHkgaW5oZXJpdHMgRW1pdHRlciBtZXRob2RzXG5cdCAgICBUb25lLkVtaXR0ZXIubWl4aW4oVG9uZS5CdWZmZXIpO1xuXHQgICAgLyoqXG5cdFx0ICogIHRoZSBzdGF0aWMgcXVldWUgZm9yIGFsbCBvZiB0aGUgeGhyIHJlcXVlc3RzXG5cdFx0ICogIEB0eXBlIHtBcnJheX1cblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuQnVmZmVyLl9kb3dubG9hZFF1ZXVlID0gW107XG5cdCAgICAvKipcblx0XHQgKiAgQSBwYXRoIHdoaWNoIGlzIHByZWZpeGVkIGJlZm9yZSBldmVyeSB1cmwuXG5cdFx0ICogIEB0eXBlICB7U3RyaW5nfVxuXHRcdCAqICBAc3RhdGljXG5cdFx0ICovXG5cdCAgICBUb25lLkJ1ZmZlci5iYXNlVXJsID0gJyc7XG5cdCAgICAvKipcblx0XHQgKiAgQ3JlYXRlIGEgVG9uZS5CdWZmZXIgZnJvbSB0aGUgYXJyYXkuIFRvIGNyZWF0ZSBhIG11bHRpY2hhbm5lbCBBdWRpb0J1ZmZlcixcblx0XHQgKiAgcGFzcyBpbiBhIG11bHRpZGltZW5zaW9uYWwgYXJyYXkuIFxuXHRcdCAqICBAcGFyYW0ge0Zsb2F0MzJBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGZpbGwgdGhlIGF1ZGlvIGJ1ZmZlclxuXHRcdCAqICBAcmV0dXJuIHtUb25lLkJ1ZmZlcn0gQSBUb25lLkJ1ZmZlciBjcmVhdGVkIGZyb20gdGhlIGFycmF5XG5cdFx0ICovXG5cdCAgICBUb25lLkJ1ZmZlci5mcm9tQXJyYXkgPSBmdW5jdGlvbiAoYXJyYXkpIHtcblx0ICAgICAgICByZXR1cm4gbmV3IFRvbmUuQnVmZmVyKCkuZnJvbUFycmF5KGFycmF5KTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiBSZW1vdmUgYW4geGhyIHJlcXVlc3QgZnJvbSB0aGUgZG93bmxvYWQgcXVldWVcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5CdWZmZXIuX3JlbW92ZUZyb21Eb3dubG9hZFF1ZXVlID0gZnVuY3Rpb24gKHJlcXVlc3QpIHtcblx0ICAgICAgICB2YXIgaW5kZXggPSBUb25lLkJ1ZmZlci5fZG93bmxvYWRRdWV1ZS5pbmRleE9mKHJlcXVlc3QpO1xuXHQgICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcblx0ICAgICAgICAgICAgVG9uZS5CdWZmZXIuX2Rvd25sb2FkUXVldWUuc3BsaWNlKGluZGV4LCAxKTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIExvYWRzIGEgdXJsIHVzaW5nIFhNTEh0dHBSZXF1ZXN0LlxuXHRcdCAqICBAcGFyYW0ge1N0cmluZ30gdXJsXG5cdFx0ICogIEBwYXJhbSB7RnVuY3Rpb259IG9ubG9hZFxuXHRcdCAqICBAcGFyYW0ge0Z1bmN0aW9ufSBvbmVycm9yXG5cdFx0ICogIEBwYXJhbSB7RnVuY3Rpb259IG9ucHJvZ3Jlc3Ncblx0XHQgKiAgQHJldHVybiB7WE1MSHR0cFJlcXVlc3R9XG5cdFx0ICovXG5cdCAgICBUb25lLkJ1ZmZlci5sb2FkID0gZnVuY3Rpb24gKHVybCwgb25sb2FkLCBvbmVycm9yKSB7XG5cdCAgICAgICAgLy9kZWZhdWx0XG5cdCAgICAgICAgb25sb2FkID0gVG9uZS5kZWZhdWx0QXJnKG9ubG9hZCwgVG9uZS5ub09wKTtcblx0ICAgICAgICAvLyB0ZXN0IGlmIHRoZSB1cmwgY29udGFpbnMgbXVsdGlwbGUgZXh0ZW5zaW9uc1xuXHQgICAgICAgIHZhciBtYXRjaGVzID0gdXJsLm1hdGNoKC9cXFsoLitcXHw/KStcXF0kLyk7XG5cdCAgICAgICAgaWYgKG1hdGNoZXMpIHtcblx0ICAgICAgICAgICAgdmFyIGV4dGVuc2lvbnMgPSBtYXRjaGVzWzFdLnNwbGl0KCd8Jyk7XG5cdCAgICAgICAgICAgIHZhciBleHRlbnNpb24gPSBleHRlbnNpb25zWzBdO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4dGVuc2lvbnMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIGlmIChUb25lLkJ1ZmZlci5zdXBwb3J0c1R5cGUoZXh0ZW5zaW9uc1tpXSkpIHtcblx0ICAgICAgICAgICAgICAgICAgICBleHRlbnNpb24gPSBleHRlbnNpb25zW2ldO1xuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHVybCA9IHVybC5yZXBsYWNlKG1hdGNoZXNbMF0sIGV4dGVuc2lvbik7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIG9uRXJyb3IoZSkge1xuXHQgICAgICAgICAgICBUb25lLkJ1ZmZlci5fcmVtb3ZlRnJvbURvd25sb2FkUXVldWUocmVxdWVzdCk7XG5cdCAgICAgICAgICAgIFRvbmUuQnVmZmVyLmVtaXQoJ2Vycm9yJywgZSk7XG5cdCAgICAgICAgICAgIGlmIChvbmVycm9yKSB7XG5cdCAgICAgICAgICAgICAgICBvbmVycm9yKGUpO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgdGhyb3cgZTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiBvblByb2dyZXNzKCkge1xuXHQgICAgICAgICAgICAvL2NhbGN1bGF0ZSB0aGUgcHJvZ3Jlc3Ncblx0ICAgICAgICAgICAgdmFyIHRvdGFsUHJvZ3Jlc3MgPSAwO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IFRvbmUuQnVmZmVyLl9kb3dubG9hZFF1ZXVlLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICB0b3RhbFByb2dyZXNzICs9IFRvbmUuQnVmZmVyLl9kb3dubG9hZFF1ZXVlW2ldLnByb2dyZXNzO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIFRvbmUuQnVmZmVyLmVtaXQoJ3Byb2dyZXNzJywgdG90YWxQcm9ncmVzcyAvIFRvbmUuQnVmZmVyLl9kb3dubG9hZFF1ZXVlLmxlbmd0aCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cdCAgICAgICAgcmVxdWVzdC5vcGVuKCdHRVQnLCBUb25lLkJ1ZmZlci5iYXNlVXJsICsgdXJsLCB0cnVlKTtcblx0ICAgICAgICByZXF1ZXN0LnJlc3BvbnNlVHlwZSA9ICdhcnJheWJ1ZmZlcic7XG5cdCAgICAgICAgLy9zdGFydCBvdXQgYXMgMFxuXHQgICAgICAgIHJlcXVlc3QucHJvZ3Jlc3MgPSAwO1xuXHQgICAgICAgIFRvbmUuQnVmZmVyLl9kb3dubG9hZFF1ZXVlLnB1c2gocmVxdWVzdCk7XG5cdCAgICAgICAgcmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICBpZiAocmVxdWVzdC5zdGF0dXMgPT09IDIwMCkge1xuXHQgICAgICAgICAgICAgICAgVG9uZS5jb250ZXh0LmRlY29kZUF1ZGlvRGF0YShyZXF1ZXN0LnJlc3BvbnNlLCBmdW5jdGlvbiAoYnVmZikge1xuXHQgICAgICAgICAgICAgICAgICAgIHJlcXVlc3QucHJvZ3Jlc3MgPSAxO1xuXHQgICAgICAgICAgICAgICAgICAgIG9uUHJvZ3Jlc3MoKTtcblx0ICAgICAgICAgICAgICAgICAgICBvbmxvYWQoYnVmZik7XG5cdCAgICAgICAgICAgICAgICAgICAgVG9uZS5CdWZmZXIuX3JlbW92ZUZyb21Eb3dubG9hZFF1ZXVlKHJlcXVlc3QpO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChUb25lLkJ1ZmZlci5fZG93bmxvYWRRdWV1ZS5sZW5ndGggPT09IDApIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy9lbWl0IHRoZSBldmVudCBhdCB0aGUgZW5kXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIFRvbmUuQnVmZmVyLmVtaXQoJ2xvYWQnKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgVG9uZS5CdWZmZXIuX3JlbW92ZUZyb21Eb3dubG9hZFF1ZXVlKHJlcXVlc3QpO1xuXHQgICAgICAgICAgICAgICAgICAgIG9uRXJyb3IoJ1RvbmUuQnVmZmVyOiBjb3VsZCBub3QgZGVjb2RlIGF1ZGlvIGRhdGE6ICcgKyB1cmwpO1xuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICBvbkVycm9yKCdUb25lLkJ1ZmZlcjogY291bGQgbm90IGxvY2F0ZSBmaWxlOiAnICsgdXJsKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIHJlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBvbkVycm9yKTtcblx0ICAgICAgICByZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoJ3Byb2dyZXNzJywgZnVuY3Rpb24gKGV2ZW50KSB7XG5cdCAgICAgICAgICAgIGlmIChldmVudC5sZW5ndGhDb21wdXRhYmxlKSB7XG5cdCAgICAgICAgICAgICAgICAvL29ubHkgZ28gdG8gOTUlLCB0aGUgbGFzdCA1JSBpcyB3aGVuIHRoZSBhdWRpbyBpcyBkZWNvZGVkXG5cdCAgICAgICAgICAgICAgICByZXF1ZXN0LnByb2dyZXNzID0gZXZlbnQubG9hZGVkIC8gZXZlbnQudG90YWwgKiAwLjk1O1xuXHQgICAgICAgICAgICAgICAgb25Qcm9ncmVzcygpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgcmVxdWVzdC5zZW5kKCk7XG5cdCAgICAgICAgcmV0dXJuIHJlcXVlc3Q7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFN0b3AgYWxsIG9mIHRoZSBkb3dubG9hZHMgaW4gcHJvZ3Jlc3Ncblx0XHQgKiAgQHJldHVybiB7VG9uZS5CdWZmZXJ9XG5cdFx0ICogIEBzdGF0aWNcblx0XHQgKi9cblx0ICAgIFRvbmUuQnVmZmVyLmNhbmNlbERvd25sb2FkcyA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLkJ1ZmZlci5fZG93bmxvYWRRdWV1ZS5zbGljZSgpLmZvckVhY2goZnVuY3Rpb24gKHJlcXVlc3QpIHtcblx0ICAgICAgICAgICAgVG9uZS5CdWZmZXIuX3JlbW92ZUZyb21Eb3dubG9hZFF1ZXVlKHJlcXVlc3QpO1xuXHQgICAgICAgICAgICByZXF1ZXN0LmFib3J0KCk7XG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgcmV0dXJuIFRvbmUuQnVmZmVyO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBDaGVja3MgYSB1cmwncyBleHRlbnNpb24gdG8gc2VlIGlmIHRoZSBjdXJyZW50IGJyb3dzZXIgY2FuIHBsYXkgdGhhdCBmaWxlIHR5cGUuXG5cdFx0ICogIEBwYXJhbSB7U3RyaW5nfSB1cmwgVGhlIHVybC9leHRlbnNpb24gdG8gdGVzdFxuXHRcdCAqICBAcmV0dXJuIHtCb29sZWFufSBJZiB0aGUgZmlsZSBleHRlbnNpb24gY2FuIGJlIHBsYXllZFxuXHRcdCAqICBAc3RhdGljXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogVG9uZS5CdWZmZXIuc3VwcG9ydHNUeXBlKFwid2F2XCIpOyAvL3JldHVybnMgdHJ1ZVxuXHRcdCAqIFRvbmUuQnVmZmVyLnN1cHBvcnRzVHlwZShcInBhdGgvdG8vZmlsZS53YXZcIik7IC8vcmV0dXJucyB0cnVlXG5cdFx0ICovXG5cdCAgICBUb25lLkJ1ZmZlci5zdXBwb3J0c1R5cGUgPSBmdW5jdGlvbiAodXJsKSB7XG5cdCAgICAgICAgdmFyIGV4dGVuc2lvbiA9IHVybC5zcGxpdCgnLicpO1xuXHQgICAgICAgIGV4dGVuc2lvbiA9IGV4dGVuc2lvbltleHRlbnNpb24ubGVuZ3RoIC0gMV07XG5cdCAgICAgICAgdmFyIHJlc3BvbnNlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYXVkaW8nKS5jYW5QbGF5VHlwZSgnYXVkaW8vJyArIGV4dGVuc2lvbik7XG5cdCAgICAgICAgcmV0dXJuIHJlc3BvbnNlICE9PSAnJztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgUmV0dXJucyBhIFByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgd2hlbiBhbGwgb2YgdGhlIGJ1ZmZlcnMgaGF2ZSBsb2FkZWRcblx0XHQgKiAgQHJldHVybiB7UHJvbWlzZX1cblx0XHQgKi9cblx0ICAgIFRvbmUubG9hZGVkID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBvbmxvYWQsIG9uZXJyb3I7XG5cdCAgICAgICAgZnVuY3Rpb24gcmVtb3ZlRXZlbnRzKCkge1xuXHQgICAgICAgICAgICAvL3JlbW92ZSB0aGUgZXZlbnRzIHdoZW4gaXQncyByZXNvbHZlZFxuXHQgICAgICAgICAgICBUb25lLkJ1ZmZlci5vZmYoJ2xvYWQnLCBvbmxvYWQpO1xuXHQgICAgICAgICAgICBUb25lLkJ1ZmZlci5vZmYoJ2Vycm9yJywgb25lcnJvcik7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoc3VjY2VzcywgZmFpbCkge1xuXHQgICAgICAgICAgICBvbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICBzdWNjZXNzKCk7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIG9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICBmYWlsKCk7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIC8vYWRkIHRoZSBldmVudCBsaXN0ZW5lcnNcblx0ICAgICAgICAgICAgVG9uZS5CdWZmZXIub24oJ2xvYWQnLCBvbmxvYWQpO1xuXHQgICAgICAgICAgICBUb25lLkJ1ZmZlci5vbignZXJyb3InLCBvbmVycm9yKTtcblx0ICAgICAgICB9KS50aGVuKHJlbW92ZUV2ZW50cykuY2F0Y2goZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgICAgICAgcmVtb3ZlRXZlbnRzKCk7XG5cdCAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlKTtcblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVG9uZS5CdWZmZXI7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgQSBkYXRhIHN0cnVjdHVyZSBmb3IgaG9sZGluZyBtdWx0aXBsZSBidWZmZXJzLlxuXHRcdCAqICBcblx0XHQgKiAgQHBhcmFtICB7T2JqZWN0fEFycmF5fSAgICB1cmxzICAgICAgQW4gb2JqZWN0IGxpdGVyYWwgb3IgYXJyYXlcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2YgdXJscyB0byBsb2FkLlxuXHRcdCAqICBAcGFyYW0gIHtGdW5jdGlvbj19ICBjYWxsYmFjayAgVGhlIGNhbGxiYWNrIHRvIGludm9rZSB3aGVuXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgYnVmZmVycyBhcmUgbG9hZGVkLiBcblx0XHQgKiAgQGV4dGVuZHMge1RvbmV9XG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogLy9sb2FkIGEgd2hvbGUgYmFuayBvZiBwaWFubyBzYW1wbGVzXG5cdFx0ICogdmFyIHBpYW5vU2FtcGxlcyA9IG5ldyBUb25lLkJ1ZmZlcnMoe1xuXHRcdCAqIFx0XCJDNFwiIDogXCJwYXRoL3RvL0M0Lm1wM1wiXG5cdFx0ICogXHRcIkMjNFwiIDogXCJwYXRoL3RvL0MjNC5tcDNcIlxuXHRcdCAqIFx0XCJENFwiIDogXCJwYXRoL3RvL0Q0Lm1wM1wiXG5cdFx0ICogXHRcIkQjNFwiIDogXCJwYXRoL3RvL0QjNC5tcDNcIlxuXHRcdCAqIFx0Li4uXG5cdFx0ICogfSwgZnVuY3Rpb24oKXtcblx0XHQgKiBcdC8vcGxheSBvbmUgb2YgdGhlIHNhbXBsZXMgd2hlbiB0aGV5IGFsbCBsb2FkXG5cdFx0ICogXHRwbGF5ZXIuYnVmZmVyID0gcGlhbm9TYW1wbGVzLmdldChcIkM0XCIpO1xuXHRcdCAqIFx0cGxheWVyLnN0YXJ0KCk7XG5cdFx0ICogfSk7XG5cdFx0ICogXHRAZXhhbXBsZVxuXHRcdCAqIC8vVG8gcGFzcyBpbiBhZGRpdGlvbmFsIHBhcmFtZXRlcnMgaW4gdGhlIHNlY29uZCBwYXJhbWV0ZXJcblx0XHQgKiB2YXIgYnVmZmVycyA9IG5ldyBUb25lLkJ1ZmZlcnModXJscywge1xuXHRcdCAqIFx0XCJvbmxvYWRcIiA6IGNhbGxiYWNrLFxuXHRcdCAqIFx0XCJiYXNlVXJsXCIgOiBcIi4uL3BhdGgvdG8vYXVkaW8vXCJcblx0XHQgKiB9KVxuXHRcdCAqL1xuXHQgICAgVG9uZS5CdWZmZXJzID0gZnVuY3Rpb24gKHVybHMpIHtcblx0ICAgICAgICAvL3JlbW92ZSB0aGUgdXJscyBmcm9tIHRoZSBvcHRpb25zXG5cdCAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuXHQgICAgICAgIGFyZ3Muc2hpZnQoKTtcblx0ICAgICAgICB2YXIgb3B0aW9ucyA9IFRvbmUuZGVmYXVsdHMoYXJncywgW1xuXHQgICAgICAgICAgICAnb25sb2FkJyxcblx0ICAgICAgICAgICAgJ2Jhc2VVcmwnXG5cdCAgICAgICAgXSwgVG9uZS5CdWZmZXJzKTtcblx0ICAgICAgICBUb25lLmNhbGwodGhpcyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgQWxsIG9mIHRoZSBidWZmZXJzXG5cdFx0XHQgKiAgQHR5cGUgIHtPYmplY3R9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2J1ZmZlcnMgPSB7fTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBBIHBhdGggd2hpY2ggaXMgcHJlZml4ZWQgYmVmb3JlIGV2ZXJ5IHVybC5cblx0XHRcdCAqICBAdHlwZSAge1N0cmluZ31cblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuYmFzZVVybCA9IG9wdGlvbnMuYmFzZVVybDtcblx0ICAgICAgICB0aGlzLl9sb2FkaW5nQ291bnQgPSAwO1xuXHQgICAgICAgIC8vYWRkIGVhY2ggb25lXG5cdCAgICAgICAgZm9yICh2YXIga2V5IGluIHVybHMpIHtcblx0ICAgICAgICAgICAgdGhpcy5fbG9hZGluZ0NvdW50Kys7XG5cdCAgICAgICAgICAgIHRoaXMuYWRkKGtleSwgdXJsc1trZXldLCB0aGlzLl9idWZmZXJMb2FkZWQuYmluZCh0aGlzLCBvcHRpb25zLm9ubG9hZCkpO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLkJ1ZmZlcnMpO1xuXHQgICAgLyoqXG5cdFx0ICogIERlZmF1bHRzXG5cdFx0ICogIEB0eXBlICB7T2JqZWN0fVxuXHRcdCAqL1xuXHQgICAgVG9uZS5CdWZmZXJzLmRlZmF1bHRzID0ge1xuXHQgICAgICAgICdvbmxvYWQnOiBUb25lLm5vT3AsXG5cdCAgICAgICAgJ2Jhc2VVcmwnOiAnJ1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBUcnVlIGlmIHRoZSBidWZmZXJzIG9iamVjdCBoYXMgYSBidWZmZXIgYnkgdGhhdCBuYW1lLlxuXHRcdCAqICBAcGFyYW0gIHtTdHJpbmd8TnVtYmVyfSAgbmFtZSAgVGhlIGtleSBvciBpbmRleCBvZiB0aGUgXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIuXG5cdFx0ICogIEByZXR1cm4gIHtCb29sZWFufVxuXHRcdCAqL1xuXHQgICAgVG9uZS5CdWZmZXJzLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiAobmFtZSkge1xuXHQgICAgICAgIHJldHVybiB0aGlzLl9idWZmZXJzLmhhc093blByb3BlcnR5KG5hbWUpO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBHZXQgYSBidWZmZXIgYnkgbmFtZS4gSWYgYW4gYXJyYXkgd2FzIGxvYWRlZCwgXG5cdFx0ICogIHRoZW4gdXNlIHRoZSBhcnJheSBpbmRleC5cblx0XHQgKiAgQHBhcmFtICB7U3RyaW5nfE51bWJlcn0gIG5hbWUgIFRoZSBrZXkgb3IgaW5kZXggb2YgdGhlIFxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyLlxuXHRcdCAqICBAcmV0dXJuICB7VG9uZS5CdWZmZXJ9XG5cdFx0ICovXG5cdCAgICBUb25lLkJ1ZmZlcnMucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChuYW1lKSB7XG5cdCAgICAgICAgaWYgKHRoaXMuaGFzKG5hbWUpKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9idWZmZXJzW25hbWVdO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVG9uZS5CdWZmZXJzOiBubyBidWZmZXIgbmFtZWQgJyArIG5hbWUpO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgQSBidWZmZXIgd2FzIGxvYWRlZC4gZGVjcmVtZW50IHRoZSBjb3VudGVyLlxuXHRcdCAqICBAcGFyYW0gIHtGdW5jdGlvbn0gIGNhbGxiYWNrIFxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5CdWZmZXJzLnByb3RvdHlwZS5fYnVmZmVyTG9hZGVkID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG5cdCAgICAgICAgdGhpcy5fbG9hZGluZ0NvdW50LS07XG5cdCAgICAgICAgaWYgKHRoaXMuX2xvYWRpbmdDb3VudCA9PT0gMCAmJiBjYWxsYmFjaykge1xuXHQgICAgICAgICAgICBjYWxsYmFjayh0aGlzKTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogSWYgdGhlIGJ1ZmZlcnMgYXJlIGxvYWRlZCBvciBub3Rcblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5CdWZmZXJzI1xuXHRcdCAqIEB0eXBlIHtCb29sZWFufVxuXHRcdCAqIEBuYW1lIGxvYWRlZFxuXHRcdCAqIEByZWFkT25seVxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuQnVmZmVycy5wcm90b3R5cGUsICdsb2FkZWQnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciBpc0xvYWRlZCA9IHRydWU7XG5cdCAgICAgICAgICAgIGZvciAodmFyIGJ1ZmZOYW1lIGluIHRoaXMuX2J1ZmZlcnMpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBidWZmID0gdGhpcy5nZXQoYnVmZk5hbWUpO1xuXHQgICAgICAgICAgICAgICAgaXNMb2FkZWQgPSBpc0xvYWRlZCAmJiBidWZmLmxvYWRlZDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gaXNMb2FkZWQ7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgQWRkIGEgYnVmZmVyIGJ5IG5hbWUgYW5kIHVybCB0byB0aGUgQnVmZmVyc1xuXHRcdCAqICBAcGFyYW0gIHtTdHJpbmd9ICAgIG5hbWUgICAgICBBIHVuaXF1ZSBuYW1lIHRvIGdpdmVcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIGJ1ZmZlclxuXHRcdCAqICBAcGFyYW0gIHtTdHJpbmd8VG9uZS5CdWZmZXJ8QXVkaW9idWZmZXJ9ICB1cmwgIEVpdGhlciB0aGUgdXJsIG9mIHRoZSBidWZlciwgXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3IgYSBidWZmZXIgd2hpY2ggd2lsbCBiZSBhZGRlZFxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpdGggdGhlIGdpdmVuIG5hbWUuXG5cdFx0ICogIEBwYXJhbSAge0Z1bmN0aW9uPX0gIGNhbGxiYWNrICBUaGUgY2FsbGJhY2sgdG8gaW52b2tlIFxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hlbiB0aGUgdXJsIGlzIGxvYWRlZC5cblx0XHQgKi9cblx0ICAgIFRvbmUuQnVmZmVycy5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKG5hbWUsIHVybCwgY2FsbGJhY2spIHtcblx0ICAgICAgICBjYWxsYmFjayA9IFRvbmUuZGVmYXVsdEFyZyhjYWxsYmFjaywgVG9uZS5ub09wKTtcblx0ICAgICAgICBpZiAodXJsIGluc3RhbmNlb2YgVG9uZS5CdWZmZXIpIHtcblx0ICAgICAgICAgICAgdGhpcy5fYnVmZmVyc1tuYW1lXSA9IHVybDtcblx0ICAgICAgICAgICAgY2FsbGJhY2sodGhpcyk7XG5cdCAgICAgICAgfSBlbHNlIGlmICh1cmwgaW5zdGFuY2VvZiBBdWRpb0J1ZmZlcikge1xuXHQgICAgICAgICAgICB0aGlzLl9idWZmZXJzW25hbWVdID0gbmV3IFRvbmUuQnVmZmVyKHVybCk7XG5cdCAgICAgICAgICAgIGNhbGxiYWNrKHRoaXMpO1xuXHQgICAgICAgIH0gZWxzZSBpZiAoVG9uZS5pc1N0cmluZyh1cmwpKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2J1ZmZlcnNbbmFtZV0gPSBuZXcgVG9uZS5CdWZmZXIodGhpcy5iYXNlVXJsICsgdXJsLCBjYWxsYmFjayk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBDbGVhbiB1cC5cblx0XHQgKiAgQHJldHVybiAge1RvbmUuQnVmZmVyc30gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5CdWZmZXJzLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICBmb3IgKHZhciBuYW1lIGluIHRoaXMuX2J1ZmZlcnMpIHtcblx0ICAgICAgICAgICAgdGhpcy5fYnVmZmVyc1tuYW1lXS5kaXNwb3NlKCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHRoaXMuX2J1ZmZlcnMgPSBudWxsO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLkJ1ZmZlcnM7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIGJ1c2VzIGFyZSBhbm90aGVyIHdheSBvZiByb3V0aW5nIGF1ZGlvXG5cdFx0ICpcblx0XHQgKiAgYXVnbWVudHMgVG9uZS5wcm90b3R5cGUgdG8gaW5jbHVkZSBzZW5kIGFuZCByZWNpZXZlXG5cdFx0ICovXG5cdCAgICAvKipcblx0XHQgICogIEFsbCBvZiB0aGUgcm91dGVzXG5cdFx0ICAqICBcblx0XHQgICogIEB0eXBlIHtPYmplY3R9XG5cdFx0ICAqICBAc3RhdGljXG5cdFx0ICAqICBAcHJpdmF0ZVxuXHRcdCAgKi9cblx0ICAgIHZhciBCdXNlcyA9IHt9O1xuXHQgICAgLyoqXG5cdFx0ICogIFNlbmQgdGhpcyBzaWduYWwgdG8gdGhlIGNoYW5uZWwgbmFtZS4gXG5cdFx0ICogIEBwYXJhbSAge1N0cmluZ30gY2hhbm5lbE5hbWUgQSBuYW1lZCBjaGFubmVsIHRvIHNlbmQgdGhlIHNpZ25hbCB0by5cblx0XHQgKiAgQHBhcmFtICB7RGVjaWJlbHN9IGFtb3VudCBUaGUgYW1vdW50IG9mIHRoZSBzb3VyY2UgdG8gc2VuZCB0byB0aGUgYnVzLiBcblx0XHQgKiAgQHJldHVybiB7R2Fpbk5vZGV9IFRoZSBnYWluIG5vZGUgd2hpY2ggY29ubmVjdHMgdGhpcyBub2RlIHRvIHRoZSBkZXNpcmVkIGNoYW5uZWwuIFxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgQ2FuIGJlIHVzZWQgdG8gYWRqdXN0IHRoZSBsZXZlbHMgb2YgdGhlIHNlbmQuXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogc291cmNlLnNlbmQoXCJyZXZlcmJcIiwgLTEyKTtcblx0XHQgKi9cblx0ICAgIFRvbmUucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbiAoY2hhbm5lbE5hbWUsIGFtb3VudCkge1xuXHQgICAgICAgIGlmICghQnVzZXMuaGFzT3duUHJvcGVydHkoY2hhbm5lbE5hbWUpKSB7XG5cdCAgICAgICAgICAgIEJ1c2VzW2NoYW5uZWxOYW1lXSA9IHRoaXMuY29udGV4dC5jcmVhdGVHYWluKCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGFtb3VudCA9IFRvbmUuZGVmYXVsdEFyZyhhbW91bnQsIDApO1xuXHQgICAgICAgIHZhciBzZW5kS25vYiA9IG5ldyBUb25lLkdhaW4oYW1vdW50LCBUb25lLlR5cGUuRGVjaWJlbHMpO1xuXHQgICAgICAgIHRoaXMub3V0cHV0LmNoYWluKHNlbmRLbm9iLCBCdXNlc1tjaGFubmVsTmFtZV0pO1xuXHQgICAgICAgIHJldHVybiBzZW5kS25vYjtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgUmVjaWV2ZSB0aGUgaW5wdXQgZnJvbSB0aGUgZGVzaXJlZCBjaGFubmVsTmFtZSB0byB0aGUgaW5wdXRcblx0XHQgKlxuXHRcdCAqICBAcGFyYW0gIHtTdHJpbmd9IGNoYW5uZWxOYW1lIEEgbmFtZWQgY2hhbm5lbCB0byBzZW5kIHRoZSBzaWduYWwgdG8uXG5cdFx0ICogIEBwYXJhbSAge051bWJlcj19IGNoYW5uZWxOdW1iZXIgVGhlIGNoYW5uZWwgdG8gY29ubmVjdCB0b1xuXHRcdCAqICBAcmV0dXJucyB7VG9uZX0gdGhpc1xuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIHJldmVyYkVmZmVjdC5yZWNlaXZlKFwicmV2ZXJiXCIpO1xuXHRcdCAqL1xuXHQgICAgVG9uZS5wcm90b3R5cGUucmVjZWl2ZSA9IGZ1bmN0aW9uIChjaGFubmVsTmFtZSwgaW5wdXROdW0pIHtcblx0ICAgICAgICBpZiAoIUJ1c2VzLmhhc093blByb3BlcnR5KGNoYW5uZWxOYW1lKSkge1xuXHQgICAgICAgICAgICBCdXNlc1tjaGFubmVsTmFtZV0gPSB0aGlzLmNvbnRleHQuY3JlYXRlR2FpbigpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBCdXNlc1tjaGFubmVsTmFtZV0uY29ubmVjdCh0aGlzLCAwLCBpbnB1dE51bSk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLy9yZW1vdmUgYWxsIHRoZSBzZW5kL3JlY2VpdmVzIHdoZW4gYSBuZXcgYXVkaW8gY29udGV4dCBpcyBwYXNzZWQgaW5cblx0ICAgIFRvbmUuQ29udGV4dC5vbignaW5pdCcsIGZ1bmN0aW9uIChjb250ZXh0KSB7XG5cdCAgICAgICAgaWYgKGNvbnRleHQuQnVzZXMpIHtcblx0ICAgICAgICAgICAgQnVzZXMgPSBjb250ZXh0LkJ1c2VzO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIEJ1c2VzID0ge307XG5cdCAgICAgICAgICAgIGNvbnRleHQuQnVzZXMgPSBCdXNlcztcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIHJldHVybiBUb25lO1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgVG9uZS5EcmF3IGlzIHVzZWZ1bCBmb3Igc3luY2hyb25pemluZyB2aXN1YWxzIGFuZCBhdWRpbyBldmVudHMuXG5cdFx0ICogICAgICAgICBDYWxsYmFja3MgZnJvbSBUb25lLlRyYW5zcG9ydCBvciBhbnkgb2YgdGhlIFRvbmUuRXZlbnQgY2xhc3Nlc1xuXHRcdCAqICAgICAgICAgYWx3YXlzIGhhcHBlbiBfYmVmb3JlXyB0aGUgc2NoZWR1bGVkIHRpbWUgYW5kIGFyZSBub3Qgc3luY2hyb25pemVkXG5cdFx0ICogICAgICAgICB0byB0aGUgYW5pbWF0aW9uIGZyYW1lIHNvIHRoZXkgYXJlIG5vdCBnb29kIGZvciB0cmlnZ2VyaW5nIHRpZ2h0bHlcblx0XHQgKiAgICAgICAgIHN5bmNocm9uaXplZCB2aXN1YWxzIGFuZCBzb3VuZC4gVG9uZS5EcmF3IG1ha2VzIGl0IGVhc3kgdG8gc2NoZWR1bGVcblx0XHQgKiAgICAgICAgIGNhbGxiYWNrcyB1c2luZyB0aGUgQXVkaW9Db250ZXh0IHRpbWUgYW5kIHVzZXMgcmVxdWVzdEFuaW1hdGlvbkZyYW1lLlxuXHRcdCAqICAgICAgICAgXG5cdFx0ICogIEBzaW5nbGV0b25cblx0XHQgKiAgQGV4dGVuZHMge1RvbmV9XG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogVG9uZS5UcmFuc3BvcnQuc2NoZWR1bGUoZnVuY3Rpb24odGltZSl7XG5cdFx0ICogXHQvL3VzZSB0aGUgdGltZSBhcmd1bWVudCB0byBzY2hlZHVsZSBhIGNhbGxiYWNrIHdpdGggVG9uZS5EcmF3XG5cdFx0ICogXHRUb25lLkRyYXcuc2NoZWR1bGUoZnVuY3Rpb24oKXtcblx0XHQgKiBcdFx0Ly9kbyBkcmF3aW5nIG9yIERPTSBtYW5pcHVsYXRpb24gaGVyZVxuXHRcdCAqIFx0fSwgdGltZSlcblx0XHQgKiB9LCBcIiswLjVcIilcblx0XHQgKi9cblx0ICAgIFRvbmUuRHJhdyA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLmNhbGwodGhpcyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgQWxsIG9mIHRoZSBldmVudHMuXG5cdFx0XHQgKiAgQHR5cGUgIHtUb25lLlRpbWVsaW5lfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9ldmVudHMgPSBuZXcgVG9uZS5UaW1lbGluZSgpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBkdXJhdGlvbiBhZnRlciB3aGljaCBldmVudHMgYXJlIG5vdCBpbnZva2VkLlxuXHRcdFx0ICogIEB0eXBlICB7TnVtYmVyfVxuXHRcdFx0ICogIEBkZWZhdWx0IDAuMjVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuZXhwaXJhdGlvbiA9IDAuMjU7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGFtb3VudCBvZiB0aW1lIGJlZm9yZSB0aGUgc2NoZWR1bGVkIHRpbWUgXG5cdFx0XHQgKiAgdGhhdCB0aGUgY2FsbGJhY2sgY2FuIGJlIGludm9rZWQuIERlZmF1bHQgaXNcblx0XHRcdCAqICBoYWxmIHRoZSB0aW1lIG9mIGFuIGFuaW1hdGlvbiBmcmFtZSAoMC4wMDggc2Vjb25kcykuXG5cdFx0XHQgKiAgQHR5cGUgIHtOdW1iZXJ9XG5cdFx0XHQgKiAgQGRlZmF1bHQgMC4wMDhcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuYW50aWNpcGF0aW9uID0gMC4wMDg7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGRyYXcgbG9vcFxuXHRcdFx0ICogIEB0eXBlICB7RnVuY3Rpb259XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2JvdW5kRHJhd0xvb3AgPSB0aGlzLl9kcmF3TG9vcC5iaW5kKHRoaXMpO1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuRHJhdyk7XG5cdCAgICAvKipcblx0XHQgKiAgU2NoZWR1bGUgYSBmdW5jdGlvbiBhdCB0aGUgZ2l2ZW4gdGltZSB0byBiZSBpbnZva2VkXG5cdFx0ICogIG9uIHRoZSBuZWFyZXN0IGFuaW1hdGlvbiBmcmFtZS5cblx0XHQgKiAgQHBhcmFtICB7RnVuY3Rpb259ICBjYWxsYmFjayAgQ2FsbGJhY2sgaXMgaW52b2tlZCBhdCB0aGUgZ2l2ZW4gdGltZS5cblx0XHQgKiAgQHBhcmFtICB7VGltZX0gICAgdGltZSAgICAgIFRoZSB0aW1lIHJlbGF0aXZlIHRvIHRoZSBBdWRpb0NvbnRleHQgdGltZVxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG8gaW52b2tlIHRoZSBjYWxsYmFjay5cblx0XHQgKiAgQHJldHVybiAge1RvbmUuRHJhd30gICAgdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5EcmF3LnByb3RvdHlwZS5zY2hlZHVsZSA9IGZ1bmN0aW9uIChjYWxsYmFjaywgdGltZSkge1xuXHQgICAgICAgIHRoaXMuX2V2ZW50cy5hZGQoe1xuXHQgICAgICAgICAgICBjYWxsYmFjazogY2FsbGJhY2ssXG5cdCAgICAgICAgICAgIHRpbWU6IHRoaXMudG9TZWNvbmRzKHRpbWUpXG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgLy9zdGFydCB0aGUgZHJhdyBsb29wIG9uIHRoZSBmaXJzdCBldmVudFxuXHQgICAgICAgIGlmICh0aGlzLl9ldmVudHMubGVuZ3RoID09PSAxKSB7XG5cdCAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLl9ib3VuZERyYXdMb29wKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIENhbmNlbCBldmVudHMgc2NoZWR1bGVkIGFmdGVyIHRoZSBnaXZlbiB0aW1lXG5cdFx0ICogIEBwYXJhbSAge1RpbWU9fSAgYWZ0ZXIgIFRpbWUgYWZ0ZXIgd2hpY2ggc2NoZWR1bGVkIGV2ZW50cyB3aWxsIFxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICBiZSByZW1vdmVkIGZyb20gdGhlIHNjaGVkdWxpbmcgdGltZWxpbmUuXG5cdFx0ICogIEByZXR1cm4gIHtUb25lLkRyYXd9ICB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkRyYXcucHJvdG90eXBlLmNhbmNlbCA9IGZ1bmN0aW9uIChhZnRlcikge1xuXHQgICAgICAgIHRoaXMuX2V2ZW50cy5jYW5jZWwodGhpcy50b1NlY29uZHMoYWZ0ZXIpKTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgVGhlIGRyYXcgbG9vcFxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5EcmF3LnByb3RvdHlwZS5fZHJhd0xvb3AgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIG5vdyA9IFRvbmUubm93KCk7XG5cdCAgICAgICAgd2hpbGUgKHRoaXMuX2V2ZW50cy5sZW5ndGggJiYgdGhpcy5fZXZlbnRzLnBlZWsoKS50aW1lIC0gdGhpcy5hbnRpY2lwYXRpb24gPD0gbm93KSB7XG5cdCAgICAgICAgICAgIHZhciBldmVudCA9IHRoaXMuX2V2ZW50cy5zaGlmdCgpO1xuXHQgICAgICAgICAgICBpZiAobm93IC0gZXZlbnQudGltZSA8PSB0aGlzLmV4cGlyYXRpb24pIHtcblx0ICAgICAgICAgICAgICAgIGV2ZW50LmNhbGxiYWNrKCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKHRoaXMuX2V2ZW50cy5sZW5ndGggPiAwKSB7XG5cdCAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLl9ib3VuZERyYXdMb29wKTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgLy9tYWtlIGEgc2luZ2xldG9uXG5cdCAgICBUb25lLkRyYXcgPSBuZXcgVG9uZS5EcmF3KCk7XG5cdCAgICByZXR1cm4gVG9uZS5EcmF3O1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgIEJvdGggVG9uZS5QYW5uZXIzRCBhbmQgVG9uZS5MaXN0ZW5lciBoYXZlIGEgcG9zaXRpb24gaW4gM0Qgc3BhY2UgXG5cdFx0ICogICAgICAgICAgdXNpbmcgYSByaWdodC1oYW5kZWQgY2FydGVzaWFuIGNvb3JkaW5hdGUgc3lzdGVtLiBcblx0XHQgKiAgICAgICAgICBUaGUgdW5pdHMgdXNlZCBpbiB0aGUgY29vcmRpbmF0ZSBzeXN0ZW0gYXJlIG5vdCBkZWZpbmVkOyBcblx0XHQgKiAgICAgICAgICB0aGVzZSBjb29yZGluYXRlcyBhcmUgaW5kZXBlbmRlbnQvaW52YXJpYW50IG9mIGFueSBwYXJ0aWN1bGFyIFxuXHRcdCAqICAgICAgICAgIHVuaXRzIHN1Y2ggYXMgbWV0ZXJzIG9yIGZlZXQuIFRvbmUuUGFubmVyM0Qgb2JqZWN0cyBoYXZlIGFuIGZvcndhcmQgXG5cdFx0ICogICAgICAgICAgdmVjdG9yIHJlcHJlc2VudGluZyB0aGUgZGlyZWN0aW9uIHRoZSBzb3VuZCBpcyBwcm9qZWN0aW5nLiBBZGRpdGlvbmFsbHksIFxuXHRcdCAqICAgICAgICAgIHRoZXkgaGF2ZSBhIHNvdW5kIGNvbmUgcmVwcmVzZW50aW5nIGhvdyBkaXJlY3Rpb25hbCB0aGUgc291bmQgaXMuIFxuXHRcdCAqICAgICAgICAgIEZvciBleGFtcGxlLCB0aGUgc291bmQgY291bGQgYmUgb21uaWRpcmVjdGlvbmFsLCBpbiB3aGljaCBjYXNlIGl0IHdvdWxkIFxuXHRcdCAqICAgICAgICAgIGJlIGhlYXJkIGFueXdoZXJlIHJlZ2FyZGxlc3Mgb2YgaXRzIGZvcndhcmQsIG9yIGl0IGNhbiBiZSBtb3JlIGRpcmVjdGlvbmFsIFxuXHRcdCAqICAgICAgICAgIGFuZCBoZWFyZCBvbmx5IGlmIGl0IGlzIGZhY2luZyB0aGUgbGlzdGVuZXIuIFRvbmUuTGlzdGVuZXIgb2JqZWN0cyBcblx0XHQgKiAgICAgICAgICAocmVwcmVzZW50aW5nIGEgcGVyc29uJ3MgZWFycykgaGF2ZSBhbiBmb3J3YXJkIGFuZCB1cCB2ZWN0b3IgXG5cdFx0ICogICAgICAgICAgcmVwcmVzZW50aW5nIGluIHdoaWNoIGRpcmVjdGlvbiB0aGUgcGVyc29uIGlzIGZhY2luZy4gQmVjYXVzZSBib3RoIHRoZSBcblx0XHQgKiAgICAgICAgICBzb3VyY2Ugc3RyZWFtIGFuZCB0aGUgbGlzdGVuZXIgY2FuIGJlIG1vdmluZywgdGhleSBib3RoIGhhdmUgYSB2ZWxvY2l0eSBcblx0XHQgKiAgICAgICAgICB2ZWN0b3IgcmVwcmVzZW50aW5nIGJvdGggdGhlIHNwZWVkIGFuZCBkaXJlY3Rpb24gb2YgbW92ZW1lbnQuIFRha2VuIHRvZ2V0aGVyLCBcblx0XHQgKiAgICAgICAgICB0aGVzZSB0d28gdmVsb2NpdGllcyBjYW4gYmUgdXNlZCB0byBnZW5lcmF0ZSBhIGRvcHBsZXIgc2hpZnQgZWZmZWN0IHdoaWNoIGNoYW5nZXMgdGhlIHBpdGNoLlxuXHRcdCAqICAgICAgICAgIDxicj48YnI+XG5cdFx0ICogICAgICAgICAgTm90ZTogdGhlIHBvc2l0aW9uIG9mIHRoZSBMaXN0ZW5lciB3aWxsIGhhdmUgbm8gZWZmZWN0IG9uIG5vZGVzIG5vdCBjb25uZWN0ZWQgdG8gYSBUb25lLlBhbm5lcjNEXG5cdFx0ICogIFxuXHRcdCAqICBAY29uc3RydWN0b3Jcblx0XHQgKiAgQGV4dGVuZHMge1RvbmV9XG5cdFx0ICogIEBzaW5nbGV0b25cblx0XHQgKi9cblx0ICAgIFRvbmUuTGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIEhvbGRzIHRoZSBjdXJyZW50IGZvcndhcmQgb3JpZW50YXRpb25cblx0XHRcdCAqICBAdHlwZSAge0FycmF5fVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9vcmllbnRhdGlvbiA9IFtcblx0ICAgICAgICAgICAgMCxcblx0ICAgICAgICAgICAgMCxcblx0ICAgICAgICAgICAgMCxcblx0ICAgICAgICAgICAgMCxcblx0ICAgICAgICAgICAgMCxcblx0ICAgICAgICAgICAgMFxuXHQgICAgICAgIF07XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgSG9sZHMgdGhlIGN1cnJlbnQgcG9zaXRpb25cblx0XHRcdCAqICBAdHlwZSAge0FycmF5fVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9wb3NpdGlvbiA9IFtcblx0ICAgICAgICAgICAgMCxcblx0ICAgICAgICAgICAgMCxcblx0ICAgICAgICAgICAgMFxuXHQgICAgICAgIF07XG5cdCAgICAgICAgVG9uZS5nZXRDb250ZXh0KGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgLy8gc2V0IHRoZSBkZWZhdWx0IHBvc2l0aW9uL2ZvcndhcmRcblx0ICAgICAgICAgICAgdGhpcy5zZXQoTGlzdGVuZXJDb25zdHJ1Y3Rvci5kZWZhdWx0cyk7XG5cdCAgICAgICAgfS5iaW5kKHRoaXMpKTtcblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLkxpc3RlbmVyKTtcblx0ICAgIC8qKlxuXHRcdCAqICBEZWZhdWx0cyBhY2NvcmRpbmcgdG8gdGhlIHNwZWNpZmljYXRpb25cblx0XHQgKiAgQHN0YXRpY1xuXHRcdCAqICBAY29uc3Rcblx0XHQgKiAgQHR5cGUge09iamVjdH1cblx0XHQgKi9cblx0ICAgIFRvbmUuTGlzdGVuZXIuZGVmYXVsdHMgPSB7XG5cdCAgICAgICAgJ3Bvc2l0aW9uWCc6IDAsXG5cdCAgICAgICAgJ3Bvc2l0aW9uWSc6IDAsXG5cdCAgICAgICAgJ3Bvc2l0aW9uWic6IDAsXG5cdCAgICAgICAgJ2ZvcndhcmRYJzogMCxcblx0ICAgICAgICAnZm9yd2FyZFknOiAwLFxuXHQgICAgICAgICdmb3J3YXJkWic6IDEsXG5cdCAgICAgICAgJ3VwWCc6IDAsXG5cdCAgICAgICAgJ3VwWSc6IDEsXG5cdCAgICAgICAgJ3VwWic6IDBcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiBUaGUgcmFtcCB0aW1lIHdoaWNoIGlzIGFwcGxpZWQgdG8gdGhlIHNldFRhcmdldEF0VGltZVxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuTGlzdGVuZXIucHJvdG90eXBlLl9yYW1wVGltZUNvbnN0YW50ID0gMC4wMTtcblx0ICAgIC8qKlxuXHRcdCAqICBTZXRzIHRoZSBwb3NpdGlvbiBvZiB0aGUgbGlzdGVuZXIgaW4gM2Qgc3BhY2UuXHRcblx0XHQgKiAgQHBhcmFtICB7TnVtYmVyfSAgeFxuXHRcdCAqICBAcGFyYW0gIHtOdW1iZXJ9ICB5XG5cdFx0ICogIEBwYXJhbSAge051bWJlcn0gIHpcblx0XHQgKiAgQHJldHVybiB7VG9uZS5MaXN0ZW5lcn0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5MaXN0ZW5lci5wcm90b3R5cGUuc2V0UG9zaXRpb24gPSBmdW5jdGlvbiAoeCwgeSwgeikge1xuXHQgICAgICAgIGlmICh0aGlzLmNvbnRleHQubGlzdGVuZXIucG9zaXRpb25YKSB7XG5cdCAgICAgICAgICAgIHZhciBub3cgPSB0aGlzLm5vdygpO1xuXHQgICAgICAgICAgICB0aGlzLmNvbnRleHQubGlzdGVuZXIucG9zaXRpb25YLnNldFRhcmdldEF0VGltZSh4LCBub3csIHRoaXMuX3JhbXBUaW1lQ29uc3RhbnQpO1xuXHQgICAgICAgICAgICB0aGlzLmNvbnRleHQubGlzdGVuZXIucG9zaXRpb25ZLnNldFRhcmdldEF0VGltZSh5LCBub3csIHRoaXMuX3JhbXBUaW1lQ29uc3RhbnQpO1xuXHQgICAgICAgICAgICB0aGlzLmNvbnRleHQubGlzdGVuZXIucG9zaXRpb25aLnNldFRhcmdldEF0VGltZSh6LCBub3csIHRoaXMuX3JhbXBUaW1lQ29uc3RhbnQpO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIHRoaXMuY29udGV4dC5saXN0ZW5lci5zZXRQb3NpdGlvbih4LCB5LCB6KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdGhpcy5fcG9zaXRpb24gPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBTZXRzIHRoZSBvcmllbnRhdGlvbiBvZiB0aGUgbGlzdGVuZXIgdXNpbmcgdHdvIHZlY3RvcnMsIHRoZSBmb3J3YXJkXG5cdFx0ICogIHZlY3RvciAod2hpY2ggZGlyZWN0aW9uIHRoZSBsaXN0ZW5lciBpcyBmYWNpbmcpIGFuZCB0aGUgdXAgdmVjdG9yIFxuXHRcdCAqICAod2hpY2ggdGhlIHVwIGRpcmVjdGlvbiBvZiB0aGUgbGlzdGVuZXIpLiBBbiB1cCB2ZWN0b3Jcblx0XHQgKiAgb2YgMCwgMCwgMSBpcyBlcXVpdmFsZW50IHRvIHRoZSBsaXN0ZW5lciBzdGFuZGluZyB1cCBpbiB0aGUgWiBkaXJlY3Rpb24uIFxuXHRcdCAqICBAcGFyYW0gIHtOdW1iZXJ9ICB4XG5cdFx0ICogIEBwYXJhbSAge051bWJlcn0gIHlcblx0XHQgKiAgQHBhcmFtICB7TnVtYmVyfSAgelxuXHRcdCAqICBAcGFyYW0gIHtOdW1iZXJ9ICB1cFhcblx0XHQgKiAgQHBhcmFtICB7TnVtYmVyfSAgdXBZXG5cdFx0ICogIEBwYXJhbSAge051bWJlcn0gIHVwWlxuXHRcdCAqICBAcmV0dXJuIHtUb25lLkxpc3RlbmVyfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkxpc3RlbmVyLnByb3RvdHlwZS5zZXRPcmllbnRhdGlvbiA9IGZ1bmN0aW9uICh4LCB5LCB6LCB1cFgsIHVwWSwgdXBaKSB7XG5cdCAgICAgICAgaWYgKHRoaXMuY29udGV4dC5saXN0ZW5lci5mb3J3YXJkWCkge1xuXHQgICAgICAgICAgICB2YXIgbm93ID0gdGhpcy5ub3coKTtcblx0ICAgICAgICAgICAgdGhpcy5jb250ZXh0Lmxpc3RlbmVyLmZvcndhcmRYLnNldFRhcmdldEF0VGltZSh4LCBub3csIHRoaXMuX3JhbXBUaW1lQ29uc3RhbnQpO1xuXHQgICAgICAgICAgICB0aGlzLmNvbnRleHQubGlzdGVuZXIuZm9yd2FyZFkuc2V0VGFyZ2V0QXRUaW1lKHksIG5vdywgdGhpcy5fcmFtcFRpbWVDb25zdGFudCk7XG5cdCAgICAgICAgICAgIHRoaXMuY29udGV4dC5saXN0ZW5lci5mb3J3YXJkWi5zZXRUYXJnZXRBdFRpbWUoeiwgbm93LCB0aGlzLl9yYW1wVGltZUNvbnN0YW50KTtcblx0ICAgICAgICAgICAgdGhpcy5jb250ZXh0Lmxpc3RlbmVyLnVwWC5zZXRUYXJnZXRBdFRpbWUodXBYLCBub3csIHRoaXMuX3JhbXBUaW1lQ29uc3RhbnQpO1xuXHQgICAgICAgICAgICB0aGlzLmNvbnRleHQubGlzdGVuZXIudXBZLnNldFRhcmdldEF0VGltZSh1cFksIG5vdywgdGhpcy5fcmFtcFRpbWVDb25zdGFudCk7XG5cdCAgICAgICAgICAgIHRoaXMuY29udGV4dC5saXN0ZW5lci51cFouc2V0VGFyZ2V0QXRUaW1lKHVwWiwgbm93LCB0aGlzLl9yYW1wVGltZUNvbnN0YW50KTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICB0aGlzLmNvbnRleHQubGlzdGVuZXIuc2V0T3JpZW50YXRpb24oeCwgeSwgeiwgdXBYLCB1cFksIHVwWik7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHRoaXMuX29yaWVudGF0aW9uID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgVGhlIHggcG9zaXRpb24gb2YgdGhlIHBhbm5lciBvYmplY3QuXG5cdFx0ICogIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogIEBtZW1iZXJPZiBUb25lLkxpc3RlbmVyI1xuXHRcdCAqICBAbmFtZSBwb3NpdGlvblhcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkxpc3RlbmVyLnByb3RvdHlwZSwgJ3Bvc2l0aW9uWCcsIHtcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChwb3MpIHtcblx0ICAgICAgICAgICAgdGhpcy5fcG9zaXRpb25bMF0gPSBwb3M7XG5cdCAgICAgICAgICAgIHRoaXMuc2V0UG9zaXRpb24uYXBwbHkodGhpcywgdGhpcy5fcG9zaXRpb24pO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9wb3NpdGlvblswXTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgeSBwb3NpdGlvbiBvZiB0aGUgcGFubmVyIG9iamVjdC5cblx0XHQgKiAgQHR5cGUge051bWJlcn1cblx0XHQgKiAgQG1lbWJlck9mIFRvbmUuTGlzdGVuZXIjXG5cdFx0ICogIEBuYW1lIHBvc2l0aW9uWVxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuTGlzdGVuZXIucHJvdG90eXBlLCAncG9zaXRpb25ZJywge1xuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKHBvcykge1xuXHQgICAgICAgICAgICB0aGlzLl9wb3NpdGlvblsxXSA9IHBvcztcblx0ICAgICAgICAgICAgdGhpcy5zZXRQb3NpdGlvbi5hcHBseSh0aGlzLCB0aGlzLl9wb3NpdGlvbik7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Bvc2l0aW9uWzFdO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIFRoZSB6IHBvc2l0aW9uIG9mIHRoZSBwYW5uZXIgb2JqZWN0LlxuXHRcdCAqICBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqICBAbWVtYmVyT2YgVG9uZS5MaXN0ZW5lciNcblx0XHQgKiAgQG5hbWUgcG9zaXRpb25aXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5MaXN0ZW5lci5wcm90b3R5cGUsICdwb3NpdGlvblonLCB7XG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAocG9zKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3Bvc2l0aW9uWzJdID0gcG9zO1xuXHQgICAgICAgICAgICB0aGlzLnNldFBvc2l0aW9uLmFwcGx5KHRoaXMsIHRoaXMuX3Bvc2l0aW9uKTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fcG9zaXRpb25bMl07XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgVGhlIHggY29vcmRpbmF0ZSBvZiB0aGUgbGlzdGVuZXJzIGZyb250IGRpcmVjdGlvbi4gaS5lLiBcblx0XHQgKiAgd2hpY2ggd2F5IHRoZXkgYXJlIGZhY2luZy5cblx0XHQgKiAgQHR5cGUge051bWJlcn1cblx0XHQgKiAgQG1lbWJlck9mIFRvbmUuTGlzdGVuZXIjXG5cdFx0ICogIEBuYW1lIGZvcndhcmRYXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5MaXN0ZW5lci5wcm90b3R5cGUsICdmb3J3YXJkWCcsIHtcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChwb3MpIHtcblx0ICAgICAgICAgICAgdGhpcy5fb3JpZW50YXRpb25bMF0gPSBwb3M7XG5cdCAgICAgICAgICAgIHRoaXMuc2V0T3JpZW50YXRpb24uYXBwbHkodGhpcywgdGhpcy5fb3JpZW50YXRpb24pO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9vcmllbnRhdGlvblswXTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgeSBjb29yZGluYXRlIG9mIHRoZSBsaXN0ZW5lcnMgZnJvbnQgZGlyZWN0aW9uLiBpLmUuIFxuXHRcdCAqICB3aGljaCB3YXkgdGhleSBhcmUgZmFjaW5nLlxuXHRcdCAqICBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqICBAbWVtYmVyT2YgVG9uZS5MaXN0ZW5lciNcblx0XHQgKiAgQG5hbWUgZm9yd2FyZFlcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkxpc3RlbmVyLnByb3RvdHlwZSwgJ2ZvcndhcmRZJywge1xuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKHBvcykge1xuXHQgICAgICAgICAgICB0aGlzLl9vcmllbnRhdGlvblsxXSA9IHBvcztcblx0ICAgICAgICAgICAgdGhpcy5zZXRPcmllbnRhdGlvbi5hcHBseSh0aGlzLCB0aGlzLl9vcmllbnRhdGlvbik7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX29yaWVudGF0aW9uWzFdO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIFRoZSB6IGNvb3JkaW5hdGUgb2YgdGhlIGxpc3RlbmVycyBmcm9udCBkaXJlY3Rpb24uIGkuZS4gXG5cdFx0ICogIHdoaWNoIHdheSB0aGV5IGFyZSBmYWNpbmcuXG5cdFx0ICogIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogIEBtZW1iZXJPZiBUb25lLkxpc3RlbmVyI1xuXHRcdCAqICBAbmFtZSBmb3J3YXJkWlxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuTGlzdGVuZXIucHJvdG90eXBlLCAnZm9yd2FyZFonLCB7XG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAocG9zKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX29yaWVudGF0aW9uWzJdID0gcG9zO1xuXHQgICAgICAgICAgICB0aGlzLnNldE9yaWVudGF0aW9uLmFwcGx5KHRoaXMsIHRoaXMuX29yaWVudGF0aW9uKTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fb3JpZW50YXRpb25bMl07XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgVGhlIHggY29vcmRpbmF0ZSBvZiB0aGUgbGlzdGVuZXIncyB1cCBkaXJlY3Rpb24uIGkuZS5cblx0XHQgKiAgdGhlIGRpcmVjdGlvbiB0aGUgbGlzdGVuZXIgaXMgc3RhbmRpbmcgaW4uXG5cdFx0ICogIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogIEBtZW1iZXJPZiBUb25lLkxpc3RlbmVyI1xuXHRcdCAqICBAbmFtZSB1cFhcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkxpc3RlbmVyLnByb3RvdHlwZSwgJ3VwWCcsIHtcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChwb3MpIHtcblx0ICAgICAgICAgICAgdGhpcy5fb3JpZW50YXRpb25bM10gPSBwb3M7XG5cdCAgICAgICAgICAgIHRoaXMuc2V0T3JpZW50YXRpb24uYXBwbHkodGhpcywgdGhpcy5fb3JpZW50YXRpb24pO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9vcmllbnRhdGlvblszXTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgeSBjb29yZGluYXRlIG9mIHRoZSBsaXN0ZW5lcidzIHVwIGRpcmVjdGlvbi4gaS5lLlxuXHRcdCAqICB0aGUgZGlyZWN0aW9uIHRoZSBsaXN0ZW5lciBpcyBzdGFuZGluZyBpbi5cblx0XHQgKiAgQHR5cGUge051bWJlcn1cblx0XHQgKiAgQG1lbWJlck9mIFRvbmUuTGlzdGVuZXIjXG5cdFx0ICogIEBuYW1lIHVwWVxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuTGlzdGVuZXIucHJvdG90eXBlLCAndXBZJywge1xuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKHBvcykge1xuXHQgICAgICAgICAgICB0aGlzLl9vcmllbnRhdGlvbls0XSA9IHBvcztcblx0ICAgICAgICAgICAgdGhpcy5zZXRPcmllbnRhdGlvbi5hcHBseSh0aGlzLCB0aGlzLl9vcmllbnRhdGlvbik7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX29yaWVudGF0aW9uWzRdO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIFRoZSB6IGNvb3JkaW5hdGUgb2YgdGhlIGxpc3RlbmVyJ3MgdXAgZGlyZWN0aW9uLiBpLmUuXG5cdFx0ICogIHRoZSBkaXJlY3Rpb24gdGhlIGxpc3RlbmVyIGlzIHN0YW5kaW5nIGluLlxuXHRcdCAqICBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqICBAbWVtYmVyT2YgVG9uZS5MaXN0ZW5lciNcblx0XHQgKiAgQG5hbWUgdXBaXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5MaXN0ZW5lci5wcm90b3R5cGUsICd1cFonLCB7XG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAocG9zKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX29yaWVudGF0aW9uWzVdID0gcG9zO1xuXHQgICAgICAgICAgICB0aGlzLnNldE9yaWVudGF0aW9uLmFwcGx5KHRoaXMsIHRoaXMuX29yaWVudGF0aW9uKTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fb3JpZW50YXRpb25bNV07XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgQ2xlYW4gdXAuXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLkxpc3RlbmVyfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkxpc3RlbmVyLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHRoaXMuX29yaWVudGF0aW9uID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9wb3NpdGlvbiA9IG51bGw7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLy9TSU5HTEVUT04gU0VUVVBcblx0ICAgIHZhciBMaXN0ZW5lckNvbnN0cnVjdG9yID0gVG9uZS5MaXN0ZW5lcjtcblx0ICAgIFRvbmUuTGlzdGVuZXIgPSBuZXcgTGlzdGVuZXJDb25zdHJ1Y3RvcigpO1xuXHQgICAgVG9uZS5Db250ZXh0Lm9uKCdpbml0JywgZnVuY3Rpb24gKGNvbnRleHQpIHtcblx0ICAgICAgICBpZiAoY29udGV4dC5MaXN0ZW5lciBpbnN0YW5jZW9mIExpc3RlbmVyQ29uc3RydWN0b3IpIHtcblx0ICAgICAgICAgICAgLy9hIHNpbmdsZSBsaXN0ZW5lciBvYmplY3Rcblx0ICAgICAgICAgICAgVG9uZS5MaXN0ZW5lciA9IGNvbnRleHQuTGlzdGVuZXI7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgLy9tYWtlIG5ldyBMaXN0ZW5lciBpbnNpZGVzXG5cdCAgICAgICAgICAgIFRvbmUuTGlzdGVuZXIgPSBuZXcgTGlzdGVuZXJDb25zdHJ1Y3RvcigpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBjb250ZXh0Lkxpc3RlbmVyID0gVG9uZS5MaXN0ZW5lcjtcblx0ICAgIH0pO1xuXHQgICAgLy9FTkQgU0lOR0xFVE9OIFNFVFVQXG5cdCAgICByZXR1cm4gVG9uZS5MaXN0ZW5lcjtcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgLyoqXG5cdFx0ICogIHNoaW1cblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIGlmICghd2luZG93Lmhhc093blByb3BlcnR5KCdPZmZsaW5lQXVkaW9Db250ZXh0JykgJiYgd2luZG93Lmhhc093blByb3BlcnR5KCd3ZWJraXRPZmZsaW5lQXVkaW9Db250ZXh0JykpIHtcblx0ICAgICAgICB3aW5kb3cuT2ZmbGluZUF1ZGlvQ29udGV4dCA9IHdpbmRvdy53ZWJraXRPZmZsaW5lQXVkaW9Db250ZXh0O1xuXHQgICAgfVxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyBXcmFwcGVyIGFyb3VuZCB0aGUgT2ZmbGluZUF1ZGlvQ29udGV4dFxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZS5Db250ZXh0fVxuXHRcdCAqICBAcGFyYW0gIHtOdW1iZXJ9ICBjaGFubmVscyAgVGhlIG51bWJlciBvZiBjaGFubmVscyB0byByZW5kZXJcblx0XHQgKiAgQHBhcmFtICB7TnVtYmVyfSAgZHVyYXRpb24gIFRoZSBkdXJhdGlvbiB0byByZW5kZXIgaW4gc2FtcGxlc1xuXHRcdCAqICBAcGFyYW0ge051bWJlcn0gc2FtcGxlUmF0ZSB0aGUgc2FtcGxlIHJhdGUgdG8gcmVuZGVyIGF0XG5cdFx0ICovXG5cdCAgICBUb25lLk9mZmxpbmVDb250ZXh0ID0gZnVuY3Rpb24gKGNoYW5uZWxzLCBkdXJhdGlvbiwgc2FtcGxlUmF0ZSkge1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBvZmZsaW5lIGNvbnRleHRcblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICogIEB0eXBlICB7T2ZmbGluZUF1ZGlvQ29udGV4dH1cblx0XHRcdCAqL1xuXHQgICAgICAgIHZhciBvZmZsaW5lQ29udGV4dCA9IG5ldyBPZmZsaW5lQXVkaW9Db250ZXh0KGNoYW5uZWxzLCBkdXJhdGlvbiAqIHNhbXBsZVJhdGUsIHNhbXBsZVJhdGUpO1xuXHQgICAgICAgIC8vd3JhcCB0aGUgbWV0aG9kcy9tZW1iZXJzXG5cdCAgICAgICAgVG9uZS5Db250ZXh0LmNhbGwodGhpcywge1xuXHQgICAgICAgICAgICAnY29udGV4dCc6IG9mZmxpbmVDb250ZXh0LFxuXHQgICAgICAgICAgICAnY2xvY2tTb3VyY2UnOiAnb2ZmbGluZScsXG5cdCAgICAgICAgICAgICdsb29rQWhlYWQnOiAwLFxuXHQgICAgICAgICAgICAndXBkYXRlSW50ZXJ2YWwnOiAxMjggLyBzYW1wbGVSYXRlXG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgQSBwcml2YXRlIHJlZmVyZW5jZSB0byB0aGUgZHVyYXRpb25cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICogIEB0eXBlICB7TnVtYmVyfVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fZHVyYXRpb24gPSBkdXJhdGlvbjtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBBbiBhcnRpZmljaWFsIGNsb2NrIHNvdXJjZVxuXHRcdFx0ICogIEB0eXBlICB7TnVtYmVyfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9jdXJyZW50VGltZSA9IDA7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5PZmZsaW5lQ29udGV4dCwgVG9uZS5Db250ZXh0KTtcblx0ICAgIC8qKlxuXHRcdCAqICBPdmVycmlkZSB0aGUgbm93IG1ldGhvZCB0byBwb2ludCB0byB0aGUgaW50ZXJuYWwgY2xvY2sgdGltZVxuXHRcdCAqICBAcmV0dXJuICB7TnVtYmVyfVxuXHRcdCAqL1xuXHQgICAgVG9uZS5PZmZsaW5lQ29udGV4dC5wcm90b3R5cGUubm93ID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHJldHVybiB0aGlzLl9jdXJyZW50VGltZTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgUmVuZGVyIHRoZSBvdXRwdXQgb2YgdGhlIE9mZmxpbmVDb250ZXh0XG5cdFx0ICogIEByZXR1cm4gIHtQcm9taXNlfVxuXHRcdCAqL1xuXHQgICAgVG9uZS5PZmZsaW5lQ29udGV4dC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHdoaWxlICh0aGlzLl9kdXJhdGlvbiAtIHRoaXMuX2N1cnJlbnRUaW1lID49IDApIHtcblx0ICAgICAgICAgICAgLy9pbnZva2UgYWxsIHRoZSBjYWxsYmFja3Mgb24gdGhhdCB0aW1lXG5cdCAgICAgICAgICAgIHRoaXMuZW1pdCgndGljaycpO1xuXHQgICAgICAgICAgICAvL2luY3JlbWVudCB0aGUgY2xvY2tcblx0ICAgICAgICAgICAgdGhpcy5fY3VycmVudFRpbWUgKz0gdGhpcy5ibG9ja1RpbWU7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8vcHJvbWlzZSByZXR1cm5lZCBpcyBub3QgeWV0IGltcGxlbWVudGVkIGluIGFsbCBicm93c2Vyc1xuXHQgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoZG9uZSkge1xuXHQgICAgICAgICAgICB0aGlzLl9jb250ZXh0Lm9uY29tcGxldGUgPSBmdW5jdGlvbiAoZSkge1xuXHQgICAgICAgICAgICAgICAgZG9uZShlLnJlbmRlcmVkQnVmZmVyKTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgdGhpcy5fY29udGV4dC5zdGFydFJlbmRlcmluZygpO1xuXHQgICAgICAgIH0uYmluZCh0aGlzKSk7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIENsb3NlIHRoZSBjb250ZXh0XG5cdFx0ICogIEByZXR1cm4gIHtOdW1iZXJ9XG5cdFx0ICovXG5cdCAgICBUb25lLk9mZmxpbmVDb250ZXh0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB0aGlzLl9jb250ZXh0ID0gbnVsbDtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVG9uZS5PZmZsaW5lQ29udGV4dDtcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgLyoqXG5cdFx0ICogIEdlbmVyYXRlIGEgYnVmZmVyIGJ5IHJlbmRlcmluZyBhbGwgb2YgdGhlIFRvbmUuanMgY29kZSB3aXRoaW4gdGhlIGNhbGxiYWNrIHVzaW5nIHRoZSBPZmZsaW5lQXVkaW9Db250ZXh0LiBcblx0XHQgKiAgVGhlIE9mZmxpbmVBdWRpb0NvbnRleHQgaXMgY2FwYWJsZSBvZiByZW5kZXJpbmcgbXVjaCBmYXN0ZXIgdGhhbiByZWFsIHRpbWUgaW4gbWFueSBjYXNlcy4gXG5cdFx0ICogIFRoZSBjYWxsYmFjayBmdW5jdGlvbiBhbHNvIHBhc3NlcyBpbiBhbiBvZmZsaW5lIGluc3RhbmNlIG9mIFRvbmUuVHJhbnNwb3J0IHdoaWNoIGNhbiBiZSB1c2VkXG5cdFx0ICogIHRvIHNjaGVkdWxlIGV2ZW50cyBhbG9uZyB0aGUgVHJhbnNwb3J0LiBcblx0XHQgKiAgQHBhcmFtICB7RnVuY3Rpb259ICBjYWxsYmFjayAgQWxsIFRvbmUuanMgbm9kZXMgd2hpY2ggYXJlIGNyZWF0ZWQgYW5kIHNjaGVkdWxlZCB3aXRoaW4gdGhpcyBjYWxsYmFjayBhcmUgcmVjb3JkZWQgaW50byB0aGUgb3V0cHV0IEJ1ZmZlci5cblx0XHQgKiAgQHBhcmFtICB7VGltZX0gIGR1cmF0aW9uICAgICB0aGUgYW1vdW50IG9mIHRpbWUgdG8gcmVjb3JkIGZvci5cblx0XHQgKiAgQHJldHVybiAge1Byb21pc2V9ICBUaGUgcHJvbWlzZSB3aGljaCBpcyBpbnZva2VkIHdpdGggdGhlIFRvbmUuQnVmZmVyIG9mIHRoZSByZWNvcmRlZCBvdXRwdXQuXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogLy9yZW5kZXIgMiBzZWNvbmRzIG9mIHRoZSBvc2NpbGxhdG9yXG5cdFx0ICogVG9uZS5PZmZsaW5lKGZ1bmN0aW9uKCl7XG5cdFx0ICogXHQvL29ubHkgbm9kZXMgY3JlYXRlZCBpbiB0aGlzIGNhbGxiYWNrIHdpbGwgYmUgcmVjb3JkZWRcblx0XHQgKiBcdHZhciBvc2NpbGxhdG9yID0gbmV3IFRvbmUuT3NjaWxsYXRvcigpLnRvTWFzdGVyKCkuc3RhcnQoMClcblx0XHQgKiBcdC8vc2NoZWR1bGUgdGhlaXIgZXZlbnRzXG5cdFx0ICogfSwgMikudGhlbihmdW5jdGlvbihidWZmZXIpe1xuXHRcdCAqIFx0Ly9kbyBzb21ldGhpbmcgd2l0aCB0aGUgb3V0cHV0IGJ1ZmZlclxuXHRcdCAqIH0pXG5cdFx0ICogQGV4YW1wbGVcblx0XHQgKiAvL2NhbiBhbHNvIHNjaGVkdWxlIGV2ZW50cyBhbG9uZyB0aGUgVHJhbnNwb3J0XG5cdFx0ICogLy91c2luZyB0aGUgcGFzc2VkIGluIE9mZmxpbmUgVHJhbnNwb3J0XG5cdFx0ICogVG9uZS5PZmZsaW5lKGZ1bmN0aW9uKFRyYW5zcG9ydCl7XG5cdFx0ICogXHR2YXIgb3NjID0gbmV3IFRvbmUuT3NjaWxsYXRvcigpLnRvTWFzdGVyKClcblx0XHQgKiBcdFRyYW5zcG9ydC5zY2hlZHVsZShmdW5jdGlvbih0aW1lKXtcblx0XHQgKiBcdFx0b3NjLnN0YXJ0KHRpbWUpLnN0b3AodGltZSArIDAuMSlcblx0XHQgKiBcdH0sIDEpXG5cdFx0ICogXHRUcmFuc3BvcnQuc3RhcnQoMC4yKVxuXHRcdCAqIH0sIDQpLnRoZW4oZnVuY3Rpb24oYnVmZmVyKXtcblx0XHQgKiBcdC8vZG8gc29tZXRoaW5nIHdpdGggdGhlIG91dHB1dCBidWZmZXJcblx0XHQgKiB9KVxuXHRcdCAqL1xuXHQgICAgVG9uZS5PZmZsaW5lID0gZnVuY3Rpb24gKGNhbGxiYWNrLCBkdXJhdGlvbikge1xuXHQgICAgICAgIC8vc2V0IHRoZSBPZmZsaW5lQXVkaW9Db250ZXh0XG5cdCAgICAgICAgdmFyIHNhbXBsZVJhdGUgPSBUb25lLmNvbnRleHQuc2FtcGxlUmF0ZTtcblx0ICAgICAgICB2YXIgb3JpZ2luYWxDb250ZXh0ID0gVG9uZS5jb250ZXh0O1xuXHQgICAgICAgIHZhciBjb250ZXh0ID0gbmV3IFRvbmUuT2ZmbGluZUNvbnRleHQoMiwgZHVyYXRpb24sIHNhbXBsZVJhdGUpO1xuXHQgICAgICAgIFRvbmUuY29udGV4dCA9IGNvbnRleHQ7XG5cdCAgICAgICAgLy9pbnZva2UgdGhlIGNhbGxiYWNrL3NjaGVkdWxpbmdcblx0ICAgICAgICBjYWxsYmFjayhUb25lLlRyYW5zcG9ydCk7XG5cdCAgICAgICAgLy9wcm9jZXNzIHRoZSBhdWRpb1xuXHQgICAgICAgIHZhciByZW5kZXJlZCA9IGNvbnRleHQucmVuZGVyKCk7XG5cdCAgICAgICAgLy9yZXR1cm4gdGhlIG9yaWdpbmFsIEF1ZGlvQ29udGV4dFxuXHQgICAgICAgIFRvbmUuY29udGV4dCA9IG9yaWdpbmFsQ29udGV4dDtcblx0ICAgICAgICAvL3JldHVybiB0aGUgYXVkaW9cblx0ICAgICAgICByZXR1cm4gcmVuZGVyZWQudGhlbihmdW5jdGlvbiAoYnVmZmVyKSB7XG5cdCAgICAgICAgICAgIC8vd3JhcCBpdCBpbiBhIFRvbmUuQnVmZmVyXG5cdCAgICAgICAgICAgIHJldHVybiBuZXcgVG9uZS5CdWZmZXIoYnVmZmVyKTtcblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVG9uZS5PZmZsaW5lO1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqIFx0QGNsYXNzICBUb25lLkVmZmVjdCBpcyB0aGUgYmFzZSBjbGFzcyBmb3IgZWZmZWN0cy4gQ29ubmVjdCB0aGUgZWZmZWN0IGJldHdlZW5cblx0XHQgKiBcdCAgICAgICAgdGhlIGVmZmVjdFNlbmQgYW5kIGVmZmVjdFJldHVybiBHYWluTm9kZXMsIHRoZW4gY29udHJvbCB0aGUgYW1vdW50IG9mXG5cdFx0ICogXHQgICAgICAgIGVmZmVjdCB3aGljaCBnb2VzIHRvIHRoZSBvdXRwdXQgdXNpbmcgdGhlIHdldCBjb250cm9sLlxuXHRcdCAqXG5cdFx0ICogIEBjb25zdHJ1Y3RvclxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZS5BdWRpb05vZGV9XG5cdFx0ICogIEBwYXJhbSB7Tm9ybWFsUmFuZ2V8T2JqZWN0fSBbd2V0XSBUaGUgc3RhcnRpbmcgd2V0IHZhbHVlLlxuXHRcdCAqL1xuXHQgICAgVG9uZS5FZmZlY3QgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIG9wdGlvbnMgPSBUb25lLmRlZmF1bHRzKGFyZ3VtZW50cywgWyd3ZXQnXSwgVG9uZS5FZmZlY3QpO1xuXHQgICAgICAgIFRvbmUuQXVkaW9Ob2RlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgdGhpcy5jcmVhdGVJbnNPdXRzKDEsIDEpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHRoZSBkcnl3ZXQga25vYiB0byBjb250cm9sIHRoZSBhbW91bnQgb2YgZWZmZWN0XG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuQ3Jvc3NGYWRlfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9kcnlXZXQgPSBuZXcgVG9uZS5Dcm9zc0ZhZGUob3B0aW9ucy53ZXQpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSB3ZXQgY29udHJvbCBpcyBob3cgbXVjaCBvZiB0aGUgZWZmZWN0ZWRcblx0XHRcdCAqICB3aWxsIHBhc3MgdGhyb3VnaCB0byB0aGUgb3V0cHV0LiAxID0gMTAwJSBlZmZlY3RlZFxuXHRcdFx0ICogIHNpZ25hbCwgMCA9IDEwMCUgZHJ5IHNpZ25hbC5cblx0XHRcdCAqICBAdHlwZSB7Tm9ybWFsUmFuZ2V9XG5cdFx0XHQgKiAgQHNpZ25hbFxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy53ZXQgPSB0aGlzLl9kcnlXZXQuZmFkZTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBjb25uZWN0IHRoZSBlZmZlY3RTZW5kIHRvIHRoZSBpbnB1dCBvZiBodGUgZWZmZWN0XG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuR2Fpbn1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5lZmZlY3RTZW5kID0gbmV3IFRvbmUuR2FpbigpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIGNvbm5lY3QgdGhlIG91dHB1dCBvZiB0aGUgZWZmZWN0IHRvIHRoZSBlZmZlY3RSZXR1cm5cblx0XHRcdCAqICBAdHlwZSB7VG9uZS5HYWlufVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmVmZmVjdFJldHVybiA9IG5ldyBUb25lLkdhaW4oKTtcblx0ICAgICAgICAvL2Nvbm5lY3Rpb25zXG5cdCAgICAgICAgdGhpcy5pbnB1dC5jb25uZWN0KHRoaXMuX2RyeVdldC5hKTtcblx0ICAgICAgICB0aGlzLmlucHV0LmNvbm5lY3QodGhpcy5lZmZlY3RTZW5kKTtcblx0ICAgICAgICB0aGlzLmVmZmVjdFJldHVybi5jb25uZWN0KHRoaXMuX2RyeVdldC5iKTtcblx0ICAgICAgICB0aGlzLl9kcnlXZXQuY29ubmVjdCh0aGlzLm91dHB1dCk7XG5cdCAgICAgICAgdGhpcy5fcmVhZE9ubHkoWyd3ZXQnXSk7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5FZmZlY3QsIFRvbmUuQXVkaW9Ob2RlKTtcblx0ICAgIC8qKlxuXHRcdCAqICBAc3RhdGljXG5cdFx0ICogIEB0eXBlIHtPYmplY3R9XG5cdFx0ICovXG5cdCAgICBUb25lLkVmZmVjdC5kZWZhdWx0cyA9IHsgJ3dldCc6IDEgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBjaGFpbnMgdGhlIGVmZmVjdCBpbiBiZXR3ZWVuIHRoZSBlZmZlY3RTZW5kIGFuZCBlZmZlY3RSZXR1cm5cblx0XHQgKiAgQHBhcmFtICB7VG9uZX0gZWZmZWN0XG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLkVmZmVjdH0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5FZmZlY3QucHJvdG90eXBlLmNvbm5lY3RFZmZlY3QgPSBmdW5jdGlvbiAoZWZmZWN0KSB7XG5cdCAgICAgICAgdGhpcy5lZmZlY3RTZW5kLmNoYWluKGVmZmVjdCwgdGhpcy5lZmZlY3RSZXR1cm4pO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBDbGVhbiB1cC5cblx0XHQgKiAgQHJldHVybnMge1RvbmUuRWZmZWN0fSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkVmZmVjdC5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLkF1ZGlvTm9kZS5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuX2RyeVdldC5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fZHJ5V2V0ID0gbnVsbDtcblx0ICAgICAgICB0aGlzLmVmZmVjdFNlbmQuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuZWZmZWN0U2VuZCA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5lZmZlY3RSZXR1cm4uZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuZWZmZWN0UmV0dXJuID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl93cml0YWJsZShbJ3dldCddKTtcblx0ICAgICAgICB0aGlzLndldCA9IG51bGw7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuRWZmZWN0O1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgVG9uZS5BdXRvRmlsdGVyIGlzIGEgVG9uZS5GaWx0ZXIgd2l0aCBhIFRvbmUuTEZPIGNvbm5lY3RlZCB0byB0aGUgZmlsdGVyIGN1dG9mZiBmcmVxdWVuY3kuXG5cdFx0ICogICAgICAgICBTZXR0aW5nIHRoZSBMRk8gcmF0ZSBhbmQgZGVwdGggYWxsb3dzIGZvciBjb250cm9sIG92ZXIgdGhlIGZpbHRlciBtb2R1bGF0aW9uIHJhdGUgXG5cdFx0ICogICAgICAgICBhbmQgZGVwdGguXG5cdFx0ICpcblx0XHQgKiAgQGNvbnN0cnVjdG9yXG5cdFx0ICogIEBleHRlbmRzIHtUb25lLkVmZmVjdH1cblx0XHQgKiAgQHBhcmFtIHtUaW1lfE9iamVjdH0gW2ZyZXF1ZW5jeV0gVGhlIHJhdGUgb2YgdGhlIExGTy5cblx0XHQgKiAgQHBhcmFtIHtGcmVxdWVuY3k9fSBiYXNlRnJlcXVlbmN5IFRoZSBsb3dlciB2YWx1ZSBvZiB0aGUgTEZPcyBvc2NpbGxhdGlvblxuXHQgXHQgKiAgQHBhcmFtIHtGcmVxdWVuY3k9fSBvY3RhdmVzIFRoZSBudW1iZXIgb2Ygb2N0YXZlcyBhYm92ZSB0aGUgYmFzZUZyZXF1ZW5jeVxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIC8vY3JlYXRlIGFuIGF1dG9maWx0ZXIgYW5kIHN0YXJ0IGl0J3MgTEZPXG5cdFx0ICogdmFyIGF1dG9GaWx0ZXIgPSBuZXcgVG9uZS5BdXRvRmlsdGVyKFwiNG5cIikudG9NYXN0ZXIoKS5zdGFydCgpO1xuXHRcdCAqIC8vcm91dGUgYW4gb3NjaWxsYXRvciB0aHJvdWdoIHRoZSBmaWx0ZXIgYW5kIHN0YXJ0IGl0XG5cdFx0ICogdmFyIG9zY2lsbGF0b3IgPSBuZXcgVG9uZS5Pc2NpbGxhdG9yKCkuY29ubmVjdChhdXRvRmlsdGVyKS5zdGFydCgpO1xuXHRcdCAqL1xuXHQgICAgVG9uZS5BdXRvRmlsdGVyID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBvcHRpb25zID0gVG9uZS5kZWZhdWx0cyhhcmd1bWVudHMsIFtcblx0ICAgICAgICAgICAgJ2ZyZXF1ZW5jeScsXG5cdCAgICAgICAgICAgICdiYXNlRnJlcXVlbmN5Jyxcblx0ICAgICAgICAgICAgJ29jdGF2ZXMnXG5cdCAgICAgICAgXSwgVG9uZS5BdXRvRmlsdGVyKTtcblx0ICAgICAgICBUb25lLkVmZmVjdC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHRoZSBsZm8gd2hpY2ggZHJpdmVzIHRoZSBmaWx0ZXIgY3V0b2ZmXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuTEZPfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9sZm8gPSBuZXcgVG9uZS5MRk8oe1xuXHQgICAgICAgICAgICAnZnJlcXVlbmN5Jzogb3B0aW9ucy5mcmVxdWVuY3ksXG5cdCAgICAgICAgICAgICdhbXBsaXR1ZGUnOiBvcHRpb25zLmRlcHRoXG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiBUaGUgcmFuZ2Ugb2YgdGhlIGZpbHRlciBtb2R1bGF0aW5nIGJldHdlZW4gdGhlIG1pbiBhbmQgbWF4IGZyZXF1ZW5jeS4gXG5cdFx0XHQgKiAwID0gbm8gbW9kdWxhdGlvbi4gMSA9IGZ1bGwgbW9kdWxhdGlvbi5cblx0XHRcdCAqIEB0eXBlIHtOb3JtYWxSYW5nZX1cblx0XHRcdCAqIEBzaWduYWxcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuZGVwdGggPSB0aGlzLl9sZm8uYW1wbGl0dWRlO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogSG93IGZhc3QgdGhlIGZpbHRlciBtb2R1bGF0ZXMgYmV0d2VlbiBtaW4gYW5kIG1heC4gXG5cdFx0XHQgKiBAdHlwZSB7RnJlcXVlbmN5fVxuXHRcdFx0ICogQHNpZ25hbFxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5mcmVxdWVuY3kgPSB0aGlzLl9sZm8uZnJlcXVlbmN5O1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBmaWx0ZXIgbm9kZVxuXHRcdFx0ICogIEB0eXBlIHtUb25lLkZpbHRlcn1cblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuZmlsdGVyID0gbmV3IFRvbmUuRmlsdGVyKG9wdGlvbnMuZmlsdGVyKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgb2N0YXZlcyBwbGFjZWhvbGRlclxuXHRcdFx0ICogIEB0eXBlIHtQb3NpdGl2ZX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fb2N0YXZlcyA9IDA7XG5cdCAgICAgICAgLy9jb25uZWN0aW9uc1xuXHQgICAgICAgIHRoaXMuY29ubmVjdEVmZmVjdCh0aGlzLmZpbHRlcik7XG5cdCAgICAgICAgdGhpcy5fbGZvLmNvbm5lY3QodGhpcy5maWx0ZXIuZnJlcXVlbmN5KTtcblx0ICAgICAgICB0aGlzLnR5cGUgPSBvcHRpb25zLnR5cGU7XG5cdCAgICAgICAgdGhpcy5fcmVhZE9ubHkoW1xuXHQgICAgICAgICAgICAnZnJlcXVlbmN5Jyxcblx0ICAgICAgICAgICAgJ2RlcHRoJ1xuXHQgICAgICAgIF0pO1xuXHQgICAgICAgIHRoaXMub2N0YXZlcyA9IG9wdGlvbnMub2N0YXZlcztcblx0ICAgICAgICB0aGlzLmJhc2VGcmVxdWVuY3kgPSBvcHRpb25zLmJhc2VGcmVxdWVuY3k7XG5cdCAgICB9O1xuXHQgICAgLy9leHRlbmQgRWZmZWN0XG5cdCAgICBUb25lLmV4dGVuZChUb25lLkF1dG9GaWx0ZXIsIFRvbmUuRWZmZWN0KTtcblx0ICAgIC8qKlxuXHRcdCAqICBkZWZhdWx0c1xuXHRcdCAqICBAc3RhdGljXG5cdFx0ICogIEB0eXBlIHtPYmplY3R9XG5cdFx0ICovXG5cdCAgICBUb25lLkF1dG9GaWx0ZXIuZGVmYXVsdHMgPSB7XG5cdCAgICAgICAgJ2ZyZXF1ZW5jeSc6IDEsXG5cdCAgICAgICAgJ3R5cGUnOiAnc2luZScsXG5cdCAgICAgICAgJ2RlcHRoJzogMSxcblx0ICAgICAgICAnYmFzZUZyZXF1ZW5jeSc6IDIwMCxcblx0ICAgICAgICAnb2N0YXZlcyc6IDIuNixcblx0ICAgICAgICAnZmlsdGVyJzoge1xuXHQgICAgICAgICAgICAndHlwZSc6ICdsb3dwYXNzJyxcblx0ICAgICAgICAgICAgJ3JvbGxvZmYnOiAtMTIsXG5cdCAgICAgICAgICAgICdRJzogMVxuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiBTdGFydCB0aGUgZWZmZWN0LlxuXHRcdCAqIEBwYXJhbSB7VGltZX0gW3RpbWU9bm93XSBXaGVuIHRoZSBMRk8gd2lsbCBzdGFydC4gXG5cdFx0ICogQHJldHVybnMge1RvbmUuQXV0b0ZpbHRlcn0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5BdXRvRmlsdGVyLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uICh0aW1lKSB7XG5cdCAgICAgICAgdGhpcy5fbGZvLnN0YXJ0KHRpbWUpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqIFN0b3AgdGhlIGVmZmVjdC5cblx0XHQgKiBAcGFyYW0ge1RpbWV9IFt0aW1lPW5vd10gV2hlbiB0aGUgTEZPIHdpbGwgc3RvcC4gXG5cdFx0ICogQHJldHVybnMge1RvbmUuQXV0b0ZpbHRlcn0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5BdXRvRmlsdGVyLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKHRpbWUpIHtcblx0ICAgICAgICB0aGlzLl9sZm8uc3RvcCh0aW1lKTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiBTeW5jIHRoZSBmaWx0ZXIgdG8gdGhlIHRyYW5zcG9ydC5cblx0XHQgKiBAcGFyYW0ge1RpbWV9IFtkZWxheT0wXSBEZWxheSB0aW1lIGJlZm9yZSBzdGFydGluZyB0aGUgZWZmZWN0IGFmdGVyIHRoZVxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRyYW5zcG9ydCBoYXMgc3RhcnRlZC4gXG5cdFx0ICogQHJldHVybnMge1RvbmUuQXV0b0ZpbHRlcn0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5BdXRvRmlsdGVyLnByb3RvdHlwZS5zeW5jID0gZnVuY3Rpb24gKGRlbGF5KSB7XG5cdCAgICAgICAgdGhpcy5fbGZvLnN5bmMoZGVsYXkpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqIFVuc3luYyB0aGUgZmlsdGVyIGZyb20gdGhlIHRyYW5zcG9ydC5cblx0XHQgKiBAcmV0dXJucyB7VG9uZS5BdXRvRmlsdGVyfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkF1dG9GaWx0ZXIucHJvdG90eXBlLnVuc3luYyA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB0aGlzLl9sZm8udW5zeW5jKCk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogVHlwZSBvZiBvc2NpbGxhdG9yIGF0dGFjaGVkIHRvIHRoZSBBdXRvRmlsdGVyLiBcblx0XHQgKiBQb3NzaWJsZSB2YWx1ZXM6IFwic2luZVwiLCBcInNxdWFyZVwiLCBcInRyaWFuZ2xlXCIsIFwic2F3dG9vdGhcIi5cblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5BdXRvRmlsdGVyI1xuXHRcdCAqIEB0eXBlIHtzdHJpbmd9XG5cdFx0ICogQG5hbWUgdHlwZVxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuQXV0b0ZpbHRlci5wcm90b3R5cGUsICd0eXBlJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fbGZvLnR5cGU7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uICh0eXBlKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2xmby50eXBlID0gdHlwZTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqIFRoZSBtaW5pbXVtIHZhbHVlIG9mIHRoZSBmaWx0ZXIncyBjdXRvZmYgZnJlcXVlbmN5LlxuXHRcdCAqIEBtZW1iZXJPZiBUb25lLkF1dG9GaWx0ZXIjXG5cdFx0ICogQHR5cGUge0ZyZXF1ZW5jeX1cblx0XHQgKiBAbmFtZSBtaW5cblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkF1dG9GaWx0ZXIucHJvdG90eXBlLCAnYmFzZUZyZXF1ZW5jeScsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xmby5taW47XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChmcmVxKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2xmby5taW4gPSB0aGlzLnRvRnJlcXVlbmN5KGZyZXEpO1xuXHQgICAgICAgICAgICAvL2FuZCBzZXQgdGhlIG1heFxuXHQgICAgICAgICAgICB0aGlzLm9jdGF2ZXMgPSB0aGlzLl9vY3RhdmVzO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogVGhlIG1heGltdW0gdmFsdWUgb2YgdGhlIGZpbHRlcidzIGN1dG9mZiBmcmVxdWVuY3kuIFxuXHRcdCAqIEBtZW1iZXJPZiBUb25lLkF1dG9GaWx0ZXIjXG5cdFx0ICogQHR5cGUge1Bvc2l0aXZlfVxuXHRcdCAqIEBuYW1lIG9jdGF2ZXNcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkF1dG9GaWx0ZXIucHJvdG90eXBlLCAnb2N0YXZlcycsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX29jdGF2ZXM7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChvY3QpIHtcblx0ICAgICAgICAgICAgdGhpcy5fb2N0YXZlcyA9IG9jdDtcblx0ICAgICAgICAgICAgdGhpcy5fbGZvLm1heCA9IHRoaXMuYmFzZUZyZXF1ZW5jeSAqIE1hdGgucG93KDIsIG9jdCk7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgQ2xlYW4gdXAuIFxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5BdXRvRmlsdGVyfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkF1dG9GaWx0ZXIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5FZmZlY3QucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLl9sZm8uZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX2xmbyA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5maWx0ZXIuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuZmlsdGVyID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl93cml0YWJsZShbXG5cdCAgICAgICAgICAgICdmcmVxdWVuY3knLFxuXHQgICAgICAgICAgICAnZGVwdGgnXG5cdCAgICAgICAgXSk7XG5cdCAgICAgICAgdGhpcy5mcmVxdWVuY3kgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuZGVwdGggPSBudWxsO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLkF1dG9GaWx0ZXI7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyBUb25lLkF1dG9QYW5uZXIgaXMgYSBUb25lLlBhbm5lciB3aXRoIGFuIExGTyBjb25uZWN0ZWQgdG8gdGhlIHBhbiBhbW91bnQuIFxuXHRcdCAqICAgICAgICAgTW9yZSBvbiB1c2luZyBhdXRvcGFubmVycyBbaGVyZV0oaHR0cHM6Ly93d3cuYWJsZXRvbi5jb20vZW4vYmxvZy9hdXRvcGFuLWNob3BwZXItZWZmZWN0LWFuZC1tb3JlLWxpdmVzY2hvb2wvKS5cblx0XHQgKlxuXHRcdCAqICBAY29uc3RydWN0b3Jcblx0XHQgKiAgQGV4dGVuZHMge1RvbmUuRWZmZWN0fVxuXHRcdCAqICBAcGFyYW0ge0ZyZXF1ZW5jeXxPYmplY3R9IFtmcmVxdWVuY3ldIFJhdGUgb2YgbGVmdC1yaWdodCBvc2NpbGxhdGlvbi4gXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogLy9jcmVhdGUgYW4gYXV0b3Bhbm5lciBhbmQgc3RhcnQgaXQncyBMRk9cblx0XHQgKiB2YXIgYXV0b1Bhbm5lciA9IG5ldyBUb25lLkF1dG9QYW5uZXIoXCI0blwiKS50b01hc3RlcigpLnN0YXJ0KCk7XG5cdFx0ICogLy9yb3V0ZSBhbiBvc2NpbGxhdG9yIHRocm91Z2ggdGhlIHBhbm5lciBhbmQgc3RhcnQgaXRcblx0XHQgKiB2YXIgb3NjaWxsYXRvciA9IG5ldyBUb25lLk9zY2lsbGF0b3IoKS5jb25uZWN0KGF1dG9QYW5uZXIpLnN0YXJ0KCk7XG5cdFx0ICovXG5cdCAgICBUb25lLkF1dG9QYW5uZXIgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIG9wdGlvbnMgPSBUb25lLmRlZmF1bHRzKGFyZ3VtZW50cywgWydmcmVxdWVuY3knXSwgVG9uZS5BdXRvUGFubmVyKTtcblx0ICAgICAgICBUb25lLkVmZmVjdC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHRoZSBsZm8gd2hpY2ggZHJpdmVzIHRoZSBwYW5uaW5nXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuTEZPfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9sZm8gPSBuZXcgVG9uZS5MRk8oe1xuXHQgICAgICAgICAgICAnZnJlcXVlbmN5Jzogb3B0aW9ucy5mcmVxdWVuY3ksXG5cdCAgICAgICAgICAgICdhbXBsaXR1ZGUnOiBvcHRpb25zLmRlcHRoLFxuXHQgICAgICAgICAgICAnbWluJzogLTEsXG5cdCAgICAgICAgICAgICdtYXgnOiAxXG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiBUaGUgYW1vdW50IG9mIHBhbm5pbmcgYmV0d2VlbiBsZWZ0IGFuZCByaWdodC4gXG5cdFx0XHQgKiAwID0gYWx3YXlzIGNlbnRlci4gMSA9IGZ1bGwgcmFuZ2UgYmV0d2VlbiBsZWZ0IGFuZCByaWdodC4gXG5cdFx0XHQgKiBAdHlwZSB7Tm9ybWFsUmFuZ2V9XG5cdFx0XHQgKiBAc2lnbmFsXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmRlcHRoID0gdGhpcy5fbGZvLmFtcGxpdHVkZTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICB0aGUgcGFubmVyIG5vZGUgd2hpY2ggZG9lcyB0aGUgcGFubmluZ1xuXHRcdFx0ICogIEB0eXBlIHtUb25lLlBhbm5lcn1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fcGFubmVyID0gbmV3IFRvbmUuUGFubmVyKCk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiBIb3cgZmFzdCB0aGUgcGFubmVyIG1vZHVsYXRlcyBiZXR3ZWVuIGxlZnQgYW5kIHJpZ2h0LiBcblx0XHRcdCAqIEB0eXBlIHtGcmVxdWVuY3l9XG5cdFx0XHQgKiBAc2lnbmFsXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmZyZXF1ZW5jeSA9IHRoaXMuX2xmby5mcmVxdWVuY3k7XG5cdCAgICAgICAgLy9jb25uZWN0aW9uc1xuXHQgICAgICAgIHRoaXMuY29ubmVjdEVmZmVjdCh0aGlzLl9wYW5uZXIpO1xuXHQgICAgICAgIHRoaXMuX2xmby5jb25uZWN0KHRoaXMuX3Bhbm5lci5wYW4pO1xuXHQgICAgICAgIHRoaXMudHlwZSA9IG9wdGlvbnMudHlwZTtcblx0ICAgICAgICB0aGlzLl9yZWFkT25seShbXG5cdCAgICAgICAgICAgICdkZXB0aCcsXG5cdCAgICAgICAgICAgICdmcmVxdWVuY3knXG5cdCAgICAgICAgXSk7XG5cdCAgICB9O1xuXHQgICAgLy9leHRlbmQgRWZmZWN0XG5cdCAgICBUb25lLmV4dGVuZChUb25lLkF1dG9QYW5uZXIsIFRvbmUuRWZmZWN0KTtcblx0ICAgIC8qKlxuXHRcdCAqICBkZWZhdWx0c1xuXHRcdCAqICBAc3RhdGljXG5cdFx0ICogIEB0eXBlIHtPYmplY3R9XG5cdFx0ICovXG5cdCAgICBUb25lLkF1dG9QYW5uZXIuZGVmYXVsdHMgPSB7XG5cdCAgICAgICAgJ2ZyZXF1ZW5jeSc6IDEsXG5cdCAgICAgICAgJ3R5cGUnOiAnc2luZScsXG5cdCAgICAgICAgJ2RlcHRoJzogMVxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqIFN0YXJ0IHRoZSBlZmZlY3QuXG5cdFx0ICogQHBhcmFtIHtUaW1lfSBbdGltZT1ub3ddIFdoZW4gdGhlIExGTyB3aWxsIHN0YXJ0LiBcblx0XHQgKiBAcmV0dXJucyB7VG9uZS5BdXRvUGFubmVyfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkF1dG9QYW5uZXIucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24gKHRpbWUpIHtcblx0ICAgICAgICB0aGlzLl9sZm8uc3RhcnQodGltZSk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogU3RvcCB0aGUgZWZmZWN0LlxuXHRcdCAqIEBwYXJhbSB7VGltZX0gW3RpbWU9bm93XSBXaGVuIHRoZSBMRk8gd2lsbCBzdG9wLiBcblx0XHQgKiBAcmV0dXJucyB7VG9uZS5BdXRvUGFubmVyfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkF1dG9QYW5uZXIucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAodGltZSkge1xuXHQgICAgICAgIHRoaXMuX2xmby5zdG9wKHRpbWUpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqIFN5bmMgdGhlIHBhbm5lciB0byB0aGUgdHJhbnNwb3J0LlxuXHRcdCAqIEBwYXJhbSB7VGltZX0gW2RlbGF5PTBdIERlbGF5IHRpbWUgYmVmb3JlIHN0YXJ0aW5nIHRoZSBlZmZlY3QgYWZ0ZXIgdGhlXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVHJhbnNwb3J0IGhhcyBzdGFydGVkLiBcblx0XHQgKiBAcmV0dXJucyB7VG9uZS5BdXRvUGFubmVyfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkF1dG9QYW5uZXIucHJvdG90eXBlLnN5bmMgPSBmdW5jdGlvbiAoZGVsYXkpIHtcblx0ICAgICAgICB0aGlzLl9sZm8uc3luYyhkZWxheSk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogVW5zeW5jIHRoZSBwYW5uZXIgZnJvbSB0aGUgdHJhbnNwb3J0XG5cdFx0ICogQHJldHVybnMge1RvbmUuQXV0b1Bhbm5lcn0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5BdXRvUGFubmVyLnByb3RvdHlwZS51bnN5bmMgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdGhpcy5fbGZvLnVuc3luYygpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqIFR5cGUgb2Ygb3NjaWxsYXRvciBhdHRhY2hlZCB0byB0aGUgQXV0b0ZpbHRlci4gXG5cdFx0ICogUG9zc2libGUgdmFsdWVzOiBcInNpbmVcIiwgXCJzcXVhcmVcIiwgXCJ0cmlhbmdsZVwiLCBcInNhd3Rvb3RoXCIuXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuQXV0b0ZpbHRlciNcblx0XHQgKiBAdHlwZSB7c3RyaW5nfVxuXHRcdCAqIEBuYW1lIHR5cGVcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkF1dG9QYW5uZXIucHJvdG90eXBlLCAndHlwZScsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xmby50eXBlO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAodHlwZSkge1xuXHQgICAgICAgICAgICB0aGlzLl9sZm8udHlwZSA9IHR5cGU7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgY2xlYW4gdXBcblx0XHQgKiAgQHJldHVybnMge1RvbmUuQXV0b1Bhbm5lcn0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5BdXRvUGFubmVyLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuRWZmZWN0LnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgdGhpcy5fbGZvLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9sZm8gPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX3Bhbm5lci5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fcGFubmVyID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl93cml0YWJsZShbXG5cdCAgICAgICAgICAgICdkZXB0aCcsXG5cdCAgICAgICAgICAgICdmcmVxdWVuY3knXG5cdCAgICAgICAgXSk7XG5cdCAgICAgICAgdGhpcy5mcmVxdWVuY3kgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuZGVwdGggPSBudWxsO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLkF1dG9QYW5uZXI7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyAgVG9uZS5BdXRvV2FoIGNvbm5lY3RzIGEgVG9uZS5Gb2xsb3dlciB0byBhIGJhbmRwYXNzIGZpbHRlciAoVG9uZS5GaWx0ZXIpLlxuXHRcdCAqICAgICAgICAgIFRoZSBmcmVxdWVuY3kgb2YgdGhlIGZpbHRlciBpcyBhZGp1c3RlZCBwcm9wb3J0aW9uYWxseSB0byB0aGUgXG5cdFx0ICogICAgICAgICAgaW5jb21pbmcgc2lnbmFsJ3MgYW1wbGl0dWRlLiBJbnNwaXJhdGlvbiBmcm9tIFtUdW5hLmpzXShodHRwczovL2dpdGh1Yi5jb20vRGluYWhtb2UvdHVuYSkuXG5cdFx0ICpcblx0XHQgKiAgQGNvbnN0cnVjdG9yXG5cdFx0ICogIEBleHRlbmRzIHtUb25lLkVmZmVjdH1cblx0XHQgKiAgQHBhcmFtIHtGcmVxdWVuY3l8T2JqZWN0fSBbYmFzZUZyZXF1ZW5jeV0gVGhlIGZyZXF1ZW5jeSB0aGUgZmlsdGVyIGlzIHNldCBcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG8gYXQgdGhlIGxvdyBwb2ludCBvZiB0aGUgd2FoXG5cdFx0ICogIEBwYXJhbSB7UG9zaXRpdmV9IFtvY3RhdmVzXSBUaGUgbnVtYmVyIG9mIG9jdGF2ZXMgYWJvdmUgdGhlIGJhc2VGcmVxdWVuY3lcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIGZpbHRlciB3aWxsIHN3ZWVwIHRvIHdoZW4gZnVsbHkgb3BlblxuXHRcdCAqICBAcGFyYW0ge0RlY2liZWxzfSBbc2Vuc2l0aXZpdHldIFRoZSBkZWNpYmVsIHRocmVzaG9sZCBzZW5zaXRpdml0eSBmb3IgXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSBpbmNvbWluZyBzaWduYWwuIE5vcm1hbCByYW5nZSBvZiAtNDAgdG8gMC4gXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogdmFyIGF1dG9XYWggPSBuZXcgVG9uZS5BdXRvV2FoKDUwLCA2LCAtMzApLnRvTWFzdGVyKCk7XG5cdFx0ICogLy9pbml0aWFsaXplIHRoZSBzeW50aCBhbmQgY29ubmVjdCB0byBhdXRvd2FoXG5cdFx0ICogdmFyIHN5bnRoID0gbmV3IFN5bnRoLmNvbm5lY3QoYXV0b1dhaCk7XG5cdFx0ICogLy9RIHZhbHVlIGluZmx1ZW5jZXMgdGhlIGVmZmVjdCBvZiB0aGUgd2FoIC0gZGVmYXVsdCBpcyAyXG5cdFx0ICogYXV0b1dhaC5RLnZhbHVlID0gNjtcblx0XHQgKiAvL21vcmUgYXVkaWJsZSBvbiBoaWdoZXIgbm90ZXNcblx0XHQgKiBzeW50aC50cmlnZ2VyQXR0YWNrUmVsZWFzZShcIkM0XCIsIFwiOG5cIilcblx0XHQgKi9cblx0ICAgIFRvbmUuQXV0b1dhaCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgb3B0aW9ucyA9IFRvbmUuZGVmYXVsdHMoYXJndW1lbnRzLCBbXG5cdCAgICAgICAgICAgICdiYXNlRnJlcXVlbmN5Jyxcblx0ICAgICAgICAgICAgJ29jdGF2ZXMnLFxuXHQgICAgICAgICAgICAnc2Vuc2l0aXZpdHknXG5cdCAgICAgICAgXSwgVG9uZS5BdXRvV2FoKTtcblx0ICAgICAgICBUb25lLkVmZmVjdC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBlbnZlbG9wZSBmb2xsb3dlci4gU2V0IHRoZSBhdHRhY2svcmVsZWFzZVxuXHRcdFx0ICogIHRpbWluZyB0byBhZGp1c3QgaG93IHRoZSBlbnZlbG9wZSBpcyBmb2xsb3dlZC4gXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuRm9sbG93ZXJ9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuZm9sbG93ZXIgPSBuZXcgVG9uZS5Gb2xsb3dlcihvcHRpb25zLmZvbGxvd2VyKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBzY2FsZXMgdGhlIGZvbGxvd2VyIHZhbHVlIHRvIHRoZSBmcmVxdWVuY3kgZG9tYWluXG5cdFx0XHQgKiAgQHR5cGUge1RvbmV9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX3N3ZWVwUmFuZ2UgPSBuZXcgVG9uZS5TY2FsZUV4cCgwLCAxLCAwLjUpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIEB0eXBlIHtudW1iZXJ9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2Jhc2VGcmVxdWVuY3kgPSBvcHRpb25zLmJhc2VGcmVxdWVuY3k7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgQHR5cGUge251bWJlcn1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fb2N0YXZlcyA9IG9wdGlvbnMub2N0YXZlcztcblx0ICAgICAgICAvKipcblx0XHRcdCAqICB0aGUgaW5wdXQgZ2FpbiB0byBhZGp1c3QgdGhlIHNlbnNpdGl2aXR5XG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuR2Fpbn1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5faW5wdXRCb29zdCA9IG5ldyBUb25lLkdhaW4oKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBAdHlwZSB7QmlxdWFkRmlsdGVyTm9kZX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fYmFuZHBhc3MgPSBuZXcgVG9uZS5GaWx0ZXIoe1xuXHQgICAgICAgICAgICAncm9sbG9mZic6IC00OCxcblx0ICAgICAgICAgICAgJ2ZyZXF1ZW5jeSc6IDAsXG5cdCAgICAgICAgICAgICdRJzogb3B0aW9ucy5RXG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuRmlsdGVyfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9wZWFraW5nID0gbmV3IFRvbmUuRmlsdGVyKDAsICdwZWFraW5nJyk7XG5cdCAgICAgICAgdGhpcy5fcGVha2luZy5nYWluLnZhbHVlID0gb3B0aW9ucy5nYWluO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogVGhlIGdhaW4gb2YgdGhlIGZpbHRlci5cblx0XHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0XHQgKiBAc2lnbmFsXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmdhaW4gPSB0aGlzLl9wZWFraW5nLmdhaW47XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiBUaGUgcXVhbGl0eSBvZiB0aGUgZmlsdGVyLlxuXHRcdFx0ICogQHR5cGUge1Bvc2l0aXZlfVxuXHRcdFx0ICogQHNpZ25hbFxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5RID0gdGhpcy5fYmFuZHBhc3MuUTtcblx0ICAgICAgICAvL3RoZSBjb250cm9sIHNpZ25hbCBwYXRoXG5cdCAgICAgICAgdGhpcy5lZmZlY3RTZW5kLmNoYWluKHRoaXMuX2lucHV0Qm9vc3QsIHRoaXMuZm9sbG93ZXIsIHRoaXMuX3N3ZWVwUmFuZ2UpO1xuXHQgICAgICAgIHRoaXMuX3N3ZWVwUmFuZ2UuY29ubmVjdCh0aGlzLl9iYW5kcGFzcy5mcmVxdWVuY3kpO1xuXHQgICAgICAgIHRoaXMuX3N3ZWVwUmFuZ2UuY29ubmVjdCh0aGlzLl9wZWFraW5nLmZyZXF1ZW5jeSk7XG5cdCAgICAgICAgLy90aGUgZmlsdGVyZWQgcGF0aFxuXHQgICAgICAgIHRoaXMuZWZmZWN0U2VuZC5jaGFpbih0aGlzLl9iYW5kcGFzcywgdGhpcy5fcGVha2luZywgdGhpcy5lZmZlY3RSZXR1cm4pO1xuXHQgICAgICAgIC8vc2V0IHRoZSBpbml0aWFsIHZhbHVlXG5cdCAgICAgICAgdGhpcy5fc2V0U3dlZXBSYW5nZSgpO1xuXHQgICAgICAgIHRoaXMuc2Vuc2l0aXZpdHkgPSBvcHRpb25zLnNlbnNpdGl2aXR5O1xuXHQgICAgICAgIHRoaXMuX3JlYWRPbmx5KFtcblx0ICAgICAgICAgICAgJ2dhaW4nLFxuXHQgICAgICAgICAgICAnUSdcblx0ICAgICAgICBdKTtcblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLkF1dG9XYWgsIFRvbmUuRWZmZWN0KTtcblx0ICAgIC8qKlxuXHRcdCAqICBAc3RhdGljXG5cdFx0ICogIEB0eXBlIHtPYmplY3R9XG5cdFx0ICovXG5cdCAgICBUb25lLkF1dG9XYWguZGVmYXVsdHMgPSB7XG5cdCAgICAgICAgJ2Jhc2VGcmVxdWVuY3knOiAxMDAsXG5cdCAgICAgICAgJ29jdGF2ZXMnOiA2LFxuXHQgICAgICAgICdzZW5zaXRpdml0eSc6IDAsXG5cdCAgICAgICAgJ1EnOiAyLFxuXHQgICAgICAgICdnYWluJzogMixcblx0ICAgICAgICAnZm9sbG93ZXInOiB7XG5cdCAgICAgICAgICAgICdhdHRhY2snOiAwLjMsXG5cdCAgICAgICAgICAgICdyZWxlYXNlJzogMC41XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqIFRoZSBudW1iZXIgb2Ygb2N0YXZlcyB0aGF0IHRoZSBmaWx0ZXIgd2lsbCBzd2VlcCBhYm92ZSB0aGUgXG5cdFx0ICogYmFzZUZyZXF1ZW5jeS4gXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuQXV0b1dhaCNcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqIEBuYW1lIG9jdGF2ZXNcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkF1dG9XYWgucHJvdG90eXBlLCAnb2N0YXZlcycsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX29jdGF2ZXM7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChvY3RhdmVzKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX29jdGF2ZXMgPSBvY3RhdmVzO1xuXHQgICAgICAgICAgICB0aGlzLl9zZXRTd2VlcFJhbmdlKCk7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiBUaGUgYmFzZSBmcmVxdWVuY3kgZnJvbSB3aGljaCB0aGUgc3dlZXAgd2lsbCBzdGFydCBmcm9tLlxuXHRcdCAqIEBtZW1iZXJPZiBUb25lLkF1dG9XYWgjXG5cdFx0ICogQHR5cGUge0ZyZXF1ZW5jeX1cblx0XHQgKiBAbmFtZSBiYXNlRnJlcXVlbmN5XG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5BdXRvV2FoLnByb3RvdHlwZSwgJ2Jhc2VGcmVxdWVuY3knLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9iYXNlRnJlcXVlbmN5O1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAoYmFzZUZyZXEpIHtcblx0ICAgICAgICAgICAgdGhpcy5fYmFzZUZyZXF1ZW5jeSA9IGJhc2VGcmVxO1xuXHQgICAgICAgICAgICB0aGlzLl9zZXRTd2VlcFJhbmdlKCk7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiBUaGUgc2Vuc2l0aXZpdHkgdG8gY29udHJvbCBob3cgcmVzcG9uc2l2ZSB0byB0aGUgaW5wdXQgc2lnbmFsIHRoZSBmaWx0ZXIgaXMuIFxuXHRcdCAqIEBtZW1iZXJPZiBUb25lLkF1dG9XYWgjXG5cdFx0ICogQHR5cGUge0RlY2liZWxzfVxuXHRcdCAqIEBuYW1lIHNlbnNpdGl2aXR5XG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5BdXRvV2FoLnByb3RvdHlwZSwgJ3NlbnNpdGl2aXR5Jywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gVG9uZS5nYWluVG9EYigxIC8gdGhpcy5faW5wdXRCb29zdC5nYWluLnZhbHVlKTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKHNlbnNpdGl2eSkge1xuXHQgICAgICAgICAgICB0aGlzLl9pbnB1dEJvb3N0LmdhaW4udmFsdWUgPSAxIC8gVG9uZS5kYlRvR2FpbihzZW5zaXRpdnkpO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIHNldHMgdGhlIHN3ZWVwIHJhbmdlIG9mIHRoZSBzY2FsZXJcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuQXV0b1dhaC5wcm90b3R5cGUuX3NldFN3ZWVwUmFuZ2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdGhpcy5fc3dlZXBSYW5nZS5taW4gPSB0aGlzLl9iYXNlRnJlcXVlbmN5O1xuXHQgICAgICAgIHRoaXMuX3N3ZWVwUmFuZ2UubWF4ID0gTWF0aC5taW4odGhpcy5fYmFzZUZyZXF1ZW5jeSAqIE1hdGgucG93KDIsIHRoaXMuX29jdGF2ZXMpLCB0aGlzLmNvbnRleHQuc2FtcGxlUmF0ZSAvIDIpO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBDbGVhbiB1cC5cblx0XHQgKiAgQHJldHVybnMge1RvbmUuQXV0b1dhaH0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5BdXRvV2FoLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuRWZmZWN0LnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgdGhpcy5mb2xsb3dlci5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5mb2xsb3dlciA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fc3dlZXBSYW5nZS5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fc3dlZXBSYW5nZSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fYmFuZHBhc3MuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX2JhbmRwYXNzID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9wZWFraW5nLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9wZWFraW5nID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9pbnB1dEJvb3N0LmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9pbnB1dEJvb3N0ID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl93cml0YWJsZShbXG5cdCAgICAgICAgICAgICdnYWluJyxcblx0ICAgICAgICAgICAgJ1EnXG5cdCAgICAgICAgXSk7XG5cdCAgICAgICAgdGhpcy5nYWluID0gbnVsbDtcblx0ICAgICAgICB0aGlzLlEgPSBudWxsO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLkF1dG9XYWg7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyBUb25lLkJpdGNydXNoZXIgZG93bnNhbXBsZXMgdGhlIGluY29taW5nIHNpZ25hbCB0byBhIGRpZmZlcmVudCBiaXRkZXB0aC4gXG5cdFx0ICogICAgICAgICBMb3dlcmluZyB0aGUgYml0ZGVwdGggb2YgdGhlIHNpZ25hbCBjcmVhdGVzIGRpc3RvcnRpb24uIFJlYWQgbW9yZSBhYm91dCBCaXRjcnVzaGluZ1xuXHRcdCAqICAgICAgICAgb24gW1dpa2lwZWRpYV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQml0Y3J1c2hlcikuXG5cdFx0ICpcblx0XHQgKiAgQGNvbnN0cnVjdG9yXG5cdFx0ICogIEBleHRlbmRzIHtUb25lLkVmZmVjdH1cblx0XHQgKiAgQHBhcmFtIHtOdW1iZXJ9IGJpdHMgVGhlIG51bWJlciBvZiBiaXRzIHRvIGRvd25zYW1wbGUgdGhlIHNpZ25hbC4gTm9taW5hbCByYW5nZVxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgICBvZiAxIHRvIDguIFxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIC8vaW5pdGlhbGl6ZSBjcnVzaGVyIGFuZCByb3V0ZSBhIHN5bnRoIHRocm91Z2ggaXRcblx0XHQgKiB2YXIgY3J1c2hlciA9IG5ldyBUb25lLkJpdENydXNoZXIoNCkudG9NYXN0ZXIoKTtcblx0XHQgKiB2YXIgc3ludGggPSBuZXcgVG9uZS5Nb25vU3ludGgoKS5jb25uZWN0KGNydXNoZXIpO1xuXHRcdCAqL1xuXHQgICAgVG9uZS5CaXRDcnVzaGVyID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBvcHRpb25zID0gVG9uZS5kZWZhdWx0cyhhcmd1bWVudHMsIFsnYml0cyddLCBUb25lLkJpdENydXNoZXIpO1xuXHQgICAgICAgIFRvbmUuRWZmZWN0LmNhbGwodGhpcywgb3B0aW9ucyk7XG5cdCAgICAgICAgdmFyIGludlN0ZXBTaXplID0gMSAvIE1hdGgucG93KDIsIG9wdGlvbnMuYml0cyAtIDEpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFN1YnRyYWN0IHRoZSBpbnB1dCBzaWduYWwgYW5kIHRoZSBtb2R1bHVzIG9mIHRoZSBpbnB1dCBzaWduYWxcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5TdWJ0cmFjdH1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fc3VidHJhY3QgPSBuZXcgVG9uZS5TdWJ0cmFjdCgpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBtb2QgZnVuY3Rpb25cblx0XHRcdCAqICBAdHlwZSAge1RvbmUuTW9kdWxvfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9tb2R1bG8gPSBuZXcgVG9uZS5Nb2R1bG8oaW52U3RlcFNpemUpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIGtlZXBzIHRyYWNrIG9mIHRoZSBiaXRzXG5cdFx0XHQgKiAgQHR5cGUge251bWJlcn1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fYml0cyA9IG9wdGlvbnMuYml0cztcblx0ICAgICAgICAvL2Nvbm5lY3QgaXQgdXBcblx0ICAgICAgICB0aGlzLmVmZmVjdFNlbmQuZmFuKHRoaXMuX3N1YnRyYWN0LCB0aGlzLl9tb2R1bG8pO1xuXHQgICAgICAgIHRoaXMuX21vZHVsby5jb25uZWN0KHRoaXMuX3N1YnRyYWN0LCAwLCAxKTtcblx0ICAgICAgICB0aGlzLl9zdWJ0cmFjdC5jb25uZWN0KHRoaXMuZWZmZWN0UmV0dXJuKTtcblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLkJpdENydXNoZXIsIFRvbmUuRWZmZWN0KTtcblx0ICAgIC8qKlxuXHRcdCAqICB0aGUgZGVmYXVsdCB2YWx1ZXNcblx0XHQgKiAgQHN0YXRpY1xuXHRcdCAqICBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqL1xuXHQgICAgVG9uZS5CaXRDcnVzaGVyLmRlZmF1bHRzID0geyAnYml0cyc6IDQgfTtcblx0ICAgIC8qKlxuXHRcdCAqIFRoZSBiaXQgZGVwdGggb2YgdGhlIGVmZmVjdC4gTm9taW5hbCByYW5nZSBvZiAxLTguIFxuXHRcdCAqIEBtZW1iZXJPZiBUb25lLkJpdENydXNoZXIjXG5cdFx0ICogQHR5cGUge251bWJlcn1cblx0XHQgKiBAbmFtZSBiaXRzXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5CaXRDcnVzaGVyLnByb3RvdHlwZSwgJ2JpdHMnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9iaXRzO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAoYml0cykge1xuXHQgICAgICAgICAgICB0aGlzLl9iaXRzID0gYml0cztcblx0ICAgICAgICAgICAgdmFyIGludlN0ZXBTaXplID0gMSAvIE1hdGgucG93KDIsIGJpdHMgLSAxKTtcblx0ICAgICAgICAgICAgdGhpcy5fbW9kdWxvLnZhbHVlID0gaW52U3RlcFNpemU7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgQ2xlYW4gdXAuIFxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5CaXRDcnVzaGVyfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkJpdENydXNoZXIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5FZmZlY3QucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLl9zdWJ0cmFjdC5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fc3VidHJhY3QgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX21vZHVsby5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fbW9kdWxvID0gbnVsbDtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVG9uZS5CaXRDcnVzaGVyO1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgVG9uZS5DaGVieVNoZXYgaXMgYSBDaGVieXNoZXYgd2F2ZXNoYXBlciwgYW4gZWZmZWN0IHdoaWNoIGlzIGdvb2QgXG5cdFx0ICogICAgICAgICBmb3IgbWFraW5nIGRpZmZlcmVudCB0eXBlcyBvZiBkaXN0b3J0aW9uIHNvdW5kcy5cblx0XHQgKiAgICAgICAgIE5vdGUgdGhhdCBvZGQgb3JkZXJzIHNvdW5kIHZlcnkgZGlmZmVyZW50IGZyb20gZXZlbiBvbmVzLCBcblx0XHQgKiAgICAgICAgIGFuZCBvcmRlciA9IDEgaXMgbm8gY2hhbmdlLiBcblx0XHQgKiAgICAgICAgIFJlYWQgbW9yZSBhdCBbbXVzaWMuY29sdW1iaWEuZWR1XShodHRwOi8vbXVzaWMuY29sdW1iaWEuZWR1L2NtYy9tdXNpY2FuZGNvbXB1dGVycy9jaGFwdGVyNC8wNF8wNi5waHApLlxuXHRcdCAqXG5cdFx0ICogIEBleHRlbmRzIHtUb25lLkVmZmVjdH1cblx0XHQgKiAgQGNvbnN0cnVjdG9yXG5cdFx0ICogIEBwYXJhbSB7UG9zaXRpdmV8T2JqZWN0fSBbb3JkZXJdIFRoZSBvcmRlciBvZiB0aGUgY2hlYnlzaGV2IHBvbHlub21pYWwuIE5vcm1hbCByYW5nZSBiZXR3ZWVuIDEtMTAwLiBcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAvL2NyZWF0ZSBhIG5ldyBjaGVieVxuXHRcdCAqIHZhciBjaGVieSA9IG5ldyBUb25lLkNoZWJ5c2hldig1MCk7XG5cdFx0ICogLy9jcmVhdGUgYSBtb25vc3ludGggY29ubmVjdGVkIHRvIG91ciBjaGVieVxuXHRcdCAqIHN5bnRoID0gbmV3IFRvbmUuTW9ub1N5bnRoKCkuY29ubmVjdChjaGVieSk7XG5cdFx0ICovXG5cdCAgICBUb25lLkNoZWJ5c2hldiA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgb3B0aW9ucyA9IFRvbmUuZGVmYXVsdHMoYXJndW1lbnRzLCBbJ29yZGVyJ10sIFRvbmUuQ2hlYnlzaGV2KTtcblx0ICAgICAgICBUb25lLkVmZmVjdC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIEB0eXBlIHtXYXZlU2hhcGVyTm9kZX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fc2hhcGVyID0gbmV3IFRvbmUuV2F2ZVNoYXBlcig0MDk2KTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqIGhvbGRzIG9udG8gdGhlIG9yZGVyIG9mIHRoZSBmaWx0ZXJcblx0XHRcdCAqIEB0eXBlIHtudW1iZXJ9XG5cdFx0XHQgKiBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fb3JkZXIgPSBvcHRpb25zLm9yZGVyO1xuXHQgICAgICAgIHRoaXMuY29ubmVjdEVmZmVjdCh0aGlzLl9zaGFwZXIpO1xuXHQgICAgICAgIHRoaXMub3JkZXIgPSBvcHRpb25zLm9yZGVyO1xuXHQgICAgICAgIHRoaXMub3ZlcnNhbXBsZSA9IG9wdGlvbnMub3ZlcnNhbXBsZTtcblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLkNoZWJ5c2hldiwgVG9uZS5FZmZlY3QpO1xuXHQgICAgLyoqXG5cdFx0ICogIEBzdGF0aWNcblx0XHQgKiAgQGNvbnN0XG5cdFx0ICogIEB0eXBlIHtPYmplY3R9XG5cdFx0ICovXG5cdCAgICBUb25lLkNoZWJ5c2hldi5kZWZhdWx0cyA9IHtcblx0ICAgICAgICAnb3JkZXInOiAxLFxuXHQgICAgICAgICdvdmVyc2FtcGxlJzogJ25vbmUnXG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIGdldCB0aGUgY29lZmZpY2llbnQgZm9yIHRoYXQgZGVncmVlXG5cdFx0ICogIEBwYXJhbSB7bnVtYmVyfSB4IHRoZSB4IHZhbHVlXG5cdFx0ICogIEBwYXJhbSAgIHtudW1iZXJ9IGRlZ3JlZSBcblx0XHQgKiAgQHBhcmFtIHtPYmplY3R9IG1lbW8gbWVtb2l6ZSB0aGUgY29tcHV0ZWQgdmFsdWUuIFxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgICB0aGlzIHNwZWVkcyB1cCBjb21wdXRhdGlvbiBncmVhdGx5LiBcblx0XHQgKiAgQHJldHVybiAge251bWJlcn0gICAgICAgdGhlIGNvZWZmaWNpZW50IFxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5DaGVieXNoZXYucHJvdG90eXBlLl9nZXRDb2VmZmljaWVudCA9IGZ1bmN0aW9uICh4LCBkZWdyZWUsIG1lbW8pIHtcblx0ICAgICAgICBpZiAobWVtby5oYXNPd25Qcm9wZXJ0eShkZWdyZWUpKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBtZW1vW2RlZ3JlZV07XG5cdCAgICAgICAgfSBlbHNlIGlmIChkZWdyZWUgPT09IDApIHtcblx0ICAgICAgICAgICAgbWVtb1tkZWdyZWVdID0gMDtcblx0ICAgICAgICB9IGVsc2UgaWYgKGRlZ3JlZSA9PT0gMSkge1xuXHQgICAgICAgICAgICBtZW1vW2RlZ3JlZV0gPSB4O1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIG1lbW9bZGVncmVlXSA9IDIgKiB4ICogdGhpcy5fZ2V0Q29lZmZpY2llbnQoeCwgZGVncmVlIC0gMSwgbWVtbykgLSB0aGlzLl9nZXRDb2VmZmljaWVudCh4LCBkZWdyZWUgLSAyLCBtZW1vKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIG1lbW9bZGVncmVlXTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiBUaGUgb3JkZXIgb2YgdGhlIENoZWJ5c2hldiBwb2x5bm9taWFsIHdoaWNoIGNyZWF0ZXNcblx0XHQgKiB0aGUgZXF1YXRpb24gd2hpY2ggaXMgYXBwbGllZCB0byB0aGUgaW5jb21pbmcgXG5cdFx0ICogc2lnbmFsIHRocm91Z2ggYSBUb25lLldhdmVTaGFwZXIuIFRoZSBlcXVhdGlvbnNcblx0XHQgKiBhcmUgaW4gdGhlIGZvcm06PGJyPlxuXHRcdCAqIG9yZGVyIDI6IDJ4XjIgKyAxPGJyPlxuXHRcdCAqIG9yZGVyIDM6IDR4XjMgKyAzeCA8YnI+XG5cdFx0ICogQG1lbWJlck9mIFRvbmUuQ2hlYnlzaGV2I1xuXHRcdCAqIEB0eXBlIHtQb3NpdGl2ZX1cblx0XHQgKiBAbmFtZSBvcmRlclxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuQ2hlYnlzaGV2LnByb3RvdHlwZSwgJ29yZGVyJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fb3JkZXI7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChvcmRlcikge1xuXHQgICAgICAgICAgICB0aGlzLl9vcmRlciA9IG9yZGVyO1xuXHQgICAgICAgICAgICB2YXIgY3VydmUgPSBuZXcgQXJyYXkoNDA5Nik7XG5cdCAgICAgICAgICAgIHZhciBsZW4gPSBjdXJ2ZS5sZW5ndGg7XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcblx0ICAgICAgICAgICAgICAgIHZhciB4ID0gaSAqIDIgLyBsZW4gLSAxO1xuXHQgICAgICAgICAgICAgICAgaWYgKHggPT09IDApIHtcblx0ICAgICAgICAgICAgICAgICAgICAvL3Nob3VsZCBvdXRwdXQgMCB3aGVuIGlucHV0IGlzIDBcblx0ICAgICAgICAgICAgICAgICAgICBjdXJ2ZVtpXSA9IDA7XG5cdCAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIGN1cnZlW2ldID0gdGhpcy5fZ2V0Q29lZmZpY2llbnQoeCwgb3JkZXIsIHt9KTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB0aGlzLl9zaGFwZXIuY3VydmUgPSBjdXJ2ZTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqIFRoZSBvdmVyc2FtcGxpbmcgb2YgdGhlIGVmZmVjdC4gQ2FuIGVpdGhlciBiZSBcIm5vbmVcIiwgXCIyeFwiIG9yIFwiNHhcIi5cblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5DaGVieXNoZXYjXG5cdFx0ICogQHR5cGUge3N0cmluZ31cblx0XHQgKiBAbmFtZSBvdmVyc2FtcGxlXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5DaGVieXNoZXYucHJvdG90eXBlLCAnb3ZlcnNhbXBsZScsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NoYXBlci5vdmVyc2FtcGxlO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAob3ZlcnNhbXBsaW5nKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3NoYXBlci5vdmVyc2FtcGxlID0gb3ZlcnNhbXBsaW5nO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIENsZWFuIHVwLiBcblx0XHQgKiAgQHJldHVybnMge1RvbmUuQ2hlYnlzaGV2fSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkNoZWJ5c2hldi5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLkVmZmVjdC5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuX3NoYXBlci5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fc2hhcGVyID0gbnVsbDtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVG9uZS5DaGVieXNoZXY7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyBCYXNlIGNsYXNzIGZvciBTdGVyZW8gZWZmZWN0cy4gUHJvdmlkZXMgZWZmZWN0U2VuZEwvUiBhbmQgZWZmZWN0UmV0dXJuTC9SLlxuXHRcdCAqXG5cdFx0ICpcdEBjb25zdHJ1Y3RvclxuXHRcdCAqXHRAZXh0ZW5kcyB7VG9uZS5FZmZlY3R9XG5cdFx0ICovXG5cdCAgICBUb25lLlN0ZXJlb0VmZmVjdCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAvL2dldCB0aGUgZGVmYXVsdHNcblx0ICAgICAgICBUb25lLkF1ZGlvTm9kZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHZhciBvcHRpb25zID0gVG9uZS5kZWZhdWx0cyhhcmd1bWVudHMsIFsnd2V0J10sIFRvbmUuRWZmZWN0KTtcblx0ICAgICAgICB0aGlzLmNyZWF0ZUluc091dHMoMSwgMSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgdGhlIGRyeXdldCBrbm9iIHRvIGNvbnRyb2wgdGhlIGFtb3VudCBvZiBlZmZlY3Rcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5Dcm9zc0ZhZGV9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2RyeVdldCA9IG5ldyBUb25lLkNyb3NzRmFkZShvcHRpb25zLndldCk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIHdldCBjb250cm9sLCBpLmUuIGhvdyBtdWNoIG9mIHRoZSBlZmZlY3RlZFxuXHRcdFx0ICogIHdpbGwgcGFzcyB0aHJvdWdoIHRvIHRoZSBvdXRwdXQuXG5cdFx0XHQgKiAgQHR5cGUge05vcm1hbFJhbmdlfVxuXHRcdFx0ICogIEBzaWduYWxcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMud2V0ID0gdGhpcy5fZHJ5V2V0LmZhZGU7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgdGhlbiBzcGxpdCBpdFxuXHRcdFx0ICogIEB0eXBlIHtUb25lLlNwbGl0fVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9zcGxpdCA9IG5ldyBUb25lLlNwbGl0KCk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgdGhlIGVmZmVjdHMgc2VuZCBMRUZUXG5cdFx0XHQgKiAgQHR5cGUge0dhaW5Ob2RlfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmVmZmVjdFNlbmRMID0gdGhpcy5fc3BsaXQubGVmdDtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICB0aGUgZWZmZWN0cyBzZW5kIFJJR0hUXG5cdFx0XHQgKiAgQHR5cGUge0dhaW5Ob2RlfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmVmZmVjdFNlbmRSID0gdGhpcy5fc3BsaXQucmlnaHQ7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgdGhlIHN0ZXJlbyBlZmZlY3QgbWVyZ2VyXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuTWVyZ2V9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX21lcmdlID0gbmV3IFRvbmUuTWVyZ2UoKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICB0aGUgZWZmZWN0IHJldHVybiBMRUZUXG5cdFx0XHQgKiAgQHR5cGUge0dhaW5Ob2RlfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmVmZmVjdFJldHVybkwgPSB0aGlzLl9tZXJnZS5sZWZ0O1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHRoZSBlZmZlY3QgcmV0dXJuIFJJR0hUXG5cdFx0XHQgKiAgQHR5cGUge0dhaW5Ob2RlfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmVmZmVjdFJldHVyblIgPSB0aGlzLl9tZXJnZS5yaWdodDtcblx0ICAgICAgICAvL2Nvbm5lY3Rpb25zXG5cdCAgICAgICAgdGhpcy5pbnB1dC5jb25uZWN0KHRoaXMuX3NwbGl0KTtcblx0ICAgICAgICAvL2RyeSB3ZXQgY29ubmVjdGlvbnNcblx0ICAgICAgICB0aGlzLmlucHV0LmNvbm5lY3QodGhpcy5fZHJ5V2V0LCAwLCAwKTtcblx0ICAgICAgICB0aGlzLl9tZXJnZS5jb25uZWN0KHRoaXMuX2RyeVdldCwgMCwgMSk7XG5cdCAgICAgICAgdGhpcy5fZHJ5V2V0LmNvbm5lY3QodGhpcy5vdXRwdXQpO1xuXHQgICAgICAgIHRoaXMuX3JlYWRPbmx5KFsnd2V0J10pO1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuU3RlcmVvRWZmZWN0LCBUb25lLkVmZmVjdCk7XG5cdCAgICAvKipcblx0XHQgKiAgQ2xlYW4gdXAuXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLlN0ZXJlb0VmZmVjdH0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5TdGVyZW9FZmZlY3QucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5BdWRpb05vZGUucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLl9kcnlXZXQuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX2RyeVdldCA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fc3BsaXQuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX3NwbGl0ID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9tZXJnZS5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fbWVyZ2UgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuZWZmZWN0U2VuZEwgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuZWZmZWN0U2VuZFIgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuZWZmZWN0UmV0dXJuTCA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5lZmZlY3RSZXR1cm5SID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl93cml0YWJsZShbJ3dldCddKTtcblx0ICAgICAgICB0aGlzLndldCA9IG51bGw7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuU3RlcmVvRWZmZWN0O1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqIFx0QGNsYXNzICBUb25lLkZlZWRiYWNrRWZmZWN0IHByb3ZpZGVzIGEgbG9vcCBiZXR3ZWVuIGFuIFxuXHRcdCAqIFx0ICAgICAgICBhdWRpbyBzb3VyY2UgYW5kIGl0cyBvd24gb3V0cHV0LiBUaGlzIGlzIGEgYmFzZS1jbGFzc1xuXHRcdCAqIFx0ICAgICAgICBmb3IgZmVlZGJhY2sgZWZmZWN0cy4gXG5cdFx0ICpcblx0XHQgKiAgQGNvbnN0cnVjdG9yXG5cdFx0ICogIEBleHRlbmRzIHtUb25lLkVmZmVjdH1cblx0XHQgKiAgQHBhcmFtIHtOb3JtYWxSYW5nZXxPYmplY3R9IFtmZWVkYmFja10gVGhlIGluaXRpYWwgZmVlZGJhY2sgdmFsdWUuXG5cdFx0ICovXG5cdCAgICBUb25lLkZlZWRiYWNrRWZmZWN0ID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBvcHRpb25zID0gVG9uZS5kZWZhdWx0cyhhcmd1bWVudHMsIFsnZmVlZGJhY2snXSwgVG9uZS5GZWVkYmFja0VmZmVjdCk7XG5cdCAgICAgICAgVG9uZS5FZmZlY3QuY2FsbCh0aGlzLCBvcHRpb25zKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICB0aGUgZ2FpbiB3aGljaCBjb250cm9scyB0aGUgZmVlZGJhY2tcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5HYWlufVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9mZWVkYmFja0dhaW4gPSBuZXcgVG9uZS5HYWluKG9wdGlvbnMuZmVlZGJhY2ssIFRvbmUuVHlwZS5Ob3JtYWxSYW5nZSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGFtb3VudCBvZiBzaWduYWwgd2hpY2ggaXMgZmVkIGJhY2sgaW50byB0aGUgZWZmZWN0IGlucHV0LiBcblx0XHRcdCAqICBAdHlwZSB7Tm9ybWFsUmFuZ2V9XG5cdFx0XHQgKiAgQHNpZ25hbFxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5mZWVkYmFjayA9IHRoaXMuX2ZlZWRiYWNrR2Fpbi5nYWluO1xuXHQgICAgICAgIC8vdGhlIGZlZWRiYWNrIGxvb3Bcblx0ICAgICAgICB0aGlzLmVmZmVjdFJldHVybi5jaGFpbih0aGlzLl9mZWVkYmFja0dhaW4sIHRoaXMuZWZmZWN0U2VuZCk7XG5cdCAgICAgICAgdGhpcy5fcmVhZE9ubHkoWydmZWVkYmFjayddKTtcblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLkZlZWRiYWNrRWZmZWN0LCBUb25lLkVmZmVjdCk7XG5cdCAgICAvKipcblx0XHQgKiAgQHN0YXRpY1xuXHRcdCAqICBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqL1xuXHQgICAgVG9uZS5GZWVkYmFja0VmZmVjdC5kZWZhdWx0cyA9IHsgJ2ZlZWRiYWNrJzogMC4xMjUgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBDbGVhbiB1cC4gXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLkZlZWRiYWNrRWZmZWN0fSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkZlZWRiYWNrRWZmZWN0LnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuRWZmZWN0LnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgdGhpcy5fd3JpdGFibGUoWydmZWVkYmFjayddKTtcblx0ICAgICAgICB0aGlzLl9mZWVkYmFja0dhaW4uZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX2ZlZWRiYWNrR2FpbiA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5mZWVkYmFjayA9IG51bGw7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuRmVlZGJhY2tFZmZlY3Q7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyBKdXN0IGxpa2UgYSBzdGVyZW8gZmVlZGJhY2sgZWZmZWN0LCBidXQgdGhlIGZlZWRiYWNrIGlzIHJvdXRlZCBmcm9tIGxlZnQgdG8gcmlnaHRcblx0XHQgKiAgICAgICAgIGFuZCByaWdodCB0byBsZWZ0IGluc3RlYWQgb2Ygb24gdGhlIHNhbWUgY2hhbm5lbC5cblx0XHQgKlxuXHRcdCAqXHRAY29uc3RydWN0b3Jcblx0XHQgKlx0QGV4dGVuZHMge1RvbmUuU3RlcmVvRWZmZWN0fVxuXHRcdCAqL1xuXHQgICAgVG9uZS5TdGVyZW9YRmVlZGJhY2tFZmZlY3QgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIG9wdGlvbnMgPSBUb25lLmRlZmF1bHRzKGFyZ3VtZW50cywgWydmZWVkYmFjayddLCBUb25lLkZlZWRiYWNrRWZmZWN0KTtcblx0ICAgICAgICBUb25lLlN0ZXJlb0VmZmVjdC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBhbW91bnQgb2YgZmVlZGJhY2sgZnJvbSB0aGUgb3V0cHV0XG5cdFx0XHQgKiAgYmFjayBpbnRvIHRoZSBpbnB1dCBvZiB0aGUgZWZmZWN0IChyb3V0ZWRcblx0XHRcdCAqICBhY3Jvc3MgbGVmdCBhbmQgcmlnaHQgY2hhbm5lbHMpLlxuXHRcdFx0ICogIEB0eXBlIHtOb3JtYWxSYW5nZX1cblx0XHRcdCAqICBAc2lnbmFsXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmZlZWRiYWNrID0gbmV3IFRvbmUuU2lnbmFsKG9wdGlvbnMuZmVlZGJhY2ssIFRvbmUuVHlwZS5Ob3JtYWxSYW5nZSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgdGhlIGxlZnQgc2lkZSBmZWViYWNrXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuR2Fpbn1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fZmVlZGJhY2tMUiA9IG5ldyBUb25lLkdhaW4oKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICB0aGUgcmlnaHQgc2lkZSBmZWViYWNrXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuR2Fpbn1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fZmVlZGJhY2tSTCA9IG5ldyBUb25lLkdhaW4oKTtcblx0ICAgICAgICAvL2Nvbm5lY3QgaXQgdXBcblx0ICAgICAgICB0aGlzLmVmZmVjdFJldHVybkwuY2hhaW4odGhpcy5fZmVlZGJhY2tMUiwgdGhpcy5lZmZlY3RTZW5kUik7XG5cdCAgICAgICAgdGhpcy5lZmZlY3RSZXR1cm5SLmNoYWluKHRoaXMuX2ZlZWRiYWNrUkwsIHRoaXMuZWZmZWN0U2VuZEwpO1xuXHQgICAgICAgIHRoaXMuZmVlZGJhY2suZmFuKHRoaXMuX2ZlZWRiYWNrTFIuZ2FpbiwgdGhpcy5fZmVlZGJhY2tSTC5nYWluKTtcblx0ICAgICAgICB0aGlzLl9yZWFkT25seShbJ2ZlZWRiYWNrJ10pO1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuU3RlcmVvWEZlZWRiYWNrRWZmZWN0LCBUb25lLlN0ZXJlb0VmZmVjdCk7XG5cdCAgICAvKipcblx0XHQgKiAgY2xlYW4gdXBcblx0XHQgKiAgQHJldHVybnMge1RvbmUuU3RlcmVvWEZlZWRiYWNrRWZmZWN0fSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLlN0ZXJlb1hGZWVkYmFja0VmZmVjdC5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLlN0ZXJlb0VmZmVjdC5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuX3dyaXRhYmxlKFsnZmVlZGJhY2snXSk7XG5cdCAgICAgICAgdGhpcy5mZWVkYmFjay5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5mZWVkYmFjayA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fZmVlZGJhY2tMUi5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fZmVlZGJhY2tMUiA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fZmVlZGJhY2tSTC5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fZmVlZGJhY2tSTCA9IG51bGw7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuU3RlcmVvWEZlZWRiYWNrRWZmZWN0O1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgVG9uZS5DaG9ydXMgaXMgYSBzdGVyZW8gY2hvcnVzIGVmZmVjdCB3aXRoIGZlZWRiYWNrIGNvbXBvc2VkIG9mIFxuXHRcdCAqICAgICAgICAgYSBsZWZ0IGFuZCByaWdodCBkZWxheSB3aXRoIGEgVG9uZS5MRk8gYXBwbGllZCB0byB0aGUgZGVsYXlUaW1lIG9mIGVhY2ggY2hhbm5lbC4gXG5cdFx0ICogICAgICAgICBJbnNwaXJhdGlvbiBmcm9tIFtUdW5hLmpzXShodHRwczovL2dpdGh1Yi5jb20vRGluYWhtb2UvdHVuYS9ibG9iL21hc3Rlci90dW5hLmpzKS5cblx0XHQgKiAgICAgICAgIFJlYWQgbW9yZSBvbiB0aGUgY2hvcnVzIGVmZmVjdCBvbiBbU291bmRPblNvdW5kXShodHRwOi8vd3d3LnNvdW5kb25zb3VuZC5jb20vc29zL2p1bjA0L2FydGljbGVzL3N5bnRoc2VjcmV0cy5odG0pLlxuXHRcdCAqXG5cdFx0ICpcdEBjb25zdHJ1Y3RvclxuXHRcdCAqXHRAZXh0ZW5kcyB7VG9uZS5TdGVyZW9YRmVlZGJhY2tFZmZlY3R9XG5cdFx0ICpcdEBwYXJhbSB7RnJlcXVlbmN5fE9iamVjdH0gW2ZyZXF1ZW5jeV0gVGhlIGZyZXF1ZW5jeSBvZiB0aGUgTEZPLlxuXHRcdCAqXHRAcGFyYW0ge01pbGxpc2Vjb25kc30gW2RlbGF5VGltZV0gVGhlIGRlbGF5IG9mIHRoZSBjaG9ydXMgZWZmZWN0IGluIG1zLiBcblx0XHQgKlx0QHBhcmFtIHtOb3JtYWxSYW5nZX0gW2RlcHRoXSBUaGUgZGVwdGggb2YgdGhlIGNob3J1cy5cblx0XHQgKlx0QGV4YW1wbGVcblx0XHQgKiB2YXIgY2hvcnVzID0gbmV3IFRvbmUuQ2hvcnVzKDQsIDIuNSwgMC41KTtcblx0XHQgKiB2YXIgc3ludGggPSBuZXcgVG9uZS5Qb2x5U3ludGgoNCwgVG9uZS5Nb25vU3ludGgpLmNvbm5lY3QoY2hvcnVzKTtcblx0XHQgKiBzeW50aC50cmlnZ2VyQXR0YWNrUmVsZWFzZShbXCJDM1wiLFwiRTNcIixcIkczXCJdLCBcIjhuXCIpO1xuXHRcdCAqL1xuXHQgICAgVG9uZS5DaG9ydXMgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIG9wdGlvbnMgPSBUb25lLmRlZmF1bHRzKGFyZ3VtZW50cywgW1xuXHQgICAgICAgICAgICAnZnJlcXVlbmN5Jyxcblx0ICAgICAgICAgICAgJ2RlbGF5VGltZScsXG5cdCAgICAgICAgICAgICdkZXB0aCdcblx0ICAgICAgICBdLCBUb25lLkNob3J1cyk7XG5cdCAgICAgICAgVG9uZS5TdGVyZW9YRmVlZGJhY2tFZmZlY3QuY2FsbCh0aGlzLCBvcHRpb25zKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICB0aGUgZGVwdGggb2YgdGhlIGNob3J1c1xuXHRcdFx0ICogIEB0eXBlIHtudW1iZXJ9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2RlcHRoID0gb3B0aW9ucy5kZXB0aDtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICB0aGUgZGVsYXlUaW1lXG5cdFx0XHQgKiAgQHR5cGUge251bWJlcn1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fZGVsYXlUaW1lID0gb3B0aW9ucy5kZWxheVRpbWUgLyAxMDAwO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHRoZSBsZm8gd2hpY2ggY29udHJvbHMgdGhlIGRlbGF5VGltZVxuXHRcdFx0ICogIEB0eXBlIHtUb25lLkxGT31cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fbGZvTCA9IG5ldyBUb25lLkxGTyh7XG5cdCAgICAgICAgICAgICdmcmVxdWVuY3knOiBvcHRpb25zLmZyZXF1ZW5jeSxcblx0ICAgICAgICAgICAgJ21pbic6IDAsXG5cdCAgICAgICAgICAgICdtYXgnOiAxXG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgYW5vdGhlciBMRk8gZm9yIHRoZSByaWdodCBzaWRlIHdpdGggYSAxODAgZGVncmVlIHBoYXNlIGRpZmZcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5MRk99XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2xmb1IgPSBuZXcgVG9uZS5MRk8oe1xuXHQgICAgICAgICAgICAnZnJlcXVlbmN5Jzogb3B0aW9ucy5mcmVxdWVuY3ksXG5cdCAgICAgICAgICAgICdtaW4nOiAwLFxuXHQgICAgICAgICAgICAnbWF4JzogMSxcblx0ICAgICAgICAgICAgJ3BoYXNlJzogMTgwXG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgZGVsYXkgZm9yIGxlZnRcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5EZWxheX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fZGVsYXlOb2RlTCA9IG5ldyBUb25lLkRlbGF5KCk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgZGVsYXkgZm9yIHJpZ2h0XG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuRGVsYXl9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2RlbGF5Tm9kZVIgPSBuZXcgVG9uZS5EZWxheSgpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogVGhlIGZyZXF1ZW5jeSBvZiB0aGUgTEZPIHdoaWNoIG1vZHVsYXRlcyB0aGUgZGVsYXlUaW1lLiBcblx0XHRcdCAqIEB0eXBlIHtGcmVxdWVuY3l9XG5cdFx0XHQgKiBAc2lnbmFsXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmZyZXF1ZW5jeSA9IHRoaXMuX2xmb0wuZnJlcXVlbmN5O1xuXHQgICAgICAgIC8vY29ubmVjdGlvbnNcblx0ICAgICAgICB0aGlzLmVmZmVjdFNlbmRMLmNoYWluKHRoaXMuX2RlbGF5Tm9kZUwsIHRoaXMuZWZmZWN0UmV0dXJuTCk7XG5cdCAgICAgICAgdGhpcy5lZmZlY3RTZW5kUi5jaGFpbih0aGlzLl9kZWxheU5vZGVSLCB0aGlzLmVmZmVjdFJldHVyblIpO1xuXHQgICAgICAgIC8vYW5kIHBhc3MgdGhyb3VnaCB0byBtYWtlIHRoZSBkZXR1bmUgYXBwYXJlbnRcblx0ICAgICAgICB0aGlzLmVmZmVjdFNlbmRMLmNvbm5lY3QodGhpcy5lZmZlY3RSZXR1cm5MKTtcblx0ICAgICAgICB0aGlzLmVmZmVjdFNlbmRSLmNvbm5lY3QodGhpcy5lZmZlY3RSZXR1cm5SKTtcblx0ICAgICAgICAvL2xmbyBzZXR1cFxuXHQgICAgICAgIHRoaXMuX2xmb0wuY29ubmVjdCh0aGlzLl9kZWxheU5vZGVMLmRlbGF5VGltZSk7XG5cdCAgICAgICAgdGhpcy5fbGZvUi5jb25uZWN0KHRoaXMuX2RlbGF5Tm9kZVIuZGVsYXlUaW1lKTtcblx0ICAgICAgICAvL3N0YXJ0IHRoZSBsZm9cblx0ICAgICAgICB0aGlzLl9sZm9MLnN0YXJ0KCk7XG5cdCAgICAgICAgdGhpcy5fbGZvUi5zdGFydCgpO1xuXHQgICAgICAgIC8vaGF2ZSBvbmUgTEZPIGZyZXF1ZW5jeSBjb250cm9sIHRoZSBvdGhlclxuXHQgICAgICAgIHRoaXMuX2xmb0wuZnJlcXVlbmN5LmNvbm5lY3QodGhpcy5fbGZvUi5mcmVxdWVuY3kpO1xuXHQgICAgICAgIC8vc2V0IHRoZSBpbml0aWFsIHZhbHVlc1xuXHQgICAgICAgIHRoaXMuZGVwdGggPSB0aGlzLl9kZXB0aDtcblx0ICAgICAgICB0aGlzLmZyZXF1ZW5jeS52YWx1ZSA9IG9wdGlvbnMuZnJlcXVlbmN5O1xuXHQgICAgICAgIHRoaXMudHlwZSA9IG9wdGlvbnMudHlwZTtcblx0ICAgICAgICB0aGlzLl9yZWFkT25seShbJ2ZyZXF1ZW5jeSddKTtcblx0ICAgICAgICB0aGlzLnNwcmVhZCA9IG9wdGlvbnMuc3ByZWFkO1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuQ2hvcnVzLCBUb25lLlN0ZXJlb1hGZWVkYmFja0VmZmVjdCk7XG5cdCAgICAvKipcblx0XHQgKiAgQHN0YXRpY1xuXHRcdCAqICBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqL1xuXHQgICAgVG9uZS5DaG9ydXMuZGVmYXVsdHMgPSB7XG5cdCAgICAgICAgJ2ZyZXF1ZW5jeSc6IDEuNSxcblx0ICAgICAgICAnZGVsYXlUaW1lJzogMy41LFxuXHQgICAgICAgICdkZXB0aCc6IDAuNyxcblx0ICAgICAgICAnZmVlZGJhY2snOiAwLjEsXG5cdCAgICAgICAgJ3R5cGUnOiAnc2luZScsXG5cdCAgICAgICAgJ3NwcmVhZCc6IDE4MFxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqIFRoZSBkZXB0aCBvZiB0aGUgZWZmZWN0LiBBIGRlcHRoIG9mIDEgbWFrZXMgdGhlIGRlbGF5VGltZVxuXHRcdCAqIG1vZHVsYXRlIGJldHdlZW4gMCBhbmQgMipkZWxheVRpbWUgKGNlbnRlcmVkIGFyb3VuZCB0aGUgZGVsYXlUaW1lKS4gXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuQ2hvcnVzI1xuXHRcdCAqIEB0eXBlIHtOb3JtYWxSYW5nZX1cblx0XHQgKiBAbmFtZSBkZXB0aFxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuQ2hvcnVzLnByb3RvdHlwZSwgJ2RlcHRoJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fZGVwdGg7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChkZXB0aCkge1xuXHQgICAgICAgICAgICB0aGlzLl9kZXB0aCA9IGRlcHRoO1xuXHQgICAgICAgICAgICB2YXIgZGV2aWF0aW9uID0gdGhpcy5fZGVsYXlUaW1lICogZGVwdGg7XG5cdCAgICAgICAgICAgIHRoaXMuX2xmb0wubWluID0gTWF0aC5tYXgodGhpcy5fZGVsYXlUaW1lIC0gZGV2aWF0aW9uLCAwKTtcblx0ICAgICAgICAgICAgdGhpcy5fbGZvTC5tYXggPSB0aGlzLl9kZWxheVRpbWUgKyBkZXZpYXRpb247XG5cdCAgICAgICAgICAgIHRoaXMuX2xmb1IubWluID0gTWF0aC5tYXgodGhpcy5fZGVsYXlUaW1lIC0gZGV2aWF0aW9uLCAwKTtcblx0ICAgICAgICAgICAgdGhpcy5fbGZvUi5tYXggPSB0aGlzLl9kZWxheVRpbWUgKyBkZXZpYXRpb247XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiBUaGUgZGVsYXlUaW1lIGluIG1pbGxpc2Vjb25kcyBvZiB0aGUgY2hvcnVzLiBBIGxhcmdlciBkZWxheVRpbWVcblx0XHQgKiB3aWxsIGdpdmUgYSBtb3JlIHByb25vdW5jZWQgZWZmZWN0LiBOb21pbmFsIHJhbmdlIGEgZGVsYXlUaW1lXG5cdFx0ICogaXMgYmV0d2VlbiAyIGFuZCAyMG1zLiBcblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5DaG9ydXMjXG5cdFx0ICogQHR5cGUge01pbGxpc2Vjb25kc31cblx0XHQgKiBAbmFtZSBkZWxheVRpbWVcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkNob3J1cy5wcm90b3R5cGUsICdkZWxheVRpbWUnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9kZWxheVRpbWUgKiAxMDAwO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAoZGVsYXlUaW1lKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2RlbGF5VGltZSA9IGRlbGF5VGltZSAvIDEwMDA7XG5cdCAgICAgICAgICAgIHRoaXMuZGVwdGggPSB0aGlzLl9kZXB0aDtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqIFRoZSBvc2NpbGxhdG9yIHR5cGUgb2YgdGhlIExGTy4gXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuQ2hvcnVzI1xuXHRcdCAqIEB0eXBlIHtzdHJpbmd9XG5cdFx0ICogQG5hbWUgdHlwZVxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuQ2hvcnVzLnByb3RvdHlwZSwgJ3R5cGUnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9sZm9MLnR5cGU7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uICh0eXBlKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2xmb0wudHlwZSA9IHR5cGU7XG5cdCAgICAgICAgICAgIHRoaXMuX2xmb1IudHlwZSA9IHR5cGU7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKiogXG5cdFx0ICogQW1vdW50IG9mIHN0ZXJlbyBzcHJlYWQuIFdoZW4gc2V0IHRvIDAsIGJvdGggTEZPJ3Mgd2lsbCBiZSBwYW5uZWQgY2VudHJhbGx5LlxuXHRcdCAqIFdoZW4gc2V0IHRvIDE4MCwgTEZPJ3Mgd2lsbCBiZSBwYW5uZWQgaGFyZCBsZWZ0IGFuZCByaWdodCByZXNwZWN0aXZlbHkuXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuQ2hvcnVzI1xuXHRcdCAqIEB0eXBlIHtEZWdyZWVzfVxuXHRcdCAqIEBuYW1lIHNwcmVhZFxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuQ2hvcnVzLnByb3RvdHlwZSwgJ3NwcmVhZCcsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xmb1IucGhhc2UgLSB0aGlzLl9sZm9MLnBoYXNlO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAoc3ByZWFkKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2xmb0wucGhhc2UgPSA5MCAtIHNwcmVhZCAvIDI7XG5cdCAgICAgICAgICAgIHRoaXMuX2xmb1IucGhhc2UgPSBzcHJlYWQgLyAyICsgOTA7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgQ2xlYW4gdXAuIFxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5DaG9ydXN9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuQ2hvcnVzLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuU3RlcmVvWEZlZWRiYWNrRWZmZWN0LnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgdGhpcy5fbGZvTC5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fbGZvTCA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fbGZvUi5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fbGZvUiA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fZGVsYXlOb2RlTC5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fZGVsYXlOb2RlTCA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fZGVsYXlOb2RlUi5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fZGVsYXlOb2RlUiA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fd3JpdGFibGUoJ2ZyZXF1ZW5jeScpO1xuXHQgICAgICAgIHRoaXMuZnJlcXVlbmN5ID0gbnVsbDtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVG9uZS5DaG9ydXM7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyAgVG9uZS5Db252b2x2ZXIgaXMgYSB3cmFwcGVyIGFyb3VuZCB0aGUgTmF0aXZlIFdlYiBBdWRpbyBcblx0XHQgKiAgICAgICAgICBbQ29udm9sdmVyTm9kZV0oaHR0cDovL3dlYmF1ZGlvLmdpdGh1Yi5pby93ZWItYXVkaW8tYXBpLyN0aGUtY29udm9sdmVybm9kZS1pbnRlcmZhY2UpLlxuXHRcdCAqICAgICAgICAgIENvbnZvbHV0aW9uIGlzIHVzZWZ1bCBmb3IgcmV2ZXJiIGFuZCBmaWx0ZXIgZW11bGF0aW9uLiBSZWFkIG1vcmUgYWJvdXQgY29udm9sdXRpb24gcmV2ZXJiIG9uXG5cdFx0ICogICAgICAgICAgW1dpa2lwZWRpYV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29udm9sdXRpb25fcmV2ZXJiKS5cblx0XHQgKiAgXG5cdFx0ICogIEBjb25zdHJ1Y3RvclxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZS5FZmZlY3R9XG5cdFx0ICogIEBwYXJhbSB7c3RyaW5nfFRvbmUuQnVmZmVyfE9iamVjdH0gW3VybF0gVGhlIFVSTCBvZiB0aGUgaW1wdWxzZSByZXNwb25zZSBvciB0aGUgVG9uZS5CdWZmZXJcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aWFuaW5nIHRoZSBpbXB1bHNlIHJlc3BvbnNlLiBcblx0XHQgKiAgQHBhcmFtIHtGdW5jdGlvbn0gb25sb2FkIFRoZSBjYWxsYmFjayB0byBpbnZva2Ugd2hlbiB0aGUgdXJsIGlzIGxvYWRlZC5cblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAvL2luaXRpYWxpemluZyB0aGUgY29udm9sdmVyIHdpdGggYW4gaW1wdWxzZSByZXNwb25zZVxuXHRcdCAqIHZhciBjb252b2x2ZXIgPSBuZXcgVG9uZS5Db252b2x2ZXIoXCIuL3BhdGgvdG8vaXIud2F2XCIpLnRvTWFzdGVyKCk7XG5cdFx0ICovXG5cdCAgICBUb25lLkNvbnZvbHZlciA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgb3B0aW9ucyA9IFRvbmUuZGVmYXVsdHMoYXJndW1lbnRzLCBbXG5cdCAgICAgICAgICAgICd1cmwnLFxuXHQgICAgICAgICAgICAnb25sb2FkJ1xuXHQgICAgICAgIF0sIFRvbmUuQ29udm9sdmVyKTtcblx0ICAgICAgICBUb25lLkVmZmVjdC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIGNvbnZvbHZlciBub2RlXG5cdFx0XHQgKiAgQHR5cGUge0NvbnZvbHZlck5vZGV9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2NvbnZvbHZlciA9IHRoaXMuY29udGV4dC5jcmVhdGVDb252b2x2ZXIoKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICB0aGUgY29udm9sdXRpb24gYnVmZmVyXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuQnVmZmVyfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9idWZmZXIgPSBuZXcgVG9uZS5CdWZmZXIoKTtcblx0ICAgICAgICBpZiAoVG9uZS5pc1N0cmluZyhvcHRpb25zLnVybCkpIHtcblx0ICAgICAgICAgICAgdGhpcy5fYnVmZmVyLmxvYWQob3B0aW9ucy51cmwsIGZ1bmN0aW9uIChidWZmZXIpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuYnVmZmVyID0gYnVmZmVyO1xuXHQgICAgICAgICAgICAgICAgb3B0aW9ucy5vbmxvYWQoKTtcblx0ICAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcblx0ICAgICAgICB9IGVsc2UgaWYgKG9wdGlvbnMudXJsKSB7XG5cdCAgICAgICAgICAgIHRoaXMuYnVmZmVyID0gb3B0aW9ucy51cmw7XG5cdCAgICAgICAgICAgIG9wdGlvbnMub25sb2FkKCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHRoaXMuY29ubmVjdEVmZmVjdCh0aGlzLl9jb252b2x2ZXIpO1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuQ29udm9sdmVyLCBUb25lLkVmZmVjdCk7XG5cdCAgICAvKipcblx0XHQgKiAgQHN0YXRpY1xuXHRcdCAqICBAY29uc3Rcblx0XHQgKiAgQHR5cGUgIHtPYmplY3R9XG5cdFx0ICovXG5cdCAgICBUb25lLkNvbnZvbHZlci5kZWZhdWx0cyA9IHsgJ29ubG9hZCc6IFRvbmUubm9PcCB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFRoZSBjb252b2x2ZXIncyBidWZmZXJcblx0XHQgKiAgQG1lbWJlck9mIFRvbmUuQ29udm9sdmVyI1xuXHRcdCAqICBAdHlwZSB7QXVkaW9CdWZmZXJ9XG5cdFx0ICogIEBuYW1lIGJ1ZmZlclxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuQ29udm9sdmVyLnByb3RvdHlwZSwgJ2J1ZmZlcicsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2J1ZmZlci5nZXQoKTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKGJ1ZmZlcikge1xuXHQgICAgICAgICAgICB0aGlzLl9idWZmZXIuc2V0KGJ1ZmZlcik7XG5cdCAgICAgICAgICAgIHRoaXMuX2NvbnZvbHZlci5idWZmZXIgPSB0aGlzLl9idWZmZXIuZ2V0KCk7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgTG9hZCBhbiBpbXB1bHNlIHJlc3BvbnNlIHVybCBhcyBhbiBhdWRpbyBidWZmZXIuXG5cdFx0ICogIERlY29kZXMgdGhlIGF1ZGlvIGFzeW5jaHJvbm91c2x5IGFuZCBpbnZva2VzXG5cdFx0ICogIHRoZSBjYWxsYmFjayBvbmNlIHRoZSBhdWRpbyBidWZmZXIgbG9hZHMuXG5cdFx0ICogIEBwYXJhbSB7c3RyaW5nfSB1cmwgVGhlIHVybCBvZiB0aGUgYnVmZmVyIHRvIGxvYWQuXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgZmlsZXR5cGUgc3VwcG9ydCBkZXBlbmRzIG9uIHRoZVxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgIGJyb3dzZXIuXG5cdFx0ICogIEBwYXJhbSAge2Z1bmN0aW9uPX0gY2FsbGJhY2tcblx0XHQgKiAgQHJldHVybnMge1Byb21pc2V9XG5cdFx0ICovXG5cdCAgICBUb25lLkNvbnZvbHZlci5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uICh1cmwsIGNhbGxiYWNrKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuX2J1ZmZlci5sb2FkKHVybCwgZnVuY3Rpb24gKGJ1ZmYpIHtcblx0ICAgICAgICAgICAgdGhpcy5idWZmZXIgPSBidWZmO1xuXHQgICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcblx0ICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9LmJpbmQodGhpcykpO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBDbGVhbiB1cC4gXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLkNvbnZvbHZlcn0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5Db252b2x2ZXIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5FZmZlY3QucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLl9jb252b2x2ZXIuZGlzY29ubmVjdCgpO1xuXHQgICAgICAgIHRoaXMuX2NvbnZvbHZlciA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fYnVmZmVyLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9idWZmZXIgPSBudWxsO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLkNvbnZvbHZlcjtcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgXG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzIFRvbmUuRGlzdG9ydGlvbiBpcyBhIHNpbXBsZSBkaXN0b3J0aW9uIGVmZmVjdCB1c2luZyBUb25lLldhdmVTaGFwZXIuXG5cdFx0ICogICAgICAgICBBbGdvcml0aG0gZnJvbSBbYSBzdGFja292ZXJmbG93IGFuc3dlcl0oaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjIzMTM0MDgpLlxuXHRcdCAqXG5cdFx0ICogIEBleHRlbmRzIHtUb25lLkVmZmVjdH1cblx0XHQgKiAgQGNvbnN0cnVjdG9yXG5cdFx0ICogIEBwYXJhbSB7TnVtYmVyfE9iamVjdH0gW2Rpc3RvcnRpb25dIFRoZSBhbW91bnQgb2YgZGlzdG9ydGlvbiAobm9taW5hbCByYW5nZSBvZiAwLTEpXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogdmFyIGRpc3QgPSBuZXcgVG9uZS5EaXN0b3J0aW9uKDAuOCkudG9NYXN0ZXIoKTtcblx0XHQgKiB2YXIgZm0gPSBuZXcgVG9uZS5TaW1wbGVGTSgpLmNvbm5lY3QoZGlzdCk7XG5cdFx0ICogLy90aGlzIHNvdW5kcyBnb29kIG9uIGJhc3Mgbm90ZXNcblx0XHQgKiBmbS50cmlnZ2VyQXR0YWNrUmVsZWFzZShcIkExXCIsIFwiOG5cIik7XG5cdFx0ICovXG5cdCAgICBUb25lLkRpc3RvcnRpb24gPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIG9wdGlvbnMgPSBUb25lLmRlZmF1bHRzKGFyZ3VtZW50cywgWydkaXN0b3J0aW9uJ10sIFRvbmUuRGlzdG9ydGlvbik7XG5cdCAgICAgICAgVG9uZS5FZmZlY3QuY2FsbCh0aGlzLCBvcHRpb25zKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5XYXZlU2hhcGVyfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9zaGFwZXIgPSBuZXcgVG9uZS5XYXZlU2hhcGVyKDQwOTYpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogaG9sZHMgdGhlIGRpc3RvcnRpb24gYW1vdW50XG5cdFx0XHQgKiBAdHlwZSB7bnVtYmVyfVxuXHRcdFx0ICogQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2Rpc3RvcnRpb24gPSBvcHRpb25zLmRpc3RvcnRpb247XG5cdCAgICAgICAgdGhpcy5jb25uZWN0RWZmZWN0KHRoaXMuX3NoYXBlcik7XG5cdCAgICAgICAgdGhpcy5kaXN0b3J0aW9uID0gb3B0aW9ucy5kaXN0b3J0aW9uO1xuXHQgICAgICAgIHRoaXMub3ZlcnNhbXBsZSA9IG9wdGlvbnMub3ZlcnNhbXBsZTtcblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLkRpc3RvcnRpb24sIFRvbmUuRWZmZWN0KTtcblx0ICAgIC8qKlxuXHRcdCAqICBAc3RhdGljXG5cdFx0ICogIEBjb25zdFxuXHRcdCAqICBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqL1xuXHQgICAgVG9uZS5EaXN0b3J0aW9uLmRlZmF1bHRzID0ge1xuXHQgICAgICAgICdkaXN0b3J0aW9uJzogMC40LFxuXHQgICAgICAgICdvdmVyc2FtcGxlJzogJ25vbmUnXG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogVGhlIGFtb3VudCBvZiBkaXN0b3J0aW9uLlxuXHRcdCAqIEBtZW1iZXJPZiBUb25lLkRpc3RvcnRpb24jXG5cdFx0ICogQHR5cGUge05vcm1hbFJhbmdlfVxuXHRcdCAqIEBuYW1lIGRpc3RvcnRpb25cblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkRpc3RvcnRpb24ucHJvdG90eXBlLCAnZGlzdG9ydGlvbicsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Rpc3RvcnRpb247XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChhbW91bnQpIHtcblx0ICAgICAgICAgICAgdGhpcy5fZGlzdG9ydGlvbiA9IGFtb3VudDtcblx0ICAgICAgICAgICAgdmFyIGsgPSBhbW91bnQgKiAxMDA7XG5cdCAgICAgICAgICAgIHZhciBkZWcgPSBNYXRoLlBJIC8gMTgwO1xuXHQgICAgICAgICAgICB0aGlzLl9zaGFwZXIuc2V0TWFwKGZ1bmN0aW9uICh4KSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoTWF0aC5hYnMoeCkgPCAwLjAwMSkge1xuXHQgICAgICAgICAgICAgICAgICAgIC8vc2hvdWxkIG91dHB1dCAwIHdoZW4gaW5wdXQgaXMgMFxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiAwO1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gKDMgKyBrKSAqIHggKiAyMCAqIGRlZyAvIChNYXRoLlBJICsgayAqIE1hdGguYWJzKHgpKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiBUaGUgb3ZlcnNhbXBsaW5nIG9mIHRoZSBlZmZlY3QuIENhbiBlaXRoZXIgYmUgXCJub25lXCIsIFwiMnhcIiBvciBcIjR4XCIuXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuRGlzdG9ydGlvbiNcblx0XHQgKiBAdHlwZSB7c3RyaW5nfVxuXHRcdCAqIEBuYW1lIG92ZXJzYW1wbGVcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkRpc3RvcnRpb24ucHJvdG90eXBlLCAnb3ZlcnNhbXBsZScsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NoYXBlci5vdmVyc2FtcGxlO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAob3ZlcnNhbXBsaW5nKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3NoYXBlci5vdmVyc2FtcGxlID0gb3ZlcnNhbXBsaW5nO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIENsZWFuIHVwLiBcblx0XHQgKiAgQHJldHVybnMge1RvbmUuRGlzdG9ydGlvbn0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5EaXN0b3J0aW9uLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuRWZmZWN0LnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgdGhpcy5fc2hhcGVyLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9zaGFwZXIgPSBudWxsO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLkRpc3RvcnRpb247XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyAgVG9uZS5GZWVkYmFja0RlbGF5IGlzIGEgRGVsYXlOb2RlIGluIHdoaWNoIHBhcnQgb2Ygb3V0cHV0XG5cdFx0ICogICAgICAgICAgc2lnbmFsIGlzIGZlZCBiYWNrIGludG8gdGhlIGRlbGF5LiBcblx0XHQgKlxuXHRcdCAqICBAY29uc3RydWN0b3Jcblx0XHQgKiAgQGV4dGVuZHMge1RvbmUuRmVlZGJhY2tFZmZlY3R9XG5cdFx0ICogIEBwYXJhbSB7VGltZXxPYmplY3R9IFtkZWxheVRpbWVdIFRoZSBkZWxheSBhcHBsaWVkIHRvIHRoZSBpbmNvbWluZyBzaWduYWwuIFxuXHRcdCAqICBAcGFyYW0ge05vcm1hbFJhbmdlPX0gZmVlZGJhY2sgVGhlIGFtb3VudCBvZiB0aGUgZWZmZWN0ZWQgc2lnbmFsIHdoaWNoIFxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzIGZlZCBiYWNrIHRocm91Z2ggdGhlIGRlbGF5LlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIHZhciBmZWVkYmFja0RlbGF5ID0gbmV3IFRvbmUuRmVlZGJhY2tEZWxheShcIjhuXCIsIDAuNSkudG9NYXN0ZXIoKTtcblx0XHQgKiB2YXIgdG9tID0gbmV3IFRvbmUuRHJ1bVN5bnRoKHtcblx0XHQgKiBcdFwib2N0YXZlc1wiIDogNCxcblx0XHQgKiBcdFwicGl0Y2hEZWNheVwiIDogMC4xXG5cdFx0ICogfSkuY29ubmVjdChmZWVkYmFja0RlbGF5KTtcblx0XHQgKiB0b20udHJpZ2dlckF0dGFja1JlbGVhc2UoXCJBMlwiLFwiMzJuXCIpO1xuXHRcdCAqL1xuXHQgICAgVG9uZS5GZWVkYmFja0RlbGF5ID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBvcHRpb25zID0gVG9uZS5kZWZhdWx0cyhhcmd1bWVudHMsIFtcblx0ICAgICAgICAgICAgJ2RlbGF5VGltZScsXG5cdCAgICAgICAgICAgICdmZWVkYmFjaydcblx0ICAgICAgICBdLCBUb25lLkZlZWRiYWNrRGVsYXkpO1xuXHQgICAgICAgIFRvbmUuRmVlZGJhY2tFZmZlY3QuY2FsbCh0aGlzLCBvcHRpb25zKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICB0aGUgZGVsYXkgbm9kZVxuXHRcdFx0ICogIEB0eXBlIHtUb25lLkRlbGF5fVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9kZWxheU5vZGUgPSBuZXcgVG9uZS5EZWxheShvcHRpb25zLmRlbGF5VGltZSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGRlbGF5VGltZSBvZiB0aGUgRGVsYXlOb2RlLiBcblx0XHRcdCAqICBAdHlwZSB7VGltZX1cblx0XHRcdCAqICBAc2lnbmFsXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmRlbGF5VGltZSA9IHRoaXMuX2RlbGF5Tm9kZS5kZWxheVRpbWU7XG5cdCAgICAgICAgLy8gY29ubmVjdCBpdCB1cFxuXHQgICAgICAgIHRoaXMuY29ubmVjdEVmZmVjdCh0aGlzLl9kZWxheU5vZGUpO1xuXHQgICAgICAgIHRoaXMuX3JlYWRPbmx5KFsnZGVsYXlUaW1lJ10pO1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuRmVlZGJhY2tEZWxheSwgVG9uZS5GZWVkYmFja0VmZmVjdCk7XG5cdCAgICAvKipcblx0XHQgKiAgVGhlIGRlZmF1bHQgdmFsdWVzLiBcblx0XHQgKiAgQGNvbnN0XG5cdFx0ICogIEBzdGF0aWNcblx0XHQgKiAgQHR5cGUge09iamVjdH1cblx0XHQgKi9cblx0ICAgIFRvbmUuRmVlZGJhY2tEZWxheS5kZWZhdWx0cyA9IHsgJ2RlbGF5VGltZSc6IDAuMjUgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBjbGVhbiB1cFxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5GZWVkYmFja0RlbGF5fSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkZlZWRiYWNrRGVsYXkucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5GZWVkYmFja0VmZmVjdC5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuX2RlbGF5Tm9kZS5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fZGVsYXlOb2RlID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl93cml0YWJsZShbJ2RlbGF5VGltZSddKTtcblx0ICAgICAgICB0aGlzLmRlbGF5VGltZSA9IG51bGw7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuRmVlZGJhY2tEZWxheTtcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgXG5cdCAgICAvKipcblx0XHQgKiAgYW4gYXJyYXkgb2YgY29tYiBmaWx0ZXIgZGVsYXkgdmFsdWVzIGZyb20gRnJlZXZlcmIgaW1wbGVtZW50YXRpb25cblx0XHQgKiAgQHN0YXRpY1xuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqICBAdHlwZSB7QXJyYXl9XG5cdFx0ICovXG5cdCAgICB2YXIgY29tYkZpbHRlclR1bmluZ3MgPSBbXG5cdCAgICAgICAgMTU1NyAvIDQ0MTAwLFxuXHQgICAgICAgIDE2MTcgLyA0NDEwMCxcblx0ICAgICAgICAxNDkxIC8gNDQxMDAsXG5cdCAgICAgICAgMTQyMiAvIDQ0MTAwLFxuXHQgICAgICAgIDEyNzcgLyA0NDEwMCxcblx0ICAgICAgICAxMzU2IC8gNDQxMDAsXG5cdCAgICAgICAgMTE4OCAvIDQ0MTAwLFxuXHQgICAgICAgIDExMTYgLyA0NDEwMFxuXHQgICAgXTtcblx0ICAgIC8qKlxuXHRcdCAqICBhbiBhcnJheSBvZiBhbGxwYXNzIGZpbHRlciBmcmVxdWVuY3kgdmFsdWVzIGZyb20gRnJlZXZlcmIgaW1wbGVtZW50YXRpb25cblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKiAgQHN0YXRpY1xuXHRcdCAqICBAdHlwZSB7QXJyYXl9XG5cdFx0ICovXG5cdCAgICB2YXIgYWxscGFzc0ZpbHRlckZyZXF1ZW5jaWVzID0gW1xuXHQgICAgICAgIDIyNSxcblx0ICAgICAgICA1NTYsXG5cdCAgICAgICAgNDQxLFxuXHQgICAgICAgIDM0MVxuXHQgICAgXTtcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgVG9uZS5GcmVldmVyYiBpcyBhIHJldmVyYiBiYXNlZCBvbiBbRnJlZXZlcmJdKGh0dHBzOi8vY2NybWEuc3RhbmZvcmQuZWR1L35qb3MvcGFzcC9GcmVldmVyYi5odG1sKS5cblx0XHQgKiAgICAgICAgIFJlYWQgbW9yZSBvbiByZXZlcmIgb24gW1NvdW5kIE9uIFNvdW5kXShodHRwczovL3dlYi5hcmNoaXZlLm9yZy93ZWIvMjAxNjA0MDQwODM5MDIvaHR0cDovL3d3dy5zb3VuZG9uc291bmQuY29tOjgwL3Nvcy9mZWIwMS9hcnRpY2xlcy9zeW50aHNlY3JldHMuYXNwKS5cblx0XHQgKlxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZS5FZmZlY3R9XG5cdFx0ICogIEBjb25zdHJ1Y3RvclxuXHRcdCAqICBAcGFyYW0ge05vcm1hbFJhbmdlfE9iamVjdH0gW3Jvb21TaXplXSBDb3JyZWxhdGVkIHRvIHRoZSBkZWNheSB0aW1lLlxuXHRcdCAqICBAcGFyYW0ge0ZyZXF1ZW5jeX0gW2RhbXBlbmluZ10gVGhlIGN1dG9mZiBmcmVxdWVuY3kgb2YgYSBsb3dwYXNzIGZpbHRlciBhcyBwYXJ0XG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZiB0aGUgcmV2ZXJiLlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIHZhciBmcmVldmVyYiA9IG5ldyBUb25lLkZyZWV2ZXJiKCkudG9NYXN0ZXIoKTtcblx0XHQgKiBmcmVldmVyYi5kYW1wZW5pbmcudmFsdWUgPSAxMDAwO1xuXHRcdCAqIC8vcm91dGluZyBzeW50aCB0aHJvdWdoIHRoZSByZXZlcmJcblx0XHQgKiB2YXIgc3ludGggPSBuZXcgVG9uZS5BTVN5bnRoKCkuY29ubmVjdChmcmVldmVyYik7XG5cdFx0ICovXG5cdCAgICBUb25lLkZyZWV2ZXJiID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBvcHRpb25zID0gVG9uZS5kZWZhdWx0cyhhcmd1bWVudHMsIFtcblx0ICAgICAgICAgICAgJ3Jvb21TaXplJyxcblx0ICAgICAgICAgICAgJ2RhbXBlbmluZydcblx0ICAgICAgICBdLCBUb25lLkZyZWV2ZXJiKTtcblx0ICAgICAgICBUb25lLlN0ZXJlb0VmZmVjdC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSByb29tU2l6ZSB2YWx1ZSBiZXR3ZWVuLiBBIGxhcmdlciByb29tU2l6ZVxuXHRcdFx0ICogIHdpbGwgcmVzdWx0IGluIGEgbG9uZ2VyIGRlY2F5LlxuXHRcdFx0ICogIEB0eXBlIHtOb3JtYWxSYW5nZX1cblx0XHRcdCAqICBAc2lnbmFsXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLnJvb21TaXplID0gbmV3IFRvbmUuU2lnbmFsKG9wdGlvbnMucm9vbVNpemUsIFRvbmUuVHlwZS5Ob3JtYWxSYW5nZSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGFtb3VudCBvZiBkYW1wZW5pbmcgb2YgdGhlIHJldmVyYmVyYW50IHNpZ25hbC5cblx0XHRcdCAqICBAdHlwZSB7RnJlcXVlbmN5fVxuXHRcdFx0ICogIEBzaWduYWxcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuZGFtcGVuaW5nID0gbmV3IFRvbmUuU2lnbmFsKG9wdGlvbnMuZGFtcGVuaW5nLCBUb25lLlR5cGUuRnJlcXVlbmN5KTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICB0aGUgY29tYiBmaWx0ZXJzXG5cdFx0XHQgKiAgQHR5cGUge0FycmF5fVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9jb21iRmlsdGVycyA9IFtdO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHRoZSBhbGxwYXNzIGZpbHRlcnMgb24gdGhlIGxlZnRcblx0XHRcdCAqICBAdHlwZSB7QXJyYXl9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2FsbHBhc3NGaWx0ZXJzTCA9IFtdO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHRoZSBhbGxwYXNzIGZpbHRlcnMgb24gdGhlIHJpZ2h0XG5cdFx0XHQgKiAgQHR5cGUge0FycmF5fVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9hbGxwYXNzRmlsdGVyc1IgPSBbXTtcblx0ICAgICAgICAvL21ha2UgdGhlIGFsbHBhc3MgZmlsdGVycyBvbiB0aGUgcmlnaHRcblx0ICAgICAgICBmb3IgKHZhciBsID0gMDsgbCA8IGFsbHBhc3NGaWx0ZXJGcmVxdWVuY2llcy5sZW5ndGg7IGwrKykge1xuXHQgICAgICAgICAgICB2YXIgYWxscGFzc0wgPSB0aGlzLmNvbnRleHQuY3JlYXRlQmlxdWFkRmlsdGVyKCk7XG5cdCAgICAgICAgICAgIGFsbHBhc3NMLnR5cGUgPSAnYWxscGFzcyc7XG5cdCAgICAgICAgICAgIGFsbHBhc3NMLmZyZXF1ZW5jeS52YWx1ZSA9IGFsbHBhc3NGaWx0ZXJGcmVxdWVuY2llc1tsXTtcblx0ICAgICAgICAgICAgdGhpcy5fYWxscGFzc0ZpbHRlcnNMLnB1c2goYWxscGFzc0wpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICAvL21ha2UgdGhlIGFsbHBhc3MgZmlsdGVycyBvbiB0aGUgbGVmdFxuXHQgICAgICAgIGZvciAodmFyIHIgPSAwOyByIDwgYWxscGFzc0ZpbHRlckZyZXF1ZW5jaWVzLmxlbmd0aDsgcisrKSB7XG5cdCAgICAgICAgICAgIHZhciBhbGxwYXNzUiA9IHRoaXMuY29udGV4dC5jcmVhdGVCaXF1YWRGaWx0ZXIoKTtcblx0ICAgICAgICAgICAgYWxscGFzc1IudHlwZSA9ICdhbGxwYXNzJztcblx0ICAgICAgICAgICAgYWxscGFzc1IuZnJlcXVlbmN5LnZhbHVlID0gYWxscGFzc0ZpbHRlckZyZXF1ZW5jaWVzW3JdO1xuXHQgICAgICAgICAgICB0aGlzLl9hbGxwYXNzRmlsdGVyc1IucHVzaChhbGxwYXNzUik7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8vbWFrZSB0aGUgY29tYiBmaWx0ZXJzXG5cdCAgICAgICAgZm9yICh2YXIgYyA9IDA7IGMgPCBjb21iRmlsdGVyVHVuaW5ncy5sZW5ndGg7IGMrKykge1xuXHQgICAgICAgICAgICB2YXIgbGZwZiA9IG5ldyBUb25lLkxvd3Bhc3NDb21iRmlsdGVyKGNvbWJGaWx0ZXJUdW5pbmdzW2NdKTtcblx0ICAgICAgICAgICAgaWYgKGMgPCBjb21iRmlsdGVyVHVuaW5ncy5sZW5ndGggLyAyKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLmVmZmVjdFNlbmRMLmNoYWluKGxmcGYsIHRoaXMuX2FsbHBhc3NGaWx0ZXJzTFswXSk7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLmVmZmVjdFNlbmRSLmNoYWluKGxmcGYsIHRoaXMuX2FsbHBhc3NGaWx0ZXJzUlswXSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdGhpcy5yb29tU2l6ZS5jb25uZWN0KGxmcGYucmVzb25hbmNlKTtcblx0ICAgICAgICAgICAgdGhpcy5kYW1wZW5pbmcuY29ubmVjdChsZnBmLmRhbXBlbmluZyk7XG5cdCAgICAgICAgICAgIHRoaXMuX2NvbWJGaWx0ZXJzLnB1c2gobGZwZik7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8vY2hhaW4gdGhlIGFsbHBhc3MgZmlsdGVycyB0b2dldGVoclxuXHQgICAgICAgIFRvbmUuY29ubmVjdFNlcmllcy5hcHBseShUb25lLCB0aGlzLl9hbGxwYXNzRmlsdGVyc0wpO1xuXHQgICAgICAgIFRvbmUuY29ubmVjdFNlcmllcy5hcHBseShUb25lLCB0aGlzLl9hbGxwYXNzRmlsdGVyc1IpO1xuXHQgICAgICAgIHRoaXMuX2FsbHBhc3NGaWx0ZXJzTFt0aGlzLl9hbGxwYXNzRmlsdGVyc0wubGVuZ3RoIC0gMV0uY29ubmVjdCh0aGlzLmVmZmVjdFJldHVybkwpO1xuXHQgICAgICAgIHRoaXMuX2FsbHBhc3NGaWx0ZXJzUlt0aGlzLl9hbGxwYXNzRmlsdGVyc1IubGVuZ3RoIC0gMV0uY29ubmVjdCh0aGlzLmVmZmVjdFJldHVyblIpO1xuXHQgICAgICAgIHRoaXMuX3JlYWRPbmx5KFtcblx0ICAgICAgICAgICAgJ3Jvb21TaXplJyxcblx0ICAgICAgICAgICAgJ2RhbXBlbmluZydcblx0ICAgICAgICBdKTtcblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLkZyZWV2ZXJiLCBUb25lLlN0ZXJlb0VmZmVjdCk7XG5cdCAgICAvKipcblx0XHQgKiAgQHN0YXRpY1xuXHRcdCAqICBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqL1xuXHQgICAgVG9uZS5GcmVldmVyYi5kZWZhdWx0cyA9IHtcblx0ICAgICAgICAncm9vbVNpemUnOiAwLjcsXG5cdCAgICAgICAgJ2RhbXBlbmluZyc6IDMwMDBcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgQ2xlYW4gdXAuXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLkZyZWV2ZXJifSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkZyZWV2ZXJiLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuU3RlcmVvRWZmZWN0LnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgZm9yICh2YXIgYWwgPSAwOyBhbCA8IHRoaXMuX2FsbHBhc3NGaWx0ZXJzTC5sZW5ndGg7IGFsKyspIHtcblx0ICAgICAgICAgICAgdGhpcy5fYWxscGFzc0ZpbHRlcnNMW2FsXS5kaXNjb25uZWN0KCk7XG5cdCAgICAgICAgICAgIHRoaXMuX2FsbHBhc3NGaWx0ZXJzTFthbF0gPSBudWxsO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB0aGlzLl9hbGxwYXNzRmlsdGVyc0wgPSBudWxsO1xuXHQgICAgICAgIGZvciAodmFyIGFyID0gMDsgYXIgPCB0aGlzLl9hbGxwYXNzRmlsdGVyc1IubGVuZ3RoOyBhcisrKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2FsbHBhc3NGaWx0ZXJzUlthcl0uZGlzY29ubmVjdCgpO1xuXHQgICAgICAgICAgICB0aGlzLl9hbGxwYXNzRmlsdGVyc1JbYXJdID0gbnVsbDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdGhpcy5fYWxscGFzc0ZpbHRlcnNSID0gbnVsbDtcblx0ICAgICAgICBmb3IgKHZhciBjZiA9IDA7IGNmIDwgdGhpcy5fY29tYkZpbHRlcnMubGVuZ3RoOyBjZisrKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2NvbWJGaWx0ZXJzW2NmXS5kaXNwb3NlKCk7XG5cdCAgICAgICAgICAgIHRoaXMuX2NvbWJGaWx0ZXJzW2NmXSA9IG51bGw7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHRoaXMuX2NvbWJGaWx0ZXJzID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl93cml0YWJsZShbXG5cdCAgICAgICAgICAgICdyb29tU2l6ZScsXG5cdCAgICAgICAgICAgICdkYW1wZW5pbmcnXG5cdCAgICAgICAgXSk7XG5cdCAgICAgICAgdGhpcy5yb29tU2l6ZS5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5yb29tU2l6ZSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5kYW1wZW5pbmcuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuZGFtcGVuaW5nID0gbnVsbDtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVG9uZS5GcmVldmVyYjtcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgXG5cdCAgICAvKipcblx0XHQgKiAgYW4gYXJyYXkgb2YgdGhlIGNvbWIgZmlsdGVyIGRlbGF5IHRpbWUgdmFsdWVzXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICogIEBzdGF0aWNcblx0XHQgKiAgQHR5cGUge0FycmF5fVxuXHRcdCAqL1xuXHQgICAgdmFyIGNvbWJGaWx0ZXJEZWxheVRpbWVzID0gW1xuXHQgICAgICAgIDE2ODcgLyAyNTAwMCxcblx0ICAgICAgICAxNjAxIC8gMjUwMDAsXG5cdCAgICAgICAgMjA1MyAvIDI1MDAwLFxuXHQgICAgICAgIDIyNTEgLyAyNTAwMFxuXHQgICAgXTtcblx0ICAgIC8qKlxuXHRcdCAqICB0aGUgcmVzb25hbmNlcyBvZiBlYWNoIG9mIHRoZSBjb21iIGZpbHRlcnNcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKiAgQHN0YXRpY1xuXHRcdCAqICBAdHlwZSB7QXJyYXl9XG5cdFx0ICovXG5cdCAgICB2YXIgY29tYkZpbHRlclJlc29uYW5jZXMgPSBbXG5cdCAgICAgICAgMC43NzMsXG5cdCAgICAgICAgMC44MDIsXG5cdCAgICAgICAgMC43NTMsXG5cdCAgICAgICAgMC43MzNcblx0ICAgIF07XG5cdCAgICAvKipcblx0XHQgKiAgdGhlIGFsbHBhc3MgZmlsdGVyIGZyZXF1ZW5jaWVzXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICogIEBzdGF0aWNcblx0XHQgKiAgQHR5cGUge0FycmF5fVxuXHRcdCAqL1xuXHQgICAgdmFyIGFsbHBhc3NGaWx0ZXJGcmVxcyA9IFtcblx0ICAgICAgICAzNDcsXG5cdCAgICAgICAgMTEzLFxuXHQgICAgICAgIDM3XG5cdCAgICBdO1xuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyBUb25lLkpDUmV2ZXJiIGlzIGEgc2ltcGxlIFtTY2hyb2VkZXIgUmV2ZXJiZXJhdG9yXShodHRwczovL2Njcm1hLnN0YW5mb3JkLmVkdS9+am9zL3Bhc3AvU2Nocm9lZGVyX1JldmVyYmVyYXRvcnMuaHRtbClcblx0XHQgKiAgICAgICAgIHR1bmVkIGJ5IEpvaG4gQ2hvd25pbmcgaW4gMTk3MC5cblx0XHQgKiAgICAgICAgIEl0IGlzIG1hZGUgdXAgb2YgdGhyZWUgYWxscGFzcyBmaWx0ZXJzIGFuZCBmb3VyIFRvbmUuRmVlZGJhY2tDb21iRmlsdGVyLiBcblx0XHQgKiAgICAgICAgIFxuXHRcdCAqXG5cdFx0ICogIEBleHRlbmRzIHtUb25lLkVmZmVjdH1cblx0XHQgKiAgQGNvbnN0cnVjdG9yXG5cdFx0ICogIEBwYXJhbSB7Tm9ybWFsUmFuZ2V8T2JqZWN0fSBbcm9vbVNpemVdIENvb3JlbGF0ZXMgdG8gdGhlIGRlY2F5IHRpbWUuXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogdmFyIHJldmVyYiA9IG5ldyBUb25lLkpDUmV2ZXJiKDAuNCkuY29ubmVjdChUb25lLk1hc3Rlcik7XG5cdFx0ICogdmFyIGRlbGF5ID0gbmV3IFRvbmUuRmVlZGJhY2tEZWxheSgwLjUpOyBcblx0XHQgKiAvL2Nvbm5lY3RpbmcgdGhlIHN5bnRoIHRvIHJldmVyYiB0aHJvdWdoIGRlbGF5XG5cdFx0ICogdmFyIHN5bnRoID0gbmV3IFRvbmUuRHVvU3ludGgoKS5jaGFpbihkZWxheSwgcmV2ZXJiKTtcblx0XHQgKiBzeW50aC50cmlnZ2VyQXR0YWNrUmVsZWFzZShcIkE0XCIsXCI4blwiKTtcblx0XHQgKi9cblx0ICAgIFRvbmUuSkNSZXZlcmIgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIG9wdGlvbnMgPSBUb25lLmRlZmF1bHRzKGFyZ3VtZW50cywgWydyb29tU2l6ZSddLCBUb25lLkpDUmV2ZXJiKTtcblx0ICAgICAgICBUb25lLlN0ZXJlb0VmZmVjdC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHJvb20gc2l6ZSBjb250cm9sIHZhbHVlcyBiZXR3ZWVuIFswLDFdXG5cdFx0XHQgKiAgQHR5cGUge05vcm1hbFJhbmdlfVxuXHRcdFx0ICogIEBzaWduYWxcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMucm9vbVNpemUgPSBuZXcgVG9uZS5TaWduYWwob3B0aW9ucy5yb29tU2l6ZSwgVG9uZS5UeXBlLk5vcm1hbFJhbmdlKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBzY2FsZSB0aGUgcm9vbSBzaXplXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuU2NhbGV9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX3NjYWxlUm9vbVNpemUgPSBuZXcgVG9uZS5TY2FsZSgtMC43MzMsIDAuMTk3KTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBhIHNlcmllcyBvZiBhbGxwYXNzIGZpbHRlcnNcblx0XHRcdCAqICBAdHlwZSB7QXJyYXl9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2FsbHBhc3NGaWx0ZXJzID0gW107XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgcGFyYWxsZWwgZmVlZGJhY2sgY29tYiBmaWx0ZXJzXG5cdFx0XHQgKiAgQHR5cGUge0FycmF5fVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9mZWVkYmFja0NvbWJGaWx0ZXJzID0gW107XG5cdCAgICAgICAgLy9tYWtlIHRoZSBhbGxwYXNzIGZpbHRlcnNcblx0ICAgICAgICBmb3IgKHZhciBhZiA9IDA7IGFmIDwgYWxscGFzc0ZpbHRlckZyZXFzLmxlbmd0aDsgYWYrKykge1xuXHQgICAgICAgICAgICB2YXIgYWxscGFzcyA9IHRoaXMuY29udGV4dC5jcmVhdGVCaXF1YWRGaWx0ZXIoKTtcblx0ICAgICAgICAgICAgYWxscGFzcy50eXBlID0gJ2FsbHBhc3MnO1xuXHQgICAgICAgICAgICBhbGxwYXNzLmZyZXF1ZW5jeS52YWx1ZSA9IGFsbHBhc3NGaWx0ZXJGcmVxc1thZl07XG5cdCAgICAgICAgICAgIHRoaXMuX2FsbHBhc3NGaWx0ZXJzLnB1c2goYWxscGFzcyk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8vYW5kIHRoZSBjb21iIGZpbHRlcnNcblx0ICAgICAgICBmb3IgKHZhciBjZiA9IDA7IGNmIDwgY29tYkZpbHRlckRlbGF5VGltZXMubGVuZ3RoOyBjZisrKSB7XG5cdCAgICAgICAgICAgIHZhciBmYmNmID0gbmV3IFRvbmUuRmVlZGJhY2tDb21iRmlsdGVyKGNvbWJGaWx0ZXJEZWxheVRpbWVzW2NmXSwgMC4xKTtcblx0ICAgICAgICAgICAgdGhpcy5fc2NhbGVSb29tU2l6ZS5jb25uZWN0KGZiY2YucmVzb25hbmNlKTtcblx0ICAgICAgICAgICAgZmJjZi5yZXNvbmFuY2UudmFsdWUgPSBjb21iRmlsdGVyUmVzb25hbmNlc1tjZl07XG5cdCAgICAgICAgICAgIHRoaXMuX2FsbHBhc3NGaWx0ZXJzW3RoaXMuX2FsbHBhc3NGaWx0ZXJzLmxlbmd0aCAtIDFdLmNvbm5lY3QoZmJjZik7XG5cdCAgICAgICAgICAgIGlmIChjZiA8IGNvbWJGaWx0ZXJEZWxheVRpbWVzLmxlbmd0aCAvIDIpIHtcblx0ICAgICAgICAgICAgICAgIGZiY2YuY29ubmVjdCh0aGlzLmVmZmVjdFJldHVybkwpO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgZmJjZi5jb25uZWN0KHRoaXMuZWZmZWN0UmV0dXJuUik7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdGhpcy5fZmVlZGJhY2tDb21iRmlsdGVycy5wdXNoKGZiY2YpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICAvL2NoYWluIHRoZSBhbGxwYXNzIGZpbHRlcnMgdG9nZXRoZXJcblx0ICAgICAgICB0aGlzLnJvb21TaXplLmNvbm5lY3QodGhpcy5fc2NhbGVSb29tU2l6ZSk7XG5cdCAgICAgICAgVG9uZS5jb25uZWN0U2VyaWVzLmFwcGx5KFRvbmUsIHRoaXMuX2FsbHBhc3NGaWx0ZXJzKTtcblx0ICAgICAgICB0aGlzLmVmZmVjdFNlbmRMLmNvbm5lY3QodGhpcy5fYWxscGFzc0ZpbHRlcnNbMF0pO1xuXHQgICAgICAgIHRoaXMuZWZmZWN0U2VuZFIuY29ubmVjdCh0aGlzLl9hbGxwYXNzRmlsdGVyc1swXSk7XG5cdCAgICAgICAgdGhpcy5fcmVhZE9ubHkoWydyb29tU2l6ZSddKTtcblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLkpDUmV2ZXJiLCBUb25lLlN0ZXJlb0VmZmVjdCk7XG5cdCAgICAvKipcblx0XHQgKiAgdGhlIGRlZmF1bHQgdmFsdWVzXG5cdFx0ICogIEBzdGF0aWNcblx0XHQgKiAgQGNvbnN0XG5cdFx0ICogIEB0eXBlIHtPYmplY3R9XG5cdFx0ICovXG5cdCAgICBUb25lLkpDUmV2ZXJiLmRlZmF1bHRzID0geyAncm9vbVNpemUnOiAwLjUgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBDbGVhbiB1cC4gXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLkpDUmV2ZXJifSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkpDUmV2ZXJiLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuU3RlcmVvRWZmZWN0LnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgZm9yICh2YXIgYXBmID0gMDsgYXBmIDwgdGhpcy5fYWxscGFzc0ZpbHRlcnMubGVuZ3RoOyBhcGYrKykge1xuXHQgICAgICAgICAgICB0aGlzLl9hbGxwYXNzRmlsdGVyc1thcGZdLmRpc2Nvbm5lY3QoKTtcblx0ICAgICAgICAgICAgdGhpcy5fYWxscGFzc0ZpbHRlcnNbYXBmXSA9IG51bGw7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHRoaXMuX2FsbHBhc3NGaWx0ZXJzID0gbnVsbDtcblx0ICAgICAgICBmb3IgKHZhciBmYmNmID0gMDsgZmJjZiA8IHRoaXMuX2ZlZWRiYWNrQ29tYkZpbHRlcnMubGVuZ3RoOyBmYmNmKyspIHtcblx0ICAgICAgICAgICAgdGhpcy5fZmVlZGJhY2tDb21iRmlsdGVyc1tmYmNmXS5kaXNwb3NlKCk7XG5cdCAgICAgICAgICAgIHRoaXMuX2ZlZWRiYWNrQ29tYkZpbHRlcnNbZmJjZl0gPSBudWxsO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB0aGlzLl9mZWVkYmFja0NvbWJGaWx0ZXJzID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl93cml0YWJsZShbJ3Jvb21TaXplJ10pO1xuXHQgICAgICAgIHRoaXMucm9vbVNpemUuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMucm9vbVNpemUgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX3NjYWxlUm9vbVNpemUuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX3NjYWxlUm9vbVNpemUgPSBudWxsO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLkpDUmV2ZXJiO1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgTWlkL1NpZGUgcHJvY2Vzc2luZyBzZXBhcmF0ZXMgdGhlIHRoZSAnbWlkJyBzaWduYWwgXG5cdFx0ICogICAgICAgICAod2hpY2ggY29tZXMgb3V0IG9mIGJvdGggdGhlIGxlZnQgYW5kIHRoZSByaWdodCBjaGFubmVsKSBcblx0XHQgKiAgICAgICAgIGFuZCB0aGUgJ3NpZGUnICh3aGljaCBvbmx5IGNvbWVzIG91dCBvZiB0aGUgdGhlIHNpZGUgY2hhbm5lbHMpIFxuXHRcdCAqICAgICAgICAgYW5kIGVmZmVjdHMgdGhlbSBzZXBhcmF0ZWx5IGJlZm9yZSBiZWluZyByZWNvbWJpbmVkLlxuXHRcdCAqICAgICAgICAgQXBwbGllcyBhIE1pZC9TaWRlIHNlcGVyYXRpb24gYW5kIHJlY29tYmluYXRpb24uXG5cdFx0ICogICAgICAgICBBbGdvcml0aG0gZm91bmQgaW4gW2t2cmF1ZGlvIGZvcnVtc10oaHR0cDovL3d3dy5rdnJhdWRpby5jb20vZm9ydW0vdmlld3RvcGljLnBocD90PTIxMjU4NykuXG5cdFx0ICogICAgICAgICA8YnI+PGJyPlxuXHRcdCAqICAgICAgICAgVGhpcyBpcyBhIGJhc2UtY2xhc3MgZm9yIE1pZC9TaWRlIEVmZmVjdHMuIFxuXHRcdCAqXG5cdFx0ICogIEBleHRlbmRzIHtUb25lLkVmZmVjdH1cblx0XHQgKiAgQGNvbnN0cnVjdG9yXG5cdFx0ICovXG5cdCAgICBUb25lLk1pZFNpZGVFZmZlY3QgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5FZmZlY3QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgbWlkL3NpZGUgc3BsaXRcblx0XHRcdCAqICBAdHlwZSAge1RvbmUuTWlkU2lkZVNwbGl0fVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9taWRTaWRlU3BsaXQgPSBuZXcgVG9uZS5NaWRTaWRlU3BsaXQoKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgbWlkL3NpZGUgbWVyZ2Vcblx0XHRcdCAqICBAdHlwZSAge1RvbmUuTWlkU2lkZU1lcmdlfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9taWRTaWRlTWVyZ2UgPSBuZXcgVG9uZS5NaWRTaWRlTWVyZ2UoKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgbWlkIHNlbmQuIENvbm5lY3QgdG8gbWlkIHByb2Nlc3Npbmdcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5FeHByfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLm1pZFNlbmQgPSB0aGlzLl9taWRTaWRlU3BsaXQubWlkO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBzaWRlIHNlbmQuIENvbm5lY3QgdG8gc2lkZSBwcm9jZXNzaW5nXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuRXhwcn1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5zaWRlU2VuZCA9IHRoaXMuX21pZFNpZGVTcGxpdC5zaWRlO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBtaWQgcmV0dXJuIGNvbm5lY3Rpb25cblx0XHRcdCAqICBAdHlwZSB7R2Fpbk5vZGV9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMubWlkUmV0dXJuID0gdGhpcy5fbWlkU2lkZU1lcmdlLm1pZDtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgc2lkZSByZXR1cm4gY29ubmVjdGlvblxuXHRcdFx0ICogIEB0eXBlIHtHYWluTm9kZX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5zaWRlUmV0dXJuID0gdGhpcy5fbWlkU2lkZU1lcmdlLnNpZGU7XG5cdCAgICAgICAgLy90aGUgY29ubmVjdGlvbnNcblx0ICAgICAgICB0aGlzLmVmZmVjdFNlbmQuY29ubmVjdCh0aGlzLl9taWRTaWRlU3BsaXQpO1xuXHQgICAgICAgIHRoaXMuX21pZFNpZGVNZXJnZS5jb25uZWN0KHRoaXMuZWZmZWN0UmV0dXJuKTtcblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLk1pZFNpZGVFZmZlY3QsIFRvbmUuRWZmZWN0KTtcblx0ICAgIC8qKlxuXHRcdCAqICBDbGVhbiB1cC4gXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLk1pZFNpZGVFZmZlY3R9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuTWlkU2lkZUVmZmVjdC5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLkVmZmVjdC5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuX21pZFNpZGVTcGxpdC5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fbWlkU2lkZVNwbGl0ID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9taWRTaWRlTWVyZ2UuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX21pZFNpZGVNZXJnZSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5taWRTZW5kID0gbnVsbDtcblx0ICAgICAgICB0aGlzLnNpZGVTZW5kID0gbnVsbDtcblx0ICAgICAgICB0aGlzLm1pZFJldHVybiA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5zaWRlUmV0dXJuID0gbnVsbDtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVG9uZS5NaWRTaWRlRWZmZWN0O1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgVG9uZS5QaGFzZXIgaXMgYSBwaGFzZXIgZWZmZWN0LiBQaGFzZXJzIHdvcmsgYnkgY2hhbmdpbmcgdGhlIHBoYXNlXG5cdFx0ICogICAgICAgICBvZiBkaWZmZXJlbnQgZnJlcXVlbmN5IGNvbXBvbmVudHMgb2YgYW4gaW5jb21pbmcgc2lnbmFsLiBSZWFkIG1vcmUgb24gXG5cdFx0ICogICAgICAgICBbV2lraXBlZGlhXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9QaGFzZXJfKGVmZmVjdCkpLiBcblx0XHQgKiAgICAgICAgIEluc3BpcmF0aW9uIGZvciB0aGlzIHBoYXNlciBjb21lcyBmcm9tIFtUdW5hLmpzXShodHRwczovL2dpdGh1Yi5jb20vRGluYWhtb2UvdHVuYS8pLlxuXHRcdCAqXG5cdFx0ICpcdEBleHRlbmRzIHtUb25lLlN0ZXJlb0VmZmVjdH1cblx0XHQgKlx0QGNvbnN0cnVjdG9yXG5cdFx0ICpcdEBwYXJhbSB7RnJlcXVlbmN5fE9iamVjdH0gW2ZyZXF1ZW5jeV0gVGhlIHNwZWVkIG9mIHRoZSBwaGFzaW5nLiBcblx0XHQgKlx0QHBhcmFtIHtudW1iZXJ9IFtvY3RhdmVzXSBUaGUgb2N0YXZlcyBvZiB0aGUgZWZmZWN0LiBcblx0XHQgKlx0QHBhcmFtIHtGcmVxdWVuY3l9IFtiYXNlRnJlcXVlbmN5XSBUaGUgYmFzZSBmcmVxdWVuY3kgb2YgdGhlIGZpbHRlcnMuIFxuXHRcdCAqXHRAZXhhbXBsZVxuXHRcdCAqIHZhciBwaGFzZXIgPSBuZXcgVG9uZS5QaGFzZXIoe1xuXHRcdCAqIFx0XCJmcmVxdWVuY3lcIiA6IDE1LCBcblx0XHQgKiBcdFwib2N0YXZlc1wiIDogNSwgXG5cdFx0ICogXHRcImJhc2VGcmVxdWVuY3lcIiA6IDEwMDBcblx0XHQgKiB9KS50b01hc3RlcigpO1xuXHRcdCAqIHZhciBzeW50aCA9IG5ldyBUb25lLkZNU3ludGgoKS5jb25uZWN0KHBoYXNlcik7XG5cdFx0ICogc3ludGgudHJpZ2dlckF0dGFja1JlbGVhc2UoXCJFM1wiLCBcIjJuXCIpO1xuXHRcdCAqL1xuXHQgICAgVG9uZS5QaGFzZXIgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgLy9zZXQgdGhlIGRlZmF1bHRzXG5cdCAgICAgICAgdmFyIG9wdGlvbnMgPSBUb25lLmRlZmF1bHRzKGFyZ3VtZW50cywgW1xuXHQgICAgICAgICAgICAnZnJlcXVlbmN5Jyxcblx0ICAgICAgICAgICAgJ29jdGF2ZXMnLFxuXHQgICAgICAgICAgICAnYmFzZUZyZXF1ZW5jeSdcblx0ICAgICAgICBdLCBUb25lLlBoYXNlcik7XG5cdCAgICAgICAgVG9uZS5TdGVyZW9FZmZlY3QuY2FsbCh0aGlzLCBvcHRpb25zKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICB0aGUgbGZvIHdoaWNoIGNvbnRyb2xzIHRoZSBmcmVxdWVuY3kgb24gdGhlIGxlZnQgc2lkZVxuXHRcdFx0ICogIEB0eXBlIHtUb25lLkxGT31cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fbGZvTCA9IG5ldyBUb25lLkxGTyhvcHRpb25zLmZyZXF1ZW5jeSwgMCwgMSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgdGhlIGxmbyB3aGljaCBjb250cm9scyB0aGUgZnJlcXVlbmN5IG9uIHRoZSByaWdodCBzaWRlXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuTEZPfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9sZm9SID0gbmV3IFRvbmUuTEZPKG9wdGlvbnMuZnJlcXVlbmN5LCAwLCAxKTtcblx0ICAgICAgICB0aGlzLl9sZm9SLnBoYXNlID0gMTgwO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHRoZSBiYXNlIG1vZHVsYXRpb24gZnJlcXVlbmN5XG5cdFx0XHQgKiAgQHR5cGUge251bWJlcn1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fYmFzZUZyZXF1ZW5jeSA9IG9wdGlvbnMuYmFzZUZyZXF1ZW5jeTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICB0aGUgb2N0YXZlcyBvZiB0aGUgcGhhc2luZ1xuXHRcdFx0ICogIEB0eXBlIHtudW1iZXJ9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX29jdGF2ZXMgPSBvcHRpb25zLm9jdGF2ZXM7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIHF1YWxpdHkgZmFjdG9yIG9mIHRoZSBmaWx0ZXJzXG5cdFx0XHQgKiAgQHR5cGUge1Bvc2l0aXZlfVxuXHRcdFx0ICogIEBzaWduYWxcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuUSA9IG5ldyBUb25lLlNpZ25hbChvcHRpb25zLlEsIFRvbmUuVHlwZS5Qb3NpdGl2ZSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgdGhlIGFycmF5IG9mIGZpbHRlcnMgZm9yIHRoZSBsZWZ0IHNpZGVcblx0XHRcdCAqICBAdHlwZSB7QXJyYXl9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2ZpbHRlcnNMID0gdGhpcy5fbWFrZUZpbHRlcnMob3B0aW9ucy5zdGFnZXMsIHRoaXMuX2xmb0wsIHRoaXMuUSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgdGhlIGFycmF5IG9mIGZpbHRlcnMgZm9yIHRoZSBsZWZ0IHNpZGVcblx0XHRcdCAqICBAdHlwZSB7QXJyYXl9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2ZpbHRlcnNSID0gdGhpcy5fbWFrZUZpbHRlcnMob3B0aW9ucy5zdGFnZXMsIHRoaXMuX2xmb1IsIHRoaXMuUSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiB0aGUgZnJlcXVlbmN5IG9mIHRoZSBlZmZlY3Rcblx0XHRcdCAqIEB0eXBlIHtUb25lLlNpZ25hbH1cblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuZnJlcXVlbmN5ID0gdGhpcy5fbGZvTC5mcmVxdWVuY3k7XG5cdCAgICAgICAgdGhpcy5mcmVxdWVuY3kudmFsdWUgPSBvcHRpb25zLmZyZXF1ZW5jeTtcblx0ICAgICAgICAvL2Nvbm5lY3QgdGhlbSB1cFxuXHQgICAgICAgIHRoaXMuZWZmZWN0U2VuZEwuY29ubmVjdCh0aGlzLl9maWx0ZXJzTFswXSk7XG5cdCAgICAgICAgdGhpcy5lZmZlY3RTZW5kUi5jb25uZWN0KHRoaXMuX2ZpbHRlcnNSWzBdKTtcblx0ICAgICAgICB0aGlzLl9maWx0ZXJzTFtvcHRpb25zLnN0YWdlcyAtIDFdLmNvbm5lY3QodGhpcy5lZmZlY3RSZXR1cm5MKTtcblx0ICAgICAgICB0aGlzLl9maWx0ZXJzUltvcHRpb25zLnN0YWdlcyAtIDFdLmNvbm5lY3QodGhpcy5lZmZlY3RSZXR1cm5SKTtcblx0ICAgICAgICAvL2NvbnRyb2wgdGhlIGZyZXF1ZW5jeSB3aXRoIG9uZSBMRk9cblx0ICAgICAgICB0aGlzLl9sZm9MLmZyZXF1ZW5jeS5jb25uZWN0KHRoaXMuX2xmb1IuZnJlcXVlbmN5KTtcblx0ICAgICAgICAvL3NldCB0aGUgb3B0aW9uc1xuXHQgICAgICAgIHRoaXMuYmFzZUZyZXF1ZW5jeSA9IG9wdGlvbnMuYmFzZUZyZXF1ZW5jeTtcblx0ICAgICAgICB0aGlzLm9jdGF2ZXMgPSBvcHRpb25zLm9jdGF2ZXM7XG5cdCAgICAgICAgLy9zdGFydCB0aGUgbGZvXG5cdCAgICAgICAgdGhpcy5fbGZvTC5zdGFydCgpO1xuXHQgICAgICAgIHRoaXMuX2xmb1Iuc3RhcnQoKTtcblx0ICAgICAgICB0aGlzLl9yZWFkT25seShbXG5cdCAgICAgICAgICAgICdmcmVxdWVuY3knLFxuXHQgICAgICAgICAgICAnUSdcblx0ICAgICAgICBdKTtcblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLlBoYXNlciwgVG9uZS5TdGVyZW9FZmZlY3QpO1xuXHQgICAgLyoqXG5cdFx0ICogIGRlZmF1bHRzXG5cdFx0ICogIEBzdGF0aWNcblx0XHQgKiAgQHR5cGUge29iamVjdH1cblx0XHQgKi9cblx0ICAgIFRvbmUuUGhhc2VyLmRlZmF1bHRzID0ge1xuXHQgICAgICAgICdmcmVxdWVuY3knOiAwLjUsXG5cdCAgICAgICAgJ29jdGF2ZXMnOiAzLFxuXHQgICAgICAgICdzdGFnZXMnOiAxMCxcblx0ICAgICAgICAnUSc6IDEwLFxuXHQgICAgICAgICdiYXNlRnJlcXVlbmN5JzogMzUwXG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIEBwYXJhbSB7bnVtYmVyfSBzdGFnZXNcblx0XHQgKiAgQHJldHVybnMge0FycmF5fSB0aGUgbnVtYmVyIG9mIGZpbHRlcnMgYWxsIGNvbm5lY3RlZCB0b2dldGhlclxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5QaGFzZXIucHJvdG90eXBlLl9tYWtlRmlsdGVycyA9IGZ1bmN0aW9uIChzdGFnZXMsIGNvbm5lY3RUb0ZyZXEsIFEpIHtcblx0ICAgICAgICB2YXIgZmlsdGVycyA9IG5ldyBBcnJheShzdGFnZXMpO1xuXHQgICAgICAgIC8vbWFrZSBhbGwgdGhlIGZpbHRlcnNcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0YWdlczsgaSsrKSB7XG5cdCAgICAgICAgICAgIHZhciBmaWx0ZXIgPSB0aGlzLmNvbnRleHQuY3JlYXRlQmlxdWFkRmlsdGVyKCk7XG5cdCAgICAgICAgICAgIGZpbHRlci50eXBlID0gJ2FsbHBhc3MnO1xuXHQgICAgICAgICAgICBRLmNvbm5lY3QoZmlsdGVyLlEpO1xuXHQgICAgICAgICAgICBjb25uZWN0VG9GcmVxLmNvbm5lY3QoZmlsdGVyLmZyZXF1ZW5jeSk7XG5cdCAgICAgICAgICAgIGZpbHRlcnNbaV0gPSBmaWx0ZXI7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIFRvbmUuY29ubmVjdFNlcmllcy5hcHBseShUb25lLCBmaWx0ZXJzKTtcblx0ICAgICAgICByZXR1cm4gZmlsdGVycztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiBUaGUgbnVtYmVyIG9mIG9jdGF2ZXMgdGhlIHBoYXNlIGdvZXMgYWJvdmVcblx0XHQgKiB0aGUgYmFzZUZyZXF1ZW5jeVxuXHRcdCAqIEBtZW1iZXJPZiBUb25lLlBoYXNlciNcblx0XHQgKiBAdHlwZSB7UG9zaXRpdmV9XG5cdFx0ICogQG5hbWUgb2N0YXZlc1xuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuUGhhc2VyLnByb3RvdHlwZSwgJ29jdGF2ZXMnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9vY3RhdmVzO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAob2N0YXZlcykge1xuXHQgICAgICAgICAgICB0aGlzLl9vY3RhdmVzID0gb2N0YXZlcztcblx0ICAgICAgICAgICAgdmFyIG1heCA9IHRoaXMuX2Jhc2VGcmVxdWVuY3kgKiBNYXRoLnBvdygyLCBvY3RhdmVzKTtcblx0ICAgICAgICAgICAgdGhpcy5fbGZvTC5tYXggPSBtYXg7XG5cdCAgICAgICAgICAgIHRoaXMuX2xmb1IubWF4ID0gbWF4O1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogVGhlIHRoZSBiYXNlIGZyZXF1ZW5jeSBvZiB0aGUgZmlsdGVycy4gXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuUGhhc2VyI1xuXHRcdCAqIEB0eXBlIHtudW1iZXJ9XG5cdFx0ICogQG5hbWUgYmFzZUZyZXF1ZW5jeVxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuUGhhc2VyLnByb3RvdHlwZSwgJ2Jhc2VGcmVxdWVuY3knLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9iYXNlRnJlcXVlbmN5O1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAoZnJlcSkge1xuXHQgICAgICAgICAgICB0aGlzLl9iYXNlRnJlcXVlbmN5ID0gZnJlcTtcblx0ICAgICAgICAgICAgdGhpcy5fbGZvTC5taW4gPSBmcmVxO1xuXHQgICAgICAgICAgICB0aGlzLl9sZm9SLm1pbiA9IGZyZXE7XG5cdCAgICAgICAgICAgIHRoaXMub2N0YXZlcyA9IHRoaXMuX29jdGF2ZXM7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgY2xlYW4gdXBcblx0XHQgKiAgQHJldHVybnMge1RvbmUuUGhhc2VyfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLlBoYXNlci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLlN0ZXJlb0VmZmVjdC5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuX3dyaXRhYmxlKFtcblx0ICAgICAgICAgICAgJ2ZyZXF1ZW5jeScsXG5cdCAgICAgICAgICAgICdRJ1xuXHQgICAgICAgIF0pO1xuXHQgICAgICAgIHRoaXMuUS5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5RID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9sZm9MLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9sZm9MID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9sZm9SLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9sZm9SID0gbnVsbDtcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2ZpbHRlcnNMLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2ZpbHRlcnNMW2ldLmRpc2Nvbm5lY3QoKTtcblx0ICAgICAgICAgICAgdGhpcy5fZmlsdGVyc0xbaV0gPSBudWxsO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB0aGlzLl9maWx0ZXJzTCA9IG51bGw7XG5cdCAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLl9maWx0ZXJzUi5sZW5ndGg7IGorKykge1xuXHQgICAgICAgICAgICB0aGlzLl9maWx0ZXJzUltqXS5kaXNjb25uZWN0KCk7XG5cdCAgICAgICAgICAgIHRoaXMuX2ZpbHRlcnNSW2pdID0gbnVsbDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdGhpcy5fZmlsdGVyc1IgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuZnJlcXVlbmN5ID0gbnVsbDtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVG9uZS5QaGFzZXI7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyAgVG9uZS5QaW5nUG9uZ0RlbGF5IGlzIGEgZmVlZGJhY2sgZGVsYXkgZWZmZWN0IHdoZXJlIHRoZSBlY2hvIGlzIGhlYXJkXG5cdFx0ICogICAgICAgICAgZmlyc3QgaW4gb25lIGNoYW5uZWwgYW5kIG5leHQgaW4gdGhlIG9wcG9zaXRlIGNoYW5uZWwuIEluIGEgc3RlcmVvXG5cdFx0ICogICAgICAgICAgc3lzdGVtIHRoZXNlIGFyZSB0aGUgcmlnaHQgYW5kIGxlZnQgY2hhbm5lbHMuXG5cdFx0ICogICAgICAgICAgUGluZ1BvbmdEZWxheSBpbiBtb3JlIHNpbXBsaWZpZWQgdGVybXMgaXMgdHdvIFRvbmUuRmVlZGJhY2tEZWxheXMgXG5cdFx0ICogICAgICAgICAgd2l0aCBpbmRlcGVuZGVudCBkZWxheSB2YWx1ZXMuIEVhY2ggZGVsYXkgaXMgcm91dGVkIHRvIG9uZSBjaGFubmVsXG5cdFx0ICogICAgICAgICAgKGxlZnQgb3IgcmlnaHQpLCBhbmQgdGhlIGNoYW5uZWwgdHJpZ2dlcmVkIHNlY29uZCB3aWxsIGFsd2F5cyBcblx0XHQgKiAgICAgICAgICB0cmlnZ2VyIGF0IHRoZSBzYW1lIGludGVydmFsIGFmdGVyIHRoZSBmaXJzdC5cblx0XHQgKlxuXHRcdCAqIFx0QGNvbnN0cnVjdG9yXG5cdFx0ICogXHRAZXh0ZW5kcyB7VG9uZS5TdGVyZW9YRmVlZGJhY2tFZmZlY3R9XG5cdFx0ICogIEBwYXJhbSB7VGltZXxPYmplY3R9IFtkZWxheVRpbWVdIFRoZSBkZWxheVRpbWUgYmV0d2VlbiBjb25zZWN1dGl2ZSBlY2hvcy5cblx0XHQgKiAgQHBhcmFtIHtOb3JtYWxSYW5nZT19IGZlZWRiYWNrIFRoZSBhbW91bnQgb2YgdGhlIGVmZmVjdGVkIHNpZ25hbCB3aGljaCBcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzIGZlZCBiYWNrIHRocm91Z2ggdGhlIGRlbGF5LlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIHZhciBwaW5nUG9uZyA9IG5ldyBUb25lLlBpbmdQb25nRGVsYXkoXCI0blwiLCAwLjIpLnRvTWFzdGVyKCk7XG5cdFx0ICogdmFyIGRydW0gPSBuZXcgVG9uZS5EcnVtU3ludGgoKS5jb25uZWN0KHBpbmdQb25nKTtcblx0XHQgKiBkcnVtLnRyaWdnZXJBdHRhY2tSZWxlYXNlKFwiQzRcIiwgXCIzMm5cIik7XG5cdFx0ICovXG5cdCAgICBUb25lLlBpbmdQb25nRGVsYXkgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIG9wdGlvbnMgPSBUb25lLmRlZmF1bHRzKGFyZ3VtZW50cywgW1xuXHQgICAgICAgICAgICAnZGVsYXlUaW1lJyxcblx0ICAgICAgICAgICAgJ2ZlZWRiYWNrJ1xuXHQgICAgICAgIF0sIFRvbmUuUGluZ1BvbmdEZWxheSk7XG5cdCAgICAgICAgVG9uZS5TdGVyZW9YRmVlZGJhY2tFZmZlY3QuY2FsbCh0aGlzLCBvcHRpb25zKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICB0aGUgZGVsYXkgbm9kZSBvbiB0aGUgbGVmdCBzaWRlXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuRGVsYXl9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2xlZnREZWxheSA9IG5ldyBUb25lLkRlbGF5KDAsIG9wdGlvbnMubWF4RGVsYXlUaW1lKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICB0aGUgZGVsYXkgbm9kZSBvbiB0aGUgcmlnaHQgc2lkZVxuXHRcdFx0ICogIEB0eXBlIHtUb25lLkRlbGF5fVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9yaWdodERlbGF5ID0gbmV3IFRvbmUuRGVsYXkoMCwgb3B0aW9ucy5tYXhEZWxheVRpbWUpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHRoZSBwcmVkZWxheSBvbiB0aGUgcmlnaHQgc2lkZVxuXHRcdFx0ICogIEB0eXBlIHtUb25lLkRlbGF5fVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9yaWdodFByZURlbGF5ID0gbmV3IFRvbmUuRGVsYXkoMCwgb3B0aW9ucy5tYXhEZWxheVRpbWUpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHRoZSBkZWxheSB0aW1lIHNpZ25hbFxuXHRcdFx0ICogIEB0eXBlIHtUaW1lfVxuXHRcdFx0ICogIEBzaWduYWxcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuZGVsYXlUaW1lID0gbmV3IFRvbmUuU2lnbmFsKG9wdGlvbnMuZGVsYXlUaW1lLCBUb25lLlR5cGUuVGltZSk7XG5cdCAgICAgICAgLy9jb25uZWN0IGl0IHVwXG5cdCAgICAgICAgdGhpcy5lZmZlY3RTZW5kTC5jaGFpbih0aGlzLl9sZWZ0RGVsYXksIHRoaXMuZWZmZWN0UmV0dXJuTCk7XG5cdCAgICAgICAgdGhpcy5lZmZlY3RTZW5kUi5jaGFpbih0aGlzLl9yaWdodFByZURlbGF5LCB0aGlzLl9yaWdodERlbGF5LCB0aGlzLmVmZmVjdFJldHVyblIpO1xuXHQgICAgICAgIHRoaXMuZGVsYXlUaW1lLmZhbih0aGlzLl9sZWZ0RGVsYXkuZGVsYXlUaW1lLCB0aGlzLl9yaWdodERlbGF5LmRlbGF5VGltZSwgdGhpcy5fcmlnaHRQcmVEZWxheS5kZWxheVRpbWUpO1xuXHQgICAgICAgIC8vcmVhcnJhbmdlZCB0aGUgZmVlZGJhY2sgdG8gYmUgYWZ0ZXIgdGhlIHJpZ2h0UHJlRGVsYXlcblx0ICAgICAgICB0aGlzLl9mZWVkYmFja0xSLmRpc2Nvbm5lY3QoKTtcblx0ICAgICAgICB0aGlzLl9mZWVkYmFja0xSLmNvbm5lY3QodGhpcy5fcmlnaHREZWxheSk7XG5cdCAgICAgICAgdGhpcy5fcmVhZE9ubHkoWydkZWxheVRpbWUnXSk7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5QaW5nUG9uZ0RlbGF5LCBUb25lLlN0ZXJlb1hGZWVkYmFja0VmZmVjdCk7XG5cdCAgICAvKipcblx0XHQgKiAgQHN0YXRpY1xuXHRcdCAqICBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqL1xuXHQgICAgVG9uZS5QaW5nUG9uZ0RlbGF5LmRlZmF1bHRzID0ge1xuXHQgICAgICAgICdkZWxheVRpbWUnOiAwLjI1LFxuXHQgICAgICAgICdtYXhEZWxheVRpbWUnOiAxXG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIENsZWFuIHVwLiBcblx0XHQgKiAgQHJldHVybnMge1RvbmUuUGluZ1BvbmdEZWxheX0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5QaW5nUG9uZ0RlbGF5LnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuU3RlcmVvWEZlZWRiYWNrRWZmZWN0LnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgdGhpcy5fbGVmdERlbGF5LmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9sZWZ0RGVsYXkgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX3JpZ2h0RGVsYXkuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX3JpZ2h0RGVsYXkgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX3JpZ2h0UHJlRGVsYXkuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX3JpZ2h0UHJlRGVsYXkgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX3dyaXRhYmxlKFsnZGVsYXlUaW1lJ10pO1xuXHQgICAgICAgIHRoaXMuZGVsYXlUaW1lLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLmRlbGF5VGltZSA9IG51bGw7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuUGluZ1BvbmdEZWxheTtcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgXG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzIFRvbmUuUGl0Y2hTaGlmdCBkb2VzIG5lYXItcmVhbHRpbWUgcGl0Y2ggc2hpZnRpbmcgdG8gdGhlIGluY29taW5nIHNpZ25hbC4gXG5cdFx0ICogICAgICAgICBUaGUgZWZmZWN0IGlzIGFjaGlldmVkIGJ5IHNwZWVkaW5nIHVwIG9yIHNsb3dpbmcgZG93biB0aGUgZGVsYXlUaW1lXG5cdFx0ICogICAgICAgICBvZiBhIERlbGF5Tm9kZSB1c2luZyBhIHNhd3Rvb3RoIHdhdmUuIFxuXHRcdCAqICAgICAgICAgQWxnb3JpdGhtIGZvdW5kIGluIFt0aGlzIHBkZl0oaHR0cDovL2RzcC1ib29rLm5hcm9kLnJ1L3NvdW5kcHJvYy5wZGYpLlxuXHRcdCAqICAgICAgICAgQWRkaXRpb25hbCByZWZlcmVuY2UgYnkgW01pbGxlciBQdWNrZXRdKGh0dHA6Ly9tc3AudWNzZC5lZHUvdGVjaG5pcXVlcy92MC4xMS9ib29rLWh0bWwvbm9kZTExNS5odG1sKS5cblx0XHQgKiAgICAgICAgIFxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZS5GZWVkYmFja0VmZmVjdH1cblx0XHQgKiAgQHBhcmFtIHtJbnRlcnZhbD19IHBpdGNoIFRoZSBpbnRlcnZhbCB0byB0cmFuc3Bvc2UgdGhlIGluY29taW5nIHNpZ25hbCBieS4gXG5cdFx0ICovXG5cdCAgICBUb25lLlBpdGNoU2hpZnQgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIG9wdGlvbnMgPSBUb25lLmRlZmF1bHRzKGFyZ3VtZW50cywgWydwaXRjaCddLCBUb25lLlBpdGNoU2hpZnQpO1xuXHQgICAgICAgIFRvbmUuRmVlZGJhY2tFZmZlY3QuY2FsbCh0aGlzLCBvcHRpb25zKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgcGl0Y2ggc2lnbmFsXG5cdFx0XHQgKiAgQHR5cGUgIHtUb25lLlNpZ25hbH1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fZnJlcXVlbmN5ID0gbmV3IFRvbmUuU2lnbmFsKDApO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFVzZXMgdHdvIERlbGF5Tm9kZXMgdG8gY292ZXIgdXAgdGhlIGp1bXAgaW5cblx0XHRcdCAqICB0aGUgc2F3dG9vdGggd2F2ZS4gXG5cdFx0XHQgKiAgQHR5cGUgIHtEZWxheU5vZGV9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2RlbGF5QSA9IG5ldyBUb25lLkRlbGF5KDAsIDEpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBmaXJzdCBMRk8uXG5cdFx0XHQgKiAgQHR5cGUgIHtUb25lLkxGT31cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fbGZvQSA9IG5ldyBUb25lLkxGTyh7XG5cdCAgICAgICAgICAgICdtaW4nOiAwLFxuXHQgICAgICAgICAgICAnbWF4JzogMC4xLFxuXHQgICAgICAgICAgICAndHlwZSc6ICdzYXd0b290aCdcblx0ICAgICAgICB9KS5jb25uZWN0KHRoaXMuX2RlbGF5QS5kZWxheVRpbWUpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBzZWNvbmQgRGVsYXlOb2RlXG5cdFx0XHQgKiAgQHR5cGUgIHtEZWxheU5vZGV9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2RlbGF5QiA9IG5ldyBUb25lLkRlbGF5KDAsIDEpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBmaXJzdCBMRk8uXG5cdFx0XHQgKiAgQHR5cGUgIHtUb25lLkxGT31cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fbGZvQiA9IG5ldyBUb25lLkxGTyh7XG5cdCAgICAgICAgICAgICdtaW4nOiAwLFxuXHQgICAgICAgICAgICAnbWF4JzogMC4xLFxuXHQgICAgICAgICAgICAndHlwZSc6ICdzYXd0b290aCcsXG5cdCAgICAgICAgICAgICdwaGFzZSc6IDE4MFxuXHQgICAgICAgIH0pLmNvbm5lY3QodGhpcy5fZGVsYXlCLmRlbGF5VGltZSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgQ3Jvc3NmYWRlIHF1aWNrbHkgYmV0d2VlbiB0aGUgdHdvIGRlbGF5IGxpbmVzXG5cdFx0XHQgKiAgdG8gY292ZXIgdXAgdGhlIGp1bXAgaW4gdGhlIHNhd3Rvb3RoIHdhdmVcblx0XHRcdCAqICBAdHlwZSAge1RvbmUuQ3Jvc3NGYWRlfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9jcm9zc0ZhZGUgPSBuZXcgVG9uZS5Dcm9zc0ZhZGUoKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBMRk8gd2hpY2ggYWx0ZXJuYXRlcyBiZXR3ZWVuIHRoZSB0d29cblx0XHRcdCAqICBkZWxheSBsaW5lcyB0byBjb3ZlciB1cCB0aGUgZGlzcGFyaXR5IGluIHRoZVxuXHRcdFx0ICogIHNhd3Rvb3RoIHdhdmUuIFxuXHRcdFx0ICogIEB0eXBlICB7VG9uZS5MRk99XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2Nyb3NzRmFkZUxGTyA9IG5ldyBUb25lLkxGTyh7XG5cdCAgICAgICAgICAgICdtaW4nOiAwLFxuXHQgICAgICAgICAgICAnbWF4JzogMSxcblx0ICAgICAgICAgICAgJ3R5cGUnOiAndHJpYW5nbGUnLFxuXHQgICAgICAgICAgICAncGhhc2UnOiA5MFxuXHQgICAgICAgIH0pLmNvbm5lY3QodGhpcy5fY3Jvc3NGYWRlLmZhZGUpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBkZWxheSBub2RlXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuRGVsYXl9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2ZlZWRiYWNrRGVsYXkgPSBuZXcgVG9uZS5EZWxheShvcHRpb25zLmRlbGF5VGltZSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGFtb3VudCBvZiBkZWxheSBvbiB0aGUgaW5wdXQgc2lnbmFsXG5cdFx0XHQgKiAgQHR5cGUge1RpbWV9XG5cdFx0XHQgKiAgQHNpZ25hbFxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5kZWxheVRpbWUgPSB0aGlzLl9mZWVkYmFja0RlbGF5LmRlbGF5VGltZTtcblx0ICAgICAgICB0aGlzLl9yZWFkT25seSgnZGVsYXlUaW1lJyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgSG9sZCB0aGUgY3VycmVudCBwaXRjaFxuXHRcdFx0ICogIEB0eXBlIHtOdW1iZXJ9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX3BpdGNoID0gb3B0aW9ucy5waXRjaDtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBIb2xkIHRoZSBjdXJyZW50IHdpbmRvd1NpemVcblx0XHRcdCAqICBAdHlwZSB7TnVtYmVyfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl93aW5kb3dTaXplID0gb3B0aW9ucy53aW5kb3dTaXplO1xuXHQgICAgICAgIC8vY29ubmVjdCB0aGUgdHdvIGRlbGF5IGxpbmVzIHVwXG5cdCAgICAgICAgdGhpcy5fZGVsYXlBLmNvbm5lY3QodGhpcy5fY3Jvc3NGYWRlLmEpO1xuXHQgICAgICAgIHRoaXMuX2RlbGF5Qi5jb25uZWN0KHRoaXMuX2Nyb3NzRmFkZS5iKTtcblx0ICAgICAgICAvL2Nvbm5lY3QgdGhlIGZyZXF1ZW5jeVxuXHQgICAgICAgIHRoaXMuX2ZyZXF1ZW5jeS5mYW4odGhpcy5fbGZvQS5mcmVxdWVuY3ksIHRoaXMuX2xmb0IuZnJlcXVlbmN5LCB0aGlzLl9jcm9zc0ZhZGVMRk8uZnJlcXVlbmN5KTtcblx0ICAgICAgICAvL3JvdXRlIHRoZSBpbnB1dFxuXHQgICAgICAgIHRoaXMuZWZmZWN0U2VuZC5mYW4odGhpcy5fZGVsYXlBLCB0aGlzLl9kZWxheUIpO1xuXHQgICAgICAgIHRoaXMuX2Nyb3NzRmFkZS5jaGFpbih0aGlzLl9mZWVkYmFja0RlbGF5LCB0aGlzLmVmZmVjdFJldHVybik7XG5cdCAgICAgICAgLy9zdGFydCB0aGUgTEZPcyBhdCB0aGUgc2FtZSB0aW1lXG5cdCAgICAgICAgdmFyIG5vdyA9IHRoaXMubm93KCk7XG5cdCAgICAgICAgdGhpcy5fbGZvQS5zdGFydChub3cpO1xuXHQgICAgICAgIHRoaXMuX2xmb0Iuc3RhcnQobm93KTtcblx0ICAgICAgICB0aGlzLl9jcm9zc0ZhZGVMRk8uc3RhcnQobm93KTtcblx0ICAgICAgICAvL3NldCB0aGUgaW5pdGlhbCB2YWx1ZVxuXHQgICAgICAgIHRoaXMud2luZG93U2l6ZSA9IHRoaXMuX3dpbmRvd1NpemU7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5QaXRjaFNoaWZ0LCBUb25lLkZlZWRiYWNrRWZmZWN0KTtcblx0ICAgIC8qKlxuXHRcdCAqICBkZWZhdWx0IHZhbHVlc1xuXHRcdCAqICBAc3RhdGljXG5cdFx0ICogIEB0eXBlIHtPYmplY3R9XG5cdFx0ICogIEBjb25zdFxuXHRcdCAqL1xuXHQgICAgVG9uZS5QaXRjaFNoaWZ0LmRlZmF1bHRzID0ge1xuXHQgICAgICAgICdwaXRjaCc6IDAsXG5cdCAgICAgICAgJ3dpbmRvd1NpemUnOiAwLjEsXG5cdCAgICAgICAgJ2RlbGF5VGltZSc6IDAsXG5cdCAgICAgICAgJ2ZlZWRiYWNrJzogMFxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqIFJlcGl0Y2ggdGhlIGluY29taW5nIHNpZ25hbCBieSBzb21lIGludGVydmFsIChtZWFzdXJlZFxuXHRcdCAqIGluIHNlbWktdG9uZXMpLiBcblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5QaXRjaFNoaWZ0I1xuXHRcdCAqIEB0eXBlIHtJbnRlcnZhbH1cblx0XHQgKiBAbmFtZSBwaXRjaFxuXHRcdCAqIEBleGFtcGxlXG5cdFx0ICogcGl0Y2hTaGlmdC5waXRjaCA9IC0xMjsgLy9kb3duIG9uZSBvY3RhdmVcblx0XHQgKiBwaXRjaFNoaWZ0LnBpdGNoID0gNzsgLy91cCBhIGZpZnRoXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5QaXRjaFNoaWZ0LnByb3RvdHlwZSwgJ3BpdGNoJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fcGl0Y2g7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChpbnRlcnZhbCkge1xuXHQgICAgICAgICAgICB0aGlzLl9waXRjaCA9IGludGVydmFsO1xuXHQgICAgICAgICAgICB2YXIgZmFjdG9yID0gMDtcblx0ICAgICAgICAgICAgaWYgKGludGVydmFsIDwgMCkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fbGZvQS5taW4gPSAwO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fbGZvQS5tYXggPSB0aGlzLl93aW5kb3dTaXplO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fbGZvQi5taW4gPSAwO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fbGZvQi5tYXggPSB0aGlzLl93aW5kb3dTaXplO1xuXHQgICAgICAgICAgICAgICAgZmFjdG9yID0gVG9uZS5pbnRlcnZhbFRvRnJlcXVlbmN5UmF0aW8oaW50ZXJ2YWwgLSAxKSArIDE7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9sZm9BLm1pbiA9IHRoaXMuX3dpbmRvd1NpemU7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9sZm9BLm1heCA9IDA7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9sZm9CLm1pbiA9IHRoaXMuX3dpbmRvd1NpemU7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9sZm9CLm1heCA9IDA7XG5cdCAgICAgICAgICAgICAgICBmYWN0b3IgPSBUb25lLmludGVydmFsVG9GcmVxdWVuY3lSYXRpbyhpbnRlcnZhbCkgLSAxO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHRoaXMuX2ZyZXF1ZW5jeS52YWx1ZSA9IGZhY3RvciAqICgxLjIgLyB0aGlzLl93aW5kb3dTaXplKTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqIFRoZSB3aW5kb3cgc2l6ZSBjb3JyZXNwb25kcyByb3VnaGx5IHRvIHRoZSBzYW1wbGUgbGVuZ3RoIGluIGEgbG9vcGluZyBzYW1wbGVyLiBcblx0XHQgKiBTbWFsbGVyIHZhbHVlcyBhcmUgZGVzaXJhYmxlIGZvciBhIGxlc3Mgbm90aWNlYWJsZSBkZWxheSB0aW1lIG9mIHRoZSBwaXRjaCBzaGlmdGVkXG5cdFx0ICogc2lnbmFsLCBidXQgbGFyZ2VyIHZhbHVlcyB3aWxsIHJlc3VsdCBpbiBzbW9vdGhlciBwaXRjaCBzaGlmdGluZyBmb3IgbGFyZ2VyIGludGVydmFscy4gXG5cdFx0ICogQSBub21pbmFsIHJhbmdlIG9mIDAuMDMgdG8gMC4xIGlzIHJlY29tbWVuZGVkLiBcblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5QaXRjaFNoaWZ0I1xuXHRcdCAqIEB0eXBlIHtUaW1lfVxuXHRcdCAqIEBuYW1lIHdpbmRvd1NpemVcblx0XHQgKiBAZXhhbXBsZVxuXHRcdCAqIHBpdGNoU2hpZnQud2luZG93U2l6ZSA9IDAuMTtcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLlBpdGNoU2hpZnQucHJvdG90eXBlLCAnd2luZG93U2l6ZScsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dpbmRvd1NpemU7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChzaXplKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3dpbmRvd1NpemUgPSB0aGlzLnRvU2Vjb25kcyhzaXplKTtcblx0ICAgICAgICAgICAgdGhpcy5waXRjaCA9IHRoaXMuX3BpdGNoO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIENsZWFuIHVwLlxuXHRcdCAqICBAcmV0dXJuICB7VG9uZS5QaXRjaFNoaWZ0fSAgdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5QaXRjaFNoaWZ0LnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuRmVlZGJhY2tFZmZlY3QucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLl9mcmVxdWVuY3kuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX2ZyZXF1ZW5jeSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fZGVsYXlBLmRpc2Nvbm5lY3QoKTtcblx0ICAgICAgICB0aGlzLl9kZWxheUEgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX2RlbGF5Qi5kaXNjb25uZWN0KCk7XG5cdCAgICAgICAgdGhpcy5fZGVsYXlCID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9sZm9BLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9sZm9BID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9sZm9CLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9sZm9CID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9jcm9zc0ZhZGUuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX2Nyb3NzRmFkZSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fY3Jvc3NGYWRlTEZPLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9jcm9zc0ZhZGVMRk8gPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX3dyaXRhYmxlKCdkZWxheVRpbWUnKTtcblx0ICAgICAgICB0aGlzLl9mZWVkYmFja0RlbGF5LmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9mZWVkYmFja0RlbGF5ID0gbnVsbDtcblx0ICAgICAgICB0aGlzLmRlbGF5VGltZSA9IG51bGw7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuUGl0Y2hTaGlmdDtcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgXG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzIEJhc2UgY2xhc3MgZm9yIHN0ZXJlbyBmZWVkYmFjayBlZmZlY3RzIHdoZXJlIHRoZSBlZmZlY3RSZXR1cm5cblx0XHQgKiAgICAgICAgIGlzIGZlZCBiYWNrIGludG8gdGhlIHNhbWUgY2hhbm5lbC4gXG5cdFx0ICpcblx0XHQgKlx0QGNvbnN0cnVjdG9yXG5cdFx0ICpcdEBleHRlbmRzIHtUb25lLlN0ZXJlb0VmZmVjdH1cblx0XHQgKi9cblx0ICAgIFRvbmUuU3RlcmVvRmVlZGJhY2tFZmZlY3QgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIG9wdGlvbnMgPSBUb25lLmRlZmF1bHRzKGFyZ3VtZW50cywgWydmZWVkYmFjayddLCBUb25lLkZlZWRiYWNrRWZmZWN0KTtcblx0ICAgICAgICBUb25lLlN0ZXJlb0VmZmVjdC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIGNvbnRyb2xzIHRoZSBhbW91bnQgb2YgZmVlZGJhY2tcblx0XHRcdCAqICBAdHlwZSB7Tm9ybWFsUmFuZ2V9XG5cdFx0XHQgKiAgQHNpZ25hbFxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5mZWVkYmFjayA9IG5ldyBUb25lLlNpZ25hbChvcHRpb25zLmZlZWRiYWNrLCBUb25lLlR5cGUuTm9ybWFsUmFuZ2UpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHRoZSBsZWZ0IHNpZGUgZmVlYmFja1xuXHRcdFx0ICogIEB0eXBlIHtUb25lLkdhaW59XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2ZlZWRiYWNrTCA9IG5ldyBUb25lLkdhaW4oKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICB0aGUgcmlnaHQgc2lkZSBmZWViYWNrXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuR2Fpbn1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fZmVlZGJhY2tSID0gbmV3IFRvbmUuR2FpbigpO1xuXHQgICAgICAgIC8vY29ubmVjdCBpdCB1cFxuXHQgICAgICAgIHRoaXMuZWZmZWN0UmV0dXJuTC5jaGFpbih0aGlzLl9mZWVkYmFja0wsIHRoaXMuZWZmZWN0U2VuZEwpO1xuXHQgICAgICAgIHRoaXMuZWZmZWN0UmV0dXJuUi5jaGFpbih0aGlzLl9mZWVkYmFja1IsIHRoaXMuZWZmZWN0U2VuZFIpO1xuXHQgICAgICAgIHRoaXMuZmVlZGJhY2suZmFuKHRoaXMuX2ZlZWRiYWNrTC5nYWluLCB0aGlzLl9mZWVkYmFja1IuZ2Fpbik7XG5cdCAgICAgICAgdGhpcy5fcmVhZE9ubHkoWydmZWVkYmFjayddKTtcblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLlN0ZXJlb0ZlZWRiYWNrRWZmZWN0LCBUb25lLlN0ZXJlb0VmZmVjdCk7XG5cdCAgICAvKipcblx0XHQgKiAgY2xlYW4gdXBcblx0XHQgKiAgQHJldHVybnMge1RvbmUuU3RlcmVvRmVlZGJhY2tFZmZlY3R9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuU3RlcmVvRmVlZGJhY2tFZmZlY3QucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5TdGVyZW9FZmZlY3QucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLl93cml0YWJsZShbJ2ZlZWRiYWNrJ10pO1xuXHQgICAgICAgIHRoaXMuZmVlZGJhY2suZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuZmVlZGJhY2sgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX2ZlZWRiYWNrTC5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fZmVlZGJhY2tMID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9mZWVkYmFja1IuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX2ZlZWRiYWNrUiA9IG51bGw7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuU3RlcmVvRmVlZGJhY2tFZmZlY3Q7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyBBcHBsaWVzIGEgd2lkdGggZmFjdG9yIHRvIHRoZSBtaWQvc2lkZSBzZXBlcmF0aW9uLiBcblx0XHQgKiAgICAgICAgIDAgaXMgYWxsIG1pZCBhbmQgMSBpcyBhbGwgc2lkZS5cblx0XHQgKiAgICAgICAgIEFsZ29yaXRobSBmb3VuZCBpbiBba3ZyYXVkaW8gZm9ydW1zXShodHRwOi8vd3d3Lmt2cmF1ZGlvLmNvbS9mb3J1bS92aWV3dG9waWMucGhwP3Q9MjEyNTg3KS5cblx0XHQgKiAgICAgICAgIDxicj48YnI+XG5cdFx0ICogICAgICAgICA8Y29kZT5cblx0XHQgKiAgICAgICAgIE1pZCAqPSAyKigxLXdpZHRoKTxicj5cblx0XHQgKiAgICAgICAgIFNpZGUgKj0gMip3aWR0aFxuXHRcdCAqICAgICAgICAgPC9jb2RlPlxuXHRcdCAqXG5cdFx0ICogIEBleHRlbmRzIHtUb25lLk1pZFNpZGVFZmZlY3R9XG5cdFx0ICogIEBjb25zdHJ1Y3RvclxuXHRcdCAqICBAcGFyYW0ge05vcm1hbFJhbmdlfE9iamVjdH0gW3dpZHRoXSBUaGUgc3RlcmVvIHdpZHRoLiBBIHdpZHRoIG9mIDAgaXMgbW9ubyBhbmQgMSBpcyBzdGVyZW8uIDAuNSBpcyBubyBjaGFuZ2UuXG5cdFx0ICovXG5cdCAgICBUb25lLlN0ZXJlb1dpZGVuZXIgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIG9wdGlvbnMgPSBUb25lLmRlZmF1bHRzKGFyZ3VtZW50cywgWyd3aWR0aCddLCBUb25lLlN0ZXJlb1dpZGVuZXIpO1xuXHQgICAgICAgIFRvbmUuTWlkU2lkZUVmZmVjdC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSB3aWR0aCBjb250cm9sLiAwID0gMTAwJSBtaWQuIDEgPSAxMDAlIHNpZGUuIDAuNSA9IG5vIGNoYW5nZS4gXG5cdFx0XHQgKiAgQHR5cGUge05vcm1hbFJhbmdlfVxuXHRcdFx0ICogIEBzaWduYWxcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMud2lkdGggPSBuZXcgVG9uZS5TaWduYWwob3B0aW9ucy53aWR0aCwgVG9uZS5UeXBlLk5vcm1hbFJhbmdlKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBNaWQgbXVsdGlwbGllclxuXHRcdFx0ICogIEB0eXBlIHtUb25lLkV4cHJ9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX21pZE11bHQgPSBuZXcgVG9uZS5FeHByKCckMCAqICgkMSAqICgxIC0gJDIpKScpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFNpZGUgbXVsdGlwbGllclxuXHRcdFx0ICogIEB0eXBlIHtUb25lLkV4cHJ9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX3NpZGVNdWx0ID0gbmV3IFRvbmUuRXhwcignJDAgKiAoJDEgKiAkMiknKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBjb25zdGFudCBvdXRwdXQgb2YgMlxuXHRcdFx0ICogIEB0eXBlIHtUb25lfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl90d28gPSBuZXcgVG9uZS5TaWduYWwoMik7XG5cdCAgICAgICAgLy90aGUgbWlkIGNoYWluXG5cdCAgICAgICAgdGhpcy5fdHdvLmNvbm5lY3QodGhpcy5fbWlkTXVsdCwgMCwgMSk7XG5cdCAgICAgICAgdGhpcy53aWR0aC5jb25uZWN0KHRoaXMuX21pZE11bHQsIDAsIDIpO1xuXHQgICAgICAgIC8vdGhlIHNpZGUgY2hhaW5cblx0ICAgICAgICB0aGlzLl90d28uY29ubmVjdCh0aGlzLl9zaWRlTXVsdCwgMCwgMSk7XG5cdCAgICAgICAgdGhpcy53aWR0aC5jb25uZWN0KHRoaXMuX3NpZGVNdWx0LCAwLCAyKTtcblx0ICAgICAgICAvL2Nvbm5lY3QgaXQgdG8gdGhlIGVmZmVjdCBzZW5kL3JldHVyblxuXHQgICAgICAgIHRoaXMubWlkU2VuZC5jaGFpbih0aGlzLl9taWRNdWx0LCB0aGlzLm1pZFJldHVybik7XG5cdCAgICAgICAgdGhpcy5zaWRlU2VuZC5jaGFpbih0aGlzLl9zaWRlTXVsdCwgdGhpcy5zaWRlUmV0dXJuKTtcblx0ICAgICAgICB0aGlzLl9yZWFkT25seShbJ3dpZHRoJ10pO1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuU3RlcmVvV2lkZW5lciwgVG9uZS5NaWRTaWRlRWZmZWN0KTtcblx0ICAgIC8qKlxuXHRcdCAqICB0aGUgZGVmYXVsdCB2YWx1ZXNcblx0XHQgKiAgQHN0YXRpY1xuXHRcdCAqICBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqL1xuXHQgICAgVG9uZS5TdGVyZW9XaWRlbmVyLmRlZmF1bHRzID0geyAnd2lkdGgnOiAwLjUgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBDbGVhbiB1cC4gXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLlN0ZXJlb1dpZGVuZXJ9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuU3RlcmVvV2lkZW5lci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLk1pZFNpZGVFZmZlY3QucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLl93cml0YWJsZShbJ3dpZHRoJ10pO1xuXHQgICAgICAgIHRoaXMud2lkdGguZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMud2lkdGggPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX21pZE11bHQuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX21pZE11bHQgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX3NpZGVNdWx0LmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9zaWRlTXVsdCA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fdHdvLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl90d28gPSBudWxsO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLlN0ZXJlb1dpZGVuZXI7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyBUb25lLlRyZW1vbG8gbW9kdWxhdGVzIHRoZSBhbXBsaXR1ZGUgb2YgYW4gaW5jb21pbmcgc2lnbmFsIHVzaW5nIGEgVG9uZS5MRk8uXG5cdFx0ICogICAgICAgICBUaGUgdHlwZSwgZnJlcXVlbmN5LCBhbmQgZGVwdGggb2YgdGhlIExGTyBpcyBjb250cm9sbGFibGUuXG5cdFx0ICpcblx0XHQgKiAgQGV4dGVuZHMge1RvbmUuU3RlcmVvRWZmZWN0fVxuXHRcdCAqICBAY29uc3RydWN0b3Jcblx0XHQgKiAgQHBhcmFtIHtGcmVxdWVuY3l9IFtmcmVxdWVuY3ldIFRoZSByYXRlIG9mIHRoZSBlZmZlY3QuXG5cdFx0ICogIEBwYXJhbSB7Tm9ybWFsUmFuZ2V9IFtkZXB0aF0gVGhlIGRlcHRoIG9mIHRoZSBlZmZlY3QuXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogLy9jcmVhdGUgYSB0cmVtb2xvIGFuZCBzdGFydCBpdCdzIExGT1xuXHRcdCAqIHZhciB0cmVtb2xvID0gbmV3IFRvbmUuVHJlbW9sbyg5LCAwLjc1KS50b01hc3RlcigpLnN0YXJ0KCk7XG5cdFx0ICogLy9yb3V0ZSBhbiBvc2NpbGxhdG9yIHRocm91Z2ggdGhlIHRyZW1vbG8gYW5kIHN0YXJ0IGl0XG5cdFx0ICogdmFyIG9zY2lsbGF0b3IgPSBuZXcgVG9uZS5Pc2NpbGxhdG9yKCkuY29ubmVjdCh0cmVtb2xvKS5zdGFydCgpO1xuXHRcdCAqL1xuXHQgICAgVG9uZS5UcmVtb2xvID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBvcHRpb25zID0gVG9uZS5kZWZhdWx0cyhhcmd1bWVudHMsIFtcblx0ICAgICAgICAgICAgJ2ZyZXF1ZW5jeScsXG5cdCAgICAgICAgICAgICdkZXB0aCdcblx0ICAgICAgICBdLCBUb25lLlRyZW1vbG8pO1xuXHQgICAgICAgIFRvbmUuU3RlcmVvRWZmZWN0LmNhbGwodGhpcywgb3B0aW9ucyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIHRyZW1lbG8gTEZPIGluIHRoZSBsZWZ0IGNoYW5uZWxcblx0XHRcdCAqICBAdHlwZSAge1RvbmUuTEZPfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9sZm9MID0gbmV3IFRvbmUuTEZPKHtcblx0ICAgICAgICAgICAgJ3BoYXNlJzogb3B0aW9ucy5zcHJlYWQsXG5cdCAgICAgICAgICAgICdtaW4nOiAxLFxuXHQgICAgICAgICAgICAnbWF4JzogMFxuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSB0cmVtZWxvIExGTyBpbiB0aGUgbGVmdCBjaGFubmVsXG5cdFx0XHQgKiAgQHR5cGUgIHtUb25lLkxGT31cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fbGZvUiA9IG5ldyBUb25lLkxGTyh7XG5cdCAgICAgICAgICAgICdwaGFzZSc6IG9wdGlvbnMuc3ByZWFkLFxuXHQgICAgICAgICAgICAnbWluJzogMSxcblx0ICAgICAgICAgICAgJ21heCc6IDBcblx0ICAgICAgICB9KTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBXaGVyZSB0aGUgZ2FpbiBpcyBtdWx0aXBsaWVkXG5cdFx0XHQgKiAgQHR5cGUgIHtUb25lLkdhaW59XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2FtcGxpdHVkZUwgPSBuZXcgVG9uZS5HYWluKCk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgV2hlcmUgdGhlIGdhaW4gaXMgbXVsdGlwbGllZFxuXHRcdFx0ICogIEB0eXBlICB7VG9uZS5HYWlufVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9hbXBsaXR1ZGVSID0gbmV3IFRvbmUuR2FpbigpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBmcmVxdWVuY3kgb2YgdGhlIHRyZW1vbG8uXG5cdFx0XHQgKiAgQHR5cGUgIHtGcmVxdWVuY3l9XG5cdFx0XHQgKiAgQHNpZ25hbFxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5mcmVxdWVuY3kgPSBuZXcgVG9uZS5TaWduYWwob3B0aW9ucy5mcmVxdWVuY3ksIFRvbmUuVHlwZS5GcmVxdWVuY3kpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBkZXB0aCBvZiB0aGUgZWZmZWN0LiBBIGRlcHRoIG9mIDAsIGhhcyBubyBlZmZlY3Rcblx0XHRcdCAqICBvbiB0aGUgYW1wbGl0dWRlLCBhbmQgYSBkZXB0aCBvZiAxIG1ha2VzIHRoZSBhbXBsaXR1ZGVcblx0XHRcdCAqICBtb2R1bGF0ZSBmdWxseSBiZXR3ZWVuIDAgYW5kIDEuXG5cdFx0XHQgKiAgQHR5cGUgIHtOb3JtYWxSYW5nZX1cblx0XHRcdCAqICBAc2lnbmFsXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmRlcHRoID0gbmV3IFRvbmUuU2lnbmFsKG9wdGlvbnMuZGVwdGgsIFRvbmUuVHlwZS5Ob3JtYWxSYW5nZSk7XG5cdCAgICAgICAgdGhpcy5fcmVhZE9ubHkoW1xuXHQgICAgICAgICAgICAnZnJlcXVlbmN5Jyxcblx0ICAgICAgICAgICAgJ2RlcHRoJ1xuXHQgICAgICAgIF0pO1xuXHQgICAgICAgIHRoaXMuZWZmZWN0U2VuZEwuY2hhaW4odGhpcy5fYW1wbGl0dWRlTCwgdGhpcy5lZmZlY3RSZXR1cm5MKTtcblx0ICAgICAgICB0aGlzLmVmZmVjdFNlbmRSLmNoYWluKHRoaXMuX2FtcGxpdHVkZVIsIHRoaXMuZWZmZWN0UmV0dXJuUik7XG5cdCAgICAgICAgdGhpcy5fbGZvTC5jb25uZWN0KHRoaXMuX2FtcGxpdHVkZUwuZ2Fpbik7XG5cdCAgICAgICAgdGhpcy5fbGZvUi5jb25uZWN0KHRoaXMuX2FtcGxpdHVkZVIuZ2Fpbik7XG5cdCAgICAgICAgdGhpcy5mcmVxdWVuY3kuZmFuKHRoaXMuX2xmb0wuZnJlcXVlbmN5LCB0aGlzLl9sZm9SLmZyZXF1ZW5jeSk7XG5cdCAgICAgICAgdGhpcy5kZXB0aC5mYW4odGhpcy5fbGZvUi5hbXBsaXR1ZGUsIHRoaXMuX2xmb0wuYW1wbGl0dWRlKTtcblx0ICAgICAgICB0aGlzLnR5cGUgPSBvcHRpb25zLnR5cGU7XG5cdCAgICAgICAgdGhpcy5zcHJlYWQgPSBvcHRpb25zLnNwcmVhZDtcblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLlRyZW1vbG8sIFRvbmUuU3RlcmVvRWZmZWN0KTtcblx0ICAgIC8qKlxuXHRcdCAqICBAc3RhdGljXG5cdFx0ICogIEBjb25zdFxuXHRcdCAqICBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqL1xuXHQgICAgVG9uZS5UcmVtb2xvLmRlZmF1bHRzID0ge1xuXHQgICAgICAgICdmcmVxdWVuY3knOiAxMCxcblx0ICAgICAgICAndHlwZSc6ICdzaW5lJyxcblx0ICAgICAgICAnZGVwdGgnOiAwLjUsXG5cdCAgICAgICAgJ3NwcmVhZCc6IDE4MFxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqIFN0YXJ0IHRoZSB0cmVtb2xvLlxuXHRcdCAqIEBwYXJhbSB7VGltZX0gW3RpbWU9bm93XSBXaGVuIHRoZSB0cmVtb2xvIGJlZ2lucy5cblx0XHQgKiBAcmV0dXJucyB7VG9uZS5UcmVtb2xvfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLlRyZW1vbG8ucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24gKHRpbWUpIHtcblx0ICAgICAgICB0aGlzLl9sZm9MLnN0YXJ0KHRpbWUpO1xuXHQgICAgICAgIHRoaXMuX2xmb1Iuc3RhcnQodGltZSk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogU3RvcCB0aGUgdHJlbW9sby5cblx0XHQgKiBAcGFyYW0ge1RpbWV9IFt0aW1lPW5vd10gV2hlbiB0aGUgdHJlbW9sbyBzdG9wcy5cblx0XHQgKiBAcmV0dXJucyB7VG9uZS5UcmVtb2xvfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLlRyZW1vbG8ucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAodGltZSkge1xuXHQgICAgICAgIHRoaXMuX2xmb0wuc3RvcCh0aW1lKTtcblx0ICAgICAgICB0aGlzLl9sZm9SLnN0b3AodGltZSk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogU3luYyB0aGUgZWZmZWN0IHRvIHRoZSB0cmFuc3BvcnQuXG5cdFx0ICogQHBhcmFtIHtUaW1lfSBbZGVsYXk9MF0gRGVsYXkgdGltZSBiZWZvcmUgc3RhcnRpbmcgdGhlIGVmZmVjdCBhZnRlciB0aGVcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRyYW5zcG9ydCBoYXMgc3RhcnRlZC5cblx0XHQgKiBAcmV0dXJucyB7VG9uZS5BdXRvRmlsdGVyfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLlRyZW1vbG8ucHJvdG90eXBlLnN5bmMgPSBmdW5jdGlvbiAoZGVsYXkpIHtcblx0ICAgICAgICB0aGlzLl9sZm9MLnN5bmMoZGVsYXkpO1xuXHQgICAgICAgIHRoaXMuX2xmb1Iuc3luYyhkZWxheSk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogVW5zeW5jIHRoZSBmaWx0ZXIgZnJvbSB0aGUgdHJhbnNwb3J0XG5cdFx0ICogQHJldHVybnMge1RvbmUuVHJlbW9sb30gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5UcmVtb2xvLnByb3RvdHlwZS51bnN5bmMgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdGhpcy5fbGZvTC51bnN5bmMoKTtcblx0ICAgICAgICB0aGlzLl9sZm9SLnVuc3luYygpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqIFRoZSBUcmVtb2xvJ3Mgb3NjaWxsYXRvciB0eXBlLlxuXHRcdCAqIEBtZW1iZXJPZiBUb25lLlRyZW1vbG8jXG5cdFx0ICogQHR5cGUge3N0cmluZ31cblx0XHQgKiBAbmFtZSB0eXBlXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5UcmVtb2xvLnByb3RvdHlwZSwgJ3R5cGUnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9sZm9MLnR5cGU7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uICh0eXBlKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2xmb0wudHlwZSA9IHR5cGU7XG5cdCAgICAgICAgICAgIHRoaXMuX2xmb1IudHlwZSA9IHR5cGU7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKiogXG5cdFx0ICogQW1vdW50IG9mIHN0ZXJlbyBzcHJlYWQuIFdoZW4gc2V0IHRvIDAsIGJvdGggTEZPJ3Mgd2lsbCBiZSBwYW5uZWQgY2VudHJhbGx5LlxuXHRcdCAqIFdoZW4gc2V0IHRvIDE4MCwgTEZPJ3Mgd2lsbCBiZSBwYW5uZWQgaGFyZCBsZWZ0IGFuZCByaWdodCByZXNwZWN0aXZlbHkuXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuVHJlbW9sbyNcblx0XHQgKiBAdHlwZSB7RGVncmVlc31cblx0XHQgKiBAbmFtZSBzcHJlYWRcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLlRyZW1vbG8ucHJvdG90eXBlLCAnc3ByZWFkJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fbGZvUi5waGFzZSAtIHRoaXMuX2xmb0wucGhhc2U7ICAgIC8vMTgwXG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChzcHJlYWQpIHtcblx0ICAgICAgICAgICAgdGhpcy5fbGZvTC5waGFzZSA9IDkwIC0gc3ByZWFkIC8gMjtcblx0ICAgICAgICAgICAgdGhpcy5fbGZvUi5waGFzZSA9IHNwcmVhZCAvIDIgKyA5MDtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBjbGVhbiB1cFxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5UcmVtb2xvfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLlRyZW1vbG8ucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5TdGVyZW9FZmZlY3QucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLl93cml0YWJsZShbXG5cdCAgICAgICAgICAgICdmcmVxdWVuY3knLFxuXHQgICAgICAgICAgICAnZGVwdGgnXG5cdCAgICAgICAgXSk7XG5cdCAgICAgICAgdGhpcy5fbGZvTC5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fbGZvTCA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fbGZvUi5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fbGZvUiA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fYW1wbGl0dWRlTC5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fYW1wbGl0dWRlTCA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fYW1wbGl0dWRlUi5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fYW1wbGl0dWRlUiA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5mcmVxdWVuY3kgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuZGVwdGggPSBudWxsO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLlRyZW1vbG87XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyBBIFZpYnJhdG8gZWZmZWN0IGNvbXBvc2VkIG9mIGEgVG9uZS5EZWxheSBhbmQgYSBUb25lLkxGTy4gVGhlIExGT1xuXHRcdCAqICAgICAgICAgbW9kdWxhdGVzIHRoZSBkZWxheVRpbWUgb2YgdGhlIGRlbGF5LCBjYXVzaW5nIHRoZSBwaXRjaCB0byByaXNlXG5cdFx0ICogICAgICAgICBhbmQgZmFsbC4gXG5cdFx0ICogIEBleHRlbmRzIHtUb25lLkVmZmVjdH1cblx0XHQgKiAgQHBhcmFtIHtGcmVxdWVuY3l9IGZyZXF1ZW5jeSBUaGUgZnJlcXVlbmN5IG9mIHRoZSB2aWJyYXRvLlxuXHRcdCAqICBAcGFyYW0ge05vcm1hbFJhbmdlfSBkZXB0aCBUaGUgYW1vdW50IHRoZSBwaXRjaCBpcyBtb2R1bGF0ZWQuXG5cdFx0ICovXG5cdCAgICBUb25lLlZpYnJhdG8gPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIG9wdGlvbnMgPSBUb25lLmRlZmF1bHRzKGFyZ3VtZW50cywgW1xuXHQgICAgICAgICAgICAnZnJlcXVlbmN5Jyxcblx0ICAgICAgICAgICAgJ2RlcHRoJ1xuXHQgICAgICAgIF0sIFRvbmUuVmlicmF0byk7XG5cdCAgICAgICAgVG9uZS5FZmZlY3QuY2FsbCh0aGlzLCBvcHRpb25zKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgZGVsYXkgbm9kZSB1c2VkIGZvciB0aGUgdmlicmF0byBlZmZlY3Rcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5EZWxheX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fZGVsYXlOb2RlID0gbmV3IFRvbmUuRGVsYXkoMCwgb3B0aW9ucy5tYXhEZWxheSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIExGTyB1c2VkIHRvIGNvbnRyb2wgdGhlIHZpYnJhdG9cblx0XHRcdCAqICBAdHlwZSB7VG9uZS5MRk99XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2xmbyA9IG5ldyBUb25lLkxGTyh7XG5cdCAgICAgICAgICAgICd0eXBlJzogb3B0aW9ucy50eXBlLFxuXHQgICAgICAgICAgICAnbWluJzogMCxcblx0ICAgICAgICAgICAgJ21heCc6IG9wdGlvbnMubWF4RGVsYXksXG5cdCAgICAgICAgICAgICdmcmVxdWVuY3knOiBvcHRpb25zLmZyZXF1ZW5jeSxcblx0ICAgICAgICAgICAgJ3BoYXNlJzogLTkwICAgIC8vb2Zmc2UgdGhlIHBoYXNlIHNvIHRoZSByZXN0aW5nIHBvc2l0aW9uIGlzIGluIHRoZSBjZW50ZXJcblx0ICAgICAgICB9KS5zdGFydCgpLmNvbm5lY3QodGhpcy5fZGVsYXlOb2RlLmRlbGF5VGltZSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGZyZXF1ZW5jeSBvZiB0aGUgdmlicmF0b1xuXHRcdFx0ICogIEB0eXBlIHtGcmVxdWVuY3l9XG5cdFx0XHQgKiAgQHNpZ25hbFxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5mcmVxdWVuY3kgPSB0aGlzLl9sZm8uZnJlcXVlbmN5O1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBkZXB0aCBvZiB0aGUgdmlicmF0by4gXG5cdFx0XHQgKiAgQHR5cGUge05vcm1hbFJhbmdlfVxuXHRcdFx0ICogIEBzaWduYWxcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuZGVwdGggPSB0aGlzLl9sZm8uYW1wbGl0dWRlO1xuXHQgICAgICAgIHRoaXMuZGVwdGgudmFsdWUgPSBvcHRpb25zLmRlcHRoO1xuXHQgICAgICAgIHRoaXMuX3JlYWRPbmx5KFtcblx0ICAgICAgICAgICAgJ2ZyZXF1ZW5jeScsXG5cdCAgICAgICAgICAgICdkZXB0aCdcblx0ICAgICAgICBdKTtcblx0ICAgICAgICB0aGlzLmVmZmVjdFNlbmQuY2hhaW4odGhpcy5fZGVsYXlOb2RlLCB0aGlzLmVmZmVjdFJldHVybik7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5WaWJyYXRvLCBUb25lLkVmZmVjdCk7XG5cdCAgICAvKipcblx0XHQgKiAgVGhlIGRlZmF1bHRzXG5cdFx0ICogIEB0eXBlICB7T2JqZWN0fVxuXHRcdCAqICBAY29uc3Rcblx0XHQgKi9cblx0ICAgIFRvbmUuVmlicmF0by5kZWZhdWx0cyA9IHtcblx0ICAgICAgICAnbWF4RGVsYXknOiAwLjAwNSxcblx0ICAgICAgICAnZnJlcXVlbmN5JzogNSxcblx0ICAgICAgICAnZGVwdGgnOiAwLjEsXG5cdCAgICAgICAgJ3R5cGUnOiAnc2luZSdcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiBUeXBlIG9mIG9zY2lsbGF0b3IgYXR0YWNoZWQgdG8gdGhlIFZpYnJhdG8uXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuVmlicmF0byNcblx0XHQgKiBAdHlwZSB7c3RyaW5nfVxuXHRcdCAqIEBuYW1lIHR5cGVcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLlZpYnJhdG8ucHJvdG90eXBlLCAndHlwZScsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xmby50eXBlO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAodHlwZSkge1xuXHQgICAgICAgICAgICB0aGlzLl9sZm8udHlwZSA9IHR5cGU7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgQ2xlYW4gdXAuXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLlZpYnJhdG99IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuVmlicmF0by5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLkVmZmVjdC5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuX2RlbGF5Tm9kZS5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fZGVsYXlOb2RlID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9sZm8uZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX2xmbyA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fd3JpdGFibGUoW1xuXHQgICAgICAgICAgICAnZnJlcXVlbmN5Jyxcblx0ICAgICAgICAgICAgJ2RlcHRoJ1xuXHQgICAgICAgIF0pO1xuXHQgICAgICAgIHRoaXMuZnJlcXVlbmN5ID0gbnVsbDtcblx0ICAgICAgICB0aGlzLmRlcHRoID0gbnVsbDtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVG9uZS5WaWJyYXRvO1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgIFRvbmUuRXZlbnQgYWJzdHJhY3RzIGF3YXkgVG9uZS5UcmFuc3BvcnQuc2NoZWR1bGUgYW5kIHByb3ZpZGVzIGEgc2NoZWR1bGFibGVcblx0XHQgKiAgICAgICAgICBjYWxsYmFjayBmb3IgYSBzaW5nbGUgb3IgcmVwZWF0YWJsZSBldmVudHMgYWxvbmcgdGhlIHRpbWVsaW5lLiBcblx0XHQgKlxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZX1cblx0XHQgKiAgQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGNhbGxiYWNrIHRvIGludm9rZSBhdCB0aGUgdGltZS4gXG5cdFx0ICogIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIG9yIHZhbHVlcyB3aGljaCBzaG91bGQgYmUgcGFzc2VkIHRvXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIG9uIGludm9jYXRpb24uICBcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiB2YXIgY2hvcmQgPSBuZXcgVG9uZS5FdmVudChmdW5jdGlvbih0aW1lLCBjaG9yZCl7XG5cdFx0ICogXHQvL3RoZSBjaG9yZCBhcyB3ZWxsIGFzIHRoZSBleGFjdCB0aW1lIG9mIHRoZSBldmVudFxuXHRcdCAqIFx0Ly9hcmUgcGFzc2VkIGluIGFzIGFyZ3VtZW50cyB0byB0aGUgY2FsbGJhY2sgZnVuY3Rpb25cblx0XHQgKiB9LCBbXCJENFwiLCBcIkU0XCIsIFwiRjRcIl0pO1xuXHRcdCAqIC8vc3RhcnQgdGhlIGNob3JkIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIHRyYW5zcG9ydCB0aW1lbGluZVxuXHRcdCAqIGNob3JkLnN0YXJ0KCk7XG5cdFx0ICogLy9sb29wIGl0IGV2ZXJ5IG1lYXN1cmUgZm9yIDggbWVhc3VyZXNcblx0XHQgKiBjaG9yZC5sb29wID0gODtcblx0XHQgKiBjaG9yZC5sb29wRW5kID0gXCIxbVwiO1xuXHRcdCAqL1xuXHQgICAgVG9uZS5FdmVudCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgb3B0aW9ucyA9IFRvbmUuZGVmYXVsdHMoYXJndW1lbnRzLCBbXG5cdCAgICAgICAgICAgICdjYWxsYmFjaycsXG5cdCAgICAgICAgICAgICd2YWx1ZSdcblx0ICAgICAgICBdLCBUb25lLkV2ZW50KTtcblx0ICAgICAgICBUb25lLmNhbGwodGhpcyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgTG9vcCB2YWx1ZVxuXHRcdFx0ICogIEB0eXBlICB7Qm9vbGVhbnxQb3NpdGl2ZX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fbG9vcCA9IG9wdGlvbnMubG9vcDtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgY2FsbGJhY2sgdG8gaW52b2tlLiBcblx0XHRcdCAqICBAdHlwZSAge0Z1bmN0aW9ufVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5jYWxsYmFjayA9IG9wdGlvbnMuY2FsbGJhY2s7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIHZhbHVlIHdoaWNoIGlzIHBhc3NlZCB0byB0aGVcblx0XHRcdCAqICBjYWxsYmFjayBmdW5jdGlvbi5cblx0XHRcdCAqICBAdHlwZSAgeyp9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMudmFsdWUgPSBvcHRpb25zLnZhbHVlO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFdoZW4gdGhlIG5vdGUgaXMgc2NoZWR1bGVkIHRvIHN0YXJ0LlxuXHRcdFx0ICogIEB0eXBlICB7TnVtYmVyfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9sb29wU3RhcnQgPSB0aGlzLnRvVGlja3Mob3B0aW9ucy5sb29wU3RhcnQpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFdoZW4gdGhlIG5vdGUgaXMgc2NoZWR1bGVkIHRvIHN0YXJ0LlxuXHRcdFx0ICogIEB0eXBlICB7TnVtYmVyfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9sb29wRW5kID0gdGhpcy50b1RpY2tzKG9wdGlvbnMubG9vcEVuZCk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVHJhY2tzIHRoZSBzY2hlZHVsZWQgZXZlbnRzXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuVGltZWxpbmVTdGF0ZX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fc3RhdGUgPSBuZXcgVG9uZS5UaW1lbGluZVN0YXRlKFRvbmUuU3RhdGUuU3RvcHBlZCk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIHBsYXliYWNrIHNwZWVkIG9mIHRoZSBub3RlLiBBIHNwZWVkIG9mIDFcblx0XHRcdCAqICBpcyBubyBjaGFuZ2UuIFxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKiAgQHR5cGUge1Bvc2l0aXZlfVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fcGxheWJhY2tSYXRlID0gMTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBBIGRlbGF5IHRpbWUgZnJvbSB3aGVuIHRoZSBldmVudCBpcyBzY2hlZHVsZWQgdG8gc3RhcnRcblx0XHRcdCAqICBAdHlwZSB7VGlja3N9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX3N0YXJ0T2Zmc2V0ID0gMDtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBwcml2YXRlIGhvbGRlciBvZiBwcm9iYWJpbGl0eSB2YWx1ZVxuXHRcdFx0ICogIEB0eXBlIHtOb3JtYWxSYW5nZX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fcHJvYmFiaWxpdHkgPSBvcHRpb25zLnByb2JhYmlsaXR5O1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHRoZSBhbW91bnQgb2YgdmFyaWF0aW9uIGZyb20gdGhlXG5cdFx0XHQgKiAgZ2l2ZW4gdGltZS4gXG5cdFx0XHQgKiAgQHR5cGUge0Jvb2xlYW58VGltZX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5faHVtYW5pemUgPSBvcHRpb25zLmh1bWFuaXplO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIElmIG11dGUgaXMgdHJ1ZSwgdGhlIGNhbGxiYWNrIHdvbid0IGJlXG5cdFx0XHQgKiAgaW52b2tlZC5cblx0XHRcdCAqICBAdHlwZSB7Qm9vbGVhbn1cblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMubXV0ZSA9IG9wdGlvbnMubXV0ZTtcblx0ICAgICAgICAvL3NldCB0aGUgaW5pdGlhbCB2YWx1ZXNcblx0ICAgICAgICB0aGlzLnBsYXliYWNrUmF0ZSA9IG9wdGlvbnMucGxheWJhY2tSYXRlO1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuRXZlbnQpO1xuXHQgICAgLyoqXG5cdFx0ICogIFRoZSBkZWZhdWx0IHZhbHVlc1xuXHRcdCAqICBAdHlwZSAge09iamVjdH1cblx0XHQgKiAgQGNvbnN0XG5cdFx0ICovXG5cdCAgICBUb25lLkV2ZW50LmRlZmF1bHRzID0ge1xuXHQgICAgICAgICdjYWxsYmFjayc6IFRvbmUubm9PcCxcblx0ICAgICAgICAnbG9vcCc6IGZhbHNlLFxuXHQgICAgICAgICdsb29wRW5kJzogJzFtJyxcblx0ICAgICAgICAnbG9vcFN0YXJ0JzogMCxcblx0ICAgICAgICAncGxheWJhY2tSYXRlJzogMSxcblx0ICAgICAgICAndmFsdWUnOiBudWxsLFxuXHQgICAgICAgICdwcm9iYWJpbGl0eSc6IDEsXG5cdCAgICAgICAgJ211dGUnOiBmYWxzZSxcblx0ICAgICAgICAnaHVtYW5pemUnOiBmYWxzZVxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBSZXNjaGVkdWxlIGFsbCBvZiB0aGUgZXZlbnRzIGFsb25nIHRoZSB0aW1lbGluZVxuXHRcdCAqICB3aXRoIHRoZSB1cGRhdGVkIHZhbHVlcy5cblx0XHQgKiAgQHBhcmFtIHtUaW1lfSBhZnRlciBPbmx5IHJlc2NoZWR1bGVzIGV2ZW50cyBhZnRlciB0aGUgZ2l2ZW4gdGltZS5cblx0XHQgKiAgQHJldHVybiAge1RvbmUuRXZlbnR9ICB0aGlzXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLkV2ZW50LnByb3RvdHlwZS5fcmVzY2hlZHVsZUV2ZW50cyA9IGZ1bmN0aW9uIChhZnRlcikge1xuXHQgICAgICAgIC8vaWYgbm8gYXJndW1lbnQgaXMgZ2l2ZW4sIHNjaGVkdWxlcyBhbGwgb2YgdGhlIGV2ZW50c1xuXHQgICAgICAgIGFmdGVyID0gVG9uZS5kZWZhdWx0QXJnKGFmdGVyLCAtMSk7XG5cdCAgICAgICAgdGhpcy5fc3RhdGUuZm9yRWFjaEZyb20oYWZ0ZXIsIGZ1bmN0aW9uIChldmVudCkge1xuXHQgICAgICAgICAgICB2YXIgZHVyYXRpb247XG5cdCAgICAgICAgICAgIGlmIChldmVudC5zdGF0ZSA9PT0gVG9uZS5TdGF0ZS5TdGFydGVkKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoIVRvbmUuaXNVbmRlZihldmVudC5pZCkpIHtcblx0ICAgICAgICAgICAgICAgICAgICBUb25lLlRyYW5zcG9ydC5jbGVhcihldmVudC5pZCk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB2YXIgc3RhcnRUaWNrID0gZXZlbnQudGltZSArIE1hdGgucm91bmQodGhpcy5zdGFydE9mZnNldCAvIHRoaXMuX3BsYXliYWNrUmF0ZSk7XG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5fbG9vcCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGR1cmF0aW9uID0gSW5maW5pdHk7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKFRvbmUuaXNOdW1iZXIodGhpcy5fbG9vcCkpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZHVyYXRpb24gPSB0aGlzLl9sb29wICogdGhpcy5fZ2V0TG9vcER1cmF0aW9uKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBuZXh0RXZlbnQgPSB0aGlzLl9zdGF0ZS5nZXRBZnRlcihzdGFydFRpY2spO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChuZXh0RXZlbnQgIT09IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZHVyYXRpb24gPSBNYXRoLm1pbihkdXJhdGlvbiwgbmV4dEV2ZW50LnRpbWUgLSBzdGFydFRpY2spO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICBpZiAoZHVyYXRpb24gIT09IEluZmluaXR5KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vc2NoZWR1bGUgYSBzdG9wIHNpbmNlIGl0J3MgZmluaXRlIGR1cmF0aW9uXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YXRlLnNldFN0YXRlQXRUaW1lKFRvbmUuU3RhdGUuU3RvcHBlZCwgc3RhcnRUaWNrICsgZHVyYXRpb24gKyAxKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZHVyYXRpb24gPSBUb25lLlRpbWUoZHVyYXRpb24sICdpJyk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBpbnRlcnZhbCA9IFRvbmUuVGltZSh0aGlzLl9nZXRMb29wRHVyYXRpb24oKSwgJ2knKTtcblx0ICAgICAgICAgICAgICAgICAgICBldmVudC5pZCA9IFRvbmUuVHJhbnNwb3J0LnNjaGVkdWxlUmVwZWF0KHRoaXMuX3RpY2suYmluZCh0aGlzKSwgaW50ZXJ2YWwsIFRvbmUuVHJhbnNwb3J0VGltZShzdGFydFRpY2ssICdpJyksIGR1cmF0aW9uKTtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgZXZlbnQuaWQgPSBUb25lLlRyYW5zcG9ydC5zY2hlZHVsZSh0aGlzLl90aWNrLmJpbmQodGhpcyksIHN0YXJ0VGljayArICdpJyk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9LmJpbmQodGhpcykpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBSZXR1cm5zIHRoZSBwbGF5YmFjayBzdGF0ZSBvZiB0aGUgbm90ZSwgZWl0aGVyIFwic3RhcnRlZFwiIG9yIFwic3RvcHBlZFwiLlxuXHRcdCAqICBAdHlwZSB7U3RyaW5nfVxuXHRcdCAqICBAcmVhZE9ubHlcblx0XHQgKiAgQG1lbWJlck9mIFRvbmUuRXZlbnQjXG5cdFx0ICogIEBuYW1lIHN0YXRlXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5FdmVudC5wcm90b3R5cGUsICdzdGF0ZScsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N0YXRlLmdldFZhbHVlQXRUaW1lKFRvbmUuVHJhbnNwb3J0LnRpY2tzKTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgc3RhcnQgZnJvbSB0aGUgc2NoZWR1bGVkIHN0YXJ0IHRpbWVcblx0XHQgKiAgQHR5cGUge1RpY2tzfVxuXHRcdCAqICBAbWVtYmVyT2YgVG9uZS5FdmVudCNcblx0XHQgKiAgQG5hbWUgc3RhcnRPZmZzZXRcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkV2ZW50LnByb3RvdHlwZSwgJ3N0YXJ0T2Zmc2V0Jywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fc3RhcnRPZmZzZXQ7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChvZmZzZXQpIHtcblx0ICAgICAgICAgICAgdGhpcy5fc3RhcnRPZmZzZXQgPSBvZmZzZXQ7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgVGhlIHByb2JhYmlsaXR5IG9mIHRoZSBub3RlcyBiZWluZyB0cmlnZ2VyZWQuXG5cdFx0ICogIEBtZW1iZXJPZiBUb25lLkV2ZW50I1xuXHRcdCAqICBAdHlwZSB7Tm9ybWFsUmFuZ2V9XG5cdFx0ICogIEBuYW1lIHByb2JhYmlsaXR5XG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5FdmVudC5wcm90b3R5cGUsICdwcm9iYWJpbGl0eScsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Byb2JhYmlsaXR5O1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAocHJvYikge1xuXHQgICAgICAgICAgICB0aGlzLl9wcm9iYWJpbGl0eSA9IHByb2I7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgSWYgc2V0IHRvIHRydWUsIHdpbGwgYXBwbHkgc21hbGwgcmFuZG9tIHZhcmlhdGlvblxuXHRcdCAqICB0byB0aGUgY2FsbGJhY2sgdGltZS4gSWYgdGhlIHZhbHVlIGlzIGdpdmVuIGFzIGEgdGltZSwgaXQgd2lsbCByYW5kb21pemVcblx0XHQgKiAgYnkgdGhhdCBhbW91bnQuXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogZXZlbnQuaHVtYW5pemUgPSB0cnVlO1xuXHRcdCAqICBAdHlwZSB7Qm9vbGVhbnxUaW1lfVxuXHRcdCAqICBAbmFtZSBodW1hbml6ZVxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuRXZlbnQucHJvdG90eXBlLCAnaHVtYW5pemUnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9odW1hbml6ZTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKHZhcmlhdGlvbikge1xuXHQgICAgICAgICAgICB0aGlzLl9odW1hbml6ZSA9IHZhcmlhdGlvbjtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBTdGFydCB0aGUgbm90ZSBhdCB0aGUgZ2l2ZW4gdGltZS4gXG5cdFx0ICogIEBwYXJhbSAge1RpbWVsaW5lUG9zaXRpb259ICB0aW1lICBXaGVuIHRoZSBub3RlIHNob3VsZCBzdGFydC5cblx0XHQgKiAgQHJldHVybiAge1RvbmUuRXZlbnR9ICB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkV2ZW50LnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uICh0aW1lKSB7XG5cdCAgICAgICAgdGltZSA9IHRoaXMudG9UaWNrcyh0aW1lKTtcblx0ICAgICAgICBpZiAodGhpcy5fc3RhdGUuZ2V0VmFsdWVBdFRpbWUodGltZSkgPT09IFRvbmUuU3RhdGUuU3RvcHBlZCkge1xuXHQgICAgICAgICAgICB0aGlzLl9zdGF0ZS5hZGQoe1xuXHQgICAgICAgICAgICAgICAgJ3N0YXRlJzogVG9uZS5TdGF0ZS5TdGFydGVkLFxuXHQgICAgICAgICAgICAgICAgJ3RpbWUnOiB0aW1lLFxuXHQgICAgICAgICAgICAgICAgJ2lkJzogdW5kZWZpbmVkXG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICB0aGlzLl9yZXNjaGVkdWxlRXZlbnRzKHRpbWUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgU3RvcCB0aGUgRXZlbnQgYXQgdGhlIGdpdmVuIHRpbWUuXG5cdFx0ICogIEBwYXJhbSAge1RpbWVsaW5lUG9zaXRpb259ICB0aW1lICBXaGVuIHRoZSBub3RlIHNob3VsZCBzdG9wLlxuXHRcdCAqICBAcmV0dXJuICB7VG9uZS5FdmVudH0gIHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuRXZlbnQucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAodGltZSkge1xuXHQgICAgICAgIHRoaXMuY2FuY2VsKHRpbWUpO1xuXHQgICAgICAgIHRpbWUgPSB0aGlzLnRvVGlja3ModGltZSk7XG5cdCAgICAgICAgaWYgKHRoaXMuX3N0YXRlLmdldFZhbHVlQXRUaW1lKHRpbWUpID09PSBUb25lLlN0YXRlLlN0YXJ0ZWQpIHtcblx0ICAgICAgICAgICAgdGhpcy5fc3RhdGUuc2V0U3RhdGVBdFRpbWUoVG9uZS5TdGF0ZS5TdG9wcGVkLCB0aW1lKTtcblx0ICAgICAgICAgICAgdmFyIHByZXZpb3VzRXZlbnQgPSB0aGlzLl9zdGF0ZS5nZXRCZWZvcmUodGltZSk7XG5cdCAgICAgICAgICAgIHZhciByZXNjaGVkdWxUaW1lID0gdGltZTtcblx0ICAgICAgICAgICAgaWYgKHByZXZpb3VzRXZlbnQgIT09IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgIHJlc2NoZWR1bFRpbWUgPSBwcmV2aW91c0V2ZW50LnRpbWU7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdGhpcy5fcmVzY2hlZHVsZUV2ZW50cyhyZXNjaGVkdWxUaW1lKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIENhbmNlbCBhbGwgc2NoZWR1bGVkIGV2ZW50cyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gdGhlIGdpdmVuIHRpbWVcblx0XHQgKiAgQHBhcmFtICB7VGltZWxpbmVQb3NpdGlvbn0gIFt0aW1lPTBdICBUaGUgdGltZSBhZnRlciB3aGljaCBldmVudHMgd2lsbCBiZSBjYW5jZWwuXG5cdFx0ICogIEByZXR1cm4gIHtUb25lLkV2ZW50fSAgdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5FdmVudC5wcm90b3R5cGUuY2FuY2VsID0gZnVuY3Rpb24gKHRpbWUpIHtcblx0ICAgICAgICB0aW1lID0gVG9uZS5kZWZhdWx0QXJnKHRpbWUsIC1JbmZpbml0eSk7XG5cdCAgICAgICAgdGltZSA9IHRoaXMudG9UaWNrcyh0aW1lKTtcblx0ICAgICAgICB0aGlzLl9zdGF0ZS5mb3JFYWNoRnJvbSh0aW1lLCBmdW5jdGlvbiAoZXZlbnQpIHtcblx0ICAgICAgICAgICAgVG9uZS5UcmFuc3BvcnQuY2xlYXIoZXZlbnQuaWQpO1xuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIHRoaXMuX3N0YXRlLmNhbmNlbCh0aW1lKTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgVGhlIGNhbGxiYWNrIGZ1bmN0aW9uIGludm9rZXIuIEFsc28gXG5cdFx0ICogIGNoZWNrcyBpZiB0aGUgRXZlbnQgaXMgZG9uZSBwbGF5aW5nXG5cdFx0ICogIEBwYXJhbSAge051bWJlcn0gIHRpbWUgIFRoZSB0aW1lIG9mIHRoZSBldmVudCBpbiBzZWNvbmRzXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLkV2ZW50LnByb3RvdHlwZS5fdGljayA9IGZ1bmN0aW9uICh0aW1lKSB7XG5cdCAgICAgICAgaWYgKCF0aGlzLm11dGUgJiYgdGhpcy5fc3RhdGUuZ2V0VmFsdWVBdFRpbWUoVG9uZS5UcmFuc3BvcnQudGlja3MpID09PSBUb25lLlN0YXRlLlN0YXJ0ZWQpIHtcblx0ICAgICAgICAgICAgaWYgKHRoaXMucHJvYmFiaWxpdHkgPCAxICYmIE1hdGgucmFuZG9tKCkgPiB0aGlzLnByb2JhYmlsaXR5KSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgaWYgKHRoaXMuaHVtYW5pemUpIHtcblx0ICAgICAgICAgICAgICAgIHZhciB2YXJpYXRpb24gPSAwLjAyO1xuXHQgICAgICAgICAgICAgICAgaWYgKCFUb25lLmlzQm9vbGVhbih0aGlzLmh1bWFuaXplKSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhcmlhdGlvbiA9IHRoaXMudG9TZWNvbmRzKHRoaXMuaHVtYW5pemUpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgdGltZSArPSAoTWF0aC5yYW5kb20oKSAqIDIgLSAxKSAqIHZhcmlhdGlvbjtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB0aGlzLmNhbGxiYWNrKHRpbWUsIHRoaXMudmFsdWUpO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgR2V0IHRoZSBkdXJhdGlvbiBvZiB0aGUgbG9vcC5cblx0XHQgKiAgQHJldHVybiAge1RpY2tzfVxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5FdmVudC5wcm90b3R5cGUuX2dldExvb3BEdXJhdGlvbiA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICByZXR1cm4gTWF0aC5yb3VuZCgodGhpcy5fbG9vcEVuZCAtIHRoaXMuX2xvb3BTdGFydCkgLyB0aGlzLl9wbGF5YmFja1JhdGUpO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBJZiB0aGUgbm90ZSBzaG91bGQgbG9vcCBvciBub3Rcblx0XHQgKiAgYmV0d2VlbiBUb25lLkV2ZW50Lmxvb3BTdGFydCBhbmQgXG5cdFx0ICogIFRvbmUuRXZlbnQubG9vcEVuZC4gQW4gaW50ZWdlclxuXHRcdCAqICB2YWx1ZSBjb3JyZXNwb25kcyB0byB0aGUgbnVtYmVyIG9mXG5cdFx0ICogIGxvb3BzIHRoZSBFdmVudCBkb2VzIGFmdGVyIGl0IHN0YXJ0cy5cblx0XHQgKiAgQG1lbWJlck9mIFRvbmUuRXZlbnQjXG5cdFx0ICogIEB0eXBlIHtCb29sZWFufFBvc2l0aXZlfVxuXHRcdCAqICBAbmFtZSBsb29wXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5FdmVudC5wcm90b3R5cGUsICdsb29wJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fbG9vcDtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKGxvb3ApIHtcblx0ICAgICAgICAgICAgdGhpcy5fbG9vcCA9IGxvb3A7XG5cdCAgICAgICAgICAgIHRoaXMuX3Jlc2NoZWR1bGVFdmVudHMoKTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqIFx0VGhlIHBsYXliYWNrIHJhdGUgb2YgdGhlIG5vdGUuIERlZmF1bHRzIHRvIDEuXG5cdFx0ICogIEBtZW1iZXJPZiBUb25lLkV2ZW50I1xuXHRcdCAqICBAdHlwZSB7UG9zaXRpdmV9XG5cdFx0ICogIEBuYW1lIHBsYXliYWNrUmF0ZVxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIG5vdGUubG9vcCA9IHRydWU7XG5cdFx0ICogLy9yZXBlYXQgdGhlIG5vdGUgdHdpY2UgYXMgZmFzdFxuXHRcdCAqIG5vdGUucGxheWJhY2tSYXRlID0gMjtcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkV2ZW50LnByb3RvdHlwZSwgJ3BsYXliYWNrUmF0ZScsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BsYXliYWNrUmF0ZTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKHJhdGUpIHtcblx0ICAgICAgICAgICAgdGhpcy5fcGxheWJhY2tSYXRlID0gcmF0ZTtcblx0ICAgICAgICAgICAgdGhpcy5fcmVzY2hlZHVsZUV2ZW50cygpO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIFRoZSBsb29wRW5kIHBvaW50IGlzIHRoZSB0aW1lIHRoZSBldmVudCB3aWxsIGxvb3Bcblx0XHQgKiAgaWYgVG9uZS5FdmVudC5sb29wIGlzIHRydWUuXG5cdFx0ICogIEBtZW1iZXJPZiBUb25lLkV2ZW50I1xuXHRcdCAqICBAdHlwZSB7VHJhbnNwb3J0VGltZX1cblx0XHQgKiAgQG5hbWUgbG9vcEVuZFxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuRXZlbnQucHJvdG90eXBlLCAnbG9vcEVuZCcsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIFRvbmUuVHJhbnNwb3J0VGltZSh0aGlzLl9sb29wRW5kLCAnaScpLnRvTm90YXRpb24oKTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKGxvb3BFbmQpIHtcblx0ICAgICAgICAgICAgdGhpcy5fbG9vcEVuZCA9IHRoaXMudG9UaWNrcyhsb29wRW5kKTtcblx0ICAgICAgICAgICAgaWYgKHRoaXMuX2xvb3ApIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX3Jlc2NoZWR1bGVFdmVudHMoKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIFRoZSB0aW1lIHdoZW4gdGhlIGxvb3Agc2hvdWxkIHN0YXJ0LiBcblx0XHQgKiAgQG1lbWJlck9mIFRvbmUuRXZlbnQjXG5cdFx0ICogIEB0eXBlIHtUcmFuc3BvcnRUaW1lfVxuXHRcdCAqICBAbmFtZSBsb29wU3RhcnRcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkV2ZW50LnByb3RvdHlwZSwgJ2xvb3BTdGFydCcsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIFRvbmUuVHJhbnNwb3J0VGltZSh0aGlzLl9sb29wU3RhcnQsICdpJykudG9Ob3RhdGlvbigpO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAobG9vcFN0YXJ0KSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2xvb3BTdGFydCA9IHRoaXMudG9UaWNrcyhsb29wU3RhcnQpO1xuXHQgICAgICAgICAgICBpZiAodGhpcy5fbG9vcCkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fcmVzY2hlZHVsZUV2ZW50cygpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgVGhlIGN1cnJlbnQgcHJvZ3Jlc3Mgb2YgdGhlIGxvb3AgaW50ZXJ2YWwuXG5cdFx0ICogIFJldHVybnMgMCBpZiB0aGUgZXZlbnQgaXMgbm90IHN0YXJ0ZWQgeWV0IG9yXG5cdFx0ICogIGl0IGlzIG5vdCBzZXQgdG8gbG9vcC5cblx0XHQgKiAgQG1lbWJlck9mIFRvbmUuRXZlbnQjXG5cdFx0ICogIEB0eXBlIHtOb3JtYWxSYW5nZX1cblx0XHQgKiAgQG5hbWUgcHJvZ3Jlc3Ncblx0XHQgKiAgQHJlYWRPbmx5XG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5FdmVudC5wcm90b3R5cGUsICdwcm9ncmVzcycsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgaWYgKHRoaXMuX2xvb3ApIHtcblx0ICAgICAgICAgICAgICAgIHZhciB0aWNrcyA9IFRvbmUuVHJhbnNwb3J0LnRpY2tzO1xuXHQgICAgICAgICAgICAgICAgdmFyIGxhc3RFdmVudCA9IHRoaXMuX3N0YXRlLmdldCh0aWNrcyk7XG5cdCAgICAgICAgICAgICAgICBpZiAobGFzdEV2ZW50ICE9PSBudWxsICYmIGxhc3RFdmVudC5zdGF0ZSA9PT0gVG9uZS5TdGF0ZS5TdGFydGVkKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGxvb3BEdXJhdGlvbiA9IHRoaXMuX2dldExvb3BEdXJhdGlvbigpO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBwcm9ncmVzcyA9ICh0aWNrcyAtIGxhc3RFdmVudC50aW1lKSAlIGxvb3BEdXJhdGlvbjtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvZ3Jlc3MgLyBsb29wRHVyYXRpb247XG5cdCAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiAwO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIDA7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBDbGVhbiB1cFxuXHRcdCAqICBAcmV0dXJuICB7VG9uZS5FdmVudH0gIHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuRXZlbnQucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdGhpcy5jYW5jZWwoKTtcblx0ICAgICAgICB0aGlzLl9zdGF0ZS5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fc3RhdGUgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuY2FsbGJhY2sgPSBudWxsO1xuXHQgICAgICAgIHRoaXMudmFsdWUgPSBudWxsO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLkV2ZW50O1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzIFRvbmUuTG9vcCBjcmVhdGVzIGEgbG9vcGVkIGNhbGxiYWNrIGF0IHRoZSBcblx0XHQgKiAgICAgICAgIHNwZWNpZmllZCBpbnRlcnZhbC4gVGhlIGNhbGxiYWNrIGNhbiBiZSBcblx0XHQgKiAgICAgICAgIHN0YXJ0ZWQsIHN0b3BwZWQgYW5kIHNjaGVkdWxlZCBhbG9uZ1xuXHRcdCAqICAgICAgICAgdGhlIFRyYW5zcG9ydCdzIHRpbWVsaW5lLiBcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiB2YXIgbG9vcCA9IG5ldyBUb25lLkxvb3AoZnVuY3Rpb24odGltZSl7XG5cdFx0ICogXHQvL3RyaWdnZXJlZCBldmVyeSBlaWdodGggbm90ZS4gXG5cdFx0ICogXHRjb25zb2xlLmxvZyh0aW1lKTtcblx0XHQgKiB9LCBcIjhuXCIpLnN0YXJ0KDApO1xuXHRcdCAqIFRvbmUuVHJhbnNwb3J0LnN0YXJ0KCk7XG5cdFx0ICogIEBleHRlbmRzIHtUb25lfVxuXHRcdCAqICBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgY2FsbGJhY2sgdG8gaW52b2tlIHdpdGggdGhlIGV2ZW50LlxuXHRcdCAqICBAcGFyYW0ge1RpbWV9IGludGVydmFsIFRoZSB0aW1lIGJldHdlZW4gc3VjY2Vzc2l2ZSBjYWxsYmFjayBjYWxscy4gXG5cdFx0ICovXG5cdCAgICBUb25lLkxvb3AgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIG9wdGlvbnMgPSBUb25lLmRlZmF1bHRzKGFyZ3VtZW50cywgW1xuXHQgICAgICAgICAgICAnY2FsbGJhY2snLFxuXHQgICAgICAgICAgICAnaW50ZXJ2YWwnXG5cdCAgICAgICAgXSwgVG9uZS5Mb29wKTtcblx0ICAgICAgICBUb25lLmNhbGwodGhpcyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGV2ZW50IHdoaWNoIHByb2R1Y2VzIHRoZSBjYWxsYmFja3Ncblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2V2ZW50ID0gbmV3IFRvbmUuRXZlbnQoe1xuXHQgICAgICAgICAgICAnY2FsbGJhY2snOiB0aGlzLl90aWNrLmJpbmQodGhpcyksXG5cdCAgICAgICAgICAgICdsb29wJzogdHJ1ZSxcblx0ICAgICAgICAgICAgJ2xvb3BFbmQnOiBvcHRpb25zLmludGVydmFsLFxuXHQgICAgICAgICAgICAncGxheWJhY2tSYXRlJzogb3B0aW9ucy5wbGF5YmFja1JhdGUsXG5cdCAgICAgICAgICAgICdwcm9iYWJpbGl0eSc6IG9wdGlvbnMucHJvYmFiaWxpdHlcblx0ICAgICAgICB9KTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgY2FsbGJhY2sgdG8gaW52b2tlIHdpdGggdGhlIG5leHQgZXZlbnQgaW4gdGhlIHBhdHRlcm5cblx0XHRcdCAqICBAdHlwZSB7RnVuY3Rpb259XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmNhbGxiYWNrID0gb3B0aW9ucy5jYWxsYmFjaztcblx0ICAgICAgICAvL3NldCB0aGUgaXRlcmF0aW9uc1xuXHQgICAgICAgIHRoaXMuaXRlcmF0aW9ucyA9IG9wdGlvbnMuaXRlcmF0aW9ucztcblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLkxvb3ApO1xuXHQgICAgLyoqXG5cdFx0ICogIFRoZSBkZWZhdWx0c1xuXHRcdCAqICBAY29uc3Rcblx0XHQgKiAgQHR5cGUgIHtPYmplY3R9XG5cdFx0ICovXG5cdCAgICBUb25lLkxvb3AuZGVmYXVsdHMgPSB7XG5cdCAgICAgICAgJ2ludGVydmFsJzogJzRuJyxcblx0ICAgICAgICAnY2FsbGJhY2snOiBUb25lLm5vT3AsXG5cdCAgICAgICAgJ3BsYXliYWNrUmF0ZSc6IDEsXG5cdCAgICAgICAgJ2l0ZXJhdGlvbnMnOiBJbmZpbml0eSxcblx0ICAgICAgICAncHJvYmFiaWxpdHknOiB0cnVlLFxuXHQgICAgICAgICdtdXRlJzogZmFsc2Vcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgU3RhcnQgdGhlIGxvb3AgYXQgdGhlIHNwZWNpZmllZCB0aW1lIGFsb25nIHRoZSBUcmFuc3BvcnQnc1xuXHRcdCAqICB0aW1lbGluZS5cblx0XHQgKiAgQHBhcmFtICB7VGltZWxpbmVQb3NpdGlvbj19ICB0aW1lICBXaGVuIHRvIHN0YXJ0IHRoZSBMb29wLlxuXHRcdCAqICBAcmV0dXJuICB7VG9uZS5Mb29wfSAgdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5Mb29wLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uICh0aW1lKSB7XG5cdCAgICAgICAgdGhpcy5fZXZlbnQuc3RhcnQodGltZSk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFN0b3AgdGhlIGxvb3AgYXQgdGhlIGdpdmVuIHRpbWUuXG5cdFx0ICogIEBwYXJhbSAge1RpbWVsaW5lUG9zaXRpb249fSAgdGltZSAgV2hlbiB0byBzdG9wIHRoZSBBcnBlZ2dpb1xuXHRcdCAqICBAcmV0dXJuICB7VG9uZS5Mb29wfSAgdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5Mb29wLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKHRpbWUpIHtcblx0ICAgICAgICB0aGlzLl9ldmVudC5zdG9wKHRpbWUpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBDYW5jZWwgYWxsIHNjaGVkdWxlZCBldmVudHMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIHRoZSBnaXZlbiB0aW1lXG5cdFx0ICogIEBwYXJhbSAge1RpbWVsaW5lUG9zaXRpb259ICBbdGltZT0wXSAgVGhlIHRpbWUgYWZ0ZXIgd2hpY2ggZXZlbnRzIHdpbGwgYmUgY2FuY2VsLlxuXHRcdCAqICBAcmV0dXJuICB7VG9uZS5Mb29wfSAgdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5Mb29wLnByb3RvdHlwZS5jYW5jZWwgPSBmdW5jdGlvbiAodGltZSkge1xuXHQgICAgICAgIHRoaXMuX2V2ZW50LmNhbmNlbCh0aW1lKTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgSW50ZXJuYWwgZnVuY3Rpb24gY2FsbGVkIHdoZW4gdGhlIG5vdGVzIHNob3VsZCBiZSBjYWxsZWRcblx0XHQgKiAgQHBhcmFtICB7TnVtYmVyfSAgdGltZSAgVGhlIHRpbWUgdGhlIGV2ZW50IG9jY3Vyc1xuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5Mb29wLnByb3RvdHlwZS5fdGljayA9IGZ1bmN0aW9uICh0aW1lKSB7XG5cdCAgICAgICAgdGhpcy5jYWxsYmFjayh0aW1lKTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgVGhlIHN0YXRlIG9mIHRoZSBMb29wLCBlaXRoZXIgc3RhcnRlZCBvciBzdG9wcGVkLlxuXHRcdCAqICBAbWVtYmVyT2YgVG9uZS5Mb29wI1xuXHRcdCAqICBAdHlwZSB7U3RyaW5nfVxuXHRcdCAqICBAbmFtZSBzdGF0ZVxuXHRcdCAqICBAcmVhZE9ubHlcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkxvb3AucHJvdG90eXBlLCAnc3RhdGUnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9ldmVudC5zdGF0ZTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgcHJvZ3Jlc3Mgb2YgdGhlIGxvb3AgYXMgYSB2YWx1ZSBiZXR3ZWVuIDAtMS4gMCwgd2hlblxuXHRcdCAqICB0aGUgbG9vcCBpcyBzdG9wcGVkIG9yIGRvbmUgaXRlcmF0aW5nLiBcblx0XHQgKiAgQG1lbWJlck9mIFRvbmUuTG9vcCNcblx0XHQgKiAgQHR5cGUge05vcm1hbFJhbmdlfVxuXHRcdCAqICBAbmFtZSBwcm9ncmVzc1xuXHRcdCAqICBAcmVhZE9ubHlcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkxvb3AucHJvdG90eXBlLCAncHJvZ3Jlc3MnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9ldmVudC5wcm9ncmVzcztcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgdGltZSBiZXR3ZWVuIHN1Y2Nlc3NpdmUgY2FsbGJhY2tzLiBcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiBsb29wLmludGVydmFsID0gXCI4blwiOyAvL2xvb3AgZXZlcnkgOG5cblx0XHQgKiAgQG1lbWJlck9mIFRvbmUuTG9vcCNcblx0XHQgKiAgQHR5cGUge1RpbWV9XG5cdFx0ICogIEBuYW1lIGludGVydmFsXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5Mb29wLnByb3RvdHlwZSwgJ2ludGVydmFsJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fZXZlbnQubG9vcEVuZDtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKGludGVydmFsKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2V2ZW50Lmxvb3BFbmQgPSBpbnRlcnZhbDtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgcGxheWJhY2sgcmF0ZSBvZiB0aGUgbG9vcC4gVGhlIG5vcm1hbCBwbGF5YmFjayByYXRlIGlzIDEgKG5vIGNoYW5nZSkuIFxuXHRcdCAqICBBIGBwbGF5YmFja1JhdGVgIG9mIDIgd291bGQgYmUgdHdpY2UgYXMgZmFzdC4gXG5cdFx0ICogIEBtZW1iZXJPZiBUb25lLkxvb3AjXG5cdFx0ICogIEB0eXBlIHtUaW1lfVxuXHRcdCAqICBAbmFtZSBwbGF5YmFja1JhdGVcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkxvb3AucHJvdG90eXBlLCAncGxheWJhY2tSYXRlJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fZXZlbnQucGxheWJhY2tSYXRlO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAocmF0ZSkge1xuXHQgICAgICAgICAgICB0aGlzLl9ldmVudC5wbGF5YmFja1JhdGUgPSByYXRlO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIFJhbmRvbSB2YXJpYXRpb24gKy8tMC4wMXMgdG8gdGhlIHNjaGVkdWxlZCB0aW1lLiBcblx0XHQgKiAgT3IgZ2l2ZSBpdCBhIHRpbWUgdmFsdWUgd2hpY2ggaXQgd2lsbCByYW5kb21pemUgYnkuXG5cdFx0ICogIEB0eXBlIHtCb29sZWFufFRpbWV9XG5cdFx0ICogIEBtZW1iZXJPZiBUb25lLkxvb3AjXG5cdFx0ICogIEBuYW1lIGh1bWFuaXplXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5Mb29wLnByb3RvdHlwZSwgJ2h1bWFuaXplJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fZXZlbnQuaHVtYW5pemU7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YXJpYXRpb24pIHtcblx0ICAgICAgICAgICAgdGhpcy5fZXZlbnQuaHVtYW5pemUgPSB2YXJpYXRpb247XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgVGhlIHByb2JhYmx5IG9mIHRoZSBjYWxsYmFjayBiZWluZyBpbnZva2VkLlxuXHRcdCAqICBAbWVtYmVyT2YgVG9uZS5Mb29wI1xuXHRcdCAqICBAdHlwZSB7Tm9ybWFsUmFuZ2V9XG5cdFx0ICogIEBuYW1lIHByb2JhYmlsaXR5XG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5Mb29wLnByb3RvdHlwZSwgJ3Byb2JhYmlsaXR5Jywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fZXZlbnQucHJvYmFiaWxpdHk7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChwcm9iKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2V2ZW50LnByb2JhYmlsaXR5ID0gcHJvYjtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBNdXRpbmcgdGhlIExvb3AgbWVhbnMgdGhhdCBubyBjYWxsYmFja3MgYXJlIGludm9rZWQuXG5cdFx0ICogIEBtZW1iZXJPZiBUb25lLkxvb3AjXG5cdFx0ICogIEB0eXBlIHtCb29sZWFufVxuXHRcdCAqICBAbmFtZSBtdXRlXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5Mb29wLnByb3RvdHlwZSwgJ211dGUnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9ldmVudC5tdXRlO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAobXV0ZSkge1xuXHQgICAgICAgICAgICB0aGlzLl9ldmVudC5tdXRlID0gbXV0ZTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgbnVtYmVyIG9mIGl0ZXJhdGlvbnMgb2YgdGhlIGxvb3AuIFRoZSBkZWZhdWx0XG5cdFx0ICogIHZhbHVlIGlzIEluZmluaXR5IChsb29wIGZvcmV2ZXIpLlxuXHRcdCAqICBAbWVtYmVyT2YgVG9uZS5Mb29wI1xuXHRcdCAqICBAdHlwZSB7UG9zaXRpdmV9XG5cdFx0ICogIEBuYW1lIGl0ZXJhdGlvbnNcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkxvb3AucHJvdG90eXBlLCAnaXRlcmF0aW9ucycsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgaWYgKHRoaXMuX2V2ZW50Lmxvb3AgPT09IHRydWUpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBJbmZpbml0eTtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9ldmVudC5sb29wO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChpdGVycykge1xuXHQgICAgICAgICAgICBpZiAoaXRlcnMgPT09IEluZmluaXR5KSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9ldmVudC5sb29wID0gdHJ1ZTtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX2V2ZW50Lmxvb3AgPSBpdGVycztcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIENsZWFuIHVwXG5cdFx0ICogIEByZXR1cm4gIHtUb25lLkxvb3B9ICB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkxvb3AucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdGhpcy5fZXZlbnQuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX2V2ZW50ID0gbnVsbDtcblx0ICAgICAgICB0aGlzLmNhbGxiYWNrID0gbnVsbDtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVG9uZS5Mb29wO1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgVG9uZS5QYXJ0IGlzIGEgY29sbGVjdGlvbiBUb25lLkV2ZW50cyB3aGljaCBjYW4gYmVcblx0XHQgKiAgICAgICAgIHN0YXJ0ZWQvc3RvcHBlZCBhbmQgbG9vcGVkIGFzIGEgc2luZ2xlIHVuaXQuXG5cdFx0ICpcblx0XHQgKiAgQGV4dGVuZHMge1RvbmUuRXZlbnR9XG5cdFx0ICogIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBjYWxsYmFjayB0byBpbnZva2Ugb24gZWFjaCBldmVudFxuXHRcdCAqICBAcGFyYW0ge0FycmF5fSBldmVudHMgdGhlIGFycmF5IG9mIGV2ZW50c1xuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIHZhciBwYXJ0ID0gbmV3IFRvbmUuUGFydChmdW5jdGlvbih0aW1lLCBub3RlKXtcblx0XHQgKiBcdC8vdGhlIG5vdGVzIGdpdmVuIGFzIHRoZSBzZWNvbmQgZWxlbWVudCBpbiB0aGUgYXJyYXlcblx0XHQgKiBcdC8vd2lsbCBiZSBwYXNzZWQgaW4gYXMgdGhlIHNlY29uZCBhcmd1bWVudFxuXHRcdCAqIFx0c3ludGgudHJpZ2dlckF0dGFja1JlbGVhc2Uobm90ZSwgXCI4blwiLCB0aW1lKTtcblx0XHQgKiB9LCBbWzAsIFwiQzJcIl0sIFtcIjA6MlwiLCBcIkMzXCJdLCBbXCIwOjM6MlwiLCBcIkcyXCJdXSk7XG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogLy91c2UgYW4gYXJyYXkgb2Ygb2JqZWN0cyBhcyBsb25nIGFzIHRoZSBvYmplY3QgaGFzIGEgXCJ0aW1lXCIgYXR0cmlidXRlXG5cdFx0ICogdmFyIHBhcnQgPSBuZXcgVG9uZS5QYXJ0KGZ1bmN0aW9uKHRpbWUsIHZhbHVlKXtcblx0XHQgKiBcdC8vdGhlIHZhbHVlIGlzIGFuIG9iamVjdCB3aGljaCBjb250YWlucyBib3RoIHRoZSBub3RlIGFuZCB0aGUgdmVsb2NpdHlcblx0XHQgKiBcdHN5bnRoLnRyaWdnZXJBdHRhY2tSZWxlYXNlKHZhbHVlLm5vdGUsIFwiOG5cIiwgdGltZSwgdmFsdWUudmVsb2NpdHkpO1xuXHRcdCAqIH0sIFt7XCJ0aW1lXCIgOiAwLCBcIm5vdGVcIiA6IFwiQzNcIiwgXCJ2ZWxvY2l0eVwiOiAwLjl9LCBcblx0XHQgKiBcdCAgIHtcInRpbWVcIiA6IFwiMDoyXCIsIFwibm90ZVwiIDogXCJDNFwiLCBcInZlbG9jaXR5XCI6IDAuNX1cblx0XHQgKiBdKS5zdGFydCgwKTtcblx0XHQgKi9cblx0ICAgIFRvbmUuUGFydCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgb3B0aW9ucyA9IFRvbmUuZGVmYXVsdHMoYXJndW1lbnRzLCBbXG5cdCAgICAgICAgICAgICdjYWxsYmFjaycsXG5cdCAgICAgICAgICAgICdldmVudHMnXG5cdCAgICAgICAgXSwgVG9uZS5QYXJ0KTtcblx0ICAgICAgICBUb25lLkV2ZW50LmNhbGwodGhpcywgb3B0aW9ucyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgQW4gYXJyYXkgb2YgT2JqZWN0cy4gXG5cdFx0XHQgKiAgQHR5cGUgIHtBcnJheX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fZXZlbnRzID0gW107XG5cdCAgICAgICAgLy9hZGQgdGhlIGV2ZW50c1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3B0aW9ucy5ldmVudHMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob3B0aW9ucy5ldmVudHNbaV0pKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLmFkZChvcHRpb25zLmV2ZW50c1tpXVswXSwgb3B0aW9ucy5ldmVudHNbaV1bMV0pO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5hZGQob3B0aW9ucy5ldmVudHNbaV0pO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuUGFydCwgVG9uZS5FdmVudCk7XG5cdCAgICAvKipcblx0XHQgKiAgVGhlIGRlZmF1bHQgdmFsdWVzXG5cdFx0ICogIEB0eXBlICB7T2JqZWN0fVxuXHRcdCAqICBAY29uc3Rcblx0XHQgKi9cblx0ICAgIFRvbmUuUGFydC5kZWZhdWx0cyA9IHtcblx0ICAgICAgICAnY2FsbGJhY2snOiBUb25lLm5vT3AsXG5cdCAgICAgICAgJ2xvb3AnOiBmYWxzZSxcblx0ICAgICAgICAnbG9vcEVuZCc6ICcxbScsXG5cdCAgICAgICAgJ2xvb3BTdGFydCc6IDAsXG5cdCAgICAgICAgJ3BsYXliYWNrUmF0ZSc6IDEsXG5cdCAgICAgICAgJ3Byb2JhYmlsaXR5JzogMSxcblx0ICAgICAgICAnaHVtYW5pemUnOiBmYWxzZSxcblx0ICAgICAgICAnbXV0ZSc6IGZhbHNlLFxuXHQgICAgICAgICdldmVudHMnOiBbXVxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBTdGFydCB0aGUgcGFydCBhdCB0aGUgZ2l2ZW4gdGltZS4gXG5cdFx0ICogIEBwYXJhbSAge1RyYW5zcG9ydFRpbWV9ICB0aW1lICAgIFdoZW4gdG8gc3RhcnQgdGhlIHBhcnQuXG5cdFx0ICogIEBwYXJhbSAge1RpbWU9fSAgb2Zmc2V0ICBUaGUgb2Zmc2V0IGZyb20gdGhlIHN0YXJ0IG9mIHRoZSBwYXJ0XG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICB0byBiZWdpbiBwbGF5aW5nIGF0LlxuXHRcdCAqICBAcmV0dXJuICB7VG9uZS5QYXJ0fSAgdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5QYXJ0LnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uICh0aW1lLCBvZmZzZXQpIHtcblx0ICAgICAgICB2YXIgdGlja3MgPSB0aGlzLnRvVGlja3ModGltZSk7XG5cdCAgICAgICAgaWYgKHRoaXMuX3N0YXRlLmdldFZhbHVlQXRUaW1lKHRpY2tzKSAhPT0gVG9uZS5TdGF0ZS5TdGFydGVkKSB7XG5cdCAgICAgICAgICAgIGlmICh0aGlzLl9sb29wKSB7XG5cdCAgICAgICAgICAgICAgICBvZmZzZXQgPSBUb25lLmRlZmF1bHRBcmcob2Zmc2V0LCB0aGlzLl9sb29wU3RhcnQpO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgb2Zmc2V0ID0gVG9uZS5kZWZhdWx0QXJnKG9mZnNldCwgMCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgb2Zmc2V0ID0gdGhpcy50b1RpY2tzKG9mZnNldCk7XG5cdCAgICAgICAgICAgIHRoaXMuX3N0YXRlLmFkZCh7XG5cdCAgICAgICAgICAgICAgICAnc3RhdGUnOiBUb25lLlN0YXRlLlN0YXJ0ZWQsXG5cdCAgICAgICAgICAgICAgICAndGltZSc6IHRpY2tzLFxuXHQgICAgICAgICAgICAgICAgJ29mZnNldCc6IG9mZnNldFxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgdGhpcy5fZm9yRWFjaChmdW5jdGlvbiAoZXZlbnQpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0Tm90ZShldmVudCwgdGlja3MsIG9mZnNldCk7XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgU3RhcnQgdGhlIGV2ZW50IGluIHRoZSBnaXZlbiBldmVudCBhdCB0aGUgY29ycmVjdCB0aW1lIGdpdmVuXG5cdFx0ICogIHRoZSB0aWNrcyBhbmQgb2Zmc2V0IGFuZCBsb29waW5nLlxuXHRcdCAqICBAcGFyYW0gIHtUb25lLkV2ZW50fSAgZXZlbnQgXG5cdFx0ICogIEBwYXJhbSAge1RpY2tzfSAgdGlja3Ncblx0XHQgKiAgQHBhcmFtICB7VGlja3N9ICBvZmZzZXRcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuUGFydC5wcm90b3R5cGUuX3N0YXJ0Tm90ZSA9IGZ1bmN0aW9uIChldmVudCwgdGlja3MsIG9mZnNldCkge1xuXHQgICAgICAgIHRpY2tzIC09IG9mZnNldDtcblx0ICAgICAgICBpZiAodGhpcy5fbG9vcCkge1xuXHQgICAgICAgICAgICBpZiAoZXZlbnQuc3RhcnRPZmZzZXQgPj0gdGhpcy5fbG9vcFN0YXJ0ICYmIGV2ZW50LnN0YXJ0T2Zmc2V0IDwgdGhpcy5fbG9vcEVuZCkge1xuXHQgICAgICAgICAgICAgICAgaWYgKGV2ZW50LnN0YXJ0T2Zmc2V0IDwgb2Zmc2V0KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgLy9zdGFydCBpdCBvbiB0aGUgbmV4dCBsb29wXG5cdCAgICAgICAgICAgICAgICAgICAgdGlja3MgKz0gdGhpcy5fZ2V0TG9vcER1cmF0aW9uKCk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBldmVudC5zdGFydChUb25lLlRyYW5zcG9ydFRpbWUodGlja3MsICdpJykpO1xuXHQgICAgICAgICAgICB9IGVsc2UgaWYgKGV2ZW50LnN0YXJ0T2Zmc2V0IDwgdGhpcy5fbG9vcFN0YXJ0ICYmIGV2ZW50LnN0YXJ0T2Zmc2V0ID49IG9mZnNldCkge1xuXHQgICAgICAgICAgICAgICAgZXZlbnQubG9vcCA9IGZhbHNlO1xuXHQgICAgICAgICAgICAgICAgZXZlbnQuc3RhcnQoVG9uZS5UcmFuc3BvcnRUaW1lKHRpY2tzLCAnaScpKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIGlmIChldmVudC5zdGFydE9mZnNldCA+PSBvZmZzZXQpIHtcblx0ICAgICAgICAgICAgICAgIGV2ZW50LnN0YXJ0KFRvbmUuVHJhbnNwb3J0VGltZSh0aWNrcywgJ2knKSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFRoZSBzdGFydCBmcm9tIHRoZSBzY2hlZHVsZWQgc3RhcnQgdGltZVxuXHRcdCAqICBAdHlwZSB7VGlja3N9XG5cdFx0ICogIEBtZW1iZXJPZiBUb25lLlBhcnQjXG5cdFx0ICogIEBuYW1lIHN0YXJ0T2Zmc2V0XG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5QYXJ0LnByb3RvdHlwZSwgJ3N0YXJ0T2Zmc2V0Jywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fc3RhcnRPZmZzZXQ7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChvZmZzZXQpIHtcblx0ICAgICAgICAgICAgdGhpcy5fc3RhcnRPZmZzZXQgPSBvZmZzZXQ7XG5cdCAgICAgICAgICAgIHRoaXMuX2ZvckVhY2goZnVuY3Rpb24gKGV2ZW50KSB7XG5cdCAgICAgICAgICAgICAgICBldmVudC5zdGFydE9mZnNldCArPSB0aGlzLl9zdGFydE9mZnNldDtcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgU3RvcCB0aGUgcGFydCBhdCB0aGUgZ2l2ZW4gdGltZS5cblx0XHQgKiAgQHBhcmFtICB7VGltZWxpbmVQb3NpdGlvbn0gIHRpbWUgIFdoZW4gdG8gc3RvcCB0aGUgcGFydC5cblx0XHQgKiAgQHJldHVybiAge1RvbmUuUGFydH0gIHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuUGFydC5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICh0aW1lKSB7XG5cdCAgICAgICAgdmFyIHRpY2tzID0gdGhpcy50b1RpY2tzKHRpbWUpO1xuXHQgICAgICAgIHRoaXMuX3N0YXRlLmNhbmNlbCh0aWNrcyk7XG5cdCAgICAgICAgdGhpcy5fc3RhdGUuc2V0U3RhdGVBdFRpbWUoVG9uZS5TdGF0ZS5TdG9wcGVkLCB0aWNrcyk7XG5cdCAgICAgICAgdGhpcy5fZm9yRWFjaChmdW5jdGlvbiAoZXZlbnQpIHtcblx0ICAgICAgICAgICAgZXZlbnQuc3RvcCh0aW1lKTtcblx0ICAgICAgICB9KTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgR2V0L1NldCBhbiBFdmVudCdzIHZhbHVlIGF0IHRoZSBnaXZlbiB0aW1lLiBcblx0XHQgKiAgSWYgYSB2YWx1ZSBpcyBwYXNzZWQgaW4gYW5kIG5vIGV2ZW50IGV4aXN0cyBhdFxuXHRcdCAqICB0aGUgZ2l2ZW4gdGltZSwgb25lIHdpbGwgYmUgY3JlYXRlZCB3aXRoIHRoYXQgdmFsdWUuIFxuXHRcdCAqICBJZiB0d28gZXZlbnRzIGFyZSBhdCB0aGUgc2FtZSB0aW1lLCB0aGUgZmlyc3Qgb25lIHdpbGxcblx0XHQgKiAgYmUgcmV0dXJuZWQuXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogcGFydC5hdChcIjFtXCIpOyAvL3JldHVybnMgdGhlIHBhcnQgYXQgdGhlIGZpcnN0IG1lYXN1cmVcblx0XHQgKlxuXHRcdCAqIHBhcnQuYXQoXCIybVwiLCBcIkMyXCIpOyAvL3NldCB0aGUgdmFsdWUgYXQgXCIybVwiIHRvIEMyLiBcblx0XHQgKiAvL2lmIGFuIGV2ZW50IGRpZG4ndCBleGlzdCBhdCB0aGF0IHRpbWUsIGl0IHdpbGwgYmUgY3JlYXRlZC5cblx0XHQgKiAgQHBhcmFtIHtUcmFuc3BvcnRUaW1lfSB0aW1lIFRoZSB0aW1lIG9mIHRoZSBldmVudCB0byBnZXQgb3Igc2V0LlxuXHRcdCAqICBAcGFyYW0geyo9fSB2YWx1ZSBJZiBhIHZhbHVlIGlzIHBhc3NlZCBpbiwgdGhlIHZhbHVlIG9mIHRoZVxuXHRcdCAqICAgICAgICAgICAgICAgICAgICBldmVudCBhdCB0aGUgZ2l2ZW4gdGltZSB3aWxsIGJlIHNldCB0byBpdC5cblx0XHQgKiAgQHJldHVybiB7VG9uZS5FdmVudH0gdGhlIGV2ZW50IGF0IHRoZSB0aW1lXG5cdFx0ICovXG5cdCAgICBUb25lLlBhcnQucHJvdG90eXBlLmF0ID0gZnVuY3Rpb24gKHRpbWUsIHZhbHVlKSB7XG5cdCAgICAgICAgdGltZSA9IFRvbmUuVHJhbnNwb3J0VGltZSh0aW1lKTtcblx0ICAgICAgICB2YXIgdGlja1RpbWUgPSBUb25lLlRpbWUoMSwgJ2knKS50b1NlY29uZHMoKTtcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2V2ZW50cy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICB2YXIgZXZlbnQgPSB0aGlzLl9ldmVudHNbaV07XG5cdCAgICAgICAgICAgIGlmIChNYXRoLmFicyh0aW1lLnRvVGlja3MoKSAtIGV2ZW50LnN0YXJ0T2Zmc2V0KSA8IHRpY2tUaW1lKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoIVRvbmUuaXNVbmRlZih2YWx1ZSkpIHtcblx0ICAgICAgICAgICAgICAgICAgICBldmVudC52YWx1ZSA9IHZhbHVlO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGV2ZW50O1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8vaWYgdGhlcmUgd2FzIG5vIGV2ZW50IGF0IHRoYXQgdGltZSwgY3JlYXRlIG9uZVxuXHQgICAgICAgIGlmICghVG9uZS5pc1VuZGVmKHZhbHVlKSkge1xuXHQgICAgICAgICAgICB0aGlzLmFkZCh0aW1lLCB2YWx1ZSk7XG5cdCAgICAgICAgICAgIC8vcmV0dXJuIHRoZSBuZXcgZXZlbnRcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2V2ZW50c1t0aGlzLl9ldmVudHMubGVuZ3RoIC0gMV07XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgcmV0dXJuIG51bGw7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBBZGQgYSBhbiBldmVudCB0byB0aGUgcGFydC4gXG5cdFx0ICogIEBwYXJhbSB7VGltZX0gdGltZSBUaGUgdGltZSB0aGUgbm90ZSBzaG91bGQgc3RhcnQuXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgSWYgYW4gb2JqZWN0IGlzIHBhc3NlZCBpbiwgaXQgc2hvdWxkXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgaGF2ZSBhICd0aW1lJyBhdHRyaWJ1dGUgYW5kIHRoZSByZXN0XG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgb2YgdGhlIG9iamVjdCB3aWxsIGJlIHVzZWQgYXMgdGhlICd2YWx1ZScuXG5cdFx0ICogIEBwYXJhbSAge1RvbmUuRXZlbnR8Kn0gIHZhbHVlIFxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5QYXJ0fSB0aGlzXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogcGFydC5hZGQoXCIxbVwiLCBcIkMjKzExXCIpO1xuXHRcdCAqL1xuXHQgICAgVG9uZS5QYXJ0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAodGltZSwgdmFsdWUpIHtcblx0ICAgICAgICAvL2V4dHJhY3QgdGhlIHBhcmFtZXRlcnNcblx0ICAgICAgICBpZiAodGltZS5oYXNPd25Qcm9wZXJ0eSgndGltZScpKSB7XG5cdCAgICAgICAgICAgIHZhbHVlID0gdGltZTtcblx0ICAgICAgICAgICAgdGltZSA9IHZhbHVlLnRpbWU7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHRpbWUgPSB0aGlzLnRvVGlja3ModGltZSk7XG5cdCAgICAgICAgdmFyIGV2ZW50O1xuXHQgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFRvbmUuRXZlbnQpIHtcblx0ICAgICAgICAgICAgZXZlbnQgPSB2YWx1ZTtcblx0ICAgICAgICAgICAgZXZlbnQuY2FsbGJhY2sgPSB0aGlzLl90aWNrLmJpbmQodGhpcyk7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgZXZlbnQgPSBuZXcgVG9uZS5FdmVudCh7XG5cdCAgICAgICAgICAgICAgICAnY2FsbGJhY2snOiB0aGlzLl90aWNrLmJpbmQodGhpcyksXG5cdCAgICAgICAgICAgICAgICAndmFsdWUnOiB2YWx1ZVxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgLy90aGUgc3RhcnQgb2Zmc2V0XG5cdCAgICAgICAgZXZlbnQuc3RhcnRPZmZzZXQgPSB0aW1lO1xuXHQgICAgICAgIC8vaW5pdGlhbGl6ZSB0aGUgdmFsdWVzXG5cdCAgICAgICAgZXZlbnQuc2V0KHtcblx0ICAgICAgICAgICAgJ2xvb3BFbmQnOiB0aGlzLmxvb3BFbmQsXG5cdCAgICAgICAgICAgICdsb29wU3RhcnQnOiB0aGlzLmxvb3BTdGFydCxcblx0ICAgICAgICAgICAgJ2xvb3AnOiB0aGlzLmxvb3AsXG5cdCAgICAgICAgICAgICdodW1hbml6ZSc6IHRoaXMuaHVtYW5pemUsXG5cdCAgICAgICAgICAgICdwbGF5YmFja1JhdGUnOiB0aGlzLnBsYXliYWNrUmF0ZSxcblx0ICAgICAgICAgICAgJ3Byb2JhYmlsaXR5JzogdGhpcy5wcm9iYWJpbGl0eVxuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIHRoaXMuX2V2ZW50cy5wdXNoKGV2ZW50KTtcblx0ICAgICAgICAvL3N0YXJ0IHRoZSBub3RlIGlmIGl0IHNob3VsZCBiZSBwbGF5ZWQgcmlnaHQgbm93XG5cdCAgICAgICAgdGhpcy5fcmVzdGFydEV2ZW50KGV2ZW50KTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgUmVzdGFydCB0aGUgZ2l2ZW4gZXZlbnRcblx0XHQgKiAgQHBhcmFtICB7VG9uZS5FdmVudH0gIGV2ZW50IFxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5QYXJ0LnByb3RvdHlwZS5fcmVzdGFydEV2ZW50ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdCAgICAgICAgdGhpcy5fc3RhdGUuZm9yRWFjaChmdW5jdGlvbiAoc3RhdGVFdmVudCkge1xuXHQgICAgICAgICAgICBpZiAoc3RhdGVFdmVudC5zdGF0ZSA9PT0gVG9uZS5TdGF0ZS5TdGFydGVkKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9zdGFydE5vdGUoZXZlbnQsIHN0YXRlRXZlbnQudGltZSwgc3RhdGVFdmVudC5vZmZzZXQpO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgLy9zdG9wIHRoZSBub3RlXG5cdCAgICAgICAgICAgICAgICBldmVudC5zdG9wKFRvbmUuVHJhbnNwb3J0VGltZShzdGF0ZUV2ZW50LnRpbWUsICdpJykpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfS5iaW5kKHRoaXMpKTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgUmVtb3ZlIGFuIGV2ZW50IGZyb20gdGhlIHBhcnQuIFdpbGwgcmVjdXJzaXZlbHkgaXRlcmF0ZVxuXHRcdCAqICBpbnRvIG5lc3RlZCBwYXJ0cyB0byBmaW5kIHRoZSBldmVudC5cblx0XHQgKiAgQHBhcmFtIHtUaW1lfSB0aW1lIFRoZSB0aW1lIG9mIHRoZSBldmVudFxuXHRcdCAqICBAcGFyYW0geyp9IHZhbHVlIE9wdGlvbmFsbHkgc2VsZWN0IG9ubHkgYSBzcGVjaWZpYyBldmVudCB2YWx1ZVxuXHRcdCAqICBAcmV0dXJuICB7VG9uZS5QYXJ0fSAgdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5QYXJ0LnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAodGltZSwgdmFsdWUpIHtcblx0ICAgICAgICAvL2V4dHJhY3QgdGhlIHBhcmFtZXRlcnNcblx0ICAgICAgICBpZiAodGltZS5oYXNPd25Qcm9wZXJ0eSgndGltZScpKSB7XG5cdCAgICAgICAgICAgIHZhbHVlID0gdGltZTtcblx0ICAgICAgICAgICAgdGltZSA9IHZhbHVlLnRpbWU7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHRpbWUgPSB0aGlzLnRvVGlja3ModGltZSk7XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMuX2V2ZW50cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHQgICAgICAgICAgICB2YXIgZXZlbnQgPSB0aGlzLl9ldmVudHNbaV07XG5cdCAgICAgICAgICAgIGlmIChldmVudCBpbnN0YW5jZW9mIFRvbmUuUGFydCkge1xuXHQgICAgICAgICAgICAgICAgZXZlbnQucmVtb3ZlKHRpbWUsIHZhbHVlKTtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIGlmIChldmVudC5zdGFydE9mZnNldCA9PT0gdGltZSkge1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChUb25lLmlzVW5kZWYodmFsdWUpIHx8ICFUb25lLmlzVW5kZWYodmFsdWUpICYmIGV2ZW50LnZhbHVlID09PSB2YWx1ZSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9ldmVudHMuc3BsaWNlKGksIDEpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBldmVudC5kaXNwb3NlKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBSZW1vdmUgYWxsIG9mIHRoZSBub3RlcyBmcm9tIHRoZSBncm91cC4gXG5cdFx0ICogIEByZXR1cm4gIHtUb25lLlBhcnR9ICB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLlBhcnQucHJvdG90eXBlLnJlbW92ZUFsbCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB0aGlzLl9mb3JFYWNoKGZ1bmN0aW9uIChldmVudCkge1xuXHQgICAgICAgICAgICBldmVudC5kaXNwb3NlKCk7XG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgdGhpcy5fZXZlbnRzID0gW107XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIENhbmNlbCBzY2hlZHVsZWQgc3RhdGUgY2hhbmdlIGV2ZW50czogaS5lLiBcInN0YXJ0XCIgYW5kIFwic3RvcFwiLlxuXHRcdCAqICBAcGFyYW0ge1RpbWVsaW5lUG9zaXRpb259IGFmdGVyIFRoZSB0aW1lIGFmdGVyIHdoaWNoIHRvIGNhbmNlbCB0aGUgc2NoZWR1bGVkIGV2ZW50cy5cblx0XHQgKiAgQHJldHVybiAge1RvbmUuUGFydH0gIHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuUGFydC5wcm90b3R5cGUuY2FuY2VsID0gZnVuY3Rpb24gKGFmdGVyKSB7XG5cdCAgICAgICAgdGhpcy5fZm9yRWFjaChmdW5jdGlvbiAoZXZlbnQpIHtcblx0ICAgICAgICAgICAgZXZlbnQuY2FuY2VsKGFmdGVyKTtcblx0ICAgICAgICB9KTtcblx0ICAgICAgICB0aGlzLl9zdGF0ZS5jYW5jZWwodGhpcy50b1RpY2tzKGFmdGVyKSk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIEl0ZXJhdGUgb3ZlciBhbGwgb2YgdGhlIGV2ZW50c1xuXHRcdCAqICBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuXHRcdCAqICBAcGFyYW0ge09iamVjdH0gY3R4IFRoZSBjb250ZXh0XG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLlBhcnQucHJvdG90eXBlLl9mb3JFYWNoID0gZnVuY3Rpb24gKGNhbGxiYWNrLCBjdHgpIHtcblx0ICAgICAgICBpZiAodGhpcy5fZXZlbnRzKSB7XG5cdCAgICAgICAgICAgIGN0eCA9IFRvbmUuZGVmYXVsdEFyZyhjdHgsIHRoaXMpO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gdGhpcy5fZXZlbnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgZSA9IHRoaXMuX2V2ZW50c1tpXTtcblx0ICAgICAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgVG9uZS5QYXJ0KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgZS5fZm9yRWFjaChjYWxsYmFjaywgY3R4KTtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2suY2FsbChjdHgsIGUpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBTZXQgdGhlIGF0dHJpYnV0ZSBvZiBhbGwgb2YgdGhlIGV2ZW50c1xuXHRcdCAqICBAcGFyYW0gIHtTdHJpbmd9ICBhdHRyICB0aGUgYXR0cmlidXRlIHRvIHNldFxuXHRcdCAqICBAcGFyYW0gIHsqfSAgdmFsdWUgICAgICBUaGUgdmFsdWUgdG8gc2V0IGl0IHRvXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLlBhcnQucHJvdG90eXBlLl9zZXRBbGwgPSBmdW5jdGlvbiAoYXR0ciwgdmFsdWUpIHtcblx0ICAgICAgICB0aGlzLl9mb3JFYWNoKGZ1bmN0aW9uIChldmVudCkge1xuXHQgICAgICAgICAgICBldmVudFthdHRyXSA9IHZhbHVlO1xuXHQgICAgICAgIH0pO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBJbnRlcm5hbCB0aWNrIG1ldGhvZFxuXHRcdCAqICBAcGFyYW0gIHtOdW1iZXJ9ICB0aW1lICBUaGUgdGltZSBvZiB0aGUgZXZlbnQgaW4gc2Vjb25kc1xuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5QYXJ0LnByb3RvdHlwZS5fdGljayA9IGZ1bmN0aW9uICh0aW1lLCB2YWx1ZSkge1xuXHQgICAgICAgIGlmICghdGhpcy5tdXRlKSB7XG5cdCAgICAgICAgICAgIHRoaXMuY2FsbGJhY2sodGltZSwgdmFsdWUpO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgRGV0ZXJtaW5lIGlmIHRoZSBldmVudCBzaG91bGQgYmUgY3VycmVudGx5IGxvb3Bpbmdcblx0XHQgKiAgZ2l2ZW4gdGhlIGxvb3AgYm91bmRyaWVzIG9mIHRoaXMgUGFydC5cblx0XHQgKiAgQHBhcmFtICB7VG9uZS5FdmVudH0gIGV2ZW50ICBUaGUgZXZlbnQgdG8gdGVzdFxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5QYXJ0LnByb3RvdHlwZS5fdGVzdExvb3BCb3VuZHJpZXMgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblx0ICAgICAgICBpZiAoZXZlbnQuc3RhcnRPZmZzZXQgPCB0aGlzLl9sb29wU3RhcnQgfHwgZXZlbnQuc3RhcnRPZmZzZXQgPj0gdGhpcy5fbG9vcEVuZCkge1xuXHQgICAgICAgICAgICBldmVudC5jYW5jZWwoMCk7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgLy9yZXNjaGVkdWxlIGl0IGlmIGl0J3Mgc3RvcHBlZFxuXHQgICAgICAgICAgICBpZiAoZXZlbnQuc3RhdGUgPT09IFRvbmUuU3RhdGUuU3RvcHBlZCkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fcmVzdGFydEV2ZW50KGV2ZW50KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgVGhlIHByb2JhYmlsaXR5IG9mIHRoZSBub3RlcyBiZWluZyB0cmlnZ2VyZWQuXG5cdFx0ICogIEBtZW1iZXJPZiBUb25lLlBhcnQjXG5cdFx0ICogIEB0eXBlIHtOb3JtYWxSYW5nZX1cblx0XHQgKiAgQG5hbWUgcHJvYmFiaWxpdHlcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLlBhcnQucHJvdG90eXBlLCAncHJvYmFiaWxpdHknLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9wcm9iYWJpbGl0eTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKHByb2IpIHtcblx0ICAgICAgICAgICAgdGhpcy5fcHJvYmFiaWxpdHkgPSBwcm9iO1xuXHQgICAgICAgICAgICB0aGlzLl9zZXRBbGwoJ3Byb2JhYmlsaXR5JywgcHJvYik7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgSWYgc2V0IHRvIHRydWUsIHdpbGwgYXBwbHkgc21hbGwgcmFuZG9tIHZhcmlhdGlvblxuXHRcdCAqICB0byB0aGUgY2FsbGJhY2sgdGltZS4gSWYgdGhlIHZhbHVlIGlzIGdpdmVuIGFzIGEgdGltZSwgaXQgd2lsbCByYW5kb21pemVcblx0XHQgKiAgYnkgdGhhdCBhbW91bnQuXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogZXZlbnQuaHVtYW5pemUgPSB0cnVlO1xuXHRcdCAqICBAdHlwZSB7Qm9vbGVhbnxUaW1lfVxuXHRcdCAqICBAbmFtZSBodW1hbml6ZVxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuUGFydC5wcm90b3R5cGUsICdodW1hbml6ZScsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2h1bWFuaXplO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFyaWF0aW9uKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2h1bWFuaXplID0gdmFyaWF0aW9uO1xuXHQgICAgICAgICAgICB0aGlzLl9zZXRBbGwoJ2h1bWFuaXplJywgdmFyaWF0aW9uKTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBJZiB0aGUgcGFydCBzaG91bGQgbG9vcCBvciBub3Rcblx0XHQgKiAgYmV0d2VlbiBUb25lLlBhcnQubG9vcFN0YXJ0IGFuZCBcblx0XHQgKiAgVG9uZS5QYXJ0Lmxvb3BFbmQuIEFuIGludGVnZXJcblx0XHQgKiAgdmFsdWUgY29ycmVzcG9uZHMgdG8gdGhlIG51bWJlciBvZlxuXHRcdCAqICBsb29wcyB0aGUgUGFydCBkb2VzIGFmdGVyIGl0IHN0YXJ0cy5cblx0XHQgKiAgQG1lbWJlck9mIFRvbmUuUGFydCNcblx0XHQgKiAgQHR5cGUge0Jvb2xlYW58UG9zaXRpdmV9XG5cdFx0ICogIEBuYW1lIGxvb3Bcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAvL2xvb3AgdGhlIHBhcnQgOCB0aW1lc1xuXHRcdCAqIHBhcnQubG9vcCA9IDg7XG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5QYXJ0LnByb3RvdHlwZSwgJ2xvb3AnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9sb29wO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAobG9vcCkge1xuXHQgICAgICAgICAgICB0aGlzLl9sb29wID0gbG9vcDtcblx0ICAgICAgICAgICAgdGhpcy5fZm9yRWFjaChmdW5jdGlvbiAoZXZlbnQpIHtcblx0ICAgICAgICAgICAgICAgIGV2ZW50Ll9sb29wU3RhcnQgPSB0aGlzLl9sb29wU3RhcnQ7XG5cdCAgICAgICAgICAgICAgICBldmVudC5fbG9vcEVuZCA9IHRoaXMuX2xvb3BFbmQ7XG5cdCAgICAgICAgICAgICAgICBldmVudC5sb29wID0gbG9vcDtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX3Rlc3RMb29wQm91bmRyaWVzKGV2ZW50KTtcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgVGhlIGxvb3BFbmQgcG9pbnQgZGV0ZXJtaW5lcyB3aGVuIGl0IHdpbGwgXG5cdFx0ICogIGxvb3AgaWYgVG9uZS5QYXJ0Lmxvb3AgaXMgdHJ1ZS5cblx0XHQgKiAgQG1lbWJlck9mIFRvbmUuUGFydCNcblx0XHQgKiAgQHR5cGUge1RyYW5zcG9ydFRpbWV9XG5cdFx0ICogIEBuYW1lIGxvb3BFbmRcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLlBhcnQucHJvdG90eXBlLCAnbG9vcEVuZCcsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIFRvbmUuVHJhbnNwb3J0VGltZSh0aGlzLl9sb29wRW5kLCAnaScpLnRvTm90YXRpb24oKTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKGxvb3BFbmQpIHtcblx0ICAgICAgICAgICAgdGhpcy5fbG9vcEVuZCA9IHRoaXMudG9UaWNrcyhsb29wRW5kKTtcblx0ICAgICAgICAgICAgaWYgKHRoaXMuX2xvb3ApIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX2ZvckVhY2goZnVuY3Rpb24gKGV2ZW50KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgZXZlbnQubG9vcEVuZCA9IGxvb3BFbmQ7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGVzdExvb3BCb3VuZHJpZXMoZXZlbnQpO1xuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgbG9vcFN0YXJ0IHBvaW50IGRldGVybWluZXMgd2hlbiBpdCB3aWxsIFxuXHRcdCAqICBsb29wIGlmIFRvbmUuUGFydC5sb29wIGlzIHRydWUuXG5cdFx0ICogIEBtZW1iZXJPZiBUb25lLlBhcnQjXG5cdFx0ICogIEB0eXBlIHtUcmFuc3BvcnRUaW1lfVxuXHRcdCAqICBAbmFtZSBsb29wU3RhcnRcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLlBhcnQucHJvdG90eXBlLCAnbG9vcFN0YXJ0Jywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gVG9uZS5UcmFuc3BvcnRUaW1lKHRoaXMuX2xvb3BTdGFydCwgJ2knKS50b05vdGF0aW9uKCk7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChsb29wU3RhcnQpIHtcblx0ICAgICAgICAgICAgdGhpcy5fbG9vcFN0YXJ0ID0gdGhpcy50b1RpY2tzKGxvb3BTdGFydCk7XG5cdCAgICAgICAgICAgIGlmICh0aGlzLl9sb29wKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9mb3JFYWNoKGZ1bmN0aW9uIChldmVudCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGV2ZW50Lmxvb3BTdGFydCA9IHRoaXMubG9vcFN0YXJ0O1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuX3Rlc3RMb29wQm91bmRyaWVzKGV2ZW50KTtcblx0ICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiBcdFRoZSBwbGF5YmFjayByYXRlIG9mIHRoZSBwYXJ0XG5cdFx0ICogIEBtZW1iZXJPZiBUb25lLlBhcnQjXG5cdFx0ICogIEB0eXBlIHtQb3NpdGl2ZX1cblx0XHQgKiAgQG5hbWUgcGxheWJhY2tSYXRlXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5QYXJ0LnByb3RvdHlwZSwgJ3BsYXliYWNrUmF0ZScsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BsYXliYWNrUmF0ZTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKHJhdGUpIHtcblx0ICAgICAgICAgICAgdGhpcy5fcGxheWJhY2tSYXRlID0gcmF0ZTtcblx0ICAgICAgICAgICAgdGhpcy5fc2V0QWxsKCdwbGF5YmFja1JhdGUnLCByYXRlKTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqIFx0VGhlIG51bWJlciBvZiBzY2hlZHVsZWQgbm90ZXMgaW4gdGhlIHBhcnQuIFxuXHRcdCAqICBAbWVtYmVyT2YgVG9uZS5QYXJ0I1xuXHRcdCAqICBAdHlwZSB7UG9zaXRpdmV9XG5cdFx0ICogIEBuYW1lIGxlbmd0aFxuXHRcdCAqICBAcmVhZE9ubHlcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLlBhcnQucHJvdG90eXBlLCAnbGVuZ3RoJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fZXZlbnRzLmxlbmd0aDtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBDbGVhbiB1cFxuXHRcdCAqICBAcmV0dXJuICB7VG9uZS5QYXJ0fSAgdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5QYXJ0LnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHRoaXMucmVtb3ZlQWxsKCk7XG5cdCAgICAgICAgdGhpcy5fc3RhdGUuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX3N0YXRlID0gbnVsbDtcblx0ICAgICAgICB0aGlzLmNhbGxiYWNrID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9ldmVudHMgPSBudWxsO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLlBhcnQ7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgVG9uZS5QYXR0ZXJuIGFycGVnZ2lhdGVzIGJldHdlZW4gdGhlIGdpdmVuIG5vdGVzXG5cdFx0ICogICAgICAgICBpbiBhIG51bWJlciBvZiBwYXR0ZXJucy4gU2VlIFRvbmUuQ3RybFBhdHRlcm4gZm9yXG5cdFx0ICogICAgICAgICBhIGZ1bGwgbGlzdCBvZiBwYXR0ZXJucy5cblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiB2YXIgcGF0dGVybiA9IG5ldyBUb25lLlBhdHRlcm4oZnVuY3Rpb24odGltZSwgbm90ZSl7XG5cdFx0ICogICAvL3RoZSBvcmRlciBvZiB0aGUgbm90ZXMgcGFzc2VkIGluIGRlcGVuZHMgb24gdGhlIHBhdHRlcm5cblx0XHQgKiB9LCBbXCJDMlwiLCBcIkQ0XCIsIFwiRTVcIiwgXCJBNlwiXSwgXCJ1cERvd25cIik7XG5cdFx0ICogIEBleHRlbmRzIHtUb25lLkxvb3B9XG5cdFx0ICogIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBjYWxsYmFjayB0byBpbnZva2Ugd2l0aCB0aGVcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQuXG5cdFx0ICogIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgdmFsdWVzIHRvIGFycGVnZ2lhdGUgb3Zlci5cblx0XHQgKi9cblx0ICAgIFRvbmUuUGF0dGVybiA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgb3B0aW9ucyA9IFRvbmUuZGVmYXVsdHMoYXJndW1lbnRzLCBbXG5cdCAgICAgICAgICAgICdjYWxsYmFjaycsXG5cdCAgICAgICAgICAgICd2YWx1ZXMnLFxuXHQgICAgICAgICAgICAncGF0dGVybidcblx0ICAgICAgICBdLCBUb25lLlBhdHRlcm4pO1xuXHQgICAgICAgIFRvbmUuTG9vcC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBwYXR0ZXJuIG1hbmFnZXJcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5DdHJsUGF0dGVybn1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fcGF0dGVybiA9IG5ldyBUb25lLkN0cmxQYXR0ZXJuKHtcblx0ICAgICAgICAgICAgJ3ZhbHVlcyc6IG9wdGlvbnMudmFsdWVzLFxuXHQgICAgICAgICAgICAndHlwZSc6IG9wdGlvbnMucGF0dGVybixcblx0ICAgICAgICAgICAgJ2luZGV4Jzogb3B0aW9ucy5pbmRleFxuXHQgICAgICAgIH0pO1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuUGF0dGVybiwgVG9uZS5Mb29wKTtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgZGVmYXVsdHNcblx0XHQgKiAgQGNvbnN0XG5cdFx0ICogIEB0eXBlICB7T2JqZWN0fVxuXHRcdCAqL1xuXHQgICAgVG9uZS5QYXR0ZXJuLmRlZmF1bHRzID0ge1xuXHQgICAgICAgICdwYXR0ZXJuJzogVG9uZS5DdHJsUGF0dGVybi5UeXBlLlVwLFxuXHQgICAgICAgICdjYWxsYmFjayc6IFRvbmUubm9PcCxcblx0ICAgICAgICAndmFsdWVzJzogW11cblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgSW50ZXJuYWwgZnVuY3Rpb24gY2FsbGVkIHdoZW4gdGhlIG5vdGVzIHNob3VsZCBiZSBjYWxsZWRcblx0XHQgKiAgQHBhcmFtICB7TnVtYmVyfSAgdGltZSAgVGhlIHRpbWUgdGhlIGV2ZW50IG9jY3Vyc1xuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5QYXR0ZXJuLnByb3RvdHlwZS5fdGljayA9IGZ1bmN0aW9uICh0aW1lKSB7XG5cdCAgICAgICAgdGhpcy5jYWxsYmFjayh0aW1lLCB0aGlzLl9wYXR0ZXJuLnZhbHVlKTtcblx0ICAgICAgICB0aGlzLl9wYXR0ZXJuLm5leHQoKTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgVGhlIGN1cnJlbnQgaW5kZXggaW4gdGhlIHZhbHVlcyBhcnJheS5cblx0XHQgKiAgQG1lbWJlck9mIFRvbmUuUGF0dGVybiNcblx0XHQgKiAgQHR5cGUge1Bvc2l0aXZlfVxuXHRcdCAqICBAbmFtZSBpbmRleFxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuUGF0dGVybi5wcm90b3R5cGUsICdpbmRleCcsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BhdHRlcm4uaW5kZXg7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChpKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3BhdHRlcm4uaW5kZXggPSBpO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIFRoZSBhcnJheSBvZiBldmVudHMuXG5cdFx0ICogIEBtZW1iZXJPZiBUb25lLlBhdHRlcm4jXG5cdFx0ICogIEB0eXBlIHtBcnJheX1cblx0XHQgKiAgQG5hbWUgdmFsdWVzXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5QYXR0ZXJuLnByb3RvdHlwZSwgJ3ZhbHVlcycsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BhdHRlcm4udmFsdWVzO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFscykge1xuXHQgICAgICAgICAgICB0aGlzLl9wYXR0ZXJuLnZhbHVlcyA9IHZhbHM7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgVGhlIGN1cnJlbnQgdmFsdWUgb2YgdGhlIHBhdHRlcm4uXG5cdFx0ICogIEBtZW1iZXJPZiBUb25lLlBhdHRlcm4jXG5cdFx0ICogIEB0eXBlIHsqfVxuXHRcdCAqICBAbmFtZSB2YWx1ZVxuXHRcdCAqICBAcmVhZE9ubHlcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLlBhdHRlcm4ucHJvdG90eXBlLCAndmFsdWUnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9wYXR0ZXJuLnZhbHVlO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIFRoZSBwYXR0ZXJuIHR5cGUuIFNlZSBUb25lLkN0cmxQYXR0ZXJuIGZvciB0aGUgZnVsbCBsaXN0IG9mIHBhdHRlcm5zLlxuXHRcdCAqICBAbWVtYmVyT2YgVG9uZS5QYXR0ZXJuI1xuXHRcdCAqICBAdHlwZSB7U3RyaW5nfVxuXHRcdCAqICBAbmFtZSBwYXR0ZXJuXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5QYXR0ZXJuLnByb3RvdHlwZSwgJ3BhdHRlcm4nLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9wYXR0ZXJuLnR5cGU7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChwYXR0ZXJuKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3BhdHRlcm4udHlwZSA9IHBhdHRlcm47XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgQ2xlYW4gdXBcblx0XHQgKiAgQHJldHVybiAge1RvbmUuUGF0dGVybn0gIHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuUGF0dGVybi5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLkxvb3AucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLl9wYXR0ZXJuLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9wYXR0ZXJuID0gbnVsbDtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVG9uZS5QYXR0ZXJuO1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgQSBzZXF1ZW5jZSBpcyBhbiBhbHRlcm5hdGUgbm90YXRpb24gb2YgYSBwYXJ0LiBJbnN0ZWFkXG5cdFx0ICogICAgICAgICBvZiBwYXNzaW5nIGluIGFuIGFycmF5IG9mIFt0aW1lLCBldmVudF0gcGFpcnMsIHBhc3Ncblx0XHQgKiAgICAgICAgIGluIGFuIGFycmF5IG9mIGV2ZW50cyB3aGljaCB3aWxsIGJlIHNwYWNlZCBhdCB0aGVcblx0XHQgKiAgICAgICAgIGdpdmVuIHN1YmRpdmlzaW9uLiBTdWItYXJyYXlzIHdpbGwgc3ViZGl2aWRlIHRoYXQgYmVhdFxuXHRcdCAqICAgICAgICAgYnkgdGhlIG51bWJlciBvZiBpdGVtcyBhcmUgaW4gdGhlIGFycmF5LiBcblx0XHQgKiAgICAgICAgIFNlcXVlbmNlIG5vdGF0aW9uIGluc3BpcmF0aW9uIGZyb20gW1RpZGFsXShodHRwOi8veWF4dS5vcmcvdGlkYWwvKVxuXHRcdCAqICBAcGFyYW0gIHtGdW5jdGlvbn0gIGNhbGxiYWNrICBUaGUgY2FsbGJhY2sgdG8gaW52b2tlIHdpdGggZXZlcnkgbm90ZVxuXHRcdCAqICBAcGFyYW0gIHtBcnJheX0gICAgZXZlbnRzICBUaGUgc2VxdWVuY2Vcblx0XHQgKiAgQHBhcmFtICB7VGltZX0gc3ViZGl2aXNpb24gIFRoZSBzdWJkaXZpc2lvbiBiZXR3ZWVuIHdoaWNoIGV2ZW50cyBhcmUgcGxhY2VkLiBcblx0XHQgKiAgQGV4dGVuZHMge1RvbmUuUGFydH1cblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiB2YXIgc2VxID0gbmV3IFRvbmUuU2VxdWVuY2UoZnVuY3Rpb24odGltZSwgbm90ZSl7XG5cdFx0ICogXHRjb25zb2xlLmxvZyhub3RlKTtcblx0XHQgKiAvL3N0cmFpZ2h0IHF1YXRlciBub3Rlc1xuXHRcdCAqIH0sIFtcIkM0XCIsIFwiRTRcIiwgXCJHNFwiLCBcIkE0XCJdLCBcIjRuXCIpO1xuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIHZhciBzZXEgPSBuZXcgVG9uZS5TZXF1ZW5jZShmdW5jdGlvbih0aW1lLCBub3RlKXtcblx0XHQgKiBcdGNvbnNvbGUubG9nKG5vdGUpO1xuXHRcdCAqIC8vc3ViZGl2aXNpb25zIGFyZSBnaXZlbiBhcyBzdWJhcnJheXNcblx0XHQgKiB9LCBbXCJDNFwiLCBbXCJFNFwiLCBcIkQ0XCIsIFwiRTRcIl0sIFwiRzRcIiwgW1wiQTRcIiwgXCJHNFwiXV0pO1xuXHRcdCAqL1xuXHQgICAgVG9uZS5TZXF1ZW5jZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgb3B0aW9ucyA9IFRvbmUuZGVmYXVsdHMoYXJndW1lbnRzLCBbXG5cdCAgICAgICAgICAgICdjYWxsYmFjaycsXG5cdCAgICAgICAgICAgICdldmVudHMnLFxuXHQgICAgICAgICAgICAnc3ViZGl2aXNpb24nXG5cdCAgICAgICAgXSwgVG9uZS5TZXF1ZW5jZSk7XG5cdCAgICAgICAgLy9yZW1vdmUgdGhlIGV2ZW50c1xuXHQgICAgICAgIHZhciBldmVudHMgPSBvcHRpb25zLmV2ZW50cztcblx0ICAgICAgICBkZWxldGUgb3B0aW9ucy5ldmVudHM7XG5cdCAgICAgICAgVG9uZS5QYXJ0LmNhbGwodGhpcywgb3B0aW9ucyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIHN1YmRpdmlzb24gb2YgZWFjaCBub3RlXG5cdFx0XHQgKiAgQHR5cGUgIHtUaWNrc31cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fc3ViZGl2aXNpb24gPSB0aGlzLnRvVGlja3Mob3B0aW9ucy5zdWJkaXZpc2lvbik7XG5cdCAgICAgICAgLy9pZiBubyB0aW1lIHdhcyBwYXNzZWQgaW4sIHRoZSBsb29wIGVuZCBpcyB0aGUgZW5kIG9mIHRoZSBjeWNsZVxuXHQgICAgICAgIGlmIChUb25lLmlzVW5kZWYob3B0aW9ucy5sb29wRW5kKSAmJiAhVG9uZS5pc1VuZGVmKGV2ZW50cykpIHtcblx0ICAgICAgICAgICAgdGhpcy5fbG9vcEVuZCA9IGV2ZW50cy5sZW5ndGggKiB0aGlzLl9zdWJkaXZpc2lvbjtcblx0ICAgICAgICB9XG5cdCAgICAgICAgLy9kZWZhdWx0cyB0byBsb29waW5nXG5cdCAgICAgICAgdGhpcy5fbG9vcCA9IHRydWU7XG5cdCAgICAgICAgLy9hZGQgYWxsIG9mIHRoZSBldmVudHNcblx0ICAgICAgICBpZiAoIVRvbmUuaXNVbmRlZihldmVudHMpKSB7XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXZlbnRzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLmFkZChpLCBldmVudHNbaV0pO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuU2VxdWVuY2UsIFRvbmUuUGFydCk7XG5cdCAgICAvKipcblx0XHQgKiAgVGhlIGRlZmF1bHQgdmFsdWVzLlxuXHRcdCAqICBAdHlwZSAge09iamVjdH1cblx0XHQgKi9cblx0ICAgIFRvbmUuU2VxdWVuY2UuZGVmYXVsdHMgPSB7ICdzdWJkaXZpc2lvbic6ICc0bicgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgc3ViZGl2aXNpb24gb2YgdGhlIHNlcXVlbmNlLiBUaGlzIGNhbiBvbmx5IGJlIFxuXHRcdCAqICBzZXQgaW4gdGhlIGNvbnN0cnVjdG9yLiBUaGUgc3ViZGl2aXNpb24gaXMgdGhlIFxuXHRcdCAqICBpbnRlcnZhbCBiZXR3ZWVuIHN1Y2Nlc3NpdmUgc3RlcHMuIFxuXHRcdCAqICBAdHlwZSB7VGltZX1cblx0XHQgKiAgQG1lbWJlck9mIFRvbmUuU2VxdWVuY2UjXG5cdFx0ICogIEBuYW1lIHN1YmRpdmlzaW9uXG5cdFx0ICogIEByZWFkT25seVxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuU2VxdWVuY2UucHJvdG90eXBlLCAnc3ViZGl2aXNpb24nLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBUb25lLlRpbWUodGhpcy5fc3ViZGl2aXNpb24sICdpJykudG9Ob3RhdGlvbigpO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIEdldC9TZXQgYW4gaW5kZXggb2YgdGhlIHNlcXVlbmNlLiBJZiB0aGUgaW5kZXggY29udGFpbnMgYSBzdWJhcnJheSwgXG5cdFx0ICogIGEgVG9uZS5TZXF1ZW5jZSByZXByZXNlbnRpbmcgdGhhdCBzdWItYXJyYXkgd2lsbCBiZSByZXR1cm5lZC4gXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogdmFyIHNlcXVlbmNlID0gbmV3IFRvbmUuU2VxdWVuY2UocGxheU5vdGUsIFtcIkU0XCIsIFwiQzRcIiwgXCJGIzRcIiwgW1wiQTRcIiwgXCJCYjNcIl1dKVxuXHRcdCAqIHNlcXVlbmNlLmF0KDApLy8gPT4gcmV0dXJucyBcIkU0XCJcblx0XHQgKiAvL3NldCBhIHZhbHVlXG5cdFx0ICogc2VxdWVuY2UuYXQoMCwgXCJHM1wiKTtcblx0XHQgKiAvL2dldCBhIG5lc3RlZCBzZXF1ZW5jZVxuXHRcdCAqIHNlcXVlbmNlLmF0KDMpLmF0KDEpLy8gPT4gcmV0dXJucyBcIkJiM1wiXG5cdFx0ICogQHBhcmFtIHtQb3NpdGl2ZX0gaW5kZXggVGhlIGluZGV4IHRvIGdldCBvciBzZXRcblx0XHQgKiBAcGFyYW0geyp9IHZhbHVlIE9wdGlvbmFsbHkgcGFzcyBpbiB0aGUgdmFsdWUgdG8gc2V0IGF0IHRoZSBnaXZlbiBpbmRleC5cblx0XHQgKi9cblx0ICAgIFRvbmUuU2VxdWVuY2UucHJvdG90eXBlLmF0ID0gZnVuY3Rpb24gKGluZGV4LCB2YWx1ZSkge1xuXHQgICAgICAgIC8vaWYgdGhlIHZhbHVlIGlzIGFuIGFycmF5LCBcblx0ICAgICAgICBpZiAoVG9uZS5pc0FycmF5KHZhbHVlKSkge1xuXHQgICAgICAgICAgICAvL3JlbW92ZSB0aGUgY3VycmVudCBldmVudCBhdCB0aGF0IGluZGV4XG5cdCAgICAgICAgICAgIHRoaXMucmVtb3ZlKGluZGV4KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgLy9jYWxsIHRoZSBwYXJlbnQncyBtZXRob2Rcblx0ICAgICAgICByZXR1cm4gVG9uZS5QYXJ0LnByb3RvdHlwZS5hdC5jYWxsKHRoaXMsIHRoaXMuX2luZGV4VGltZShpbmRleCksIHZhbHVlKTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgQWRkIGFuIGV2ZW50IGF0IGFuIGluZGV4LCBpZiB0aGVyZSdzIGFscmVhZHkgc29tZXRoaW5nXG5cdFx0ICogIGF0IHRoYXQgaW5kZXgsIG92ZXJ3cml0ZSBpdC4gSWYgYHZhbHVlYCBpcyBhbiBhcnJheSwgXG5cdFx0ICogIGl0IHdpbGwgYmUgcGFyc2VkIGFzIGEgc3Vic2VxdWVuY2UuXG5cdFx0ICogIEBwYXJhbSB7TnVtYmVyfSBpbmRleCBUaGUgaW5kZXggdG8gYWRkIHRoZSBldmVudCB0b1xuXHRcdCAqICBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBhZGQgYXQgdGhhdCBpbmRleFxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5TZXF1ZW5jZX0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5TZXF1ZW5jZS5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKGluZGV4LCB2YWx1ZSkge1xuXHQgICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKFRvbmUuaXNBcnJheSh2YWx1ZSkpIHtcblx0ICAgICAgICAgICAgLy9tYWtlIGEgc3Vic2VxdWVuY2UgYW5kIGFkZCB0aGF0IHRvIHRoZSBzZXF1ZW5jZVxuXHQgICAgICAgICAgICB2YXIgc3ViU3ViZGl2aXNpb24gPSBNYXRoLnJvdW5kKHRoaXMuX3N1YmRpdmlzaW9uIC8gdmFsdWUubGVuZ3RoKTtcblx0ICAgICAgICAgICAgdmFsdWUgPSBuZXcgVG9uZS5TZXF1ZW5jZSh0aGlzLl90aWNrLmJpbmQodGhpcyksIHZhbHVlLCBUb25lLlRpbWUoc3ViU3ViZGl2aXNpb24sICdpJykpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBUb25lLlBhcnQucHJvdG90eXBlLmFkZC5jYWxsKHRoaXMsIHRoaXMuX2luZGV4VGltZShpbmRleCksIHZhbHVlKTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgUmVtb3ZlIGEgdmFsdWUgZnJvbSB0aGUgc2VxdWVuY2UgYnkgaW5kZXhcblx0XHQgKiAgQHBhcmFtIHtOdW1iZXJ9IGluZGV4IFRoZSBpbmRleCBvZiB0aGUgZXZlbnQgdG8gcmVtb3ZlXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLlNlcXVlbmNlfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLlNlcXVlbmNlLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoaW5kZXgsIHZhbHVlKSB7XG5cdCAgICAgICAgVG9uZS5QYXJ0LnByb3RvdHlwZS5yZW1vdmUuY2FsbCh0aGlzLCB0aGlzLl9pbmRleFRpbWUoaW5kZXgpLCB2YWx1ZSk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIEdldCB0aGUgdGltZSBvZiB0aGUgaW5kZXggZ2l2ZW4gdGhlIFNlcXVlbmNlJ3Mgc3ViZGl2aXNpb25cblx0XHQgKiAgQHBhcmFtICB7TnVtYmVyfSAgaW5kZXggXG5cdFx0ICogIEByZXR1cm4gIHtUaW1lfSAgVGhlIHRpbWUgb2YgdGhhdCBpbmRleFxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5TZXF1ZW5jZS5wcm90b3R5cGUuX2luZGV4VGltZSA9IGZ1bmN0aW9uIChpbmRleCkge1xuXHQgICAgICAgIGlmIChpbmRleCBpbnN0YW5jZW9mIFRvbmUuVHJhbnNwb3J0VGltZSkge1xuXHQgICAgICAgICAgICByZXR1cm4gaW5kZXg7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgcmV0dXJuIFRvbmUuVHJhbnNwb3J0VGltZShpbmRleCAqIHRoaXMuX3N1YmRpdmlzaW9uICsgdGhpcy5zdGFydE9mZnNldCwgJ2knKTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIENsZWFuIHVwLlxuXHRcdCAqICBAcmV0dXJuIHtUb25lLlNlcXVlbmNlfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLlNlcXVlbmNlLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuUGFydC5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLlNlcXVlbmNlO1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgVG9uZS5QdWxzZU9zY2lsbGF0b3IgaXMgYSBwdWxzZSBvc2NpbGxhdG9yIHdpdGggY29udHJvbCBvdmVyIHB1bHNlIHdpZHRoLFxuXHRcdCAqICAgICAgICAgYWxzbyBrbm93biBhcyB0aGUgZHV0eSBjeWNsZS4gQXQgNTAlIGR1dHkgY3ljbGUgKHdpZHRoID0gMC41KSB0aGUgd2F2ZSBpcyBcblx0XHQgKiAgICAgICAgIGEgc3F1YXJlIGFuZCBvbmx5IG9kZC1udW1iZXJlZCBoYXJtb25pY3MgYXJlIHByZXNlbnQuIEF0IGFsbCBvdGhlciB3aWR0aHMgXG5cdFx0ICogICAgICAgICBldmVuLW51bWJlcmVkIGhhcm1vbmljcyBhcmUgcHJlc2VudC4gUmVhZCBtb3JlIFxuXHRcdCAqICAgICAgICAgW2hlcmVdKGh0dHBzOi8vd2lnZ2xld2F2ZS53b3JkcHJlc3MuY29tLzIwMTQvMDgvMTYvcHVsc2Utd2F2ZWZvcm1zLWFuZC1oYXJtb25pY3MvKS5cblx0XHQgKlxuXHRcdCAqICBAY29uc3RydWN0b3Jcblx0XHQgKiAgQGV4dGVuZHMge1RvbmUuU291cmNlfVxuXHRcdCAqICBAcGFyYW0ge0ZyZXF1ZW5jeX0gW2ZyZXF1ZW5jeV0gVGhlIGZyZXF1ZW5jeSBvZiB0aGUgb3NjaWxsYXRvclxuXHRcdCAqICBAcGFyYW0ge05vcm1hbFJhbmdlfSBbd2lkdGhdIFRoZSB3aWR0aCBvZiB0aGUgcHVsc2Vcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiB2YXIgcHVsc2UgPSBuZXcgVG9uZS5QdWxzZU9zY2lsbGF0b3IoXCJFNVwiLCAwLjQpLnRvTWFzdGVyKCkuc3RhcnQoKTtcblx0XHQgKi9cblx0ICAgIFRvbmUuUHVsc2VPc2NpbGxhdG9yID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBvcHRpb25zID0gVG9uZS5kZWZhdWx0cyhhcmd1bWVudHMsIFtcblx0ICAgICAgICAgICAgJ2ZyZXF1ZW5jeScsXG5cdCAgICAgICAgICAgICd3aWR0aCdcblx0ICAgICAgICBdLCBUb25lLk9zY2lsbGF0b3IpO1xuXHQgICAgICAgIFRvbmUuU291cmNlLmNhbGwodGhpcywgb3B0aW9ucyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIHdpZHRoIG9mIHRoZSBwdWxzZS4gXG5cdFx0XHQgKiAgQHR5cGUge05vcm1hbFJhbmdlfVxuXHRcdFx0ICogIEBzaWduYWxcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMud2lkdGggPSBuZXcgVG9uZS5TaWduYWwob3B0aW9ucy53aWR0aCwgVG9uZS5UeXBlLk5vcm1hbFJhbmdlKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBnYXRlIHRoZSB3aWR0aCBhbW91bnRcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5HYWlufVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl93aWR0aEdhdGUgPSBuZXcgVG9uZS5HYWluKCk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgdGhlIHNhd3Rvb3RoIG9zY2lsbGF0b3Jcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5Pc2NpbGxhdG9yfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9zYXd0b290aCA9IG5ldyBUb25lLk9zY2lsbGF0b3Ioe1xuXHQgICAgICAgICAgICBmcmVxdWVuY3k6IG9wdGlvbnMuZnJlcXVlbmN5LFxuXHQgICAgICAgICAgICBkZXR1bmU6IG9wdGlvbnMuZGV0dW5lLFxuXHQgICAgICAgICAgICB0eXBlOiAnc2F3dG9vdGgnLFxuXHQgICAgICAgICAgICBwaGFzZTogb3B0aW9ucy5waGFzZVxuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBmcmVxdWVuY3kgY29udHJvbC5cblx0XHRcdCAqICBAdHlwZSB7RnJlcXVlbmN5fVxuXHRcdFx0ICogIEBzaWduYWxcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuZnJlcXVlbmN5ID0gdGhpcy5fc2F3dG9vdGguZnJlcXVlbmN5O1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBkZXR1bmUgaW4gY2VudHMuIFxuXHRcdFx0ICogIEB0eXBlIHtDZW50c31cblx0XHRcdCAqICBAc2lnbmFsXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmRldHVuZSA9IHRoaXMuX3Nhd3Rvb3RoLmRldHVuZTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaHJlc2hvbGQgdGhlIHNpZ25hbCB0byB0dXJuIGl0IGludG8gYSBzcXVhcmVcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5XYXZlU2hhcGVyfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl90aHJlc2ggPSBuZXcgVG9uZS5XYXZlU2hhcGVyKGZ1bmN0aW9uICh2YWwpIHtcblx0ICAgICAgICAgICAgaWYgKHZhbCA8IDApIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiAtMTtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiAxO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgLy9jb25uZWN0aW9uc1xuXHQgICAgICAgIHRoaXMuX3Nhd3Rvb3RoLmNoYWluKHRoaXMuX3RocmVzaCwgdGhpcy5vdXRwdXQpO1xuXHQgICAgICAgIHRoaXMud2lkdGguY2hhaW4odGhpcy5fd2lkdGhHYXRlLCB0aGlzLl90aHJlc2gpO1xuXHQgICAgICAgIHRoaXMuX3JlYWRPbmx5KFtcblx0ICAgICAgICAgICAgJ3dpZHRoJyxcblx0ICAgICAgICAgICAgJ2ZyZXF1ZW5jeScsXG5cdCAgICAgICAgICAgICdkZXR1bmUnXG5cdCAgICAgICAgXSk7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5QdWxzZU9zY2lsbGF0b3IsIFRvbmUuU291cmNlKTtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgZGVmYXVsdCBwYXJhbWV0ZXJzLlxuXHRcdCAqICBAc3RhdGljXG5cdFx0ICogIEBjb25zdFxuXHRcdCAqICBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqL1xuXHQgICAgVG9uZS5QdWxzZU9zY2lsbGF0b3IuZGVmYXVsdHMgPSB7XG5cdCAgICAgICAgJ2ZyZXF1ZW5jeSc6IDQ0MCxcblx0ICAgICAgICAnZGV0dW5lJzogMCxcblx0ICAgICAgICAncGhhc2UnOiAwLFxuXHQgICAgICAgICd3aWR0aCc6IDAuMlxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBzdGFydCB0aGUgb3NjaWxsYXRvclxuXHRcdCAqICBAcGFyYW0gIHtUaW1lfSB0aW1lIFxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5QdWxzZU9zY2lsbGF0b3IucHJvdG90eXBlLl9zdGFydCA9IGZ1bmN0aW9uICh0aW1lKSB7XG5cdCAgICAgICAgdGltZSA9IHRoaXMudG9TZWNvbmRzKHRpbWUpO1xuXHQgICAgICAgIHRoaXMuX3Nhd3Rvb3RoLnN0YXJ0KHRpbWUpO1xuXHQgICAgICAgIHRoaXMuX3dpZHRoR2F0ZS5nYWluLnNldFZhbHVlQXRUaW1lKDEsIHRpbWUpO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBzdG9wIHRoZSBvc2NpbGxhdG9yXG5cdFx0ICogIEBwYXJhbSAge1RpbWV9IHRpbWUgXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLlB1bHNlT3NjaWxsYXRvci5wcm90b3R5cGUuX3N0b3AgPSBmdW5jdGlvbiAodGltZSkge1xuXHQgICAgICAgIHRpbWUgPSB0aGlzLnRvU2Vjb25kcyh0aW1lKTtcblx0ICAgICAgICB0aGlzLl9zYXd0b290aC5zdG9wKHRpbWUpO1xuXHQgICAgICAgIC8vdGhlIHdpZHRoIGlzIHN0aWxsIGNvbm5lY3RlZCB0byB0aGUgb3V0cHV0LiBcblx0ICAgICAgICAvL3RoYXQgbmVlZHMgdG8gYmUgc3RvcHBlZCBhbHNvXG5cdCAgICAgICAgdGhpcy5fd2lkdGhHYXRlLmdhaW4uc2V0VmFsdWVBdFRpbWUoMCwgdGltZSk7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogVGhlIHBoYXNlIG9mIHRoZSBvc2NpbGxhdG9yIGluIGRlZ3JlZXMuXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuUHVsc2VPc2NpbGxhdG9yI1xuXHRcdCAqIEB0eXBlIHtEZWdyZWVzfVxuXHRcdCAqIEBuYW1lIHBoYXNlXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5QdWxzZU9zY2lsbGF0b3IucHJvdG90eXBlLCAncGhhc2UnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9zYXd0b290aC5waGFzZTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKHBoYXNlKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3Nhd3Rvb3RoLnBoYXNlID0gcGhhc2U7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiBUaGUgdHlwZSBvZiB0aGUgb3NjaWxsYXRvci4gQWx3YXlzIHJldHVybnMgXCJwdWxzZVwiLlxuXHRcdCAqIEByZWFkT25seVxuXHRcdCAqIEBtZW1iZXJPZiBUb25lLlB1bHNlT3NjaWxsYXRvciNcblx0XHQgKiBAdHlwZSB7c3RyaW5nfVxuXHRcdCAqIEBuYW1lIHR5cGVcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLlB1bHNlT3NjaWxsYXRvci5wcm90b3R5cGUsICd0eXBlJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gJ3B1bHNlJztcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqIFRoZSBwYXJ0aWFscyBvZiB0aGUgd2F2ZWZvcm0uIENhbm5vdCBzZXQgcGFydGlhbHMgZm9yIHRoaXMgd2F2ZWZvcm0gdHlwZVxuXHRcdCAqIEBtZW1iZXJPZiBUb25lLlB1bHNlT3NjaWxsYXRvciNcblx0XHQgKiBAdHlwZSB7QXJyYXl9XG5cdFx0ICogQG5hbWUgcGFydGlhbHNcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuUHVsc2VPc2NpbGxhdG9yLnByb3RvdHlwZSwgJ3BhcnRpYWxzJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gW107XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgQ2xlYW4gdXAgbWV0aG9kLlxuXHRcdCAqICBAcmV0dXJuIHtUb25lLlB1bHNlT3NjaWxsYXRvcn0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5QdWxzZU9zY2lsbGF0b3IucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5Tb3VyY2UucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLl9zYXd0b290aC5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fc2F3dG9vdGggPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX3dyaXRhYmxlKFtcblx0ICAgICAgICAgICAgJ3dpZHRoJyxcblx0ICAgICAgICAgICAgJ2ZyZXF1ZW5jeScsXG5cdCAgICAgICAgICAgICdkZXR1bmUnXG5cdCAgICAgICAgXSk7XG5cdCAgICAgICAgdGhpcy53aWR0aC5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy53aWR0aCA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fd2lkdGhHYXRlLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl93aWR0aEdhdGUgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX3RocmVzaC5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fdGhyZXNoID0gbnVsbDtcblx0ICAgICAgICB0aGlzLmZyZXF1ZW5jeSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5kZXR1bmUgPSBudWxsO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLlB1bHNlT3NjaWxsYXRvcjtcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgXG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzIFRvbmUuUFdNT3NjaWxsYXRvciBtb2R1bGF0ZXMgdGhlIHdpZHRoIG9mIGEgVG9uZS5QdWxzZU9zY2lsbGF0b3IgXG5cdFx0ICogICAgICAgICBhdCB0aGUgbW9kdWxhdGlvbkZyZXF1ZW5jeS4gVGhpcyBoYXMgdGhlIGVmZmVjdCBvZiBjb250aW51b3VzbHlcblx0XHQgKiAgICAgICAgIGNoYW5naW5nIHRoZSB0aW1icmUgb2YgdGhlIG9zY2lsbGF0b3IgYnkgYWx0ZXJpbmcgdGhlIGhhcm1vbmljcyBcblx0XHQgKiAgICAgICAgIGdlbmVyYXRlZC5cblx0XHQgKlxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZS5Tb3VyY2V9XG5cdFx0ICogIEBjb25zdHJ1Y3RvclxuXHRcdCAqICBAcGFyYW0ge0ZyZXF1ZW5jeX0gZnJlcXVlbmN5IFRoZSBzdGFydGluZyBmcmVxdWVuY3kgb2YgdGhlIG9zY2lsbGF0b3IuIFxuXHRcdCAqICBAcGFyYW0ge0ZyZXF1ZW5jeX0gbW9kdWxhdGlvbkZyZXF1ZW5jeSBUaGUgbW9kdWxhdGlvbiBmcmVxdWVuY3kgb2YgdGhlIHdpZHRoIG9mIHRoZSBwdWxzZS4gXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogIHZhciBwd20gPSBuZXcgVG9uZS5QV01Pc2NpbGxhdG9yKFwiQWIzXCIsIDAuMykudG9NYXN0ZXIoKS5zdGFydCgpO1xuXHRcdCAqL1xuXHQgICAgVG9uZS5QV01Pc2NpbGxhdG9yID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBvcHRpb25zID0gVG9uZS5kZWZhdWx0cyhhcmd1bWVudHMsIFtcblx0ICAgICAgICAgICAgJ2ZyZXF1ZW5jeScsXG5cdCAgICAgICAgICAgICdtb2R1bGF0aW9uRnJlcXVlbmN5J1xuXHQgICAgICAgIF0sIFRvbmUuUFdNT3NjaWxsYXRvcik7XG5cdCAgICAgICAgVG9uZS5Tb3VyY2UuY2FsbCh0aGlzLCBvcHRpb25zKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICB0aGUgcHVsc2Ugb3NjaWxsYXRvclxuXHRcdFx0ICogIEB0eXBlIHtUb25lLlB1bHNlT3NjaWxsYXRvcn1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fcHVsc2UgPSBuZXcgVG9uZS5QdWxzZU9zY2lsbGF0b3Iob3B0aW9ucy5tb2R1bGF0aW9uRnJlcXVlbmN5KTtcblx0ICAgICAgICAvL2NoYW5nZSB0aGUgcHVsc2Ugb3NjaWxsYXRvciB0eXBlXG5cdCAgICAgICAgdGhpcy5fcHVsc2UuX3Nhd3Rvb3RoLnR5cGUgPSAnc2luZSc7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgdGhlIG1vZHVsYXRvclxuXHRcdFx0ICogIEB0eXBlIHtUb25lLk9zY2lsbGF0b3J9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX21vZHVsYXRvciA9IG5ldyBUb25lLk9zY2lsbGF0b3Ioe1xuXHQgICAgICAgICAgICAnZnJlcXVlbmN5Jzogb3B0aW9ucy5mcmVxdWVuY3ksXG5cdCAgICAgICAgICAgICdkZXR1bmUnOiBvcHRpb25zLmRldHVuZSxcblx0ICAgICAgICAgICAgJ3BoYXNlJzogb3B0aW9ucy5waGFzZVxuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFNjYWxlIHRoZSBvc2NpbGxhdG9yIHNvIGl0IGRvZXNuJ3QgZ28gc2lsZW50IFxuXHRcdFx0ICogIGF0IHRoZSBleHRyZW1lIHZhbHVlcy5cblx0XHRcdCAqICBAdHlwZSB7VG9uZS5NdWx0aXBseX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fc2NhbGUgPSBuZXcgVG9uZS5NdWx0aXBseSgyKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgZnJlcXVlbmN5IGNvbnRyb2wuXG5cdFx0XHQgKiAgQHR5cGUge0ZyZXF1ZW5jeX1cblx0XHRcdCAqICBAc2lnbmFsXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmZyZXF1ZW5jeSA9IHRoaXMuX21vZHVsYXRvci5mcmVxdWVuY3k7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGRldHVuZSBvZiB0aGUgb3NjaWxsYXRvci5cblx0XHRcdCAqICBAdHlwZSB7Q2VudHN9XG5cdFx0XHQgKiAgQHNpZ25hbFxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5kZXR1bmUgPSB0aGlzLl9tb2R1bGF0b3IuZGV0dW5lO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBtb2R1bGF0aW9uIHJhdGUgb2YgdGhlIG9zY2lsbGF0b3IuIFxuXHRcdFx0ICogIEB0eXBlIHtGcmVxdWVuY3l9XG5cdFx0XHQgKiAgQHNpZ25hbFxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5tb2R1bGF0aW9uRnJlcXVlbmN5ID0gdGhpcy5fcHVsc2UuZnJlcXVlbmN5O1xuXHQgICAgICAgIC8vY29ubmVjdGlvbnNcblx0ICAgICAgICB0aGlzLl9tb2R1bGF0b3IuY2hhaW4odGhpcy5fc2NhbGUsIHRoaXMuX3B1bHNlLndpZHRoKTtcblx0ICAgICAgICB0aGlzLl9wdWxzZS5jb25uZWN0KHRoaXMub3V0cHV0KTtcblx0ICAgICAgICB0aGlzLl9yZWFkT25seShbXG5cdCAgICAgICAgICAgICdtb2R1bGF0aW9uRnJlcXVlbmN5Jyxcblx0ICAgICAgICAgICAgJ2ZyZXF1ZW5jeScsXG5cdCAgICAgICAgICAgICdkZXR1bmUnXG5cdCAgICAgICAgXSk7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5QV01Pc2NpbGxhdG9yLCBUb25lLlNvdXJjZSk7XG5cdCAgICAvKipcblx0XHQgKiAgZGVmYXVsdCB2YWx1ZXNcblx0XHQgKiAgQHN0YXRpY1xuXHRcdCAqICBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqICBAY29uc3Rcblx0XHQgKi9cblx0ICAgIFRvbmUuUFdNT3NjaWxsYXRvci5kZWZhdWx0cyA9IHtcblx0ICAgICAgICAnZnJlcXVlbmN5JzogNDQwLFxuXHQgICAgICAgICdkZXR1bmUnOiAwLFxuXHQgICAgICAgICdwaGFzZSc6IDAsXG5cdCAgICAgICAgJ21vZHVsYXRpb25GcmVxdWVuY3knOiAwLjRcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgc3RhcnQgdGhlIG9zY2lsbGF0b3Jcblx0XHQgKiAgQHBhcmFtICB7VGltZX0gW3RpbWU9bm93XVxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5QV01Pc2NpbGxhdG9yLnByb3RvdHlwZS5fc3RhcnQgPSBmdW5jdGlvbiAodGltZSkge1xuXHQgICAgICAgIHRpbWUgPSB0aGlzLnRvU2Vjb25kcyh0aW1lKTtcblx0ICAgICAgICB0aGlzLl9tb2R1bGF0b3Iuc3RhcnQodGltZSk7XG5cdCAgICAgICAgdGhpcy5fcHVsc2Uuc3RhcnQodGltZSk7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIHN0b3AgdGhlIG9zY2lsbGF0b3Jcblx0XHQgKiAgQHBhcmFtICB7VGltZX0gdGltZSAob3B0aW9uYWwpIHRpbWluZyBwYXJhbWV0ZXJcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuUFdNT3NjaWxsYXRvci5wcm90b3R5cGUuX3N0b3AgPSBmdW5jdGlvbiAodGltZSkge1xuXHQgICAgICAgIHRpbWUgPSB0aGlzLnRvU2Vjb25kcyh0aW1lKTtcblx0ICAgICAgICB0aGlzLl9tb2R1bGF0b3Iuc3RvcCh0aW1lKTtcblx0ICAgICAgICB0aGlzLl9wdWxzZS5zdG9wKHRpbWUpO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqIFRoZSB0eXBlIG9mIHRoZSBvc2NpbGxhdG9yLiBBbHdheXMgcmV0dXJucyBcInB3bVwiLlxuXHRcdCAqIEByZWFkT25seVxuXHRcdCAqIEBtZW1iZXJPZiBUb25lLlBXTU9zY2lsbGF0b3IjXG5cdFx0ICogQHR5cGUge3N0cmluZ31cblx0XHQgKiBAbmFtZSB0eXBlXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5QV01Pc2NpbGxhdG9yLnByb3RvdHlwZSwgJ3R5cGUnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiAncHdtJztcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqIFRoZSBwYXJ0aWFscyBvZiB0aGUgd2F2ZWZvcm0uIENhbm5vdCBzZXQgcGFydGlhbHMgZm9yIHRoaXMgd2F2ZWZvcm0gdHlwZVxuXHRcdCAqIEBtZW1iZXJPZiBUb25lLlBXTU9zY2lsbGF0b3IjXG5cdFx0ICogQHR5cGUge0FycmF5fVxuXHRcdCAqIEBuYW1lIHBhcnRpYWxzXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLlBXTU9zY2lsbGF0b3IucHJvdG90eXBlLCAncGFydGlhbHMnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBbXTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqIFRoZSBwaGFzZSBvZiB0aGUgb3NjaWxsYXRvciBpbiBkZWdyZWVzLlxuXHRcdCAqIEBtZW1iZXJPZiBUb25lLlBXTU9zY2lsbGF0b3IjXG5cdFx0ICogQHR5cGUge251bWJlcn1cblx0XHQgKiBAbmFtZSBwaGFzZVxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuUFdNT3NjaWxsYXRvci5wcm90b3R5cGUsICdwaGFzZScsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21vZHVsYXRvci5waGFzZTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKHBoYXNlKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX21vZHVsYXRvci5waGFzZSA9IHBoYXNlO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIENsZWFuIHVwLlxuXHRcdCAqICBAcmV0dXJuIHtUb25lLlBXTU9zY2lsbGF0b3J9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuUFdNT3NjaWxsYXRvci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLlNvdXJjZS5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuX3B1bHNlLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9wdWxzZSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fc2NhbGUuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX3NjYWxlID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9tb2R1bGF0b3IuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX21vZHVsYXRvciA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fd3JpdGFibGUoW1xuXHQgICAgICAgICAgICAnbW9kdWxhdGlvbkZyZXF1ZW5jeScsXG5cdCAgICAgICAgICAgICdmcmVxdWVuY3knLFxuXHQgICAgICAgICAgICAnZGV0dW5lJ1xuXHQgICAgICAgIF0pO1xuXHQgICAgICAgIHRoaXMuZnJlcXVlbmN5ID0gbnVsbDtcblx0ICAgICAgICB0aGlzLmRldHVuZSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5tb2R1bGF0aW9uRnJlcXVlbmN5ID0gbnVsbDtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVG9uZS5QV01Pc2NpbGxhdG9yO1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgVG9uZS5GTU9zY2lsbGF0b3IgXG5cdFx0ICpcblx0XHQgKiAgQGV4dGVuZHMge1RvbmUuU291cmNlfVxuXHRcdCAqICBAY29uc3RydWN0b3Jcblx0XHQgKiAgQHBhcmFtIHtGcmVxdWVuY3l9IGZyZXF1ZW5jeSBUaGUgc3RhcnRpbmcgZnJlcXVlbmN5IG9mIHRoZSBvc2NpbGxhdG9yLiBcblx0XHQgKiAgQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIHR5cGUgb2YgdGhlIGNhcnJpZXIgb3NjaWxsYXRvci5cblx0XHQgKiAgQHBhcmFtIHtTdHJpbmd9IG1vZHVsYXRpb25UeXBlIFRoZSB0eXBlIG9mIHRoZSBtb2R1bGF0b3Igb3NjaWxsYXRvci5cblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAvL2Egc2luZSBvc2NpbGxhdG9yIGZyZXF1ZW5jeS1tb2R1bGF0ZWQgYnkgYSBzcXVhcmUgd2F2ZVxuXHRcdCAqIHZhciBmbU9zYyA9IG5ldyBUb25lLkZNT3NjaWxsYXRvcihcIkFiM1wiLCBcInNpbmVcIiwgXCJzcXVhcmVcIikudG9NYXN0ZXIoKS5zdGFydCgpO1xuXHRcdCAqL1xuXHQgICAgVG9uZS5GTU9zY2lsbGF0b3IgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIG9wdGlvbnMgPSBUb25lLmRlZmF1bHRzKGFyZ3VtZW50cywgW1xuXHQgICAgICAgICAgICAnZnJlcXVlbmN5Jyxcblx0ICAgICAgICAgICAgJ3R5cGUnLFxuXHQgICAgICAgICAgICAnbW9kdWxhdGlvblR5cGUnXG5cdCAgICAgICAgXSwgVG9uZS5GTU9zY2lsbGF0b3IpO1xuXHQgICAgICAgIFRvbmUuU291cmNlLmNhbGwodGhpcywgb3B0aW9ucyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGNhcnJpZXIgb3NjaWxsYXRvclxuXHRcdFx0ICogIEB0eXBlIHtUb25lLk9zY2lsbGF0b3J9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2NhcnJpZXIgPSBuZXcgVG9uZS5Pc2NpbGxhdG9yKG9wdGlvbnMuZnJlcXVlbmN5LCBvcHRpb25zLnR5cGUpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBvc2NpbGxhdG9yJ3MgZnJlcXVlbmN5XG5cdFx0XHQgKiAgQHR5cGUge0ZyZXF1ZW5jeX1cblx0XHRcdCAqICBAc2lnbmFsXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmZyZXF1ZW5jeSA9IG5ldyBUb25lLlNpZ25hbChvcHRpb25zLmZyZXF1ZW5jeSwgVG9uZS5UeXBlLkZyZXF1ZW5jeSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGRldHVuZSBjb250cm9sIHNpZ25hbC5cblx0XHRcdCAqICBAdHlwZSB7Q2VudHN9XG5cdFx0XHQgKiAgQHNpZ25hbFxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5kZXR1bmUgPSB0aGlzLl9jYXJyaWVyLmRldHVuZTtcblx0ICAgICAgICB0aGlzLmRldHVuZS52YWx1ZSA9IG9wdGlvbnMuZGV0dW5lO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBtb2R1bGF0aW9uIGluZGV4IHdoaWNoIGlzIGluIGVzc2VuY2UgdGhlIGRlcHRoIG9yIGFtb3VudCBvZiB0aGUgbW9kdWxhdGlvbi4gSW4gb3RoZXIgdGVybXMgaXQgaXMgdGhlIFxuXHRcdFx0ICogIHJhdGlvIG9mIHRoZSBmcmVxdWVuY3kgb2YgdGhlIG1vZHVsYXRpbmcgc2lnbmFsIChtZikgdG8gdGhlIGFtcGxpdHVkZSBvZiB0aGUgXG5cdFx0XHQgKiAgbW9kdWxhdGluZyBzaWduYWwgKG1hKSAtLSBhcyBpbiBtYS9tZi4gXG5cdFx0XHQgKlx0QHR5cGUge1Bvc2l0aXZlfVxuXHRcdFx0ICpcdEBzaWduYWxcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMubW9kdWxhdGlvbkluZGV4ID0gbmV3IFRvbmUuTXVsdGlwbHkob3B0aW9ucy5tb2R1bGF0aW9uSW5kZXgpO1xuXHQgICAgICAgIHRoaXMubW9kdWxhdGlvbkluZGV4LnVuaXRzID0gVG9uZS5UeXBlLlBvc2l0aXZlO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBtb2R1bGF0aW5nIG9zY2lsbGF0b3Jcblx0XHRcdCAqICBAdHlwZSAge1RvbmUuT3NjaWxsYXRvcn1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fbW9kdWxhdG9yID0gbmV3IFRvbmUuT3NjaWxsYXRvcihvcHRpb25zLmZyZXF1ZW5jeSwgb3B0aW9ucy5tb2R1bGF0aW9uVHlwZSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgSGFybW9uaWNpdHkgaXMgdGhlIGZyZXF1ZW5jeSByYXRpbyBiZXR3ZWVuIHRoZSBjYXJyaWVyIGFuZCB0aGUgbW9kdWxhdG9yIG9zY2lsbGF0b3JzLiBcblx0XHRcdCAqICBBIGhhcm1vbmljaXR5IG9mIDEgZ2l2ZXMgYm90aCBvc2NpbGxhdG9ycyB0aGUgc2FtZSBmcmVxdWVuY3kuIFxuXHRcdFx0ICogIEhhcm1vbmljaXR5ID0gMiBtZWFucyBhIGNoYW5nZSBvZiBhbiBvY3RhdmUuIFxuXHRcdFx0ICogIEB0eXBlIHtQb3NpdGl2ZX1cblx0XHRcdCAqICBAc2lnbmFsXG5cdFx0XHQgKiAgQGV4YW1wbGVcblx0XHRcdCAqIC8vcGl0Y2ggdGhlIG1vZHVsYXRvciBhbiBvY3RhdmUgYmVsb3cgY2FycmllclxuXHRcdFx0ICogc3ludGguaGFybW9uaWNpdHkudmFsdWUgPSAwLjU7XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmhhcm1vbmljaXR5ID0gbmV3IFRvbmUuTXVsdGlwbHkob3B0aW9ucy5oYXJtb25pY2l0eSk7XG5cdCAgICAgICAgdGhpcy5oYXJtb25pY2l0eS51bml0cyA9IFRvbmUuVHlwZS5Qb3NpdGl2ZTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICB0aGUgbm9kZSB3aGVyZSB0aGUgbW9kdWxhdGlvbiBoYXBwZW5zXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuR2Fpbn1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fbW9kdWxhdGlvbk5vZGUgPSBuZXcgVG9uZS5HYWluKDApO1xuXHQgICAgICAgIC8vY29ubmVjdGlvbnNcblx0ICAgICAgICB0aGlzLmZyZXF1ZW5jeS5jb25uZWN0KHRoaXMuX2NhcnJpZXIuZnJlcXVlbmN5KTtcblx0ICAgICAgICB0aGlzLmZyZXF1ZW5jeS5jaGFpbih0aGlzLmhhcm1vbmljaXR5LCB0aGlzLl9tb2R1bGF0b3IuZnJlcXVlbmN5KTtcblx0ICAgICAgICB0aGlzLmZyZXF1ZW5jeS5jaGFpbih0aGlzLm1vZHVsYXRpb25JbmRleCwgdGhpcy5fbW9kdWxhdGlvbk5vZGUpO1xuXHQgICAgICAgIHRoaXMuX21vZHVsYXRvci5jb25uZWN0KHRoaXMuX21vZHVsYXRpb25Ob2RlLmdhaW4pO1xuXHQgICAgICAgIHRoaXMuX21vZHVsYXRpb25Ob2RlLmNvbm5lY3QodGhpcy5fY2Fycmllci5mcmVxdWVuY3kpO1xuXHQgICAgICAgIHRoaXMuX2NhcnJpZXIuY29ubmVjdCh0aGlzLm91dHB1dCk7XG5cdCAgICAgICAgdGhpcy5kZXR1bmUuY29ubmVjdCh0aGlzLl9tb2R1bGF0b3IuZGV0dW5lKTtcblx0ICAgICAgICB0aGlzLnBoYXNlID0gb3B0aW9ucy5waGFzZTtcblx0ICAgICAgICB0aGlzLl9yZWFkT25seShbXG5cdCAgICAgICAgICAgICdtb2R1bGF0aW9uSW5kZXgnLFxuXHQgICAgICAgICAgICAnZnJlcXVlbmN5Jyxcblx0ICAgICAgICAgICAgJ2RldHVuZScsXG5cdCAgICAgICAgICAgICdoYXJtb25pY2l0eSdcblx0ICAgICAgICBdKTtcblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLkZNT3NjaWxsYXRvciwgVG9uZS5Tb3VyY2UpO1xuXHQgICAgLyoqXG5cdFx0ICogIGRlZmF1bHQgdmFsdWVzXG5cdFx0ICogIEBzdGF0aWNcblx0XHQgKiAgQHR5cGUge09iamVjdH1cblx0XHQgKiAgQGNvbnN0XG5cdFx0ICovXG5cdCAgICBUb25lLkZNT3NjaWxsYXRvci5kZWZhdWx0cyA9IHtcblx0ICAgICAgICAnZnJlcXVlbmN5JzogNDQwLFxuXHQgICAgICAgICdkZXR1bmUnOiAwLFxuXHQgICAgICAgICdwaGFzZSc6IDAsXG5cdCAgICAgICAgJ21vZHVsYXRpb25JbmRleCc6IDIsXG5cdCAgICAgICAgJ21vZHVsYXRpb25UeXBlJzogJ3NxdWFyZScsXG5cdCAgICAgICAgJ2hhcm1vbmljaXR5JzogMVxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBzdGFydCB0aGUgb3NjaWxsYXRvclxuXHRcdCAqICBAcGFyYW0gIHtUaW1lfSBbdGltZT1ub3ddXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLkZNT3NjaWxsYXRvci5wcm90b3R5cGUuX3N0YXJ0ID0gZnVuY3Rpb24gKHRpbWUpIHtcblx0ICAgICAgICB0aW1lID0gdGhpcy50b1NlY29uZHModGltZSk7XG5cdCAgICAgICAgdGhpcy5fbW9kdWxhdG9yLnN0YXJ0KHRpbWUpO1xuXHQgICAgICAgIHRoaXMuX2NhcnJpZXIuc3RhcnQodGltZSk7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIHN0b3AgdGhlIG9zY2lsbGF0b3Jcblx0XHQgKiAgQHBhcmFtICB7VGltZX0gdGltZSAob3B0aW9uYWwpIHRpbWluZyBwYXJhbWV0ZXJcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuRk1Pc2NpbGxhdG9yLnByb3RvdHlwZS5fc3RvcCA9IGZ1bmN0aW9uICh0aW1lKSB7XG5cdCAgICAgICAgdGltZSA9IHRoaXMudG9TZWNvbmRzKHRpbWUpO1xuXHQgICAgICAgIHRoaXMuX21vZHVsYXRvci5zdG9wKHRpbWUpO1xuXHQgICAgICAgIHRoaXMuX2NhcnJpZXIuc3RvcCh0aW1lKTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiBUaGUgdHlwZSBvZiB0aGUgY2FycmllciBvc2NpbGxhdG9yXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuRk1Pc2NpbGxhdG9yI1xuXHRcdCAqIEB0eXBlIHtzdHJpbmd9XG5cdFx0ICogQG5hbWUgdHlwZVxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuRk1Pc2NpbGxhdG9yLnByb3RvdHlwZSwgJ3R5cGUnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9jYXJyaWVyLnR5cGU7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uICh0eXBlKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2NhcnJpZXIudHlwZSA9IHR5cGU7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiBUaGUgdHlwZSBvZiB0aGUgbW9kdWxhdG9yIG9zY2lsbGF0b3Jcblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5GTU9zY2lsbGF0b3IjXG5cdFx0ICogQHR5cGUge1N0cmluZ31cblx0XHQgKiBAbmFtZSBtb2R1bGF0aW9uVHlwZVxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuRk1Pc2NpbGxhdG9yLnByb3RvdHlwZSwgJ21vZHVsYXRpb25UeXBlJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9kdWxhdG9yLnR5cGU7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uICh0eXBlKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX21vZHVsYXRvci50eXBlID0gdHlwZTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqIFRoZSBwaGFzZSBvZiB0aGUgb3NjaWxsYXRvciBpbiBkZWdyZWVzLlxuXHRcdCAqIEBtZW1iZXJPZiBUb25lLkZNT3NjaWxsYXRvciNcblx0XHQgKiBAdHlwZSB7bnVtYmVyfVxuXHRcdCAqIEBuYW1lIHBoYXNlXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5GTU9zY2lsbGF0b3IucHJvdG90eXBlLCAncGhhc2UnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9jYXJyaWVyLnBoYXNlO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAocGhhc2UpIHtcblx0ICAgICAgICAgICAgdGhpcy5fY2Fycmllci5waGFzZSA9IHBoYXNlO1xuXHQgICAgICAgICAgICB0aGlzLl9tb2R1bGF0b3IucGhhc2UgPSBwaGFzZTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqIFRoZSBwYXJ0aWFscyBvZiB0aGUgY2FycmllciB3YXZlZm9ybS4gQSBwYXJ0aWFsIHJlcHJlc2VudHMgXG5cdFx0ICogdGhlIGFtcGxpdHVkZSBhdCBhIGhhcm1vbmljLiBUaGUgZmlyc3QgaGFybW9uaWMgaXMgdGhlIFxuXHRcdCAqIGZ1bmRhbWVudGFsIGZyZXF1ZW5jeSwgdGhlIHNlY29uZCBpcyB0aGUgb2N0YXZlIGFuZCBzbyBvblxuXHRcdCAqIGZvbGxvd2luZyB0aGUgaGFybW9uaWMgc2VyaWVzLiBcblx0XHQgKiBTZXR0aW5nIHRoaXMgdmFsdWUgd2lsbCBhdXRvbWF0aWNhbGx5IHNldCB0aGUgdHlwZSB0byBcImN1c3RvbVwiLiBcblx0XHQgKiBUaGUgdmFsdWUgaXMgYW4gZW1wdHkgYXJyYXkgd2hlbiB0aGUgdHlwZSBpcyBub3QgXCJjdXN0b21cIi4gXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuRk1Pc2NpbGxhdG9yI1xuXHRcdCAqIEB0eXBlIHtBcnJheX1cblx0XHQgKiBAbmFtZSBwYXJ0aWFsc1xuXHRcdCAqIEBleGFtcGxlXG5cdFx0ICogb3NjLnBhcnRpYWxzID0gWzEsIDAuMiwgMC4wMV07XG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5GTU9zY2lsbGF0b3IucHJvdG90eXBlLCAncGFydGlhbHMnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9jYXJyaWVyLnBhcnRpYWxzO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAocGFydGlhbHMpIHtcblx0ICAgICAgICAgICAgdGhpcy5fY2Fycmllci5wYXJ0aWFscyA9IHBhcnRpYWxzO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIENsZWFuIHVwLlxuXHRcdCAqICBAcmV0dXJuIHtUb25lLkZNT3NjaWxsYXRvcn0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5GTU9zY2lsbGF0b3IucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5Tb3VyY2UucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLl93cml0YWJsZShbXG5cdCAgICAgICAgICAgICdtb2R1bGF0aW9uSW5kZXgnLFxuXHQgICAgICAgICAgICAnZnJlcXVlbmN5Jyxcblx0ICAgICAgICAgICAgJ2RldHVuZScsXG5cdCAgICAgICAgICAgICdoYXJtb25pY2l0eSdcblx0ICAgICAgICBdKTtcblx0ICAgICAgICB0aGlzLmZyZXF1ZW5jeS5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5mcmVxdWVuY3kgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuZGV0dW5lID0gbnVsbDtcblx0ICAgICAgICB0aGlzLmhhcm1vbmljaXR5LmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLmhhcm1vbmljaXR5ID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9jYXJyaWVyLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9jYXJyaWVyID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9tb2R1bGF0b3IuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX21vZHVsYXRvciA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fbW9kdWxhdGlvbk5vZGUuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX21vZHVsYXRpb25Ob2RlID0gbnVsbDtcblx0ICAgICAgICB0aGlzLm1vZHVsYXRpb25JbmRleC5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5tb2R1bGF0aW9uSW5kZXggPSBudWxsO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLkZNT3NjaWxsYXRvcjtcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgXG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzIFRvbmUuQU1Pc2NpbGxhdG9yIFxuXHRcdCAqXG5cdFx0ICogIEBleHRlbmRzIHtUb25lLk9zY2lsbGF0b3J9XG5cdFx0ICogIEBjb25zdHJ1Y3RvclxuXHRcdCAqICBAcGFyYW0ge0ZyZXF1ZW5jeX0gZnJlcXVlbmN5IFRoZSBzdGFydGluZyBmcmVxdWVuY3kgb2YgdGhlIG9zY2lsbGF0b3IuIFxuXHRcdCAqICBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgdHlwZSBvZiB0aGUgY2FycmllciBvc2NpbGxhdG9yLlxuXHRcdCAqICBAcGFyYW0ge1N0cmluZ30gbW9kdWxhdGlvblR5cGUgVGhlIHR5cGUgb2YgdGhlIG1vZHVsYXRvciBvc2NpbGxhdG9yLlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIC8vYSBzaW5lIG9zY2lsbGF0b3IgZnJlcXVlbmN5LW1vZHVsYXRlZCBieSBhIHNxdWFyZSB3YXZlXG5cdFx0ICogdmFyIGZtT3NjID0gbmV3IFRvbmUuQU1Pc2NpbGxhdG9yKFwiQWIzXCIsIFwic2luZVwiLCBcInNxdWFyZVwiKS50b01hc3RlcigpLnN0YXJ0KCk7XG5cdFx0ICovXG5cdCAgICBUb25lLkFNT3NjaWxsYXRvciA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgb3B0aW9ucyA9IFRvbmUuZGVmYXVsdHMoYXJndW1lbnRzLCBbXG5cdCAgICAgICAgICAgICdmcmVxdWVuY3knLFxuXHQgICAgICAgICAgICAndHlwZScsXG5cdCAgICAgICAgICAgICdtb2R1bGF0aW9uVHlwZSdcblx0ICAgICAgICBdLCBUb25lLkFNT3NjaWxsYXRvcik7XG5cdCAgICAgICAgVG9uZS5Tb3VyY2UuY2FsbCh0aGlzLCBvcHRpb25zKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgY2FycmllciBvc2NpbGxhdG9yXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuT3NjaWxsYXRvcn1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fY2FycmllciA9IG5ldyBUb25lLk9zY2lsbGF0b3Iob3B0aW9ucy5mcmVxdWVuY3ksIG9wdGlvbnMudHlwZSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIG9zY2lsbGF0b3IncyBmcmVxdWVuY3lcblx0XHRcdCAqICBAdHlwZSB7RnJlcXVlbmN5fVxuXHRcdFx0ICogIEBzaWduYWxcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuZnJlcXVlbmN5ID0gdGhpcy5fY2Fycmllci5mcmVxdWVuY3k7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGRldHVuZSBjb250cm9sIHNpZ25hbC5cblx0XHRcdCAqICBAdHlwZSB7Q2VudHN9XG5cdFx0XHQgKiAgQHNpZ25hbFxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5kZXR1bmUgPSB0aGlzLl9jYXJyaWVyLmRldHVuZTtcblx0ICAgICAgICB0aGlzLmRldHVuZS52YWx1ZSA9IG9wdGlvbnMuZGV0dW5lO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBtb2R1bGF0aW5nIG9zY2lsbGF0b3Jcblx0XHRcdCAqICBAdHlwZSAge1RvbmUuT3NjaWxsYXRvcn1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fbW9kdWxhdG9yID0gbmV3IFRvbmUuT3NjaWxsYXRvcihvcHRpb25zLmZyZXF1ZW5jeSwgb3B0aW9ucy5tb2R1bGF0aW9uVHlwZSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgY29udmVydCB0aGUgLTEsMSBvdXRwdXQgdG8gMCwxXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuQXVkaW9Ub0dhaW59XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX21vZHVsYXRpb25TY2FsZSA9IG5ldyBUb25lLkF1ZGlvVG9HYWluKCk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgSGFybW9uaWNpdHkgaXMgdGhlIGZyZXF1ZW5jeSByYXRpbyBiZXR3ZWVuIHRoZSBjYXJyaWVyIGFuZCB0aGUgbW9kdWxhdG9yIG9zY2lsbGF0b3JzLiBcblx0XHRcdCAqICBBIGhhcm1vbmljaXR5IG9mIDEgZ2l2ZXMgYm90aCBvc2NpbGxhdG9ycyB0aGUgc2FtZSBmcmVxdWVuY3kuIFxuXHRcdFx0ICogIEhhcm1vbmljaXR5ID0gMiBtZWFucyBhIGNoYW5nZSBvZiBhbiBvY3RhdmUuIFxuXHRcdFx0ICogIEB0eXBlIHtQb3NpdGl2ZX1cblx0XHRcdCAqICBAc2lnbmFsXG5cdFx0XHQgKiAgQGV4YW1wbGVcblx0XHRcdCAqIC8vcGl0Y2ggdGhlIG1vZHVsYXRvciBhbiBvY3RhdmUgYmVsb3cgY2FycmllclxuXHRcdFx0ICogc3ludGguaGFybW9uaWNpdHkudmFsdWUgPSAwLjU7XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmhhcm1vbmljaXR5ID0gbmV3IFRvbmUuTXVsdGlwbHkob3B0aW9ucy5oYXJtb25pY2l0eSk7XG5cdCAgICAgICAgdGhpcy5oYXJtb25pY2l0eS51bml0cyA9IFRvbmUuVHlwZS5Qb3NpdGl2ZTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICB0aGUgbm9kZSB3aGVyZSB0aGUgbW9kdWxhdGlvbiBoYXBwZW5zXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuR2Fpbn1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fbW9kdWxhdGlvbk5vZGUgPSBuZXcgVG9uZS5HYWluKDApO1xuXHQgICAgICAgIC8vY29ubmVjdGlvbnNcblx0ICAgICAgICB0aGlzLmZyZXF1ZW5jeS5jaGFpbih0aGlzLmhhcm1vbmljaXR5LCB0aGlzLl9tb2R1bGF0b3IuZnJlcXVlbmN5KTtcblx0ICAgICAgICB0aGlzLmRldHVuZS5jb25uZWN0KHRoaXMuX21vZHVsYXRvci5kZXR1bmUpO1xuXHQgICAgICAgIHRoaXMuX21vZHVsYXRvci5jaGFpbih0aGlzLl9tb2R1bGF0aW9uU2NhbGUsIHRoaXMuX21vZHVsYXRpb25Ob2RlLmdhaW4pO1xuXHQgICAgICAgIHRoaXMuX2NhcnJpZXIuY2hhaW4odGhpcy5fbW9kdWxhdGlvbk5vZGUsIHRoaXMub3V0cHV0KTtcblx0ICAgICAgICB0aGlzLnBoYXNlID0gb3B0aW9ucy5waGFzZTtcblx0ICAgICAgICB0aGlzLl9yZWFkT25seShbXG5cdCAgICAgICAgICAgICdmcmVxdWVuY3knLFxuXHQgICAgICAgICAgICAnZGV0dW5lJyxcblx0ICAgICAgICAgICAgJ2hhcm1vbmljaXR5J1xuXHQgICAgICAgIF0pO1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuQU1Pc2NpbGxhdG9yLCBUb25lLk9zY2lsbGF0b3IpO1xuXHQgICAgLyoqXG5cdFx0ICogIGRlZmF1bHQgdmFsdWVzXG5cdFx0ICogIEBzdGF0aWNcblx0XHQgKiAgQHR5cGUge09iamVjdH1cblx0XHQgKiAgQGNvbnN0XG5cdFx0ICovXG5cdCAgICBUb25lLkFNT3NjaWxsYXRvci5kZWZhdWx0cyA9IHtcblx0ICAgICAgICAnZnJlcXVlbmN5JzogNDQwLFxuXHQgICAgICAgICdkZXR1bmUnOiAwLFxuXHQgICAgICAgICdwaGFzZSc6IDAsXG5cdCAgICAgICAgJ21vZHVsYXRpb25UeXBlJzogJ3NxdWFyZScsXG5cdCAgICAgICAgJ2hhcm1vbmljaXR5JzogMVxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBzdGFydCB0aGUgb3NjaWxsYXRvclxuXHRcdCAqICBAcGFyYW0gIHtUaW1lfSBbdGltZT1ub3ddXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLkFNT3NjaWxsYXRvci5wcm90b3R5cGUuX3N0YXJ0ID0gZnVuY3Rpb24gKHRpbWUpIHtcblx0ICAgICAgICB0aW1lID0gdGhpcy50b1NlY29uZHModGltZSk7XG5cdCAgICAgICAgdGhpcy5fbW9kdWxhdG9yLnN0YXJ0KHRpbWUpO1xuXHQgICAgICAgIHRoaXMuX2NhcnJpZXIuc3RhcnQodGltZSk7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIHN0b3AgdGhlIG9zY2lsbGF0b3Jcblx0XHQgKiAgQHBhcmFtICB7VGltZX0gdGltZSAob3B0aW9uYWwpIHRpbWluZyBwYXJhbWV0ZXJcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuQU1Pc2NpbGxhdG9yLnByb3RvdHlwZS5fc3RvcCA9IGZ1bmN0aW9uICh0aW1lKSB7XG5cdCAgICAgICAgdGltZSA9IHRoaXMudG9TZWNvbmRzKHRpbWUpO1xuXHQgICAgICAgIHRoaXMuX21vZHVsYXRvci5zdG9wKHRpbWUpO1xuXHQgICAgICAgIHRoaXMuX2NhcnJpZXIuc3RvcCh0aW1lKTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiBUaGUgdHlwZSBvZiB0aGUgY2FycmllciBvc2NpbGxhdG9yXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuQU1Pc2NpbGxhdG9yI1xuXHRcdCAqIEB0eXBlIHtzdHJpbmd9XG5cdFx0ICogQG5hbWUgdHlwZVxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuQU1Pc2NpbGxhdG9yLnByb3RvdHlwZSwgJ3R5cGUnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9jYXJyaWVyLnR5cGU7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uICh0eXBlKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2NhcnJpZXIudHlwZSA9IHR5cGU7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiBUaGUgdHlwZSBvZiB0aGUgbW9kdWxhdG9yIG9zY2lsbGF0b3Jcblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5BTU9zY2lsbGF0b3IjXG5cdFx0ICogQHR5cGUge3N0cmluZ31cblx0XHQgKiBAbmFtZSBtb2R1bGF0aW9uVHlwZVxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuQU1Pc2NpbGxhdG9yLnByb3RvdHlwZSwgJ21vZHVsYXRpb25UeXBlJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9kdWxhdG9yLnR5cGU7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uICh0eXBlKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX21vZHVsYXRvci50eXBlID0gdHlwZTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqIFRoZSBwaGFzZSBvZiB0aGUgb3NjaWxsYXRvciBpbiBkZWdyZWVzLlxuXHRcdCAqIEBtZW1iZXJPZiBUb25lLkFNT3NjaWxsYXRvciNcblx0XHQgKiBAdHlwZSB7bnVtYmVyfVxuXHRcdCAqIEBuYW1lIHBoYXNlXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5BTU9zY2lsbGF0b3IucHJvdG90eXBlLCAncGhhc2UnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9jYXJyaWVyLnBoYXNlO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAocGhhc2UpIHtcblx0ICAgICAgICAgICAgdGhpcy5fY2Fycmllci5waGFzZSA9IHBoYXNlO1xuXHQgICAgICAgICAgICB0aGlzLl9tb2R1bGF0b3IucGhhc2UgPSBwaGFzZTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqIFRoZSBwYXJ0aWFscyBvZiB0aGUgY2FycmllciB3YXZlZm9ybS4gQSBwYXJ0aWFsIHJlcHJlc2VudHMgXG5cdFx0ICogdGhlIGFtcGxpdHVkZSBhdCBhIGhhcm1vbmljLiBUaGUgZmlyc3QgaGFybW9uaWMgaXMgdGhlIFxuXHRcdCAqIGZ1bmRhbWVudGFsIGZyZXF1ZW5jeSwgdGhlIHNlY29uZCBpcyB0aGUgb2N0YXZlIGFuZCBzbyBvblxuXHRcdCAqIGZvbGxvd2luZyB0aGUgaGFybW9uaWMgc2VyaWVzLiBcblx0XHQgKiBTZXR0aW5nIHRoaXMgdmFsdWUgd2lsbCBhdXRvbWF0aWNhbGx5IHNldCB0aGUgdHlwZSB0byBcImN1c3RvbVwiLiBcblx0XHQgKiBUaGUgdmFsdWUgaXMgYW4gZW1wdHkgYXJyYXkgd2hlbiB0aGUgdHlwZSBpcyBub3QgXCJjdXN0b21cIi4gXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuQU1Pc2NpbGxhdG9yI1xuXHRcdCAqIEB0eXBlIHtBcnJheX1cblx0XHQgKiBAbmFtZSBwYXJ0aWFsc1xuXHRcdCAqIEBleGFtcGxlXG5cdFx0ICogb3NjLnBhcnRpYWxzID0gWzEsIDAuMiwgMC4wMV07XG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5BTU9zY2lsbGF0b3IucHJvdG90eXBlLCAncGFydGlhbHMnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9jYXJyaWVyLnBhcnRpYWxzO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAocGFydGlhbHMpIHtcblx0ICAgICAgICAgICAgdGhpcy5fY2Fycmllci5wYXJ0aWFscyA9IHBhcnRpYWxzO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIENsZWFuIHVwLlxuXHRcdCAqICBAcmV0dXJuIHtUb25lLkFNT3NjaWxsYXRvcn0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5BTU9zY2lsbGF0b3IucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5Tb3VyY2UucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLl93cml0YWJsZShbXG5cdCAgICAgICAgICAgICdmcmVxdWVuY3knLFxuXHQgICAgICAgICAgICAnZGV0dW5lJyxcblx0ICAgICAgICAgICAgJ2hhcm1vbmljaXR5J1xuXHQgICAgICAgIF0pO1xuXHQgICAgICAgIHRoaXMuZnJlcXVlbmN5ID0gbnVsbDtcblx0ICAgICAgICB0aGlzLmRldHVuZSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5oYXJtb25pY2l0eS5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5oYXJtb25pY2l0eSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fY2Fycmllci5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fY2FycmllciA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fbW9kdWxhdG9yLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9tb2R1bGF0b3IgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX21vZHVsYXRpb25Ob2RlLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9tb2R1bGF0aW9uTm9kZSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fbW9kdWxhdGlvblNjYWxlLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9tb2R1bGF0aW9uU2NhbGUgPSBudWxsO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLkFNT3NjaWxsYXRvcjtcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgXG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzIFRvbmUuRmF0T3NjaWxsYXRvciBcblx0XHQgKlxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZS5Tb3VyY2V9XG5cdFx0ICogIEBjb25zdHJ1Y3RvclxuXHRcdCAqICBAcGFyYW0ge0ZyZXF1ZW5jeX0gZnJlcXVlbmN5IFRoZSBzdGFydGluZyBmcmVxdWVuY3kgb2YgdGhlIG9zY2lsbGF0b3IuIFxuXHRcdCAqICBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgdHlwZSBvZiB0aGUgY2FycmllciBvc2NpbGxhdG9yLlxuXHRcdCAqICBAcGFyYW0ge1N0cmluZ30gbW9kdWxhdGlvblR5cGUgVGhlIHR5cGUgb2YgdGhlIG1vZHVsYXRvciBvc2NpbGxhdG9yLlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIC8vYSBzaW5lIG9zY2lsbGF0b3IgZnJlcXVlbmN5LW1vZHVsYXRlZCBieSBhIHNxdWFyZSB3YXZlXG5cdFx0ICogdmFyIGZtT3NjID0gbmV3IFRvbmUuRmF0T3NjaWxsYXRvcihcIkFiM1wiLCBcInNpbmVcIiwgXCJzcXVhcmVcIikudG9NYXN0ZXIoKS5zdGFydCgpO1xuXHRcdCAqL1xuXHQgICAgVG9uZS5GYXRPc2NpbGxhdG9yID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBvcHRpb25zID0gVG9uZS5kZWZhdWx0cyhhcmd1bWVudHMsIFtcblx0ICAgICAgICAgICAgJ2ZyZXF1ZW5jeScsXG5cdCAgICAgICAgICAgICd0eXBlJyxcblx0ICAgICAgICAgICAgJ3NwcmVhZCdcblx0ICAgICAgICBdLCBUb25lLkZhdE9zY2lsbGF0b3IpO1xuXHQgICAgICAgIFRvbmUuU291cmNlLmNhbGwodGhpcywgb3B0aW9ucyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIG9zY2lsbGF0b3IncyBmcmVxdWVuY3lcblx0XHRcdCAqICBAdHlwZSB7RnJlcXVlbmN5fVxuXHRcdFx0ICogIEBzaWduYWxcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuZnJlcXVlbmN5ID0gbmV3IFRvbmUuU2lnbmFsKG9wdGlvbnMuZnJlcXVlbmN5LCBUb25lLlR5cGUuRnJlcXVlbmN5KTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgZGV0dW5lIGNvbnRyb2wgc2lnbmFsLlxuXHRcdFx0ICogIEB0eXBlIHtDZW50c31cblx0XHRcdCAqICBAc2lnbmFsXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmRldHVuZSA9IG5ldyBUb25lLlNpZ25hbChvcHRpb25zLmRldHVuZSwgVG9uZS5UeXBlLkNlbnRzKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgYXJyYXkgb2Ygb3NjaWxsYXRvcnNcblx0XHRcdCAqICBAdHlwZSB7QXJyYXl9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX29zY2lsbGF0b3JzID0gW107XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIHRvdGFsIHNwcmVhZCBvZiB0aGUgb3NjaWxsYXRvcnNcblx0XHRcdCAqICBAdHlwZSAge0NlbnRzfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9zcHJlYWQgPSBvcHRpb25zLnNwcmVhZDtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgdHlwZSBvZiB0aGUgb3NjaWxsYXRvclxuXHRcdFx0ICogIEB0eXBlIHtTdHJpbmd9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX3R5cGUgPSBvcHRpb25zLnR5cGU7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIHBoYXNlIG9mIHRoZSBvc2NpbGxhdG9yc1xuXHRcdFx0ICogIEB0eXBlIHtEZWdyZWVzfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9waGFzZSA9IG9wdGlvbnMucGhhc2U7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIHBhcnRpYWxzIGFycmF5XG5cdFx0XHQgKiAgQHR5cGUge0FycmF5fVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9wYXJ0aWFscyA9IFRvbmUuZGVmYXVsdEFyZyhvcHRpb25zLnBhcnRpYWxzLCBbXSk7XG5cdCAgICAgICAgLy9zZXQgdGhlIGNvdW50IGluaXRpYWxseVxuXHQgICAgICAgIHRoaXMuY291bnQgPSBvcHRpb25zLmNvdW50O1xuXHQgICAgICAgIHRoaXMuX3JlYWRPbmx5KFtcblx0ICAgICAgICAgICAgJ2ZyZXF1ZW5jeScsXG5cdCAgICAgICAgICAgICdkZXR1bmUnXG5cdCAgICAgICAgXSk7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5GYXRPc2NpbGxhdG9yLCBUb25lLlNvdXJjZSk7XG5cdCAgICAvKipcblx0XHQgKiAgZGVmYXVsdCB2YWx1ZXNcblx0XHQgKiAgQHN0YXRpY1xuXHRcdCAqICBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqICBAY29uc3Rcblx0XHQgKi9cblx0ICAgIFRvbmUuRmF0T3NjaWxsYXRvci5kZWZhdWx0cyA9IHtcblx0ICAgICAgICAnZnJlcXVlbmN5JzogNDQwLFxuXHQgICAgICAgICdkZXR1bmUnOiAwLFxuXHQgICAgICAgICdwaGFzZSc6IDAsXG5cdCAgICAgICAgJ3NwcmVhZCc6IDIwLFxuXHQgICAgICAgICdjb3VudCc6IDMsXG5cdCAgICAgICAgJ3R5cGUnOiAnc2F3dG9vdGgnXG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIHN0YXJ0IHRoZSBvc2NpbGxhdG9yXG5cdFx0ICogIEBwYXJhbSAge1RpbWV9IFt0aW1lPW5vd11cblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuRmF0T3NjaWxsYXRvci5wcm90b3R5cGUuX3N0YXJ0ID0gZnVuY3Rpb24gKHRpbWUpIHtcblx0ICAgICAgICB0aW1lID0gdGhpcy50b1NlY29uZHModGltZSk7XG5cdCAgICAgICAgdGhpcy5fZm9yRWFjaChmdW5jdGlvbiAob3NjKSB7XG5cdCAgICAgICAgICAgIG9zYy5zdGFydCh0aW1lKTtcblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgc3RvcCB0aGUgb3NjaWxsYXRvclxuXHRcdCAqICBAcGFyYW0gIHtUaW1lfSB0aW1lIChvcHRpb25hbCkgdGltaW5nIHBhcmFtZXRlclxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5GYXRPc2NpbGxhdG9yLnByb3RvdHlwZS5fc3RvcCA9IGZ1bmN0aW9uICh0aW1lKSB7XG5cdCAgICAgICAgdGltZSA9IHRoaXMudG9TZWNvbmRzKHRpbWUpO1xuXHQgICAgICAgIHRoaXMuX2ZvckVhY2goZnVuY3Rpb24gKG9zYykge1xuXHQgICAgICAgICAgICBvc2Muc3RvcCh0aW1lKTtcblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgSXRlcmF0ZSBvdmVyIGFsbCBvZiB0aGUgb3NjaWxsYXRvcnNcblx0XHQgKiAgQHBhcmFtICB7RnVuY3Rpb259ICBpdGVyYXRvciAgVGhlIGl0ZXJhdG9yIGZ1bmN0aW9uXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLkZhdE9zY2lsbGF0b3IucHJvdG90eXBlLl9mb3JFYWNoID0gZnVuY3Rpb24gKGl0ZXJhdG9yKSB7XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9vc2NpbGxhdG9ycy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICBpdGVyYXRvci5jYWxsKHRoaXMsIHRoaXMuX29zY2lsbGF0b3JzW2ldLCBpKTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogVGhlIHR5cGUgb2YgdGhlIGNhcnJpZXIgb3NjaWxsYXRvclxuXHRcdCAqIEBtZW1iZXJPZiBUb25lLkZhdE9zY2lsbGF0b3IjXG5cdFx0ICogQHR5cGUge3N0cmluZ31cblx0XHQgKiBAbmFtZSB0eXBlXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5GYXRPc2NpbGxhdG9yLnByb3RvdHlwZSwgJ3R5cGUnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl90eXBlO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAodHlwZSkge1xuXHQgICAgICAgICAgICB0aGlzLl90eXBlID0gdHlwZTtcblx0ICAgICAgICAgICAgdGhpcy5fZm9yRWFjaChmdW5jdGlvbiAob3NjKSB7XG5cdCAgICAgICAgICAgICAgICBvc2MudHlwZSA9IHR5cGU7XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogVGhlIGRldHVuZSBzcHJlYWQgYmV0d2VlbiB0aGUgb3NjaWxsYXRvcnMuIElmIFwiY291bnRcIiBpc1xuXHRcdCAqIHNldCB0byAzIG9zY2lsbGF0b3JzIGFuZCB0aGUgXCJzcHJlYWRcIiBpcyBzZXQgdG8gNDAsXG5cdFx0ICogdGhlIHRocmVlIG9zY2lsbGF0b3JzIHdvdWxkIGJlIGRldHVuZWQgbGlrZSB0aGlzOiBbLTIwLCAwLCAyMF1cblx0XHQgKiBmb3IgYSB0b3RhbCBkZXR1bmUgc3ByZWFkIG9mIDQwIGNlbnRzLlxuXHRcdCAqIEBtZW1iZXJPZiBUb25lLkZhdE9zY2lsbGF0b3IjXG5cdFx0ICogQHR5cGUge0NlbnRzfVxuXHRcdCAqIEBuYW1lIHNwcmVhZFxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuRmF0T3NjaWxsYXRvci5wcm90b3R5cGUsICdzcHJlYWQnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9zcHJlYWQ7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChzcHJlYWQpIHtcblx0ICAgICAgICAgICAgdGhpcy5fc3ByZWFkID0gc3ByZWFkO1xuXHQgICAgICAgICAgICBpZiAodGhpcy5fb3NjaWxsYXRvcnMubGVuZ3RoID4gMSkge1xuXHQgICAgICAgICAgICAgICAgdmFyIHN0YXJ0ID0gLXNwcmVhZCAvIDI7XG5cdCAgICAgICAgICAgICAgICB2YXIgc3RlcCA9IHNwcmVhZCAvICh0aGlzLl9vc2NpbGxhdG9ycy5sZW5ndGggLSAxKTtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX2ZvckVhY2goZnVuY3Rpb24gKG9zYywgaSkge1xuXHQgICAgICAgICAgICAgICAgICAgIG9zYy5kZXR1bmUudmFsdWUgPSBzdGFydCArIHN0ZXAgKiBpO1xuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqIFRoZSBudW1iZXIgb2YgZGV0dW5lZCBvc2NpbGxhdG9yc1xuXHRcdCAqIEBtZW1iZXJPZiBUb25lLkZhdE9zY2lsbGF0b3IjXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKiBAbmFtZSBjb3VudFxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuRmF0T3NjaWxsYXRvci5wcm90b3R5cGUsICdjb3VudCcsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX29zY2lsbGF0b3JzLmxlbmd0aDtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKGNvdW50KSB7XG5cdCAgICAgICAgICAgIGNvdW50ID0gTWF0aC5tYXgoY291bnQsIDEpO1xuXHQgICAgICAgICAgICBpZiAodGhpcy5fb3NjaWxsYXRvcnMubGVuZ3RoICE9PSBjb3VudCkge1xuXHQgICAgICAgICAgICAgICAgLy8gdmFyIHBhcnRpYWxzID0gdGhpcy5wYXJ0aWFscztcblx0ICAgICAgICAgICAgICAgIC8vIHZhciB0eXBlID0gdGhpcy50eXBlO1xuXHQgICAgICAgICAgICAgICAgLy9kaXNwb3NlIHRoZSBwcmV2aW91cyBvc2NpbGxhdG9yc1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fZm9yRWFjaChmdW5jdGlvbiAob3NjKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgb3NjLmRpc3Bvc2UoKTtcblx0ICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fb3NjaWxsYXRvcnMgPSBbXTtcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBvc2MgPSBuZXcgVG9uZS5Pc2NpbGxhdG9yKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gVG9uZS5Pc2NpbGxhdG9yLlR5cGUuQ3VzdG9tKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG9zYy5wYXJ0aWFscyA9IHRoaXMuX3BhcnRpYWxzO1xuXHQgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG9zYy50eXBlID0gdGhpcy5fdHlwZTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgb3NjLnBoYXNlID0gdGhpcy5fcGhhc2U7XG5cdCAgICAgICAgICAgICAgICAgICAgb3NjLnZvbHVtZS52YWx1ZSA9IC02IC0gY291bnQ7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5mcmVxdWVuY3kuY29ubmVjdChvc2MuZnJlcXVlbmN5KTtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmRldHVuZS5jb25uZWN0KG9zYy5kZXR1bmUpO1xuXHQgICAgICAgICAgICAgICAgICAgIG9zYy5jb25uZWN0KHRoaXMub3V0cHV0KTtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLl9vc2NpbGxhdG9yc1tpXSA9IG9zYztcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIC8vc2V0IHRoZSBzcHJlYWRcblx0ICAgICAgICAgICAgICAgIHRoaXMuc3ByZWFkID0gdGhpcy5fc3ByZWFkO1xuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IFRvbmUuU3RhdGUuU3RhcnRlZCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuX2ZvckVhY2goZnVuY3Rpb24gKG9zYykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBvc2Muc3RhcnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogVGhlIHBoYXNlIG9mIHRoZSBvc2NpbGxhdG9yIGluIGRlZ3JlZXMuXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuRmF0T3NjaWxsYXRvciNcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqIEBuYW1lIHBoYXNlXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5GYXRPc2NpbGxhdG9yLnByb3RvdHlwZSwgJ3BoYXNlJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fcGhhc2U7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChwaGFzZSkge1xuXHQgICAgICAgICAgICB0aGlzLl9waGFzZSA9IHBoYXNlO1xuXHQgICAgICAgICAgICB0aGlzLl9mb3JFYWNoKGZ1bmN0aW9uIChvc2MpIHtcblx0ICAgICAgICAgICAgICAgIG9zYy5waGFzZSA9IHBoYXNlO1xuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqIFRoZSBwYXJ0aWFscyBvZiB0aGUgY2FycmllciB3YXZlZm9ybS4gQSBwYXJ0aWFsIHJlcHJlc2VudHMgXG5cdFx0ICogdGhlIGFtcGxpdHVkZSBhdCBhIGhhcm1vbmljLiBUaGUgZmlyc3QgaGFybW9uaWMgaXMgdGhlIFxuXHRcdCAqIGZ1bmRhbWVudGFsIGZyZXF1ZW5jeSwgdGhlIHNlY29uZCBpcyB0aGUgb2N0YXZlIGFuZCBzbyBvblxuXHRcdCAqIGZvbGxvd2luZyB0aGUgaGFybW9uaWMgc2VyaWVzLiBcblx0XHQgKiBTZXR0aW5nIHRoaXMgdmFsdWUgd2lsbCBhdXRvbWF0aWNhbGx5IHNldCB0aGUgdHlwZSB0byBcImN1c3RvbVwiLiBcblx0XHQgKiBUaGUgdmFsdWUgaXMgYW4gZW1wdHkgYXJyYXkgd2hlbiB0aGUgdHlwZSBpcyBub3QgXCJjdXN0b21cIi4gXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuRmF0T3NjaWxsYXRvciNcblx0XHQgKiBAdHlwZSB7QXJyYXl9XG5cdFx0ICogQG5hbWUgcGFydGlhbHNcblx0XHQgKiBAZXhhbXBsZVxuXHRcdCAqIG9zYy5wYXJ0aWFscyA9IFsxLCAwLjIsIDAuMDFdO1xuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuRmF0T3NjaWxsYXRvci5wcm90b3R5cGUsICdwYXJ0aWFscycsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BhcnRpYWxzO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAocGFydGlhbHMpIHtcblx0ICAgICAgICAgICAgdGhpcy5fcGFydGlhbHMgPSBwYXJ0aWFscztcblx0ICAgICAgICAgICAgdGhpcy5fdHlwZSA9IFRvbmUuT3NjaWxsYXRvci5UeXBlLkN1c3RvbTtcblx0ICAgICAgICAgICAgdGhpcy5fZm9yRWFjaChmdW5jdGlvbiAob3NjKSB7XG5cdCAgICAgICAgICAgICAgICBvc2MucGFydGlhbHMgPSBwYXJ0aWFscztcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgQ2xlYW4gdXAuXG5cdFx0ICogIEByZXR1cm4ge1RvbmUuRmF0T3NjaWxsYXRvcn0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5GYXRPc2NpbGxhdG9yLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuU291cmNlLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgdGhpcy5fd3JpdGFibGUoW1xuXHQgICAgICAgICAgICAnZnJlcXVlbmN5Jyxcblx0ICAgICAgICAgICAgJ2RldHVuZSdcblx0ICAgICAgICBdKTtcblx0ICAgICAgICB0aGlzLmZyZXF1ZW5jeS5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5mcmVxdWVuY3kgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuZGV0dW5lLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLmRldHVuZSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fZm9yRWFjaChmdW5jdGlvbiAob3NjKSB7XG5cdCAgICAgICAgICAgIG9zYy5kaXNwb3NlKCk7XG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgdGhpcy5fb3NjaWxsYXRvcnMgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX3BhcnRpYWxzID0gbnVsbDtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVG9uZS5GYXRPc2NpbGxhdG9yO1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgVG9uZS5PbW5pT3NjaWxsYXRvciBhZ2dyZWdhdGVzIFRvbmUuT3NjaWxsYXRvciwgVG9uZS5QdWxzZU9zY2lsbGF0b3IsXG5cdFx0ICogICAgICAgICBUb25lLlBXTU9zY2lsbGF0b3IsIFRvbmUuRk1Pc2NpbGxhdG9yLCBUb25lLkFNT3NjaWxsYXRvciwgYW5kIFRvbmUuRmF0T3NjaWxsYXRvclxuXHRcdCAqICAgICAgICAgaW50byBvbmUgY2xhc3MuIFRoZSBvc2NpbGxhdG9yIGNsYXNzIGNhbiBiZSBjaGFuZ2VkIGJ5IHNldHRpbmcgdGhlIGB0eXBlYC4gXG5cdFx0ICogICAgICAgICBgb21uaU9zYy50eXBlID0gXCJwd21cImAgd2lsbCBzZXQgaXQgdG8gdGhlIFRvbmUuUFdNT3NjaWxsYXRvci4gUHJlZml4aW5nXG5cdFx0ICogICAgICAgICBhbnkgb2YgdGhlIGJhc2ljIHR5cGVzIChcInNpbmVcIiwgXCJzcXVhcmU0XCIsIGV0Yy4pIHdpdGggXCJmbVwiLCBcImFtXCIsIG9yIFwiZmF0XCJcblx0XHQgKiAgICAgICAgIHdpbGwgdXNlIHRoZSBGTU9zY2lsbGF0b3IsIEFNT3NjaWxsYXRvciBvciBGYXRPc2NpbGxhdG9yIHJlc3BlY3RpdmVseS4gXG5cdFx0ICogICAgICAgICBGb3IgZXhhbXBsZTogYG9tbmlPc2MudHlwZSA9IFwiZmF0c2F3dG9vdGhcImAgd2lsbCBjcmVhdGUgc2V0IHRoZSBvc2NpbGxhdG9yXG5cdFx0ICogICAgICAgICB0byBhIEZhdE9zY2lsbGF0b3Igb2YgdHlwZSBcInNhd3Rvb3RoXCIuIFxuXHRcdCAqXG5cdFx0ICogIEBleHRlbmRzIHtUb25lLlNvdXJjZX1cblx0XHQgKiAgQGNvbnN0cnVjdG9yXG5cdFx0ICogIEBwYXJhbSB7RnJlcXVlbmN5fSBmcmVxdWVuY3kgVGhlIGluaXRpYWwgZnJlcXVlbmN5IG9mIHRoZSBvc2NpbGxhdG9yLlxuXHRcdCAqICBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgdHlwZSBvZiB0aGUgb3NjaWxsYXRvci5cblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgdmFyIG9tbmlPc2MgPSBuZXcgVG9uZS5PbW5pT3NjaWxsYXRvcihcIkMjNFwiLCBcInB3bVwiKTtcblx0XHQgKi9cblx0ICAgIFRvbmUuT21uaU9zY2lsbGF0b3IgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIG9wdGlvbnMgPSBUb25lLmRlZmF1bHRzKGFyZ3VtZW50cywgW1xuXHQgICAgICAgICAgICAnZnJlcXVlbmN5Jyxcblx0ICAgICAgICAgICAgJ3R5cGUnXG5cdCAgICAgICAgXSwgVG9uZS5PbW5pT3NjaWxsYXRvcik7XG5cdCAgICAgICAgVG9uZS5Tb3VyY2UuY2FsbCh0aGlzLCBvcHRpb25zKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgZnJlcXVlbmN5IGNvbnRyb2wuXG5cdFx0XHQgKiAgQHR5cGUge0ZyZXF1ZW5jeX1cblx0XHRcdCAqICBAc2lnbmFsXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmZyZXF1ZW5jeSA9IG5ldyBUb25lLlNpZ25hbChvcHRpb25zLmZyZXF1ZW5jeSwgVG9uZS5UeXBlLkZyZXF1ZW5jeSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGRldHVuZSBjb250cm9sXG5cdFx0XHQgKiAgQHR5cGUge0NlbnRzfVxuXHRcdFx0ICogIEBzaWduYWxcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuZGV0dW5lID0gbmV3IFRvbmUuU2lnbmFsKG9wdGlvbnMuZGV0dW5lLCBUb25lLlR5cGUuQ2VudHMpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHRoZSB0eXBlIG9mIHRoZSBvc2NpbGxhdG9yIHNvdXJjZVxuXHRcdFx0ICogIEB0eXBlIHtTdHJpbmd9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX3NvdXJjZVR5cGUgPSB1bmRlZmluZWQ7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgdGhlIG9zY2lsbGF0b3Jcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5Pc2NpbGxhdG9yfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9vc2NpbGxhdG9yID0gbnVsbDtcblx0ICAgICAgICAvL3NldCB0aGUgb3NjaWxsYXRvclxuXHQgICAgICAgIHRoaXMudHlwZSA9IG9wdGlvbnMudHlwZTtcblx0ICAgICAgICB0aGlzLl9yZWFkT25seShbXG5cdCAgICAgICAgICAgICdmcmVxdWVuY3knLFxuXHQgICAgICAgICAgICAnZGV0dW5lJ1xuXHQgICAgICAgIF0pO1xuXHQgICAgICAgIC8vc2V0IHRoZSBvcHRpb25zXG5cdCAgICAgICAgdGhpcy5zZXQob3B0aW9ucyk7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5PbW5pT3NjaWxsYXRvciwgVG9uZS5Tb3VyY2UpO1xuXHQgICAgLyoqXG5cdFx0ICogIGRlZmF1bHQgdmFsdWVzXG5cdFx0ICogIEBzdGF0aWNcblx0XHQgKiAgQHR5cGUge09iamVjdH1cblx0XHQgKiAgQGNvbnN0XG5cdFx0ICovXG5cdCAgICBUb25lLk9tbmlPc2NpbGxhdG9yLmRlZmF1bHRzID0ge1xuXHQgICAgICAgICdmcmVxdWVuY3knOiA0NDAsXG5cdCAgICAgICAgJ2RldHVuZSc6IDAsXG5cdCAgICAgICAgJ3R5cGUnOiAnc2luZScsXG5cdCAgICAgICAgJ3BoYXNlJzogMFxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBAZW51bSB7U3RyaW5nfVxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgdmFyIE9tbmlPc2NUeXBlID0ge1xuXHQgICAgICAgIFB1bHNlOiAnUHVsc2VPc2NpbGxhdG9yJyxcblx0ICAgICAgICBQV006ICdQV01Pc2NpbGxhdG9yJyxcblx0ICAgICAgICBPc2M6ICdPc2NpbGxhdG9yJyxcblx0ICAgICAgICBGTTogJ0ZNT3NjaWxsYXRvcicsXG5cdCAgICAgICAgQU06ICdBTU9zY2lsbGF0b3InLFxuXHQgICAgICAgIEZhdDogJ0ZhdE9zY2lsbGF0b3InXG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIHN0YXJ0IHRoZSBvc2NpbGxhdG9yXG5cdFx0ICogIEBwYXJhbSB7VGltZX0gW3RpbWU9bm93XSB0aGUgdGltZSB0byBzdGFydCB0aGUgb3NjaWxsYXRvclxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5PbW5pT3NjaWxsYXRvci5wcm90b3R5cGUuX3N0YXJ0ID0gZnVuY3Rpb24gKHRpbWUpIHtcblx0ICAgICAgICB0aGlzLl9vc2NpbGxhdG9yLnN0YXJ0KHRpbWUpO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBzdGFydCB0aGUgb3NjaWxsYXRvclxuXHRcdCAqICBAcGFyYW0ge1RpbWV9IFt0aW1lPW5vd10gdGhlIHRpbWUgdG8gc3RhcnQgdGhlIG9zY2lsbGF0b3Jcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuT21uaU9zY2lsbGF0b3IucHJvdG90eXBlLl9zdG9wID0gZnVuY3Rpb24gKHRpbWUpIHtcblx0ICAgICAgICB0aGlzLl9vc2NpbGxhdG9yLnN0b3AodGltZSk7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogVGhlIHR5cGUgb2YgdGhlIG9zY2lsbGF0b3IuIENhbiBiZSBhbnkgb2YgdGhlIGJhc2ljIHR5cGVzOiBzaW5lLCBzcXVhcmUsIHRyaWFuZ2xlLCBzYXd0b290aC4gT3Jcblx0XHQgKiBwcmVmaXggdGhlIGJhc2ljIHR5cGVzIHdpdGggXCJmbVwiLCBcImFtXCIsIG9yIFwiZmF0XCIgdG8gdXNlIHRoZSBGTU9zY2lsbGF0b3IsIEFNT3NjaWxsYXRvciBvciBGYXRPc2NpbGxhdG9yXG5cdFx0ICogdHlwZXMuIFRoZSBvc2NpbGxhdG9yIGNvdWxkIGFsc28gYmUgc2V0IHRvIFwicHdtXCIgb3IgXCJwdWxzZVwiLiBBbGwgb2YgdGhlIHBhcmFtZXRlcnMgb2YgdGhlXG5cdFx0ICogb3NjaWxsYXRvcidzIGNsYXNzIGFyZSBhY2Nlc3NpYmxlIHdoZW4gdGhlIG9zY2lsbGF0b3IgaXMgc2V0IHRvIHRoYXQgdHlwZSwgYnV0IHRocm93cyBhbiBlcnJvciBcblx0XHQgKiB3aGVuIGl0J3Mgbm90LlxuXHRcdCAqIFxuXHRcdCAqIEBtZW1iZXJPZiBUb25lLk9tbmlPc2NpbGxhdG9yI1xuXHRcdCAqIEB0eXBlIHtTdHJpbmd9XG5cdFx0ICogQG5hbWUgdHlwZVxuXHRcdCAqIEBleGFtcGxlXG5cdFx0ICogb21uaU9zYy50eXBlID0gXCJwd21cIjtcblx0XHQgKiAvL21vZHVsYXRpb25GcmVxdWVuY3kgaXMgcGFyYW1ldGVyIHdoaWNoIGlzIGF2YWlsYWJsZVxuXHRcdCAqIC8vb25seSB3aGVuIHRoZSB0eXBlIGlzIFwicHdtXCIuIFxuXHRcdCAqIG9tbmlPc2MubW9kdWxhdGlvbkZyZXF1ZW5jeS52YWx1ZSA9IDAuNTtcblx0XHQgKiBAZXhhbXBsZVxuXHRcdCAqIC8vYW4gc3F1YXJlIHdhdmUgZnJlcXVlbmN5IG1vZHVsYXRlZCBieSBhIHNhd3Rvb3RoXG5cdFx0ICogb21uaU9zYy50eXBlID0gXCJmbXNxdWFyZVwiO1xuXHRcdCAqIG9tbmlPc2MubW9kdWxhdGlvblR5cGUgPSBcInNhd3Rvb3RoXCI7XG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5PbW5pT3NjaWxsYXRvci5wcm90b3R5cGUsICd0eXBlJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgcHJlZml4ID0gJyc7XG5cdCAgICAgICAgICAgIGlmICh0aGlzLl9zb3VyY2VUeXBlID09PSBPbW5pT3NjVHlwZS5GTSkge1xuXHQgICAgICAgICAgICAgICAgcHJlZml4ID0gJ2ZtJztcblx0ICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9zb3VyY2VUeXBlID09PSBPbW5pT3NjVHlwZS5BTSkge1xuXHQgICAgICAgICAgICAgICAgcHJlZml4ID0gJ2FtJztcblx0ICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9zb3VyY2VUeXBlID09PSBPbW5pT3NjVHlwZS5GYXQpIHtcblx0ICAgICAgICAgICAgICAgIHByZWZpeCA9ICdmYXQnO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiBwcmVmaXggKyB0aGlzLl9vc2NpbGxhdG9yLnR5cGU7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uICh0eXBlKSB7XG5cdCAgICAgICAgICAgIGlmICh0eXBlLnN1YnN0cigwLCAyKSA9PT0gJ2ZtJykge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fY3JlYXRlTmV3T3NjaWxsYXRvcihPbW5pT3NjVHlwZS5GTSk7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9vc2NpbGxhdG9yLnR5cGUgPSB0eXBlLnN1YnN0cigyKTtcblx0ICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlLnN1YnN0cigwLCAyKSA9PT0gJ2FtJykge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fY3JlYXRlTmV3T3NjaWxsYXRvcihPbW5pT3NjVHlwZS5BTSk7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9vc2NpbGxhdG9yLnR5cGUgPSB0eXBlLnN1YnN0cigyKTtcblx0ICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlLnN1YnN0cigwLCAzKSA9PT0gJ2ZhdCcpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX2NyZWF0ZU5ld09zY2lsbGF0b3IoT21uaU9zY1R5cGUuRmF0KTtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX29zY2lsbGF0b3IudHlwZSA9IHR5cGUuc3Vic3RyKDMpO1xuXHQgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdwd20nKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9jcmVhdGVOZXdPc2NpbGxhdG9yKE9tbmlPc2NUeXBlLlBXTSk7XG5cdCAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3B1bHNlJykge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fY3JlYXRlTmV3T3NjaWxsYXRvcihPbW5pT3NjVHlwZS5QdWxzZSk7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9jcmVhdGVOZXdPc2NpbGxhdG9yKE9tbmlPc2NUeXBlLk9zYyk7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9vc2NpbGxhdG9yLnR5cGUgPSB0eXBlO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiBUaGUgcGFydGlhbHMgb2YgdGhlIHdhdmVmb3JtLiBBIHBhcnRpYWwgcmVwcmVzZW50cyBcblx0XHQgKiB0aGUgYW1wbGl0dWRlIGF0IGEgaGFybW9uaWMuIFRoZSBmaXJzdCBoYXJtb25pYyBpcyB0aGUgXG5cdFx0ICogZnVuZGFtZW50YWwgZnJlcXVlbmN5LCB0aGUgc2Vjb25kIGlzIHRoZSBvY3RhdmUgYW5kIHNvIG9uXG5cdFx0ICogZm9sbG93aW5nIHRoZSBoYXJtb25pYyBzZXJpZXMuIFxuXHRcdCAqIFNldHRpbmcgdGhpcyB2YWx1ZSB3aWxsIGF1dG9tYXRpY2FsbHkgc2V0IHRoZSB0eXBlIHRvIFwiY3VzdG9tXCIuIFxuXHRcdCAqIFRoZSB2YWx1ZSBpcyBhbiBlbXB0eSBhcnJheSB3aGVuIHRoZSB0eXBlIGlzIG5vdCBcImN1c3RvbVwiLiBcblx0XHQgKiBUaGlzIGlzIG5vdCBhdmFpbGFibGUgb24gXCJwd21cIiBhbmQgXCJwdWxzZVwiIG9zY2lsbGF0b3IgdHlwZXMuXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuT21uaU9zY2lsbGF0b3IjXG5cdFx0ICogQHR5cGUge0FycmF5fVxuXHRcdCAqIEBuYW1lIHBhcnRpYWxzXG5cdFx0ICogQGV4YW1wbGVcblx0XHQgKiBvc2MucGFydGlhbHMgPSBbMSwgMC4yLCAwLjAxXTtcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLk9tbmlPc2NpbGxhdG9yLnByb3RvdHlwZSwgJ3BhcnRpYWxzJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fb3NjaWxsYXRvci5wYXJ0aWFscztcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKHBhcnRpYWxzKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX29zY2lsbGF0b3IucGFydGlhbHMgPSBwYXJ0aWFscztcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBTZXQgYSBtZW1iZXIvYXR0cmlidXRlIG9mIHRoZSBvc2NpbGxhdG9yLiBcblx0XHQgKiAgQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBwYXJhbXNcblx0XHQgKiAgQHBhcmFtIHtudW1iZXI9fSB2YWx1ZVxuXHRcdCAqICBAcGFyYW0ge1RpbWU9fSByYW1wVGltZVxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5PbW5pT3NjaWxsYXRvcn0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5PbW5pT3NjaWxsYXRvci5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKHBhcmFtcywgdmFsdWUpIHtcblx0ICAgICAgICAvL21ha2Ugc3VyZSB0aGUgdHlwZSBpcyBzZXQgZmlyc3Rcblx0ICAgICAgICBpZiAocGFyYW1zID09PSAndHlwZScpIHtcblx0ICAgICAgICAgICAgdGhpcy50eXBlID0gdmFsdWU7XG5cdCAgICAgICAgfSBlbHNlIGlmIChUb25lLmlzT2JqZWN0KHBhcmFtcykgJiYgcGFyYW1zLmhhc093blByb3BlcnR5KCd0eXBlJykpIHtcblx0ICAgICAgICAgICAgdGhpcy50eXBlID0gcGFyYW1zLnR5cGU7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8vdGhlbiBzZXQgdGhlIHJlc3Rcblx0ICAgICAgICBUb25lLnByb3RvdHlwZS5zZXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgY29ubmVjdCB0aGUgb3NjaWxsYXRvciB0byB0aGUgZnJlcXVlbmN5IGFuZCBkZXR1bmUgc2lnbmFsc1xuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5PbW5pT3NjaWxsYXRvci5wcm90b3R5cGUuX2NyZWF0ZU5ld09zY2lsbGF0b3IgPSBmdW5jdGlvbiAob3NjVHlwZSkge1xuXHQgICAgICAgIGlmIChvc2NUeXBlICE9PSB0aGlzLl9zb3VyY2VUeXBlKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3NvdXJjZVR5cGUgPSBvc2NUeXBlO1xuXHQgICAgICAgICAgICB2YXIgT3NjaWxsYXRvckNvbnN0cnVjdG9yID0gVG9uZVtvc2NUeXBlXTtcblx0ICAgICAgICAgICAgLy9zaG9ydCBkZWxheSB0byBhdm9pZCBjbGlja3Mgb24gdGhlIGNoYW5nZVxuXHQgICAgICAgICAgICB2YXIgbm93ID0gdGhpcy5ub3coKTtcblx0ICAgICAgICAgICAgaWYgKHRoaXMuX29zY2lsbGF0b3IgIT09IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBvbGRPc2MgPSB0aGlzLl9vc2NpbGxhdG9yO1xuXHQgICAgICAgICAgICAgICAgb2xkT3NjLnN0b3Aobm93KTtcblx0ICAgICAgICAgICAgICAgIC8vZGlzcG9zZSB0aGUgb2xkIG9uZVxuXHQgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgICAgIG9sZE9zYy5kaXNwb3NlKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgb2xkT3NjID0gbnVsbDtcblx0ICAgICAgICAgICAgICAgIH0sIHRoaXMuYmxvY2tUaW1lKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB0aGlzLl9vc2NpbGxhdG9yID0gbmV3IE9zY2lsbGF0b3JDb25zdHJ1Y3RvcigpO1xuXHQgICAgICAgICAgICB0aGlzLmZyZXF1ZW5jeS5jb25uZWN0KHRoaXMuX29zY2lsbGF0b3IuZnJlcXVlbmN5KTtcblx0ICAgICAgICAgICAgdGhpcy5kZXR1bmUuY29ubmVjdCh0aGlzLl9vc2NpbGxhdG9yLmRldHVuZSk7XG5cdCAgICAgICAgICAgIHRoaXMuX29zY2lsbGF0b3IuY29ubmVjdCh0aGlzLm91dHB1dCk7XG5cdCAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlID09PSBUb25lLlN0YXRlLlN0YXJ0ZWQpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX29zY2lsbGF0b3Iuc3RhcnQobm93KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiBUaGUgcGhhc2Ugb2YgdGhlIG9zY2lsbGF0b3IgaW4gZGVncmVlcy4gXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuT21uaU9zY2lsbGF0b3IjXG5cdFx0ICogQHR5cGUge0RlZ3JlZXN9XG5cdFx0ICogQG5hbWUgcGhhc2Vcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLk9tbmlPc2NpbGxhdG9yLnByb3RvdHlwZSwgJ3BoYXNlJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fb3NjaWxsYXRvci5waGFzZTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKHBoYXNlKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX29zY2lsbGF0b3IucGhhc2UgPSBwaGFzZTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqIFRoZSB3aWR0aCBvZiB0aGUgb3NjaWxsYXRvciAob25seSBpZiB0aGUgb3NjaWxsYXRvciBpcyBzZXQgdG8gXCJwdWxzZVwiKVxuXHRcdCAqIEBtZW1iZXJPZiBUb25lLk9tbmlPc2NpbGxhdG9yI1xuXHRcdCAqIEB0eXBlIHtOb3JtYWxSYW5nZX1cblx0XHQgKiBAc2lnbmFsXG5cdFx0ICogQG5hbWUgd2lkdGhcblx0XHQgKiBAZXhhbXBsZVxuXHRcdCAqIHZhciBvbW5pT3NjID0gbmV3IFRvbmUuT21uaU9zY2lsbGF0b3IoNDQwLCBcInB1bHNlXCIpO1xuXHRcdCAqIC8vY2FuIGFjY2VzcyB0aGUgd2lkdGggYXR0cmlidXRlIG9ubHkgaWYgdHlwZSA9PT0gXCJwdWxzZVwiXG5cdFx0ICogb21uaU9zYy53aWR0aC52YWx1ZSA9IDAuMjsgXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5PbW5pT3NjaWxsYXRvci5wcm90b3R5cGUsICd3aWR0aCcsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgaWYgKHRoaXMuX3NvdXJjZVR5cGUgPT09IE9tbmlPc2NUeXBlLlB1bHNlKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fb3NjaWxsYXRvci53aWR0aDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogVGhlIG51bWJlciBvZiBkZXR1bmVkIG9zY2lsbGF0b3JzXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuT21uaU9zY2lsbGF0b3IjXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKiBAbmFtZSBjb3VudFxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuT21uaU9zY2lsbGF0b3IucHJvdG90eXBlLCAnY291bnQnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIGlmICh0aGlzLl9zb3VyY2VUeXBlID09PSBPbW5pT3NjVHlwZS5GYXQpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9vc2NpbGxhdG9yLmNvdW50O1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChjb3VudCkge1xuXHQgICAgICAgICAgICBpZiAodGhpcy5fc291cmNlVHlwZSA9PT0gT21uaU9zY1R5cGUuRmF0KSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9vc2NpbGxhdG9yLmNvdW50ID0gY291bnQ7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqIFRoZSBkZXR1bmUgc3ByZWFkIGJldHdlZW4gdGhlIG9zY2lsbGF0b3JzLiBJZiBcImNvdW50XCIgaXNcblx0XHQgKiBzZXQgdG8gMyBvc2NpbGxhdG9ycyBhbmQgdGhlIFwic3ByZWFkXCIgaXMgc2V0IHRvIDQwLFxuXHRcdCAqIHRoZSB0aHJlZSBvc2NpbGxhdG9ycyB3b3VsZCBiZSBkZXR1bmVkIGxpa2UgdGhpczogWy0yMCwgMCwgMjBdXG5cdFx0ICogZm9yIGEgdG90YWwgZGV0dW5lIHNwcmVhZCBvZiA0MCBjZW50cy4gU2VlIFRvbmUuRmF0T3NjaWxsYXRvclxuXHRcdCAqIGZvciBtb3JlIGluZm8uXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuT21uaU9zY2lsbGF0b3IjXG5cdFx0ICogQHR5cGUge0NlbnRzfVxuXHRcdCAqIEBuYW1lIHNwcmVhZFxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuT21uaU9zY2lsbGF0b3IucHJvdG90eXBlLCAnc3ByZWFkJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICBpZiAodGhpcy5fc291cmNlVHlwZSA9PT0gT21uaU9zY1R5cGUuRmF0KSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fb3NjaWxsYXRvci5zcHJlYWQ7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKHNwcmVhZCkge1xuXHQgICAgICAgICAgICBpZiAodGhpcy5fc291cmNlVHlwZSA9PT0gT21uaU9zY1R5cGUuRmF0KSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9vc2NpbGxhdG9yLnNwcmVhZCA9IHNwcmVhZDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogVGhlIHR5cGUgb2YgdGhlIG1vZHVsYXRvciBvc2NpbGxhdG9yLiBPbmx5IGlmIHRoZSBvc2NpbGxhdG9yXG5cdFx0ICogaXMgc2V0IHRvIFwiYW1cIiBvciBcImZtXCIgdHlwZXMuIHNlZS4gVG9uZS5BTU9zY2lsbGF0b3Igb3IgVG9uZS5GTU9zY2lsbGF0b3Jcblx0XHQgKiBmb3IgbW9yZSBpbmZvLiBcblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5PbW5pT3NjaWxsYXRvciNcblx0XHQgKiBAdHlwZSB7U3RyaW5nfVxuXHRcdCAqIEBuYW1lIG1vZHVsYXRpb25UeXBlXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5PbW5pT3NjaWxsYXRvci5wcm90b3R5cGUsICdtb2R1bGF0aW9uVHlwZScsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgaWYgKHRoaXMuX3NvdXJjZVR5cGUgPT09IE9tbmlPc2NUeXBlLkZNIHx8IHRoaXMuX3NvdXJjZVR5cGUgPT09IE9tbmlPc2NUeXBlLkFNKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fb3NjaWxsYXRvci5tb2R1bGF0aW9uVHlwZTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAobVR5cGUpIHtcblx0ICAgICAgICAgICAgaWYgKHRoaXMuX3NvdXJjZVR5cGUgPT09IE9tbmlPc2NUeXBlLkZNIHx8IHRoaXMuX3NvdXJjZVR5cGUgPT09IE9tbmlPc2NUeXBlLkFNKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9vc2NpbGxhdG9yLm1vZHVsYXRpb25UeXBlID0gbVR5cGU7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqIFRoZSBtb2R1bGF0aW9uIGluZGV4IHdoaWNoIGlzIGluIGVzc2VuY2UgdGhlIGRlcHRoIG9yIGFtb3VudCBvZiB0aGUgbW9kdWxhdGlvbi4gSW4gb3RoZXIgdGVybXMgaXQgaXMgdGhlIFxuXHRcdCAqIHJhdGlvIG9mIHRoZSBmcmVxdWVuY3kgb2YgdGhlIG1vZHVsYXRpbmcgc2lnbmFsIChtZikgdG8gdGhlIGFtcGxpdHVkZSBvZiB0aGUgXG5cdFx0ICogbW9kdWxhdGluZyBzaWduYWwgKG1hKSAtLSBhcyBpbiBtYS9tZi4gXG5cdFx0ICogU2VlIFRvbmUuRk1Pc2NpbGxhdG9yIGZvciBtb3JlIGluZm8uIFxuXHRcdCAqIEB0eXBlIHtQb3NpdGl2ZX1cblx0XHQgKiBAc2lnbmFsXG5cdFx0ICogQG5hbWUgbW9kdWxhdGlvbkluZGV4XG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5PbW5pT3NjaWxsYXRvci5wcm90b3R5cGUsICdtb2R1bGF0aW9uSW5kZXgnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIGlmICh0aGlzLl9zb3VyY2VUeXBlID09PSBPbW5pT3NjVHlwZS5GTSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX29zY2lsbGF0b3IubW9kdWxhdGlvbkluZGV4O1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgSGFybW9uaWNpdHkgaXMgdGhlIGZyZXF1ZW5jeSByYXRpbyBiZXR3ZWVuIHRoZSBjYXJyaWVyIGFuZCB0aGUgbW9kdWxhdG9yIG9zY2lsbGF0b3JzLiBcblx0XHQgKiAgQSBoYXJtb25pY2l0eSBvZiAxIGdpdmVzIGJvdGggb3NjaWxsYXRvcnMgdGhlIHNhbWUgZnJlcXVlbmN5LiBcblx0XHQgKiAgSGFybW9uaWNpdHkgPSAyIG1lYW5zIGEgY2hhbmdlIG9mIGFuIG9jdGF2ZS4gU2VlIFRvbmUuQU1Pc2NpbGxhdG9yIG9yIFRvbmUuRk1Pc2NpbGxhdG9yXG5cdFx0ICogIGZvciBtb3JlIGluZm8uIFxuXHRcdCAqICBAbWVtYmVyT2YgVG9uZS5PbW5pT3NjaWxsYXRvciNcblx0XHQgKiAgQHNpZ25hbFxuXHRcdCAqICBAdHlwZSB7UG9zaXRpdmV9XG5cdFx0ICogIEBuYW1lIGhhcm1vbmljaXR5XG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5PbW5pT3NjaWxsYXRvci5wcm90b3R5cGUsICdoYXJtb25pY2l0eScsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgaWYgKHRoaXMuX3NvdXJjZVR5cGUgPT09IE9tbmlPc2NUeXBlLkZNIHx8IHRoaXMuX3NvdXJjZVR5cGUgPT09IE9tbmlPc2NUeXBlLkFNKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fb3NjaWxsYXRvci5oYXJtb25pY2l0eTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogVGhlIG1vZHVsYXRpb25GcmVxdWVuY3kgU2lnbmFsIG9mIHRoZSBvc2NpbGxhdG9yIFxuXHRcdCAqIChvbmx5IGlmIHRoZSBvc2NpbGxhdG9yIHR5cGUgaXMgc2V0IHRvIHB3bSkuIFNlZSBcblx0XHQgKiBUb25lLlBXTU9zY2lsbGF0b3IgZm9yIG1vcmUgaW5mby4gXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuT21uaU9zY2lsbGF0b3IjXG5cdFx0ICogQHR5cGUge0ZyZXF1ZW5jeX1cblx0XHQgKiBAc2lnbmFsXG5cdFx0ICogQG5hbWUgbW9kdWxhdGlvbkZyZXF1ZW5jeVxuXHRcdCAqIEBleGFtcGxlXG5cdFx0ICogdmFyIG9tbmlPc2MgPSBuZXcgVG9uZS5PbW5pT3NjaWxsYXRvcig0NDAsIFwicHdtXCIpO1xuXHRcdCAqIC8vY2FuIGFjY2VzcyB0aGUgbW9kdWxhdGlvbkZyZXF1ZW5jeSBhdHRyaWJ1dGUgb25seSBpZiB0eXBlID09PSBcInB3bVwiXG5cdFx0ICogb21uaU9zYy5tb2R1bGF0aW9uRnJlcXVlbmN5LnZhbHVlID0gMC4yOyBcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLk9tbmlPc2NpbGxhdG9yLnByb3RvdHlwZSwgJ21vZHVsYXRpb25GcmVxdWVuY3knLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIGlmICh0aGlzLl9zb3VyY2VUeXBlID09PSBPbW5pT3NjVHlwZS5QV00pIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9vc2NpbGxhdG9yLm1vZHVsYXRpb25GcmVxdWVuY3k7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBDbGVhbiB1cC5cblx0XHQgKiAgQHJldHVybiB7VG9uZS5PbW5pT3NjaWxsYXRvcn0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5PbW5pT3NjaWxsYXRvci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLlNvdXJjZS5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuX3dyaXRhYmxlKFtcblx0ICAgICAgICAgICAgJ2ZyZXF1ZW5jeScsXG5cdCAgICAgICAgICAgICdkZXR1bmUnXG5cdCAgICAgICAgXSk7XG5cdCAgICAgICAgdGhpcy5kZXR1bmUuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuZGV0dW5lID0gbnVsbDtcblx0ICAgICAgICB0aGlzLmZyZXF1ZW5jeS5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5mcmVxdWVuY3kgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX29zY2lsbGF0b3IuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX29zY2lsbGF0b3IgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX3NvdXJjZVR5cGUgPSBudWxsO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLk9tbmlPc2NpbGxhdG9yO1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgIEJhc2UtY2xhc3MgZm9yIGFsbCBpbnN0cnVtZW50c1xuXHRcdCAqXG5cdFx0ICogIEBjb25zdHJ1Y3RvclxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZS5BdWRpb05vZGV9XG5cdFx0ICovXG5cdCAgICBUb25lLkluc3RydW1lbnQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuXHQgICAgICAgIC8vZ2V0IHRoZSBkZWZhdWx0c1xuXHQgICAgICAgIG9wdGlvbnMgPSBUb25lLmRlZmF1bHRBcmcob3B0aW9ucywgVG9uZS5JbnN0cnVtZW50LmRlZmF1bHRzKTtcblx0ICAgICAgICBUb25lLkF1ZGlvTm9kZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBvdXRwdXQgYW5kIHZvbHVtZSB0cmltaW5nIG5vZGVcblx0XHRcdCAqICBAdHlwZSAge1RvbmUuVm9sdW1lfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl92b2x1bWUgPSB0aGlzLm91dHB1dCA9IG5ldyBUb25lLlZvbHVtZShvcHRpb25zLnZvbHVtZSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiBUaGUgdm9sdW1lIG9mIHRoZSBvdXRwdXQgaW4gZGVjaWJlbHMuXG5cdFx0XHQgKiBAdHlwZSB7RGVjaWJlbHN9XG5cdFx0XHQgKiBAc2lnbmFsXG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICogc291cmNlLnZvbHVtZS52YWx1ZSA9IC02O1xuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy52b2x1bWUgPSB0aGlzLl92b2x1bWUudm9sdW1lO1xuXHQgICAgICAgIHRoaXMuX3JlYWRPbmx5KCd2b2x1bWUnKTtcblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLkluc3RydW1lbnQsIFRvbmUuQXVkaW9Ob2RlKTtcblx0ICAgIC8qKlxuXHRcdCAqICB0aGUgZGVmYXVsdCBhdHRyaWJ1dGVzXG5cdFx0ICogIEB0eXBlIHtvYmplY3R9XG5cdFx0ICovXG5cdCAgICBUb25lLkluc3RydW1lbnQuZGVmYXVsdHMgPSB7XG5cdCAgICAgICAgLyoqIHRoZSB2b2x1bWUgb2YgdGhlIG91dHB1dCBpbiBkZWNpYmVscyAqL1xuXHQgICAgICAgICd2b2x1bWUnOiAwXG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIEBhYnN0cmFjdFxuXHRcdCAqICBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IG5vdGUgdGhlIG5vdGUgdG8gdHJpZ2dlclxuXHRcdCAqICBAcGFyYW0ge1RpbWV9IFt0aW1lPW5vd10gdGhlIHRpbWUgdG8gdHJpZ2dlciB0aGUgbnRvZVxuXHRcdCAqICBAcGFyYW0ge251bWJlcn0gW3ZlbG9jaXR5PTFdIHRoZSB2ZWxvY2l0eSB0byB0cmlnZ2VyIHRoZSBub3RlXG5cdFx0ICovXG5cdCAgICBUb25lLkluc3RydW1lbnQucHJvdG90eXBlLnRyaWdnZXJBdHRhY2sgPSBUb25lLm5vT3A7XG5cdCAgICAvKipcblx0XHQgKiAgQGFic3RyYWN0XG5cdFx0ICogIEBwYXJhbSB7VGltZX0gW3RpbWU9bm93XSB3aGVuIHRvIHRyaWdnZXIgdGhlIHJlbGVhc2Vcblx0XHQgKi9cblx0ICAgIFRvbmUuSW5zdHJ1bWVudC5wcm90b3R5cGUudHJpZ2dlclJlbGVhc2UgPSBUb25lLm5vT3A7XG5cdCAgICAvKipcblx0XHQgKiAgVHJpZ2dlciB0aGUgYXR0YWNrIGFuZCB0aGVuIHRoZSByZWxlYXNlIGFmdGVyIHRoZSBkdXJhdGlvbi5cblx0XHQgKiAgQHBhcmFtICB7RnJlcXVlbmN5fSBub3RlICAgICBUaGUgbm90ZSB0byB0cmlnZ2VyLlxuXHRcdCAqICBAcGFyYW0gIHtUaW1lfSBkdXJhdGlvbiBIb3cgbG9uZyB0aGUgbm90ZSBzaG91bGQgYmUgaGVsZCBmb3IgYmVmb3JlXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgIHRyaWdnZXJpbmcgdGhlIHJlbGVhc2UuIFRoaXMgdmFsdWUgbXVzdCBiZSBncmVhdGVyIHRoYW4gMC5cblx0XHQgKiAgQHBhcmFtIHtUaW1lfSBbdGltZT1ub3ddICBXaGVuIHRoZSBub3RlIHNob3VsZCBiZSB0cmlnZ2VyZWQuXG5cdFx0ICogIEBwYXJhbSAge05vcm1hbFJhbmdlfSBbdmVsb2NpdHk9MV0gVGhlIHZlbG9jaXR5IHRoZSBub3RlIHNob3VsZCBiZSB0cmlnZ2VyZWQgYXQuXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLkluc3RydW1lbnR9IHRoaXNcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAvL3RyaWdnZXIgXCJDNFwiIGZvciB0aGUgZHVyYXRpb24gb2YgYW4gOHRoIG5vdGVcblx0XHQgKiBzeW50aC50cmlnZ2VyQXR0YWNrUmVsZWFzZShcIkM0XCIsIFwiOG5cIik7XG5cdFx0ICovXG5cdCAgICBUb25lLkluc3RydW1lbnQucHJvdG90eXBlLnRyaWdnZXJBdHRhY2tSZWxlYXNlID0gZnVuY3Rpb24gKG5vdGUsIGR1cmF0aW9uLCB0aW1lLCB2ZWxvY2l0eSkge1xuXHQgICAgICAgIHRpbWUgPSB0aGlzLnRvU2Vjb25kcyh0aW1lKTtcblx0ICAgICAgICBkdXJhdGlvbiA9IHRoaXMudG9TZWNvbmRzKGR1cmF0aW9uKTtcblx0ICAgICAgICB0aGlzLnRyaWdnZXJBdHRhY2sobm90ZSwgdGltZSwgdmVsb2NpdHkpO1xuXHQgICAgICAgIHRoaXMudHJpZ2dlclJlbGVhc2UodGltZSArIGR1cmF0aW9uKTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgY2xlYW4gdXBcblx0XHQgKiAgQHJldHVybnMge1RvbmUuSW5zdHJ1bWVudH0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5JbnN0cnVtZW50LnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuQXVkaW9Ob2RlLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgdGhpcy5fdm9sdW1lLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl92b2x1bWUgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX3dyaXRhYmxlKFsndm9sdW1lJ10pO1xuXHQgICAgICAgIHRoaXMudm9sdW1lID0gbnVsbDtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVG9uZS5JbnN0cnVtZW50O1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgIFRoaXMgaXMgYW4gYWJzdHJhY3QgYmFzZSBjbGFzcyBmb3Igb3RoZXIgbW9ub3Bob25pYyBpbnN0cnVtZW50cyB0byBcblx0XHQgKiAgICAgICAgICBleHRlbmQuIElNUE9SVEFOVDogSXQgZG9lcyBub3QgbWFrZSBhbnkgc291bmQgb24gaXRzIG93biBhbmRcblx0XHQgKiAgICAgICAgICBzaG91bGRuJ3QgYmUgZGlyZWN0bHkgaW5zdGFudGlhdGVkLlxuXHRcdCAqXG5cdFx0ICogIEBjb25zdHJ1Y3RvclxuXHRcdCAqICBAYWJzdHJhY3Rcblx0XHQgKiAgQGV4dGVuZHMge1RvbmUuSW5zdHJ1bWVudH1cblx0XHQgKi9cblx0ICAgIFRvbmUuTW9ub3Bob25pYyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG5cdCAgICAgICAgLy9nZXQgdGhlIGRlZmF1bHRzXG5cdCAgICAgICAgb3B0aW9ucyA9IFRvbmUuZGVmYXVsdEFyZyhvcHRpb25zLCBUb25lLk1vbm9waG9uaWMuZGVmYXVsdHMpO1xuXHQgICAgICAgIFRvbmUuSW5zdHJ1bWVudC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBnbGlkZSB0aW1lIGJldHdlZW4gbm90ZXMuIFxuXHRcdFx0ICogIEB0eXBlIHtUaW1lfVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5wb3J0YW1lbnRvID0gb3B0aW9ucy5wb3J0YW1lbnRvO1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuTW9ub3Bob25pYywgVG9uZS5JbnN0cnVtZW50KTtcblx0ICAgIC8qKlxuXHRcdCAqICBAc3RhdGljXG5cdFx0ICogIEBjb25zdFxuXHRcdCAqICBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqL1xuXHQgICAgVG9uZS5Nb25vcGhvbmljLmRlZmF1bHRzID0geyAncG9ydGFtZW50byc6IDAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBUcmlnZ2VyIHRoZSBhdHRhY2sgb2YgdGhlIG5vdGUgb3B0aW9uYWxseSB3aXRoIGEgZ2l2ZW4gdmVsb2NpdHkuIFxuXHRcdCAqICBcblx0XHQgKiAgXG5cdFx0ICogIEBwYXJhbSAge0ZyZXF1ZW5jeX0gbm90ZSAgICAgVGhlIG5vdGUgdG8gdHJpZ2dlci5cblx0XHQgKiAgQHBhcmFtICB7VGltZX0gW3RpbWU9bm93XSAgICAgV2hlbiB0aGUgbm90ZSBzaG91bGQgc3RhcnQuXG5cdFx0ICogIEBwYXJhbSAge251bWJlcn0gW3ZlbG9jaXR5PTFdIHZlbG9jaXR5IFRoZSB2ZWxvY2l0eSBzY2FsZXIgXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRldGVybWluZXMgaG93IFwibG91ZFwiIHRoZSBub3RlIFxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWxsIGJlIHRyaWdnZXJlZC5cblx0XHQgKiAgQHJldHVybnMge1RvbmUuTW9ub3Bob25pY30gdGhpc1xuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIHN5bnRoLnRyaWdnZXJBdHRhY2soXCJDNFwiKTtcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAvL3RyaWdnZXIgdGhlIG5vdGUgYSBoYWxmIHNlY29uZCBmcm9tIG5vdyBhdCBoYWxmIHZlbG9jaXR5XG5cdFx0ICogc3ludGgudHJpZ2dlckF0dGFjayhcIkM0XCIsIFwiKzAuNVwiLCAwLjUpO1xuXHRcdCAqL1xuXHQgICAgVG9uZS5Nb25vcGhvbmljLnByb3RvdHlwZS50cmlnZ2VyQXR0YWNrID0gZnVuY3Rpb24gKG5vdGUsIHRpbWUsIHZlbG9jaXR5KSB7XG5cdCAgICAgICAgdGltZSA9IHRoaXMudG9TZWNvbmRzKHRpbWUpO1xuXHQgICAgICAgIHRoaXMuX3RyaWdnZXJFbnZlbG9wZUF0dGFjayh0aW1lLCB2ZWxvY2l0eSk7XG5cdCAgICAgICAgdGhpcy5zZXROb3RlKG5vdGUsIHRpbWUpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBUcmlnZ2VyIHRoZSByZWxlYXNlIHBvcnRpb24gb2YgdGhlIGVudmVsb3BlXG5cdFx0ICogIEBwYXJhbSAge1RpbWV9IFt0aW1lPW5vd10gSWYgbm8gdGltZSBpcyBnaXZlbiwgdGhlIHJlbGVhc2UgaGFwcGVucyBpbW1lZGlhdGx5XG5cdFx0ICogIEByZXR1cm5zIHtUb25lLk1vbm9waG9uaWN9IHRoaXNcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiBzeW50aC50cmlnZ2VyUmVsZWFzZSgpO1xuXHRcdCAqL1xuXHQgICAgVG9uZS5Nb25vcGhvbmljLnByb3RvdHlwZS50cmlnZ2VyUmVsZWFzZSA9IGZ1bmN0aW9uICh0aW1lKSB7XG5cdCAgICAgICAgdGltZSA9IHRoaXMudG9TZWNvbmRzKHRpbWUpO1xuXHQgICAgICAgIHRoaXMuX3RyaWdnZXJFbnZlbG9wZVJlbGVhc2UodGltZSk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIG92ZXJyaWRlIHRoaXMgbWV0aG9kIHdpdGggdGhlIGFjdHVhbCBtZXRob2Rcblx0XHQgKiAgQGFic3RyYWN0XG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLk1vbm9waG9uaWMucHJvdG90eXBlLl90cmlnZ2VyRW52ZWxvcGVBdHRhY2sgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIG92ZXJyaWRlIHRoaXMgbWV0aG9kIHdpdGggdGhlIGFjdHVhbCBtZXRob2Rcblx0XHQgKiAgQGFic3RyYWN0XG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLk1vbm9waG9uaWMucHJvdG90eXBlLl90cmlnZ2VyRW52ZWxvcGVSZWxlYXNlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBTZXQgdGhlIG5vdGUgYXQgdGhlIGdpdmVuIHRpbWUuIElmIG5vIHRpbWUgaXMgZ2l2ZW4sIHRoZSBub3RlXG5cdFx0ICogIHdpbGwgc2V0IGltbWVkaWF0ZWx5LiBcblx0XHQgKiAgQHBhcmFtIHtGcmVxdWVuY3l9IG5vdGUgVGhlIG5vdGUgdG8gY2hhbmdlIHRvLlxuXHRcdCAqICBAcGFyYW0gIHtUaW1lfSBbdGltZT1ub3ddIFRoZSB0aW1lIHdoZW4gdGhlIG5vdGUgc2hvdWxkIGJlIHNldC4gXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLk1vbm9waG9uaWN9IHRoaXNcblx0XHQgKiBAZXhhbXBsZVxuXHRcdCAqIC8vY2hhbmdlIHRvIEYjNiBpbiBvbmUgcXVhcnRlciBub3RlIGZyb20gbm93LlxuXHRcdCAqIHN5bnRoLnNldE5vdGUoXCJGIzZcIiwgXCIrNG5cIik7XG5cdFx0ICogQGV4YW1wbGVcblx0XHQgKiAvL2NoYW5nZSB0byBCYjQgcmlnaHQgbm93XG5cdFx0ICogc3ludGguc2V0Tm90ZShcIkJiNFwiKTtcblx0XHQgKi9cblx0ICAgIFRvbmUuTW9ub3Bob25pYy5wcm90b3R5cGUuc2V0Tm90ZSA9IGZ1bmN0aW9uIChub3RlLCB0aW1lKSB7XG5cdCAgICAgICAgdGltZSA9IHRoaXMudG9TZWNvbmRzKHRpbWUpO1xuXHQgICAgICAgIGlmICh0aGlzLnBvcnRhbWVudG8gPiAwKSB7XG5cdCAgICAgICAgICAgIHZhciBjdXJyZW50Tm90ZSA9IHRoaXMuZnJlcXVlbmN5LnZhbHVlO1xuXHQgICAgICAgICAgICB0aGlzLmZyZXF1ZW5jeS5zZXRWYWx1ZUF0VGltZShjdXJyZW50Tm90ZSwgdGltZSk7XG5cdCAgICAgICAgICAgIHZhciBwb3J0VGltZSA9IHRoaXMudG9TZWNvbmRzKHRoaXMucG9ydGFtZW50byk7XG5cdCAgICAgICAgICAgIHRoaXMuZnJlcXVlbmN5LmV4cG9uZW50aWFsUmFtcFRvVmFsdWVBdFRpbWUobm90ZSwgdGltZSArIHBvcnRUaW1lKTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICB0aGlzLmZyZXF1ZW5jeS5zZXRWYWx1ZUF0VGltZShub3RlLCB0aW1lKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuTW9ub3Bob25pYztcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgXG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzICBUb25lLlN5bnRoIGlzIGNvbXBvc2VkIHNpbXBseSBvZiBhIFRvbmUuT21uaU9zY2lsbGF0b3Jcblx0XHQgKiAgICAgICAgICByb3V0ZWQgdGhyb3VnaCBhIFRvbmUuQW1wbGl0dWRlRW52ZWxvcGUuIFxuXHRcdCAqICAgICAgICAgIDxpbWcgc3JjPVwiaHR0cHM6Ly9kb2NzLmdvb2dsZS5jb20vZHJhd2luZ3MvZC8xLTFfMFlXMloxSjJFUEkzNlA4Zk5DTWNaRzdOMXcxR1psdVBzNG9nNGV2by9wdWI/dz0xMTYzJmg9MjMxXCI+XG5cdFx0ICpcblx0XHQgKiAgQGNvbnN0cnVjdG9yXG5cdFx0ICogIEBleHRlbmRzIHtUb25lLk1vbm9waG9uaWN9XG5cdFx0ICogIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gdGhlIG9wdGlvbnMgYXZhaWxhYmxlIGZvciB0aGUgc3ludGggXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgIHNlZSBkZWZhdWx0cyBiZWxvd1xuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIHZhciBzeW50aCA9IG5ldyBUb25lLlN5bnRoKCkudG9NYXN0ZXIoKTtcblx0XHQgKiBzeW50aC50cmlnZ2VyQXR0YWNrUmVsZWFzZShcIkM0XCIsIFwiOG5cIik7XG5cdFx0ICovXG5cdCAgICBUb25lLlN5bnRoID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcblx0ICAgICAgICAvL2dldCB0aGUgZGVmYXVsdHNcblx0ICAgICAgICBvcHRpb25zID0gVG9uZS5kZWZhdWx0QXJnKG9wdGlvbnMsIFRvbmUuU3ludGguZGVmYXVsdHMpO1xuXHQgICAgICAgIFRvbmUuTW9ub3Bob25pYy5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBvc2NpbGxhdG9yLlxuXHRcdFx0ICogIEB0eXBlIHtUb25lLk9tbmlPc2NpbGxhdG9yfVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5vc2NpbGxhdG9yID0gbmV3IFRvbmUuT21uaU9zY2lsbGF0b3Iob3B0aW9ucy5vc2NpbGxhdG9yKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgZnJlcXVlbmN5IGNvbnRyb2wuXG5cdFx0XHQgKiAgQHR5cGUge0ZyZXF1ZW5jeX1cblx0XHRcdCAqICBAc2lnbmFsXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmZyZXF1ZW5jeSA9IHRoaXMub3NjaWxsYXRvci5mcmVxdWVuY3k7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGRldHVuZSBjb250cm9sLlxuXHRcdFx0ICogIEB0eXBlIHtDZW50c31cblx0XHRcdCAqICBAc2lnbmFsXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmRldHVuZSA9IHRoaXMub3NjaWxsYXRvci5kZXR1bmU7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGFtcGxpdHVkZSBlbnZlbG9wZS5cblx0XHRcdCAqICBAdHlwZSB7VG9uZS5BbXBsaXR1ZGVFbnZlbG9wZX1cblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuZW52ZWxvcGUgPSBuZXcgVG9uZS5BbXBsaXR1ZGVFbnZlbG9wZShvcHRpb25zLmVudmVsb3BlKTtcblx0ICAgICAgICAvL2Nvbm5lY3QgdGhlIG9zY2lsbGF0b3JzIHRvIHRoZSBvdXRwdXRcblx0ICAgICAgICB0aGlzLm9zY2lsbGF0b3IuY2hhaW4odGhpcy5lbnZlbG9wZSwgdGhpcy5vdXRwdXQpO1xuXHQgICAgICAgIC8vc3RhcnQgdGhlIG9zY2lsbGF0b3JzXG5cdCAgICAgICAgdGhpcy5vc2NpbGxhdG9yLnN0YXJ0KCk7XG5cdCAgICAgICAgdGhpcy5fcmVhZE9ubHkoW1xuXHQgICAgICAgICAgICAnb3NjaWxsYXRvcicsXG5cdCAgICAgICAgICAgICdmcmVxdWVuY3knLFxuXHQgICAgICAgICAgICAnZGV0dW5lJyxcblx0ICAgICAgICAgICAgJ2VudmVsb3BlJ1xuXHQgICAgICAgIF0pO1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuU3ludGgsIFRvbmUuTW9ub3Bob25pYyk7XG5cdCAgICAvKipcblx0XHQgKiAgQGNvbnN0XG5cdFx0ICogIEBzdGF0aWNcblx0XHQgKiAgQHR5cGUge09iamVjdH1cblx0XHQgKi9cblx0ICAgIFRvbmUuU3ludGguZGVmYXVsdHMgPSB7XG5cdCAgICAgICAgJ29zY2lsbGF0b3InOiB7ICd0eXBlJzogJ3RyaWFuZ2xlJyB9LFxuXHQgICAgICAgICdlbnZlbG9wZSc6IHtcblx0ICAgICAgICAgICAgJ2F0dGFjayc6IDAuMDA1LFxuXHQgICAgICAgICAgICAnZGVjYXknOiAwLjEsXG5cdCAgICAgICAgICAgICdzdXN0YWluJzogMC4zLFxuXHQgICAgICAgICAgICAncmVsZWFzZSc6IDFcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIHN0YXJ0IHRoZSBhdHRhY2sgcG9ydGlvbiBvZiB0aGUgZW52ZWxvcGVcblx0XHQgKiAgQHBhcmFtIHtUaW1lfSBbdGltZT1ub3ddIHRoZSB0aW1lIHRoZSBhdHRhY2sgc2hvdWxkIHN0YXJ0XG5cdFx0ICogIEBwYXJhbSB7bnVtYmVyfSBbdmVsb2NpdHk9MV0gdGhlIHZlbG9jaXR5IG9mIHRoZSBub3RlICgwLTEpXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLlN5bnRofSB0aGlzXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLlN5bnRoLnByb3RvdHlwZS5fdHJpZ2dlckVudmVsb3BlQXR0YWNrID0gZnVuY3Rpb24gKHRpbWUsIHZlbG9jaXR5KSB7XG5cdCAgICAgICAgLy90aGUgZW52ZWxvcGVzXG5cdCAgICAgICAgdGhpcy5lbnZlbG9wZS50cmlnZ2VyQXR0YWNrKHRpbWUsIHZlbG9jaXR5KTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgc3RhcnQgdGhlIHJlbGVhc2UgcG9ydGlvbiBvZiB0aGUgZW52ZWxvcGVcblx0XHQgKiAgQHBhcmFtIHtUaW1lfSBbdGltZT1ub3ddIHRoZSB0aW1lIHRoZSByZWxlYXNlIHNob3VsZCBzdGFydFxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5TeW50aH0gdGhpc1xuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5TeW50aC5wcm90b3R5cGUuX3RyaWdnZXJFbnZlbG9wZVJlbGVhc2UgPSBmdW5jdGlvbiAodGltZSkge1xuXHQgICAgICAgIHRoaXMuZW52ZWxvcGUudHJpZ2dlclJlbGVhc2UodGltZSk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIGNsZWFuIHVwXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLlN5bnRofSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLlN5bnRoLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuTW9ub3Bob25pYy5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuX3dyaXRhYmxlKFtcblx0ICAgICAgICAgICAgJ29zY2lsbGF0b3InLFxuXHQgICAgICAgICAgICAnZnJlcXVlbmN5Jyxcblx0ICAgICAgICAgICAgJ2RldHVuZScsXG5cdCAgICAgICAgICAgICdlbnZlbG9wZSdcblx0ICAgICAgICBdKTtcblx0ICAgICAgICB0aGlzLm9zY2lsbGF0b3IuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMub3NjaWxsYXRvciA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5lbnZlbG9wZS5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5lbnZlbG9wZSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5mcmVxdWVuY3kgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuZGV0dW5lID0gbnVsbDtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVG9uZS5TeW50aDtcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgXG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzICBBTVN5bnRoIHVzZXMgdGhlIG91dHB1dCBvZiBvbmUgVG9uZS5TeW50aCB0byBtb2R1bGF0ZSB0aGVcblx0XHQgKiAgICAgICAgICBhbXBsaXR1ZGUgb2YgYW5vdGhlciBUb25lLlN5bnRoLiBUaGUgaGFybW9uaWNpdHkgKHRoZSByYXRpbyBiZXR3ZWVuXG5cdFx0ICogICAgICAgICAgdGhlIHR3byBzaWduYWxzKSBhZmZlY3RzIHRoZSB0aW1icmUgb2YgdGhlIG91dHB1dCBzaWduYWwgZ3JlYXRseS5cblx0XHQgKiAgICAgICAgICBSZWFkIG1vcmUgYWJvdXQgQW1wbGl0dWRlIE1vZHVsYXRpb24gU3ludGhlc2lzIG9uXG5cdFx0ICogICAgICAgICAgW1NvdW5kT25Tb3VuZF0oaHR0cHM6Ly93ZWIuYXJjaGl2ZS5vcmcvd2ViLzIwMTYwNDA0MTAzNjUzL2h0dHA6Ly93d3cuc291bmRvbnNvdW5kLmNvbTo4MC9zb3MvbWFyMDAvYXJ0aWNsZXMvc3ludGhzZWNyZXRzLmh0bSkuXG5cdFx0ICogICAgICAgICAgPGltZyBzcmM9XCJodHRwczovL2RvY3MuZ29vZ2xlLmNvbS9kcmF3aW5ncy9kLzFUUXU4RWQ0aUZyMVlUTEtwQjNVMV9odXItVXdCcmg1Z2RCWGM4QnhmR0t3L3B1Yj93PTEwMDkmaD00NTdcIj5cblx0XHQgKlxuXHRcdCAqICBAY29uc3RydWN0b3Jcblx0XHQgKiAgQGV4dGVuZHMge1RvbmUuTW9ub3Bob25pY31cblx0XHQgKiAgQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSB0aGUgb3B0aW9ucyBhdmFpbGFibGUgZm9yIHRoZSBzeW50aFxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlZSBkZWZhdWx0cyBiZWxvd1xuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIHZhciBzeW50aCA9IG5ldyBUb25lLkFNU3ludGgoKS50b01hc3RlcigpO1xuXHRcdCAqIHN5bnRoLnRyaWdnZXJBdHRhY2tSZWxlYXNlKFwiQzRcIiwgXCI0blwiKTtcblx0XHQgKi9cblx0ICAgIFRvbmUuQU1TeW50aCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG5cdCAgICAgICAgb3B0aW9ucyA9IFRvbmUuZGVmYXVsdEFyZyhvcHRpb25zLCBUb25lLkFNU3ludGguZGVmYXVsdHMpO1xuXHQgICAgICAgIFRvbmUuTW9ub3Bob25pYy5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBjYXJyaWVyIHZvaWNlLlxuXHRcdFx0ICogIEB0eXBlIHtUb25lLlN5bnRofVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9jYXJyaWVyID0gbmV3IFRvbmUuU3ludGgoKTtcblx0ICAgICAgICB0aGlzLl9jYXJyaWVyLnZvbHVtZS52YWx1ZSA9IC0xMDtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgY2FycmllcidzIG9zY2lsbGF0b3Jcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5Pc2NpbGxhdG9yfVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5vc2NpbGxhdG9yID0gdGhpcy5fY2Fycmllci5vc2NpbGxhdG9yO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBjYXJyaWVyJ3MgZW52ZWxvcGVcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5BbXBsaXR1ZGVFbnZlbG9wZX1cblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuZW52ZWxvcGUgPSB0aGlzLl9jYXJyaWVyLmVudmVsb3BlLnNldChvcHRpb25zLmVudmVsb3BlKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgbW9kdWxhdG9yIHZvaWNlLlxuXHRcdFx0ICogIEB0eXBlIHtUb25lLlN5bnRofVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9tb2R1bGF0b3IgPSBuZXcgVG9uZS5TeW50aCgpO1xuXHQgICAgICAgIHRoaXMuX21vZHVsYXRvci52b2x1bWUudmFsdWUgPSAtMTA7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIG1vZHVsYXRvcidzIG9zY2lsbGF0b3Igd2hpY2ggaXMgYXBwbGllZFxuXHRcdFx0ICogIHRvIHRoZSBhbXBsaXR1ZGUgb2YgdGhlIG9zY2lsbGF0b3Jcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5Pc2NpbGxhdG9yfVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5tb2R1bGF0aW9uID0gdGhpcy5fbW9kdWxhdG9yLm9zY2lsbGF0b3Iuc2V0KG9wdGlvbnMubW9kdWxhdGlvbik7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIG1vZHVsYXRvcidzIGVudmVsb3BlXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuQW1wbGl0dWRlRW52ZWxvcGV9XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLm1vZHVsYXRpb25FbnZlbG9wZSA9IHRoaXMuX21vZHVsYXRvci5lbnZlbG9wZS5zZXQob3B0aW9ucy5tb2R1bGF0aW9uRW52ZWxvcGUpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBmcmVxdWVuY3kuXG5cdFx0XHQgKiAgQHR5cGUge0ZyZXF1ZW5jeX1cblx0XHRcdCAqICBAc2lnbmFsXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmZyZXF1ZW5jeSA9IG5ldyBUb25lLlNpZ25hbCg0NDAsIFRvbmUuVHlwZS5GcmVxdWVuY3kpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBkZXR1bmUgaW4gY2VudHNcblx0XHRcdCAqICBAdHlwZSB7Q2VudHN9XG5cdFx0XHQgKiAgQHNpZ25hbFxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5kZXR1bmUgPSBuZXcgVG9uZS5TaWduYWwob3B0aW9ucy5kZXR1bmUsIFRvbmUuVHlwZS5DZW50cyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgSGFybW9uaWNpdHkgaXMgdGhlIHJhdGlvIGJldHdlZW4gdGhlIHR3byB2b2ljZXMuIEEgaGFybW9uaWNpdHkgb2Zcblx0XHRcdCAqICAxIGlzIG5vIGNoYW5nZS4gSGFybW9uaWNpdHkgPSAyIG1lYW5zIGEgY2hhbmdlIG9mIGFuIG9jdGF2ZS5cblx0XHRcdCAqICBAdHlwZSB7UG9zaXRpdmV9XG5cdFx0XHQgKiAgQHNpZ25hbFxuXHRcdFx0ICogIEBleGFtcGxlXG5cdFx0XHQgKiAvL3BpdGNoIHZvaWNlMSBhbiBvY3RhdmUgYmVsb3cgdm9pY2UwXG5cdFx0XHQgKiBzeW50aC5oYXJtb25pY2l0eS52YWx1ZSA9IDAuNTtcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuaGFybW9uaWNpdHkgPSBuZXcgVG9uZS5NdWx0aXBseShvcHRpb25zLmhhcm1vbmljaXR5KTtcblx0ICAgICAgICB0aGlzLmhhcm1vbmljaXR5LnVuaXRzID0gVG9uZS5UeXBlLlBvc2l0aXZlO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIGNvbnZlcnQgdGhlIC0xLDEgb3V0cHV0IHRvIDAsMVxuXHRcdFx0ICogIEB0eXBlIHtUb25lLkF1ZGlvVG9HYWlufVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9tb2R1bGF0aW9uU2NhbGUgPSBuZXcgVG9uZS5BdWRpb1RvR2FpbigpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHRoZSBub2RlIHdoZXJlIHRoZSBtb2R1bGF0aW9uIGhhcHBlbnNcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5HYWlufVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9tb2R1bGF0aW9uTm9kZSA9IG5ldyBUb25lLkdhaW4oKTtcblx0ICAgICAgICAvL2NvbnRyb2wgdGhlIHR3byB2b2ljZXMgZnJlcXVlbmN5XG5cdCAgICAgICAgdGhpcy5mcmVxdWVuY3kuY29ubmVjdCh0aGlzLl9jYXJyaWVyLmZyZXF1ZW5jeSk7XG5cdCAgICAgICAgdGhpcy5mcmVxdWVuY3kuY2hhaW4odGhpcy5oYXJtb25pY2l0eSwgdGhpcy5fbW9kdWxhdG9yLmZyZXF1ZW5jeSk7XG5cdCAgICAgICAgdGhpcy5kZXR1bmUuZmFuKHRoaXMuX2NhcnJpZXIuZGV0dW5lLCB0aGlzLl9tb2R1bGF0b3IuZGV0dW5lKTtcblx0ICAgICAgICB0aGlzLl9tb2R1bGF0b3IuY2hhaW4odGhpcy5fbW9kdWxhdGlvblNjYWxlLCB0aGlzLl9tb2R1bGF0aW9uTm9kZS5nYWluKTtcblx0ICAgICAgICB0aGlzLl9jYXJyaWVyLmNoYWluKHRoaXMuX21vZHVsYXRpb25Ob2RlLCB0aGlzLm91dHB1dCk7XG5cdCAgICAgICAgdGhpcy5fcmVhZE9ubHkoW1xuXHQgICAgICAgICAgICAnZnJlcXVlbmN5Jyxcblx0ICAgICAgICAgICAgJ2hhcm1vbmljaXR5Jyxcblx0ICAgICAgICAgICAgJ29zY2lsbGF0b3InLFxuXHQgICAgICAgICAgICAnZW52ZWxvcGUnLFxuXHQgICAgICAgICAgICAnbW9kdWxhdGlvbicsXG5cdCAgICAgICAgICAgICdtb2R1bGF0aW9uRW52ZWxvcGUnLFxuXHQgICAgICAgICAgICAnZGV0dW5lJ1xuXHQgICAgICAgIF0pO1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuQU1TeW50aCwgVG9uZS5Nb25vcGhvbmljKTtcblx0ICAgIC8qKlxuXHRcdCAqICBAc3RhdGljXG5cdFx0ICogIEB0eXBlIHtPYmplY3R9XG5cdFx0ICovXG5cdCAgICBUb25lLkFNU3ludGguZGVmYXVsdHMgPSB7XG5cdCAgICAgICAgJ2hhcm1vbmljaXR5JzogMyxcblx0ICAgICAgICAnZGV0dW5lJzogMCxcblx0ICAgICAgICAnb3NjaWxsYXRvcic6IHsgJ3R5cGUnOiAnc2luZScgfSxcblx0ICAgICAgICAnZW52ZWxvcGUnOiB7XG5cdCAgICAgICAgICAgICdhdHRhY2snOiAwLjAxLFxuXHQgICAgICAgICAgICAnZGVjYXknOiAwLjAxLFxuXHQgICAgICAgICAgICAnc3VzdGFpbic6IDEsXG5cdCAgICAgICAgICAgICdyZWxlYXNlJzogMC41XG5cdCAgICAgICAgfSxcblx0ICAgICAgICAnbW9kdWxhdGlvbic6IHsgJ3R5cGUnOiAnc3F1YXJlJyB9LFxuXHQgICAgICAgICdtb2R1bGF0aW9uRW52ZWxvcGUnOiB7XG5cdCAgICAgICAgICAgICdhdHRhY2snOiAwLjUsXG5cdCAgICAgICAgICAgICdkZWNheSc6IDAsXG5cdCAgICAgICAgICAgICdzdXN0YWluJzogMSxcblx0ICAgICAgICAgICAgJ3JlbGVhc2UnOiAwLjVcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIHRyaWdnZXIgdGhlIGF0dGFjayBwb3J0aW9uIG9mIHRoZSBub3RlXG5cdFx0ICpcblx0XHQgKiAgQHBhcmFtICB7VGltZX0gW3RpbWU9bm93XSB0aGUgdGltZSB0aGUgbm90ZSB3aWxsIG9jY3VyXG5cdFx0ICogIEBwYXJhbSB7Tm9ybWFsUmFuZ2V9IFt2ZWxvY2l0eT0xXSB0aGUgdmVsb2NpdHkgb2YgdGhlIG5vdGVcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKiAgQHJldHVybnMge1RvbmUuQU1TeW50aH0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5BTVN5bnRoLnByb3RvdHlwZS5fdHJpZ2dlckVudmVsb3BlQXR0YWNrID0gZnVuY3Rpb24gKHRpbWUsIHZlbG9jaXR5KSB7XG5cdCAgICAgICAgLy90aGUgcG9ydCBnbGlkZVxuXHQgICAgICAgIHRpbWUgPSB0aGlzLnRvU2Vjb25kcyh0aW1lKTtcblx0ICAgICAgICAvL3RoZSBlbnZlbG9wZXNcblx0ICAgICAgICB0aGlzLmVudmVsb3BlLnRyaWdnZXJBdHRhY2sodGltZSwgdmVsb2NpdHkpO1xuXHQgICAgICAgIHRoaXMubW9kdWxhdGlvbkVudmVsb3BlLnRyaWdnZXJBdHRhY2sodGltZSwgdmVsb2NpdHkpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICB0cmlnZ2VyIHRoZSByZWxlYXNlIHBvcnRpb24gb2YgdGhlIG5vdGVcblx0XHQgKlxuXHRcdCAqICBAcGFyYW0gIHtUaW1lfSBbdGltZT1ub3ddIHRoZSB0aW1lIHRoZSBub3RlIHdpbGwgcmVsZWFzZVxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5BTVN5bnRofSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkFNU3ludGgucHJvdG90eXBlLl90cmlnZ2VyRW52ZWxvcGVSZWxlYXNlID0gZnVuY3Rpb24gKHRpbWUpIHtcblx0ICAgICAgICB0aGlzLmVudmVsb3BlLnRyaWdnZXJSZWxlYXNlKHRpbWUpO1xuXHQgICAgICAgIHRoaXMubW9kdWxhdGlvbkVudmVsb3BlLnRyaWdnZXJSZWxlYXNlKHRpbWUpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBjbGVhbiB1cFxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5BTVN5bnRofSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkFNU3ludGgucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5Nb25vcGhvbmljLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgdGhpcy5fd3JpdGFibGUoW1xuXHQgICAgICAgICAgICAnZnJlcXVlbmN5Jyxcblx0ICAgICAgICAgICAgJ2hhcm1vbmljaXR5Jyxcblx0ICAgICAgICAgICAgJ29zY2lsbGF0b3InLFxuXHQgICAgICAgICAgICAnZW52ZWxvcGUnLFxuXHQgICAgICAgICAgICAnbW9kdWxhdGlvbicsXG5cdCAgICAgICAgICAgICdtb2R1bGF0aW9uRW52ZWxvcGUnLFxuXHQgICAgICAgICAgICAnZGV0dW5lJ1xuXHQgICAgICAgIF0pO1xuXHQgICAgICAgIHRoaXMuX2NhcnJpZXIuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX2NhcnJpZXIgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX21vZHVsYXRvci5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fbW9kdWxhdG9yID0gbnVsbDtcblx0ICAgICAgICB0aGlzLmZyZXF1ZW5jeS5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5mcmVxdWVuY3kgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuZGV0dW5lLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLmRldHVuZSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5oYXJtb25pY2l0eS5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5oYXJtb25pY2l0eSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fbW9kdWxhdGlvblNjYWxlLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9tb2R1bGF0aW9uU2NhbGUgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX21vZHVsYXRpb25Ob2RlLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9tb2R1bGF0aW9uTm9kZSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5vc2NpbGxhdG9yID0gbnVsbDtcblx0ICAgICAgICB0aGlzLmVudmVsb3BlID0gbnVsbDtcblx0ICAgICAgICB0aGlzLm1vZHVsYXRpb25FbnZlbG9wZSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5tb2R1bGF0aW9uID0gbnVsbDtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVG9uZS5BTVN5bnRoO1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgIFRvbmUuTW9ub1N5bnRoIGlzIGNvbXBvc2VkIG9mIG9uZSBvc2NpbGxhdG9yLCBvbmUgZmlsdGVyLCBhbmQgdHdvIGVudmVsb3Blcy5cblx0XHQgKiAgICAgICAgICBUaGUgYW1wbGl0dWRlIG9mIHRoZSBUb25lLk9zY2lsbGF0b3IgYW5kIHRoZSBjdXRvZmYgZnJlcXVlbmN5IG9mIHRoZSBcblx0XHQgKiAgICAgICAgICBUb25lLkZpbHRlciBhcmUgY29udHJvbGxlZCBieSBUb25lLkVudmVsb3Blcy4gXG5cdFx0ICogICAgICAgICAgPGltZyBzcmM9XCJodHRwczovL2RvY3MuZ29vZ2xlLmNvbS9kcmF3aW5ncy9kLzFnYVkxREY5X0h6a29kcWY4SkkxQ2cyVlpmd1NFbHBGUWZJOTRJUXdhZDM4L3B1Yj93PTkyNCZoPTI0MFwiPlxuXHRcdCAqICAgICAgICAgIFxuXHRcdCAqICBAY29uc3RydWN0b3Jcblx0XHQgKiAgQGV4dGVuZHMge1RvbmUuTW9ub3Bob25pY31cblx0XHQgKiAgQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSB0aGUgb3B0aW9ucyBhdmFpbGFibGUgZm9yIHRoZSBzeW50aCBcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgc2VlIGRlZmF1bHRzIGJlbG93XG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogdmFyIHN5bnRoID0gbmV3IFRvbmUuTW9ub1N5bnRoKHtcblx0XHQgKiBcdFwib3NjaWxsYXRvclwiIDoge1xuXHRcdCAqIFx0XHRcInR5cGVcIiA6IFwic3F1YXJlXCJcblx0XHQgKiAgfSxcblx0XHQgKiAgXCJlbnZlbG9wZVwiIDoge1xuXHRcdCAqICBcdFwiYXR0YWNrXCIgOiAwLjFcblx0XHQgKiAgfVxuXHRcdCAqIH0pLnRvTWFzdGVyKCk7XG5cdFx0ICogc3ludGgudHJpZ2dlckF0dGFja1JlbGVhc2UoXCJDNFwiLCBcIjhuXCIpO1xuXHRcdCAqL1xuXHQgICAgVG9uZS5Nb25vU3ludGggPSBmdW5jdGlvbiAob3B0aW9ucykge1xuXHQgICAgICAgIC8vZ2V0IHRoZSBkZWZhdWx0c1xuXHQgICAgICAgIG9wdGlvbnMgPSBUb25lLmRlZmF1bHRBcmcob3B0aW9ucywgVG9uZS5Nb25vU3ludGguZGVmYXVsdHMpO1xuXHQgICAgICAgIFRvbmUuTW9ub3Bob25pYy5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBvc2NpbGxhdG9yLlxuXHRcdFx0ICogIEB0eXBlIHtUb25lLk9tbmlPc2NpbGxhdG9yfVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5vc2NpbGxhdG9yID0gbmV3IFRvbmUuT21uaU9zY2lsbGF0b3Iob3B0aW9ucy5vc2NpbGxhdG9yKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgZnJlcXVlbmN5IGNvbnRyb2wuXG5cdFx0XHQgKiAgQHR5cGUge0ZyZXF1ZW5jeX1cblx0XHRcdCAqICBAc2lnbmFsXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmZyZXF1ZW5jeSA9IHRoaXMub3NjaWxsYXRvci5mcmVxdWVuY3k7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGRldHVuZSBjb250cm9sLlxuXHRcdFx0ICogIEB0eXBlIHtDZW50c31cblx0XHRcdCAqICBAc2lnbmFsXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmRldHVuZSA9IHRoaXMub3NjaWxsYXRvci5kZXR1bmU7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGZpbHRlci5cblx0XHRcdCAqICBAdHlwZSB7VG9uZS5GaWx0ZXJ9XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmZpbHRlciA9IG5ldyBUb25lLkZpbHRlcihvcHRpb25zLmZpbHRlcik7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGZpbHRlciBlbnZlbG9wZS5cblx0XHRcdCAqICBAdHlwZSB7VG9uZS5GcmVxdWVuY3lFbnZlbG9wZX1cblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuZmlsdGVyRW52ZWxvcGUgPSBuZXcgVG9uZS5GcmVxdWVuY3lFbnZlbG9wZShvcHRpb25zLmZpbHRlckVudmVsb3BlKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgYW1wbGl0dWRlIGVudmVsb3BlLlxuXHRcdFx0ICogIEB0eXBlIHtUb25lLkFtcGxpdHVkZUVudmVsb3BlfVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5lbnZlbG9wZSA9IG5ldyBUb25lLkFtcGxpdHVkZUVudmVsb3BlKG9wdGlvbnMuZW52ZWxvcGUpO1xuXHQgICAgICAgIC8vY29ubmVjdCB0aGUgb3NjaWxsYXRvcnMgdG8gdGhlIG91dHB1dFxuXHQgICAgICAgIHRoaXMub3NjaWxsYXRvci5jaGFpbih0aGlzLmZpbHRlciwgdGhpcy5lbnZlbG9wZSwgdGhpcy5vdXRwdXQpO1xuXHQgICAgICAgIC8vc3RhcnQgdGhlIG9zY2lsbGF0b3JzXG5cdCAgICAgICAgdGhpcy5vc2NpbGxhdG9yLnN0YXJ0KCk7XG5cdCAgICAgICAgLy9jb25uZWN0IHRoZSBmaWx0ZXIgZW52ZWxvcGVcblx0ICAgICAgICB0aGlzLmZpbHRlckVudmVsb3BlLmNvbm5lY3QodGhpcy5maWx0ZXIuZnJlcXVlbmN5KTtcblx0ICAgICAgICB0aGlzLl9yZWFkT25seShbXG5cdCAgICAgICAgICAgICdvc2NpbGxhdG9yJyxcblx0ICAgICAgICAgICAgJ2ZyZXF1ZW5jeScsXG5cdCAgICAgICAgICAgICdkZXR1bmUnLFxuXHQgICAgICAgICAgICAnZmlsdGVyJyxcblx0ICAgICAgICAgICAgJ2ZpbHRlckVudmVsb3BlJyxcblx0ICAgICAgICAgICAgJ2VudmVsb3BlJ1xuXHQgICAgICAgIF0pO1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuTW9ub1N5bnRoLCBUb25lLk1vbm9waG9uaWMpO1xuXHQgICAgLyoqXG5cdFx0ICogIEBjb25zdFxuXHRcdCAqICBAc3RhdGljXG5cdFx0ICogIEB0eXBlIHtPYmplY3R9XG5cdFx0ICovXG5cdCAgICBUb25lLk1vbm9TeW50aC5kZWZhdWx0cyA9IHtcblx0ICAgICAgICAnZnJlcXVlbmN5JzogJ0M0Jyxcblx0ICAgICAgICAnZGV0dW5lJzogMCxcblx0ICAgICAgICAnb3NjaWxsYXRvcic6IHsgJ3R5cGUnOiAnc3F1YXJlJyB9LFxuXHQgICAgICAgICdmaWx0ZXInOiB7XG5cdCAgICAgICAgICAgICdRJzogNixcblx0ICAgICAgICAgICAgJ3R5cGUnOiAnbG93cGFzcycsXG5cdCAgICAgICAgICAgICdyb2xsb2ZmJzogLTI0XG5cdCAgICAgICAgfSxcblx0ICAgICAgICAnZW52ZWxvcGUnOiB7XG5cdCAgICAgICAgICAgICdhdHRhY2snOiAwLjAwNSxcblx0ICAgICAgICAgICAgJ2RlY2F5JzogMC4xLFxuXHQgICAgICAgICAgICAnc3VzdGFpbic6IDAuOSxcblx0ICAgICAgICAgICAgJ3JlbGVhc2UnOiAxXG5cdCAgICAgICAgfSxcblx0ICAgICAgICAnZmlsdGVyRW52ZWxvcGUnOiB7XG5cdCAgICAgICAgICAgICdhdHRhY2snOiAwLjA2LFxuXHQgICAgICAgICAgICAnZGVjYXknOiAwLjIsXG5cdCAgICAgICAgICAgICdzdXN0YWluJzogMC41LFxuXHQgICAgICAgICAgICAncmVsZWFzZSc6IDIsXG5cdCAgICAgICAgICAgICdiYXNlRnJlcXVlbmN5JzogMjAwLFxuXHQgICAgICAgICAgICAnb2N0YXZlcyc6IDcsXG5cdCAgICAgICAgICAgICdleHBvbmVudCc6IDJcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIHN0YXJ0IHRoZSBhdHRhY2sgcG9ydGlvbiBvZiB0aGUgZW52ZWxvcGVcblx0XHQgKiAgQHBhcmFtIHtUaW1lfSBbdGltZT1ub3ddIHRoZSB0aW1lIHRoZSBhdHRhY2sgc2hvdWxkIHN0YXJ0XG5cdFx0ICogIEBwYXJhbSB7Tm9ybWFsUmFuZ2V9IFt2ZWxvY2l0eT0xXSB0aGUgdmVsb2NpdHkgb2YgdGhlIG5vdGUgKDAtMSlcblx0XHQgKiAgQHJldHVybnMge1RvbmUuTW9ub1N5bnRofSB0aGlzXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLk1vbm9TeW50aC5wcm90b3R5cGUuX3RyaWdnZXJFbnZlbG9wZUF0dGFjayA9IGZ1bmN0aW9uICh0aW1lLCB2ZWxvY2l0eSkge1xuXHQgICAgICAgIC8vdGhlIGVudmVsb3Blc1xuXHQgICAgICAgIHRoaXMuZW52ZWxvcGUudHJpZ2dlckF0dGFjayh0aW1lLCB2ZWxvY2l0eSk7XG5cdCAgICAgICAgdGhpcy5maWx0ZXJFbnZlbG9wZS50cmlnZ2VyQXR0YWNrKHRpbWUpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBzdGFydCB0aGUgcmVsZWFzZSBwb3J0aW9uIG9mIHRoZSBlbnZlbG9wZVxuXHRcdCAqICBAcGFyYW0ge1RpbWV9IFt0aW1lPW5vd10gdGhlIHRpbWUgdGhlIHJlbGVhc2Ugc2hvdWxkIHN0YXJ0XG5cdFx0ICogIEByZXR1cm5zIHtUb25lLk1vbm9TeW50aH0gdGhpc1xuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5Nb25vU3ludGgucHJvdG90eXBlLl90cmlnZ2VyRW52ZWxvcGVSZWxlYXNlID0gZnVuY3Rpb24gKHRpbWUpIHtcblx0ICAgICAgICB0aGlzLmVudmVsb3BlLnRyaWdnZXJSZWxlYXNlKHRpbWUpO1xuXHQgICAgICAgIHRoaXMuZmlsdGVyRW52ZWxvcGUudHJpZ2dlclJlbGVhc2UodGltZSk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIGNsZWFuIHVwXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLk1vbm9TeW50aH0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5Nb25vU3ludGgucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5Nb25vcGhvbmljLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgdGhpcy5fd3JpdGFibGUoW1xuXHQgICAgICAgICAgICAnb3NjaWxsYXRvcicsXG5cdCAgICAgICAgICAgICdmcmVxdWVuY3knLFxuXHQgICAgICAgICAgICAnZGV0dW5lJyxcblx0ICAgICAgICAgICAgJ2ZpbHRlcicsXG5cdCAgICAgICAgICAgICdmaWx0ZXJFbnZlbG9wZScsXG5cdCAgICAgICAgICAgICdlbnZlbG9wZSdcblx0ICAgICAgICBdKTtcblx0ICAgICAgICB0aGlzLm9zY2lsbGF0b3IuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMub3NjaWxsYXRvciA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5lbnZlbG9wZS5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5lbnZlbG9wZSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5maWx0ZXJFbnZlbG9wZS5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5maWx0ZXJFbnZlbG9wZSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5maWx0ZXIuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuZmlsdGVyID0gbnVsbDtcblx0ICAgICAgICB0aGlzLmZyZXF1ZW5jeSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5kZXR1bmUgPSBudWxsO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLk1vbm9TeW50aDtcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgXG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzICBUb25lLkR1b1N5bnRoIGlzIGEgbW9ub3Bob25pYyBzeW50aCBjb21wb3NlZCBvZiB0d28gXG5cdFx0ICogICAgICAgICAgTW9ub1N5bnRocyBydW4gaW4gcGFyYWxsZWwgd2l0aCBjb250cm9sIG92ZXIgdGhlIFxuXHRcdCAqICAgICAgICAgIGZyZXF1ZW5jeSByYXRpbyBiZXR3ZWVuIHRoZSB0d28gdm9pY2VzIGFuZCB2aWJyYXRvIGVmZmVjdC5cblx0XHQgKiAgICAgICAgICA8aW1nIHNyYz1cImh0dHBzOi8vZG9jcy5nb29nbGUuY29tL2RyYXdpbmdzL2QvMWJMNEdYdmZSTU1scVM3WHlCbTlDakw5S0pQU1VLYmNkQk5wcU9sa0ZMeGsvcHViP3c9MTAxMiZoPTQ0OFwiPlxuXHRcdCAqXG5cdFx0ICogIEBjb25zdHJ1Y3RvclxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZS5Nb25vcGhvbmljfVxuXHRcdCAqICBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIHRoZSBvcHRpb25zIGF2YWlsYWJsZSBmb3IgdGhlIHN5bnRoIFxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICBzZWUgZGVmYXVsdHMgYmVsb3dcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiB2YXIgZHVvU3ludGggPSBuZXcgVG9uZS5EdW9TeW50aCgpLnRvTWFzdGVyKCk7XG5cdFx0ICogZHVvU3ludGgudHJpZ2dlckF0dGFja1JlbGVhc2UoXCJDNFwiLCBcIjJuXCIpO1xuXHRcdCAqL1xuXHQgICAgVG9uZS5EdW9TeW50aCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG5cdCAgICAgICAgb3B0aW9ucyA9IFRvbmUuZGVmYXVsdEFyZyhvcHRpb25zLCBUb25lLkR1b1N5bnRoLmRlZmF1bHRzKTtcblx0ICAgICAgICBUb25lLk1vbm9waG9uaWMuY2FsbCh0aGlzLCBvcHRpb25zKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICB0aGUgZmlyc3Qgdm9pY2Vcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5Nb25vU3ludGh9XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLnZvaWNlMCA9IG5ldyBUb25lLk1vbm9TeW50aChvcHRpb25zLnZvaWNlMCk7XG5cdCAgICAgICAgdGhpcy52b2ljZTAudm9sdW1lLnZhbHVlID0gLTEwO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHRoZSBzZWNvbmQgdm9pY2Vcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5Nb25vU3ludGh9XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLnZvaWNlMSA9IG5ldyBUb25lLk1vbm9TeW50aChvcHRpb25zLnZvaWNlMSk7XG5cdCAgICAgICAgdGhpcy52b2ljZTEudm9sdW1lLnZhbHVlID0gLTEwO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSB2aWJyYXRvIExGTy4gXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuTEZPfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl92aWJyYXRvID0gbmV3IFRvbmUuTEZPKG9wdGlvbnMudmlicmF0b1JhdGUsIC01MCwgNTApO1xuXHQgICAgICAgIHRoaXMuX3ZpYnJhdG8uc3RhcnQoKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqIHRoZSB2aWJyYXRvIGZyZXF1ZW5jeVxuXHRcdFx0ICogQHR5cGUge0ZyZXF1ZW5jeX1cblx0XHRcdCAqIEBzaWduYWxcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMudmlicmF0b1JhdGUgPSB0aGlzLl92aWJyYXRvLmZyZXF1ZW5jeTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICB0aGUgdmlicmF0byBnYWluXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuR2Fpbn1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fdmlicmF0b0dhaW4gPSBuZXcgVG9uZS5HYWluKG9wdGlvbnMudmlicmF0b0Ftb3VudCwgVG9uZS5UeXBlLlBvc2l0aXZlKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqIFRoZSBhbW91bnQgb2YgdmlicmF0b1xuXHRcdFx0ICogQHR5cGUge1Bvc2l0aXZlfVxuXHRcdFx0ICogQHNpZ25hbFxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy52aWJyYXRvQW1vdW50ID0gdGhpcy5fdmlicmF0b0dhaW4uZ2Fpbjtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICB0aGUgZnJlcXVlbmN5IGNvbnRyb2xcblx0XHRcdCAqICBAdHlwZSB7RnJlcXVlbmN5fVxuXHRcdFx0ICogIEBzaWduYWxcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuZnJlcXVlbmN5ID0gbmV3IFRvbmUuU2lnbmFsKDQ0MCwgVG9uZS5UeXBlLkZyZXF1ZW5jeSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgSGFybW9uaWNpdHkgaXMgdGhlIHJhdGlvIGJldHdlZW4gdGhlIHR3byB2b2ljZXMuIEEgaGFybW9uaWNpdHkgb2Zcblx0XHRcdCAqICAxIGlzIG5vIGNoYW5nZS4gSGFybW9uaWNpdHkgPSAyIG1lYW5zIGEgY2hhbmdlIG9mIGFuIG9jdGF2ZS4gXG5cdFx0XHQgKiAgQHR5cGUge1Bvc2l0aXZlfVxuXHRcdFx0ICogIEBzaWduYWxcblx0XHRcdCAqICBAZXhhbXBsZVxuXHRcdFx0ICogLy9waXRjaCB2b2ljZTEgYW4gb2N0YXZlIGJlbG93IHZvaWNlMFxuXHRcdFx0ICogZHVvU3ludGguaGFybW9uaWNpdHkudmFsdWUgPSAwLjU7XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmhhcm1vbmljaXR5ID0gbmV3IFRvbmUuTXVsdGlwbHkob3B0aW9ucy5oYXJtb25pY2l0eSk7XG5cdCAgICAgICAgdGhpcy5oYXJtb25pY2l0eS51bml0cyA9IFRvbmUuVHlwZS5Qb3NpdGl2ZTtcblx0ICAgICAgICAvL2NvbnRyb2wgdGhlIHR3byB2b2ljZXMgZnJlcXVlbmN5XG5cdCAgICAgICAgdGhpcy5mcmVxdWVuY3kuY29ubmVjdCh0aGlzLnZvaWNlMC5mcmVxdWVuY3kpO1xuXHQgICAgICAgIHRoaXMuZnJlcXVlbmN5LmNoYWluKHRoaXMuaGFybW9uaWNpdHksIHRoaXMudm9pY2UxLmZyZXF1ZW5jeSk7XG5cdCAgICAgICAgdGhpcy5fdmlicmF0by5jb25uZWN0KHRoaXMuX3ZpYnJhdG9HYWluKTtcblx0ICAgICAgICB0aGlzLl92aWJyYXRvR2Fpbi5mYW4odGhpcy52b2ljZTAuZGV0dW5lLCB0aGlzLnZvaWNlMS5kZXR1bmUpO1xuXHQgICAgICAgIHRoaXMudm9pY2UwLmNvbm5lY3QodGhpcy5vdXRwdXQpO1xuXHQgICAgICAgIHRoaXMudm9pY2UxLmNvbm5lY3QodGhpcy5vdXRwdXQpO1xuXHQgICAgICAgIHRoaXMuX3JlYWRPbmx5KFtcblx0ICAgICAgICAgICAgJ3ZvaWNlMCcsXG5cdCAgICAgICAgICAgICd2b2ljZTEnLFxuXHQgICAgICAgICAgICAnZnJlcXVlbmN5Jyxcblx0ICAgICAgICAgICAgJ3ZpYnJhdG9BbW91bnQnLFxuXHQgICAgICAgICAgICAndmlicmF0b1JhdGUnXG5cdCAgICAgICAgXSk7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5EdW9TeW50aCwgVG9uZS5Nb25vcGhvbmljKTtcblx0ICAgIC8qKlxuXHRcdCAqICBAc3RhdGljXG5cdFx0ICogIEB0eXBlIHtPYmplY3R9XG5cdFx0ICovXG5cdCAgICBUb25lLkR1b1N5bnRoLmRlZmF1bHRzID0ge1xuXHQgICAgICAgICd2aWJyYXRvQW1vdW50JzogMC41LFxuXHQgICAgICAgICd2aWJyYXRvUmF0ZSc6IDUsXG5cdCAgICAgICAgJ2hhcm1vbmljaXR5JzogMS41LFxuXHQgICAgICAgICd2b2ljZTAnOiB7XG5cdCAgICAgICAgICAgICd2b2x1bWUnOiAtMTAsXG5cdCAgICAgICAgICAgICdwb3J0YW1lbnRvJzogMCxcblx0ICAgICAgICAgICAgJ29zY2lsbGF0b3InOiB7ICd0eXBlJzogJ3NpbmUnIH0sXG5cdCAgICAgICAgICAgICdmaWx0ZXJFbnZlbG9wZSc6IHtcblx0ICAgICAgICAgICAgICAgICdhdHRhY2snOiAwLjAxLFxuXHQgICAgICAgICAgICAgICAgJ2RlY2F5JzogMCxcblx0ICAgICAgICAgICAgICAgICdzdXN0YWluJzogMSxcblx0ICAgICAgICAgICAgICAgICdyZWxlYXNlJzogMC41XG5cdCAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgICdlbnZlbG9wZSc6IHtcblx0ICAgICAgICAgICAgICAgICdhdHRhY2snOiAwLjAxLFxuXHQgICAgICAgICAgICAgICAgJ2RlY2F5JzogMCxcblx0ICAgICAgICAgICAgICAgICdzdXN0YWluJzogMSxcblx0ICAgICAgICAgICAgICAgICdyZWxlYXNlJzogMC41XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9LFxuXHQgICAgICAgICd2b2ljZTEnOiB7XG5cdCAgICAgICAgICAgICd2b2x1bWUnOiAtMTAsXG5cdCAgICAgICAgICAgICdwb3J0YW1lbnRvJzogMCxcblx0ICAgICAgICAgICAgJ29zY2lsbGF0b3InOiB7ICd0eXBlJzogJ3NpbmUnIH0sXG5cdCAgICAgICAgICAgICdmaWx0ZXJFbnZlbG9wZSc6IHtcblx0ICAgICAgICAgICAgICAgICdhdHRhY2snOiAwLjAxLFxuXHQgICAgICAgICAgICAgICAgJ2RlY2F5JzogMCxcblx0ICAgICAgICAgICAgICAgICdzdXN0YWluJzogMSxcblx0ICAgICAgICAgICAgICAgICdyZWxlYXNlJzogMC41XG5cdCAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgICdlbnZlbG9wZSc6IHtcblx0ICAgICAgICAgICAgICAgICdhdHRhY2snOiAwLjAxLFxuXHQgICAgICAgICAgICAgICAgJ2RlY2F5JzogMCxcblx0ICAgICAgICAgICAgICAgICdzdXN0YWluJzogMSxcblx0ICAgICAgICAgICAgICAgICdyZWxlYXNlJzogMC41XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIHN0YXJ0IHRoZSBhdHRhY2sgcG9ydGlvbiBvZiB0aGUgZW52ZWxvcGVzXG5cdFx0ICogIFxuXHRcdCAqICBAcGFyYW0ge1RpbWV9IFt0aW1lPW5vd10gdGhlIHRpbWUgdGhlIGF0dGFjayBzaG91bGQgc3RhcnRcblx0XHQgKiAgQHBhcmFtIHtOb3JtYWxSYW5nZX0gW3ZlbG9jaXR5PTFdIHRoZSB2ZWxvY2l0eSBvZiB0aGUgbm90ZSAoMC0xKVxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5EdW9TeW50aH0gdGhpc1xuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5EdW9TeW50aC5wcm90b3R5cGUuX3RyaWdnZXJFbnZlbG9wZUF0dGFjayA9IGZ1bmN0aW9uICh0aW1lLCB2ZWxvY2l0eSkge1xuXHQgICAgICAgIHRpbWUgPSB0aGlzLnRvU2Vjb25kcyh0aW1lKTtcblx0ICAgICAgICB0aGlzLnZvaWNlMC5lbnZlbG9wZS50cmlnZ2VyQXR0YWNrKHRpbWUsIHZlbG9jaXR5KTtcblx0ICAgICAgICB0aGlzLnZvaWNlMS5lbnZlbG9wZS50cmlnZ2VyQXR0YWNrKHRpbWUsIHZlbG9jaXR5KTtcblx0ICAgICAgICB0aGlzLnZvaWNlMC5maWx0ZXJFbnZlbG9wZS50cmlnZ2VyQXR0YWNrKHRpbWUpO1xuXHQgICAgICAgIHRoaXMudm9pY2UxLmZpbHRlckVudmVsb3BlLnRyaWdnZXJBdHRhY2sodGltZSk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIHN0YXJ0IHRoZSByZWxlYXNlIHBvcnRpb24gb2YgdGhlIGVudmVsb3Blc1xuXHRcdCAqICBcblx0XHQgKiAgQHBhcmFtIHtUaW1lfSBbdGltZT1ub3ddIHRoZSB0aW1lIHRoZSByZWxlYXNlIHNob3VsZCBzdGFydFxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5EdW9TeW50aH0gdGhpc1xuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5EdW9TeW50aC5wcm90b3R5cGUuX3RyaWdnZXJFbnZlbG9wZVJlbGVhc2UgPSBmdW5jdGlvbiAodGltZSkge1xuXHQgICAgICAgIHRoaXMudm9pY2UwLnRyaWdnZXJSZWxlYXNlKHRpbWUpO1xuXHQgICAgICAgIHRoaXMudm9pY2UxLnRyaWdnZXJSZWxlYXNlKHRpbWUpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBjbGVhbiB1cFxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5EdW9TeW50aH0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5EdW9TeW50aC5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLk1vbm9waG9uaWMucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLl93cml0YWJsZShbXG5cdCAgICAgICAgICAgICd2b2ljZTAnLFxuXHQgICAgICAgICAgICAndm9pY2UxJyxcblx0ICAgICAgICAgICAgJ2ZyZXF1ZW5jeScsXG5cdCAgICAgICAgICAgICd2aWJyYXRvQW1vdW50Jyxcblx0ICAgICAgICAgICAgJ3ZpYnJhdG9SYXRlJ1xuXHQgICAgICAgIF0pO1xuXHQgICAgICAgIHRoaXMudm9pY2UwLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLnZvaWNlMCA9IG51bGw7XG5cdCAgICAgICAgdGhpcy52b2ljZTEuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMudm9pY2UxID0gbnVsbDtcblx0ICAgICAgICB0aGlzLmZyZXF1ZW5jeS5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5mcmVxdWVuY3kgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX3ZpYnJhdG9HYWluLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl92aWJyYXRvR2FpbiA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fdmlicmF0byA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5oYXJtb25pY2l0eS5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5oYXJtb25pY2l0eSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy52aWJyYXRvQW1vdW50LmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLnZpYnJhdG9BbW91bnQgPSBudWxsO1xuXHQgICAgICAgIHRoaXMudmlicmF0b1JhdGUgPSBudWxsO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLkR1b1N5bnRoO1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgIEZNU3ludGggaXMgY29tcG9zZWQgb2YgdHdvIFRvbmUuU3ludGhzIHdoZXJlIG9uZSBUb25lLlN5bnRoIG1vZHVsYXRlc1xuXHRcdCAqICAgICAgICAgIHRoZSBmcmVxdWVuY3kgb2YgYSBzZWNvbmQgVG9uZS5TeW50aC4gQSBsb3Qgb2Ygc3BlY3RyYWwgY29udGVudCBcblx0XHQgKiAgICAgICAgICBjYW4gYmUgZXhwbG9yZWQgdXNpbmcgdGhlIG1vZHVsYXRpb25JbmRleCBwYXJhbWV0ZXIuIFJlYWQgbW9yZSBhYm91dFxuXHRcdCAqICAgICAgICAgIGZyZXF1ZW5jeSBtb2R1bGF0aW9uIHN5bnRoZXNpcyBvbiBTb3VuZCBPbiBTb3VuZDogW1BhcnQgMV0oaHR0cHM6Ly93ZWIuYXJjaGl2ZS5vcmcvd2ViLzIwMTYwNDAzMTIzNzA0L2h0dHA6Ly93d3cuc291bmRvbnNvdW5kLmNvbS9zb3MvYXByMDAvYXJ0aWNsZXMvc3ludGhzZWNyZXRzLmh0bSksIFtQYXJ0IDJdKGh0dHBzOi8vd2ViLmFyY2hpdmUub3JnL3dlYi8yMDE2MDQwMzExNTgzNS9odHRwOi8vd3d3LnNvdW5kb25zb3VuZC5jb20vc29zL21heTAwL2FydGljbGVzL3N5bnRoLmh0bSkuXG5cdFx0ICogICAgICAgICAgPGltZyBzcmM9XCJodHRwczovL2RvY3MuZ29vZ2xlLmNvbS9kcmF3aW5ncy9kLzFoMFBVRFpYUGdpNElreDZiVlQ2b25jcllQTGx1Rkt5N2xqNTNwdXhqLURNL3B1Yj93PTkwMiZoPTQ2MlwiPlxuXHRcdCAqXG5cdFx0ICogIEBjb25zdHJ1Y3RvclxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZS5Nb25vcGhvbmljfVxuXHRcdCAqICBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIHRoZSBvcHRpb25zIGF2YWlsYWJsZSBmb3IgdGhlIHN5bnRoXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgIHNlZSBkZWZhdWx0cyBiZWxvd1xuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIHZhciBmbVN5bnRoID0gbmV3IFRvbmUuRk1TeW50aCgpLnRvTWFzdGVyKCk7XG5cdFx0ICogZm1TeW50aC50cmlnZ2VyQXR0YWNrUmVsZWFzZShcIkM1XCIsIFwiNG5cIik7XG5cdFx0ICovXG5cdCAgICBUb25lLkZNU3ludGggPSBmdW5jdGlvbiAob3B0aW9ucykge1xuXHQgICAgICAgIG9wdGlvbnMgPSBUb25lLmRlZmF1bHRBcmcob3B0aW9ucywgVG9uZS5GTVN5bnRoLmRlZmF1bHRzKTtcblx0ICAgICAgICBUb25lLk1vbm9waG9uaWMuY2FsbCh0aGlzLCBvcHRpb25zKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgY2FycmllciB2b2ljZS5cblx0XHRcdCAqICBAdHlwZSB7VG9uZS5TeW50aH1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fY2FycmllciA9IG5ldyBUb25lLlN5bnRoKG9wdGlvbnMuY2Fycmllcik7XG5cdCAgICAgICAgdGhpcy5fY2Fycmllci52b2x1bWUudmFsdWUgPSAtMTA7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGNhcnJpZXIncyBvc2NpbGxhdG9yXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuT3NjaWxsYXRvcn1cblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMub3NjaWxsYXRvciA9IHRoaXMuX2NhcnJpZXIub3NjaWxsYXRvcjtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgY2FycmllcidzIGVudmVsb3BlXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuT3NjaWxsYXRvcn1cblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuZW52ZWxvcGUgPSB0aGlzLl9jYXJyaWVyLmVudmVsb3BlLnNldChvcHRpb25zLmVudmVsb3BlKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgbW9kdWxhdG9yIHZvaWNlLlxuXHRcdFx0ICogIEB0eXBlIHtUb25lLlN5bnRofVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9tb2R1bGF0b3IgPSBuZXcgVG9uZS5TeW50aChvcHRpb25zLm1vZHVsYXRvcik7XG5cdCAgICAgICAgdGhpcy5fbW9kdWxhdG9yLnZvbHVtZS52YWx1ZSA9IC0xMDtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgbW9kdWxhdG9yJ3Mgb3NjaWxsYXRvciB3aGljaCBpcyBhcHBsaWVkXG5cdFx0XHQgKiAgdG8gdGhlIGFtcGxpdHVkZSBvZiB0aGUgb3NjaWxsYXRvclxuXHRcdFx0ICogIEB0eXBlIHtUb25lLk9zY2lsbGF0b3J9XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLm1vZHVsYXRpb24gPSB0aGlzLl9tb2R1bGF0b3Iub3NjaWxsYXRvci5zZXQob3B0aW9ucy5tb2R1bGF0aW9uKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgbW9kdWxhdG9yJ3MgZW52ZWxvcGVcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5Pc2NpbGxhdG9yfVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5tb2R1bGF0aW9uRW52ZWxvcGUgPSB0aGlzLl9tb2R1bGF0b3IuZW52ZWxvcGUuc2V0KG9wdGlvbnMubW9kdWxhdGlvbkVudmVsb3BlKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgZnJlcXVlbmN5IGNvbnRyb2wuXG5cdFx0XHQgKiAgQHR5cGUge0ZyZXF1ZW5jeX1cblx0XHRcdCAqICBAc2lnbmFsXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmZyZXF1ZW5jeSA9IG5ldyBUb25lLlNpZ25hbCg0NDAsIFRvbmUuVHlwZS5GcmVxdWVuY3kpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBkZXR1bmUgaW4gY2VudHNcblx0XHRcdCAqICBAdHlwZSB7Q2VudHN9XG5cdFx0XHQgKiAgQHNpZ25hbFxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5kZXR1bmUgPSBuZXcgVG9uZS5TaWduYWwob3B0aW9ucy5kZXR1bmUsIFRvbmUuVHlwZS5DZW50cyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgSGFybW9uaWNpdHkgaXMgdGhlIHJhdGlvIGJldHdlZW4gdGhlIHR3byB2b2ljZXMuIEEgaGFybW9uaWNpdHkgb2Zcblx0XHRcdCAqICAxIGlzIG5vIGNoYW5nZS4gSGFybW9uaWNpdHkgPSAyIG1lYW5zIGEgY2hhbmdlIG9mIGFuIG9jdGF2ZS5cblx0XHRcdCAqICBAdHlwZSB7UG9zaXRpdmV9XG5cdFx0XHQgKiAgQHNpZ25hbFxuXHRcdFx0ICogIEBleGFtcGxlXG5cdFx0XHQgKiAvL3BpdGNoIHZvaWNlMSBhbiBvY3RhdmUgYmVsb3cgdm9pY2UwXG5cdFx0XHQgKiBzeW50aC5oYXJtb25pY2l0eS52YWx1ZSA9IDAuNTtcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuaGFybW9uaWNpdHkgPSBuZXcgVG9uZS5NdWx0aXBseShvcHRpb25zLmhhcm1vbmljaXR5KTtcblx0ICAgICAgICB0aGlzLmhhcm1vbmljaXR5LnVuaXRzID0gVG9uZS5UeXBlLlBvc2l0aXZlO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBtb2R1bGF0aW9uIGluZGV4IHdoaWNoIGVzc2VudGlhbGx5IHRoZSBkZXB0aCBvciBhbW91bnQgb2YgdGhlIG1vZHVsYXRpb24uIEl0IGlzIHRoZVxuXHRcdFx0ICogIHJhdGlvIG9mIHRoZSBmcmVxdWVuY3kgb2YgdGhlIG1vZHVsYXRpbmcgc2lnbmFsIChtZikgdG8gdGhlIGFtcGxpdHVkZSBvZiB0aGVcblx0XHRcdCAqICBtb2R1bGF0aW5nIHNpZ25hbCAobWEpIC0tIGFzIGluIG1hL21mLlxuXHRcdFx0ICpcdEB0eXBlIHtQb3NpdGl2ZX1cblx0XHRcdCAqXHRAc2lnbmFsXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLm1vZHVsYXRpb25JbmRleCA9IG5ldyBUb25lLk11bHRpcGx5KG9wdGlvbnMubW9kdWxhdGlvbkluZGV4KTtcblx0ICAgICAgICB0aGlzLm1vZHVsYXRpb25JbmRleC51bml0cyA9IFRvbmUuVHlwZS5Qb3NpdGl2ZTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICB0aGUgbm9kZSB3aGVyZSB0aGUgbW9kdWxhdGlvbiBoYXBwZW5zXG5cdFx0XHQgKiAgQHR5cGUge0dhaW5Ob2RlfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9tb2R1bGF0aW9uTm9kZSA9IG5ldyBUb25lLkdhaW4oMCk7XG5cdCAgICAgICAgLy9jb250cm9sIHRoZSB0d28gdm9pY2VzIGZyZXF1ZW5jeVxuXHQgICAgICAgIHRoaXMuZnJlcXVlbmN5LmNvbm5lY3QodGhpcy5fY2Fycmllci5mcmVxdWVuY3kpO1xuXHQgICAgICAgIHRoaXMuZnJlcXVlbmN5LmNoYWluKHRoaXMuaGFybW9uaWNpdHksIHRoaXMuX21vZHVsYXRvci5mcmVxdWVuY3kpO1xuXHQgICAgICAgIHRoaXMuZnJlcXVlbmN5LmNoYWluKHRoaXMubW9kdWxhdGlvbkluZGV4LCB0aGlzLl9tb2R1bGF0aW9uTm9kZSk7XG5cdCAgICAgICAgdGhpcy5kZXR1bmUuZmFuKHRoaXMuX2NhcnJpZXIuZGV0dW5lLCB0aGlzLl9tb2R1bGF0b3IuZGV0dW5lKTtcblx0ICAgICAgICB0aGlzLl9tb2R1bGF0b3IuY29ubmVjdCh0aGlzLl9tb2R1bGF0aW9uTm9kZS5nYWluKTtcblx0ICAgICAgICB0aGlzLl9tb2R1bGF0aW9uTm9kZS5jb25uZWN0KHRoaXMuX2NhcnJpZXIuZnJlcXVlbmN5KTtcblx0ICAgICAgICB0aGlzLl9jYXJyaWVyLmNvbm5lY3QodGhpcy5vdXRwdXQpO1xuXHQgICAgICAgIHRoaXMuX3JlYWRPbmx5KFtcblx0ICAgICAgICAgICAgJ2ZyZXF1ZW5jeScsXG5cdCAgICAgICAgICAgICdoYXJtb25pY2l0eScsXG5cdCAgICAgICAgICAgICdtb2R1bGF0aW9uSW5kZXgnLFxuXHQgICAgICAgICAgICAnb3NjaWxsYXRvcicsXG5cdCAgICAgICAgICAgICdlbnZlbG9wZScsXG5cdCAgICAgICAgICAgICdtb2R1bGF0aW9uJyxcblx0ICAgICAgICAgICAgJ21vZHVsYXRpb25FbnZlbG9wZScsXG5cdCAgICAgICAgICAgICdkZXR1bmUnXG5cdCAgICAgICAgXSk7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5GTVN5bnRoLCBUb25lLk1vbm9waG9uaWMpO1xuXHQgICAgLyoqXG5cdFx0ICogIEBzdGF0aWNcblx0XHQgKiAgQHR5cGUge09iamVjdH1cblx0XHQgKi9cblx0ICAgIFRvbmUuRk1TeW50aC5kZWZhdWx0cyA9IHtcblx0ICAgICAgICAnaGFybW9uaWNpdHknOiAzLFxuXHQgICAgICAgICdtb2R1bGF0aW9uSW5kZXgnOiAxMCxcblx0ICAgICAgICAnZGV0dW5lJzogMCxcblx0ICAgICAgICAnb3NjaWxsYXRvcic6IHsgJ3R5cGUnOiAnc2luZScgfSxcblx0ICAgICAgICAnZW52ZWxvcGUnOiB7XG5cdCAgICAgICAgICAgICdhdHRhY2snOiAwLjAxLFxuXHQgICAgICAgICAgICAnZGVjYXknOiAwLjAxLFxuXHQgICAgICAgICAgICAnc3VzdGFpbic6IDEsXG5cdCAgICAgICAgICAgICdyZWxlYXNlJzogMC41XG5cdCAgICAgICAgfSxcblx0ICAgICAgICAnbW9kdWxhdGlvbic6IHsgJ3R5cGUnOiAnc3F1YXJlJyB9LFxuXHQgICAgICAgICdtb2R1bGF0aW9uRW52ZWxvcGUnOiB7XG5cdCAgICAgICAgICAgICdhdHRhY2snOiAwLjUsXG5cdCAgICAgICAgICAgICdkZWNheSc6IDAsXG5cdCAgICAgICAgICAgICdzdXN0YWluJzogMSxcblx0ICAgICAgICAgICAgJ3JlbGVhc2UnOiAwLjVcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogXHR0cmlnZ2VyIHRoZSBhdHRhY2sgcG9ydGlvbiBvZiB0aGUgbm90ZVxuXHRcdCAqXG5cdFx0ICogIEBwYXJhbSAge1RpbWV9IFt0aW1lPW5vd10gdGhlIHRpbWUgdGhlIG5vdGUgd2lsbCBvY2N1clxuXHRcdCAqICBAcGFyYW0ge251bWJlcn0gW3ZlbG9jaXR5PTFdIHRoZSB2ZWxvY2l0eSBvZiB0aGUgbm90ZVxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5GTVN5bnRofSB0aGlzXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLkZNU3ludGgucHJvdG90eXBlLl90cmlnZ2VyRW52ZWxvcGVBdHRhY2sgPSBmdW5jdGlvbiAodGltZSwgdmVsb2NpdHkpIHtcblx0ICAgICAgICB0aW1lID0gdGhpcy50b1NlY29uZHModGltZSk7XG5cdCAgICAgICAgLy90aGUgZW52ZWxvcGVzXG5cdCAgICAgICAgdGhpcy5lbnZlbG9wZS50cmlnZ2VyQXR0YWNrKHRpbWUsIHZlbG9jaXR5KTtcblx0ICAgICAgICB0aGlzLm1vZHVsYXRpb25FbnZlbG9wZS50cmlnZ2VyQXR0YWNrKHRpbWUpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICB0cmlnZ2VyIHRoZSByZWxlYXNlIHBvcnRpb24gb2YgdGhlIG5vdGVcblx0XHQgKlxuXHRcdCAqICBAcGFyYW0gIHtUaW1lfSBbdGltZT1ub3ddIHRoZSB0aW1lIHRoZSBub3RlIHdpbGwgcmVsZWFzZVxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5GTVN5bnRofSB0aGlzXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLkZNU3ludGgucHJvdG90eXBlLl90cmlnZ2VyRW52ZWxvcGVSZWxlYXNlID0gZnVuY3Rpb24gKHRpbWUpIHtcblx0ICAgICAgICB0aW1lID0gdGhpcy50b1NlY29uZHModGltZSk7XG5cdCAgICAgICAgdGhpcy5lbnZlbG9wZS50cmlnZ2VyUmVsZWFzZSh0aW1lKTtcblx0ICAgICAgICB0aGlzLm1vZHVsYXRpb25FbnZlbG9wZS50cmlnZ2VyUmVsZWFzZSh0aW1lKTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgY2xlYW4gdXBcblx0XHQgKiAgQHJldHVybnMge1RvbmUuRk1TeW50aH0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5GTVN5bnRoLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuTW9ub3Bob25pYy5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuX3dyaXRhYmxlKFtcblx0ICAgICAgICAgICAgJ2ZyZXF1ZW5jeScsXG5cdCAgICAgICAgICAgICdoYXJtb25pY2l0eScsXG5cdCAgICAgICAgICAgICdtb2R1bGF0aW9uSW5kZXgnLFxuXHQgICAgICAgICAgICAnb3NjaWxsYXRvcicsXG5cdCAgICAgICAgICAgICdlbnZlbG9wZScsXG5cdCAgICAgICAgICAgICdtb2R1bGF0aW9uJyxcblx0ICAgICAgICAgICAgJ21vZHVsYXRpb25FbnZlbG9wZScsXG5cdCAgICAgICAgICAgICdkZXR1bmUnXG5cdCAgICAgICAgXSk7XG5cdCAgICAgICAgdGhpcy5fY2Fycmllci5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fY2FycmllciA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fbW9kdWxhdG9yLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9tb2R1bGF0b3IgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuZnJlcXVlbmN5LmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLmZyZXF1ZW5jeSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5kZXR1bmUuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuZGV0dW5lID0gbnVsbDtcblx0ICAgICAgICB0aGlzLm1vZHVsYXRpb25JbmRleC5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5tb2R1bGF0aW9uSW5kZXggPSBudWxsO1xuXHQgICAgICAgIHRoaXMuaGFybW9uaWNpdHkuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuaGFybW9uaWNpdHkgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX21vZHVsYXRpb25Ob2RlLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9tb2R1bGF0aW9uTm9kZSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5vc2NpbGxhdG9yID0gbnVsbDtcblx0ICAgICAgICB0aGlzLmVudmVsb3BlID0gbnVsbDtcblx0ICAgICAgICB0aGlzLm1vZHVsYXRpb25FbnZlbG9wZSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5tb2R1bGF0aW9uID0gbnVsbDtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVG9uZS5GTVN5bnRoO1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgIFRvbmUuTWVtYnJhbmVTeW50aCBtYWtlcyBraWNrIGFuZCB0b20gc291bmRzIHVzaW5nIGEgc2luZ2xlIG9zY2lsbGF0b3Jcblx0XHQgKiAgICAgICAgICB3aXRoIGFuIGFtcGxpdHVkZSBlbnZlbG9wZSBhbmQgZnJlcXVlbmN5IHJhbXAuIEEgVG9uZS5PbW5pT3NjaWxsYXRvclxuXHRcdCAqICAgICAgICAgIGlzIHJvdXRlZCB0aHJvdWdoIGEgVG9uZS5BbXBsaXR1ZGVFbnZlbG9wZSB0byB0aGUgb3V0cHV0LiBUaGUgZHJ1bVxuXHRcdCAqICAgICAgICAgIHF1YWxpdHkgb2YgdGhlIHNvdW5kIGNvbWVzIGZyb20gdGhlIGZyZXF1ZW5jeSBlbnZlbG9wZSBhcHBsaWVkXG5cdFx0ICogICAgICAgICAgZHVyaW5nIGR1cmluZyBUb25lLk1lbWJyYW5lU3ludGgudHJpZ2dlckF0dGFjayhub3RlKS4gVGhlIGZyZXF1ZW5jeVxuXHRcdCAqICAgICAgICAgIGVudmVsb3BlIHN0YXJ0cyBhdCA8Y29kZT5ub3RlICogLm9jdGF2ZXM8L2NvZGU+IGFuZCByYW1wcyB0byBcblx0XHQgKiAgICAgICAgICA8Y29kZT5ub3RlPC9jb2RlPiBvdmVyIHRoZSBkdXJhdGlvbiBvZiA8Y29kZT4ucGl0Y2hEZWNheTwvY29kZT4uIFxuXHRcdCAqXG5cdFx0ICogIEBjb25zdHJ1Y3RvclxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZS5JbnN0cnVtZW50fVxuXHRcdCAqICBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIHRoZSBvcHRpb25zIGF2YWlsYWJsZSBmb3IgdGhlIHN5bnRoIFxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICBzZWUgZGVmYXVsdHMgYmVsb3dcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiB2YXIgc3ludGggPSBuZXcgVG9uZS5NZW1icmFuZVN5bnRoKCkudG9NYXN0ZXIoKTtcblx0XHQgKiBzeW50aC50cmlnZ2VyQXR0YWNrUmVsZWFzZShcIkMyXCIsIFwiOG5cIik7XG5cdFx0ICovXG5cdCAgICBUb25lLk1lbWJyYW5lU3ludGggPSBmdW5jdGlvbiAob3B0aW9ucykge1xuXHQgICAgICAgIG9wdGlvbnMgPSBUb25lLmRlZmF1bHRBcmcob3B0aW9ucywgVG9uZS5NZW1icmFuZVN5bnRoLmRlZmF1bHRzKTtcblx0ICAgICAgICBUb25lLkluc3RydW1lbnQuY2FsbCh0aGlzLCBvcHRpb25zKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgb3NjaWxsYXRvci5cblx0XHRcdCAqICBAdHlwZSB7VG9uZS5PbW5pT3NjaWxsYXRvcn1cblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMub3NjaWxsYXRvciA9IG5ldyBUb25lLk9tbmlPc2NpbGxhdG9yKG9wdGlvbnMub3NjaWxsYXRvcikuc3RhcnQoKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgYW1wbGl0dWRlIGVudmVsb3BlLlxuXHRcdFx0ICogIEB0eXBlIHtUb25lLkFtcGxpdHVkZUVudmVsb3BlfVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5lbnZlbG9wZSA9IG5ldyBUb25lLkFtcGxpdHVkZUVudmVsb3BlKG9wdGlvbnMuZW52ZWxvcGUpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBudW1iZXIgb2Ygb2N0YXZlcyB0aGUgcGl0Y2ggZW52ZWxvcGUgcmFtcHMuXG5cdFx0XHQgKiAgQHR5cGUge1Bvc2l0aXZlfVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5vY3RhdmVzID0gb3B0aW9ucy5vY3RhdmVzO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBhbW91bnQgb2YgdGltZSB0aGUgZnJlcXVlbmN5IGVudmVsb3BlIHRha2VzLiBcblx0XHRcdCAqICBAdHlwZSB7VGltZX1cblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMucGl0Y2hEZWNheSA9IG9wdGlvbnMucGl0Y2hEZWNheTtcblx0ICAgICAgICB0aGlzLm9zY2lsbGF0b3IuY2hhaW4odGhpcy5lbnZlbG9wZSwgdGhpcy5vdXRwdXQpO1xuXHQgICAgICAgIHRoaXMuX3JlYWRPbmx5KFtcblx0ICAgICAgICAgICAgJ29zY2lsbGF0b3InLFxuXHQgICAgICAgICAgICAnZW52ZWxvcGUnXG5cdCAgICAgICAgXSk7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5NZW1icmFuZVN5bnRoLCBUb25lLkluc3RydW1lbnQpO1xuXHQgICAgLyoqXG5cdFx0ICogIEBzdGF0aWNcblx0XHQgKiAgQHR5cGUge09iamVjdH1cblx0XHQgKi9cblx0ICAgIFRvbmUuTWVtYnJhbmVTeW50aC5kZWZhdWx0cyA9IHtcblx0ICAgICAgICAncGl0Y2hEZWNheSc6IDAuMDUsXG5cdCAgICAgICAgJ29jdGF2ZXMnOiAxMCxcblx0ICAgICAgICAnb3NjaWxsYXRvcic6IHsgJ3R5cGUnOiAnc2luZScgfSxcblx0ICAgICAgICAnZW52ZWxvcGUnOiB7XG5cdCAgICAgICAgICAgICdhdHRhY2snOiAwLjAwMSxcblx0ICAgICAgICAgICAgJ2RlY2F5JzogMC40LFxuXHQgICAgICAgICAgICAnc3VzdGFpbic6IDAuMDEsXG5cdCAgICAgICAgICAgICdyZWxlYXNlJzogMS40LFxuXHQgICAgICAgICAgICAnYXR0YWNrQ3VydmUnOiAnZXhwb25lbnRpYWwnXG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBUcmlnZ2VyIHRoZSBub3RlIGF0IHRoZSBnaXZlbiB0aW1lIHdpdGggdGhlIGdpdmVuIHZlbG9jaXR5LiBcblx0XHQgKiAgXG5cdFx0ICogIEBwYXJhbSAge0ZyZXF1ZW5jeX0gbm90ZSAgICAgdGhlIG5vdGVcblx0XHQgKiAgQHBhcmFtICB7VGltZX0gW3RpbWU9bm93XSAgICAgdGhlIHRpbWUsIGlmIG5vdCBnaXZlbiBpcyBub3dcblx0XHQgKiAgQHBhcmFtICB7bnVtYmVyfSBbdmVsb2NpdHk9MV0gdmVsb2NpdHkgZGVmYXVsdHMgdG8gMVxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5NZW1icmFuZVN5bnRofSB0aGlzXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogIGtpY2sudHJpZ2dlckF0dGFjayg2MCk7XG5cdFx0ICovXG5cdCAgICBUb25lLk1lbWJyYW5lU3ludGgucHJvdG90eXBlLnRyaWdnZXJBdHRhY2sgPSBmdW5jdGlvbiAobm90ZSwgdGltZSwgdmVsb2NpdHkpIHtcblx0ICAgICAgICB0aW1lID0gdGhpcy50b1NlY29uZHModGltZSk7XG5cdCAgICAgICAgbm90ZSA9IHRoaXMudG9GcmVxdWVuY3kobm90ZSk7XG5cdCAgICAgICAgdmFyIG1heE5vdGUgPSBub3RlICogdGhpcy5vY3RhdmVzO1xuXHQgICAgICAgIHRoaXMub3NjaWxsYXRvci5mcmVxdWVuY3kuc2V0VmFsdWVBdFRpbWUobWF4Tm90ZSwgdGltZSk7XG5cdCAgICAgICAgdGhpcy5vc2NpbGxhdG9yLmZyZXF1ZW5jeS5leHBvbmVudGlhbFJhbXBUb1ZhbHVlQXRUaW1lKG5vdGUsIHRpbWUgKyB0aGlzLnRvU2Vjb25kcyh0aGlzLnBpdGNoRGVjYXkpKTtcblx0ICAgICAgICB0aGlzLmVudmVsb3BlLnRyaWdnZXJBdHRhY2sodGltZSwgdmVsb2NpdHkpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBUcmlnZ2VyIHRoZSByZWxlYXNlIHBvcnRpb24gb2YgdGhlIG5vdGUuXG5cdFx0ICogIFxuXHRcdCAqICBAcGFyYW0gIHtUaW1lfSBbdGltZT1ub3ddIHRoZSB0aW1lIHRoZSBub3RlIHdpbGwgcmVsZWFzZVxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5NZW1icmFuZVN5bnRofSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLk1lbWJyYW5lU3ludGgucHJvdG90eXBlLnRyaWdnZXJSZWxlYXNlID0gZnVuY3Rpb24gKHRpbWUpIHtcblx0ICAgICAgICB0aGlzLmVudmVsb3BlLnRyaWdnZXJSZWxlYXNlKHRpbWUpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBDbGVhbiB1cC5cblx0XHQgKiAgQHJldHVybnMge1RvbmUuTWVtYnJhbmVTeW50aH0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5NZW1icmFuZVN5bnRoLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuSW5zdHJ1bWVudC5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuX3dyaXRhYmxlKFtcblx0ICAgICAgICAgICAgJ29zY2lsbGF0b3InLFxuXHQgICAgICAgICAgICAnZW52ZWxvcGUnXG5cdCAgICAgICAgXSk7XG5cdCAgICAgICAgdGhpcy5vc2NpbGxhdG9yLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLm9zY2lsbGF0b3IgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuZW52ZWxvcGUuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuZW52ZWxvcGUgPSBudWxsO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLk1lbWJyYW5lU3ludGg7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIC8qKlxuXHRcdCAqICBJbmhhcm1vbmljIHJhdGlvIG9mIGZyZXF1ZW5jaWVzIGJhc2VkIG9uIHRoZSBSb2xhbmQgVFItODA4XG5cdFx0ICogIFRha2VuIGZyb20gaHR0cHM6Ly9jY3JtYS5zdGFuZm9yZC5lZHUvcGFwZXJzL3RyLTgwOC1jeW1iYWwtcGh5c2ljYWxseS1pbmZvcm1lZC1jaXJjdWl0LWJlbmRhYmxlLWRpZ2l0YWwtbW9kZWxcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKiAgQHN0YXRpY1xuXHRcdCAqICBAdHlwZSB7QXJyYXl9XG5cdFx0ICovXG5cdCAgICB2YXIgaW5oYXJtUmF0aW9zID0gW1xuXHQgICAgICAgIDEsXG5cdCAgICAgICAgMS40ODMsXG5cdCAgICAgICAgMS45MzIsXG5cdCAgICAgICAgMi41NDYsXG5cdCAgICAgICAgMi42Myxcblx0ICAgICAgICAzLjg5N1xuXHQgICAgXTtcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgIEEgaGlnaGx5IGluaGFybW9uaWMgYW5kIHNwZWN0cmFsbHkgY29tcGxleCBzb3VyY2Ugd2l0aCBhIGhpZ2hwYXNzIGZpbHRlclxuXHRcdCAqICAgICAgICAgIGFuZCBhbXBsaXR1ZGUgZW52ZWxvcGUgd2hpY2ggaXMgZ29vZCBmb3IgbWFraW5nIG1ldGFsb3Bob25lIHNvdW5kcy4gQmFzZWRcblx0XHQgKiAgICAgICAgICBvbiBDeW1iYWxTeW50aCBieSBbQHBvbHlyaHl0aG1hdGljXShodHRwczovL2dpdGh1Yi5jb20vcG9seXJoeXRobWF0aWMpLlxuXHRcdCAqICAgICAgICAgIEluc3BpcmF0aW9uIGZyb20gW1NvdW5kIG9uIFNvdW5kXShodHRwczovL3dlYi5hcmNoaXZlLm9yZy93ZWIvMjAxNjA2MTAxNDM5MjQvaHR0cHM6Ly93d3cuc291bmRvbnNvdW5kLmNvbS9zb3MvanVsMDIvYXJ0aWNsZXMvc3ludGhzZWNyZXRzMDcwMi5hc3ApLlxuXHRcdCAqXG5cdFx0ICogIEBjb25zdHJ1Y3RvclxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZS5JbnN0cnVtZW50fVxuXHRcdCAqICBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIFRoZSBvcHRpb25zIGF2YWlsYmxlIGZvciB0aGUgc3ludGhcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VlIGRlZmF1bHRzIGJlbG93XG5cdFx0ICovXG5cdCAgICBUb25lLk1ldGFsU3ludGggPSBmdW5jdGlvbiAob3B0aW9ucykge1xuXHQgICAgICAgIG9wdGlvbnMgPSBUb25lLmRlZmF1bHRBcmcob3B0aW9ucywgVG9uZS5NZXRhbFN5bnRoLmRlZmF1bHRzKTtcblx0ICAgICAgICBUb25lLkluc3RydW1lbnQuY2FsbCh0aGlzLCBvcHRpb25zKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgZnJlcXVlbmN5IG9mIHRoZSBjeW1iYWxcblx0XHRcdCAqICBAdHlwZSAge0ZyZXF1ZW5jeX1cblx0XHRcdCAqICBAc2lnbmFsXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmZyZXF1ZW5jeSA9IG5ldyBUb25lLlNpZ25hbChvcHRpb25zLmZyZXF1ZW5jeSwgVG9uZS5UeXBlLkZyZXF1ZW5jeSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGFycmF5IG9mIEZNT3NjaWxsYXRvcnNcblx0XHRcdCAqICBAdHlwZSAge0FycmF5fVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9vc2NpbGxhdG9ycyA9IFtdO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBmcmVxdWVuY3kgbXVsdGlwbGllcnNcblx0XHRcdCAqICBAdHlwZSB7QXJyYXl9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2ZyZXFNdWx0aXBsaWVycyA9IFtdO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBhbXBsaXR1ZGUgZm9yIHRoZSBib2R5XG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuR2Fpbn1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fYW1wbGl0dWUgPSBuZXcgVG9uZS5HYWluKDApLmNvbm5lY3QodGhpcy5vdXRwdXQpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIGhpZ2hwYXNzIHRoZSBvdXRwdXRcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5GaWx0ZXJ9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2hpZ2hwYXNzID0gbmV3IFRvbmUuRmlsdGVyKHtcblx0ICAgICAgICAgICAgJ3R5cGUnOiAnaGlnaHBhc3MnLFxuXHQgICAgICAgICAgICAnUSc6IC0zLjAxMDI5OTk1NjYzOTgxMjVcblx0ICAgICAgICB9KS5jb25uZWN0KHRoaXMuX2FtcGxpdHVlKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgbnVtYmVyIG9mIG9jdGF2ZXMgdGhlIGhpZ2hwYXNzXG5cdFx0XHQgKiAgZmlsdGVyIGZyZXF1ZW5jeSByYW1wc1xuXHRcdFx0ICogIEB0eXBlIHtOdW1iZXJ9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX29jdGF2ZXMgPSBvcHRpb25zLm9jdGF2ZXM7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgU2NhbGUgdGhlIGJvZHkgZW52ZWxvcGVcblx0XHRcdCAqICBmb3IgdGhlIGJhbmRwYXNzXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuU2NhbGV9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2ZpbHRlckZyZXFTY2FsZXIgPSBuZXcgVG9uZS5TY2FsZShvcHRpb25zLnJlc29uYW5jZSwgNzAwMCk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGVudmVsb3BlIHdoaWNoIGlzIGNvbm5lY3RlZCBib3RoIHRvIHRoZVxuXHRcdFx0ICogIGFtcGxpdHVkZSBhbmQgaGlnaHBhc3MgZmlsdGVyJ3MgY3V0b2ZmIGZyZXF1ZW5jeVxuXHRcdFx0ICogIEB0eXBlICB7VG9uZS5FbnZlbG9wZX1cblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuZW52ZWxvcGUgPSBuZXcgVG9uZS5FbnZlbG9wZSh7XG5cdCAgICAgICAgICAgICdhdHRhY2snOiBvcHRpb25zLmVudmVsb3BlLmF0dGFjayxcblx0ICAgICAgICAgICAgJ2F0dGFja0N1cnZlJzogJ2xpbmVhcicsXG5cdCAgICAgICAgICAgICdkZWNheSc6IG9wdGlvbnMuZW52ZWxvcGUuZGVjYXksXG5cdCAgICAgICAgICAgICdzdXN0YWluJzogMCxcblx0ICAgICAgICAgICAgJ3JlbGVhc2UnOiBvcHRpb25zLmVudmVsb3BlLnJlbGVhc2Vcblx0ICAgICAgICB9KS5jaGFpbih0aGlzLl9maWx0ZXJGcmVxU2NhbGVyLCB0aGlzLl9oaWdocGFzcy5mcmVxdWVuY3kpO1xuXHQgICAgICAgIHRoaXMuZW52ZWxvcGUuY29ubmVjdCh0aGlzLl9hbXBsaXR1ZS5nYWluKTtcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGluaGFybVJhdGlvcy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICB2YXIgb3NjID0gbmV3IFRvbmUuRk1Pc2NpbGxhdG9yKHtcblx0ICAgICAgICAgICAgICAgICd0eXBlJzogJ3NxdWFyZScsXG5cdCAgICAgICAgICAgICAgICAnbW9kdWxhdGlvblR5cGUnOiAnc3F1YXJlJyxcblx0ICAgICAgICAgICAgICAgICdoYXJtb25pY2l0eSc6IG9wdGlvbnMuaGFybW9uaWNpdHksXG5cdCAgICAgICAgICAgICAgICAnbW9kdWxhdGlvbkluZGV4Jzogb3B0aW9ucy5tb2R1bGF0aW9uSW5kZXhcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIG9zYy5jb25uZWN0KHRoaXMuX2hpZ2hwYXNzKS5zdGFydCgwKTtcblx0ICAgICAgICAgICAgdGhpcy5fb3NjaWxsYXRvcnNbaV0gPSBvc2M7XG5cdCAgICAgICAgICAgIHZhciBtdWx0ID0gbmV3IFRvbmUuTXVsdGlwbHkoaW5oYXJtUmF0aW9zW2ldKTtcblx0ICAgICAgICAgICAgdGhpcy5fZnJlcU11bHRpcGxpZXJzW2ldID0gbXVsdDtcblx0ICAgICAgICAgICAgdGhpcy5mcmVxdWVuY3kuY2hhaW4obXVsdCwgb3NjLmZyZXF1ZW5jeSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8vc2V0IHRoZSBvY3RhdmVzXG5cdCAgICAgICAgdGhpcy5vY3RhdmVzID0gb3B0aW9ucy5vY3RhdmVzO1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuTWV0YWxTeW50aCwgVG9uZS5JbnN0cnVtZW50KTtcblx0ICAgIC8qKlxuXHRcdCAqICBkZWZhdWx0IHZhbHVlc1xuXHRcdCAqICBAc3RhdGljXG5cdFx0ICogIEBjb25zdFxuXHRcdCAqICBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqL1xuXHQgICAgVG9uZS5NZXRhbFN5bnRoLmRlZmF1bHRzID0ge1xuXHQgICAgICAgICdmcmVxdWVuY3knOiAyMDAsXG5cdCAgICAgICAgJ2VudmVsb3BlJzoge1xuXHQgICAgICAgICAgICAnYXR0YWNrJzogMC4wMDEsXG5cdCAgICAgICAgICAgICdkZWNheSc6IDEuNCxcblx0ICAgICAgICAgICAgJ3JlbGVhc2UnOiAwLjJcblx0ICAgICAgICB9LFxuXHQgICAgICAgICdoYXJtb25pY2l0eSc6IDUuMSxcblx0ICAgICAgICAnbW9kdWxhdGlvbkluZGV4JzogMzIsXG5cdCAgICAgICAgJ3Jlc29uYW5jZSc6IDQwMDAsXG5cdCAgICAgICAgJ29jdGF2ZXMnOiAxLjVcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgVHJpZ2dlciB0aGUgYXR0YWNrLlxuXHRcdCAqICBAcGFyYW0gIHtUaW1lfSAgdGltZSAgICAgIFdoZW4gdGhlIGF0dGFjayBzaG91bGQgYmUgdHJpZ2dlcmVkLlxuXHRcdCAqICBAcGFyYW0gIHtOb3JtYWxSYW5nZX0gIFt2ZWxvY2l0eT0xXSAgVGhlIHZlbG9jaXR5IHRoYXQgdGhlIGVudmVsb3BlIHNob3VsZCBiZSB0cmlnZ2VyZWQgYXQuXG5cdFx0ICogIEByZXR1cm4gIHtUb25lLk1ldGFsU3ludGh9ICB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLk1ldGFsU3ludGgucHJvdG90eXBlLnRyaWdnZXJBdHRhY2sgPSBmdW5jdGlvbiAodGltZSwgdmVsKSB7XG5cdCAgICAgICAgdGltZSA9IHRoaXMudG9TZWNvbmRzKHRpbWUpO1xuXHQgICAgICAgIHZlbCA9IFRvbmUuZGVmYXVsdEFyZyh2ZWwsIDEpO1xuXHQgICAgICAgIHRoaXMuZW52ZWxvcGUudHJpZ2dlckF0dGFjayh0aW1lLCB2ZWwpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBUcmlnZ2VyIHRoZSByZWxlYXNlIG9mIHRoZSBlbnZlbG9wZS5cblx0XHQgKiAgQHBhcmFtICB7VGltZX0gIHRpbWUgICAgICBXaGVuIHRoZSByZWxlYXNlIHNob3VsZCBiZSB0cmlnZ2VyZWQuXG5cdFx0ICogIEByZXR1cm4gIHtUb25lLk1ldGFsU3ludGh9ICB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLk1ldGFsU3ludGgucHJvdG90eXBlLnRyaWdnZXJSZWxlYXNlID0gZnVuY3Rpb24gKHRpbWUpIHtcblx0ICAgICAgICB0aW1lID0gdGhpcy50b1NlY29uZHModGltZSk7XG5cdCAgICAgICAgdGhpcy5lbnZlbG9wZS50cmlnZ2VyUmVsZWFzZSh0aW1lKTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgVHJpZ2dlciB0aGUgYXR0YWNrIGFuZCByZWxlYXNlIG9mIHRoZSBlbnZlbG9wZSBhZnRlciB0aGUgZ2l2ZW5cblx0XHQgKiAgZHVyYXRpb24uXG5cdFx0ICogIEBwYXJhbSAge1RpbWV9ICBkdXJhdGlvbiAgVGhlIGR1cmF0aW9uIGJlZm9yZSB0cmlnZ2VyaW5nIHRoZSByZWxlYXNlXG5cdFx0ICogIEBwYXJhbSAge1RpbWV9ICB0aW1lICAgICAgV2hlbiB0aGUgYXR0YWNrIHNob3VsZCBiZSB0cmlnZ2VyZWQuXG5cdFx0ICogIEBwYXJhbSAge05vcm1hbFJhbmdlfSAgW3ZlbG9jaXR5PTFdICBUaGUgdmVsb2NpdHkgdGhhdCB0aGUgZW52ZWxvcGUgc2hvdWxkIGJlIHRyaWdnZXJlZCBhdC5cblx0XHQgKiAgQHJldHVybiAge1RvbmUuTWV0YWxTeW50aH0gIHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuTWV0YWxTeW50aC5wcm90b3R5cGUudHJpZ2dlckF0dGFja1JlbGVhc2UgPSBmdW5jdGlvbiAoZHVyYXRpb24sIHRpbWUsIHZlbG9jaXR5KSB7XG5cdCAgICAgICAgdGltZSA9IHRoaXMudG9TZWNvbmRzKHRpbWUpO1xuXHQgICAgICAgIGR1cmF0aW9uID0gdGhpcy50b1NlY29uZHMoZHVyYXRpb24pO1xuXHQgICAgICAgIHRoaXMudHJpZ2dlckF0dGFjayh0aW1lLCB2ZWxvY2l0eSk7XG5cdCAgICAgICAgdGhpcy50cmlnZ2VyUmVsZWFzZSh0aW1lICsgZHVyYXRpb24pO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgbW9kdWxhdGlvbkluZGV4IG9mIHRoZSBvc2NpbGxhdG9ycyB3aGljaCBtYWtlIHVwIHRoZSBzb3VyY2UuXG5cdFx0ICogIHNlZSBUb25lLkZNT3NjaWxsYXRvci5tb2R1bGF0aW9uSW5kZXhcblx0XHQgKiAgQG1lbWJlck9mIFRvbmUuTWV0YWxTeW50aCNcblx0XHQgKiAgQHR5cGUge1Bvc2l0aXZlfVxuXHRcdCAqICBAbmFtZSAgbW9kdWxhdGlvbkluZGV4XG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5NZXRhbFN5bnRoLnByb3RvdHlwZSwgJ21vZHVsYXRpb25JbmRleCcsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX29zY2lsbGF0b3JzWzBdLm1vZHVsYXRpb25JbmRleC52YWx1ZTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX29zY2lsbGF0b3JzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9vc2NpbGxhdG9yc1tpXS5tb2R1bGF0aW9uSW5kZXgudmFsdWUgPSB2YWw7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgaGFybW9uaWNpdHkgb2YgdGhlIG9zY2lsbGF0b3JzIHdoaWNoIG1ha2UgdXAgdGhlIHNvdXJjZS5cblx0XHQgKiAgc2VlIFRvbmUuRk1Pc2NpbGxhdG9yLmhhcm1vbmljaXR5XG5cdFx0ICogIEBtZW1iZXJPZiBUb25lLk1ldGFsU3ludGgjXG5cdFx0ICogIEB0eXBlIHtQb3NpdGl2ZX1cblx0XHQgKiAgQG5hbWUgIGhhcm1vbmljaXR5XG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5NZXRhbFN5bnRoLnByb3RvdHlwZSwgJ2hhcm1vbmljaXR5Jywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fb3NjaWxsYXRvcnNbMF0uaGFybW9uaWNpdHkudmFsdWU7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9vc2NpbGxhdG9ycy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fb3NjaWxsYXRvcnNbaV0uaGFybW9uaWNpdHkudmFsdWUgPSB2YWw7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgZnJlcXVlbmN5IG9mIHRoZSBoaWdocGFzcyBmaWx0ZXIgYXR0YWNoZWQgdG8gdGhlIGVudmVsb3BlXG5cdFx0ICogIEBtZW1iZXJPZiBUb25lLk1ldGFsU3ludGgjXG5cdFx0ICogIEB0eXBlIHtGcmVxdWVuY3l9XG5cdFx0ICogIEBuYW1lICByZXNvbmFuY2Vcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLk1ldGFsU3ludGgucHJvdG90eXBlLCAncmVzb25hbmNlJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fZmlsdGVyRnJlcVNjYWxlci5taW47XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcblx0ICAgICAgICAgICAgdGhpcy5fZmlsdGVyRnJlcVNjYWxlci5taW4gPSB2YWw7XG5cdCAgICAgICAgICAgIHRoaXMub2N0YXZlcyA9IHRoaXMuX29jdGF2ZXM7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgVGhlIG51bWJlciBvZiBvY3RhdmVzIGFib3ZlIHRoZSBcInJlc29uYW5jZVwiIGZyZXF1ZW5jeVxuXHRcdCAqICB0aGF0IHRoZSBmaWx0ZXIgcmFtcHMgZHVyaW5nIHRoZSBhdHRhY2svZGVjYXkgZW52ZWxvcGVcblx0XHQgKiAgQG1lbWJlck9mIFRvbmUuTWV0YWxTeW50aCNcblx0XHQgKiAgQHR5cGUge051bWJlcn1cblx0XHQgKiAgQG5hbWUgIG9jdGF2ZXNcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLk1ldGFsU3ludGgucHJvdG90eXBlLCAnb2N0YXZlcycsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX29jdGF2ZXM7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChvY3RzKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX29jdGF2ZXMgPSBvY3RzO1xuXHQgICAgICAgICAgICB0aGlzLl9maWx0ZXJGcmVxU2NhbGVyLm1heCA9IHRoaXMuX2ZpbHRlckZyZXFTY2FsZXIubWluICogTWF0aC5wb3coMiwgb2N0cyk7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgQ2xlYW4gdXBcblx0XHQgKiAgQHJldHVybnMge1RvbmUuTWV0YWxTeW50aH0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5NZXRhbFN5bnRoLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuSW5zdHJ1bWVudC5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fb3NjaWxsYXRvcnMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgdGhpcy5fb3NjaWxsYXRvcnNbaV0uZGlzcG9zZSgpO1xuXHQgICAgICAgICAgICB0aGlzLl9mcmVxTXVsdGlwbGllcnNbaV0uZGlzcG9zZSgpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB0aGlzLl9vc2NpbGxhdG9ycyA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fZnJlcU11bHRpcGxpZXJzID0gbnVsbDtcblx0ICAgICAgICB0aGlzLmZyZXF1ZW5jeS5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5mcmVxdWVuY3kgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX2ZpbHRlckZyZXFTY2FsZXIuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX2ZpbHRlckZyZXFTY2FsZXIgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX2FtcGxpdHVlLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9hbXBsaXR1ZSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5lbnZlbG9wZS5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5lbnZlbG9wZSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5faGlnaHBhc3MuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX2hpZ2hwYXNzID0gbnVsbDtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVG9uZS5NZXRhbFN5bnRoO1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICAvKipcblx0XHQgKiAgQnVmZmVyU291cmNlIHBvbHlmaWxsXG5cdFx0ICovXG5cdCAgICBpZiAod2luZG93LkF1ZGlvQnVmZmVyU291cmNlTm9kZSAmJiAhQXVkaW9CdWZmZXJTb3VyY2VOb2RlLnByb3RvdHlwZS5zdGFydCkge1xuXHQgICAgICAgIEF1ZGlvQnVmZmVyU291cmNlTm9kZS5wcm90b3R5cGUuc3RhcnQgPSBBdWRpb0J1ZmZlclNvdXJjZU5vZGUucHJvdG90eXBlLm5vdGVHcmFpbk9uO1xuXHQgICAgICAgIEF1ZGlvQnVmZmVyU291cmNlTm9kZS5wcm90b3R5cGUuc3RvcCA9IEF1ZGlvQnVmZmVyU291cmNlTm9kZS5wcm90b3R5cGUubm90ZU9mZjtcblx0ICAgIH1cblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgV3JhcHBlciBhcm91bmQgdGhlIG5hdGl2ZSBCdWZmZXJTb3VyY2VOb2RlLlxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZS5BdWRpb05vZGV9XG5cdFx0ICogIEBwYXJhbSAge0F1ZGlvQnVmZmVyfFRvbmUuQnVmZmVyfSAgYnVmZmVyICAgVGhlIGJ1ZmZlciB0byBwbGF5XG5cdFx0ICogIEBwYXJhbSAge0Z1bmN0aW9ufSAgb25sb2FkICBUaGUgY2FsbGJhY2sgdG8gaW52b2tlIHdoZW4gdGhlXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyIGlzIGRvbmUgcGxheWluZy5cblx0XHQgKi9cblx0ICAgIFRvbmUuQnVmZmVyU291cmNlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBvcHRpb25zID0gVG9uZS5kZWZhdWx0cyhhcmd1bWVudHMsIFtcblx0ICAgICAgICAgICAgJ2J1ZmZlcicsXG5cdCAgICAgICAgICAgICdvbmxvYWQnXG5cdCAgICAgICAgXSwgVG9uZS5CdWZmZXJTb3VyY2UpO1xuXHQgICAgICAgIFRvbmUuQXVkaW9Ob2RlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGNhbGxiYWNrIHRvIGludm9rZSBhZnRlciB0aGVcblx0XHRcdCAqICBidWZmZXIgc291cmNlIGlzIGRvbmUgcGxheWluZy5cblx0XHRcdCAqICBAdHlwZSAge0Z1bmN0aW9ufVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5vbmVuZGVkID0gb3B0aW9ucy5vbmVuZGVkO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSB0aW1lIHRoYXQgdGhlIGJ1ZmZlciB3YXMgc3RhcnRlZC5cblx0XHRcdCAqICBAdHlwZSAge051bWJlcn1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fc3RhcnRUaW1lID0gLTE7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIHRpbWUgdGhhdCB0aGUgYnVmZmVyIGlzIHNjaGVkdWxlZCB0byBzdG9wLlxuXHRcdFx0ICogIEB0eXBlICB7TnVtYmVyfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9zdG9wVGltZSA9IC0xO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBnYWluIG5vZGUgd2hpY2ggZW52ZWxvcGVzIHRoZSBCdWZmZXJTb3VyY2Vcblx0XHRcdCAqICBAdHlwZSAge1RvbmUuR2Fpbn1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fZ2Fpbk5vZGUgPSB0aGlzLm91dHB1dCA9IG5ldyBUb25lLkdhaW4oKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgYnVmZmVyIHNvdXJjZVxuXHRcdFx0ICogIEB0eXBlICB7QXVkaW9CdWZmZXJTb3VyY2VOb2RlfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9zb3VyY2UgPSB0aGlzLmNvbnRleHQuY3JlYXRlQnVmZmVyU291cmNlKCk7XG5cdCAgICAgICAgdGhpcy5fc291cmNlLmNvbm5lY3QodGhpcy5fZ2Fpbk5vZGUpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogVGhlIHByaXZhdGUgYnVmZmVyIGluc3RhbmNlXG5cdFx0XHQgKiBAdHlwZSB7VG9uZS5CdWZmZXJ9XG5cdFx0XHQgKiBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fYnVmZmVyID0gbmV3IFRvbmUuQnVmZmVyKG9wdGlvbnMuYnVmZmVyLCBvcHRpb25zLm9ubG9hZCk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIHBsYXliYWNrUmF0ZSBvZiB0aGUgYnVmZmVyXG5cdFx0XHQgKiAgQHR5cGUge1Bvc2l0aXZlfVxuXHRcdFx0ICogIEBzaWduYWxcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMucGxheWJhY2tSYXRlID0gbmV3IFRvbmUuUGFyYW0odGhpcy5fc291cmNlLnBsYXliYWNrUmF0ZSwgVG9uZS5UeXBlLlBvc2l0aXZlKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgZmFkZUluIHRpbWUgb2YgdGhlIGFtcGxpdHVkZSBlbnZlbG9wZS5cblx0XHRcdCAqICBAdHlwZSB7VGltZX1cblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuZmFkZUluID0gb3B0aW9ucy5mYWRlSW47XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGZhZGVPdXQgdGltZSBvZiB0aGUgYW1wbGl0dWRlIGVudmVsb3BlLlxuXHRcdFx0ICogIEB0eXBlIHtUaW1lfVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5mYWRlT3V0ID0gb3B0aW9ucy5mYWRlT3V0O1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSB2YWx1ZSB0aGF0IHRoZSBidWZmZXIgcmFtcHMgdG9cblx0XHRcdCAqICBAdHlwZSB7R2Fpbn1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fZ2FpbiA9IDE7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiBUaGUgb25lbmRlZCB0aW1lb3V0XG5cdFx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdFx0ICogQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX29uZW5kZWRUaW1lb3V0ID0gLTE7XG5cdCAgICAgICAgdGhpcy5sb29wID0gb3B0aW9ucy5sb29wO1xuXHQgICAgICAgIHRoaXMubG9vcFN0YXJ0ID0gb3B0aW9ucy5sb29wU3RhcnQ7XG5cdCAgICAgICAgdGhpcy5sb29wRW5kID0gb3B0aW9ucy5sb29wRW5kO1xuXHQgICAgICAgIHRoaXMucGxheWJhY2tSYXRlLnZhbHVlID0gb3B0aW9ucy5wbGF5YmFja1JhdGU7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5CdWZmZXJTb3VyY2UsIFRvbmUuQXVkaW9Ob2RlKTtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgZGVmYXVsdHNcblx0XHQgKiAgQGNvbnN0XG5cdFx0ICogIEB0eXBlICB7T2JqZWN0fVxuXHRcdCAqL1xuXHQgICAgVG9uZS5CdWZmZXJTb3VyY2UuZGVmYXVsdHMgPSB7XG5cdCAgICAgICAgJ29uZW5kZWQnOiBUb25lLm5vT3AsXG5cdCAgICAgICAgJ29ubG9hZCc6IFRvbmUubm9PcCxcblx0ICAgICAgICAnbG9vcCc6IGZhbHNlLFxuXHQgICAgICAgICdsb29wU3RhcnQnOiAwLFxuXHQgICAgICAgICdsb29wRW5kJzogMCxcblx0ICAgICAgICAnZmFkZUluJzogMCxcblx0ICAgICAgICAnZmFkZU91dCc6IDAsXG5cdCAgICAgICAgJ3BsYXliYWNrUmF0ZSc6IDFcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgUmV0dXJucyB0aGUgcGxheWJhY2sgc3RhdGUgb2YgdGhlIHNvdXJjZSwgZWl0aGVyIFwic3RhcnRlZFwiIG9yIFwic3RvcHBlZFwiLlxuXHRcdCAqICBAdHlwZSB7VG9uZS5TdGF0ZX1cblx0XHQgKiAgQHJlYWRPbmx5XG5cdFx0ICogIEBtZW1iZXJPZiBUb25lLkJ1ZmZlclNvdXJjZSNcblx0XHQgKiAgQG5hbWUgc3RhdGVcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkJ1ZmZlclNvdXJjZS5wcm90b3R5cGUsICdzdGF0ZScsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIG5vdyA9IHRoaXMubm93KCk7XG5cdCAgICAgICAgICAgIGlmICh0aGlzLl9zdGFydFRpbWUgIT09IC0xICYmIG5vdyA+PSB0aGlzLl9zdGFydFRpbWUgJiYgbm93IDwgdGhpcy5fc3RvcFRpbWUpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBUb25lLlN0YXRlLlN0YXJ0ZWQ7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gVG9uZS5TdGF0ZS5TdG9wcGVkO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgU3RhcnQgdGhlIGJ1ZmZlclxuXHRcdCAqICBAcGFyYW0gIHtUaW1lfSBbc3RhcnRUaW1lPW5vd10gV2hlbiB0aGUgcGxheWVyIHNob3VsZCBzdGFydC5cblx0XHQgKiAgQHBhcmFtICB7VGltZX0gW29mZnNldD0wXSBUaGUgb2Zmc2V0IGZyb20gdGhlIGJlZ2lubmluZyBvZiB0aGUgc2FtcGxlXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0byBzdGFydCBhdC5cblx0XHQgKiAgQHBhcmFtICB7VGltZT19IGR1cmF0aW9uIEhvdyBsb25nIHRoZSBzYW1wbGUgc2hvdWxkIHBsYXkuIElmIG5vIGR1cmF0aW9uXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzIGdpdmVuLCBpdCB3aWxsIGRlZmF1bHQgdG8gdGhlIGZ1bGwgbGVuZ3RoXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mIHRoZSBzYW1wbGUgKG1pbnVzIGFueSBvZmZzZXQpXG5cdFx0ICogIEBwYXJhbSAge0dhaW59ICBbZ2Fpbj0xXSAgVGhlIGdhaW4gdG8gcGxheSB0aGUgYnVmZmVyIGJhY2sgYXQuXG5cdFx0ICogIEBwYXJhbSAge1RpbWU9fSAgZmFkZUluVGltZSAgVGhlIG9wdGlvbmFsIGZhZGVJbiByYW1wIHRpbWUuXG5cdFx0ICogIEByZXR1cm4gIHtUb25lLkJ1ZmZlclNvdXJjZX0gIHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuQnVmZmVyU291cmNlLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uICh0aW1lLCBvZmZzZXQsIGR1cmF0aW9uLCBnYWluLCBmYWRlSW5UaW1lKSB7XG5cdCAgICAgICAgaWYgKHRoaXMuX3N0YXJ0VGltZSAhPT0gLTEpIHtcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUb25lLkJ1ZmZlclNvdXJjZSBjYW4gb25seSBiZSBzdGFydGVkIG9uY2UuJyk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmICh0aGlzLmJ1ZmZlci5sb2FkZWQpIHtcblx0ICAgICAgICAgICAgdGltZSA9IHRoaXMudG9TZWNvbmRzKHRpbWUpO1xuXHQgICAgICAgICAgICAvL2lmIGl0J3MgYSBsb29wIHRoZSBkZWZhdWx0IG9mZnNldCBpcyB0aGUgbG9vcHN0YXJ0IHBvaW50XG5cdCAgICAgICAgICAgIGlmICh0aGlzLmxvb3ApIHtcblx0ICAgICAgICAgICAgICAgIG9mZnNldCA9IFRvbmUuZGVmYXVsdEFyZyhvZmZzZXQsIHRoaXMubG9vcFN0YXJ0KTtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIC8vb3RoZXJ3aXNlIHRoZSBkZWZhdWx0IG9mZnNldCBpcyAwXG5cdCAgICAgICAgICAgICAgICBvZmZzZXQgPSBUb25lLmRlZmF1bHRBcmcob2Zmc2V0LCAwKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBvZmZzZXQgPSB0aGlzLnRvU2Vjb25kcyhvZmZzZXQpO1xuXHQgICAgICAgICAgICAvL3RoZSB2YWx1ZXMgaW4gc2Vjb25kc1xuXHQgICAgICAgICAgICB0aW1lID0gdGhpcy50b1NlY29uZHModGltZSk7XG5cdCAgICAgICAgICAgIGdhaW4gPSBUb25lLmRlZmF1bHRBcmcoZ2FpbiwgMSk7XG5cdCAgICAgICAgICAgIHRoaXMuX2dhaW4gPSBnYWluO1xuXHQgICAgICAgICAgICAvL3RoZSBmYWRlSW4gdGltZVxuXHQgICAgICAgICAgICBpZiAoVG9uZS5pc1VuZGVmKGZhZGVJblRpbWUpKSB7XG5cdCAgICAgICAgICAgICAgICBmYWRlSW5UaW1lID0gdGhpcy50b1NlY29uZHModGhpcy5mYWRlSW4pO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgZmFkZUluVGltZSA9IHRoaXMudG9TZWNvbmRzKGZhZGVJblRpbWUpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGlmIChmYWRlSW5UaW1lID4gMCkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fZ2Fpbk5vZGUuZ2Fpbi5zZXRWYWx1ZUF0VGltZSgwLCB0aW1lKTtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX2dhaW5Ob2RlLmdhaW4ubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUodGhpcy5fZ2FpbiwgdGltZSArIGZhZGVJblRpbWUpO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fZ2Fpbk5vZGUuZ2Fpbi5zZXRWYWx1ZUF0VGltZShnYWluLCB0aW1lKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB0aGlzLl9zdGFydFRpbWUgPSB0aW1lICsgZmFkZUluVGltZTtcblx0ICAgICAgICAgICAgdmFyIGNvbXB1dGVkRHVyID0gVG9uZS5kZWZhdWx0QXJnKGR1cmF0aW9uLCB0aGlzLmJ1ZmZlci5kdXJhdGlvbiAtIG9mZnNldCk7XG5cdCAgICAgICAgICAgIGNvbXB1dGVkRHVyID0gdGhpcy50b1NlY29uZHMoY29tcHV0ZWREdXIpO1xuXHQgICAgICAgICAgICBjb21wdXRlZER1ciA9IE1hdGgubWF4KGNvbXB1dGVkRHVyLCAwKTtcblx0ICAgICAgICAgICAgaWYgKCF0aGlzLmxvb3AgfHwgdGhpcy5sb29wICYmICFUb25lLmlzVW5kZWYoZHVyYXRpb24pKSB7XG5cdCAgICAgICAgICAgICAgICAvL2NsaXAgdGhlIGR1cmF0aW9uIHdoZW4gbm90IGxvb3Bpbmdcblx0ICAgICAgICAgICAgICAgIGlmICghdGhpcy5sb29wKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgY29tcHV0ZWREdXIgPSBNYXRoLm1pbihjb21wdXRlZER1ciwgdGhpcy5idWZmZXIuZHVyYXRpb24gLSBvZmZzZXQpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgdGhpcy5zdG9wKHRpbWUgKyBjb21wdXRlZER1ciArIGZhZGVJblRpbWUsIHRoaXMuZmFkZU91dCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgLy9zdGFydCB0aGUgYnVmZmVyIHNvdXJjZVxuXHQgICAgICAgICAgICBpZiAodGhpcy5sb29wKSB7XG5cdCAgICAgICAgICAgICAgICAvL21vZGlmeSB0aGUgb2Zmc2V0IGlmIGl0J3MgZ3JlYXRlciB0aGFuIHRoZSBsb29wIHRpbWVcblx0ICAgICAgICAgICAgICAgIHZhciBsb29wRW5kID0gdGhpcy5sb29wRW5kIHx8IHRoaXMuYnVmZmVyLmR1cmF0aW9uO1xuXHQgICAgICAgICAgICAgICAgdmFyIGxvb3BTdGFydCA9IHRoaXMubG9vcFN0YXJ0O1xuXHQgICAgICAgICAgICAgICAgdmFyIGxvb3BEdXJhdGlvbiA9IGxvb3BFbmQgLSBsb29wU3RhcnQ7XG5cdCAgICAgICAgICAgICAgICAvL21vdmUgdGhlIG9mZnNldCBiYWNrXG5cdCAgICAgICAgICAgICAgICBpZiAob2Zmc2V0ID4gbG9vcEVuZCkge1xuXHQgICAgICAgICAgICAgICAgICAgIG9mZnNldCA9IChvZmZzZXQgLSBsb29wU3RhcnQpICUgbG9vcER1cmF0aW9uICsgbG9vcFN0YXJ0O1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHRoaXMuX3NvdXJjZS5idWZmZXIgPSB0aGlzLmJ1ZmZlci5nZXQoKTtcblx0ICAgICAgICAgICAgdGhpcy5fc291cmNlLmxvb3BFbmQgPSB0aGlzLmxvb3BFbmQgfHwgdGhpcy5idWZmZXIuZHVyYXRpb247XG5cdCAgICAgICAgICAgIHRoaXMuX3NvdXJjZS5zdGFydCh0aW1lLCBvZmZzZXQpO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVG9uZS5CdWZmZXJTb3VyY2U6IGJ1ZmZlciBpcyBlaXRoZXIgbm90IHNldCBvciBub3QgbG9hZGVkLicpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgU3RvcCB0aGUgYnVmZmVyLiBPcHRpb25hbGx5IGFkZCBhIHJhbXAgdGltZSB0byBmYWRlIHRoZVxuXHRcdCAqICBidWZmZXIgb3V0LlxuXHRcdCAqICBAcGFyYW0gIHtUaW1lPX0gIHRpbWUgICAgICAgICBUaGUgdGltZSB0aGUgYnVmZmVyIHNob3VsZCBzdG9wLlxuXHRcdCAqICBAcGFyYW0gIHtUaW1lPX0gIGZhZGVPdXRUaW1lICBIb3cgbG9uZyB0aGUgZ2FpbiBzaG91bGQgZmFkZSBvdXQgZm9yXG5cdFx0ICogIEByZXR1cm4gIHtUb25lLkJ1ZmZlclNvdXJjZX0gIHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuQnVmZmVyU291cmNlLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKHRpbWUsIGZhZGVPdXRUaW1lKSB7XG5cdCAgICAgICAgaWYgKHRoaXMuYnVmZmVyLmxvYWRlZCkge1xuXHQgICAgICAgICAgICB0aW1lID0gdGhpcy50b1NlY29uZHModGltZSk7XG5cdCAgICAgICAgICAgIC8vdGhlIGZhZGVPdXQgdGltZVxuXHQgICAgICAgICAgICBpZiAoVG9uZS5pc1VuZGVmKGZhZGVPdXRUaW1lKSkge1xuXHQgICAgICAgICAgICAgICAgZmFkZU91dFRpbWUgPSB0aGlzLnRvU2Vjb25kcyh0aGlzLmZhZGVPdXQpO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgZmFkZU91dFRpbWUgPSB0aGlzLnRvU2Vjb25kcyhmYWRlT3V0VGltZSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgLy9vbmx5IHN0b3AgaWYgdGhlIGxhc3Qgc3RvcCB3YXMgc2NoZWR1bGVkIGxhdGVyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLl9zdG9wVGltZSA9PT0gLTEgfHwgdGhpcy5fc3RvcFRpbWUgPiB0aW1lKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9zdG9wVGltZSA9IHRpbWU7XG5cdCAgICAgICAgICAgICAgICAvL2NhbmNlbCB0aGUgZW5kIGN1cnZlXG5cdCAgICAgICAgICAgICAgICB0aGlzLl9nYWluTm9kZS5nYWluLmNhbmNlbFNjaGVkdWxlZFZhbHVlcyh0aGlzLl9zdGFydFRpbWUgKyB0aGlzLnNhbXBsZVRpbWUpO1xuXHQgICAgICAgICAgICAgICAgdGltZSA9IE1hdGgubWF4KHRoaXMuX3N0YXJ0VGltZSwgdGltZSk7XG5cdCAgICAgICAgICAgICAgICAvL3NldCBhIG5ldyBvbmVcblx0ICAgICAgICAgICAgICAgIGlmIChmYWRlT3V0VGltZSA+IDApIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgc3RhcnRGYWRlID0gTWF0aC5tYXgodGhpcy5fc3RhcnRUaW1lLCB0aW1lIC0gZmFkZU91dFRpbWUpO1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuX2dhaW5Ob2RlLmdhaW4uc2V0VmFsdWVBdFRpbWUodGhpcy5fZ2Fpbiwgc3RhcnRGYWRlKTtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLl9nYWluTm9kZS5nYWluLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKDAsIHRpbWUpO1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLl9nYWluTm9kZS5nYWluLnNldFZhbHVlQXRUaW1lKDAsIHRpbWUpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgVG9uZS5jb250ZXh0LmNsZWFyVGltZW91dCh0aGlzLl9vbmVuZGVkVGltZW91dCk7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9vbmVuZGVkVGltZW91dCA9IFRvbmUuY29udGV4dC5zZXRUaW1lb3V0KHRoaXMuX29uZW5kZWQuYmluZCh0aGlzKSwgdGhpcy5fc3RvcFRpbWUgLSB0aGlzLm5vdygpKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVG9uZS5CdWZmZXJTb3VyY2U6IGJ1ZmZlciBpcyBlaXRoZXIgbm90IHNldCBvciBub3QgbG9hZGVkLicpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgSW50ZXJuYWwgY2FsbGJhY2sgd2hlbiB0aGUgYnVmZmVyIGlzIGVuZGVkLlxuXHRcdCAqICBJbnZva2VzIGBvbmVuZGVkYCBhbmQgZGlzcG9zZXMgdGhlIG5vZGUuXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLkJ1ZmZlclNvdXJjZS5wcm90b3R5cGUuX29uZW5kZWQgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdGhpcy5vbmVuZGVkKHRoaXMpO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqIElmIGxvb3AgaXMgdHJ1ZSwgdGhlIGxvb3Agd2lsbCBzdGFydCBhdCB0aGlzIHBvc2l0aW9uLlxuXHRcdCAqIEBtZW1iZXJPZiBUb25lLkJ1ZmZlclNvdXJjZSNcblx0XHQgKiBAdHlwZSB7VGltZX1cblx0XHQgKiBAbmFtZSBsb29wU3RhcnRcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkJ1ZmZlclNvdXJjZS5wcm90b3R5cGUsICdsb29wU3RhcnQnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9zb3VyY2UubG9vcFN0YXJ0O1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAobG9vcFN0YXJ0KSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3NvdXJjZS5sb29wU3RhcnQgPSB0aGlzLnRvU2Vjb25kcyhsb29wU3RhcnQpO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogSWYgbG9vcCBpcyB0cnVlLCB0aGUgbG9vcCB3aWxsIGVuZCBhdCB0aGlzIHBvc2l0aW9uLlxuXHRcdCAqIEBtZW1iZXJPZiBUb25lLkJ1ZmZlclNvdXJjZSNcblx0XHQgKiBAdHlwZSB7VGltZX1cblx0XHQgKiBAbmFtZSBsb29wRW5kXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5CdWZmZXJTb3VyY2UucHJvdG90eXBlLCAnbG9vcEVuZCcsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NvdXJjZS5sb29wRW5kO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAobG9vcEVuZCkge1xuXHQgICAgICAgICAgICB0aGlzLl9zb3VyY2UubG9vcEVuZCA9IHRoaXMudG9TZWNvbmRzKGxvb3BFbmQpO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogVGhlIGF1ZGlvIGJ1ZmZlciBiZWxvbmdpbmcgdG8gdGhlIHBsYXllci5cblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5CdWZmZXJTb3VyY2UjXG5cdFx0ICogQHR5cGUge1RvbmUuQnVmZmVyfVxuXHRcdCAqIEBuYW1lIGJ1ZmZlclxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuQnVmZmVyU291cmNlLnByb3RvdHlwZSwgJ2J1ZmZlcicsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2J1ZmZlcjtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKGJ1ZmZlcikge1xuXHQgICAgICAgICAgICB0aGlzLl9idWZmZXIuc2V0KGJ1ZmZlcik7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiBJZiB0aGUgYnVmZmVyIHNob3VsZCBsb29wIG9uY2UgaXQncyBvdmVyLlxuXHRcdCAqIEBtZW1iZXJPZiBUb25lLkJ1ZmZlclNvdXJjZSNcblx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0XHQgKiBAbmFtZSBsb29wXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5CdWZmZXJTb3VyY2UucHJvdG90eXBlLCAnbG9vcCcsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NvdXJjZS5sb29wO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAobG9vcCkge1xuXHQgICAgICAgICAgICB0aGlzLl9zb3VyY2UubG9vcCA9IGxvb3A7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgQ2xlYW4gdXAuXG5cdFx0ICogIEByZXR1cm4gIHtUb25lLkJ1ZmZlclNvdXJjZX0gIHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuQnVmZmVyU291cmNlLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuQXVkaW9Ob2RlLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgdGhpcy5vbmVuZGVkID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9zb3VyY2UuZGlzY29ubmVjdCgpO1xuXHQgICAgICAgIHRoaXMuX3NvdXJjZSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fZ2Fpbk5vZGUuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX2dhaW5Ob2RlID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9idWZmZXIuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX2J1ZmZlciA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fc3RhcnRUaW1lID0gLTE7XG5cdCAgICAgICAgdGhpcy5wbGF5YmFja1JhdGUgPSBudWxsO1xuXHQgICAgICAgIFRvbmUuY29udGV4dC5jbGVhclRpbWVvdXQodGhpcy5fb25lbmRlZFRpbWVvdXQpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLkJ1ZmZlclNvdXJjZTtcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgXG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzICBUb25lLk5vaXNlIGlzIGEgbm9pc2UgZ2VuZXJhdG9yLiBJdCB1c2VzIGxvb3BlZCBub2lzZSBidWZmZXJzIHRvIHNhdmUgb24gcGVyZm9ybWFuY2UuXG5cdFx0ICogICAgICAgICAgVG9uZS5Ob2lzZSBzdXBwb3J0cyB0aGUgbm9pc2UgdHlwZXM6IFwicGlua1wiLCBcIndoaXRlXCIsIGFuZCBcImJyb3duXCIuIFJlYWQgbW9yZSBhYm91dFxuXHRcdCAqICAgICAgICAgIGNvbG9ycyBvZiBub2lzZSBvbiBbV2lraXBlZGlhXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Db2xvcnNfb2Zfbm9pc2UpLlxuXHRcdCAqXG5cdFx0ICogIEBjb25zdHJ1Y3RvclxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZS5Tb3VyY2V9XG5cdFx0ICogIEBwYXJhbSB7c3RyaW5nfSB0eXBlIHRoZSBub2lzZSB0eXBlICh3aGl0ZXxwaW5rfGJyb3duKVxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIC8vaW5pdGlhbGl6ZSB0aGUgbm9pc2UgYW5kIHN0YXJ0XG5cdFx0ICogdmFyIG5vaXNlID0gbmV3IFRvbmUuTm9pc2UoXCJwaW5rXCIpLnN0YXJ0KCk7XG5cdFx0ICogXG5cdFx0ICogLy9tYWtlIGFuIGF1dG9maWx0ZXIgdG8gc2hhcGUgdGhlIG5vaXNlXG5cdFx0ICogdmFyIGF1dG9GaWx0ZXIgPSBuZXcgVG9uZS5BdXRvRmlsdGVyKHtcblx0XHQgKiBcdFwiZnJlcXVlbmN5XCIgOiBcIjhtXCIsIFxuXHRcdCAqIFx0XCJtaW5cIiA6IDgwMCwgXG5cdFx0ICogXHRcIm1heFwiIDogMTUwMDBcblx0XHQgKiB9KS5jb25uZWN0KFRvbmUuTWFzdGVyKTtcblx0XHQgKiBcblx0XHQgKiAvL2Nvbm5lY3QgdGhlIG5vaXNlXG5cdFx0ICogbm9pc2UuY29ubmVjdChhdXRvRmlsdGVyKTtcblx0XHQgKiAvL3N0YXJ0IHRoZSBhdXRvZmlsdGVyIExGT1xuXHRcdCAqIGF1dG9GaWx0ZXIuc3RhcnQoKVxuXHRcdCAqL1xuXHQgICAgVG9uZS5Ob2lzZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgb3B0aW9ucyA9IFRvbmUuZGVmYXVsdHMoYXJndW1lbnRzLCBbJ3R5cGUnXSwgVG9uZS5Ob2lzZSk7XG5cdCAgICAgICAgVG9uZS5Tb3VyY2UuY2FsbCh0aGlzLCBvcHRpb25zKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICogIEB0eXBlIHtBdWRpb0J1ZmZlclNvdXJjZU5vZGV9XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9zb3VyY2UgPSBudWxsO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHRoZSBidWZmZXJcblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICogIEB0eXBlIHtBdWRpb0J1ZmZlcn1cblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX3R5cGUgPSBvcHRpb25zLnR5cGU7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIHBsYXliYWNrIHJhdGUgb2YgdGhlIG5vaXNlLiBBZmZlY3RzXG5cdFx0XHQgKiAgdGhlIFwiZnJlcXVlbmN5XCIgb2YgdGhlIG5vaXNlLlxuXHRcdFx0ICogIEB0eXBlIHtQb3NpdGl2ZX1cblx0XHRcdCAqICBAc2lnbmFsXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9wbGF5YmFja1JhdGUgPSBvcHRpb25zLnBsYXliYWNrUmF0ZTtcblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLk5vaXNlLCBUb25lLlNvdXJjZSk7XG5cdCAgICAvKipcblx0XHQgKiAgdGhlIGRlZmF1bHQgcGFyYW1ldGVyc1xuXHRcdCAqXG5cdFx0ICogIEBzdGF0aWNcblx0XHQgKiAgQGNvbnN0XG5cdFx0ICogIEB0eXBlIHtPYmplY3R9XG5cdFx0ICovXG5cdCAgICBUb25lLk5vaXNlLmRlZmF1bHRzID0ge1xuXHQgICAgICAgICd0eXBlJzogJ3doaXRlJyxcblx0ICAgICAgICAncGxheWJhY2tSYXRlJzogMVxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqIFRoZSB0eXBlIG9mIHRoZSBub2lzZS4gQ2FuIGJlIFwid2hpdGVcIiwgXCJicm93blwiLCBvciBcInBpbmtcIi4gXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuTm9pc2UjXG5cdFx0ICogQHR5cGUge3N0cmluZ31cblx0XHQgKiBAbmFtZSB0eXBlXG5cdFx0ICogQGV4YW1wbGVcblx0XHQgKiBub2lzZS50eXBlID0gXCJ3aGl0ZVwiO1xuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuTm9pc2UucHJvdG90eXBlLCAndHlwZScsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3R5cGU7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uICh0eXBlKSB7XG5cdCAgICAgICAgICAgIGlmICh0aGlzLl90eXBlICE9PSB0eXBlKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAodHlwZSBpbiBfbm9pc2VCdWZmZXJzKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5fdHlwZSA9IHR5cGU7XG5cdCAgICAgICAgICAgICAgICAgICAgLy9pZiBpdCdzIHBsYXlpbmcsIHN0b3AgYW5kIHJlc3RhcnQgaXRcblx0ICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gVG9uZS5TdGF0ZS5TdGFydGVkKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBub3cgPSB0aGlzLm5vdygpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdG9wKG5vdyk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0KG5vdyk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUb25lLk5vaXNlOiBpbnZhbGlkIHR5cGU6ICcgKyB0eXBlKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIFRoZSBwbGF5YmFjayByYXRlIG9mIHRoZSBub2lzZS4gQWZmZWN0c1xuXHRcdCAqICB0aGUgXCJmcmVxdWVuY3lcIiBvZiB0aGUgbm9pc2UuXG5cdFx0ICogIEB0eXBlIHtQb3NpdGl2ZX1cblx0XHQgKiAgQHNpZ25hbFxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuTm9pc2UucHJvdG90eXBlLCAncGxheWJhY2tSYXRlJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fcGxheWJhY2tSYXRlO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAocmF0ZSkge1xuXHQgICAgICAgICAgICB0aGlzLl9wbGF5YmFja1JhdGUgPSByYXRlO1xuXHQgICAgICAgICAgICBpZiAodGhpcy5fc291cmNlKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9zb3VyY2UucGxheWJhY2tSYXRlLnZhbHVlID0gcmF0ZTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIGludGVybmFsIHN0YXJ0IG1ldGhvZFxuXHRcdCAqXG5cdFx0ICogIEBwYXJhbSB7VGltZX0gdGltZVxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5Ob2lzZS5wcm90b3R5cGUuX3N0YXJ0ID0gZnVuY3Rpb24gKHRpbWUpIHtcblx0ICAgICAgICB2YXIgYnVmZmVyID0gX25vaXNlQnVmZmVyc1t0aGlzLl90eXBlXTtcblx0ICAgICAgICB0aGlzLl9zb3VyY2UgPSBuZXcgVG9uZS5CdWZmZXJTb3VyY2UoYnVmZmVyKS5jb25uZWN0KHRoaXMub3V0cHV0KTtcblx0ICAgICAgICB0aGlzLl9zb3VyY2UubG9vcCA9IHRydWU7XG5cdCAgICAgICAgdGhpcy5fc291cmNlLnBsYXliYWNrUmF0ZS52YWx1ZSA9IHRoaXMuX3BsYXliYWNrUmF0ZTtcblx0ICAgICAgICB0aGlzLl9zb3VyY2Uuc3RhcnQodGhpcy50b1NlY29uZHModGltZSksIE1hdGgucmFuZG9tKCkgKiAoYnVmZmVyLmR1cmF0aW9uIC0gMC4wMDEpKTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgaW50ZXJuYWwgc3RvcCBtZXRob2Rcblx0XHQgKlxuXHRcdCAqICBAcGFyYW0ge1RpbWV9IHRpbWVcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuTm9pc2UucHJvdG90eXBlLl9zdG9wID0gZnVuY3Rpb24gKHRpbWUpIHtcblx0ICAgICAgICBpZiAodGhpcy5fc291cmNlKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3NvdXJjZS5zdG9wKHRoaXMudG9TZWNvbmRzKHRpbWUpKTtcblx0ICAgICAgICAgICAgdGhpcy5fc291cmNlID0gbnVsbDtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIENsZWFuIHVwLlxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5Ob2lzZX0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5Ob2lzZS5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLlNvdXJjZS5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIGlmICh0aGlzLl9zb3VyY2UgIT09IG51bGwpIHtcblx0ICAgICAgICAgICAgdGhpcy5fc291cmNlLmRpc2Nvbm5lY3QoKTtcblx0ICAgICAgICAgICAgdGhpcy5fc291cmNlID0gbnVsbDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdGhpcy5fYnVmZmVyID0gbnVsbDtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblx0ICAgIC8vIFRIRSBCVUZGRVJTXG5cdCAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblx0ICAgIC8vTm9pc2UgYnVmZmVyIHN0YXRzXG5cdCAgICB2YXIgYnVmZmVyTGVuZ3RoID0gNDQxMDAgKiA1O1xuXHQgICAgdmFyIGNoYW5uZWxzID0gMjtcblx0ICAgIC8qKlxuXHRcdCAqXHRUaGUgbm9pc2UgYXJyYXlzLiBHZW5lcmF0ZWQgb24gaW5pdGlhbGl6YXRpb24uXG5cdFx0ICogIGJvcnJvd2VkIGhlYXZpbHkgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vemFjaGFyeWRlbnRvbi9ub2lzZS5qcyBcblx0XHQgKiAgKGMpIDIwMTMgWmFjaCBEZW50b24gKE1JVClcblx0XHQgKiAgQHN0YXRpY1xuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqICBAdHlwZSB7QXJyYXl9XG5cdFx0ICovXG5cdCAgICB2YXIgX25vaXNlQXJyYXlzID0ge1xuXHQgICAgICAgICdwaW5rJzogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgYnVmZmVyID0gW107XG5cdCAgICAgICAgICAgIGZvciAodmFyIGNoYW5uZWxOdW0gPSAwOyBjaGFubmVsTnVtIDwgY2hhbm5lbHM7IGNoYW5uZWxOdW0rKykge1xuXHQgICAgICAgICAgICAgICAgdmFyIGNoYW5uZWwgPSBuZXcgRmxvYXQzMkFycmF5KGJ1ZmZlckxlbmd0aCk7XG5cdCAgICAgICAgICAgICAgICBidWZmZXJbY2hhbm5lbE51bV0gPSBjaGFubmVsO1xuXHQgICAgICAgICAgICAgICAgdmFyIGIwLCBiMSwgYjIsIGIzLCBiNCwgYjUsIGI2O1xuXHQgICAgICAgICAgICAgICAgYjAgPSBiMSA9IGIyID0gYjMgPSBiNCA9IGI1ID0gYjYgPSAwO1xuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBidWZmZXJMZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciB3aGl0ZSA9IE1hdGgucmFuZG9tKCkgKiAyIC0gMTtcblx0ICAgICAgICAgICAgICAgICAgICBiMCA9IDAuOTk4ODYgKiBiMCArIHdoaXRlICogMC4wNTU1MTc5O1xuXHQgICAgICAgICAgICAgICAgICAgIGIxID0gMC45OTMzMiAqIGIxICsgd2hpdGUgKiAwLjA3NTA3NTk7XG5cdCAgICAgICAgICAgICAgICAgICAgYjIgPSAwLjk2OSAqIGIyICsgd2hpdGUgKiAwLjE1Mzg1Mjtcblx0ICAgICAgICAgICAgICAgICAgICBiMyA9IDAuODY2NSAqIGIzICsgd2hpdGUgKiAwLjMxMDQ4NTY7XG5cdCAgICAgICAgICAgICAgICAgICAgYjQgPSAwLjU1ICogYjQgKyB3aGl0ZSAqIDAuNTMyOTUyMjtcblx0ICAgICAgICAgICAgICAgICAgICBiNSA9IC0wLjc2MTYgKiBiNSAtIHdoaXRlICogMC4wMTY4OTg7XG5cdCAgICAgICAgICAgICAgICAgICAgY2hhbm5lbFtpXSA9IGIwICsgYjEgKyBiMiArIGIzICsgYjQgKyBiNSArIGI2ICsgd2hpdGUgKiAwLjUzNjI7XG5cdCAgICAgICAgICAgICAgICAgICAgY2hhbm5lbFtpXSAqPSAwLjExO1xuXHQgICAgICAgICAgICAgICAgICAgIC8vIChyb3VnaGx5KSBjb21wZW5zYXRlIGZvciBnYWluXG5cdCAgICAgICAgICAgICAgICAgICAgYjYgPSB3aGl0ZSAqIDAuMTE1OTI2O1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiBidWZmZXI7XG5cdCAgICAgICAgfSgpLFxuXHQgICAgICAgICdicm93bic6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIGJ1ZmZlciA9IFtdO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBjaGFubmVsTnVtID0gMDsgY2hhbm5lbE51bSA8IGNoYW5uZWxzOyBjaGFubmVsTnVtKyspIHtcblx0ICAgICAgICAgICAgICAgIHZhciBjaGFubmVsID0gbmV3IEZsb2F0MzJBcnJheShidWZmZXJMZW5ndGgpO1xuXHQgICAgICAgICAgICAgICAgYnVmZmVyW2NoYW5uZWxOdW1dID0gY2hhbm5lbDtcblx0ICAgICAgICAgICAgICAgIHZhciBsYXN0T3V0ID0gMDtcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnVmZmVyTGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgd2hpdGUgPSBNYXRoLnJhbmRvbSgpICogMiAtIDE7XG5cdCAgICAgICAgICAgICAgICAgICAgY2hhbm5lbFtpXSA9IChsYXN0T3V0ICsgMC4wMiAqIHdoaXRlKSAvIDEuMDI7XG5cdCAgICAgICAgICAgICAgICAgICAgbGFzdE91dCA9IGNoYW5uZWxbaV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2hhbm5lbFtpXSAqPSAzLjU7ICAgIC8vIChyb3VnaGx5KSBjb21wZW5zYXRlIGZvciBnYWluXG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlcjtcblx0ICAgICAgICB9KCksXG5cdCAgICAgICAgJ3doaXRlJzogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgYnVmZmVyID0gW107XG5cdCAgICAgICAgICAgIGZvciAodmFyIGNoYW5uZWxOdW0gPSAwOyBjaGFubmVsTnVtIDwgY2hhbm5lbHM7IGNoYW5uZWxOdW0rKykge1xuXHQgICAgICAgICAgICAgICAgdmFyIGNoYW5uZWwgPSBuZXcgRmxvYXQzMkFycmF5KGJ1ZmZlckxlbmd0aCk7XG5cdCAgICAgICAgICAgICAgICBidWZmZXJbY2hhbm5lbE51bV0gPSBjaGFubmVsO1xuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBidWZmZXJMZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgICAgIGNoYW5uZWxbaV0gPSBNYXRoLnJhbmRvbSgpICogMiAtIDE7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlcjtcblx0ICAgICAgICB9KClcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKlx0c3RhdGljIG5vaXNlIGJ1ZmZlcnNcblx0XHQgKiAgQHN0YXRpY1xuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqICBAdHlwZSB7VG9uZS5CdWZmZXJ9XG5cdFx0ICovXG5cdCAgICB2YXIgX25vaXNlQnVmZmVycyA9IHt9O1xuXHQgICAgLy9jcmVhdGUgdGhlIFRvbmUuQnVmZmVyc1xuXHQgICAgZnVuY3Rpb24gY3JlYXRlQnVmZmVycygpIHtcblx0ICAgICAgICBmb3IgKHZhciB0eXBlIGluIF9ub2lzZUFycmF5cykge1xuXHQgICAgICAgICAgICBfbm9pc2VCdWZmZXJzW3R5cGVdID0gbmV3IFRvbmUuQnVmZmVyKCkuZnJvbUFycmF5KF9ub2lzZUFycmF5c1t0eXBlXSk7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHQgICAgLy9jcmVhdGUgdGhlIG5vaXNlIGJ1ZmZlcnNcblx0ICAgIFRvbmUuZ2V0Q29udGV4dChjcmVhdGVCdWZmZXJzKTtcblx0ICAgIFRvbmUuQ29udGV4dC5vbignaW5pdCcsIGNyZWF0ZUJ1ZmZlcnMpO1xuXHQgICAgcmV0dXJuIFRvbmUuTm9pc2U7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyAgVG9uZS5Ob2lzZVN5bnRoIGlzIGNvbXBvc2VkIG9mIGEgbm9pc2UgZ2VuZXJhdG9yIChUb25lLk5vaXNlKSwgb25lIGZpbHRlciAoVG9uZS5GaWx0ZXIpLCBcblx0XHQgKiAgICAgICAgICBhbmQgdHdvIGVudmVsb3BlcyAoVG9uZS5FbnZlbG9wKS4gT25lIGVudmVsb3BlIGNvbnRyb2xzIHRoZSBhbXBsaXR1ZGVcblx0XHQgKiAgICAgICAgICBvZiB0aGUgbm9pc2UgYW5kIHRoZSBvdGhlciBpcyBjb250cm9scyB0aGUgY3V0b2ZmIGZyZXF1ZW5jeSBvZiB0aGUgZmlsdGVyLiBcblx0XHQgKiAgICAgICAgICA8aW1nIHNyYz1cImh0dHBzOi8vZG9jcy5nb29nbGUuY29tL2RyYXdpbmdzL2QvMXJxenVYOXJCbGhUNTBNUnZEMlRLbWw5Ym5aaGNabXpYRjFyZl9vN3ZkbkUvcHViP3c9OTE4Jmg9MjQyXCI+XG5cdFx0ICpcblx0XHQgKiAgQGNvbnN0cnVjdG9yXG5cdFx0ICogIEBleHRlbmRzIHtUb25lLkluc3RydW1lbnR9XG5cdFx0ICogIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gdGhlIG9wdGlvbnMgYXZhaWxhYmxlIGZvciB0aGUgc3ludGggXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgIHNlZSBkZWZhdWx0cyBiZWxvd1xuXHRcdCAqIEBleGFtcGxlXG5cdFx0ICogdmFyIG5vaXNlU3ludGggPSBuZXcgVG9uZS5Ob2lzZVN5bnRoKCkudG9NYXN0ZXIoKTtcblx0XHQgKiBub2lzZVN5bnRoLnRyaWdnZXJBdHRhY2tSZWxlYXNlKFwiOG5cIik7XG5cdFx0ICovXG5cdCAgICBUb25lLk5vaXNlU3ludGggPSBmdW5jdGlvbiAob3B0aW9ucykge1xuXHQgICAgICAgIC8vZ2V0IHRoZSBkZWZhdWx0c1xuXHQgICAgICAgIG9wdGlvbnMgPSBUb25lLmRlZmF1bHRBcmcob3B0aW9ucywgVG9uZS5Ob2lzZVN5bnRoLmRlZmF1bHRzKTtcblx0ICAgICAgICBUb25lLkluc3RydW1lbnQuY2FsbCh0aGlzLCBvcHRpb25zKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgbm9pc2Ugc291cmNlLlxuXHRcdFx0ICogIEB0eXBlIHtUb25lLk5vaXNlfVxuXHRcdFx0ICogIEBleGFtcGxlXG5cdFx0XHQgKiBub2lzZVN5bnRoLnNldChcIm5vaXNlLnR5cGVcIiwgXCJicm93blwiKTtcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMubm9pc2UgPSBuZXcgVG9uZS5Ob2lzZSgpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBhbXBsaXR1ZGUgZW52ZWxvcGUuIFxuXHRcdFx0ICogIEB0eXBlIHtUb25lLkFtcGxpdHVkZUVudmVsb3BlfVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5lbnZlbG9wZSA9IG5ldyBUb25lLkFtcGxpdHVkZUVudmVsb3BlKG9wdGlvbnMuZW52ZWxvcGUpO1xuXHQgICAgICAgIC8vY29ubmVjdCB0aGUgbm9pc2UgdG8gdGhlIG91dHB1dFxuXHQgICAgICAgIHRoaXMubm9pc2UuY2hhaW4odGhpcy5lbnZlbG9wZSwgdGhpcy5vdXRwdXQpO1xuXHQgICAgICAgIC8vc3RhcnQgdGhlIG5vaXNlXG5cdCAgICAgICAgdGhpcy5ub2lzZS5zdGFydCgpO1xuXHQgICAgICAgIHRoaXMuX3JlYWRPbmx5KFtcblx0ICAgICAgICAgICAgJ25vaXNlJyxcblx0ICAgICAgICAgICAgJ2VudmVsb3BlJ1xuXHQgICAgICAgIF0pO1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuTm9pc2VTeW50aCwgVG9uZS5JbnN0cnVtZW50KTtcblx0ICAgIC8qKlxuXHRcdCAqICBAY29uc3Rcblx0XHQgKiAgQHN0YXRpY1xuXHRcdCAqICBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqL1xuXHQgICAgVG9uZS5Ob2lzZVN5bnRoLmRlZmF1bHRzID0ge1xuXHQgICAgICAgICdub2lzZSc6IHsgJ3R5cGUnOiAnd2hpdGUnIH0sXG5cdCAgICAgICAgJ2VudmVsb3BlJzoge1xuXHQgICAgICAgICAgICAnYXR0YWNrJzogMC4wMDUsXG5cdCAgICAgICAgICAgICdkZWNheSc6IDAuMSxcblx0ICAgICAgICAgICAgJ3N1c3RhaW4nOiAwXG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBTdGFydCB0aGUgYXR0YWNrIHBvcnRpb24gb2YgdGhlIGVudmVsb3Blcy4gVW5saWtlIG90aGVyIFxuXHRcdCAqICBpbnN0cnVtZW50cywgVG9uZS5Ob2lzZVN5bnRoIGRvZXNuJ3QgaGF2ZSBhIG5vdGUuIFxuXHRcdCAqICBAcGFyYW0ge1RpbWV9IFt0aW1lPW5vd10gdGhlIHRpbWUgdGhlIGF0dGFjayBzaG91bGQgc3RhcnRcblx0XHQgKiAgQHBhcmFtIHtudW1iZXJ9IFt2ZWxvY2l0eT0xXSB0aGUgdmVsb2NpdHkgb2YgdGhlIG5vdGUgKDAtMSlcblx0XHQgKiAgQHJldHVybnMge1RvbmUuTm9pc2VTeW50aH0gdGhpc1xuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIG5vaXNlU3ludGgudHJpZ2dlckF0dGFjaygpO1xuXHRcdCAqL1xuXHQgICAgVG9uZS5Ob2lzZVN5bnRoLnByb3RvdHlwZS50cmlnZ2VyQXR0YWNrID0gZnVuY3Rpb24gKHRpbWUsIHZlbG9jaXR5KSB7XG5cdCAgICAgICAgLy90aGUgZW52ZWxvcGVzXG5cdCAgICAgICAgdGhpcy5lbnZlbG9wZS50cmlnZ2VyQXR0YWNrKHRpbWUsIHZlbG9jaXR5KTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgU3RhcnQgdGhlIHJlbGVhc2UgcG9ydGlvbiBvZiB0aGUgZW52ZWxvcGVzLlxuXHRcdCAqICBAcGFyYW0ge1RpbWV9IFt0aW1lPW5vd10gdGhlIHRpbWUgdGhlIHJlbGVhc2Ugc2hvdWxkIHN0YXJ0XG5cdFx0ICogIEByZXR1cm5zIHtUb25lLk5vaXNlU3ludGh9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuTm9pc2VTeW50aC5wcm90b3R5cGUudHJpZ2dlclJlbGVhc2UgPSBmdW5jdGlvbiAodGltZSkge1xuXHQgICAgICAgIHRoaXMuZW52ZWxvcGUudHJpZ2dlclJlbGVhc2UodGltZSk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFRyaWdnZXIgdGhlIGF0dGFjayBhbmQgdGhlbiB0aGUgcmVsZWFzZS4gXG5cdFx0ICogIEBwYXJhbSAge1RpbWV9IGR1cmF0aW9uIHRoZSBkdXJhdGlvbiBvZiB0aGUgbm90ZVxuXHRcdCAqICBAcGFyYW0gIHtUaW1lfSBbdGltZT1ub3ddICAgICB0aGUgdGltZSBvZiB0aGUgYXR0YWNrXG5cdFx0ICogIEBwYXJhbSAge251bWJlcn0gW3ZlbG9jaXR5PTFdIHRoZSB2ZWxvY2l0eVxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5Ob2lzZVN5bnRofSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLk5vaXNlU3ludGgucHJvdG90eXBlLnRyaWdnZXJBdHRhY2tSZWxlYXNlID0gZnVuY3Rpb24gKGR1cmF0aW9uLCB0aW1lLCB2ZWxvY2l0eSkge1xuXHQgICAgICAgIHRpbWUgPSB0aGlzLnRvU2Vjb25kcyh0aW1lKTtcblx0ICAgICAgICBkdXJhdGlvbiA9IHRoaXMudG9TZWNvbmRzKGR1cmF0aW9uKTtcblx0ICAgICAgICB0aGlzLnRyaWdnZXJBdHRhY2sodGltZSwgdmVsb2NpdHkpO1xuXHQgICAgICAgIHRoaXMudHJpZ2dlclJlbGVhc2UodGltZSArIGR1cmF0aW9uKTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgQ2xlYW4gdXAuIFxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5Ob2lzZVN5bnRofSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLk5vaXNlU3ludGgucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5JbnN0cnVtZW50LnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgdGhpcy5fd3JpdGFibGUoW1xuXHQgICAgICAgICAgICAnbm9pc2UnLFxuXHQgICAgICAgICAgICAnZW52ZWxvcGUnXG5cdCAgICAgICAgXSk7XG5cdCAgICAgICAgdGhpcy5ub2lzZS5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5ub2lzZSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5lbnZlbG9wZS5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5lbnZlbG9wZSA9IG51bGw7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuTm9pc2VTeW50aDtcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgXG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzIEthcnBsdXMtU3RyaW5nIHN0cmluZyBzeW50aGVzaXMuIE9mdGVuIG91dCBvZiB0dW5lLiBcblx0XHQgKiAgICAgICAgIFdpbGwgY2hhbmdlIHdoZW4gdGhlIEF1ZGlvV29ya2VyTm9kZSBpcyBhdmFpbGFibGUgYWNyb3NzXG5cdFx0ICogICAgICAgICBicm93c2Vycy4gXG5cdFx0ICogIFxuXHRcdCAqICBAY29uc3RydWN0b3Jcblx0XHQgKiAgQGV4dGVuZHMge1RvbmUuSW5zdHJ1bWVudH1cblx0XHQgKiAgQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBzZWUgdGhlIGRlZmF1bHRzXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogdmFyIHBsdWNreSA9IG5ldyBUb25lLlBsdWNrU3ludGgoKS50b01hc3RlcigpO1xuXHRcdCAqIHBsdWNreS50cmlnZ2VyQXR0YWNrKFwiQzRcIik7XG5cdFx0ICovXG5cdCAgICBUb25lLlBsdWNrU3ludGggPSBmdW5jdGlvbiAob3B0aW9ucykge1xuXHQgICAgICAgIG9wdGlvbnMgPSBUb25lLmRlZmF1bHRBcmcob3B0aW9ucywgVG9uZS5QbHVja1N5bnRoLmRlZmF1bHRzKTtcblx0ICAgICAgICBUb25lLkluc3RydW1lbnQuY2FsbCh0aGlzLCBvcHRpb25zKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5Ob2lzZX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fbm9pc2UgPSBuZXcgVG9uZS5Ob2lzZSgncGluaycpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBhbW91bnQgb2Ygbm9pc2UgYXQgdGhlIGF0dGFjay4gXG5cdFx0XHQgKiAgTm9taW5hbCByYW5nZSBvZiBbMC4xLCAyMF1cblx0XHRcdCAqICBAdHlwZSB7bnVtYmVyfVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5hdHRhY2tOb2lzZSA9IG9wdGlvbnMuYXR0YWNrTm9pc2U7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgdGhlIExGQ0Zcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5Mb3dwYXNzQ29tYkZpbHRlcn1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fbGZjZiA9IG5ldyBUb25lLkxvd3Bhc3NDb21iRmlsdGVyKHtcblx0ICAgICAgICAgICAgJ3Jlc29uYW5jZSc6IG9wdGlvbnMucmVzb25hbmNlLFxuXHQgICAgICAgICAgICAnZGFtcGVuaW5nJzogb3B0aW9ucy5kYW1wZW5pbmdcblx0ICAgICAgICB9KTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgcmVzb25hbmNlIGNvbnRyb2wuIFxuXHRcdFx0ICogIEB0eXBlIHtOb3JtYWxSYW5nZX1cblx0XHRcdCAqICBAc2lnbmFsXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLnJlc29uYW5jZSA9IHRoaXMuX2xmY2YucmVzb25hbmNlO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBkYW1wZW5pbmcgY29udHJvbC4gaS5lLiB0aGUgbG93cGFzcyBmaWx0ZXIgZnJlcXVlbmN5IG9mIHRoZSBjb21iIGZpbHRlclxuXHRcdFx0ICogIEB0eXBlIHtGcmVxdWVuY3l9XG5cdFx0XHQgKiAgQHNpZ25hbFxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5kYW1wZW5pbmcgPSB0aGlzLl9sZmNmLmRhbXBlbmluZztcblx0ICAgICAgICAvL2Nvbm5lY3Rpb25zXG5cdCAgICAgICAgdGhpcy5fbm9pc2UuY29ubmVjdCh0aGlzLl9sZmNmKTtcblx0ICAgICAgICB0aGlzLl9sZmNmLmNvbm5lY3QodGhpcy5vdXRwdXQpO1xuXHQgICAgICAgIHRoaXMuX3JlYWRPbmx5KFtcblx0ICAgICAgICAgICAgJ3Jlc29uYW5jZScsXG5cdCAgICAgICAgICAgICdkYW1wZW5pbmcnXG5cdCAgICAgICAgXSk7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5QbHVja1N5bnRoLCBUb25lLkluc3RydW1lbnQpO1xuXHQgICAgLyoqXG5cdFx0ICogIEBzdGF0aWNcblx0XHQgKiAgQGNvbnN0XG5cdFx0ICogIEB0eXBlIHtPYmplY3R9XG5cdFx0ICovXG5cdCAgICBUb25lLlBsdWNrU3ludGguZGVmYXVsdHMgPSB7XG5cdCAgICAgICAgJ2F0dGFja05vaXNlJzogMSxcblx0ICAgICAgICAnZGFtcGVuaW5nJzogNDAwMCxcblx0ICAgICAgICAncmVzb25hbmNlJzogMC45XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFRyaWdnZXIgdGhlIG5vdGUuIFxuXHRcdCAqICBAcGFyYW0ge0ZyZXF1ZW5jeX0gbm90ZSBUaGUgbm90ZSB0byB0cmlnZ2VyLlxuXHRcdCAqICBAcGFyYW0ge1RpbWV9IFt0aW1lPW5vd10gV2hlbiB0aGUgbm90ZSBzaG91bGQgYmUgdHJpZ2dlcmVkLlxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5QbHVja1N5bnRofSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLlBsdWNrU3ludGgucHJvdG90eXBlLnRyaWdnZXJBdHRhY2sgPSBmdW5jdGlvbiAobm90ZSwgdGltZSkge1xuXHQgICAgICAgIG5vdGUgPSB0aGlzLnRvRnJlcXVlbmN5KG5vdGUpO1xuXHQgICAgICAgIHRpbWUgPSB0aGlzLnRvU2Vjb25kcyh0aW1lKTtcblx0ICAgICAgICB2YXIgZGVsYXlBbW91bnQgPSAxIC8gbm90ZTtcblx0ICAgICAgICB0aGlzLl9sZmNmLmRlbGF5VGltZS5zZXRWYWx1ZUF0VGltZShkZWxheUFtb3VudCwgdGltZSk7XG5cdCAgICAgICAgdGhpcy5fbm9pc2Uuc3RhcnQodGltZSk7XG5cdCAgICAgICAgdGhpcy5fbm9pc2Uuc3RvcCh0aW1lICsgZGVsYXlBbW91bnQgKiB0aGlzLmF0dGFja05vaXNlKTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgQ2xlYW4gdXAuIFxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5QbHVja1N5bnRofSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLlBsdWNrU3ludGgucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5JbnN0cnVtZW50LnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgdGhpcy5fbm9pc2UuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX2xmY2YuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX25vaXNlID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9sZmNmID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl93cml0YWJsZShbXG5cdCAgICAgICAgICAgICdyZXNvbmFuY2UnLFxuXHQgICAgICAgICAgICAnZGFtcGVuaW5nJ1xuXHQgICAgICAgIF0pO1xuXHQgICAgICAgIHRoaXMuZGFtcGVuaW5nID0gbnVsbDtcblx0ICAgICAgICB0aGlzLnJlc29uYW5jZSA9IG51bGw7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuUGx1Y2tTeW50aDtcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgXG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzICBUb25lLlBvbHlTeW50aCBoYW5kbGVzIHZvaWNlIGNyZWF0aW9uIGFuZCBhbGxvY2F0aW9uIGZvciBhbnlcblx0XHQgKiAgICAgICAgICBpbnN0cnVtZW50cyBwYXNzZWQgaW4gYXMgdGhlIHNlY29uZCBwYXJhbXRlci4gUG9seVN5bnRoIGlzIFxuXHRcdCAqICAgICAgICAgIG5vdCBhIHN5bnRoZXNpemVyIGJ5IGl0c2VsZiwgaXQgbWVyZWx5IG1hbmFnZXMgdm9pY2VzIG9mIFxuXHRcdCAqICAgICAgICAgIG9uZSBvZiB0aGUgb3RoZXIgdHlwZXMgb2Ygc3ludGhzLCBhbGxvd2luZyBhbnkgb2YgdGhlIFxuXHRcdCAqICAgICAgICAgIG1vbm9waG9uaWMgc3ludGhlc2l6ZXJzIHRvIGJlIHBvbHlwaG9uaWMuIFxuXHRcdCAqXG5cdFx0ICogIEBjb25zdHJ1Y3RvclxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZS5JbnN0cnVtZW50fVxuXHRcdCAqICBAcGFyYW0ge251bWJlcnxPYmplY3R9IFtwb2x5cGhvbnk9NF0gVGhlIG51bWJlciBvZiB2b2ljZXMgdG8gY3JlYXRlXG5cdFx0ICogIEBwYXJhbSB7ZnVuY3Rpb259IFt2b2ljZT1Ub25lLlN5bnRoXSBUaGUgY29uc3RydWN0b3Igb2YgdGhlIHZvaWNlc1xuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1c2VzIFRvbmUuU3ludGggYnkgZGVmYXVsdC4gXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogLy9hIHBvbHlzeW50aCBjb21wb3NlZCBvZiA2IFZvaWNlcyBvZiBTeW50aFxuXHRcdCAqIHZhciBzeW50aCA9IG5ldyBUb25lLlBvbHlTeW50aCg2LCBUb25lLlN5bnRoKS50b01hc3RlcigpO1xuXHRcdCAqIC8vc2V0IHRoZSBhdHRyaWJ1dGVzIHVzaW5nIHRoZSBzZXQgaW50ZXJmYWNlXG5cdFx0ICogc3ludGguc2V0KFwiZGV0dW5lXCIsIC0xMjAwKTtcblx0XHQgKiAvL3BsYXkgYSBjaG9yZFxuXHRcdCAqIHN5bnRoLnRyaWdnZXJBdHRhY2tSZWxlYXNlKFtcIkM0XCIsIFwiRTRcIiwgXCJBNFwiXSwgXCI0blwiKTtcblx0XHQgKi9cblx0ICAgIFRvbmUuUG9seVN5bnRoID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBvcHRpb25zID0gVG9uZS5kZWZhdWx0cyhhcmd1bWVudHMsIFtcblx0ICAgICAgICAgICAgJ3BvbHlwaG9ueScsXG5cdCAgICAgICAgICAgICd2b2ljZSdcblx0ICAgICAgICBdLCBUb25lLlBvbHlTeW50aCk7XG5cdCAgICAgICAgVG9uZS5JbnN0cnVtZW50LmNhbGwodGhpcywgb3B0aW9ucyk7XG5cdCAgICAgICAgb3B0aW9ucyA9IFRvbmUuZGVmYXVsdEFyZyhvcHRpb25zLCBUb25lLkluc3RydW1lbnQuZGVmYXVsdHMpO1xuXHQgICAgICAgIC8vbWF4IHBvbHlwaG9ueVxuXHQgICAgICAgIG9wdGlvbnMucG9seXBob255ID0gTWF0aC5taW4oVG9uZS5Qb2x5U3ludGguTUFYX1BPTFlQSE9OWSwgb3B0aW9ucy5wb2x5cGhvbnkpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHRoZSBhcnJheSBvZiB2b2ljZXNcblx0XHRcdCAqICBAdHlwZSB7QXJyYXl9XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLnZvaWNlcyA9IG5ldyBBcnJheShvcHRpb25zLnBvbHlwaG9ueSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIHF1ZXVlIG9mIHZvaWNlcyB3aXRoIGRhdGEgYWJvdXQgbGFzdCB0cmlnZ2VyXG5cdFx0XHQgKiAgYW5kIHRoZSB0cmlnZ2VyZWQgbm90ZVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKiAgQHR5cGUge0FycmF5fVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fdHJpZ2dlcnMgPSBuZXcgQXJyYXkob3B0aW9ucy5wb2x5cGhvbnkpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBkZXR1bmUgaW4gY2VudHNcblx0XHRcdCAqICBAdHlwZSB7Q2VudHN9XG5cdFx0XHQgKiAgQHNpZ25hbFxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5kZXR1bmUgPSBuZXcgVG9uZS5TaWduYWwob3B0aW9ucy5kZXR1bmUsIFRvbmUuVHlwZS5DZW50cyk7XG5cdCAgICAgICAgdGhpcy5fcmVhZE9ubHkoJ2RldHVuZScpO1xuXHQgICAgICAgIC8vY3JlYXRlIHRoZSB2b2ljZXNcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9wdGlvbnMucG9seXBob255OyBpKyspIHtcblx0ICAgICAgICAgICAgdmFyIHYgPSBuZXcgb3B0aW9ucy52b2ljZShhcmd1bWVudHNbMl0sIGFyZ3VtZW50c1szXSk7XG5cdCAgICAgICAgICAgIHRoaXMudm9pY2VzW2ldID0gdjtcblx0ICAgICAgICAgICAgdi5jb25uZWN0KHRoaXMub3V0cHV0KTtcblx0ICAgICAgICAgICAgaWYgKHYuaGFzT3duUHJvcGVydHkoJ2RldHVuZScpKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLmRldHVuZS5jb25uZWN0KHYuZGV0dW5lKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB0aGlzLl90cmlnZ2Vyc1tpXSA9IHtcblx0ICAgICAgICAgICAgICAgIHJlbGVhc2U6IC0xLFxuXHQgICAgICAgICAgICAgICAgbm90ZTogbnVsbCxcblx0ICAgICAgICAgICAgICAgIHZvaWNlOiB2XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuUG9seVN5bnRoLCBUb25lLkluc3RydW1lbnQpO1xuXHQgICAgLyoqXG5cdFx0ICogIHRoZSBkZWZhdWx0c1xuXHRcdCAqICBAY29uc3Rcblx0XHQgKiAgQHN0YXRpY1xuXHRcdCAqICBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqL1xuXHQgICAgVG9uZS5Qb2x5U3ludGguZGVmYXVsdHMgPSB7XG5cdCAgICAgICAgJ3BvbHlwaG9ueSc6IDQsXG5cdCAgICAgICAgJ3ZvbHVtZSc6IDAsXG5cdCAgICAgICAgJ2RldHVuZSc6IDAsXG5cdCAgICAgICAgJ3ZvaWNlJzogVG9uZS5TeW50aFxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBUcmlnZ2VyIHRoZSBhdHRhY2sgcG9ydGlvbiBvZiB0aGUgbm90ZVxuXHRcdCAqICBAcGFyYW0gIHtGcmVxdWVuY3l8QXJyYXl9IG5vdGVzIFRoZSBub3RlcyB0byBwbGF5LiBBY2NlcHRzIGEgc2luZ2xlXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRnJlcXVlbmN5IG9yIGFuIGFycmF5IG9mIGZyZXF1ZW5jaWVzLlxuXHRcdCAqICBAcGFyYW0gIHtUaW1lfSBbdGltZT1ub3ddICBUaGUgc3RhcnQgdGltZSBvZiB0aGUgbm90ZS5cblx0XHQgKiAgQHBhcmFtIHtudW1iZXJ9IFt2ZWxvY2l0eT0xXSBUaGUgdmVsb2NpdHkgb2YgdGhlIG5vdGUuXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLlBvbHlTeW50aH0gdGhpc1xuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIC8vdHJpZ2dlciBhIGNob3JkIGltbWVkaWF0ZWx5IHdpdGggYSB2ZWxvY2l0eSBvZiAwLjJcblx0XHQgKiBwb2x5LnRyaWdnZXJBdHRhY2soW1wiQWIzXCIsIFwiQzRcIiwgXCJGNVwiXSwgdW5kZWZpbmVkLCAwLjIpO1xuXHRcdCAqL1xuXHQgICAgVG9uZS5Qb2x5U3ludGgucHJvdG90eXBlLnRyaWdnZXJBdHRhY2sgPSBmdW5jdGlvbiAobm90ZXMsIHRpbWUsIHZlbG9jaXR5KSB7XG5cdCAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG5vdGVzKSkge1xuXHQgICAgICAgICAgICBub3RlcyA9IFtub3Rlc107XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHRpbWUgPSB0aGlzLnRvU2Vjb25kcyh0aW1lKTtcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vdGVzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgIHZhciB2YWwgPSBub3Rlc1tpXTtcblx0ICAgICAgICAgICAgLy90cmlnZ2VyIHRoZSBvbGRlc3Qgdm9pY2Vcblx0ICAgICAgICAgICAgdmFyIG9sZGVzdCA9IHRoaXMuX3RyaWdnZXJzWzBdO1xuXHQgICAgICAgICAgICB2YXIgb2xkZXN0SW5kZXggPSAwO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBqID0gMTsgaiA8IHRoaXMuX3RyaWdnZXJzLmxlbmd0aDsgaisrKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5fdHJpZ2dlcnNbal0ucmVsZWFzZSA8IG9sZGVzdC5yZWxlYXNlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgb2xkZXN0ID0gdGhpcy5fdHJpZ2dlcnNbal07XG5cdCAgICAgICAgICAgICAgICAgICAgb2xkZXN0SW5kZXggPSBqO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIG9sZGVzdC5yZWxlYXNlID0gSW5maW5pdHk7XG5cdCAgICAgICAgICAgIG9sZGVzdC5ub3RlID0gSlNPTi5zdHJpbmdpZnkodmFsKTtcblx0ICAgICAgICAgICAgb2xkZXN0LnZvaWNlLnRyaWdnZXJBdHRhY2sodmFsLCB0aW1lLCB2ZWxvY2l0eSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBUcmlnZ2VyIHRoZSBhdHRhY2sgYW5kIHJlbGVhc2UgYWZ0ZXIgdGhlIHNwZWNpZmllZCBkdXJhdGlvblxuXHRcdCAqICBcblx0XHQgKiAgQHBhcmFtICB7RnJlcXVlbmN5fEFycmF5fSBub3RlcyBUaGUgbm90ZXMgdG8gcGxheS4gQWNjZXB0cyBhIHNpbmdsZVxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEZyZXF1ZW5jeSBvciBhbiBhcnJheSBvZiBmcmVxdWVuY2llcy5cblx0XHQgKiAgQHBhcmFtICB7VGltZX0gZHVyYXRpb24gdGhlIGR1cmF0aW9uIG9mIHRoZSBub3RlXG5cdFx0ICogIEBwYXJhbSAge1RpbWV9IFt0aW1lPW5vd10gICAgIGlmIG5vIHRpbWUgaXMgZ2l2ZW4sIGRlZmF1bHRzIHRvIG5vd1xuXHRcdCAqICBAcGFyYW0gIHtudW1iZXJ9IFt2ZWxvY2l0eT0xXSB0aGUgdmVsb2NpdHkgb2YgdGhlIGF0dGFjayAoMC0xKVxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5Qb2x5U3ludGh9IHRoaXNcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAvL3RyaWdnZXIgYSBjaG9yZCBmb3IgYSBkdXJhdGlvbiBvZiBhIGhhbGYgbm90ZSBcblx0XHQgKiBwb2x5LnRyaWdnZXJBdHRhY2tSZWxlYXNlKFtcIkViM1wiLCBcIkc0XCIsIFwiQzVcIl0sIFwiMm5cIik7XG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogLy9jYW4gcGFzcyBpbiBhbiBhcnJheSBvZiBkdXJhdGlvbnMgYXMgd2VsbFxuXHRcdCAqIHBvbHkudHJpZ2dlckF0dGFja1JlbGVhc2UoW1wiRWIzXCIsIFwiRzRcIiwgXCJDNVwiXSwgW1wiMm5cIiwgXCI0blwiLCBcIjRuXCJdKTtcblx0XHQgKi9cblx0ICAgIFRvbmUuUG9seVN5bnRoLnByb3RvdHlwZS50cmlnZ2VyQXR0YWNrUmVsZWFzZSA9IGZ1bmN0aW9uIChub3RlcywgZHVyYXRpb24sIHRpbWUsIHZlbG9jaXR5KSB7XG5cdCAgICAgICAgdGltZSA9IHRoaXMudG9TZWNvbmRzKHRpbWUpO1xuXHQgICAgICAgIHRoaXMudHJpZ2dlckF0dGFjayhub3RlcywgdGltZSwgdmVsb2NpdHkpO1xuXHQgICAgICAgIGlmIChUb25lLmlzQXJyYXkoZHVyYXRpb24pICYmIFRvbmUuaXNBcnJheShub3RlcykpIHtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub3Rlcy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgdmFyIGQgPSBkdXJhdGlvbltNYXRoLm1pbihpLCBkdXJhdGlvbi5sZW5ndGggLSAxKV07XG5cdCAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXJSZWxlYXNlKG5vdGVzW2ldLCB0aW1lICsgdGhpcy50b1NlY29uZHMoZCkpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgdGhpcy50cmlnZ2VyUmVsZWFzZShub3RlcywgdGltZSArIHRoaXMudG9TZWNvbmRzKGR1cmF0aW9uKSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBUcmlnZ2VyIHRoZSByZWxlYXNlIG9mIHRoZSBub3RlLiBVbmxpa2UgbW9ub3Bob25pYyBpbnN0cnVtZW50cywgXG5cdFx0ICogIGEgbm90ZSAob3IgYXJyYXkgb2Ygbm90ZXMpIG5lZWRzIHRvIGJlIHBhc3NlZCBpbiBhcyB0aGUgZmlyc3QgYXJndW1lbnQuXG5cdFx0ICogIEBwYXJhbSAge0ZyZXF1ZW5jeXxBcnJheX0gbm90ZXMgVGhlIG5vdGVzIHRvIHBsYXkuIEFjY2VwdHMgYSBzaW5nbGVcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBGcmVxdWVuY3kgb3IgYW4gYXJyYXkgb2YgZnJlcXVlbmNpZXMuXG5cdFx0ICogIEBwYXJhbSAge1RpbWV9IFt0aW1lPW5vd10gIFdoZW4gdGhlIHJlbGVhc2Ugd2lsbCBiZSB0cmlnZ2VyZWQuIFxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5Qb2x5U3ludGh9IHRoaXNcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiBwb2x5LnRyaWdnZXJSZWxlYXNlKFtcIkFiM1wiLCBcIkM0XCIsIFwiRjVcIl0sIFwiKzJuXCIpO1xuXHRcdCAqL1xuXHQgICAgVG9uZS5Qb2x5U3ludGgucHJvdG90eXBlLnRyaWdnZXJSZWxlYXNlID0gZnVuY3Rpb24gKG5vdGVzLCB0aW1lKSB7XG5cdCAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG5vdGVzKSkge1xuXHQgICAgICAgICAgICBub3RlcyA9IFtub3Rlc107XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHRpbWUgPSB0aGlzLnRvU2Vjb25kcyh0aW1lKTtcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vdGVzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgIC8vZ2V0IHRoZSB2b2ljZVxuXHQgICAgICAgICAgICB2YXIgc3RyaW5naWZpZWQgPSBKU09OLnN0cmluZ2lmeShub3Rlc1tpXSk7XG5cdCAgICAgICAgICAgIGZvciAodmFyIHYgPSAwOyB2IDwgdGhpcy5fdHJpZ2dlcnMubGVuZ3RoOyB2KyspIHtcblx0ICAgICAgICAgICAgICAgIHZhciBkZXNjID0gdGhpcy5fdHJpZ2dlcnNbdl07XG5cdCAgICAgICAgICAgICAgICBpZiAoZGVzYy5ub3RlID09PSBzdHJpbmdpZmllZCAmJiBkZXNjLnJlbGVhc2UgPiB0aW1lKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgZGVzYy52b2ljZS50cmlnZ2VyUmVsZWFzZSh0aW1lKTtcblx0ICAgICAgICAgICAgICAgICAgICBkZXNjLnJlbGVhc2UgPSB0aW1lO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBTZXQgYSBtZW1iZXIvYXR0cmlidXRlIG9mIHRoZSB2b2ljZXMuIFxuXHRcdCAqICBAcGFyYW0ge09iamVjdHxzdHJpbmd9IHBhcmFtc1xuXHRcdCAqICBAcGFyYW0ge251bWJlcj19IHZhbHVlXG5cdFx0ICogIEBwYXJhbSB7VGltZT19IHJhbXBUaW1lXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLlBvbHlTeW50aH0gdGhpc1xuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIHBvbHkuc2V0KHtcblx0XHQgKiBcdFwiZmlsdGVyXCIgOiB7XG5cdFx0ICogXHRcdFwidHlwZVwiIDogXCJoaWdocGFzc1wiXG5cdFx0ICogXHR9LFxuXHRcdCAqIFx0XCJlbnZlbG9wZVwiIDoge1xuXHRcdCAqIFx0XHRcImF0dGFja1wiIDogMC4yNVxuXHRcdCAqIFx0fVxuXHRcdCAqIH0pO1xuXHRcdCAqL1xuXHQgICAgVG9uZS5Qb2x5U3ludGgucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChwYXJhbXMsIHZhbHVlLCByYW1wVGltZSkge1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy52b2ljZXMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgdGhpcy52b2ljZXNbaV0uc2V0KHBhcmFtcywgdmFsdWUsIHJhbXBUaW1lKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIEdldCB0aGUgc3ludGgncyBhdHRyaWJ1dGVzLiBHaXZlbiBubyBhcmd1bWVudHMgZ2V0XG5cdFx0ICogIHdpbGwgcmV0dXJuIGFsbCBhdmFpbGFibGUgb2JqZWN0IHByb3BlcnRpZXMgYW5kIHRoZWlyIGNvcnJlc3BvbmRpbmdcblx0XHQgKiAgdmFsdWVzLiBQYXNzIGluIGEgc2luZ2xlIGF0dHJpYnV0ZSB0byByZXRyaWV2ZSBvciBhbiBhcnJheVxuXHRcdCAqICBvZiBhdHRyaWJ1dGVzLiBUaGUgYXR0cmlidXRlIHN0cmluZ3MgY2FuIGFsc28gaW5jbHVkZSBhIFwiLlwiXG5cdFx0ICogIHRvIGFjY2VzcyBkZWVwZXIgcHJvcGVydGllcy5cblx0XHQgKiAgQHBhcmFtIHtBcnJheT19IHBhcmFtcyB0aGUgcGFyYW1ldGVycyB0byBnZXQsIG90aGVyd2lzZSB3aWxsIHJldHVybiBcblx0XHQgKiAgXHRcdFx0XHRcdCAgIGFsbCBhdmFpbGFibGUuXG5cdFx0ICovXG5cdCAgICBUb25lLlBvbHlTeW50aC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKHBhcmFtcykge1xuXHQgICAgICAgIHJldHVybiB0aGlzLnZvaWNlc1swXS5nZXQocGFyYW1zKTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgVHJpZ2dlciB0aGUgcmVsZWFzZSBwb3J0aW9uIG9mIGFsbCB0aGUgY3VycmVudGx5IGFjdGl2ZSB2b2ljZXMuXG5cdFx0ICogIEBwYXJhbSB7VGltZX0gW3RpbWU9bm93XSBXaGVuIHRoZSBub3RlcyBzaG91bGQgYmUgcmVsZWFzZWQuXG5cdFx0ICogIEByZXR1cm4ge1RvbmUuUG9seVN5bnRofSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLlBvbHlTeW50aC5wcm90b3R5cGUucmVsZWFzZUFsbCA9IGZ1bmN0aW9uICh0aW1lKSB7XG5cdCAgICAgICAgdGltZSA9IHRoaXMudG9TZWNvbmRzKHRpbWUpO1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fdHJpZ2dlcnMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgdmFyIGRlc2MgPSB0aGlzLl90cmlnZ2Vyc1tpXTtcblx0ICAgICAgICAgICAgaWYgKGRlc2MucmVsZWFzZSA+IHRpbWUpIHtcblx0ICAgICAgICAgICAgICAgIGRlc2MucmVsZWFzZSA9IHRpbWU7XG5cdCAgICAgICAgICAgICAgICBkZXNjLnZvaWNlLnRyaWdnZXJSZWxlYXNlKHRpbWUpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBDbGVhbiB1cC5cblx0XHQgKiAgQHJldHVybnMge1RvbmUuUG9seVN5bnRofSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLlBvbHlTeW50aC5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLkluc3RydW1lbnQucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMudm9pY2VzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgIHRoaXMudm9pY2VzW2ldLmRpc3Bvc2UoKTtcblx0ICAgICAgICAgICAgdGhpcy52b2ljZXNbaV0gPSBudWxsO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB0aGlzLl93cml0YWJsZSgnZGV0dW5lJyk7XG5cdCAgICAgICAgdGhpcy5kZXR1bmUuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuZGV0dW5lID0gbnVsbDtcblx0ICAgICAgICB0aGlzLnZvaWNlcyA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fdHJpZ2dlcnMgPSBudWxsO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgbWF4aW11bSBudW1iZXIgb2Ygbm90ZXMgdGhhdCBjYW4gYmUgYWxsb2NhdGVkIFxuXHRcdCAqICB0byBhIHBvbHlzeW50aC4gXG5cdFx0ICogIEB0eXBlICB7TnVtYmVyfVxuXHRcdCAqICBAc3RhdGljXG5cdFx0ICovXG5cdCAgICBUb25lLlBvbHlTeW50aC5NQVhfUE9MWVBIT05ZID0gMjA7XG5cdCAgICByZXR1cm4gVG9uZS5Qb2x5U3ludGg7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIC8qKlxuXHRcdCAqIEBjbGFzcyBBdXRvbWF0aWNhbGx5IGludGVycG9sYXRlcyBiZXR3ZWVuIGEgc2V0IG9mIHBpdGNoZWQgc2FtcGxlcy4gUGFzcyBpbiBhbiBvYmplY3Qgd2hpY2ggbWFwcyB0aGUgbm90ZSdzIHBpdGNoIG9yIG1pZGkgdmFsdWUgdG8gdGhlIHVybCwgdGhlbiB5b3UgY2FuIHRyaWdnZXIgdGhlIGF0dGFjayBhbmQgcmVsZWFzZSBvZiB0aGF0IG5vdGUgbGlrZSBvdGhlciBpbnN0cnVtZW50cy4gQnkgYXV0b21hdGljYWxseSByZXBpdGNoaW5nIHRoZSBzYW1wbGVzLCBpdCBpcyBwb3NzaWJsZSB0byBwbGF5IHBpdGNoZXMgd2hpY2ggd2VyZSBub3QgZXhwbGljaXRseSBpbmNsdWRlZCB3aGljaCBjYW4gc2F2ZSBsb2FkaW5nIHRpbWUuXG5cdFx0ICogICAgICAgIEZvciBzYW1wbGUgb3IgYnVmZmVyIHBsYXliYWNrIHdoZXJlIHJlcGl0Y2hpbmcgaXMgbm90IG5lY2Vzc2FyeSwgdXNlIFtUb25lLlBsYXllcl0oaHR0cHM6Ly90b25lanMuZ2l0aHViLmlvL2RvY3MvUGxheWVyKS5cblx0XHQgKiBAcGFyYW0ge09iamVjdH0gc2FtcGxlcyBBbiBvYmplY3Qgb2Ygc2FtcGxlcyBtYXBwaW5nIGVpdGhlciBNaWRpXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgTm90ZSBOdW1iZXJzIG9yIFNjaWVudGlmaWMgUGl0Y2ggTm90YXRpb25cblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICB0byB0aGUgdXJsIG9mIHRoYXQgc2FtcGxlLlxuXHRcdCAqIEBleGFtcGxlXG5cdFx0ICogdmFyIHNhbXBsZXIgPSBuZXcgVG9uZS5TYW1wbGVyKHtcblx0XHQgKiBcdFwiQzNcIiA6IFwicGF0aC90by9DMy5tcDNcIixcblx0XHQgKiBcdFwiRCMzXCIgOiBcInBhdGgvdG8vRHNoYXJwMy5tcDNcIixcblx0XHQgKiBcdFwiRiMzXCIgOiBcInBhdGgvdG8vRnNoYXJwMy5tcDNcIixcblx0XHQgKiBcdFwiQTNcIiA6IFwicGF0aC90by9BMy5tcDNcIixcblx0XHQgKiB9LCBmdW5jdGlvbigpe1xuXHRcdCAqIFx0Ly9zYW1wbGVyIHdpbGwgcmVwaXRjaCB0aGUgY2xvc2VzdCBzYW1wbGVcblx0XHQgKiBcdHNhbXBsZXIudHJpZ2dlckF0dGFjayhcIkQzXCIpXG5cdFx0ICogfSlcblx0XHQgKiBAZXh0ZW5kcyB7VG9uZS5JbnN0cnVtZW50fVxuXHRcdCAqL1xuXHQgICAgVG9uZS5TYW1wbGVyID0gZnVuY3Rpb24gKHVybHMpIHtcblx0ICAgICAgICAvLyBzaGlmdCBhcmd1bWVudHMgb3ZlciBvbmUuIFRob3NlIGFyZSB0aGUgcmVtYWluZGVyIG9mIHRoZSBvcHRpb25zXG5cdCAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuXHQgICAgICAgIGFyZ3Muc2hpZnQoKTtcblx0ICAgICAgICB2YXIgb3B0aW9ucyA9IFRvbmUuZGVmYXVsdHMoYXJncywgW1xuXHQgICAgICAgICAgICAnb25sb2FkJyxcblx0ICAgICAgICAgICAgJ2Jhc2VVcmwnXG5cdCAgICAgICAgXSwgVG9uZS5TYW1wbGVyKTtcblx0ICAgICAgICBUb25lLkluc3RydW1lbnQuY2FsbCh0aGlzLCBvcHRpb25zKTtcblx0ICAgICAgICB2YXIgdXJsTWFwID0ge307XG5cdCAgICAgICAgZm9yICh2YXIgbm90ZSBpbiB1cmxzKSB7XG5cdCAgICAgICAgICAgIGlmIChUb25lLmlzTm90ZShub3RlKSkge1xuXHQgICAgICAgICAgICAgICAgLy9jb252ZXJ0IHRoZSBub3RlIG5hbWUgdG8gTUlESVxuXHQgICAgICAgICAgICAgICAgdmFyIG1pZCA9IFRvbmUuRnJlcXVlbmN5KG5vdGUpLnRvTWlkaSgpO1xuXHQgICAgICAgICAgICAgICAgdXJsTWFwW21pZF0gPSB1cmxzW25vdGVdO1xuXHQgICAgICAgICAgICB9IGVsc2UgaWYgKCFpc05hTihwYXJzZUZsb2F0KG5vdGUpKSkge1xuXHQgICAgICAgICAgICAgICAgLy9vdGhlcndpc2UgaWYgaXQncyBudW1iZXJzIGFzc3VtZSBpdCdzIG1pZGlcblx0ICAgICAgICAgICAgICAgIHVybE1hcFtub3RlXSA9IHVybHNbbm90ZV07XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RvbmUuU2FtcGxlcjogdXJsIGtleXMgbXVzdCBiZSB0aGUgbm90ZVxcJ3MgcGl0Y2gnKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICAvKipcblx0XHRcdCAqIFRoZSBzdG9yZWQgYW5kIGxvYWRlZCBidWZmZXJzXG5cdFx0XHQgKiBAdHlwZSB7VG9uZS5CdWZmZXJzfVxuXHRcdFx0ICogQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2J1ZmZlcnMgPSBuZXcgVG9uZS5CdWZmZXJzKHVybE1hcCwgb3B0aW9ucy5vbmxvYWQsIG9wdGlvbnMuYmFzZVVybCk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiBUaGUgb2JqZWN0IG9mIGFsbCBjdXJyZW50bHkgcGxheWluZyBCdWZmZXJTb3VyY2VzXG5cdFx0XHQgKiBAdHlwZSB7T2JqZWN0fVxuXHRcdFx0ICogQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2FjdGl2ZVNvdXJjZXMgPSB7fTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqIFRoZSBlbnZlbG9wZSBhcHBsaWVkIHRvIHRoZSBiZWdpbm5pbmcgb2YgdGhlIHNhbXBsZS5cblx0XHRcdCAqIEB0eXBlIHtUaW1lfVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5hdHRhY2sgPSBvcHRpb25zLmF0dGFjaztcblx0ICAgICAgICAvKipcblx0XHRcdCAqIFRoZSBlbnZlbG9wZSBhcHBsaWVkIHRvIHRoZSBlbmQgb2YgdGhlIGVudmVsb3BlLlxuXHRcdFx0ICogQHR5cGUge1RpbWV9XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLnJlbGVhc2UgPSBvcHRpb25zLnJlbGVhc2U7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5TYW1wbGVyLCBUb25lLkluc3RydW1lbnQpO1xuXHQgICAgLyoqXG5cdFx0ICogVGhlIGRlZmF1bHRzXG5cdFx0ICogQGNvbnN0XG5cdFx0ICogQHR5cGUge09iamVjdH1cblx0XHQgKi9cblx0ICAgIFRvbmUuU2FtcGxlci5kZWZhdWx0cyA9IHtcblx0ICAgICAgICBhdHRhY2s6IDAsXG5cdCAgICAgICAgcmVsZWFzZTogMC4xLFxuXHQgICAgICAgIG9ubG9hZDogVG9uZS5ub09wLFxuXHQgICAgICAgIGJhc2VVcmw6ICcnXG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogUmV0dXJucyB0aGUgZGlmZmVyZW5jZSBpbiBzdGVwcyBiZXR3ZWVuIHRoZSBnaXZlbiBtaWRpIG5vdGUgYXQgdGhlIGNsb3NldHMgc2FtcGxlLlxuXHRcdCAqIEBwYXJhbSAge01pZGl9IG1pZGlcblx0XHQgKiBAcmV0dXJuIHtJbnRlcnZhbH1cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5TYW1wbGVyLnByb3RvdHlwZS5fZmluZENsb3Nlc3QgPSBmdW5jdGlvbiAobWlkaSkge1xuXHQgICAgICAgIHZhciBNQVhfSU5URVJWQUwgPSAyNDtcblx0ICAgICAgICB2YXIgaW50ZXJ2YWwgPSAwO1xuXHQgICAgICAgIHdoaWxlIChpbnRlcnZhbCA8IE1BWF9JTlRFUlZBTCkge1xuXHQgICAgICAgICAgICAvLyBjaGVjayBhYm92ZSBhbmQgYmVsb3dcblx0ICAgICAgICAgICAgaWYgKHRoaXMuX2J1ZmZlcnMuaGFzKG1pZGkgKyBpbnRlcnZhbCkpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiAtaW50ZXJ2YWw7XG5cdCAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5fYnVmZmVycy5oYXMobWlkaSAtIGludGVydmFsKSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGludGVydmFsO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGludGVydmFsKys7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBudWxsO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqIEBwYXJhbSAge0ZyZXF1ZW5jeX0gbm90ZSAgICAgVGhlIG5vdGUgdG8gcGxheVxuXHRcdCAqIEBwYXJhbSAge1RpbWU9fSB0aW1lICAgICBXaGVuIHRvIHBsYXkgdGhlIG5vdGVcblx0XHQgKiBAcGFyYW0gIHtOb3JtYWxSYW5nZT19IHZlbG9jaXR5IFRoZSB2ZWxvY2l0eSB0byBwbGF5IHRoZSBzYW1wbGUgYmFjay5cblx0XHQgKiBAcmV0dXJuIHtUb25lLlNhbXBsZXJ9ICAgICAgICAgIHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuU2FtcGxlci5wcm90b3R5cGUudHJpZ2dlckF0dGFjayA9IGZ1bmN0aW9uIChub3RlLCB0aW1lLCB2ZWxvY2l0eSkge1xuXHQgICAgICAgIHZhciBtaWRpID0gVG9uZS5GcmVxdWVuY3kobm90ZSkudG9NaWRpKCk7XG5cdCAgICAgICAgLy8gZmluZCB0aGUgY2xvc2VzdCBub3RlIHBpdGNoXG5cdCAgICAgICAgdmFyIGRpZmZlcmVuY2UgPSB0aGlzLl9maW5kQ2xvc2VzdChtaWRpKTtcblx0ICAgICAgICBpZiAoZGlmZmVyZW5jZSAhPT0gbnVsbCkge1xuXHQgICAgICAgICAgICB2YXIgY2xvc2VzdE5vdGUgPSBtaWRpIC0gZGlmZmVyZW5jZTtcblx0ICAgICAgICAgICAgdmFyIGJ1ZmZlciA9IHRoaXMuX2J1ZmZlcnMuZ2V0KGNsb3Nlc3ROb3RlKTtcblx0ICAgICAgICAgICAgLy8gcGxheSB0aGF0IG5vdGVcblx0ICAgICAgICAgICAgdmFyIHNvdXJjZSA9IG5ldyBUb25lLkJ1ZmZlclNvdXJjZSh7XG5cdCAgICAgICAgICAgICAgICAnYnVmZmVyJzogYnVmZmVyLFxuXHQgICAgICAgICAgICAgICAgJ3BsYXliYWNrUmF0ZSc6IFRvbmUuaW50ZXJ2YWxUb0ZyZXF1ZW5jeVJhdGlvKGRpZmZlcmVuY2UpLFxuXHQgICAgICAgICAgICAgICAgJ2ZhZGVJbic6IHRoaXMuYXR0YWNrLFxuXHQgICAgICAgICAgICAgICAgJ2ZhZGVPdXQnOiB0aGlzLnJlbGVhc2Vcblx0ICAgICAgICAgICAgfSkuY29ubmVjdCh0aGlzLm91dHB1dCk7XG5cdCAgICAgICAgICAgIHNvdXJjZS5zdGFydCh0aW1lLCAwLCBidWZmZXIuZHVyYXRpb24sIHZlbG9jaXR5KTtcblx0ICAgICAgICAgICAgLy8gYWRkIGl0IHRvIHRoZSBhY3RpdmUgc291cmNlc1xuXHQgICAgICAgICAgICBpZiAoIVRvbmUuaXNBcnJheSh0aGlzLl9hY3RpdmVTb3VyY2VzW21pZGldKSkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fYWN0aXZlU291cmNlc1ttaWRpXSA9IFtdO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHRoaXMuX2FjdGl2ZVNvdXJjZXNbbWlkaV0ucHVzaCh7XG5cdCAgICAgICAgICAgICAgICBub3RlOiBtaWRpLFxuXHQgICAgICAgICAgICAgICAgc291cmNlOiBzb3VyY2Vcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqIEBwYXJhbSAge0ZyZXF1ZW5jeX0gbm90ZSAgICAgVGhlIG5vdGUgdG8gcmVsZWFzZS5cblx0XHQgKiBAcGFyYW0gIHtUaW1lPX0gdGltZSAgICAgXHRXaGVuIHRvIHJlbGVhc2UgdGhlIG5vdGUuXG5cdFx0ICogQHJldHVybiB7VG9uZS5TYW1wbGVyfVx0dGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5TYW1wbGVyLnByb3RvdHlwZS50cmlnZ2VyUmVsZWFzZSA9IGZ1bmN0aW9uIChub3RlLCB0aW1lKSB7XG5cdCAgICAgICAgdmFyIG1pZGkgPSBUb25lLkZyZXF1ZW5jeShub3RlKS50b01pZGkoKTtcblx0ICAgICAgICAvLyBmaW5kIHRoZSBub3RlXG5cdCAgICAgICAgaWYgKHRoaXMuX2FjdGl2ZVNvdXJjZXNbbWlkaV0gJiYgdGhpcy5fYWN0aXZlU291cmNlc1ttaWRpXS5sZW5ndGgpIHtcblx0ICAgICAgICAgICAgdmFyIHNvdXJjZSA9IHRoaXMuX2FjdGl2ZVNvdXJjZXNbbWlkaV0uc2hpZnQoKS5zb3VyY2U7XG5cdCAgICAgICAgICAgIHRpbWUgPSB0aGlzLnRvU2Vjb25kcyh0aW1lKTtcblx0ICAgICAgICAgICAgc291cmNlLnN0b3AodGltZSArIHRoaXMucmVsZWFzZSwgdGhpcy5yZWxlYXNlKTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogSW52b2tlIHRoZSBhdHRhY2sgcGhhc2UsIHRoZW4gYWZ0ZXIgdGhlIGR1cmF0aW9uLCBpbnZva2UgdGhlIHJlbGVhc2UuXG5cdFx0ICogQHBhcmFtICB7RnJlcXVlbmN5fSBub3RlICAgICBUaGUgbm90ZSB0byBwbGF5XG5cdFx0ICogQHBhcmFtICB7VGltZX0gZHVyYXRpb24gVGhlIHRpbWUgdGhlIG5vdGUgc2hvdWxkIGJlIGhlbGRcblx0XHQgKiBAcGFyYW0gIHtUaW1lPX0gdGltZSAgICAgV2hlbiB0byBzdGFydCB0aGUgYXR0YWNrXG5cdFx0ICogQHBhcmFtICB7Tm9ybWFsUmFuZ2V9IFt2ZWxvY2l0eT0xXSBUaGUgdmVsb2NpdHkgb2YgdGhlIGF0dGFja1xuXHRcdCAqIEByZXR1cm4ge1RvbmUuU2FtcGxlcn0gICAgICAgICAgdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5TYW1wbGVyLnByb3RvdHlwZS50cmlnZ2VyQXR0YWNrUmVsZWFzZSA9IGZ1bmN0aW9uIChub3RlLCBkdXJhdGlvbiwgdGltZSwgdmVsb2NpdHkpIHtcblx0ICAgICAgICB0aW1lID0gdGhpcy50b1NlY29uZHModGltZSk7XG5cdCAgICAgICAgZHVyYXRpb24gPSB0aGlzLnRvU2Vjb25kcyhkdXJhdGlvbik7XG5cdCAgICAgICAgdGhpcy50cmlnZ2VyQXR0YWNrKG5vdGUsIHRpbWUsIHZlbG9jaXR5KTtcblx0ICAgICAgICB0aGlzLnRyaWdnZXJSZWxlYXNlKG5vdGUsIHRpbWUgKyBkdXJhdGlvbik7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIEFkZCBhIG5vdGUgdG8gdGhlIHNhbXBsZXIuXG5cdFx0ICogIEBwYXJhbSAge05vdGV8TWlkaX0gICBub3RlICAgICAgVGhlIGJ1ZmZlcidzIHBpdGNoLlxuXHRcdCAqICBAcGFyYW0gIHtTdHJpbmd8VG9uZS5CdWZmZXJ8QXVkaW9idWZmZXJ9ICB1cmwgIEVpdGhlciB0aGUgdXJsIG9mIHRoZSBidWZlcixcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvciBhIGJ1ZmZlciB3aGljaCB3aWxsIGJlIGFkZGVkXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2l0aCB0aGUgZ2l2ZW4gbmFtZS5cblx0XHQgKiAgQHBhcmFtICB7RnVuY3Rpb249fSAgY2FsbGJhY2sgIFRoZSBjYWxsYmFjayB0byBpbnZva2Vcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoZW4gdGhlIHVybCBpcyBsb2FkZWQuXG5cdFx0ICovXG5cdCAgICBUb25lLlNhbXBsZXIucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChub3RlLCB1cmwsIGNhbGxiYWNrKSB7XG5cdCAgICAgICAgaWYgKFRvbmUuaXNOb3RlKG5vdGUpKSB7XG5cdCAgICAgICAgICAgIC8vY29udmVydCB0aGUgbm90ZSBuYW1lIHRvIE1JRElcblx0ICAgICAgICAgICAgdmFyIG1pZCA9IFRvbmUuRnJlcXVlbmN5KG5vdGUpLnRvTWlkaSgpO1xuXHQgICAgICAgICAgICB0aGlzLl9idWZmZXJzLmFkZChtaWQsIHVybCwgY2FsbGJhY2spO1xuXHQgICAgICAgIH0gZWxzZSBpZiAoIWlzTmFOKHBhcnNlRmxvYXQobm90ZSkpKSB7XG5cdCAgICAgICAgICAgIC8vb3RoZXJ3aXNlIGlmIGl0J3MgbnVtYmVycyBhc3N1bWUgaXQncyBtaWRpXG5cdCAgICAgICAgICAgIHRoaXMuX2J1ZmZlcnMuYWRkKG5vdGUsIHVybCwgY2FsbGJhY2spO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVG9uZS5TYW1wbGVyOiBub3RlIG11c3QgYmUgdGhlIG5vdGVcXCdzIHBpdGNoLiBJbnN0ZWFkIGdvdCAnICsgbm90ZSk7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqIElmIHRoZSBidWZmZXJzIGFyZSBsb2FkZWQgb3Igbm90XG5cdFx0ICogQG1lbWJlck9mIFRvbmUuU2FtcGxlciNcblx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0XHQgKiBAbmFtZSBsb2FkZWRcblx0XHQgKiBAcmVhZE9ubHlcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLlNhbXBsZXIucHJvdG90eXBlLCAnbG9hZGVkJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fYnVmZmVycy5sb2FkZWQ7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiBDbGVhbiB1cFxuXHRcdCAqIEByZXR1cm4ge1RvbmUuU2FtcGxlcn0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5TYW1wbGVyLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuSW5zdHJ1bWVudC5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuX2J1ZmZlcnMuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX2J1ZmZlcnMgPSBudWxsO1xuXHQgICAgICAgIGZvciAodmFyIG1pZGkgaW4gdGhpcy5fYWN0aXZlU291cmNlcykge1xuXHQgICAgICAgICAgICB0aGlzLl9hY3RpdmVTb3VyY2VzW21pZGldLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50KSB7XG5cdCAgICAgICAgICAgICAgICBldmVudC5zb3VyY2UuZGlzcG9zZSgpO1xuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdGhpcy5fYWN0aXZlU291cmNlcyA9IG51bGw7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuU2FtcGxlcjtcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgXG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzIE1hcHMgYSBOb3JtYWxSYW5nZSBbMCwgMV0gdG8gYW4gQXVkaW9SYW5nZSBbLTEsIDFdLiBcblx0XHQgKiAgICAgICAgIFNlZSBhbHNvIFRvbmUuQXVkaW9Ub0dhaW4uIFxuXHRcdCAqXG5cdFx0ICogIEBleHRlbmRzIHtUb25lLlNpZ25hbEJhc2V9XG5cdFx0ICogIEBjb25zdHJ1Y3RvclxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIHZhciBnMmEgPSBuZXcgVG9uZS5HYWluVG9BdWRpbygpO1xuXHRcdCAqL1xuXHQgICAgVG9uZS5HYWluVG9BdWRpbyA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLlNpZ25hbEJhc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBAdHlwZSB7V2F2ZVNoYXBlck5vZGV9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX25vcm0gPSB0aGlzLmlucHV0ID0gdGhpcy5vdXRwdXQgPSBuZXcgVG9uZS5XYXZlU2hhcGVyKGZ1bmN0aW9uICh4KSB7XG5cdCAgICAgICAgICAgIHJldHVybiBNYXRoLmFicyh4KSAqIDIgLSAxO1xuXHQgICAgICAgIH0pO1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuR2FpblRvQXVkaW8sIFRvbmUuU2lnbmFsQmFzZSk7XG5cdCAgICAvKipcblx0XHQgKiAgY2xlYW4gdXBcblx0XHQgKiAgQHJldHVybnMge1RvbmUuR2FpblRvQXVkaW99IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuR2FpblRvQXVkaW8ucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5TaWduYWxCYXNlLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgdGhpcy5fbm9ybS5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fbm9ybSA9IG51bGw7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuR2FpblRvQXVkaW87XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyBOb3JtYWxpemUgdGFrZXMgYW4gaW5wdXQgbWluIGFuZCBtYXggYW5kIG1hcHMgaXQgbGluZWFybHkgdG8gTm9ybWFsUmFuZ2UgWzAsMV1cblx0XHQgKlxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZS5TaWduYWxCYXNlfVxuXHRcdCAqICBAY29uc3RydWN0b3Jcblx0XHQgKiAgQHBhcmFtIHtudW1iZXJ9IGlucHV0TWluIHRoZSBtaW4gaW5wdXQgdmFsdWVcblx0XHQgKiAgQHBhcmFtIHtudW1iZXJ9IGlucHV0TWF4IHRoZSBtYXggaW5wdXQgdmFsdWVcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiB2YXIgbm9ybSA9IG5ldyBUb25lLk5vcm1hbGl6ZSgyLCA0KTtcblx0XHQgKiB2YXIgc2lnID0gbmV3IFRvbmUuU2lnbmFsKDMpLmNvbm5lY3Qobm9ybSk7XG5cdFx0ICogLy9vdXRwdXQgb2Ygbm9ybSBpcyAwLjUuIFxuXHRcdCAqL1xuXHQgICAgVG9uZS5Ob3JtYWxpemUgPSBmdW5jdGlvbiAoaW5wdXRNaW4sIGlucHV0TWF4KSB7XG5cdCAgICAgICAgVG9uZS5TaWduYWxCYXNlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgdGhlIG1pbiBpbnB1dCB2YWx1ZVxuXHRcdFx0ICogIEB0eXBlIHtudW1iZXJ9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2lucHV0TWluID0gVG9uZS5kZWZhdWx0QXJnKGlucHV0TWluLCAwKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICB0aGUgbWF4IGlucHV0IHZhbHVlXG5cdFx0XHQgKiAgQHR5cGUge251bWJlcn1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5faW5wdXRNYXggPSBUb25lLmRlZmF1bHRBcmcoaW5wdXRNYXgsIDEpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHN1YnRyYWN0IHRoZSBtaW4gZnJvbSB0aGUgaW5wdXRcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5BZGR9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX3N1YiA9IHRoaXMuaW5wdXQgPSBuZXcgVG9uZS5BZGQoMCk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgZGl2aWRlIGJ5IHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gdGhlIGlucHV0IGFuZCBvdXRwdXRcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5NdWx0aXBseX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fZGl2ID0gdGhpcy5vdXRwdXQgPSBuZXcgVG9uZS5NdWx0aXBseSgxKTtcblx0ICAgICAgICB0aGlzLl9zdWIuY29ubmVjdCh0aGlzLl9kaXYpO1xuXHQgICAgICAgIHRoaXMuX3NldFJhbmdlKCk7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5Ob3JtYWxpemUsIFRvbmUuU2lnbmFsQmFzZSk7XG5cdCAgICAvKipcblx0XHQgKiBUaGUgbWluaW11bSB2YWx1ZSB0aGUgaW5wdXQgc2lnbmFsIHdpbGwgcmVhY2guXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuTm9ybWFsaXplI1xuXHRcdCAqIEB0eXBlIHtudW1iZXJ9XG5cdFx0ICogQG5hbWUgbWluXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5Ob3JtYWxpemUucHJvdG90eXBlLCAnbWluJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5faW5wdXRNaW47XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChtaW4pIHtcblx0ICAgICAgICAgICAgdGhpcy5faW5wdXRNaW4gPSBtaW47XG5cdCAgICAgICAgICAgIHRoaXMuX3NldFJhbmdlKCk7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiBUaGUgbWF4aW11bSB2YWx1ZSB0aGUgaW5wdXQgc2lnbmFsIHdpbGwgcmVhY2guXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuTm9ybWFsaXplI1xuXHRcdCAqIEB0eXBlIHtudW1iZXJ9XG5cdFx0ICogQG5hbWUgbWF4XG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5Ob3JtYWxpemUucHJvdG90eXBlLCAnbWF4Jywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5faW5wdXRNYXg7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChtYXgpIHtcblx0ICAgICAgICAgICAgdGhpcy5faW5wdXRNYXggPSBtYXg7XG5cdCAgICAgICAgICAgIHRoaXMuX3NldFJhbmdlKCk7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgc2V0IHRoZSB2YWx1ZXNcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuTm9ybWFsaXplLnByb3RvdHlwZS5fc2V0UmFuZ2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdGhpcy5fc3ViLnZhbHVlID0gLXRoaXMuX2lucHV0TWluO1xuXHQgICAgICAgIHRoaXMuX2Rpdi52YWx1ZSA9IDEgLyAodGhpcy5faW5wdXRNYXggLSB0aGlzLl9pbnB1dE1pbik7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIGNsZWFuIHVwXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLk5vcm1hbGl6ZX0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5Ob3JtYWxpemUucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5TaWduYWxCYXNlLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgdGhpcy5fc3ViLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9zdWIgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX2Rpdi5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fZGl2ID0gbnVsbDtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVG9uZS5Ob3JtYWxpemU7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIC8qKlxuXHRcdCAqIEBjbGFzcyBUb25lLlRyYW5zcG9ydFRpbWVsaW5lU2lnbmFsIGV4dGVuZHMgVG9uZS5UaW1lbGluZVNpZ25hbCwgYnV0IGFkZHMgdGhlIGFiaWxpdHkgdG8gc3luY2hyb25pemUgdGhlIHNpZ25hbCB0byB0aGUgc2lnbmFsIHRvIHRoZSBUb25lLlRyYW5zcG9ydFxuXHRcdCAqIEBleHRlbmRzIHtUb25lLlRpbWVsaW5lU2lnbmFsfVxuXHRcdCAqL1xuXHQgICAgVG9uZS5UcmFuc3BvcnRUaW1lbGluZVNpZ25hbCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLlRpbWVsaW5lU2lnbmFsLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiBUaGUgcmVhbCBzaWduYWwgb3V0cHV0XG5cdFx0XHQgKiBAdHlwZSB7VG9uZS5TaWduYWx9XG5cdFx0XHQgKiBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5vdXRwdXQgPSB0aGlzLl9vdXRwdXRTaWcgPSBuZXcgVG9uZS5TaWduYWwodGhpcy5faW5pdGlhbCk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiBLZWVwIHRyYWNrIG9mIHRoZSBsYXN0IHZhbHVlLiAoc21hbGwgb3B0aW1pemF0aW9uKVxuXHRcdFx0ICogQHByaXZhdGVcblx0XHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9sYXN0VmFsID0gdGhpcy52YWx1ZTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqIFRoZSBldmVudCBpZCBvZiB0aGUgdGljayB1cGRhdGUgbG9vcFxuXHRcdFx0ICogQHByaXZhdGVcblx0XHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9zeW5jZWQgPSBUb25lLlRyYW5zcG9ydC5zY2hlZHVsZVJlcGVhdCh0aGlzLl9vblRpY2suYmluZCh0aGlzKSwgJzFpJyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiBBIGJvdW5kIHZlcnNpb24gb2YgdGhlIGFuY2hvciB2YWx1ZSBtZXRob2RzXG5cdFx0XHQgKiBAdHlwZSB7RnVuY3Rpb259XG5cdFx0XHQgKiBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fYmluZEFuY2hvclZhbHVlID0gdGhpcy5fYW5jaG9yVmFsdWUuYmluZCh0aGlzKTtcblx0ICAgICAgICBUb25lLlRyYW5zcG9ydC5vbignc3RhcnQgc3RvcCBwYXVzZScsIHRoaXMuX2JpbmRBbmNob3JWYWx1ZSk7XG5cdCAgICAgICAgdGhpcy5fZXZlbnRzLm1lbW9yeSA9IEluZmluaXR5O1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuVHJhbnNwb3J0VGltZWxpbmVTaWduYWwsIFRvbmUuVGltZWxpbmVTaWduYWwpO1xuXHQgICAgLyoqXG5cdFx0ICogQ2FsbGJhY2sgd2hpY2ggaXMgaW52b2tlZCBldmVyeSB0aWNrLlxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICogQHBhcmFtICB7TnVtYmVyfSB0aW1lXG5cdFx0ICogQHJldHVybiB7VG9uZS5UcmFuc3BvcnRUaW1lbGluZVNpZ25hbH0gICAgICB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLlRyYW5zcG9ydFRpbWVsaW5lU2lnbmFsLnByb3RvdHlwZS5fb25UaWNrID0gZnVuY3Rpb24gKHRpbWUpIHtcblx0ICAgICAgICB2YXIgdmFsID0gdGhpcy5nZXRWYWx1ZUF0VGltZShUb25lLlRyYW5zcG9ydC5zZWNvbmRzKTtcblx0ICAgICAgICBpZiAodGhpcy5fbGFzdFZhbCAhPT0gdmFsKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2xhc3RWYWwgPSB2YWw7XG5cdCAgICAgICAgICAgIC8vYXBwcm94aW1hdGUgcmFtcCBjdXJ2ZXMgd2l0aCBsaW5lYXIgcmFtcHNcblx0ICAgICAgICAgICAgdGhpcy5fb3V0cHV0U2lnLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKHZhbCwgdGltZSk7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqIEFuY2hvciB0aGUgdmFsdWUgYXQgdGhlIHN0YXJ0IGFuZCBzdG9wIG9mIHRoZSBUcmFuc3BvcnRcblx0XHQgKiBAcGFyYW0gIHtOdW1iZXJ9IHRpbWUgVGhlIHRpbWUgb2YgdGhlIGV2ZW50XG5cdFx0ICogQHJldHVybiB7VG9uZS5UcmFuc3BvcnRUaW1lbGluZVNpZ25hbH0gICAgICB0aGlzXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuVHJhbnNwb3J0VGltZWxpbmVTaWduYWwucHJvdG90eXBlLl9hbmNob3JWYWx1ZSA9IGZ1bmN0aW9uICh0aW1lKSB7XG5cdCAgICAgICAgdmFyIHZhbCA9IHRoaXMuZ2V0VmFsdWVBdFRpbWUoVG9uZS5UcmFuc3BvcnQudGlja3MpO1xuXHQgICAgICAgIHRoaXMuX2xhc3RWYWwgPSB2YWw7XG5cdCAgICAgICAgdGhpcy5fb3V0cHV0U2lnLmNhbmNlbFNjaGVkdWxlZFZhbHVlcyh0aW1lKTtcblx0ICAgICAgICB0aGlzLl9vdXRwdXRTaWcuc2V0VmFsdWVBdFRpbWUodmFsLCB0aW1lKTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgR2V0IHRoZSBzY2hlZHVsZWQgdmFsdWUgYXQgdGhlIGdpdmVuIHRpbWUuIFRoaXMgd2lsbFxuXHRcdCAqICByZXR1cm4gdGhlIHVuY29udmVydGVkIChyYXcpIHZhbHVlLlxuXHRcdCAqICBAcGFyYW0gIHtUcmFuc3BvcnRUaW1lfSAgdGltZSAgVGhlIHRpbWUgaW4gc2Vjb25kcy5cblx0XHQgKiAgQHJldHVybiAge051bWJlcn0gIFRoZSBzY2hlZHVsZWQgdmFsdWUgYXQgdGhlIGdpdmVuIHRpbWUuXG5cdFx0ICovXG5cdCAgICBUb25lLlRyYW5zcG9ydFRpbWVsaW5lU2lnbmFsLnByb3RvdHlwZS5nZXRWYWx1ZUF0VGltZSA9IGZ1bmN0aW9uICh0aW1lKSB7XG5cdCAgICAgICAgdGltZSA9IHRoaXMudG9UaWNrcyh0aW1lKTtcblx0ICAgICAgICByZXR1cm4gVG9uZS5UaW1lbGluZVNpZ25hbC5wcm90b3R5cGUuZ2V0VmFsdWVBdFRpbWUuY2FsbCh0aGlzLCB0aW1lKTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiBTZXQgdGhlIG91dHB1dCBvZiB0aGUgc2lnbmFsIGF0IHRoZSBnaXZlbiB0aW1lXG5cdFx0ICogQHBhcmFtICB7TnVtYmVyfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hhbmdlIHRvIGF0IHRoZSBnaXZlbiB0aW1lXG5cdFx0ICogQHBhcmFtICB7VHJhbnNwb3J0VGltZX0gdGltZSAgVGhlIHRpbWUgdG8gY2hhbmdlIHRoZSBzaWduYWxcblx0XHQgKiBAcmV0dXJuIHtUb25lLlRyYW5zcG9ydFRpbWVsaW5lU2lnbmFsfSAgICAgICB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLlRyYW5zcG9ydFRpbWVsaW5lU2lnbmFsLnByb3RvdHlwZS5zZXRWYWx1ZUF0VGltZSA9IGZ1bmN0aW9uICh2YWx1ZSwgdGltZSkge1xuXHQgICAgICAgIHRpbWUgPSB0aGlzLnRvVGlja3ModGltZSk7XG5cdCAgICAgICAgVG9uZS5UaW1lbGluZVNpZ25hbC5wcm90b3R5cGUuc2V0VmFsdWVBdFRpbWUuY2FsbCh0aGlzLCB2YWx1ZSwgdGltZSk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogTGluZWFyIHJhbXAgdG8gdGhlIGdpdmVuIHZhbHVlIGZyb20gdGhlIHByZXZpb3VzIHNjaGVkdWxlZCBwb2ludCB0byB0aGUgZ2l2ZW4gdmFsdWVcblx0XHQgKiBAcGFyYW0gIHtOdW1iZXJ9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGFuZ2UgdG8gYXQgdGhlIGdpdmVuIHRpbWVcblx0XHQgKiBAcGFyYW0gIHtUcmFuc3BvcnRUaW1lfSB0aW1lICBUaGUgdGltZSB0byBjaGFuZ2UgdGhlIHNpZ25hbFxuXHRcdCAqIEByZXR1cm4ge1RvbmUuVHJhbnNwb3J0VGltZWxpbmVTaWduYWx9ICAgICAgIHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuVHJhbnNwb3J0VGltZWxpbmVTaWduYWwucHJvdG90eXBlLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lID0gZnVuY3Rpb24gKHZhbHVlLCB0aW1lKSB7XG5cdCAgICAgICAgdGltZSA9IHRoaXMudG9UaWNrcyh0aW1lKTtcblx0ICAgICAgICBUb25lLlRpbWVsaW5lU2lnbmFsLnByb3RvdHlwZS5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZS5jYWxsKHRoaXMsIHZhbHVlLCB0aW1lKTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiBFeHBvbmVudGlhbCByYW1wIHRvIHRoZSBnaXZlbiB2YWx1ZSBmcm9tIHRoZSBwcmV2aW91cyBzY2hlZHVsZWQgcG9pbnQgdG8gdGhlIGdpdmVuIHZhbHVlXG5cdFx0ICogQHBhcmFtICB7TnVtYmVyfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hhbmdlIHRvIGF0IHRoZSBnaXZlbiB0aW1lXG5cdFx0ICogQHBhcmFtICB7VHJhbnNwb3J0VGltZX0gdGltZSAgVGhlIHRpbWUgdG8gY2hhbmdlIHRoZSBzaWduYWxcblx0XHQgKiBAcmV0dXJuIHtUb25lLlRyYW5zcG9ydFRpbWVsaW5lU2lnbmFsfSAgICAgICB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLlRyYW5zcG9ydFRpbWVsaW5lU2lnbmFsLnByb3RvdHlwZS5leHBvbmVudGlhbFJhbXBUb1ZhbHVlQXRUaW1lID0gZnVuY3Rpb24gKHZhbHVlLCB0aW1lKSB7XG5cdCAgICAgICAgdGltZSA9IHRoaXMudG9UaWNrcyh0aW1lKTtcblx0ICAgICAgICBUb25lLlRpbWVsaW5lU2lnbmFsLnByb3RvdHlwZS5leHBvbmVudGlhbFJhbXBUb1ZhbHVlQXRUaW1lLmNhbGwodGhpcywgdmFsdWUsIHRpbWUpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBTdGFydCBleHBvbmVudGlhbGx5IGFwcHJvYWNoaW5nIHRoZSB0YXJnZXQgdmFsdWUgYXQgdGhlIGdpdmVuIHRpbWUgd2l0aFxuXHRcdCAqICBhIHJhdGUgaGF2aW5nIHRoZSBnaXZlbiB0aW1lIGNvbnN0YW50LlxuXHRcdCAqICBAcGFyYW0ge251bWJlcn0gdmFsdWVcblx0XHQgKiAgQHBhcmFtIHtUcmFuc3BvcnRUaW1lfSBzdGFydFRpbWVcblx0XHQgKiAgQHBhcmFtIHtudW1iZXJ9IHRpbWVDb25zdGFudFxuXHRcdCAqIEByZXR1cm4ge1RvbmUuVHJhbnNwb3J0VGltZWxpbmVTaWduYWx9ICAgICAgIHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuVHJhbnNwb3J0VGltZWxpbmVTaWduYWwucHJvdG90eXBlLnNldFRhcmdldEF0VGltZSA9IGZ1bmN0aW9uICh2YWx1ZSwgc3RhcnRUaW1lLCB0aW1lQ29uc3RhbnQpIHtcblx0ICAgICAgICBzdGFydFRpbWUgPSB0aGlzLnRvVGlja3Moc3RhcnRUaW1lKTtcblx0ICAgICAgICBUb25lLlRpbWVsaW5lU2lnbmFsLnByb3RvdHlwZS5zZXRUYXJnZXRBdFRpbWUuY2FsbCh0aGlzLCB2YWx1ZSwgc3RhcnRUaW1lLCB0aW1lQ29uc3RhbnQpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBDYW5jZWxzIGFsbCBzY2hlZHVsZWQgcGFyYW1ldGVyIGNoYW5nZXMgd2l0aCB0aW1lcyBncmVhdGVyIHRoYW4gb3Jcblx0XHQgKiAgZXF1YWwgdG8gc3RhcnRUaW1lLlxuXHRcdCAqICBAcGFyYW0gIHtUcmFuc3BvcnRUaW1lfSBzdGFydFRpbWVcblx0XHQgKiAgQHJldHVybnMge1RvbmUuUGFyYW19IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuVHJhbnNwb3J0VGltZWxpbmVTaWduYWwucHJvdG90eXBlLmNhbmNlbFNjaGVkdWxlZFZhbHVlcyA9IGZ1bmN0aW9uIChzdGFydFRpbWUpIHtcblx0ICAgICAgICBzdGFydFRpbWUgPSB0aGlzLnRvVGlja3Moc3RhcnRUaW1lKTtcblx0ICAgICAgICBUb25lLlRpbWVsaW5lU2lnbmFsLnByb3RvdHlwZS5jYW5jZWxTY2hlZHVsZWRWYWx1ZXMuY2FsbCh0aGlzLCBzdGFydFRpbWUpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBTZXQgYW4gYXJyYXkgb2YgYXJiaXRyYXJ5IHZhbHVlcyBzdGFydGluZyBhdCB0aGUgZ2l2ZW4gdGltZSBmb3IgdGhlIGdpdmVuIGR1cmF0aW9uLlxuXHRcdCAqICBAcGFyYW0ge0Zsb2F0MzJBcnJheX0gdmFsdWVzXG5cdFx0ICogIEBwYXJhbSB7VGltZX0gc3RhcnRUaW1lXG5cdFx0ICogIEBwYXJhbSB7VGltZX0gZHVyYXRpb25cblx0XHQgKiAgQHBhcmFtIHtOb3JtYWxSYW5nZX0gW3NjYWxpbmc9MV0gSWYgdGhlIHZhbHVlcyBpbiB0aGUgY3VydmUgc2hvdWxkIGJlIHNjYWxlZCBieSBzb21lIHZhbHVlXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLlRpbWVsaW5lU2lnbmFsfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLlRyYW5zcG9ydFRpbWVsaW5lU2lnbmFsLnByb3RvdHlwZS5zZXRWYWx1ZUN1cnZlQXRUaW1lID0gZnVuY3Rpb24gKHZhbHVlcywgc3RhcnRUaW1lLCBkdXJhdGlvbiwgc2NhbGluZykge1xuXHQgICAgICAgIHN0YXJ0VGltZSA9IHRoaXMudG9UaWNrcyhzdGFydFRpbWUpO1xuXHQgICAgICAgIGR1cmF0aW9uID0gdGhpcy50b1RpY2tzKGR1cmF0aW9uKTtcblx0ICAgICAgICBUb25lLlRpbWVsaW5lU2lnbmFsLnByb3RvdHlwZS5zZXRWYWx1ZUN1cnZlQXRUaW1lLmNhbGwodGhpcywgdmFsdWVzLCBzdGFydFRpbWUsIGR1cmF0aW9uLCBzY2FsaW5nKTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiBEaXNwb3NlIGFuZCBkaXNjb25uZWN0XG5cdFx0ICogQHJldHVybiB7VG9uZS5UcmFuc3BvcnRUaW1lbGluZVNpZ25hbH0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5UcmFuc3BvcnRUaW1lbGluZVNpZ25hbC5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLlRyYW5zcG9ydC5jbGVhcih0aGlzLl9zeW5jZWQpO1xuXHQgICAgICAgIFRvbmUuVHJhbnNwb3J0Lm9mZignc3RhcnQgc3RvcCBwYXVzZScsIHRoaXMuX3N5bmNlZENhbGxiYWNrKTtcblx0ICAgICAgICB0aGlzLl9ldmVudHMuY2FuY2VsKDApO1xuXHQgICAgICAgIFRvbmUuVGltZWxpbmVTaWduYWwucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLl9vdXRwdXRTaWcuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX291dHB1dFNpZyA9IG51bGw7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuVHJhbnNwb3J0VGltZWxpbmVTaWduYWw7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgVG9uZS5NdWx0aVBsYXllciBpcyB3ZWxsIHN1aXRlZCBmb3Igb25lLXNob3RzLCBtdWx0aS1zYW1wbGVkIGluc3RydW1lbnRzXG5cdFx0ICogICAgICAgICBvciBhbnkgdGltZSB5b3UgbmVlZCB0byBwbGF5IGEgYnVuY2ggb2YgYXVkaW8gYnVmZmVycy4gXG5cdFx0ICpcblx0XHQgKiAgQGRlcHJlY2F0ZWQgVXNlIFtUb25lLlBsYXllcnNdKFBsYXllcnMpIGluc3RlYWQuXG5cdFx0ICogIEBwYXJhbSAge09iamVjdHxBcnJheXxUb25lLkJ1ZmZlcnN9ICBidWZmZXJzICBUaGUgYnVmZmVycyB3aGljaCBhcmUgYXZhaWxhYmxlXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0byB0aGUgTXVsdGlQbGF5ZXJcblx0XHQgKiAgQHBhcmFtIHtGdW5jdGlvbn0gb25sb2FkIFRoZSBjYWxsYmFjayB0byBpbnZva2Ugd2hlbiBhbGwgb2YgdGhlIGJ1ZmZlcnMgYXJlIGxvYWRlZC5cblx0XHQgKiAgQGV4dGVuZHMge1RvbmV9XG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogdmFyIG11bHRpUGxheWVyID0gbmV3IE11bHRpUGxheWVyKHtcblx0XHQgKiBcdFwia2lja1wiIDogXCJwYXRoL3RvL2tpY2subXAzXCIsXG5cdFx0ICogXHRcInNuYXJlXCIgOiBcInBhdGgvdG8vc25hcmUubXAzXCIsXG5cdFx0ICogfSwgZnVuY3Rpb24oKXtcblx0XHQgKiBcdG11bHRpUGxheWVyLnN0YXJ0KFwia2lja1wiKTtcblx0XHQgKiB9KTtcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAvL2NhbiBhbHNvIHN0b3JlIHRoZSB2YWx1ZXMgaW4gYW4gYXJyYXlcblx0XHQgKiB2YXIgbXVsdGlQbGF5ZXIgPSBuZXcgTXVsdGlQbGF5ZXIoW1wicGF0aC90by9raWNrLm1wM1wiLCBcInBhdGgvdG8vc25hcmUubXAzXCJdLCBcblx0XHQgKiBmdW5jdGlvbigpe1xuXHRcdCAqIFx0Ly9pZiBhbiBhcnJheSBpcyBwYXNzZWQgaW4sIHRoZSBzYW1wbGVzIGFyZSByZWZlcmVuY2VkIHRvIGJ5IGluZGV4XG5cdFx0ICogXHRtdWx0aVBsYXllci5zdGFydCgxKTtcblx0XHQgKiB9KTtcblx0XHQgKi9cblx0ICAgIFRvbmUuTXVsdGlQbGF5ZXIgPSBmdW5jdGlvbiAodXJscykge1xuXHQgICAgICAgIGNvbnNvbGUud2FybignVG9uZS5NdWx0aVBsYXllciBpcyBkZXByZWNhdGVkLiBVc2UgVG9uZS5QbGF5ZXJzIGluc3RlYWQuJyk7XG5cdCAgICAgICAgLy9yZW1vdmUgdGhlIHVybHMgZnJvbSB0aGUgb3B0aW9uc1xuXHQgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxICYmICFUb25lLmlzVW5kZWYoYXJndW1lbnRzWzBdKSAmJiAhYXJndW1lbnRzWzBdLmhhc093blByb3BlcnR5KCd1cmxzJykpIHtcblx0ICAgICAgICAgICAgdXJscyA9IHsgJ3VybHMnOiB1cmxzIH07XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBvcHRpb25zID0gVG9uZS5kZWZhdWx0cyhhcmd1bWVudHMsIFtcblx0ICAgICAgICAgICAgJ3VybHMnLFxuXHQgICAgICAgICAgICAnb25sb2FkJ1xuXHQgICAgICAgIF0sIFRvbmUuTXVsdGlQbGF5ZXIpO1xuXHQgICAgICAgIFRvbmUuU291cmNlLmNhbGwodGhpcywgb3B0aW9ucyk7XG5cdCAgICAgICAgaWYgKG9wdGlvbnMudXJscyBpbnN0YW5jZW9mIFRvbmUuQnVmZmVycykge1xuXHQgICAgICAgICAgICAvKipcblx0XHRcdFx0ICogIEFsbCB0aGUgYnVmZmVycyBiZWxvbmdpbmcgdG8gdGhlIHBsYXllci5cblx0XHRcdFx0ICogIEB0eXBlICB7VG9uZS5CdWZmZXJzfVxuXHRcdFx0XHQgKi9cblx0ICAgICAgICAgICAgdGhpcy5idWZmZXJzID0gb3B0aW9ucy51cmxzO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIHRoaXMuYnVmZmVycyA9IG5ldyBUb25lLkJ1ZmZlcnMob3B0aW9ucy51cmxzLCBvcHRpb25zLm9ubG9hZCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIEtlZXBzIHRyYWNrIG9mIHRoZSBjdXJyZW50bHkgcGxheWluZyBzb3VyY2VzLlxuXHRcdFx0ICogIEB0eXBlICB7T2JqZWN0fVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9hY3RpdmVTb3VyY2VzID0ge307XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGZhZGUgaW4gZW52ZWxvcGUgd2hpY2ggaXMgYXBwbGllZFxuXHRcdFx0ICogIHRvIHRoZSBiZWdpbm5pbmcgb2YgdGhlIEJ1ZmZlclNvdXJjZVxuXHRcdFx0ICogIEB0eXBlICB7VGltZX1cblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuZmFkZUluID0gb3B0aW9ucy5mYWRlSW47XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGZhZGUgb3V0IGVudmVsb3BlIHdoaWNoIGlzIGFwcGxpZWRcblx0XHRcdCAqICB0byB0aGUgZW5kIG9mIHRoZSBCdWZmZXJTb3VyY2Vcblx0XHRcdCAqICBAdHlwZSAge1RpbWV9XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmZhZGVPdXQgPSBvcHRpb25zLmZhZGVPdXQ7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5NdWx0aVBsYXllciwgVG9uZS5Tb3VyY2UpO1xuXHQgICAgLyoqXG5cdFx0ICogIFRoZSBkZWZhdWx0c1xuXHRcdCAqICBAdHlwZSAge09iamVjdH1cblx0XHQgKi9cblx0ICAgIFRvbmUuTXVsdGlQbGF5ZXIuZGVmYXVsdHMgPSB7XG5cdCAgICAgICAgJ29ubG9hZCc6IFRvbmUubm9PcCxcblx0ICAgICAgICAnZmFkZUluJzogMCxcblx0ICAgICAgICAnZmFkZU91dCc6IDBcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiBNYWtlIHRoZSBzb3VyY2UgZnJvbSB0aGUgYnVmZmVybmFtZVxuXHRcdCAqIEBwYXJhbSAge1N0cmluZ30gYnVmZmVyTmFtZVxuXHRcdCAqIEByZXR1cm4ge1RvbmUuQnVmZmVyU291cmNlfVxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLk11bHRpUGxheWVyLnByb3RvdHlwZS5fbWFrZVNvdXJjZSA9IGZ1bmN0aW9uIChidWZmZXJOYW1lKSB7XG5cdCAgICAgICAgdmFyIGJ1ZmZlcjtcblx0ICAgICAgICBpZiAoVG9uZS5pc1N0cmluZyhidWZmZXJOYW1lKSB8fCBUb25lLmlzTnVtYmVyKGJ1ZmZlck5hbWUpKSB7XG5cdCAgICAgICAgICAgIGJ1ZmZlciA9IHRoaXMuYnVmZmVycy5nZXQoYnVmZmVyTmFtZSkuZ2V0KCk7XG5cdCAgICAgICAgfSBlbHNlIGlmIChidWZmZXJOYW1lIGluc3RhbmNlb2YgVG9uZS5CdWZmZXIpIHtcblx0ICAgICAgICAgICAgYnVmZmVyID0gYnVmZmVyTmFtZS5nZXQoKTtcblx0ICAgICAgICB9IGVsc2UgaWYgKGJ1ZmZlck5hbWUgaW5zdGFuY2VvZiBBdWRpb0J1ZmZlcikge1xuXHQgICAgICAgICAgICBidWZmZXIgPSBidWZmZXJOYW1lO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgc291cmNlID0gbmV3IFRvbmUuQnVmZmVyU291cmNlKGJ1ZmZlcikuY29ubmVjdCh0aGlzLm91dHB1dCk7XG5cdCAgICAgICAgaWYgKCF0aGlzLl9hY3RpdmVTb3VyY2VzLmhhc093blByb3BlcnR5KGJ1ZmZlck5hbWUpKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2FjdGl2ZVNvdXJjZXNbYnVmZmVyTmFtZV0gPSBbXTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdGhpcy5fYWN0aXZlU291cmNlc1tidWZmZXJOYW1lXS5wdXNoKHNvdXJjZSk7XG5cdCAgICAgICAgcmV0dXJuIHNvdXJjZTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgU3RhcnQgYSBidWZmZXIgYnkgbmFtZS4gVGhlIGBzdGFydGAgbWV0aG9kIGFsbG93cyBhIG51bWJlciBvZiBvcHRpb25zXG5cdFx0ICogIHRvIGJlIHBhc3NlZCBpbiBzdWNoIGFzIG9mZnNldCwgaW50ZXJ2YWwsIGFuZCBnYWluLiBUaGlzIGlzIGdvb2QgZm9yIG11bHRpLXNhbXBsZWQgXG5cdFx0ICogIGluc3RydW1lbnRzIGFuZCBzb3VuZCBzcHJpdGVzIHdoZXJlIHNhbXBsZXMgYXJlIHJlcGl0Y2hlZCBwbGF5ZWQgYmFjayBhdCBkaWZmZXJlbnQgdmVsb2NpdGllcy5cblx0XHQgKiAgQHBhcmFtICB7U3RyaW5nfSAgYnVmZmVyTmFtZSAgICBUaGUgbmFtZSBvZiB0aGUgYnVmZmVyIHRvIHN0YXJ0LlxuXHRcdCAqICBAcGFyYW0gIHtUaW1lfSAgdGltZSAgICAgIFdoZW4gdG8gc3RhcnQgdGhlIGJ1ZmZlci5cblx0XHQgKiAgQHBhcmFtICB7VGltZX0gIFtvZmZzZXQ9MF0gICAgVGhlIG9mZnNldCBpbnRvIHRoZSBidWZmZXIgdG8gcGxheSBmcm9tLlxuXHRcdCAqICBAcGFyYW0gIHtUaW1lPX0gIGR1cmF0aW9uICAgSG93IGxvbmcgdG8gcGxheSB0aGUgYnVmZmVyIGZvci5cblx0XHQgKiAgQHBhcmFtICB7SW50ZXJ2YWx9ICBbcGl0Y2g9MF0gIFRoZSBpbnRlcnZhbCB0byByZXBpdGNoIHRoZSBidWZmZXIuXG5cdFx0ICogIEBwYXJhbSAge0dhaW59ICBbZ2Fpbj0xXSAgICAgIFRoZSBnYWluIHRvIHBsYXkgdGhlIHNhbXBsZSBhdC5cblx0XHQgKiAgQHJldHVybiAge1RvbmUuTXVsdGlQbGF5ZXJ9ICB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLk11bHRpUGxheWVyLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uIChidWZmZXJOYW1lLCB0aW1lLCBvZmZzZXQsIGR1cmF0aW9uLCBwaXRjaCwgZ2Fpbikge1xuXHQgICAgICAgIHRpbWUgPSB0aGlzLnRvU2Vjb25kcyh0aW1lKTtcblx0ICAgICAgICB2YXIgc291cmNlID0gdGhpcy5fbWFrZVNvdXJjZShidWZmZXJOYW1lKTtcblx0ICAgICAgICBzb3VyY2Uuc3RhcnQodGltZSwgb2Zmc2V0LCBkdXJhdGlvbiwgVG9uZS5kZWZhdWx0QXJnKGdhaW4sIDEpLCB0aGlzLmZhZGVJbik7XG5cdCAgICAgICAgaWYgKGR1cmF0aW9uKSB7XG5cdCAgICAgICAgICAgIHNvdXJjZS5zdG9wKHRpbWUgKyB0aGlzLnRvU2Vjb25kcyhkdXJhdGlvbiksIHRoaXMuZmFkZU91dCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHBpdGNoID0gVG9uZS5kZWZhdWx0QXJnKHBpdGNoLCAwKTtcblx0ICAgICAgICBzb3VyY2UucGxheWJhY2tSYXRlLnZhbHVlID0gVG9uZS5pbnRlcnZhbFRvRnJlcXVlbmN5UmF0aW8ocGl0Y2gpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBTdGFydCBhIGxvb3BpbmcgYnVmZmVyIGJ5IG5hbWUuIFNpbWlsYXIgdG8gYHN0YXJ0YCwgYnV0IHRoZSBidWZmZXJcblx0XHQgKiAgaXMgbG9vcGVkIGluc3RlYWQgb2YgcGxheWVkIHN0cmFpZ2h0IHRocm91Z2guIENhbiBzdGlsbCBiZSBzdG9wcGVkIHdpdGggYHN0b3BgLiBcblx0XHQgKiAgQHBhcmFtICB7U3RyaW5nfSAgYnVmZmVyTmFtZSAgICBUaGUgbmFtZSBvZiB0aGUgYnVmZmVyIHRvIHN0YXJ0LlxuXHRcdCAqICBAcGFyYW0gIHtUaW1lfSAgdGltZSAgICAgIFdoZW4gdG8gc3RhcnQgdGhlIGJ1ZmZlci5cblx0XHQgKiAgQHBhcmFtICB7VGltZX0gIFtvZmZzZXQ9MF0gICAgVGhlIG9mZnNldCBpbnRvIHRoZSBidWZmZXIgdG8gcGxheSBmcm9tLlxuXHRcdCAqICBAcGFyYW0gIHtUaW1lPX0gIGxvb3BTdGFydCAgIFRoZSBzdGFydCBvZiB0aGUgbG9vcC5cblx0XHQgKiAgQHBhcmFtICB7VGltZT19ICBsb29wRW5kXHRUaGUgZW5kIG9mIHRoZSBsb29wLlxuXHRcdCAqICBAcGFyYW0gIHtJbnRlcnZhbH0gIFtwaXRjaD0wXSAgVGhlIGludGVydmFsIHRvIHJlcGl0Y2ggdGhlIGJ1ZmZlci5cblx0XHQgKiAgQHBhcmFtICB7R2Fpbn0gIFtnYWluPTFdICAgICAgVGhlIGdhaW4gdG8gcGxheSB0aGUgc2FtcGxlIGF0LlxuXHRcdCAqICBAcmV0dXJuICB7VG9uZS5NdWx0aVBsYXllcn0gIHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuTXVsdGlQbGF5ZXIucHJvdG90eXBlLnN0YXJ0TG9vcCA9IGZ1bmN0aW9uIChidWZmZXJOYW1lLCB0aW1lLCBvZmZzZXQsIGxvb3BTdGFydCwgbG9vcEVuZCwgcGl0Y2gsIGdhaW4pIHtcblx0ICAgICAgICB0aW1lID0gdGhpcy50b1NlY29uZHModGltZSk7XG5cdCAgICAgICAgdmFyIHNvdXJjZSA9IHRoaXMuX21ha2VTb3VyY2UoYnVmZmVyTmFtZSk7XG5cdCAgICAgICAgc291cmNlLmxvb3AgPSB0cnVlO1xuXHQgICAgICAgIHNvdXJjZS5sb29wU3RhcnQgPSB0aGlzLnRvU2Vjb25kcyhUb25lLmRlZmF1bHRBcmcobG9vcFN0YXJ0LCAwKSk7XG5cdCAgICAgICAgc291cmNlLmxvb3BFbmQgPSB0aGlzLnRvU2Vjb25kcyhUb25lLmRlZmF1bHRBcmcobG9vcEVuZCwgMCkpO1xuXHQgICAgICAgIHNvdXJjZS5zdGFydCh0aW1lLCBvZmZzZXQsIHVuZGVmaW5lZCwgVG9uZS5kZWZhdWx0QXJnKGdhaW4sIDEpLCB0aGlzLmZhZGVJbik7XG5cdCAgICAgICAgcGl0Y2ggPSBUb25lLmRlZmF1bHRBcmcocGl0Y2gsIDApO1xuXHQgICAgICAgIHNvdXJjZS5wbGF5YmFja1JhdGUudmFsdWUgPSBUb25lLmludGVydmFsVG9GcmVxdWVuY3lSYXRpbyhwaXRjaCk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFN0b3AgdGhlIGZpcnN0IHBsYXllZCBpbnN0YW5jZSBvZiB0aGUgYnVmZmVyIG5hbWUuXG5cdFx0ICogIEBwYXJhbSAge1N0cmluZ30gIGJ1ZmZlck5hbWUgIFRoZSBidWZmZXIgdG8gc3RvcC5cblx0XHQgKiAgQHBhcmFtICB7VGltZT19ICB0aW1lICAgIFdoZW4gdG8gc3RvcCB0aGUgYnVmZmVyXG5cdFx0ICogIEByZXR1cm4gIHtUb25lLk11bHRpUGxheWVyfSAgdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5NdWx0aVBsYXllci5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uIChidWZmZXJOYW1lLCB0aW1lKSB7XG5cdCAgICAgICAgaWYgKHRoaXMuX2FjdGl2ZVNvdXJjZXNbYnVmZmVyTmFtZV0gJiYgdGhpcy5fYWN0aXZlU291cmNlc1tidWZmZXJOYW1lXS5sZW5ndGgpIHtcblx0ICAgICAgICAgICAgdGltZSA9IHRoaXMudG9TZWNvbmRzKHRpbWUpO1xuXHQgICAgICAgICAgICB0aGlzLl9hY3RpdmVTb3VyY2VzW2J1ZmZlck5hbWVdLnNoaWZ0KCkuc3RvcCh0aW1lLCB0aGlzLmZhZGVPdXQpO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVG9uZS5NdWx0aVBsYXllcjogY2Fubm90IHN0b3AgYSBidWZmZXIgdGhhdCBoYXNuXFwndCBiZWVuIHN0YXJ0ZWQgb3IgaXMgYWxyZWFkeSBzdG9wcGVkJyk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBTdG9wIGFsbCBjdXJyZW50bHkgcGxheWluZyBidWZmZXJzIGF0IHRoZSBnaXZlbiB0aW1lLlxuXHRcdCAqICBAcGFyYW0gIHtUaW1lPX0gIHRpbWUgIFdoZW4gdG8gc3RvcCB0aGUgYnVmZmVycy5cblx0XHQgKiAgQHJldHVybiAge1RvbmUuTXVsdGlQbGF5ZXJ9ICB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLk11bHRpUGxheWVyLnByb3RvdHlwZS5zdG9wQWxsID0gZnVuY3Rpb24gKHRpbWUpIHtcblx0ICAgICAgICB0aW1lID0gdGhpcy50b1NlY29uZHModGltZSk7XG5cdCAgICAgICAgZm9yICh2YXIgYnVmZmVyTmFtZSBpbiB0aGlzLl9hY3RpdmVTb3VyY2VzKSB7XG5cdCAgICAgICAgICAgIHZhciBzb3VyY2VzID0gdGhpcy5fYWN0aXZlU291cmNlc1tidWZmZXJOYW1lXTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzb3VyY2VzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICBzb3VyY2VzW2ldLnN0b3AodGltZSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIEFkZCBhbm90aGVyIGJ1ZmZlciB0byB0aGUgYXZhaWxhYmxlIGJ1ZmZlcnMuXG5cdFx0ICogIEBwYXJhbSB7U3RyaW5nfSBuYW1lIFRoZSBuYW1lIHRvIHRoYXQgdGhlIGJ1ZmZlciBpcyByZWZlcmVkXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgIHRvIGluIHN0YXJ0L3N0b3AgbWV0aG9kcy4gXG5cdFx0ICogIEBwYXJhbSB7U3RyaW5nfFRvbmUuQnVmZmVyfSB1cmwgVGhlIHVybCBvZiB0aGUgYnVmZmVyIHRvIGxvYWRcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvciB0aGUgYnVmZmVyLlxuXHRcdCAqICBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdG8gaW52b2tlIGFmdGVyIHRoZSBidWZmZXIgaXMgbG9hZGVkLlxuXHRcdCAqL1xuXHQgICAgVG9uZS5NdWx0aVBsYXllci5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKG5hbWUsIHVybCwgY2FsbGJhY2spIHtcblx0ICAgICAgICB0aGlzLmJ1ZmZlcnMuYWRkKG5hbWUsIHVybCwgY2FsbGJhY2spO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBSZXR1cm5zIHRoZSBwbGF5YmFjayBzdGF0ZSBvZiB0aGUgc291cmNlLiBcInN0YXJ0ZWRcIlxuXHRcdCAqICBpZiB0aGVyZSBhcmUgYW55IGJ1ZmZlcnMgcGxheWluZy4gXCJzdG9wcGVkXCIgb3RoZXJ3aXNlLlxuXHRcdCAqICBAdHlwZSB7VG9uZS5TdGF0ZX1cblx0XHQgKiAgQHJlYWRPbmx5XG5cdFx0ICogIEBtZW1iZXJPZiBUb25lLk11bHRpUGxheWVyI1xuXHRcdCAqICBAbmFtZSBzdGF0ZVxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuTXVsdGlQbGF5ZXIucHJvdG90eXBlLCAnc3RhdGUnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9hY3RpdmVTb3VyY2VzLmxlbmd0aCA+IDAgPyBUb25lLlN0YXRlLlN0YXJ0ZWQgOiBUb25lLlN0YXRlLlN0b3BwZWQ7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiBNdXRlIHRoZSBvdXRwdXQuIFxuXHRcdCAqIEBtZW1iZXJPZiBUb25lLk11bHRpUGxheWVyI1xuXHRcdCAqIEB0eXBlIHtib29sZWFufVxuXHRcdCAqIEBuYW1lIG11dGVcblx0XHQgKiBAZXhhbXBsZVxuXHRcdCAqIC8vbXV0ZSB0aGUgb3V0cHV0XG5cdFx0ICogc291cmNlLm11dGUgPSB0cnVlO1xuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuTXVsdGlQbGF5ZXIucHJvdG90eXBlLCAnbXV0ZScsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ZvbHVtZS5tdXRlO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAobXV0ZSkge1xuXHQgICAgICAgICAgICB0aGlzLl92b2x1bWUubXV0ZSA9IG11dGU7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgQ2xlYW4gdXAuXG5cdFx0ICogIEByZXR1cm4gIHtUb25lLk11bHRpUGxheWVyfSAgdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5NdWx0aVBsYXllci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLlNvdXJjZS5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIGZvciAodmFyIGJ1ZmZlck5hbWUgaW4gdGhpcy5fYWN0aXZlU291cmNlcykge1xuXHQgICAgICAgICAgICB0aGlzLl9hY3RpdmVTb3VyY2VzW2J1ZmZlck5hbWVdLmZvckVhY2goZnVuY3Rpb24gKHNvdXJjZSkge1xuXHQgICAgICAgICAgICAgICAgc291cmNlLmRpc3Bvc2UoKTtcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHRoaXMuYnVmZmVycy5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5idWZmZXJzID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9hY3RpdmVTb3VyY2VzID0gbnVsbDtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVG9uZS5NdWx0aVBsYXllcjtcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgLyoqXG5cdFx0ICogQGNsYXNzIFRvbmUuR3JhaW5QbGF5ZXIgaW1wbGVtZW50cyBbZ3JhbnVsYXIgc3ludGhlc2lzXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9HcmFudWxhcl9zeW50aGVzaXMpLlxuXHRcdCAqICAgICAgICBHcmFudWxhciBTeW50aGVzaXMgZW5hYmxlcyB5b3UgdG8gYWRqdXN0IHBpdGNoIGFuZCBwbGF5YmFjayByYXRlIGluZGVwZW5kZW50bHkuIFRoZSBncmFpblNpemUgaXMgdGhlXG5cdFx0ICogICAgICAgIGFtb3VudCBvZiB0aW1lIGVhY2ggc21hbGwgY2h1bmsgb2YgYXVkaW8gaXMgcGxheWVkIGZvciBhbmQgdGhlIG92ZXJsYXAgaXMgdGhlXG5cdFx0ICogICAgICAgIGFtb3VudCBvZiBjcm9zc2ZhZGluZyB0cmFuc2l0aW9uIHRpbWUgYmV0d2VlbiBzdWNjZXNzaXZlIGdyYWlucy5cblx0XHQgKiBAZXh0ZW5kcyB7VG9uZS5Tb3VyY2V9XG5cdFx0ICogQHBhcmFtIHtTdHJpbmd8VG9uZS5CdWZmZXJ9IHVybFx0VGhlIHVybCB0byBsb2FkLCBvciB0aGUgVG9uZS5CdWZmZXIgdG8gcGxheS5cblx0XHQgKiBAcGFyYW0ge0Z1bmN0aW9uPX0gY2FsbGJhY2sgVGhlIGNhbGxiYWNrIHRvIGludm9rZSBhZnRlciB0aGUgdXJsIGlzIGxvYWRlZC5cblx0XHQgKi9cblx0ICAgIFRvbmUuR3JhaW5QbGF5ZXIgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIG9wdGlvbnMgPSBUb25lLmRlZmF1bHRzKGFyZ3VtZW50cywgW1xuXHQgICAgICAgICAgICAndXJsJyxcblx0ICAgICAgICAgICAgJ29ubG9hZCdcblx0ICAgICAgICBdLCBUb25lLkdyYWluUGxheWVyKTtcblx0ICAgICAgICBUb25lLlNvdXJjZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBhdWRpbyBidWZmZXIgYmVsb25naW5nIHRvIHRoZSBwbGF5ZXIuXG5cdFx0XHQgKiAgQHR5cGUgIHtUb25lLkJ1ZmZlcn1cblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuYnVmZmVyID0gbmV3IFRvbmUuQnVmZmVyKG9wdGlvbnMudXJsLCBvcHRpb25zLm9ubG9hZCk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgQ3JlYXRlIGEgcmVwZWF0aW5nIHRpY2sgdG8gc2NoZWR1bGVcblx0XHRcdCAqICB0aGUgZ3JhaW5zLlxuXHRcdFx0ICogIEB0eXBlICB7VG9uZS5DbG9ja31cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fY2xvY2sgPSBuZXcgVG9uZS5DbG9jayh0aGlzLl90aWNrLmJpbmQodGhpcyksIG9wdGlvbnMuZ3JhaW5TaXplKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBAdHlwZSAge051bWJlcn1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fbG9vcFN0YXJ0ID0gMDtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBAdHlwZSAge051bWJlcn1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fbG9vcEVuZCA9IDA7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiBBbGwgb2YgdGhlIGN1cnJlbnRseSBwbGF5aW5nIEJ1ZmZlclNvdXJjZXNcblx0XHRcdCAqIEB0eXBlIHtBcnJheX1cblx0XHRcdCAqIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9hY3RpdmVTb3VyY2VzID0gW107XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgQHR5cGUgIHtOdW1iZXJ9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX3BsYXliYWNrUmF0ZSA9IG9wdGlvbnMucGxheWJhY2tSYXRlO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIEB0eXBlICB7TnVtYmVyfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9ncmFpblNpemUgPSBvcHRpb25zLmdyYWluU2l6ZTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICogIEB0eXBlIHtOdW1iZXJ9XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9vdmVybGFwID0gb3B0aW9ucy5vdmVybGFwO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIEFkanVzdCB0aGUgcGl0Y2ggaW5kZXBlbmRlbnRseSBvZiB0aGUgcGxheWJhY2tSYXRlLlxuXHRcdFx0ICogIEB0eXBlICB7Q2VudHN9XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmRldHVuZSA9IG9wdGlvbnMuZGV0dW5lO1xuXHQgICAgICAgIC8vc2V0dXBcblx0ICAgICAgICB0aGlzLm92ZXJsYXAgPSBvcHRpb25zLm92ZXJsYXA7XG5cdCAgICAgICAgdGhpcy5sb29wID0gb3B0aW9ucy5sb29wO1xuXHQgICAgICAgIHRoaXMucGxheWJhY2tSYXRlID0gb3B0aW9ucy5wbGF5YmFja1JhdGU7XG5cdCAgICAgICAgdGhpcy5ncmFpblNpemUgPSBvcHRpb25zLmdyYWluU2l6ZTtcblx0ICAgICAgICB0aGlzLmxvb3BTdGFydCA9IG9wdGlvbnMubG9vcFN0YXJ0O1xuXHQgICAgICAgIHRoaXMubG9vcEVuZCA9IG9wdGlvbnMubG9vcEVuZDtcblx0ICAgICAgICB0aGlzLnJldmVyc2UgPSBvcHRpb25zLnJldmVyc2U7XG5cdCAgICAgICAgdGhpcy5fY2xvY2sub24oJ3N0b3AnLCB0aGlzLl9vbnN0b3AuYmluZCh0aGlzKSk7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5HcmFpblBsYXllciwgVG9uZS5Tb3VyY2UpO1xuXHQgICAgLyoqXG5cdFx0ICogIHRoZSBkZWZhdWx0IHBhcmFtZXRlcnNcblx0XHQgKiAgQHN0YXRpY1xuXHRcdCAqICBAY29uc3Rcblx0XHQgKiAgQHR5cGUge09iamVjdH1cblx0XHQgKi9cblx0ICAgIFRvbmUuR3JhaW5QbGF5ZXIuZGVmYXVsdHMgPSB7XG5cdCAgICAgICAgJ29ubG9hZCc6IFRvbmUubm9PcCxcblx0ICAgICAgICAnb3ZlcmxhcCc6IDAuMSxcblx0ICAgICAgICAnZ3JhaW5TaXplJzogMC4yLFxuXHQgICAgICAgICdwbGF5YmFja1JhdGUnOiAxLFxuXHQgICAgICAgICdkZXR1bmUnOiAwLFxuXHQgICAgICAgICdsb29wJzogZmFsc2UsXG5cdCAgICAgICAgJ2xvb3BTdGFydCc6IDAsXG5cdCAgICAgICAgJ2xvb3BFbmQnOiAwLFxuXHQgICAgICAgICdyZXZlcnNlJzogZmFsc2Vcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgUGxheSB0aGUgYnVmZmVyIGF0IHRoZSBnaXZlbiBzdGFydFRpbWUuIE9wdGlvbmFsbHkgYWRkIGFuIG9mZnNldFxuXHRcdCAqICBhbmQvb3IgZHVyYXRpb24gd2hpY2ggd2lsbCBwbGF5IHRoZSBidWZmZXIgZnJvbSBhIHBvc2l0aW9uXG5cdFx0ICogIHdpdGhpbiB0aGUgYnVmZmVyIGZvciB0aGUgZ2l2ZW4gZHVyYXRpb24uXG5cdFx0ICpcblx0XHQgKiAgQHBhcmFtICB7VGltZX0gW3N0YXJ0VGltZT1ub3ddIFdoZW4gdGhlIHBsYXllciBzaG91bGQgc3RhcnQuXG5cdFx0ICogIEBwYXJhbSAge1RpbWV9IFtvZmZzZXQ9MF0gVGhlIG9mZnNldCBmcm9tIHRoZSBiZWdpbm5pbmcgb2YgdGhlIHNhbXBsZVxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG8gc3RhcnQgYXQuXG5cdFx0ICogIEBwYXJhbSAge1RpbWU9fSBkdXJhdGlvbiBIb3cgbG9uZyB0aGUgc2FtcGxlIHNob3VsZCBwbGF5LiBJZiBubyBkdXJhdGlvblxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpcyBnaXZlbiwgaXQgd2lsbCBkZWZhdWx0IHRvIHRoZSBmdWxsIGxlbmd0aFxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZiB0aGUgc2FtcGxlIChtaW51cyBhbnkgb2Zmc2V0KVxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5HcmFpblBsYXllcn0gdGhpc1xuXHRcdCAqICBAbWVtYmVyT2YgVG9uZS5HcmFpblBsYXllciNcblx0XHQgKiAgQG1ldGhvZCBzdGFydFxuXHRcdCAqICBAbmFtZSBzdGFydFxuXHRcdCAqL1xuXHQgICAgLyoqXG5cdFx0ICogIEludGVybmFsIHN0YXJ0IG1ldGhvZFxuXHRcdCAqICBAcGFyYW0ge1RpbWV9IHRpbWVcblx0XHQgKiAgQHBhcmFtIHtUaW1lfSBvZmZzZXRcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuR3JhaW5QbGF5ZXIucHJvdG90eXBlLl9zdGFydCA9IGZ1bmN0aW9uICh0aW1lLCBvZmZzZXQsIGR1cmF0aW9uKSB7XG5cdCAgICAgICAgb2Zmc2V0ID0gVG9uZS5kZWZhdWx0QXJnKG9mZnNldCwgMCk7XG5cdCAgICAgICAgb2Zmc2V0ID0gdGhpcy50b1NlY29uZHMob2Zmc2V0KTtcblx0ICAgICAgICB0aW1lID0gdGhpcy50b1NlY29uZHModGltZSk7XG5cdCAgICAgICAgdGhpcy5fb2Zmc2V0ID0gb2Zmc2V0O1xuXHQgICAgICAgIHRoaXMuX2Nsb2NrLnN0YXJ0KHRpbWUpO1xuXHQgICAgICAgIGlmIChkdXJhdGlvbikge1xuXHQgICAgICAgICAgICB0aGlzLnN0b3AodGltZSArIHRoaXMudG9TZWNvbmRzKGR1cmF0aW9uKSk7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBJbnRlcm5hbCBzdGFydCBtZXRob2Rcblx0XHQgKiAgQHBhcmFtIHtUaW1lfSB0aW1lXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLkdyYWluUGxheWVyLnByb3RvdHlwZS5fc3RvcCA9IGZ1bmN0aW9uICh0aW1lKSB7XG5cdCAgICAgICAgdGhpcy5fY2xvY2suc3RvcCh0aW1lKTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiBJbnZva2VkIHdoZW4gdGhlIGNsb2NrIGlzIHN0b3BwZWRcblx0XHQgKiBAcGFyYW0gIHtOdW1iZXJ9IHRpbWVcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5HcmFpblBsYXllci5wcm90b3R5cGUuX29uc3RvcCA9IGZ1bmN0aW9uICh0aW1lKSB7XG5cdCAgICAgICAgLy9zdG9wIHRoZSBwbGF5ZXJzXG5cdCAgICAgICAgdGhpcy5fYWN0aXZlU291cmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChzb3VyY2UpIHtcblx0ICAgICAgICAgICAgc291cmNlLnN0b3AodGltZSwgMCk7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIEludm9rZWQgb24gZWFjaCBjbG9jayB0aWNrLiBzY2hlZHVsZWQgYSBuZXdcblx0XHQgKiAgZ3JhaW4gYXQgdGhpcyB0aW1lLlxuXHRcdCAqICBAcGFyYW0gIHtUaW1lfSAgdGltZVxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5HcmFpblBsYXllci5wcm90b3R5cGUuX3RpY2sgPSBmdW5jdGlvbiAodGltZSkge1xuXHQgICAgICAgIHZhciBmYWRlSW4gPSB0aGlzLl9vZmZzZXQgPCB0aGlzLl9vdmVybGFwID8gMCA6IHRoaXMuX292ZXJsYXA7XG5cdCAgICAgICAgdmFyIHNvdXJjZSA9IG5ldyBUb25lLkJ1ZmZlclNvdXJjZSh7XG5cdCAgICAgICAgICAgICdidWZmZXInOiB0aGlzLmJ1ZmZlcixcblx0ICAgICAgICAgICAgJ2ZhZGVJbic6IGZhZGVJbixcblx0ICAgICAgICAgICAgJ2ZhZGVPdXQnOiB0aGlzLl9vdmVybGFwLFxuXHQgICAgICAgICAgICAnbG9vcCc6IHRoaXMubG9vcCxcblx0ICAgICAgICAgICAgJ2xvb3BTdGFydCc6IHRoaXMuX2xvb3BTdGFydCxcblx0ICAgICAgICAgICAgJ2xvb3BFbmQnOiB0aGlzLl9sb29wRW5kLFxuXHQgICAgICAgICAgICAncGxheWJhY2tSYXRlJzogVG9uZS5pbnRlcnZhbFRvRnJlcXVlbmN5UmF0aW8odGhpcy5kZXR1bmUgLyAxMDApXG5cdCAgICAgICAgfSkuY29ubmVjdCh0aGlzLm91dHB1dCk7XG5cdCAgICAgICAgc291cmNlLnN0YXJ0KHRpbWUsIHRoaXMuX29mZnNldCk7XG5cdCAgICAgICAgdGhpcy5fb2Zmc2V0ICs9IHRoaXMuZ3JhaW5TaXplO1xuXHQgICAgICAgIHNvdXJjZS5zdG9wKHRpbWUgKyB0aGlzLmdyYWluU2l6ZSk7XG5cdCAgICAgICAgLy9hZGQgaXQgdG8gdGhlIGFjdGl2ZSBzb3VyY2VzXG5cdCAgICAgICAgdGhpcy5fYWN0aXZlU291cmNlcy5wdXNoKHNvdXJjZSk7XG5cdCAgICAgICAgLy9yZW1vdmUgaXQgd2hlbiBpdCdzIGRvbmVcblx0ICAgICAgICBzb3VyY2Uub25lbmRlZCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5fYWN0aXZlU291cmNlcy5pbmRleE9mKHNvdXJjZSk7XG5cdCAgICAgICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX2FjdGl2ZVNvdXJjZXMuc3BsaWNlKGluZGV4LCAxKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0uYmluZCh0aGlzKTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgSnVtcCB0byBhIHNwZWNpZmljIHRpbWUgYW5kIHBsYXkgaXQuXG5cdFx0ICogIEBwYXJhbSAge1RpbWV9ICBvZmZzZXQgIFRoZSBvZmZzZXQgdG8ganVtcCB0by5cblx0XHQgKiAgQHBhcmFtIHtUaW1lPX0gdGltZSBXaGVuIHRvIG1ha2UgdGhlIGp1bXAuXG5cdFx0ICogIEByZXR1cm4gIHtUb25lLkdyYWluUGxheWVyfSAgdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5HcmFpblBsYXllci5wcm90b3R5cGUuc2VlayA9IGZ1bmN0aW9uIChvZmZzZXQsIHRpbWUpIHtcblx0ICAgICAgICB0aGlzLl9vZmZzZXQgPSB0aGlzLnRvU2Vjb25kcyhvZmZzZXQpO1xuXHQgICAgICAgIHRoaXMuX3RpY2sodGhpcy50b1NlY29uZHModGltZSkpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqIFRoZSBwbGF5YmFjayByYXRlIG9mIHRoZSBzYW1wbGVcblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5HcmFpblBsYXllciNcblx0XHQgKiBAdHlwZSB7UG9zaXRpdmV9XG5cdFx0ICogQG5hbWUgcGxheWJhY2tSYXRlXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5HcmFpblBsYXllci5wcm90b3R5cGUsICdwbGF5YmFja1JhdGUnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9wbGF5YmFja1JhdGU7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChyYXRlKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3BsYXliYWNrUmF0ZSA9IHJhdGU7XG5cdCAgICAgICAgICAgIHRoaXMuZ3JhaW5TaXplID0gdGhpcy5fZ3JhaW5TaXplO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogVGhlIGxvb3Agc3RhcnQgdGltZS5cblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5HcmFpblBsYXllciNcblx0XHQgKiBAdHlwZSB7VGltZX1cblx0XHQgKiBAbmFtZSBsb29wU3RhcnRcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkdyYWluUGxheWVyLnByb3RvdHlwZSwgJ2xvb3BTdGFydCcsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xvb3BTdGFydDtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKHRpbWUpIHtcblx0ICAgICAgICAgICAgdGhpcy5fbG9vcFN0YXJ0ID0gdGhpcy50b1NlY29uZHModGltZSk7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiBUaGUgbG9vcCBlbmQgdGltZS5cblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5HcmFpblBsYXllciNcblx0XHQgKiBAdHlwZSB7VGltZX1cblx0XHQgKiBAbmFtZSBsb29wRW5kXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5HcmFpblBsYXllci5wcm90b3R5cGUsICdsb29wRW5kJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fbG9vcEVuZDtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKHRpbWUpIHtcblx0ICAgICAgICAgICAgdGhpcy5fbG9vcEVuZCA9IHRoaXMudG9TZWNvbmRzKHRpbWUpO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogVGhlIGRpcmVjdGlvbiB0aGUgYnVmZmVyIHNob3VsZCBwbGF5IGluXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuR3JhaW5QbGF5ZXIjXG5cdFx0ICogQHR5cGUge2Jvb2xlYW59XG5cdFx0ICogQG5hbWUgcmV2ZXJzZVxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuR3JhaW5QbGF5ZXIucHJvdG90eXBlLCAncmV2ZXJzZScsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyLnJldmVyc2U7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChyZXYpIHtcblx0ICAgICAgICAgICAgdGhpcy5idWZmZXIucmV2ZXJzZSA9IHJldjtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqIFRoZSBzaXplIG9mIGVhY2ggY2h1bmsgb2YgYXVkaW8gdGhhdCB0aGVcblx0XHQgKiBidWZmZXIgaXMgY2hvcHBlZCBpbnRvIGFuZCBwbGF5ZWQgYmFjayBhdC5cblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5HcmFpblBsYXllciNcblx0XHQgKiBAdHlwZSB7VGltZX1cblx0XHQgKiBAbmFtZSBncmFpblNpemVcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkdyYWluUGxheWVyLnByb3RvdHlwZSwgJ2dyYWluU2l6ZScsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dyYWluU2l6ZTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKHNpemUpIHtcblx0ICAgICAgICAgICAgdGhpcy5fZ3JhaW5TaXplID0gdGhpcy50b1NlY29uZHMoc2l6ZSk7XG5cdCAgICAgICAgICAgIHRoaXMuX2Nsb2NrLmZyZXF1ZW5jeS52YWx1ZSA9IHRoaXMuX3BsYXliYWNrUmF0ZSAvIHRoaXMuX2dyYWluU2l6ZTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqIFRoaXMgaXMgdGhlIGR1cmF0aW9uIG9mIHRoZSBjcm9zcy1mYWRlIGJldHdlZW5cblx0XHQgKiBzdWNlc3NpdmUgZ3JhaW5zLlxuXHRcdCAqIEBtZW1iZXJPZiBUb25lLkdyYWluUGxheWVyI1xuXHRcdCAqIEB0eXBlIHtUaW1lfVxuXHRcdCAqIEBuYW1lIG92ZXJsYXBcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkdyYWluUGxheWVyLnByb3RvdHlwZSwgJ292ZXJsYXAnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9vdmVybGFwO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAodGltZSkge1xuXHQgICAgICAgICAgICB0aGlzLl9vdmVybGFwID0gdGhpcy50b1NlY29uZHModGltZSk7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiBDbGVhbiB1cFxuXHRcdCAqIEByZXR1cm4ge1RvbmUuR3JhaW5QbGF5ZXJ9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuR3JhaW5QbGF5ZXIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5Tb3VyY2UucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLmJ1ZmZlci5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5idWZmZXIgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX2Nsb2NrLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9jbG9jayA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fYWN0aXZlU291cmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChzb3VyY2UpIHtcblx0ICAgICAgICAgICAgc291cmNlLmRpc3Bvc2UoKTtcblx0ICAgICAgICB9KTtcblx0ICAgICAgICB0aGlzLl9hY3RpdmVTb3VyY2VzID0gbnVsbDtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVG9uZS5HcmFpblBsYXllcjtcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgXG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzICBUb25lLlBsYXllciBpcyBhbiBhdWRpbyBmaWxlIHBsYXllciB3aXRoIHN0YXJ0LCBsb29wLCBhbmQgc3RvcCBmdW5jdGlvbnMuXG5cdFx0ICogIFxuXHRcdCAqICBAY29uc3RydWN0b3Jcblx0XHQgKiAgQGV4dGVuZHMge1RvbmUuU291cmNlfSBcblx0XHQgKiAgQHBhcmFtIHtzdHJpbmd8QXVkaW9CdWZmZXJ9IHVybCBFaXRoZXIgdGhlIEF1ZGlvQnVmZmVyIG9yIHRoZSB1cmwgZnJvbVxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWNoIHRvIGxvYWQgdGhlIEF1ZGlvQnVmZmVyXG5cdFx0ICogIEBwYXJhbSB7ZnVuY3Rpb249fSBvbmxvYWQgVGhlIGZ1bmN0aW9uIHRvIGludm9rZSB3aGVuIHRoZSBidWZmZXIgaXMgbG9hZGVkLiBcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBSZWNvbW1lbmRlZCB0byB1c2UgVG9uZS5CdWZmZXIub24oJ2xvYWQnKSBpbnN0ZWFkLlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIHZhciBwbGF5ZXIgPSBuZXcgVG9uZS5QbGF5ZXIoXCIuL3BhdGgvdG8vc2FtcGxlLm1wM1wiKS50b01hc3RlcigpO1xuXHRcdCAqIC8vcGxheSBhcyBzb29uIGFzIHRoZSBidWZmZXIgaXMgbG9hZGVkXG5cdFx0ICogcGxheWVyLmF1dG9zdGFydCA9IHRydWU7XG5cdFx0ICovXG5cdCAgICBUb25lLlBsYXllciA9IGZ1bmN0aW9uICh1cmwpIHtcblx0ICAgICAgICB2YXIgb3B0aW9ucztcblx0ICAgICAgICBpZiAodXJsIGluc3RhbmNlb2YgVG9uZS5CdWZmZXIpIHtcblx0ICAgICAgICAgICAgdXJsID0gdXJsLmdldCgpO1xuXHQgICAgICAgICAgICBvcHRpb25zID0gVG9uZS5QbGF5ZXIuZGVmYXVsdHM7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgb3B0aW9ucyA9IFRvbmUuZGVmYXVsdHMoYXJndW1lbnRzLCBbXG5cdCAgICAgICAgICAgICAgICAndXJsJyxcblx0ICAgICAgICAgICAgICAgICdvbmxvYWQnXG5cdCAgICAgICAgICAgIF0sIFRvbmUuUGxheWVyKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgVG9uZS5Tb3VyY2UuY2FsbCh0aGlzLCBvcHRpb25zKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICogIEB0eXBlIHtBdWRpb0J1ZmZlclNvdXJjZU5vZGV9XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9zb3VyY2UgPSBudWxsO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIElmIHRoZSBmaWxlIHNob3VsZCBwbGF5IGFzIHNvb25cblx0XHRcdCAqICBhcyB0aGUgYnVmZmVyIGlzIGxvYWRlZC4gXG5cdFx0XHQgKiAgQHR5cGUge2Jvb2xlYW59XG5cdFx0XHQgKiAgQGV4YW1wbGVcblx0XHRcdCAqIC8vd2lsbCBwbGF5IGFzIHNvb24gYXMgaXQncyBsb2FkZWRcblx0XHRcdCAqIHZhciBwbGF5ZXIgPSBuZXcgVG9uZS5QbGF5ZXIoe1xuXHRcdFx0ICogXHRcInVybFwiIDogXCIuL3BhdGgvdG8vc2FtcGxlLm1wM1wiLFxuXHRcdFx0ICogXHRcImF1dG9zdGFydFwiIDogdHJ1ZSxcblx0XHRcdCAqIH0pLnRvTWFzdGVyKCk7XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmF1dG9zdGFydCA9IG9wdGlvbnMuYXV0b3N0YXJ0O1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHRoZSBidWZmZXJcblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICogIEB0eXBlIHtUb25lLkJ1ZmZlcn1cblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2J1ZmZlciA9IG5ldyBUb25lLkJ1ZmZlcih7XG5cdCAgICAgICAgICAgICd1cmwnOiBvcHRpb25zLnVybCxcblx0ICAgICAgICAgICAgJ29ubG9hZCc6IHRoaXMuX29ubG9hZC5iaW5kKHRoaXMsIG9wdGlvbnMub25sb2FkKSxcblx0ICAgICAgICAgICAgJ3JldmVyc2UnOiBvcHRpb25zLnJldmVyc2Vcblx0ICAgICAgICB9KTtcblx0ICAgICAgICBpZiAodXJsIGluc3RhbmNlb2YgQXVkaW9CdWZmZXIpIHtcblx0ICAgICAgICAgICAgdGhpcy5fYnVmZmVyLnNldCh1cmwpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICAvKipcblx0XHRcdCAqICBpZiB0aGUgYnVmZmVyIHNob3VsZCBsb29wIG9uY2UgaXQncyBvdmVyXG5cdFx0XHQgKiAgQHR5cGUge2Jvb2xlYW59XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2xvb3AgPSBvcHRpb25zLmxvb3A7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgaWYgJ2xvb3AnIGlzIHRydWUsIHRoZSBsb29wIHdpbGwgc3RhcnQgYXQgdGhpcyBwb3NpdGlvblxuXHRcdFx0ICogIEB0eXBlIHtUaW1lfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9sb29wU3RhcnQgPSBvcHRpb25zLmxvb3BTdGFydDtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBpZiAnbG9vcCcgaXMgdHJ1ZSwgdGhlIGxvb3Agd2lsbCBlbmQgYXQgdGhpcyBwb3NpdGlvblxuXHRcdFx0ICogIEB0eXBlIHtUaW1lfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9sb29wRW5kID0gb3B0aW9ucy5sb29wRW5kO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHRoZSBwbGF5YmFjayByYXRlXG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqICBAdHlwZSB7bnVtYmVyfVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fcGxheWJhY2tSYXRlID0gb3B0aW9ucy5wbGF5YmFja1JhdGU7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgRW5hYmxpbmcgcmV0cmlnZ2VyIHdpbGwgYWxsb3cgYSBwbGF5ZXIgdG8gYmUgcmVzdGFydGVkXG5cdFx0XHQgKiAgYmVmb3JlIHRoZSB0aGUgcHJldmlvdXMgJ3N0YXJ0JyBpcyBkb25lIHBsYXlpbmcuIE90aGVyd2lzZSwgXG5cdFx0XHQgKiAgc3VjY2Vzc2l2ZSBjYWxscyB0byBUb25lLlBsYXllci5zdGFydCB3aWxsIG9ubHkgc3RhcnRcblx0XHRcdCAqICB0aGUgc2FtcGxlIGlmIGl0IGhhZCBwbGF5ZWQgYWxsIHRoZSB3YXkgdGhyb3VnaC4gXG5cdFx0XHQgKiAgQHR5cGUge2Jvb2xlYW59XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLnJldHJpZ2dlciA9IG9wdGlvbnMucmV0cmlnZ2VyO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBmYWRlSW4gdGltZSBvZiB0aGUgYW1wbGl0dWRlIGVudmVsb3BlLlxuXHRcdFx0ICogIEB0eXBlIHtUaW1lfVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5mYWRlSW4gPSBvcHRpb25zLmZhZGVJbjtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgZmFkZU91dCB0aW1lIG9mIHRoZSBhbXBsaXR1ZGUgZW52ZWxvcGUuXG5cdFx0XHQgKiAgQHR5cGUge1RpbWV9XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmZhZGVPdXQgPSBvcHRpb25zLmZhZGVPdXQ7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5QbGF5ZXIsIFRvbmUuU291cmNlKTtcblx0ICAgIC8qKlxuXHRcdCAqICB0aGUgZGVmYXVsdCBwYXJhbWV0ZXJzXG5cdFx0ICogIEBzdGF0aWNcblx0XHQgKiAgQGNvbnN0XG5cdFx0ICogIEB0eXBlIHtPYmplY3R9XG5cdFx0ICovXG5cdCAgICBUb25lLlBsYXllci5kZWZhdWx0cyA9IHtcblx0ICAgICAgICAnb25sb2FkJzogVG9uZS5ub09wLFxuXHQgICAgICAgICdwbGF5YmFja1JhdGUnOiAxLFxuXHQgICAgICAgICdsb29wJzogZmFsc2UsXG5cdCAgICAgICAgJ2F1dG9zdGFydCc6IGZhbHNlLFxuXHQgICAgICAgICdsb29wU3RhcnQnOiAwLFxuXHQgICAgICAgICdsb29wRW5kJzogMCxcblx0ICAgICAgICAncmV0cmlnZ2VyJzogZmFsc2UsXG5cdCAgICAgICAgJ3JldmVyc2UnOiBmYWxzZSxcblx0ICAgICAgICAnZmFkZUluJzogMCxcblx0ICAgICAgICAnZmFkZU91dCc6IDBcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgTG9hZCB0aGUgYXVkaW8gZmlsZSBhcyBhbiBhdWRpbyBidWZmZXIuXG5cdFx0ICogIERlY29kZXMgdGhlIGF1ZGlvIGFzeW5jaHJvbm91c2x5IGFuZCBpbnZva2VzXG5cdFx0ICogIHRoZSBjYWxsYmFjayBvbmNlIHRoZSBhdWRpbyBidWZmZXIgbG9hZHMuIFxuXHRcdCAqICBOb3RlOiB0aGlzIGRvZXMgbm90IG5lZWQgdG8gYmUgY2FsbGVkIGlmIGEgdXJsXG5cdFx0ICogIHdhcyBwYXNzZWQgaW4gdG8gdGhlIGNvbnN0cnVjdG9yLiBPbmx5IHVzZSB0aGlzXG5cdFx0ICogIGlmIHlvdSB3YW50IHRvIG1hbnVhbGx5IGxvYWQgYSBuZXcgdXJsLiBcblx0XHQgKiBAcGFyYW0ge3N0cmluZ30gdXJsIFRoZSB1cmwgb2YgdGhlIGJ1ZmZlciB0byBsb2FkLlxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgRmlsZXR5cGUgc3VwcG9ydCBkZXBlbmRzIG9uIHRoZVxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgYnJvd3Nlci5cblx0XHQgKiAgQHBhcmFtICB7ZnVuY3Rpb249fSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdG8gaW52b2tlIG9uY2Vcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgc2FtcGxlIGlzIGxvYWRlZC5cblx0XHQgKiAgQHJldHVybnMge1Byb21pc2V9XG5cdFx0ICovXG5cdCAgICBUb25lLlBsYXllci5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uICh1cmwsIGNhbGxiYWNrKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuX2J1ZmZlci5sb2FkKHVybCwgdGhpcy5fb25sb2FkLmJpbmQodGhpcywgY2FsbGJhY2spKTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiBJbnRlcm5hbCBjYWxsYmFjayB3aGVuIHRoZSBidWZmZXIgaXMgbG9hZGVkLlxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLlBsYXllci5wcm90b3R5cGUuX29ubG9hZCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuXHQgICAgICAgIGNhbGxiYWNrID0gVG9uZS5kZWZhdWx0QXJnKGNhbGxiYWNrLCBUb25lLm5vT3ApO1xuXHQgICAgICAgIGNhbGxiYWNrKHRoaXMpO1xuXHQgICAgICAgIGlmICh0aGlzLmF1dG9zdGFydCkge1xuXHQgICAgICAgICAgICB0aGlzLnN0YXJ0KCk7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBQbGF5IHRoZSBidWZmZXIgYXQgdGhlIGdpdmVuIHN0YXJ0VGltZS4gT3B0aW9uYWxseSBhZGQgYW4gb2Zmc2V0XG5cdFx0ICogIGFuZC9vciBkdXJhdGlvbiB3aGljaCB3aWxsIHBsYXkgdGhlIGJ1ZmZlciBmcm9tIGEgcG9zaXRpb25cblx0XHQgKiAgd2l0aGluIHRoZSBidWZmZXIgZm9yIHRoZSBnaXZlbiBkdXJhdGlvbi4gXG5cdFx0ICogIFxuXHRcdCAqICBAcGFyYW0gIHtUaW1lfSBbc3RhcnRUaW1lPW5vd10gV2hlbiB0aGUgcGxheWVyIHNob3VsZCBzdGFydC5cblx0XHQgKiAgQHBhcmFtICB7VGltZX0gW29mZnNldD0wXSBUaGUgb2Zmc2V0IGZyb20gdGhlIGJlZ2lubmluZyBvZiB0aGUgc2FtcGxlXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0byBzdGFydCBhdC4gXG5cdFx0ICogIEBwYXJhbSAge1RpbWU9fSBkdXJhdGlvbiBIb3cgbG9uZyB0aGUgc2FtcGxlIHNob3VsZCBwbGF5LiBJZiBubyBkdXJhdGlvblxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpcyBnaXZlbiwgaXQgd2lsbCBkZWZhdWx0IHRvIHRoZSBmdWxsIGxlbmd0aCBcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2YgdGhlIHNhbXBsZSAobWludXMgYW55IG9mZnNldClcblx0XHQgKiAgQHJldHVybnMge1RvbmUuUGxheWVyfSB0aGlzXG5cdFx0ICogIEBtZW1iZXJPZiBUb25lLlBsYXllciNcblx0XHQgKiAgQG1ldGhvZCBzdGFydFxuXHRcdCAqICBAbmFtZSBzdGFydFxuXHRcdCAqL1xuXHQgICAgLyoqXG5cdFx0ICogIEludGVybmFsIHN0YXJ0IG1ldGhvZFxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5QbGF5ZXIucHJvdG90eXBlLl9zdGFydCA9IGZ1bmN0aW9uIChzdGFydFRpbWUsIG9mZnNldCwgZHVyYXRpb24pIHtcblx0ICAgICAgICAvL2lmIGl0J3MgYSBsb29wIHRoZSBkZWZhdWx0IG9mZnNldCBpcyB0aGUgbG9vcHN0YXJ0IHBvaW50XG5cdCAgICAgICAgaWYgKHRoaXMuX2xvb3ApIHtcblx0ICAgICAgICAgICAgb2Zmc2V0ID0gVG9uZS5kZWZhdWx0QXJnKG9mZnNldCwgdGhpcy5fbG9vcFN0YXJ0KTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAvL290aGVyd2lzZSB0aGUgZGVmYXVsdCBvZmZzZXQgaXMgMFxuXHQgICAgICAgICAgICBvZmZzZXQgPSBUb25lLmRlZmF1bHRBcmcob2Zmc2V0LCAwKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgLy9jb21wdXRlIHRoZSB2YWx1ZXMgaW4gc2Vjb25kc1xuXHQgICAgICAgIG9mZnNldCA9IHRoaXMudG9TZWNvbmRzKG9mZnNldCk7XG5cdCAgICAgICAgZHVyYXRpb24gPSBUb25lLmRlZmF1bHRBcmcoZHVyYXRpb24sIE1hdGgubWF4KHRoaXMuX2J1ZmZlci5kdXJhdGlvbiAtIG9mZnNldCwgMCkpO1xuXHQgICAgICAgIGR1cmF0aW9uID0gdGhpcy50b1NlY29uZHMoZHVyYXRpb24pO1xuXHQgICAgICAgIHN0YXJ0VGltZSA9IHRoaXMudG9TZWNvbmRzKHN0YXJ0VGltZSk7XG5cdCAgICAgICAgLy8gLy9tYWtlIHRoZSBzb3VyY2Vcblx0ICAgICAgICB0aGlzLl9zb3VyY2UgPSBuZXcgVG9uZS5CdWZmZXJTb3VyY2Uoe1xuXHQgICAgICAgICAgICAnYnVmZmVyJzogdGhpcy5fYnVmZmVyLFxuXHQgICAgICAgICAgICAnbG9vcCc6IHRoaXMuX2xvb3AsXG5cdCAgICAgICAgICAgICdsb29wU3RhcnQnOiB0aGlzLl9sb29wU3RhcnQsXG5cdCAgICAgICAgICAgICdsb29wRW5kJzogdGhpcy5fbG9vcEVuZCxcblx0ICAgICAgICAgICAgJ3BsYXliYWNrUmF0ZSc6IHRoaXMuX3BsYXliYWNrUmF0ZSxcblx0ICAgICAgICAgICAgJ2ZhZGVJbic6IHRoaXMuZmFkZUluLFxuXHQgICAgICAgICAgICAnZmFkZU91dCc6IHRoaXMuZmFkZU91dFxuXHQgICAgICAgIH0pLmNvbm5lY3QodGhpcy5vdXRwdXQpO1xuXHQgICAgICAgIC8vc2V0IHRoZSBsb29waW5nIHByb3BlcnRpZXNcblx0ICAgICAgICBpZiAoIXRoaXMuX2xvb3AgJiYgIXRoaXMuX3N5bmNlZCkge1xuXHQgICAgICAgICAgICAvL2lmIGl0J3Mgbm90IGxvb3BpbmcsIHNldCB0aGUgc3RhdGUgY2hhbmdlIGF0IHRoZSBlbmQgb2YgdGhlIHNhbXBsZVxuXHQgICAgICAgICAgICB0aGlzLl9zdGF0ZS5zZXRTdGF0ZUF0VGltZShUb25lLlN0YXRlLlN0b3BwZWQsIHN0YXJ0VGltZSArIGR1cmF0aW9uKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgLy9zdGFydCBpdFxuXHQgICAgICAgIGlmICh0aGlzLl9sb29wKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3NvdXJjZS5zdGFydChzdGFydFRpbWUsIG9mZnNldCk7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgdGhpcy5fc291cmNlLnN0YXJ0KHN0YXJ0VGltZSwgb2Zmc2V0LCBkdXJhdGlvbik7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBTdG9wIHBsYXliYWNrLlxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqICBAcGFyYW0gIHtUaW1lfSBbdGltZT1ub3ddXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLlBsYXllcn0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5QbGF5ZXIucHJvdG90eXBlLl9zdG9wID0gZnVuY3Rpb24gKHRpbWUpIHtcblx0ICAgICAgICBpZiAodGhpcy5fc291cmNlKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3NvdXJjZS5zdG9wKHRoaXMudG9TZWNvbmRzKHRpbWUpKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFNlZWsgdG8gYSBzcGVjaWZpYyB0aW1lIGluIHRoZSBwbGF5ZXIncyBidWZmZXIuIElmIHRoZSBcblx0XHQgKiAgc291cmNlIGlzIG5vIGxvbmdlciBwbGF5aW5nIGF0IHRoYXQgdGltZSwgaXQgd2lsbCBzdG9wLlxuXHRcdCAqICBJZiB5b3Ugc2VlayB0byBhIHRpbWUgdGhhdCBcblx0XHQgKiAgQHBhcmFtIHtUaW1lfSBvZmZzZXQgVGhlIHRpbWUgdG8gc2VlayB0by5cblx0XHQgKiAgQHBhcmFtIHtUaW1lPX0gdGltZSBUaGUgdGltZSBmb3IgdGhlIHNlZWsgZXZlbnQgdG8gb2NjdXIuXG5cdFx0ICogIEByZXR1cm4ge1RvbmUuUGxheWVyfSB0aGlzXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogc291cmNlLnN0YXJ0KDAuMik7XG5cdFx0ICogc291cmNlLnN0b3AoMC40KTtcblx0XHQgKi9cblx0ICAgIFRvbmUuUGxheWVyLnByb3RvdHlwZS5zZWVrID0gZnVuY3Rpb24gKG9mZnNldCwgdGltZSkge1xuXHQgICAgICAgIHRpbWUgPSB0aGlzLnRvU2Vjb25kcyh0aW1lKTtcblx0ICAgICAgICBpZiAodGhpcy5fc3RhdGUuZ2V0VmFsdWVBdFRpbWUodGltZSkgPT09IFRvbmUuU3RhdGUuU3RhcnRlZCkge1xuXHQgICAgICAgICAgICBvZmZzZXQgPSB0aGlzLnRvU2Vjb25kcyhvZmZzZXQpO1xuXHQgICAgICAgICAgICAvLyBpZiBpdCdzIGN1cnJlbnRseSBwbGF5aW5nLCBzdG9wIGl0XG5cdCAgICAgICAgICAgIHRoaXMuX3N0b3AodGltZSk7XG5cdCAgICAgICAgICAgIC8vcmVzdGFydCBpdCBhdCB0aGUgZ2l2ZW4gdGltZVxuXHQgICAgICAgICAgICB0aGlzLl9zdGFydCh0aW1lLCBvZmZzZXQpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgU2V0IHRoZSBsb29wIHN0YXJ0IGFuZCBlbmQuIFdpbGwgb25seSBsb29wIGlmIGxvb3AgaXMgXG5cdFx0ICogIHNldCB0byB0cnVlLiBcblx0XHQgKiAgQHBhcmFtIHtUaW1lfSBsb29wU3RhcnQgVGhlIGxvb3AgZW5kIHRpbWVcblx0XHQgKiAgQHBhcmFtIHtUaW1lfSBsb29wRW5kIFRoZSBsb29wIGVuZCB0aW1lXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLlBsYXllcn0gdGhpc1xuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIC8vbG9vcCAwLjEgc2Vjb25kcyBvZiB0aGUgZmlsZS4gXG5cdFx0ICogcGxheWVyLnNldExvb3BQb2ludHMoMC4yLCAwLjMpO1xuXHRcdCAqIHBsYXllci5sb29wID0gdHJ1ZTtcblx0XHQgKi9cblx0ICAgIFRvbmUuUGxheWVyLnByb3RvdHlwZS5zZXRMb29wUG9pbnRzID0gZnVuY3Rpb24gKGxvb3BTdGFydCwgbG9vcEVuZCkge1xuXHQgICAgICAgIHRoaXMubG9vcFN0YXJ0ID0gbG9vcFN0YXJ0O1xuXHQgICAgICAgIHRoaXMubG9vcEVuZCA9IGxvb3BFbmQ7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogSWYgbG9vcCBpcyB0cnVlLCB0aGUgbG9vcCB3aWxsIHN0YXJ0IGF0IHRoaXMgcG9zaXRpb24uIFxuXHRcdCAqIEBtZW1iZXJPZiBUb25lLlBsYXllciNcblx0XHQgKiBAdHlwZSB7VGltZX1cblx0XHQgKiBAbmFtZSBsb29wU3RhcnRcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLlBsYXllci5wcm90b3R5cGUsICdsb29wU3RhcnQnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9sb29wU3RhcnQ7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChsb29wU3RhcnQpIHtcblx0ICAgICAgICAgICAgdGhpcy5fbG9vcFN0YXJ0ID0gbG9vcFN0YXJ0O1xuXHQgICAgICAgICAgICBpZiAodGhpcy5fc291cmNlKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9zb3VyY2UubG9vcFN0YXJ0ID0gdGhpcy50b1NlY29uZHMobG9vcFN0YXJ0KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogSWYgbG9vcCBpcyB0cnVlLCB0aGUgbG9vcCB3aWxsIGVuZCBhdCB0aGlzIHBvc2l0aW9uLlxuXHRcdCAqIEBtZW1iZXJPZiBUb25lLlBsYXllciNcblx0XHQgKiBAdHlwZSB7VGltZX1cblx0XHQgKiBAbmFtZSBsb29wRW5kXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5QbGF5ZXIucHJvdG90eXBlLCAnbG9vcEVuZCcsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xvb3BFbmQ7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChsb29wRW5kKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2xvb3BFbmQgPSBsb29wRW5kO1xuXHQgICAgICAgICAgICBpZiAodGhpcy5fc291cmNlKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9zb3VyY2UubG9vcEVuZCA9IHRoaXMudG9TZWNvbmRzKGxvb3BFbmQpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiBUaGUgYXVkaW8gYnVmZmVyIGJlbG9uZ2luZyB0byB0aGUgcGxheWVyLiBcblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5QbGF5ZXIjXG5cdFx0ICogQHR5cGUge1RvbmUuQnVmZmVyfVxuXHRcdCAqIEBuYW1lIGJ1ZmZlclxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuUGxheWVyLnByb3RvdHlwZSwgJ2J1ZmZlcicsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2J1ZmZlcjtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKGJ1ZmZlcikge1xuXHQgICAgICAgICAgICB0aGlzLl9idWZmZXIuc2V0KGJ1ZmZlcik7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiBJZiB0aGUgYnVmZmVyIHNob3VsZCBsb29wIG9uY2UgaXQncyBvdmVyLiBcblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5QbGF5ZXIjXG5cdFx0ICogQHR5cGUge2Jvb2xlYW59XG5cdFx0ICogQG5hbWUgbG9vcFxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuUGxheWVyLnByb3RvdHlwZSwgJ2xvb3AnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9sb29wO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAobG9vcCkge1xuXHQgICAgICAgICAgICB0aGlzLl9sb29wID0gbG9vcDtcblx0ICAgICAgICAgICAgaWYgKHRoaXMuX3NvdXJjZSkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fc291cmNlLmxvb3AgPSBsb29wO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiBUaGUgcGxheWJhY2sgc3BlZWQuIDEgaXMgbm9ybWFsIHNwZWVkLiBUaGlzIGlzIG5vdCBhIHNpZ25hbCBiZWNhdXNlXG5cdFx0ICogU2FmYXJpIGFuZCBpT1MgY3VycmVudGx5IGRvbid0IHN1cHBvcnQgcGxheWJhY2tSYXRlIGFzIGEgc2lnbmFsLlxuXHRcdCAqIEBtZW1iZXJPZiBUb25lLlBsYXllciNcblx0XHQgKiBAdHlwZSB7bnVtYmVyfVxuXHRcdCAqIEBuYW1lIHBsYXliYWNrUmF0ZVxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuUGxheWVyLnByb3RvdHlwZSwgJ3BsYXliYWNrUmF0ZScsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BsYXliYWNrUmF0ZTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKHJhdGUpIHtcblx0ICAgICAgICAgICAgdGhpcy5fcGxheWJhY2tSYXRlID0gcmF0ZTtcblx0ICAgICAgICAgICAgaWYgKHRoaXMuX3NvdXJjZSkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fc291cmNlLnBsYXliYWNrUmF0ZS52YWx1ZSA9IHJhdGU7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqIFRoZSBkaXJlY3Rpb24gdGhlIGJ1ZmZlciBzaG91bGQgcGxheSBpblxuXHRcdCAqIEBtZW1iZXJPZiBUb25lLlBsYXllciNcblx0XHQgKiBAdHlwZSB7Ym9vbGVhbn1cblx0XHQgKiBAbmFtZSByZXZlcnNlXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5QbGF5ZXIucHJvdG90eXBlLCAncmV2ZXJzZScsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2J1ZmZlci5yZXZlcnNlO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAocmV2KSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2J1ZmZlci5yZXZlcnNlID0gcmV2O1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogSWYgYWxsIHRoZSBidWZmZXIgaXMgbG9hZGVkXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuUGxheWVyI1xuXHRcdCAqIEB0eXBlIHtCb29sZWFufVxuXHRcdCAqIEBuYW1lIGxvYWRlZFxuXHRcdCAqIEByZWFkT25seVxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuUGxheWVyLnByb3RvdHlwZSwgJ2xvYWRlZCcsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2J1ZmZlci5sb2FkZWQ7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgRGlzcG9zZSBhbmQgZGlzY29ubmVjdC5cblx0XHQgKiAgQHJldHVybiB7VG9uZS5QbGF5ZXJ9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuUGxheWVyLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuU291cmNlLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgaWYgKHRoaXMuX3NvdXJjZSAhPT0gbnVsbCkge1xuXHQgICAgICAgICAgICB0aGlzLl9zb3VyY2UuZGlzY29ubmVjdCgpO1xuXHQgICAgICAgICAgICB0aGlzLl9zb3VyY2UgPSBudWxsO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB0aGlzLl9idWZmZXIuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX2J1ZmZlciA9IG51bGw7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuUGxheWVyO1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgIFRvbmUuUGxheWVycyBjb21iaW5lcyBtdWx0aXBsZSBbVG9uZS5QbGF5ZXJdKFBsYXllcikgb2JqZWN0cy5cblx0XHQgKlxuXHRcdCAqICBAY29uc3RydWN0b3Jcblx0XHQgKiAgQGV4dGVuZHMge1RvbmUuQXVkaW9Ob2RlfVxuXHRcdCAqICBAcGFyYW0ge09iamVjdH0gdXJscyBBbiBvYmplY3QgbWFwcGluZyBhIG5hbWUgdG8gYSB1cmwuXG5cdFx0ICogIEBwYXJhbSB7ZnVuY3Rpb249fSBvbmxvYWQgVGhlIGZ1bmN0aW9uIHRvIGludm9rZSB3aGVuIHRoZSBidWZmZXIgaXMgbG9hZGVkLlxuXHRcdCAqL1xuXHQgICAgVG9uZS5QbGF5ZXJzID0gZnVuY3Rpb24gKHVybHMpIHtcblx0ICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG5cdCAgICAgICAgYXJncy5zaGlmdCgpO1xuXHQgICAgICAgIHZhciBvcHRpb25zID0gVG9uZS5kZWZhdWx0cyhhcmdzLCBbJ29ubG9hZCddLCBUb25lLlBsYXllcnMpO1xuXHQgICAgICAgIFRvbmUuY2FsbCh0aGlzKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgb3V0cHV0IHZvbHVtZSBub2RlXG5cdFx0XHQgKiAgQHR5cGUgIHtUb25lLlZvbHVtZX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fdm9sdW1lID0gdGhpcy5vdXRwdXQgPSBuZXcgVG9uZS5Wb2x1bWUob3B0aW9ucy52b2x1bWUpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogVGhlIHZvbHVtZSBvZiB0aGUgb3V0cHV0IGluIGRlY2liZWxzLlxuXHRcdFx0ICogQHR5cGUge0RlY2liZWxzfVxuXHRcdFx0ICogQHNpZ25hbFxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIHNvdXJjZS52b2x1bWUudmFsdWUgPSAtNjtcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMudm9sdW1lID0gdGhpcy5fdm9sdW1lLnZvbHVtZTtcblx0ICAgICAgICB0aGlzLl9yZWFkT25seSgndm9sdW1lJyk7XG5cdCAgICAgICAgLy9tYWtlIHRoZSBvdXRwdXQgZXhwbGljaXRseSBzdGVyZW9cblx0ICAgICAgICB0aGlzLl92b2x1bWUub3V0cHV0Lm91dHB1dC5jaGFubmVsQ291bnQgPSAyO1xuXHQgICAgICAgIHRoaXMuX3ZvbHVtZS5vdXRwdXQub3V0cHV0LmNoYW5uZWxDb3VudE1vZGUgPSAnZXhwbGljaXQnO1xuXHQgICAgICAgIC8vbXV0ZSBpbml0aWFsbHlcblx0ICAgICAgICB0aGlzLm11dGUgPSBvcHRpb25zLm11dGU7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiBUaGUgY29udGFpbmVyIG9mIGFsbCBvZiB0aGUgcGxheWVyc1xuXHRcdFx0ICogQHR5cGUge09iamVjdH1cblx0XHRcdCAqIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9wbGF5ZXJzID0ge307XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiBUaGUgbG9hZGluZyBjb3VudFxuXHRcdFx0ICogQHR5cGUge051bWJlcn1cblx0XHRcdCAqIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9sb2FkaW5nQ291bnQgPSAwO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogcHJpdmF0ZSBob2xkZXIgb2YgdGhlIGZhZGVJbiB0aW1lXG5cdFx0XHQgKiBAdHlwZSB7VGltZX1cblx0XHRcdCAqIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9mYWRlSW4gPSBvcHRpb25zLmZhZGVJbjtcblx0ICAgICAgICAvKipcblx0XHRcdCAqIHByaXZhdGUgaG9sZGVyIG9mIHRoZSBmYWRlT3V0IHRpbWVcblx0XHRcdCAqIEB0eXBlIHtUaW1lfVxuXHRcdFx0ICogQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2ZhZGVPdXQgPSBvcHRpb25zLmZhZGVPdXQ7XG5cdCAgICAgICAgLy9hZGQgYWxsIG9mIHRoZSBwbGF5ZXJzXG5cdCAgICAgICAgZm9yICh2YXIgbmFtZSBpbiB1cmxzKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2xvYWRpbmdDb3VudCsrO1xuXHQgICAgICAgICAgICB0aGlzLmFkZChuYW1lLCB1cmxzW25hbWVdLCB0aGlzLl9idWZmZXJMb2FkZWQuYmluZCh0aGlzLCBvcHRpb25zLm9ubG9hZCkpO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLlBsYXllcnMsIFRvbmUuQXVkaW9Ob2RlKTtcblx0ICAgIC8qKlxuXHRcdCAqIFRoZSBkZWZhdWx0IHZhbHVlc1xuXHRcdCAqIEB0eXBlIHtPYmplY3R9XG5cdFx0ICovXG5cdCAgICBUb25lLlBsYXllcnMuZGVmYXVsdHMgPSB7XG5cdCAgICAgICAgJ3ZvbHVtZSc6IDAsXG5cdCAgICAgICAgJ211dGUnOiBmYWxzZSxcblx0ICAgICAgICAnb25sb2FkJzogVG9uZS5ub09wLFxuXHQgICAgICAgICdmYWRlSW4nOiAwLFxuXHQgICAgICAgICdmYWRlT3V0JzogMFxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBBIGJ1ZmZlciB3YXMgbG9hZGVkLiBkZWNyZW1lbnQgdGhlIGNvdW50ZXIuXG5cdFx0ICogIEBwYXJhbSAge0Z1bmN0aW9ufSAgY2FsbGJhY2tcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuUGxheWVycy5wcm90b3R5cGUuX2J1ZmZlckxvYWRlZCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuXHQgICAgICAgIHRoaXMuX2xvYWRpbmdDb3VudC0tO1xuXHQgICAgICAgIGlmICh0aGlzLl9sb2FkaW5nQ291bnQgPT09IDAgJiYgY2FsbGJhY2spIHtcblx0ICAgICAgICAgICAgY2FsbGJhY2sodGhpcyk7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqIE11dGUgdGhlIG91dHB1dC5cblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5Tb3VyY2UjXG5cdFx0ICogQHR5cGUge2Jvb2xlYW59XG5cdFx0ICogQG5hbWUgbXV0ZVxuXHRcdCAqIEBleGFtcGxlXG5cdFx0ICogLy9tdXRlIHRoZSBvdXRwdXRcblx0XHQgKiBzb3VyY2UubXV0ZSA9IHRydWU7XG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5QbGF5ZXJzLnByb3RvdHlwZSwgJ211dGUnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl92b2x1bWUubXV0ZTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKG11dGUpIHtcblx0ICAgICAgICAgICAgdGhpcy5fdm9sdW1lLm11dGUgPSBtdXRlO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogVGhlIGZhZGVJbiB0aW1lIG9mIHRoZSBhbXBsaXR1ZGUgZW52ZWxvcGUuXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuU291cmNlI1xuXHRcdCAqIEB0eXBlIHtUaW1lfVxuXHRcdCAqIEBuYW1lIGZhZGVJblxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuUGxheWVycy5wcm90b3R5cGUsICdmYWRlSW4nLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9mYWRlSW47XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChmYWRlSW4pIHtcblx0ICAgICAgICAgICAgdGhpcy5fZmFkZUluID0gZmFkZUluO1xuXHQgICAgICAgICAgICB0aGlzLl9mb3JFYWNoKGZ1bmN0aW9uIChwbGF5ZXIpIHtcblx0ICAgICAgICAgICAgICAgIHBsYXllci5mYWRlSW4gPSBmYWRlSW47XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogVGhlIGZhZGVPdXQgdGltZSBvZiB0aGUgYW1wbGl0dWRlIGVudmVsb3BlLlxuXHRcdCAqIEBtZW1iZXJPZiBUb25lLlNvdXJjZSNcblx0XHQgKiBAdHlwZSB7VGltZX1cblx0XHQgKiBAbmFtZSBmYWRlT3V0XG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5QbGF5ZXJzLnByb3RvdHlwZSwgJ2ZhZGVPdXQnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9mYWRlT3V0O1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAoZmFkZU91dCkge1xuXHQgICAgICAgICAgICB0aGlzLl9mYWRlT3V0ID0gZmFkZU91dDtcblx0ICAgICAgICAgICAgdGhpcy5fZm9yRWFjaChmdW5jdGlvbiAocGxheWVyKSB7XG5cdCAgICAgICAgICAgICAgICBwbGF5ZXIuZmFkZU91dCA9IGZhZGVPdXQ7XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogVGhlIHN0YXRlIG9mIHRoZSBwbGF5ZXJzIG9iamVjdC4gUmV0dXJucyBcInN0YXJ0ZWRcIiBpZiBhbnkgb2YgdGhlIHBsYXllcnMgYXJlIHBsYXlpbmcuXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuUGxheWVycyNcblx0XHQgKiBAdHlwZSB7U3RyaW5nfVxuXHRcdCAqIEBuYW1lIHN0YXRlXG5cdFx0ICogQHJlYWRPbmx5XG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5QbGF5ZXJzLnByb3RvdHlwZSwgJ3N0YXRlJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgcGxheWluZyA9IGZhbHNlO1xuXHQgICAgICAgICAgICB0aGlzLl9mb3JFYWNoKGZ1bmN0aW9uIChwbGF5ZXIpIHtcblx0ICAgICAgICAgICAgICAgIHBsYXlpbmcgPSBwbGF5aW5nIHx8IHBsYXllci5zdGF0ZSA9PT0gVG9uZS5TdGF0ZS5TdGFydGVkO1xuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgcmV0dXJuIHBsYXlpbmcgPyBUb25lLlN0YXRlLlN0YXJ0ZWQgOiBUb25lLlN0YXRlLlN0b3BwZWQ7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgVHJ1ZSBpZiB0aGUgYnVmZmVycyBvYmplY3QgaGFzIGEgYnVmZmVyIGJ5IHRoYXQgbmFtZS5cblx0XHQgKiAgQHBhcmFtICB7U3RyaW5nfE51bWJlcn0gIG5hbWUgIFRoZSBrZXkgb3IgaW5kZXggb2YgdGhlXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIuXG5cdFx0ICogIEByZXR1cm4gIHtCb29sZWFufVxuXHRcdCAqL1xuXHQgICAgVG9uZS5QbGF5ZXJzLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiAobmFtZSkge1xuXHQgICAgICAgIHJldHVybiB0aGlzLl9wbGF5ZXJzLmhhc093blByb3BlcnR5KG5hbWUpO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBHZXQgYSBwbGF5ZXIgYnkgbmFtZS5cblx0XHQgKiAgQHBhcmFtICB7U3RyaW5nfSAgbmFtZSAgVGhlIHBsYXllcnMgbmFtZSBhcyBkZWZpbmVkIGluXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSBjb25zdHJ1Y3RvciBvYmplY3Qgb3IgYGFkZGAgbWV0aG9kLlxuXHRcdCAqICBAcmV0dXJuICB7VG9uZS5QbGF5ZXJ9XG5cdFx0ICovXG5cdCAgICBUb25lLlBsYXllcnMucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChuYW1lKSB7XG5cdCAgICAgICAgaWYgKHRoaXMuaGFzKG5hbWUpKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9wbGF5ZXJzW25hbWVdO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVG9uZS5QbGF5ZXJzOiBubyBwbGF5ZXIgbmFtZWQgJyArIG5hbWUpO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiBJdGVyYXRlIG92ZXIgYWxsIG9mIHRoZSBwbGF5ZXJzXG5cdFx0ICogQHBhcmFtICB7RnVuY3Rpb259IGNhbGxiYWNrXG5cdFx0ICogQHJldHVybiB7VG9uZS5QbGF5ZXJzfSAgICAgICAgICAgIHRoaXNcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5QbGF5ZXJzLnByb3RvdHlwZS5fZm9yRWFjaCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuXHQgICAgICAgIGZvciAodmFyIHBsYXllck5hbWUgaW4gdGhpcy5fcGxheWVycykge1xuXHQgICAgICAgICAgICBjYWxsYmFjayh0aGlzLl9wbGF5ZXJzW3BsYXllck5hbWVdLCBwbGF5ZXJOYW1lKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogSWYgYWxsIHRoZSBidWZmZXJzIGFyZSBsb2FkZWQgb3Igbm90XG5cdFx0ICogQG1lbWJlck9mIFRvbmUuUGxheWVycyNcblx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0XHQgKiBAbmFtZSBsb2FkZWRcblx0XHQgKiBAcmVhZE9ubHlcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLlBsYXllcnMucHJvdG90eXBlLCAnbG9hZGVkJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgaXNMb2FkZWQgPSB0cnVlO1xuXHQgICAgICAgICAgICB0aGlzLl9mb3JFYWNoKGZ1bmN0aW9uIChwbGF5ZXIpIHtcblx0ICAgICAgICAgICAgICAgIGlzTG9hZGVkID0gaXNMb2FkZWQgJiYgcGxheWVyLmxvYWRlZDtcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIHJldHVybiBpc0xvYWRlZDtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBBZGQgYSBwbGF5ZXIgYnkgbmFtZSBhbmQgdXJsIHRvIHRoZSBQbGF5ZXJzXG5cdFx0ICogIEBwYXJhbSAge1N0cmluZ30gICAgbmFtZSAgICAgIEEgdW5pcXVlIG5hbWUgdG8gZ2l2ZSB0aGUgcGxheWVyXG5cdFx0ICogIEBwYXJhbSAge1N0cmluZ3xUb25lLkJ1ZmZlcnxBdWRpb2J1ZmZlcn0gIHVybCAgRWl0aGVyIHRoZSB1cmwgb2YgdGhlIGJ1ZmVyLFxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yIGEgYnVmZmVyIHdoaWNoIHdpbGwgYmUgYWRkZWRcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aXRoIHRoZSBnaXZlbiBuYW1lLlxuXHRcdCAqICBAcGFyYW0gIHtGdW5jdGlvbj19ICBjYWxsYmFjayAgVGhlIGNhbGxiYWNrIHRvIGludm9rZVxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hlbiB0aGUgdXJsIGlzIGxvYWRlZC5cblx0XHQgKi9cblx0ICAgIFRvbmUuUGxheWVycy5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKG5hbWUsIHVybCwgY2FsbGJhY2spIHtcblx0ICAgICAgICB0aGlzLl9wbGF5ZXJzW25hbWVdID0gbmV3IFRvbmUuUGxheWVyKHVybCwgY2FsbGJhY2spLmNvbm5lY3QodGhpcy5vdXRwdXQpO1xuXHQgICAgICAgIHRoaXMuX3BsYXllcnNbbmFtZV0uZmFkZUluID0gdGhpcy5fZmFkZUluO1xuXHQgICAgICAgIHRoaXMuX3BsYXllcnNbbmFtZV0uZmFkZU91dCA9IHRoaXMuX2ZhZGVPdXQ7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogU3RvcCBhbGwgb2YgdGhlIHBsYXllcnMgYXQgdGhlIGdpdmVuIHRpbWVcblx0XHQgKiBAcGFyYW0ge1RpbWV9IHRpbWUgVGhlIHRpbWUgdG8gc3RvcCBhbGwgb2YgdGhlIHBsYXllcnMuXG5cdFx0ICogQHJldHVybiB7VG9uZS5QbGF5ZXJzfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLlBsYXllcnMucHJvdG90eXBlLnN0b3BBbGwgPSBmdW5jdGlvbiAodGltZSkge1xuXHQgICAgICAgIHRoaXMuX2ZvckVhY2goZnVuY3Rpb24gKHBsYXllcikge1xuXHQgICAgICAgICAgICBwbGF5ZXIuc3RvcCh0aW1lKTtcblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgRGlzcG9zZSBhbmQgZGlzY29ubmVjdC5cblx0XHQgKiAgQHJldHVybiB7VG9uZS5QbGF5ZXJzfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLlBsYXllcnMucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5BdWRpb05vZGUucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLl92b2x1bWUuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX3ZvbHVtZSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fd3JpdGFibGUoJ3ZvbHVtZScpO1xuXHQgICAgICAgIHRoaXMudm9sdW1lID0gbnVsbDtcblx0ICAgICAgICB0aGlzLm91dHB1dCA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fZm9yRWFjaChmdW5jdGlvbiAocGxheWVyKSB7XG5cdCAgICAgICAgICAgIHBsYXllci5kaXNwb3NlKCk7XG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgdGhpcy5fcGxheWVycyA9IG51bGw7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuUGxheWVycztcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgXG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzICBUb25lLlVzZXJNZWRpYSB1c2VzIE1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEgdG8gb3BlbiB1cFxuXHRcdCAqICAgICAgICAgIGFuZCBleHRlcm5hbCBtaWNyb3Bob25lIG9yIGF1ZGlvIGlucHV0LiBDaGVja1xuXHRcdCAqICAgICAgICAgIFtNZWRpYURldmljZXMgQVBJIFN1cHBvcnRdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9NZWRpYURldmljZXMvZ2V0VXNlck1lZGlhKVxuXHRcdCAqICAgICAgICAgIHRvIHNlZSB3aGljaCBicm93c2VycyBhcmUgc3VwcG9ydGVkLiBBY2Nlc3MgdG8gYW4gZXh0ZXJuYWwgaW5wdXRcblx0XHQgKiAgICAgICAgICBpcyBsaW1pdGVkIHRvIHNlY3VyZSAoSFRUUFMpIGNvbm5lY3Rpb25zLlxuXHRcdCAqXG5cdFx0ICogIEBjb25zdHJ1Y3RvclxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZS5BdWRpb05vZGV9XG5cdFx0ICogIEBwYXJhbSB7RGVjaWJlbHM9fSB2b2x1bWUgVGhlIGxldmVsIG9mIHRoZSBpbnB1dFxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIC8vbGlzdCB0aGUgaW5wdXRzIGFuZCBvcGVuIHRoZSB0aGlyZCBvbmVcblx0XHQgKiB2YXIgbW90dSA9IG5ldyBUb25lLlVzZXJNZWRpYSgpO1xuXHRcdCAqXG5cdFx0ICogLy9vcGVuaW5nIHRoZSBpbnB1dCBhc2tzIHRoZSB1c2VyIHRvIGFjdGl2YXRlIHRoZWlyIG1pY1xuXHRcdCAqIG1vdHUub3BlbigpLnRoZW4oZnVuY3Rpb24oKXtcblx0XHQgKiBcdC8vb3BlbmluZyBpcyBhY3RpdmF0ZXMgdGhlIG1pY3JvcGhvbmVcblx0XHQgKiBcdC8vc3RhcnRpbmcgbGV0cyBhdWRpbyB0aHJvdWdoXG5cdFx0ICogXHRtb3R1LnN0YXJ0KDEwKTtcblx0XHQgKiB9KTtcblx0XHQgKi9cblx0ICAgIFRvbmUuVXNlck1lZGlhID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBvcHRpb25zID0gVG9uZS5kZWZhdWx0cyhhcmd1bWVudHMsIFsndm9sdW1lJ10sIFRvbmUuVXNlck1lZGlhKTtcblx0ICAgICAgICBUb25lLkF1ZGlvTm9kZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBNZWRpYVN0cmVhbU5vZGVcblx0XHRcdCAqICBAdHlwZSB7TWVkaWFTdHJlYW1BdWRpb1NvdXJjZU5vZGV9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX21lZGlhU3RyZWFtID0gbnVsbDtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgbWVkaWEgc3RyZWFtIGNyZWF0ZWQgYnkgZ2V0VXNlck1lZGlhLlxuXHRcdFx0ICogIEB0eXBlIHtMb2NhbE1lZGlhU3RyZWFtfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9zdHJlYW0gPSBudWxsO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBvcGVuIGRldmljZVxuXHRcdFx0ICogIEB0eXBlICB7TWVkaWFEZXZpY2VJbmZvfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9kZXZpY2UgPSBudWxsO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBvdXRwdXQgdm9sdW1lIG5vZGVcblx0XHRcdCAqICBAdHlwZSAge1RvbmUuVm9sdW1lfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl92b2x1bWUgPSB0aGlzLm91dHB1dCA9IG5ldyBUb25lLlZvbHVtZShvcHRpb25zLnZvbHVtZSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiBUaGUgdm9sdW1lIG9mIHRoZSBvdXRwdXQgaW4gZGVjaWJlbHMuXG5cdFx0XHQgKiBAdHlwZSB7RGVjaWJlbHN9XG5cdFx0XHQgKiBAc2lnbmFsXG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICogaW5wdXQudm9sdW1lLnZhbHVlID0gLTY7XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLnZvbHVtZSA9IHRoaXMuX3ZvbHVtZS52b2x1bWU7XG5cdCAgICAgICAgdGhpcy5fcmVhZE9ubHkoJ3ZvbHVtZScpO1xuXHQgICAgICAgIHRoaXMubXV0ZSA9IG9wdGlvbnMubXV0ZTtcblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLlVzZXJNZWRpYSwgVG9uZS5BdWRpb05vZGUpO1xuXHQgICAgLyoqXG5cdFx0ICogdGhlIGRlZmF1bHQgcGFyYW1ldGVyc1xuXHRcdCAqIEB0eXBlIHtPYmplY3R9XG5cdFx0ICovXG5cdCAgICBUb25lLlVzZXJNZWRpYS5kZWZhdWx0cyA9IHtcblx0ICAgICAgICAndm9sdW1lJzogMCxcblx0ICAgICAgICAnbXV0ZSc6IGZhbHNlXG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIE9wZW4gdGhlIG1lZGlhIHN0cmVhbS4gSWYgYSBzdHJpbmcgaXMgcGFzc2VkIGluLCBpdCBpcyBhc3N1bWVkXG5cdFx0ICogIHRvIGJlIHRoZSBsYWJlbCBvciBpZCBvZiB0aGUgc3RyZWFtLCBpZiBhIG51bWJlciBpcyBwYXNzZWQgaW4sXG5cdFx0ICogIGl0IGlzIHRoZSBpbnB1dCBudW1iZXIgb2YgdGhlIHN0cmVhbS5cblx0XHQgKiAgQHBhcmFtICB7U3RyaW5nfE51bWJlcn0gW2xhYmVsT3JJZD1cImRlZmF1bHRcIl0gVGhlIGxhYmVsIG9yIGlkIG9mIHRoZSBhdWRpbyBpbnB1dCBtZWRpYSBkZXZpY2UuXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBXaXRoIG5vIGFyZ3VtZW50LCB0aGUgZGVmYXVsdCBzdHJlYW0gaXMgb3BlbmVkLlxuXHRcdCAqICBAcmV0dXJuIHtQcm9taXNlfSBUaGUgcHJvbWlzZSBpcyByZXNvbHZlZCB3aGVuIHRoZSBzdHJlYW0gaXMgb3Blbi5cblx0XHQgKi9cblx0ICAgIFRvbmUuVXNlck1lZGlhLnByb3RvdHlwZS5vcGVuID0gZnVuY3Rpb24gKGxhYmVsT3JJZCkge1xuXHQgICAgICAgIGxhYmVsT3JJZCA9IFRvbmUuZGVmYXVsdEFyZyhsYWJlbE9ySWQsICdkZWZhdWx0Jyk7XG5cdCAgICAgICAgcmV0dXJuIFRvbmUuVXNlck1lZGlhLmVudW1lcmF0ZURldmljZXMoKS50aGVuKGZ1bmN0aW9uIChkZXZpY2VzKSB7XG5cdCAgICAgICAgICAgIHZhciBkZXZpY2U7XG5cdCAgICAgICAgICAgIGlmIChUb25lLmlzTnVtYmVyKGxhYmVsT3JJZCkpIHtcblx0ICAgICAgICAgICAgICAgIGRldmljZSA9IGRldmljZXNbbGFiZWxPcklkXTtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIGRldmljZSA9IGRldmljZXMuZmluZChmdW5jdGlvbiAoZGV2aWNlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRldmljZS5sYWJlbCA9PT0gbGFiZWxPcklkIHx8IGRldmljZS5kZXZpY2VJZCA9PT0gbGFiZWxPcklkO1xuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAvL2RpZG4ndCBmaW5kIGEgbWF0Y2hpbmcgZGV2aWNlXG5cdCAgICAgICAgICAgICAgICBpZiAoIWRldmljZSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVG9uZS5Vc2VyTWVkaWE6IG5vIG1hdGNoaW5nIGRldmljZTogJyArIGxhYmVsT3JJZCk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdGhpcy5fZGV2aWNlID0gZGV2aWNlO1xuXHQgICAgICAgICAgICAvL2RvIGdldFVzZXJNZWRpYVxuXHQgICAgICAgICAgICB2YXIgY29uc3RyYWludHMgPSB7XG5cdCAgICAgICAgICAgICAgICBhdWRpbzoge1xuXHQgICAgICAgICAgICAgICAgICAgICdkZXZpY2VJZCc6IGRldmljZS5kZXZpY2VJZCxcblx0ICAgICAgICAgICAgICAgICAgICAnZWNob0NhbmNlbGxhdGlvbic6IGZhbHNlLFxuXHQgICAgICAgICAgICAgICAgICAgICdzYW1wbGVSYXRlJzogdGhpcy5jb250ZXh0LnNhbXBsZVJhdGVcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgcmV0dXJuIG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKGNvbnN0cmFpbnRzKS50aGVuKGZ1bmN0aW9uIChzdHJlYW0pIHtcblx0ICAgICAgICAgICAgICAgIC8vc3RhcnQgYSBuZXcgc291cmNlIG9ubHkgaWYgdGhlIHByZXZpb3VzIG9uZSBpcyBjbG9zZWRcblx0ICAgICAgICAgICAgICAgIGlmICghdGhpcy5fc3RyZWFtKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RyZWFtID0gc3RyZWFtO1xuXHQgICAgICAgICAgICAgICAgICAgIC8vV3JhcCBhIE1lZGlhU3RyZWFtU291cmNlTm9kZSBhcm91bmQgdGhlIGxpdmUgaW5wdXQgc3RyZWFtLlxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuX21lZGlhU3RyZWFtID0gdGhpcy5jb250ZXh0LmNyZWF0ZU1lZGlhU3RyZWFtU291cmNlKHN0cmVhbSk7XG5cdCAgICAgICAgICAgICAgICAgICAgLy9Db25uZWN0IHRoZSBNZWRpYVN0cmVhbVNvdXJjZU5vZGUgdG8gYSBnYXRlIGdhaW4gbm9kZVxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuX21lZGlhU3RyZWFtLmNvbm5lY3QodGhpcy5vdXRwdXQpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XG5cdCAgICAgICAgfS5iaW5kKHRoaXMpKTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgQ2xvc2UgdGhlIG1lZGlhIHN0cmVhbVxuXHRcdCAqICBAcmV0dXJuIHtUb25lLlVzZXJNZWRpYX0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5Vc2VyTWVkaWEucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIGlmICh0aGlzLl9zdHJlYW0pIHtcblx0ICAgICAgICAgICAgdGhpcy5fc3RyZWFtLmdldEF1ZGlvVHJhY2tzKCkuZm9yRWFjaChmdW5jdGlvbiAodHJhY2spIHtcblx0ICAgICAgICAgICAgICAgIHRyYWNrLnN0b3AoKTtcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIHRoaXMuX3N0cmVhbSA9IG51bGw7XG5cdCAgICAgICAgICAgIC8vcmVtb3ZlIHRoZSBvbGQgbWVkaWEgc3RyZWFtXG5cdCAgICAgICAgICAgIHRoaXMuX21lZGlhU3RyZWFtLmRpc2Nvbm5lY3QoKTtcblx0ICAgICAgICAgICAgdGhpcy5fbWVkaWFTdHJlYW0gPSBudWxsO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB0aGlzLl9kZXZpY2UgPSBudWxsO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBSZXR1cm5zIGEgcHJvbWlzZSB3aGljaCByZXNvbHZlcyB3aXRoIHRoZSBsaXN0IG9mIGF1ZGlvIGlucHV0IGRldmljZXMgYXZhaWxhYmxlLlxuXHRcdCAqICBAcmV0dXJuIHtQcm9taXNlfSBUaGUgcHJvbWlzZSB0aGF0IGlzIHJlc29sdmVkIHdpdGggdGhlIGRldmljZXNcblx0XHQgKiAgQHN0YXRpY1xuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIFRvbmUuVXNlck1lZGlhLmVudW1lcmF0ZURldmljZXMoKS50aGVuKGZ1bmN0aW9uKGRldmljZXMpe1xuXHRcdCAqIFx0Y29uc29sZS5sb2coZGV2aWNlcylcblx0XHQgKiB9KVxuXHRcdCAqL1xuXHQgICAgVG9uZS5Vc2VyTWVkaWEuZW51bWVyYXRlRGV2aWNlcyA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICByZXR1cm4gbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5lbnVtZXJhdGVEZXZpY2VzKCkudGhlbihmdW5jdGlvbiAoZGV2aWNlcykge1xuXHQgICAgICAgICAgICByZXR1cm4gZGV2aWNlcy5maWx0ZXIoZnVuY3Rpb24gKGRldmljZSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGRldmljZS5raW5kID09PSAnYXVkaW9pbnB1dCc7XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH0pO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBSZXR1cm5zIHRoZSBwbGF5YmFjayBzdGF0ZSBvZiB0aGUgc291cmNlLCBcInN0YXJ0ZWRcIiB3aGVuIHRoZSBtaWNyb3Bob25lIGlzIG9wZW5cblx0XHQgKiAgYW5kIFwic3RvcHBlZFwiIHdoZW4gdGhlIG1pYyBpcyBjbG9zZWQuXG5cdFx0ICogIEB0eXBlIHtUb25lLlN0YXRlfVxuXHRcdCAqICBAcmVhZE9ubHlcblx0XHQgKiAgQG1lbWJlck9mIFRvbmUuVXNlck1lZGlhI1xuXHRcdCAqICBAbmFtZSBzdGF0ZVxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuVXNlck1lZGlhLnByb3RvdHlwZSwgJ3N0YXRlJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fc3RyZWFtICYmIHRoaXMuX3N0cmVhbS5hY3RpdmUgPyBUb25lLlN0YXRlLlN0YXJ0ZWQgOiBUb25lLlN0YXRlLlN0b3BwZWQ7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiBcdFJldHVybnMgYW4gaWRlbnRpZmllciBmb3IgdGhlIHJlcHJlc2VudGVkIGRldmljZSB0aGF0IGlzXG5cdFx0ICogXHRwZXJzaXN0ZWQgYWNyb3NzIHNlc3Npb25zLiBJdCBpcyB1bi1ndWVzc2FibGUgYnkgb3RoZXIgYXBwbGljYXRpb25zIGFuZFxuXHRcdCAqIFx0dW5pcXVlIHRvIHRoZSBvcmlnaW4gb2YgdGhlIGNhbGxpbmcgYXBwbGljYXRpb24uIEl0IGlzIHJlc2V0IHdoZW4gdGhlXG5cdFx0ICogXHR1c2VyIGNsZWFycyBjb29raWVzIChmb3IgUHJpdmF0ZSBCcm93c2luZywgYSBkaWZmZXJlbnQgaWRlbnRpZmllciBpc1xuXHRcdCAqIFx0dXNlZCB0aGF0IGlzIG5vdCBwZXJzaXN0ZWQgYWNyb3NzIHNlc3Npb25zKS4gUmV0dXJucyB1bmRlZmluZWQgd2hlbiB0aGVcblx0XHQgKiBcdGRldmljZSBpcyBub3Qgb3Blbi5cblx0XHQgKiAgQHR5cGUge1N0cmluZ31cblx0XHQgKiAgQHJlYWRPbmx5XG5cdFx0ICogIEBtZW1iZXJPZiBUb25lLlVzZXJNZWRpYSNcblx0XHQgKiAgQG5hbWUgZGV2aWNlSWRcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLlVzZXJNZWRpYS5wcm90b3R5cGUsICdkZXZpY2VJZCcsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgaWYgKHRoaXMuX2RldmljZSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RldmljZS5kZXZpY2VJZDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogXHRSZXR1cm5zIGEgZ3JvdXAgaWRlbnRpZmllci4gVHdvIGRldmljZXMgaGF2ZSB0aGVcblx0XHQgKiBcdHNhbWUgZ3JvdXAgaWRlbnRpZmllciBpZiB0aGV5IGJlbG9uZyB0byB0aGUgc2FtZSBwaHlzaWNhbCBkZXZpY2UuXG5cdFx0ICogXHRSZXR1cm5zIHVuZGVmaW5lZCB3aGVuIHRoZSBkZXZpY2UgaXMgbm90IG9wZW4uXG5cdFx0ICogIEB0eXBlIHtTdHJpbmd9XG5cdFx0ICogIEByZWFkT25seVxuXHRcdCAqICBAbWVtYmVyT2YgVG9uZS5Vc2VyTWVkaWEjXG5cdFx0ICogIEBuYW1lIGdyb3VwSWRcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLlVzZXJNZWRpYS5wcm90b3R5cGUsICdncm91cElkJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICBpZiAodGhpcy5fZGV2aWNlKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZGV2aWNlLmdyb3VwSWQ7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqIFx0UmV0dXJucyBhIGxhYmVsIGRlc2NyaWJpbmcgdGhpcyBkZXZpY2UgKGZvciBleGFtcGxlIFwiQnVpbHQtaW4gTWljcm9waG9uZVwiKS5cblx0XHQgKiBcdFJldHVybnMgdW5kZWZpbmVkIHdoZW4gdGhlIGRldmljZSBpcyBub3Qgb3BlbiBvciBsYWJlbCBpcyBub3QgYXZhaWxhYmxlXG5cdFx0ICogXHRiZWNhdXNlIG9mIHBlcm1pc3Npb25zLlxuXHRcdCAqICBAdHlwZSB7U3RyaW5nfVxuXHRcdCAqICBAcmVhZE9ubHlcblx0XHQgKiAgQG1lbWJlck9mIFRvbmUuVXNlck1lZGlhI1xuXHRcdCAqICBAbmFtZSBncm91cElkXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5Vc2VyTWVkaWEucHJvdG90eXBlLCAnbGFiZWwnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIGlmICh0aGlzLl9kZXZpY2UpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9kZXZpY2UubGFiZWw7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqIE11dGUgdGhlIG91dHB1dC5cblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5Vc2VyTWVkaWEjXG5cdFx0ICogQHR5cGUge2Jvb2xlYW59XG5cdFx0ICogQG5hbWUgbXV0ZVxuXHRcdCAqIEBleGFtcGxlXG5cdFx0ICogLy9tdXRlIHRoZSBvdXRwdXRcblx0XHQgKiB1c2VyTWVkaWEubXV0ZSA9IHRydWU7XG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5Vc2VyTWVkaWEucHJvdG90eXBlLCAnbXV0ZScsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ZvbHVtZS5tdXRlO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAobXV0ZSkge1xuXHQgICAgICAgICAgICB0aGlzLl92b2x1bWUubXV0ZSA9IG11dGU7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiBDbGVhbiB1cC5cblx0XHQgKiBAcmV0dXJuIHtUb25lLlVzZXJNZWRpYX0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5Vc2VyTWVkaWEucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5BdWRpb05vZGUucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLmNsb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fd3JpdGFibGUoJ3ZvbHVtZScpO1xuXHQgICAgICAgIHRoaXMuX3ZvbHVtZS5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fdm9sdW1lID0gbnVsbDtcblx0ICAgICAgICB0aGlzLnZvbHVtZSA9IG51bGw7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIElmIGdldFVzZXJNZWRpYSBpcyBzdXBwb3J0ZWQgYnkgdGhlIGJyb3dzZXIuXG5cdFx0ICogIEB0eXBlICB7Qm9vbGVhbn1cblx0XHQgKiAgQG1lbWJlck9mIFRvbmUuVXNlck1lZGlhI1xuXHRcdCAqICBAbmFtZSBzdXBwb3J0ZWRcblx0XHQgKiAgQHN0YXRpY1xuXHRcdCAqICBAcmVhZE9ubHlcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLlVzZXJNZWRpYSwgJ3N1cHBvcnRlZCcsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuICFUb25lLmlzVW5kZWYobmF2aWdhdG9yLm1lZGlhRGV2aWNlcykgJiYgVG9uZS5pc0Z1bmN0aW9uKG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIHJldHVybiBUb25lLlVzZXJNZWRpYTtcblx0fSk7XG5cdFxuXHRyZXR1cm4gVG9uZTtcbn0pKTsiLCIvKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cbmNvbnN0IG9mZnNldHMgPSBbMCwgMC41LCAxLCAxLjUsIDIsIDMsIDMuNSwgNCwgNC41LCA1LCA1LjUsIDZdO1xuXG5jb25zdCBtaW5Ob3RlID0gMjE7XG5jb25zdCBtYXhOb3RlID0gMTA4O1xuXG5leHBvcnQgY2xhc3MgS2V5Ym9hcmRFbGVtZW50IHtcbiAgcHJpdmF0ZSBjb250YWluZXI6IEVsZW1lbnQ7XG4gIHByaXZhdGUga2V5czoge1trZXk6IG51bWJlcl06IEVsZW1lbnR9O1xuICBwcml2YXRlIG5vdGVzOiB7W2tleTogbnVtYmVyXTogTm90ZVtdfTtcblxuICBjb25zdHJ1Y3Rvcihjb250YWluZXI6IEVsZW1lbnQpIHtcbiAgICB0aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICB0aGlzLmtleXMgPSB7fTtcblxuICAgIHRoaXMucmVzaXplKCk7XG4gICAgdGhpcy5ub3RlcyA9IHt9O1xuICB9XG5cbiAgcmVzaXplKCkge1xuICAgIC8vIGNsZWFyIHRoZSBwcmV2aW91cyBvbmVzLlxuICAgIHRoaXMua2V5cyA9IHt9O1xuICAgIHRoaXMuY29udGFpbmVyLmlubmVySFRNTCA9ICcnO1xuXG4gICAgLy8gZWFjaCBvZiB0aGUga2V5cy5cbiAgICBjb25zdCBrZXlXaWR0aCA9IDEgLyA1MjtcblxuICAgIGZvciAobGV0IGkgPSBtaW5Ob3RlOyBpIDw9IG1heE5vdGU7IGkrKykge1xuICAgICAgY29uc3Qga2V5ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBrZXkuY2xhc3NMaXN0LmFkZCgna2V5Jyk7XG4gICAgICBjb25zdCBpc1NoYXJwID0gKFsxLCAzLCA2LCA4LCAxMF0uaW5kZXhPZihpICUgMTIpICE9PSAtMSk7XG4gICAgICBrZXkuY2xhc3NMaXN0LmFkZChpc1NoYXJwID8gJ2JsYWNrJyA6ICd3aGl0ZScpO1xuICAgICAgdGhpcy5jb250YWluZXIuYXBwZW5kQ2hpbGQoa2V5KTtcbiAgICAgIC8vIHBvc2l0aW9uIHRoZSBlbGVtZW50XG5cbiAgICAgIGNvbnN0IG5vdGVPY3RhdmUgPSBNYXRoLmZsb29yKGkgLyAxMikgLSBNYXRoLmZsb29yKG1pbk5vdGUgLyAxMik7XG4gICAgICBjb25zdCBvZmZzZXQgPSBvZmZzZXRzW2kgJSAxMl0gKyBub3RlT2N0YXZlICogNyAtIDU7XG4gICAgICBrZXkuc3R5bGUud2lkdGggPSBgJHtrZXlXaWR0aCAqIDEwMH0lYDtcbiAgICAgIGtleS5zdHlsZS5sZWZ0ID0gYCR7b2Zmc2V0ICoga2V5V2lkdGggKiAxMDB9JWA7XG4gICAgICBrZXkuaWQgPSBpLnRvU3RyaW5nKCk7XG5cbiAgICAgIGNvbnN0IGZpbGwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIGZpbGwuY2xhc3NMaXN0LmFkZCgnZmlsbCcpO1xuICAgICAga2V5LmFwcGVuZENoaWxkKGZpbGwpO1xuICAgICAgdGhpcy5rZXlzW2ldID0ga2V5O1xuICAgIH1cbiAgfVxuXG4gIGtleURvd24obm90ZU51bTogbnVtYmVyKSB7XG4gICAgaWYgKG5vdGVOdW0gaW4gdGhpcy5rZXlzKSB7XG4gICAgICBjb25zdCBrZXkgPSB0aGlzLmtleXNbbm90ZU51bV07XG5cbiAgICAgIGNvbnN0IG5vdGUgPSBuZXcgTm90ZShrZXkucXVlcnlTZWxlY3RvcignLmZpbGwnKSk7XG4gICAgICBpZiAoIXRoaXMubm90ZXNbbm90ZU51bV0pIHtcbiAgICAgICAgdGhpcy5ub3Rlc1tub3RlTnVtXSA9IFtdIGFzIE5vdGVbXTtcbiAgICAgIH1cbiAgICAgIHRoaXMubm90ZXNbbm90ZU51bV0ucHVzaChub3RlKTtcbiAgICB9XG4gIH1cblxuICBrZXlVcChub3RlTnVtOiBudW1iZXIpIHtcbiAgICBpZiAobm90ZU51bSBpbiB0aGlzLmtleXMpIHtcbiAgICAgIGlmICghKHRoaXMubm90ZXNbbm90ZU51bV0gJiYgdGhpcy5ub3Rlc1tub3RlTnVtXS5sZW5ndGgpKSB7XG4gICAgICAgIGNvbnNvbGUud2Fybignbm90ZSBvZmYgYmVmb3JlIG5vdGUgb24nKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubm90ZXNbbm90ZU51bV0uc2hpZnQoKS5ub3RlT2ZmKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmNsYXNzIE5vdGUge1xuICBwcml2YXRlIGVsZW1lbnQ6IEVsZW1lbnQ7XG5cbiAgY29uc3RydWN0b3IoZWxlbWVudDogRWxlbWVudCkge1xuICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5hZGQoJ2FjdGl2ZScpO1xuICB9XG5cbiAgbm90ZU9mZigpIHtcbiAgICB0aGlzLmVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZSgnYWN0aXZlJyk7XG4gIH1cbn1cbiIsIi8qIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm1heC1saW5lLWxlbmd0aFxuaW1wb3J0IHtBcnJheTFELCBBcnJheTJELCBDaGVja3BvaW50TG9hZGVyLCBOREFycmF5LCBOREFycmF5TWF0aEdQVSwgU2NhbGFyfSBmcm9tICdkZWVwbGVhcm4nO1xuaW1wb3J0ICogYXMgZGVtb191dGlsIGZyb20gJy4uL3V0aWwnO1xuXG5pbXBvcnQge0tleWJvYXJkRWxlbWVudH0gZnJvbSAnLi9rZXlib2FyZF9lbGVtZW50JztcblxuLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLXJlcXVpcmUtaW1wb3J0c1xuY29uc3QgUGlhbm8gPSByZXF1aXJlKCd0b25lLXBpYW5vJykuUGlhbm87XG5cbmxldCBsc3RtS2VybmVsMTogQXJyYXkyRDtcbmxldCBsc3RtQmlhczE6IEFycmF5MUQ7XG5sZXQgbHN0bUtlcm5lbDI6IEFycmF5MkQ7XG5sZXQgbHN0bUJpYXMyOiBBcnJheTFEO1xubGV0IGxzdG1LZXJuZWwzOiBBcnJheTJEO1xubGV0IGxzdG1CaWFzMzogQXJyYXkxRDtcbmxldCBjOiBBcnJheTJEW107XG5sZXQgaDogQXJyYXkyRFtdO1xubGV0IGZ1bGx5Q29ubmVjdGVkQmlhc2VzOiBBcnJheTFEO1xubGV0IGZ1bGx5Q29ubmVjdGVkV2VpZ2h0czogQXJyYXkyRDtcbmNvbnN0IGZvcmdldEJpYXMgPSBTY2FsYXIubmV3KDEuMCk7XG5jb25zdCBhY3RpdmVOb3RlcyA9IG5ldyBNYXA8bnVtYmVyLCBudW1iZXI+KCk7XG5cbi8vIEhvdyBtYW55IHN0ZXBzIHRvIGdlbmVyYXRlIHBlciBnZW5lcmF0ZVN0ZXAgY2FsbC5cbi8vIEdlbmVyYXRpbmcgbW9yZSBzdGVwcyBtYWtlcyBpdCBsZXNzIGxpa2VseSB0aGF0IHdlJ2xsIGxhZyBiZWhpbmQgaW4gbm90ZVxuLy8gZ2VuZXJhdGlvbi4gR2VuZXJhdGluZyBmZXdlciBzdGVwcyBtYWtlcyBpdCBsZXNzIGxpa2VseSB0aGF0IHRoZSBicm93c2VyIFVJXG4vLyB0aHJlYWQgd2lsbCBiZSBzdGFydmVkIGZvciBjeWNsZXMuXG5jb25zdCBTVEVQU19QRVJfR0VORVJBVEVfQ0FMTCA9IDEwO1xuLy8gSG93IG11Y2ggdGltZSB0byB0cnkgdG8gZ2VuZXJhdGUgYWhlYWQuIE1vcmUgdGltZSBtZWFucyBmZXdlciBidWZmZXJcbi8vIHVuZGVycnVucywgYnV0IGFsc28gbWFrZXMgdGhlIGxhZyBmcm9tIFVJIGNoYW5nZSB0byBvdXRwdXQgbGFyZ2VyLlxuY29uc3QgR0VORVJBVElPTl9CVUZGRVJfU0VDT05EUyA9IC41O1xuLy8gSWYgd2UncmUgdGhpcyBmYXIgYmVoaW5kLCByZXNldCBjdXJyZW50VGltZSB0aW1lIHRvIHBpYW5vLm5vdygpLlxuY29uc3QgTUFYX0dFTkVSQVRJT05fTEFHX1NFQ09ORFMgPSAxO1xuLy8gSWYgYSBub3RlIGlzIGhlbGQgbG9uZ2VyIHRoYW4gdGhpcywgcmVsZWFzZSBpdC5cbmNvbnN0IE1BWF9OT1RFX0RVUkFUSU9OX1NFQ09ORFMgPSAzO1xuXG5jb25zdCBOT1RFU19QRVJfT0NUQVZFID0gMTI7XG5jb25zdCBERU5TSVRZX0JJTl9SQU5HRVMgPSBbMS4wLCAyLjAsIDQuMCwgOC4wLCAxNi4wLCAzMi4wLCA2NC4wXTtcbmNvbnN0IFBJVENIX0hJU1RPR1JBTV9TSVpFID0gTk9URVNfUEVSX09DVEFWRTtcblxubGV0IHBpdGNoSGlzdG9ncmFtRW5jb2Rpbmc6IEFycmF5MUQ7XG5sZXQgbm90ZURlbnNpdHlFbmNvZGluZzogQXJyYXkxRDtcbmxldCBjb25kaXRpb25pbmdPZmYgPSB0cnVlO1xuXG5sZXQgY3VycmVudFBpYW5vVGltZVNlYyA9IDA7XG4vLyBXaGVuIHRoZSBwaWFubyByb2xsIHN0YXJ0cyBpbiBicm93c2VyLXRpbWUgdmlhIHBlcmZvcm1hbmNlLm5vdygpLlxubGV0IHBpYW5vU3RhcnRUaW1lc3RhbXBNcyA9IDA7XG5cbmxldCBjdXJyZW50VmVsb2NpdHkgPSAxMDA7XG5cbmNvbnN0IE1JTl9NSURJX1BJVENIID0gMDtcbmNvbnN0IE1BWF9NSURJX1BJVENIID0gMTI3O1xuY29uc3QgVkVMT0NJVFlfQklOUyA9IDMyO1xuY29uc3QgTUFYX1NISUZUX1NURVBTID0gMTAwO1xuY29uc3QgU1RFUFNfUEVSX1NFQ09ORCA9IDEwMDtcblxuY29uc3QgTUlESV9FVkVOVF9PTiA9IDB4OTA7XG5jb25zdCBNSURJX0VWRU5UX09GRiA9IDB4ODA7XG5jb25zdCBNSURJX05PX09VVFBVVF9ERVZJQ0VTX0ZPVU5EX01FU1NBR0UgPSAnTm8gbWlkaSBvdXRwdXQgZGV2aWNlcyBmb3VuZC4nO1xuXG4vLyBUaGUgdW5pcXVlIGlkIG9mIHRoZSBjdXJyZW50bHkgc2NoZWR1bGVkIHNldFRpbWVvdXQgbG9vcC5cbmxldCBjdXJyZW50TG9vcElkID0gMDtcblxuY29uc3QgRVZFTlRfUkFOR0VTID0gW1xuICBbJ25vdGVfb24nLCBNSU5fTUlESV9QSVRDSCwgTUFYX01JRElfUElUQ0hdLFxuICBbJ25vdGVfb2ZmJywgTUlOX01JRElfUElUQ0gsIE1BWF9NSURJX1BJVENIXSxcbiAgWyd0aW1lX3NoaWZ0JywgMSwgTUFYX1NISUZUX1NURVBTXSxcbiAgWyd2ZWxvY2l0eV9jaGFuZ2UnLCAxLCBWRUxPQ0lUWV9CSU5TXSxcbl07XG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZUV2ZW50U2l6ZSgpOiBudW1iZXIge1xuICBsZXQgZXZlbnRPZmZzZXQgPSAwO1xuICBmb3IgKGNvbnN0IGV2ZW50UmFuZ2Ugb2YgRVZFTlRfUkFOR0VTKSB7XG4gICAgY29uc3QgbWluVmFsdWUgPSBldmVudFJhbmdlWzFdIGFzIG51bWJlcjtcbiAgICBjb25zdCBtYXhWYWx1ZSA9IGV2ZW50UmFuZ2VbMl0gYXMgbnVtYmVyO1xuICAgIGV2ZW50T2Zmc2V0ICs9IG1heFZhbHVlIC0gbWluVmFsdWUgKyAxO1xuICB9XG4gIHJldHVybiBldmVudE9mZnNldDtcbn1cblxuY29uc3QgRVZFTlRfU0laRSA9IGNhbGN1bGF0ZUV2ZW50U2l6ZSgpO1xuY29uc3QgUFJJTUVSX0lEWCA9IDM1NTsgIC8vIHNoaWZ0IDFzLlxubGV0IGxhc3RTYW1wbGUgPSBTY2FsYXIubmV3KFBSSU1FUl9JRFgpO1xuXG5jb25zdCBjb250YWluZXIgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcja2V5Ym9hcmQnKTtcbmNvbnN0IGtleWJvYXJkSW50ZXJmYWNlID0gbmV3IEtleWJvYXJkRWxlbWVudChjb250YWluZXIpO1xuXG5jb25zdCBwaWFubyA9IG5ldyBQaWFubyh7dmVsb2NpdGllczogNH0pLnRvTWFzdGVyKCk7XG5cbmNvbnN0IFNBTEFNQU5ERVJfVVJMID0gJ2h0dHBzOi8vc3RvcmFnZS5nb29nbGVhcGlzLmNvbS9sZWFybmpzLWRhdGEvJyArXG4gICAgJ1BpYW5vL1NhbGFtYW5kZXIvJztcbmNvbnN0IENIRUNLUE9JTlRfVVJMID0gJy4nO1xuXG5jb25zdCBpc0RldmljZVN1cHBvcnRlZCA9IGRlbW9fdXRpbC5pc1dlYkdMU3VwcG9ydGVkKCkgJiYgIWRlbW9fdXRpbC5pc1NhZmFyaSgpO1xuXG5pZiAoIWlzRGV2aWNlU3VwcG9ydGVkKSB7XG4gIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNzdGF0dXMnKS5pbm5lckhUTUwgPVxuICAgICAgJ1dlIGRvIG5vdCB5ZXQgc3VwcG9ydCB5b3VyIGRldmljZS4gUGxlYXNlIHRyeSBvbiBhIGRlc2t0b3AgJyArXG4gICAgICAnY29tcHV0ZXIgd2l0aCBDaHJvbWUvRmlyZWZveCwgb3IgYW4gQW5kcm9pZCBwaG9uZSB3aXRoIFdlYkdMIHN1cHBvcnQuJztcbn0gZWxzZSB7XG4gIHN0YXJ0KCk7XG59XG5cbmNvbnN0IG1hdGggPSBuZXcgTkRBcnJheU1hdGhHUFUoKTtcblxuZnVuY3Rpb24gc3RhcnQoKSB7XG4gIHBpYW5vLmxvYWQoU0FMQU1BTkRFUl9VUkwpXG4gICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IG5ldyBDaGVja3BvaW50TG9hZGVyKENIRUNLUE9JTlRfVVJMKTtcbiAgICAgICAgcmV0dXJuIHJlYWRlci5nZXRBbGxWYXJpYWJsZXMoKTtcbiAgICAgIH0pXG4gICAgICAudGhlbigodmFyczoge1t2YXJOYW1lOiBzdHJpbmddOiBOREFycmF5fSkgPT4ge1xuICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjc3RhdHVzJykuY2xhc3NMaXN0LmFkZCgnaGlkZGVuJyk7XG4gICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNjb250cm9scycpLmNsYXNzTGlzdC5yZW1vdmUoJ2hpZGRlbicpO1xuICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcja2V5Ym9hcmQnKS5jbGFzc0xpc3QucmVtb3ZlKCdoaWRkZW4nKTtcblxuICAgICAgICBsc3RtS2VybmVsMSA9XG4gICAgICAgICAgICB2YXJzWydybm4vbXVsdGlfcm5uX2NlbGwvY2VsbF8wL2Jhc2ljX2xzdG1fY2VsbC9rZXJuZWwnXSBhcyBBcnJheTJEO1xuICAgICAgICBsc3RtQmlhczEgPVxuICAgICAgICAgICAgdmFyc1sncm5uL211bHRpX3Jubl9jZWxsL2NlbGxfMC9iYXNpY19sc3RtX2NlbGwvYmlhcyddIGFzIEFycmF5MUQ7XG5cbiAgICAgICAgbHN0bUtlcm5lbDIgPVxuICAgICAgICAgICAgdmFyc1sncm5uL211bHRpX3Jubl9jZWxsL2NlbGxfMS9iYXNpY19sc3RtX2NlbGwva2VybmVsJ10gYXMgQXJyYXkyRDtcbiAgICAgICAgbHN0bUJpYXMyID1cbiAgICAgICAgICAgIHZhcnNbJ3Jubi9tdWx0aV9ybm5fY2VsbC9jZWxsXzEvYmFzaWNfbHN0bV9jZWxsL2JpYXMnXSBhcyBBcnJheTFEO1xuXG4gICAgICAgIGxzdG1LZXJuZWwzID1cbiAgICAgICAgICAgIHZhcnNbJ3Jubi9tdWx0aV9ybm5fY2VsbC9jZWxsXzIvYmFzaWNfbHN0bV9jZWxsL2tlcm5lbCddIGFzIEFycmF5MkQ7XG4gICAgICAgIGxzdG1CaWFzMyA9XG4gICAgICAgICAgICB2YXJzWydybm4vbXVsdGlfcm5uX2NlbGwvY2VsbF8yL2Jhc2ljX2xzdG1fY2VsbC9iaWFzJ10gYXMgQXJyYXkxRDtcblxuICAgICAgICBmdWxseUNvbm5lY3RlZEJpYXNlcyA9IHZhcnNbJ2Z1bGx5X2Nvbm5lY3RlZC9iaWFzZXMnXSBhcyBBcnJheTFEO1xuICAgICAgICBmdWxseUNvbm5lY3RlZFdlaWdodHMgPSB2YXJzWydmdWxseV9jb25uZWN0ZWQvd2VpZ2h0cyddIGFzIEFycmF5MkQ7XG4gICAgICAgIHJlc2V0Um5uKCk7XG4gICAgICB9KTtcbn1cblxuZnVuY3Rpb24gcmVzZXRSbm4oKSB7XG4gIGMgPSBbXG4gICAgQXJyYXkyRC56ZXJvcyhbMSwgbHN0bUJpYXMxLnNoYXBlWzBdIC8gNF0pLFxuICAgIEFycmF5MkQuemVyb3MoWzEsIGxzdG1CaWFzMi5zaGFwZVswXSAvIDRdKSxcbiAgICBBcnJheTJELnplcm9zKFsxLCBsc3RtQmlhczMuc2hhcGVbMF0gLyA0XSksXG4gIF07XG4gIGggPSBbXG4gICAgQXJyYXkyRC56ZXJvcyhbMSwgbHN0bUJpYXMxLnNoYXBlWzBdIC8gNF0pLFxuICAgIEFycmF5MkQuemVyb3MoWzEsIGxzdG1CaWFzMi5zaGFwZVswXSAvIDRdKSxcbiAgICBBcnJheTJELnplcm9zKFsxLCBsc3RtQmlhczMuc2hhcGVbMF0gLyA0XSksXG4gIF07XG4gIGlmIChsYXN0U2FtcGxlICE9IG51bGwpIHtcbiAgICBsYXN0U2FtcGxlLmRpc3Bvc2UoKTtcbiAgfVxuICBsYXN0U2FtcGxlID0gU2NhbGFyLm5ldyhQUklNRVJfSURYKTtcbiAgY3VycmVudFBpYW5vVGltZVNlYyA9IHBpYW5vLm5vdygpO1xuICBwaWFub1N0YXJ0VGltZXN0YW1wTXMgPSBwZXJmb3JtYW5jZS5ub3coKSAtIGN1cnJlbnRQaWFub1RpbWVTZWMgKiAxMDAwO1xuICBjdXJyZW50TG9vcElkKys7XG4gIGdlbmVyYXRlU3RlcChjdXJyZW50TG9vcElkKTtcbn1cblxud2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHJlc2l6ZSk7XG5cbmZ1bmN0aW9uIHJlc2l6ZSgpIHtcbiAga2V5Ym9hcmRJbnRlcmZhY2UucmVzaXplKCk7XG59XG5cbnJlc2l6ZSgpO1xuXG5jb25zdCBkZW5zaXR5Q29udHJvbCA9XG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ25vdGUtZGVuc2l0eScpIGFzIEhUTUxJbnB1dEVsZW1lbnQ7XG5jb25zdCBkZW5zaXR5RGlzcGxheSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdub3RlLWRlbnNpdHktZGlzcGxheScpO1xuY29uc3QgY29uZGl0aW9uaW5nT2ZmRWxlbSA9XG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NvbmRpdGlvbmluZy1vZmYnKSBhcyBIVE1MSW5wdXRFbGVtZW50O1xuY29uZGl0aW9uaW5nT2ZmRWxlbS5vbmNoYW5nZSA9IHVwZGF0ZUNvbmRpdGlvbmluZ1BhcmFtcztcbmNvbnN0IGNvbmRpdGlvbmluZ09uRWxlbSA9XG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NvbmRpdGlvbmluZy1vbicpIGFzIEhUTUxJbnB1dEVsZW1lbnQ7XG5jb25kaXRpb25pbmdPbkVsZW0ub25jaGFuZ2UgPSB1cGRhdGVDb25kaXRpb25pbmdQYXJhbXM7XG5jb25zdCBjb25kaXRpb25pbmdDb250cm9sc0VsZW0gPVxuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjb25kaXRpb25pbmctY29udHJvbHMnKSBhcyBIVE1MRGl2RWxlbWVudDtcblxuY29uc3QgZ2FpblNsaWRlckVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZ2FpbicpIGFzIEhUTUxJbnB1dEVsZW1lbnQ7XG5jb25zdCBnYWluRGlzcGxheUVsZW1lbnQgPVxuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdnYWluLWRpc3BsYXknKSBhcyBIVE1MU3BhbkVsZW1lbnQ7XG5sZXQgZ2xvYmFsR2FpbiA9ICtnYWluU2xpZGVyRWxlbWVudC52YWx1ZTtcbmdhaW5EaXNwbGF5RWxlbWVudC5pbm5lclRleHQgPSBnbG9iYWxHYWluLnRvU3RyaW5nKCk7XG5nYWluU2xpZGVyRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdpbnB1dCcsICgpID0+IHtcbiAgZ2xvYmFsR2FpbiA9ICtnYWluU2xpZGVyRWxlbWVudC52YWx1ZTtcbiAgZ2FpbkRpc3BsYXlFbGVtZW50LmlubmVyVGV4dCA9IGdsb2JhbEdhaW4udG9TdHJpbmcoKTtcbn0pO1xuXG5jb25zdCBwaXRjaEhpc3RvZ3JhbUVsZW1lbnRzID0gW1xuICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncGl0Y2gtYycpLFxuICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncGl0Y2gtY3MnKSxcbiAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3BpdGNoLWQnKSxcbiAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3BpdGNoLWRzJyksXG4gIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdwaXRjaC1lJyksXG4gIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdwaXRjaC1mJyksXG4gIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdwaXRjaC1mcycpLFxuICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncGl0Y2gtZycpLFxuICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncGl0Y2gtZ3MnKSxcbiAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3BpdGNoLWEnKSxcbiAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3BpdGNoLWFzJyksXG4gIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdwaXRjaC1iJyksXG5dIGFzIEhUTUxJbnB1dEVsZW1lbnRbXTtcblxubGV0IHByZXNldDEgPSBbMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMV07XG5sZXQgcHJlc2V0MiA9IFsxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxXTtcblxudHJ5IHtcbiAgcGFyc2VIYXNoKCk7XG59IGNhdGNoIChlKSB7XG4gIC8vIElmIHdlIGRpZG4ndCBzdWNjZXNzZnVsbHkgcGFyc2UgdGhlIGhhc2gsIHdlIGNhbiBqdXN0IHVzZSBkZWZhdWx0cy5cbiAgY29uc29sZS53YXJuKGUpO1xufVxuXG5mdW5jdGlvbiBwYXJzZUhhc2goKSB7XG4gIGlmICghd2luZG93LmxvY2F0aW9uLmhhc2gpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgcGFyYW1zID0gd2luZG93LmxvY2F0aW9uLmhhc2guc3Vic3RyKDEpLnNwbGl0KCd8Jyk7XG4gIGRlbnNpdHlDb250cm9sLnZhbHVlID0gcGFyYW1zWzBdO1xuICBjb25zdCBwaXRjaGVzID0gcGFyYW1zWzFdLnNwbGl0KCcsJyk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcGl0Y2hIaXN0b2dyYW1FbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHBpdGNoSGlzdG9ncmFtRWxlbWVudHNbaV0udmFsdWUgPSBwaXRjaGVzW2ldO1xuICB9XG4gIGNvbnN0IHByZXNldDFWYWx1ZXMgPSBwYXJhbXNbMl0uc3BsaXQoJywnKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcmVzZXQxLmxlbmd0aDsgaSsrKSB7XG4gICAgcHJlc2V0MVtpXSA9IHBhcnNlSW50KHByZXNldDFWYWx1ZXNbaV0sIDEwKTtcbiAgfVxuICBjb25zdCBwcmVzZXQyVmFsdWVzID0gcGFyYW1zWzNdLnNwbGl0KCcsJyk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcHJlc2V0Mi5sZW5ndGg7IGkrKykge1xuICAgIHByZXNldDJbaV0gPSBwYXJzZUludChwcmVzZXQyVmFsdWVzW2ldLCAxMCk7XG4gIH1cbiAgaWYgKCEhcGFyc2VJbnQocGFyYW1zWzRdLCAxMCkpIHtcbiAgICBjb25kaXRpb25pbmdPZmZFbGVtLmNoZWNrZWQgPSB0cnVlO1xuICB9IGVsc2Uge1xuICAgIGNvbmRpdGlvbmluZ09uRWxlbS5jaGVja2VkID0gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiB1cGRhdGVDb25kaXRpb25pbmdQYXJhbXMoKSB7XG4gIGNvbnN0IHBpdGNoSGlzdG9ncmFtID0gcGl0Y2hIaXN0b2dyYW1FbGVtZW50cy5tYXAoKGUpID0+IHtcbiAgICByZXR1cm4gcGFyc2VJbnQoZS52YWx1ZSwgMTApIHx8IDA7XG4gIH0pO1xuXG4gIGlmIChub3RlRGVuc2l0eUVuY29kaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICBub3RlRGVuc2l0eUVuY29kaW5nLmRpc3Bvc2UoKTtcbiAgICBub3RlRGVuc2l0eUVuY29kaW5nID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgaWYgKGNvbmRpdGlvbmluZ09mZkVsZW0uY2hlY2tlZCkge1xuICAgIGNvbmRpdGlvbmluZ09mZiA9IHRydWU7XG4gICAgY29uZGl0aW9uaW5nQ29udHJvbHNFbGVtLmNsYXNzTGlzdC5hZGQoJ2luYWN0aXZlJyk7XG4gIH0gZWxzZSB7XG4gICAgY29uZGl0aW9uaW5nT2ZmID0gZmFsc2U7XG4gICAgY29uZGl0aW9uaW5nQ29udHJvbHNFbGVtLmNsYXNzTGlzdC5yZW1vdmUoJ2luYWN0aXZlJyk7XG4gIH1cblxuICB3aW5kb3cubG9jYXRpb24uYXNzaWduKFxuICAgICAgJyMnICsgZGVuc2l0eUNvbnRyb2wudmFsdWUgKyAnfCcgKyBwaXRjaEhpc3RvZ3JhbS5qb2luKCcsJykgKyAnfCcgK1xuICAgICAgcHJlc2V0MS5qb2luKCcsJykgKyAnfCcgKyBwcmVzZXQyLmpvaW4oJywnKSArICd8JyArXG4gICAgICAoY29uZGl0aW9uaW5nT2ZmID8gJzEnIDogJzAnKSk7XG5cbiAgY29uc3Qgbm90ZURlbnNpdHlJZHggPSBwYXJzZUludChkZW5zaXR5Q29udHJvbC52YWx1ZSwgMTApIHx8IDA7XG4gIGNvbnN0IG5vdGVEZW5zaXR5ID0gREVOU0lUWV9CSU5fUkFOR0VTW25vdGVEZW5zaXR5SWR4XTtcbiAgZGVuc2l0eURpc3BsYXkuaW5uZXJIVE1MID0gbm90ZURlbnNpdHkudG9TdHJpbmcoKTtcbiAgbm90ZURlbnNpdHlFbmNvZGluZyA9IEFycmF5MUQuemVyb3MoW0RFTlNJVFlfQklOX1JBTkdFUy5sZW5ndGggKyAxXSk7XG4gIG5vdGVEZW5zaXR5RW5jb2Rpbmcuc2V0KDEuMCwgbm90ZURlbnNpdHlJZHggKyAxKTtcblxuICBpZiAocGl0Y2hIaXN0b2dyYW1FbmNvZGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcGl0Y2hIaXN0b2dyYW1FbmNvZGluZy5kaXNwb3NlKCk7XG4gICAgcGl0Y2hIaXN0b2dyYW1FbmNvZGluZyA9IHVuZGVmaW5lZDtcbiAgfVxuICBwaXRjaEhpc3RvZ3JhbUVuY29kaW5nID0gQXJyYXkxRC56ZXJvcyhbUElUQ0hfSElTVE9HUkFNX1NJWkVdKTtcbiAgY29uc3QgcGl0Y2hIaXN0b2dyYW1Ub3RhbCA9IHBpdGNoSGlzdG9ncmFtLnJlZHVjZSgocHJldiwgdmFsKSA9PiB7XG4gICAgcmV0dXJuIHByZXYgKyB2YWw7XG4gIH0pO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IFBJVENIX0hJU1RPR1JBTV9TSVpFOyBpKyspIHtcbiAgICBwaXRjaEhpc3RvZ3JhbUVuY29kaW5nLnNldChwaXRjaEhpc3RvZ3JhbVtpXSAvIHBpdGNoSGlzdG9ncmFtVG90YWwsIGkpO1xuICB9XG59XG5cbmRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdub3RlLWRlbnNpdHknKS5vbmlucHV0ID0gdXBkYXRlQ29uZGl0aW9uaW5nUGFyYW1zO1xucGl0Y2hIaXN0b2dyYW1FbGVtZW50cy5tYXAoKGUpID0+IHtcbiAgZS5vbmlucHV0ID0gdXBkYXRlQ29uZGl0aW9uaW5nUGFyYW1zO1xufSk7XG51cGRhdGVDb25kaXRpb25pbmdQYXJhbXMoKTtcblxuZnVuY3Rpb24gdXBkYXRlUGl0Y2hIaXN0b2dyYW0obmV3SGlzdDogbnVtYmVyW10pIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBuZXdIaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgcGl0Y2hIaXN0b2dyYW1FbGVtZW50c1tpXS52YWx1ZSA9IG5ld0hpc3RbaV0udG9TdHJpbmcoKTtcbiAgfVxuICB1cGRhdGVDb25kaXRpb25pbmdQYXJhbXMoKTtcbn1cblxuZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2MtbWFqb3InKS5vbmNsaWNrID0gKCkgPT4ge1xuICB1cGRhdGVQaXRjaEhpc3RvZ3JhbShbMiwgMCwgMSwgMCwgMSwgMSwgMCwgMSwgMCwgMSwgMCwgMV0pO1xufTtcblxuZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2YtbWFqb3InKS5vbmNsaWNrID0gKCkgPT4ge1xuICB1cGRhdGVQaXRjaEhpc3RvZ3JhbShbMSwgMCwgMSwgMCwgMSwgMiwgMCwgMSwgMCwgMSwgMSwgMF0pO1xufTtcblxuZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2QtbWlub3InKS5vbmNsaWNrID0gKCkgPT4ge1xuICB1cGRhdGVQaXRjaEhpc3RvZ3JhbShbMSwgMCwgMiwgMCwgMSwgMSwgMCwgMSwgMCwgMSwgMSwgMF0pO1xufTtcblxuZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3dob2xlLXRvbmUnKS5vbmNsaWNrID0gKCkgPT4ge1xuICB1cGRhdGVQaXRjaEhpc3RvZ3JhbShbMSwgMCwgMSwgMCwgMSwgMCwgMSwgMCwgMSwgMCwgMSwgMF0pO1xufTtcblxuZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3BlbnRhdG9uaWMnKS5vbmNsaWNrID0gKCkgPT4ge1xuICB1cGRhdGVQaXRjaEhpc3RvZ3JhbShbMCwgMSwgMCwgMSwgMCwgMCwgMSwgMCwgMSwgMCwgMSwgMF0pO1xufTtcblxuZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3Jlc2V0LXJubicpLm9uY2xpY2sgPSAoKSA9PiB7XG4gIHJlc2V0Um5uKCk7XG59O1xuXG5kb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncHJlc2V0LTEnKS5vbmNsaWNrID0gKCkgPT4ge1xuICB1cGRhdGVQaXRjaEhpc3RvZ3JhbShwcmVzZXQxKTtcbn07XG5cbmRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdwcmVzZXQtMicpLm9uY2xpY2sgPSAoKSA9PiB7XG4gIHVwZGF0ZVBpdGNoSGlzdG9ncmFtKHByZXNldDIpO1xufTtcblxuZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3NhdmUtMScpLm9uY2xpY2sgPSAoKSA9PiB7XG4gIHByZXNldDEgPSBwaXRjaEhpc3RvZ3JhbUVsZW1lbnRzLm1hcCgoZSkgPT4ge1xuICAgIHJldHVybiBwYXJzZUludChlLnZhbHVlLCAxMCkgfHwgMDtcbiAgfSk7XG4gIHVwZGF0ZUNvbmRpdGlvbmluZ1BhcmFtcygpO1xufTtcblxuZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3NhdmUtMicpLm9uY2xpY2sgPSAoKSA9PiB7XG4gIHByZXNldDIgPSBwaXRjaEhpc3RvZ3JhbUVsZW1lbnRzLm1hcCgoZSkgPT4ge1xuICAgIHJldHVybiBwYXJzZUludChlLnZhbHVlLCAxMCkgfHwgMDtcbiAgfSk7XG4gIHVwZGF0ZUNvbmRpdGlvbmluZ1BhcmFtcygpO1xufTtcblxuLy9mdW5jdGlvbiBnZXRDb25kaXRpb25pbmcobWF0aDogTkRBcnJheU1hdGgpOiBBcnJheTFEIHtcbi8vICByZXR1cm4gbWF0aC5zY29wZSgoa2VlcCwgdHJhY2spID0+IHtcbi8vICAgIGlmIChjb25kaXRpb25pbmdPZmYpIHtcbi8vICAgICAgLy8gVE9ETyhuc3Rob3JhdCk6IGZpZ3VyZSBvdXQgd2h5IHdlIGhhdmUgdG8gY2FzdCB0aGVzZSBzaGFwZXMgdG8gbnVtYmVycy5cbi8vICAgICAgLy8gVGhlIGxpbnRlciBpcyBjb21wbGFpbmluZywgdGhvdWdoIFZTQ29kZSBjYW4gaW5mZXIgdGhlIHR5cGVzLlxuLy8gICAgICBjb25zdCBzaXplID0gMSArIChub3RlRGVuc2l0eUVuY29kaW5nLnNoYXBlWzBdIGFzIG51bWJlcikgK1xuLy8gICAgICAgICAgKHBpdGNoSGlzdG9ncmFtRW5jb2Rpbmcuc2hhcGVbMF0gYXMgbnVtYmVyKTtcbi8vICAgICAgY29uc3QgY29uZGl0aW9uaW5nID0gdHJhY2soQXJyYXkxRC56ZXJvcyhbc2l6ZV0pKTtcbi8vICAgICAgY29uZGl0aW9uaW5nLnNldCgxLjAsIDApO1xuLy8gICAgICByZXR1cm4gY29uZGl0aW9uaW5nO1xuLy8gICAgfSBlbHNlIHtcbi8vICAgICAgY29uc3QgY29uZGl0aW9uaW5nVmFsdWVzID1cbi8vICAgICAgICAgIG1hdGguY29uY2F0MUQobm90ZURlbnNpdHlFbmNvZGluZywgcGl0Y2hIaXN0b2dyYW1FbmNvZGluZyk7XG4vLyAgICAgIHJldHVybiBtYXRoLmNvbmNhdDFEKFxuLy8gICAgICAgICAgdHJhY2soU2NhbGFyLm5ldygwLjApLmFzMUQoKSksICAvLyBjb25kaXRpb25pbmcgb24uXG4vLyAgICAgICAgICBjb25kaXRpb25pbmdWYWx1ZXMpO1xuLy8gICAgfVxuLy8gIH0pO1xuLy99XG5cbmFzeW5jIGZ1bmN0aW9uIGdlbmVyYXRlU3RlcChsb29wSWQ6IG51bWJlcikge1xuICBpZiAobG9vcElkIDwgY3VycmVudExvb3BJZCkge1xuICAgIC8vIFdhcyBwYXJ0IG9mIGFuIG91dGRhdGVkIGdlbmVyYXRlU3RlcCgpIHNjaGVkdWxlZCB2aWEgc2V0VGltZW91dC5cbiAgICByZXR1cm47XG4gIH1cbiAgYXdhaXQgbWF0aC5zY29wZShhc3luYyAoa2VlcCwgdHJhY2spID0+IHtcbiAgICBjb25zdCBsc3RtMSA9XG4gICAgICAgIG1hdGguYmFzaWNMU1RNQ2VsbC5iaW5kKG1hdGgsIGZvcmdldEJpYXMsIGxzdG1LZXJuZWwxLCBsc3RtQmlhczEpO1xuICAgIGNvbnN0IGxzdG0yID1cbiAgICAgICAgbWF0aC5iYXNpY0xTVE1DZWxsLmJpbmQobWF0aCwgZm9yZ2V0QmlhcywgbHN0bUtlcm5lbDIsIGxzdG1CaWFzMik7XG4gICAgY29uc3QgbHN0bTMgPVxuICAgICAgICBtYXRoLmJhc2ljTFNUTUNlbGwuYmluZChtYXRoLCBmb3JnZXRCaWFzLCBsc3RtS2VybmVsMywgbHN0bUJpYXMzKTtcblxuICAgIGMubWFwKHZhbCA9PiB7XG4gICAgICB0cmFjayh2YWwpO1xuICAgIH0pO1xuICAgIGgubWFwKHZhbCA9PiB7XG4gICAgICB0cmFjayh2YWwpO1xuICAgIH0pO1xuICAgIGNvbnN0IG91dHB1dHM6IFNjYWxhcltdID0gW107XG4gICAgLy8gR2VuZXJhdGUgc29tZSBub3Rlcy5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IFNURVBTX1BFUl9HRU5FUkFURV9DQUxMOyBpKyspIHtcbiAgICAgIC8vIFVzZSBsYXN0IHNhbXBsZWQgb3V0cHV0IGFzIHRoZSBuZXh0IGlucHV0LlxuICAgICAgY29uc3QgZXZlbnRJbnB1dCA9IG1hdGgub25lSG90KGxhc3RTYW1wbGUuYXMxRCgpLCBFVkVOVF9TSVpFKS5hczFEKCk7XG4gICAgICAvLyBEaXNwb3NlIHRoZSBsYXN0IHNhbXBsZSBmcm9tIHRoZSBwcmV2aW91cyBnZW5lcmF0ZSBjYWxsLCBzaW5jZSB3ZVxuICAgICAgLy8ga2VwdCBpdC5cbiAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgIGxhc3RTYW1wbGUuZGlzcG9zZSgpO1xuICAgICAgfVxuICAgICAgLy9jb25zdCBjb25kaXRpb25pbmcgPSBnZXRDb25kaXRpb25pbmcobWF0aCk7XG4gICAgICBjb25zdCBpbnB1dCA9IGV2ZW50SW5wdXQ7IC8vbWF0aC5jb25jYXQxRChjb25kaXRpb25pbmcsIGV2ZW50SW5wdXQpO1xuICAgICAgY29uc3Qgb3V0cHV0ID1cbiAgICAgICAgICBtYXRoLm11bHRpUk5OQ2VsbChbbHN0bTEsIGxzdG0yLCBsc3RtM10sIGlucHV0LmFzMkQoMSwgLTEpLCBjLCBoKTtcbiAgICAgIGMgPSBvdXRwdXRbMF07XG4gICAgICBoID0gb3V0cHV0WzFdO1xuXG4gICAgICBjb25zdCBvdXRwdXRIID0gaFsyXTtcbiAgICAgIGNvbnN0IHdlaWdodGVkUmVzdWx0ID0gbWF0aC5tYXRNdWwob3V0cHV0SCwgZnVsbHlDb25uZWN0ZWRXZWlnaHRzKTtcbiAgICAgIGNvbnN0IGxvZ2l0cyA9IG1hdGguYWRkKHdlaWdodGVkUmVzdWx0LCBmdWxseUNvbm5lY3RlZEJpYXNlcyk7XG5cbiAgICAgIGNvbnN0IHNvZnRtYXggPSBtYXRoLnNvZnRtYXgobG9naXRzLmFzMUQoKSk7XG4gICAgICBjb25zdCBzYW1wbGVkT3V0cHV0ID0gbWF0aC5tdWx0aW5vbWlhbChzb2Z0bWF4LCAxKS5hc1NjYWxhcigpO1xuICAgICAgb3V0cHV0cy5wdXNoKHNhbXBsZWRPdXRwdXQpO1xuICAgICAga2VlcChzYW1wbGVkT3V0cHV0KTtcbiAgICAgIGxhc3RTYW1wbGUgPSBzYW1wbGVkT3V0cHV0O1xuICAgIH1cblxuICAgIGMubWFwKHZhbCA9PiB7XG4gICAgICBrZWVwKHZhbCk7XG4gICAgfSk7XG4gICAgaC5tYXAodmFsID0+IHtcbiAgICAgIGtlZXAodmFsKTtcbiAgICB9KTtcblxuICAgIGF3YWl0IG91dHB1dHNbb3V0cHV0cy5sZW5ndGggLSAxXS5kYXRhKCk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dHB1dHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHBsYXlPdXRwdXQoYXdhaXQgb3V0cHV0c1tpXS52YWwoKSk7XG4gICAgfVxuXG4gICAgLy8gUHJvLWFjdGl2ZWx5IHVwbG9hZCB0aGUgbGFzdCBzYW1wbGUgdG8gdGhlIGdwdSBhZ2FpbiBhbmQga2VlcCBpdFxuICAgIC8vIGZvciBuZXh0IHRpbWUuXG4gICAgbGFzdFNhbXBsZS5nZXRUZXh0dXJlKCk7XG5cbiAgICBpZiAocGlhbm8ubm93KCkgLSBjdXJyZW50UGlhbm9UaW1lU2VjID4gTUFYX0dFTkVSQVRJT05fTEFHX1NFQ09ORFMpIHtcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICBgR2VuZXJhdGlvbiBpcyAke1xuICAgICAgICAgICAgICBwaWFuby5ub3coKSAtIGN1cnJlbnRQaWFub1RpbWVTZWN9IHNlY29uZHMgYmVoaW5kLCBgICtcbiAgICAgICAgICBgd2hpY2ggaXMgb3ZlciAke01BWF9OT1RFX0RVUkFUSU9OX1NFQ09ORFN9LiBSZXNldHRpbmcgdGltZSFgKTtcbiAgICAgIGN1cnJlbnRQaWFub1RpbWVTZWMgPSBwaWFuby5ub3coKTtcbiAgICB9XG4gICAgY29uc3QgZGVsdGEgPSBNYXRoLm1heChcbiAgICAgICAgMCwgY3VycmVudFBpYW5vVGltZVNlYyAtIHBpYW5vLm5vdygpIC0gR0VORVJBVElPTl9CVUZGRVJfU0VDT05EUyk7XG4gICAgc2V0VGltZW91dCgoKSA9PiBnZW5lcmF0ZVN0ZXAobG9vcElkKSwgZGVsdGEgKiAxMDAwKTtcbiAgfSk7XG59XG5cbmxldCBtaWRpO1xuLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWFueVxubGV0IG91dHB1dERldmljZTogYW55ID0gbnVsbDtcbihhc3luYyAoKSA9PiB7XG4gIGNvbnN0IG1pZGlPdXREcm9wZG93bkNvbnRhaW5lciA9XG4gICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbWlkaS1vdXQtY29udGFpbmVyJyk7XG4gIHRyeSB7XG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWFueVxuICAgIGNvbnN0IG5hdmlnYXRvcjogYW55ID0gd2luZG93Lm5hdmlnYXRvcjtcbiAgICBtaWRpID0gYXdhaXQgbmF2aWdhdG9yLnJlcXVlc3RNSURJQWNjZXNzKCk7XG5cbiAgICBjb25zdCBtaWRpT3V0RHJvcGRvd24gPVxuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbWlkaS1vdXQnKSBhcyBIVE1MU2VsZWN0RWxlbWVudDtcblxuICAgIGxldCBjb3VudCA9IDA7XG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWFueVxuICAgIGNvbnN0IG1pZGlEZXZpY2VzOiBhbnlbXSA9IFtdO1xuICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1hbnlcbiAgICBtaWRpLm91dHB1dHMuZm9yRWFjaCgob3V0cHV0OiBhbnkpID0+IHtcbiAgICAgIGNvbnNvbGUubG9nKGBcbiAgICAgICAgICBPdXRwdXQgbWlkaSBkZXZpY2UgW3R5cGU6ICcke291dHB1dC50eXBlfSddXG4gICAgICAgICAgaWQ6ICR7b3V0cHV0LmlkfVxuICAgICAgICAgIG1hbnVmYWN0dXJlcjogJHtvdXRwdXQubWFudWZhY3R1cmVyfVxuICAgICAgICAgIG5hbWU6JHtvdXRwdXQubmFtZX1cbiAgICAgICAgICB2ZXJzaW9uOiAke291dHB1dC52ZXJzaW9ufWApO1xuICAgICAgbWlkaURldmljZXMucHVzaChvdXRwdXQpO1xuXG4gICAgICBjb25zdCBvcHRpb24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdvcHRpb24nKTtcbiAgICAgIG9wdGlvbi5pbm5lclRleHQgPSBvdXRwdXQubmFtZTtcbiAgICAgIG1pZGlPdXREcm9wZG93bi5hcHBlbmRDaGlsZChvcHRpb24pO1xuICAgICAgY291bnQrKztcbiAgICB9KTtcblxuICAgIG1pZGlPdXREcm9wZG93bi5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCAoKSA9PiB7XG4gICAgICBvdXRwdXREZXZpY2UgPSBtaWRpRGV2aWNlc1ttaWRpT3V0RHJvcGRvd24uc2VsZWN0ZWRJbmRleF07XG4gICAgfSk7XG5cbiAgICBpZiAoY291bnQgPiAwKSB7XG4gICAgICBvdXRwdXREZXZpY2UgPSBtaWRpRGV2aWNlc1swXTtcbiAgICB9IGVsc2Uge1xuICAgICAgbWlkaU91dERyb3Bkb3duQ29udGFpbmVyLmlubmVyVGV4dCA9IE1JRElfTk9fT1VUUFVUX0RFVklDRVNfRk9VTkRfTUVTU0FHRTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBtaWRpT3V0RHJvcGRvd25Db250YWluZXIuaW5uZXJUZXh0ID0gTUlESV9OT19PVVRQVVRfREVWSUNFU19GT1VORF9NRVNTQUdFO1xuXG4gICAgbWlkaSA9IG51bGw7XG4gIH1cbn0pKCk7XG5cbi8qKlxuICogRGVjb2RlIHRoZSBvdXRwdXQgaW5kZXggYW5kIHBsYXkgaXQgb24gdGhlIHBpYW5vIGFuZCBrZXlib2FyZEludGVyZmFjZS5cbiAqL1xuZnVuY3Rpb24gcGxheU91dHB1dChpbmRleDogbnVtYmVyKSB7XG4gIGxldCBvZmZzZXQgPSAwO1xuICBmb3IgKGNvbnN0IGV2ZW50UmFuZ2Ugb2YgRVZFTlRfUkFOR0VTKSB7XG4gICAgY29uc3QgZXZlbnRUeXBlID0gZXZlbnRSYW5nZVswXSBhcyBzdHJpbmc7XG4gICAgY29uc3QgbWluVmFsdWUgPSBldmVudFJhbmdlWzFdIGFzIG51bWJlcjtcbiAgICBjb25zdCBtYXhWYWx1ZSA9IGV2ZW50UmFuZ2VbMl0gYXMgbnVtYmVyO1xuICAgIGlmIChvZmZzZXQgPD0gaW5kZXggJiYgaW5kZXggPD0gb2Zmc2V0ICsgbWF4VmFsdWUgLSBtaW5WYWx1ZSkge1xuICAgICAgaWYgKGV2ZW50VHlwZSA9PT0gJ25vdGVfb24nKSB7XG4gICAgICAgIGNvbnN0IG5vdGVOdW0gPSBpbmRleCAtIG9mZnNldDtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAga2V5Ym9hcmRJbnRlcmZhY2Uua2V5RG93bihub3RlTnVtKTtcbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGtleWJvYXJkSW50ZXJmYWNlLmtleVVwKG5vdGVOdW0pO1xuICAgICAgICAgIH0sIDEwMCk7XG4gICAgICAgIH0sIChjdXJyZW50UGlhbm9UaW1lU2VjIC0gcGlhbm8ubm93KCkpICogMTAwMCk7XG4gICAgICAgIGFjdGl2ZU5vdGVzLnNldChub3RlTnVtLCBjdXJyZW50UGlhbm9UaW1lU2VjKTtcblxuICAgICAgICBpZiAob3V0cHV0RGV2aWNlICE9IG51bGwpIHtcbiAgICAgICAgICBvdXRwdXREZXZpY2Uuc2VuZChcbiAgICAgICAgICAgICAgW01JRElfRVZFTlRfT04sIG5vdGVOdW0sIGN1cnJlbnRWZWxvY2l0eSAqIGdsb2JhbEdhaW5dLFxuICAgICAgICAgICAgICBNYXRoLmZsb29yKDEwMDAgKiBjdXJyZW50UGlhbm9UaW1lU2VjKSAtIHBpYW5vU3RhcnRUaW1lc3RhbXBNcyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcGlhbm8ua2V5RG93bihcbiAgICAgICAgICAgIG5vdGVOdW0sIGN1cnJlbnRQaWFub1RpbWVTZWMsIGN1cnJlbnRWZWxvY2l0eSAqIGdsb2JhbEdhaW4gLyAxMDApO1xuICAgICAgfSBlbHNlIGlmIChldmVudFR5cGUgPT09ICdub3RlX29mZicpIHtcbiAgICAgICAgY29uc3Qgbm90ZU51bSA9IGluZGV4IC0gb2Zmc2V0O1xuXG4gICAgICAgIGNvbnN0IGFjdGl2ZU5vdGVFbmRUaW1lU2VjID0gYWN0aXZlTm90ZXMuZ2V0KG5vdGVOdW0pO1xuICAgICAgICAvLyBJZiB0aGUgbm90ZSBvZmYgZXZlbnQgaXMgZ2VuZXJhdGVkIGZvciBhIG5vdGUgdGhhdCBoYXNuJ3QgYmVlblxuICAgICAgICAvLyBwcmVzc2VkLCBqdXN0IGlnbm9yZSBpdC5cbiAgICAgICAgaWYgKGFjdGl2ZU5vdGVFbmRUaW1lU2VjID09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGltZVNlYyA9XG4gICAgICAgICAgICBNYXRoLm1heChjdXJyZW50UGlhbm9UaW1lU2VjLCBhY3RpdmVOb3RlRW5kVGltZVNlYyArIC41KTtcblxuICAgICAgICBpZiAob3V0cHV0RGV2aWNlICE9IG51bGwpIHtcbiAgICAgICAgICBvdXRwdXREZXZpY2Uuc2VuZChcbiAgICAgICAgICAgICAgW01JRElfRVZFTlRfT0ZGLCBub3RlTnVtLCBjdXJyZW50VmVsb2NpdHkgKiBnbG9iYWxHYWluXSxcbiAgICAgICAgICAgICAgTWF0aC5mbG9vcih0aW1lU2VjICogMTAwMCkgLSBwaWFub1N0YXJ0VGltZXN0YW1wTXMpO1xuICAgICAgICB9XG4gICAgICAgIHBpYW5vLmtleVVwKG5vdGVOdW0sIHRpbWVTZWMpO1xuICAgICAgICBhY3RpdmVOb3Rlcy5kZWxldGUobm90ZU51bSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSBpZiAoZXZlbnRUeXBlID09PSAndGltZV9zaGlmdCcpIHtcbiAgICAgICAgY3VycmVudFBpYW5vVGltZVNlYyArPSAoaW5kZXggLSBvZmZzZXQgKyAxKSAvIFNURVBTX1BFUl9TRUNPTkQ7XG4gICAgICAgIGFjdGl2ZU5vdGVzLmZvckVhY2goKHRpbWVTZWMsIG5vdGVOdW0pID0+IHtcbiAgICAgICAgICBpZiAoY3VycmVudFBpYW5vVGltZVNlYyAtIHRpbWVTZWMgPiBNQVhfTk9URV9EVVJBVElPTl9TRUNPTkRTKSB7XG4gICAgICAgICAgICBjb25zb2xlLmluZm8oXG4gICAgICAgICAgICAgICAgYE5vdGUgJHtub3RlTnVtfSBoYXMgYmVlbiBhY3RpdmUgZm9yICR7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQaWFub1RpbWVTZWMgLSB0aW1lU2VjfSwgYCArXG4gICAgICAgICAgICAgICAgYHNlY29uZHMgd2hpY2ggaXMgb3ZlciAke01BWF9OT1RFX0RVUkFUSU9OX1NFQ09ORFN9LCB3aWxsIGAgK1xuICAgICAgICAgICAgICAgIGByZWxlYXNlLmApO1xuICAgICAgICAgICAgaWYgKG91dHB1dERldmljZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIG91dHB1dERldmljZS5zZW5kKFxuICAgICAgICAgICAgICAgICAgW01JRElfRVZFTlRfT0ZGLCBub3RlTnVtLCBjdXJyZW50VmVsb2NpdHkgKiBnbG9iYWxHYWluXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwaWFuby5rZXlVcChub3RlTnVtLCBjdXJyZW50UGlhbm9UaW1lU2VjKTtcbiAgICAgICAgICAgIGFjdGl2ZU5vdGVzLmRlbGV0ZShub3RlTnVtKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gY3VycmVudFBpYW5vVGltZVNlYztcbiAgICAgIH0gZWxzZSBpZiAoZXZlbnRUeXBlID09PSAndmVsb2NpdHlfY2hhbmdlJykge1xuICAgICAgICBjdXJyZW50VmVsb2NpdHkgPSAoaW5kZXggLSBvZmZzZXQgKyAxKSAqIE1hdGguY2VpbCgxMjcgLyBWRUxPQ0lUWV9CSU5TKTtcbiAgICAgICAgY3VycmVudFZlbG9jaXR5ID0gY3VycmVudFZlbG9jaXR5IC8gMTI3O1xuICAgICAgICByZXR1cm4gY3VycmVudFZlbG9jaXR5O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgZGVjb2RlIGV2ZW50VHlwZTogJyArIGV2ZW50VHlwZSk7XG4gICAgICB9XG4gICAgfVxuICAgIG9mZnNldCArPSBtYXhWYWx1ZSAtIG1pblZhbHVlICsgMTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCBkZWNvZGUgaW5kZXg6ICR7aW5kZXh9YCk7XG59XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5cbmltcG9ydCB7TkRBcnJheU1hdGhHUFV9IGZyb20gJ2RlZXBsZWFybic7XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1dlYkdMU3VwcG9ydGVkKCk6IGJvb2xlYW4ge1xuICB0cnkge1xuICAgIGNvbnN0IG1hdGggPSBuZXcgTkRBcnJheU1hdGhHUFUoKTtcbiAgICBtYXRoLmRpc3Bvc2UoKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNTYWZhcmkoKTogYm9vbGVhbiB7XG4gIGNvbnN0IHVhID0gbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpO1xuICBpZiAodWEuaW5kZXhPZignc2FmYXJpJykgIT09IC0xKSB7XG4gICAgaWYgKHVhLmluZGV4T2YoJ2Nocm9tZScpID4gLTEpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzTW9iaWxlKCk6IGJvb2xlYW4ge1xuICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tYW55XG4gIGNvbnN0IGEgPSBuYXZpZ2F0b3IudXNlckFnZW50IHx8IG5hdmlnYXRvci52ZW5kb3IgfHwgKHdpbmRvdyBhcyBhbnkpLm9wZXJhO1xuICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bWF4LWxpbmUtbGVuZ3RoXG4gIHJldHVybiAvKGFuZHJvaWR8YmJcXGQrfG1lZWdvKS4rbW9iaWxlfGF2YW50Z298YmFkYVxcL3xibGFja2JlcnJ5fGJsYXplcnxjb21wYWx8ZWxhaW5lfGZlbm5lY3xoaXB0b3B8aWVtb2JpbGV8aXAoaG9uZXxvZCl8aXJpc3xraW5kbGV8bGdlIHxtYWVtb3xtaWRwfG1tcHxtb2JpbGUuK2ZpcmVmb3h8bmV0ZnJvbnR8b3BlcmEgbShvYnxpbilpfHBhbG0oIG9zKT98cGhvbmV8cChpeGl8cmUpXFwvfHBsdWNrZXJ8cG9ja2V0fHBzcHxzZXJpZXMoNHw2KTB8c3ltYmlhbnx0cmVvfHVwXFwuKGJyb3dzZXJ8bGluayl8dm9kYWZvbmV8d2FwfHdpbmRvd3MgY2V8eGRhfHhpaW5vL2lcbiAgICAgICAgICAgICAudGVzdChhKSB8fFxuICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm1heC1saW5lLWxlbmd0aFxuICAgICAgLzEyMDd8NjMxMHw2NTkwfDNnc298NHRocHw1MFsxLTZdaXw3NzBzfDgwMnN8YSB3YXxhYmFjfGFjKGVyfG9vfHNcXC0pfGFpKGtvfHJuKXxhbChhdnxjYXxjbyl8YW1vaXxhbihleHxueXx5dyl8YXB0dXxhcihjaHxnbyl8YXModGV8dXMpfGF0dHd8YXUoZGl8XFwtbXxyIHxzICl8YXZhbnxiZShja3xsbHxucSl8YmkobGJ8cmQpfGJsKGFjfGF6KXxicihlfHYpd3xidW1ifGJ3XFwtKG58dSl8YzU1XFwvfGNhcGl8Y2N3YXxjZG1cXC18Y2VsbHxjaHRtfGNsZGN8Y21kXFwtfGNvKG1wfG5kKXxjcmF3fGRhKGl0fGxsfG5nKXxkYnRlfGRjXFwtc3xkZXZpfGRpY2F8ZG1vYnxkbyhjfHApb3xkcygxMnxcXC1kKXxlbCg0OXxhaSl8ZW0obDJ8dWwpfGVyKGljfGswKXxlc2w4fGV6KFs0LTddMHxvc3x3YXx6ZSl8ZmV0Y3xmbHkoXFwtfF8pfGcxIHV8ZzU2MHxnZW5lfGdmXFwtNXxnXFwtbW98Z28oXFwud3xvZCl8Z3IoYWR8dW4pfGhhaWV8aGNpdHxoZFxcLShtfHB8dCl8aGVpXFwtfGhpKHB0fHRhKXxocCggaXxpcCl8aHNcXC1jfGh0KGMoXFwtfCB8X3xhfGd8cHxzfHQpfHRwKXxodShhd3x0Yyl8aVxcLSgyMHxnb3xtYSl8aTIzMHxpYWMoIHxcXC18XFwvKXxpYnJvfGlkZWF8aWcwMXxpa29tfGltMWt8aW5ub3xpcGFxfGlyaXN8amEodHx2KWF8amJyb3xqZW11fGppZ3N8a2RkaXxrZWppfGtndCggfFxcLyl8a2xvbnxrcHQgfGt3Y1xcLXxreW8oY3xrKXxsZShub3x4aSl8bGcoIGd8XFwvKGt8bHx1KXw1MHw1NHxcXC1bYS13XSl8bGlid3xseW54fG0xXFwtd3xtM2dhfG01MFxcL3xtYSh0ZXx1aXx4byl8bWMoMDF8MjF8Y2EpfG1cXC1jcnxtZShyY3xyaSl8bWkobzh8b2F8dHMpfG1tZWZ8bW8oMDF8MDJ8Yml8ZGV8ZG98dChcXC18IHxvfHYpfHp6KXxtdCg1MHxwMXx2ICl8bXdicHxteXdhfG4xMFswLTJdfG4yMFsyLTNdfG4zMCgwfDIpfG41MCgwfDJ8NSl8bjcoMCgwfDEpfDEwKXxuZSgoY3xtKVxcLXxvbnx0Znx3Znx3Z3x3dCl8bm9rKDZ8aSl8bnpwaHxvMmltfG9wKHRpfHd2KXxvcmFufG93ZzF8cDgwMHxwYW4oYXxkfHQpfHBkeGd8cGcoMTN8XFwtKFsxLThdfGMpKXxwaGlsfHBpcmV8cGwoYXl8dWMpfHBuXFwtMnxwbyhja3xydHxzZSl8cHJveHxwc2lvfHB0XFwtZ3xxYVxcLWF8cWMoMDd8MTJ8MjF8MzJ8NjB8XFwtWzItN118aVxcLSl8cXRla3xyMzgwfHI2MDB8cmFrc3xyaW05fHJvKHZlfHpvKXxzNTVcXC98c2EoZ2V8bWF8bW18bXN8bnl8dmEpfHNjKDAxfGhcXC18b298cFxcLSl8c2RrXFwvfHNlKGMoXFwtfDB8MSl8NDd8bWN8bmR8cmkpfHNnaFxcLXxzaGFyfHNpZShcXC18bSl8c2tcXC0wfHNsKDQ1fGlkKXxzbShhbHxhcnxiM3xpdHx0NSl8c28oZnR8bnkpfHNwKDAxfGhcXC18dlxcLXx2ICl8c3koMDF8bWIpfHQyKDE4fDUwKXx0NigwMHwxMHwxOCl8dGEoZ3R8bGspfHRjbFxcLXx0ZGdcXC18dGVsKGl8bSl8dGltXFwtfHRcXC1tb3x0byhwbHxzaCl8dHMoNzB8bVxcLXxtM3xtNSl8dHhcXC05fHVwKFxcLmJ8ZzF8c2kpfHV0c3R8djQwMHx2NzUwfHZlcml8dmkocmd8dGUpfHZrKDQwfDVbMC0zXXxcXC12KXx2bTQwfHZvZGF8dnVsY3x2eCg1Mnw1M3w2MHw2MXw3MHw4MHw4MXw4M3w4NXw5OCl8dzNjKFxcLXwgKXx3ZWJjfHdoaXR8d2koZyB8bmN8bncpfHdtbGJ8d29udXx4NzAwfHlhc1xcLXx5b3VyfHpldG98enRlXFwtL2lcbiAgICAgICAgICAudGVzdChhLnN1YnN0cigwLCA0KSk7XG59XG4iXX0=
